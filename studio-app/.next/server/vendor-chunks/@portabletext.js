"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@portabletext";
exports.ids = ["vendor-chunks/@portabletext"];
exports.modules = {

/***/ "(ssr)/../node_modules/@portabletext/block-tools/lib/_chunks-es/helpers.js":
/*!***************************************************************************!*\
  !*** ../node_modules/@portabletext/block-tools/lib/_chunks-es/helpers.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BLOCK_DEFAULT_STYLE: () => (/* binding */ BLOCK_DEFAULT_STYLE),\n/* harmony export */   DEFAULT_BLOCK: () => (/* binding */ DEFAULT_BLOCK),\n/* harmony export */   DEFAULT_SPAN: () => (/* binding */ DEFAULT_SPAN),\n/* harmony export */   HTML_BLOCK_TAGS: () => (/* binding */ HTML_BLOCK_TAGS),\n/* harmony export */   HTML_DECORATOR_TAGS: () => (/* binding */ HTML_DECORATOR_TAGS),\n/* harmony export */   HTML_HEADER_TAGS: () => (/* binding */ HTML_HEADER_TAGS),\n/* harmony export */   HTML_LIST_CONTAINER_TAGS: () => (/* binding */ HTML_LIST_CONTAINER_TAGS),\n/* harmony export */   HTML_LIST_ITEM_TAGS: () => (/* binding */ HTML_LIST_ITEM_TAGS),\n/* harmony export */   HTML_SPAN_TAGS: () => (/* binding */ HTML_SPAN_TAGS),\n/* harmony export */   defaultParseHtml: () => (/* binding */ defaultParseHtml),\n/* harmony export */   ensureRootIsBlocks: () => (/* binding */ ensureRootIsBlocks),\n/* harmony export */   flattenNestedBlocks: () => (/* binding */ flattenNestedBlocks),\n/* harmony export */   isElement: () => (/* binding */ isElement),\n/* harmony export */   isMinimalBlock: () => (/* binding */ isMinimalBlock),\n/* harmony export */   isMinimalSpan: () => (/* binding */ isMinimalSpan),\n/* harmony export */   isNodeList: () => (/* binding */ isNodeList),\n/* harmony export */   isPlaceholderAnnotation: () => (/* binding */ isPlaceholderAnnotation),\n/* harmony export */   isPlaceholderDecorator: () => (/* binding */ isPlaceholderDecorator),\n/* harmony export */   preprocess: () => (/* binding */ preprocess),\n/* harmony export */   resolveJsType: () => (/* binding */ resolveJsType),\n/* harmony export */   tagName: () => (/* binding */ tagName),\n/* harmony export */   trimWhitespace: () => (/* binding */ trimWhitespace)\n/* harmony export */ });\n/* harmony import */ var _portabletext_schema__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @portabletext/schema */ \"(ssr)/../node_modules/@portabletext/schema/dist/index.js\");\n/* harmony import */ var lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isEqual.js */ \"(ssr)/../node_modules/lodash/isEqual.js\");\n/* harmony import */ var lodash_uniq_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/uniq.js */ \"(ssr)/../node_modules/lodash/uniq.js\");\n\n\n\nconst objectToString = Object.prototype.toString;\nfunction resolveJsType(val) {\n  switch (objectToString.call(val)) {\n    case \"[object Function]\":\n      return \"function\";\n    case \"[object Date]\":\n      return \"date\";\n    case \"[object RegExp]\":\n      return \"regexp\";\n    case \"[object Arguments]\":\n      return \"arguments\";\n    case \"[object Array]\":\n      return \"array\";\n    case \"[object String]\":\n      return \"string\";\n  }\n  return val === null ? \"null\" : val === void 0 ? \"undefined\" : val && typeof val == \"object\" && \"nodeType\" in val && val.nodeType === 1 ? \"element\" : val === Object(val) ? \"object\" : typeof val;\n}\nfunction isArbitraryTypedObject(object) {\n  return isRecord(object) && typeof object._type == \"string\";\n}\nfunction isRecord(value) {\n  return !!value && (typeof value == \"object\" || typeof value == \"function\");\n}\nfunction flattenNestedBlocks(context, blocks) {\n  return blocks.flatMap((block) => {\n    if (isBlockContainer(block))\n      return flattenNestedBlocks(context, [block.block]);\n    if ((0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_2__.isTextBlock)(context, block)) {\n      const hasBlockObjects = block.children.some((child) => context.schema.blockObjects.some(\n        (blockObject) => blockObject.name === child._type\n      )), hasBlocks = block.children.some(\n        (child) => child._type === \"__block\" || child._type === \"block\"\n      );\n      if (hasBlockObjects || hasBlocks) {\n        const splitChildren = getSplitChildren(context, block);\n        return splitChildren.length === 1 && splitChildren[0].type === \"children\" && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_0__(splitChildren[0].children, block.children) ? [block] : splitChildren.flatMap((slice) => slice.type === \"block object\" ? [slice.block] : slice.type === \"block\" ? flattenNestedBlocks(context, [\n          slice.block\n        ]) : slice.children.length > 0 ? slice.children.every(\n          (child) => (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_2__.isSpan)(context, child) && child.text.trim() === \"\"\n        ) ? [] : flattenNestedBlocks(context, [\n          {\n            ...block,\n            children: slice.children\n          }\n        ]) : []);\n      }\n      return [block];\n    }\n    return [block];\n  });\n}\nfunction isBlockContainer(block) {\n  return block._type === \"__block\" && isArbitraryTypedObject(block.block);\n}\nfunction getSplitChildren(context, block) {\n  return block.children.reduce(\n    (slices, child) => {\n      const knownInlineObject = context.schema.inlineObjects.some(\n        (inlineObject) => inlineObject.name === child._type\n      ), knownBlockObject = context.schema.blockObjects.some(\n        (blockObject) => blockObject.name === child._type\n      ), lastSlice = slices.pop();\n      return !(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_2__.isSpan)(context, child) && !knownInlineObject && knownBlockObject ? [\n        ...slices,\n        ...lastSlice ? [lastSlice] : [],\n        { type: \"block object\", block: child }\n      ] : child._type === \"__block\" ? [\n        ...slices,\n        ...lastSlice ? [lastSlice] : [],\n        {\n          type: \"block object\",\n          block: child.block\n        }\n      ] : child._type === \"block\" ? [\n        ...slices,\n        ...lastSlice ? [lastSlice] : [],\n        { type: \"block\", block: child }\n      ] : lastSlice && lastSlice.type === \"children\" ? [\n        ...slices,\n        {\n          type: \"children\",\n          children: [...lastSlice.children, child]\n        }\n      ] : [\n        ...slices,\n        ...lastSlice ? [lastSlice] : [],\n        { type: \"children\", children: [child] }\n      ];\n    },\n    []\n  );\n}\nvar s = { 0: 8203, 1: 8204, 2: 8205, 3: 8290, 4: 8291, 5: 8288, 6: 65279, 7: 8289, 8: 119155, 9: 119156, a: 119157, b: 119158, c: 119159, d: 119160, e: 119161, f: 119162 }, c = { 0: 8203, 1: 8204, 2: 8205, 3: 65279 };\nnew Array(4).fill(String.fromCodePoint(c[0])).join(\"\");\nObject.fromEntries(Object.entries(c).map((t) => t.reverse()));\nObject.fromEntries(Object.entries(s).map((t) => t.reverse()));\nvar S = `${Object.values(s).map((t) => `\\\\u{${t.toString(16)}}`).join(\"\")}`, f = new RegExp(`[${S}]{4,}`, \"gu\");\nfunction _(t) {\n  var e;\n  return { cleaned: t.replace(f, \"\"), encoded: ((e = t.match(f)) == null ? void 0 : e[0]) || \"\" };\n}\nfunction O(t) {\n  return t && JSON.parse(_(JSON.stringify(t)).cleaned);\n}\nconst PRESERVE_WHITESPACE_TAGS = [\"pre\", \"textarea\", \"code\"], BLOCK_DEFAULT_STYLE = \"normal\", DEFAULT_BLOCK = Object.freeze({\n  _type: \"block\",\n  markDefs: [],\n  style: BLOCK_DEFAULT_STYLE\n}), DEFAULT_SPAN = Object.freeze({\n  _type: \"span\",\n  marks: []\n}), HTML_BLOCK_TAGS = {\n  p: DEFAULT_BLOCK,\n  blockquote: { ...DEFAULT_BLOCK, style: \"blockquote\" }\n}, HTML_SPAN_TAGS = {\n  span: { object: \"text\" }\n}, HTML_LIST_CONTAINER_TAGS = {\n  ol: { object: null },\n  ul: { object: null }\n}, HTML_HEADER_TAGS = {\n  h1: { ...DEFAULT_BLOCK, style: \"h1\" },\n  h2: { ...DEFAULT_BLOCK, style: \"h2\" },\n  h3: { ...DEFAULT_BLOCK, style: \"h3\" },\n  h4: { ...DEFAULT_BLOCK, style: \"h4\" },\n  h5: { ...DEFAULT_BLOCK, style: \"h5\" },\n  h6: { ...DEFAULT_BLOCK, style: \"h6\" }\n}, HTML_MISC_TAGS = {\n  br: { ...DEFAULT_BLOCK, style: BLOCK_DEFAULT_STYLE }\n}, HTML_DECORATOR_TAGS = {\n  b: \"strong\",\n  strong: \"strong\",\n  i: \"em\",\n  em: \"em\",\n  u: \"underline\",\n  s: \"strike-through\",\n  strike: \"strike-through\",\n  del: \"strike-through\",\n  code: \"code\",\n  sup: \"sup\",\n  sub: \"sub\",\n  ins: \"ins\",\n  mark: \"mark\",\n  small: \"small\"\n}, HTML_LIST_ITEM_TAGS = {\n  li: {\n    ...DEFAULT_BLOCK,\n    style: BLOCK_DEFAULT_STYLE,\n    level: 1,\n    listItem: \"bullet\"\n  }\n}, ELEMENT_MAP = {\n  ...HTML_BLOCK_TAGS,\n  ...HTML_SPAN_TAGS,\n  ...HTML_LIST_CONTAINER_TAGS,\n  ...HTML_LIST_ITEM_TAGS,\n  ...HTML_HEADER_TAGS,\n  ...HTML_MISC_TAGS\n};\nlodash_uniq_js__WEBPACK_IMPORTED_MODULE_1__(\n  Object.values(ELEMENT_MAP).filter((tag) => \"style\" in tag).map((tag) => tag.style)\n);\nlodash_uniq_js__WEBPACK_IMPORTED_MODULE_1__(\n  Object.values(HTML_DECORATOR_TAGS)\n);\nconst _XPathResult = {\n  BOOLEAN_TYPE: 3,\n  ORDERED_NODE_ITERATOR_TYPE: 5,\n  UNORDERED_NODE_SNAPSHOT_TYPE: 6\n};\nvar preprocessGDocs = (_html, doc, options) => {\n  const whitespaceOnPasteMode = options?.unstable_whitespaceOnPasteMode || \"preserve\";\n  let gDocsRootOrSiblingNode = doc.evaluate(\n    '//*[@id and contains(@id, \"docs-internal-guid\")]',\n    doc,\n    null,\n    _XPathResult.ORDERED_NODE_ITERATOR_TYPE,\n    null\n  ).iterateNext();\n  if (gDocsRootOrSiblingNode) {\n    const isWrappedRootTag = tagName(gDocsRootOrSiblingNode) === \"b\";\n    switch (isWrappedRootTag || (gDocsRootOrSiblingNode = doc.body), whitespaceOnPasteMode) {\n      case \"normalize\":\n        normalizeWhitespace(gDocsRootOrSiblingNode);\n        break;\n      case \"remove\":\n        removeAllWhitespace(gDocsRootOrSiblingNode);\n        break;\n    }\n    const childNodes = doc.evaluate(\n      \"//*\",\n      doc,\n      null,\n      _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n      null\n    );\n    for (let i = childNodes.snapshotLength - 1; i >= 0; i--) {\n      const elm = childNodes.snapshotItem(i);\n      elm?.setAttribute(\"data-is-google-docs\", \"true\"), (elm?.parentElement === gDocsRootOrSiblingNode || !isWrappedRootTag && elm.parentElement === doc.body) && (elm?.setAttribute(\"data-is-root-node\", \"true\"), tagName(elm)), tagName(elm) === \"li\" && elm.firstChild && tagName(elm?.firstChild) === \"img\" && elm.removeChild(elm.firstChild);\n    }\n    return isWrappedRootTag && doc.body.firstElementChild?.replaceWith(\n      ...Array.from(gDocsRootOrSiblingNode.childNodes)\n    ), doc;\n  }\n  return doc;\n};\nconst unwantedWordDocumentPaths = [\n  \"/html/text()\",\n  \"/html/head/text()\",\n  \"/html/body/text()\",\n  \"/html/body/ul/text()\",\n  \"/html/body/ol/text()\",\n  \"//comment()\",\n  \"//style\",\n  \"//xml\",\n  \"//script\",\n  \"//meta\",\n  \"//link\"\n];\nvar preprocessHTML = (_html, doc) => {\n  const bodyTextNodes = doc.evaluate(\n    \"/html/body/text()\",\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null\n  );\n  for (let i = bodyTextNodes.snapshotLength - 1; i >= 0; i--) {\n    const node = bodyTextNodes.snapshotItem(i), text = node.textContent || \"\";\n    if (text.replace(/[^\\S\\n]+$/g, \"\")) {\n      const newNode = doc.createElement(\"span\");\n      newNode.appendChild(doc.createTextNode(text)), node.parentNode?.replaceChild(newNode, node);\n    } else\n      node.parentNode?.removeChild(node);\n  }\n  const unwantedNodes = doc.evaluate(\n    unwantedWordDocumentPaths.join(\"|\"),\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null\n  );\n  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {\n    const unwanted = unwantedNodes.snapshotItem(i);\n    unwanted && unwanted.parentNode?.removeChild(unwanted);\n  }\n  return doc;\n}, preprocessNotion = (html, doc) => {\n  const NOTION_REGEX = /<!-- notionvc:.*?-->/g;\n  if (html.match(NOTION_REGEX)) {\n    const childNodes = doc.evaluate(\n      \"//*\",\n      doc,\n      null,\n      _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n      null\n    );\n    for (let i = childNodes.snapshotLength - 1; i >= 0; i--)\n      childNodes.snapshotItem(i)?.setAttribute(\"data-is-notion\", \"true\");\n    return doc;\n  }\n  return doc;\n}, preprocessWhitespace = (_2, doc) => {\n  function processNode(node) {\n    if (node.nodeType === _XPathResult.BOOLEAN_TYPE && !PRESERVE_WHITESPACE_TAGS.includes(\n      node.parentElement?.tagName.toLowerCase() || \"\"\n    ))\n      node.textContent = node.textContent?.replace(/\\s\\s+/g, \" \").replace(/[\\r\\n]+/g, \" \") || \"\";\n    else\n      for (let i = 0; i < node.childNodes.length; i++)\n        processNode(node.childNodes[i]);\n  }\n  return processNode(doc.body), doc;\n};\nconst WORD_HTML_REGEX = /(class=\"?Mso|style=(?:\"|')[^\"]*?\\bmso-|w:WordDocument|<o:\\w+>|<\\/font>)/, unwantedPaths = [\n  \"//o:p\",\n  \"//span[@style='mso-list:Ignore']\",\n  \"//span[@style='mso-list: Ignore']\"\n], mappedPaths = [\n  \"//p[@class='MsoTocHeading']\",\n  \"//p[@class='MsoTitle']\",\n  \"//p[@class='MsoToaHeading']\",\n  \"//p[@class='MsoSubtitle']\",\n  \"//span[@class='MsoSubtleEmphasis']\",\n  \"//span[@class='MsoIntenseEmphasis']\"\n], elementMap = {\n  MsoTocHeading: [\"h3\"],\n  MsoTitle: [\"h1\"],\n  MsoToaHeading: [\"h2\"],\n  MsoSubtitle: [\"h5\"],\n  MsoSubtleEmphasis: [\"span\", \"em\"],\n  MsoIntenseEmphasis: [\"span\", \"em\", \"strong\"]\n  // Remove cruft\n};\nfunction isWordHtml(html) {\n  return WORD_HTML_REGEX.test(html);\n}\nvar preprocessWord = (html, doc) => {\n  if (!isWordHtml(html))\n    return doc;\n  const unwantedNodes = doc.evaluate(\n    unwantedPaths.join(\"|\"),\n    doc,\n    (prefix) => prefix === \"o\" ? \"urn:schemas-microsoft-com:office:office\" : null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null\n  );\n  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {\n    const unwanted = unwantedNodes.snapshotItem(i);\n    unwanted?.parentNode && unwanted.parentNode.removeChild(unwanted);\n  }\n  const mappedElements = doc.evaluate(\n    mappedPaths.join(\"|\"),\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null\n  );\n  for (let i = mappedElements.snapshotLength - 1; i >= 0; i--) {\n    const mappedElm = mappedElements.snapshotItem(i), tags = elementMap[mappedElm.className], text = doc.createTextNode(mappedElm.textContent || \"\");\n    if (!tags)\n      continue;\n    const parentElement = doc.createElement(tags[0]);\n    let parent = parentElement, child = parentElement;\n    tags.slice(1).forEach((tag) => {\n      child = doc.createElement(tag), parent.appendChild(child), parent = child;\n    }), child.appendChild(text), mappedElm?.parentNode?.replaceChild(parentElement, mappedElm);\n  }\n  return doc;\n}, preprocessors = [\n  preprocessWhitespace,\n  preprocessNotion,\n  preprocessWord,\n  preprocessGDocs,\n  preprocessHTML\n];\nfunction tagName(el) {\n  if (el && \"tagName\" in el)\n    return el.tagName.toLowerCase();\n}\nfunction preprocess(html, parseHtml, options) {\n  const cleanHTML = O(html), doc = parseHtml(normalizeHtmlBeforePreprocess(cleanHTML));\n  return preprocessors.forEach((processor) => {\n    processor(cleanHTML, doc, options);\n  }), doc;\n}\nfunction normalizeHtmlBeforePreprocess(html) {\n  return html.trim();\n}\nfunction defaultParseHtml() {\n  if (resolveJsType(DOMParser) === \"undefined\")\n    throw new Error(\n      \"The native `DOMParser` global which the `Html` deserializer uses by default is not present in this environment. You must supply the `options.parseHtml` function instead.\"\n    );\n  return (html) => new DOMParser().parseFromString(html, \"text/html\");\n}\nfunction nextSpan(block, index) {\n  const next = block.children[index + 1];\n  return next && next._type === \"span\" ? next : null;\n}\nfunction prevSpan(block, index) {\n  const prev = block.children[index - 1];\n  return prev && prev._type === \"span\" ? prev : null;\n}\nfunction isWhiteSpaceChar(text) {\n  return [\"\\xA0\", \" \"].includes(text);\n}\nfunction trimWhitespace(schema, blocks) {\n  return blocks.forEach((block) => {\n    (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_2__.isTextBlock)({ schema }, block) && block.children.forEach((child, index) => {\n      if (!isMinimalSpan(child))\n        return;\n      const nextChild = nextSpan(block, index), prevChild = prevSpan(block, index);\n      index === 0 && (child.text = child.text.replace(/^[^\\S\\n]+/g, \"\")), index === block.children.length - 1 && (child.text = child.text.replace(/[^\\S\\n]+$/g, \"\")), /\\s/.test(child.text.slice(Math.max(0, child.text.length - 1))) && nextChild && isMinimalSpan(nextChild) && /\\s/.test(nextChild.text.slice(0, 1)) && (child.text = child.text.replace(/[^\\S\\n]+$/g, \"\")), /\\s/.test(child.text.slice(0, 1)) && prevChild && isMinimalSpan(prevChild) && /\\s/.test(prevChild.text.slice(Math.max(0, prevChild.text.length - 1))) && (child.text = child.text.replace(/^[^\\S\\n]+/g, \"\")), child.text || block.children.splice(index, 1), prevChild && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_0__(prevChild.marks, child.marks) && isWhiteSpaceChar(child.text) ? (prevChild.text += \" \", block.children.splice(index, 1)) : nextChild && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_0__(nextChild.marks, child.marks) && isWhiteSpaceChar(child.text) && (nextChild.text = ` ${nextChild.text}`, block.children.splice(index, 1));\n    });\n  }), blocks;\n}\nfunction ensureRootIsBlocks(schema, objects) {\n  return objects.reduce((blocks, node, i, original) => {\n    if (node._type === \"block\")\n      return blocks.push(node), blocks;\n    if (node._type === \"__block\")\n      return blocks.push(node.block), blocks;\n    const lastBlock = blocks[blocks.length - 1];\n    if (i > 0 && !(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_2__.isTextBlock)({ schema }, original[i - 1]) && (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_2__.isTextBlock)({ schema }, lastBlock))\n      return lastBlock.children.push(node), blocks;\n    const block = {\n      ...DEFAULT_BLOCK,\n      children: [node]\n    };\n    return blocks.push(block), blocks;\n  }, []);\n}\nfunction isNodeList(node) {\n  return Object.prototype.toString.call(node) === \"[object NodeList]\";\n}\nfunction isMinimalSpan(node) {\n  return node._type === \"span\";\n}\nfunction isMinimalBlock(node) {\n  return node._type === \"block\";\n}\nfunction isPlaceholderDecorator(node) {\n  return node._type === \"__decorator\";\n}\nfunction isPlaceholderAnnotation(node) {\n  return node._type === \"__annotation\";\n}\nfunction isElement(node) {\n  return node.nodeType === 1;\n}\nfunction normalizeWhitespace(rootNode) {\n  let emptyBlockCount = 0, lastParent = null;\n  const nodesToRemove = [];\n  for (let child = rootNode.firstChild; child; child = child.nextSibling) {\n    if (!isElement(child)) {\n      normalizeWhitespace(child), emptyBlockCount = 0;\n      continue;\n    }\n    const elm = child;\n    isWhitespaceBlock(elm) ? (lastParent && elm.parentElement === lastParent ? (emptyBlockCount++, emptyBlockCount > 1 && nodesToRemove.push(elm)) : emptyBlockCount = 1, lastParent = elm.parentElement) : (normalizeWhitespace(child), emptyBlockCount = 0);\n  }\n  nodesToRemove.forEach((node) => {\n    node.parentElement?.removeChild(node);\n  });\n}\nfunction removeAllWhitespace(rootNode) {\n  const nodesToRemove = [];\n  function collectNodesToRemove(currentNode) {\n    if (isElement(currentNode)) {\n      const elm = currentNode;\n      if (tagName(elm) === \"br\" && (tagName(elm.nextElementSibling) === \"p\" || tagName(elm.previousElementSibling) === \"p\")) {\n        nodesToRemove.push(elm);\n        return;\n      }\n      if ((tagName(elm) === \"p\" || tagName(elm) === \"br\") && elm?.firstChild?.textContent?.trim() === \"\") {\n        nodesToRemove.push(elm);\n        return;\n      }\n      for (let child = elm.firstChild; child; child = child.nextSibling)\n        collectNodesToRemove(child);\n    }\n  }\n  collectNodesToRemove(rootNode), nodesToRemove.forEach((node) => {\n    node.parentElement?.removeChild(node);\n  });\n}\nfunction isWhitespaceBlock(elm) {\n  return [\"p\", \"br\"].includes(tagName(elm) || \"\") && !elm.textContent?.trim();\n}\n\n//# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvYmxvY2stdG9vbHMvbGliL19jaHVua3MtZXMvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTJEO0FBQ25CO0FBQ047QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLDhDQUFPO0FBQzVGO0FBQ0E7QUFDQSxxQkFBcUIsNERBQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0REFBTTtBQUNwQjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlLQUFpSyxRQUFRO0FBQ25MO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUNBQWlDLEVBQUUsZ0JBQWdCLFlBQVksc0JBQXNCLEVBQUUsRUFBRSxHQUFHO0FBQ3ZHO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsZ0JBQWdCO0FBQ2hCLENBQUM7QUFDRCxVQUFVO0FBQ1YsQ0FBQztBQUNELFFBQVEsY0FBYztBQUN0QixRQUFRO0FBQ1IsQ0FBQztBQUNELFFBQVEsK0JBQStCO0FBQ3ZDLFFBQVEsK0JBQStCO0FBQ3ZDLFFBQVEsK0JBQStCO0FBQ3ZDLFFBQVEsK0JBQStCO0FBQ3ZDLFFBQVEsK0JBQStCO0FBQ3ZDLFFBQVE7QUFDUixDQUFDO0FBQ0QsUUFBUTtBQUNSLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUFJO0FBQ0o7QUFDQTtBQUNBLDJDQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFFBQVE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksaUVBQVcsR0FBRyxRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLDBuQkFBMG5CLDhDQUFPLHlJQUF5SSw4Q0FBTyx3RkFBd0YsZUFBZTtBQUN4M0IsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlFQUFXLEdBQUcsUUFBUSxzQkFBc0IsaUVBQVcsR0FBRyxRQUFRO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQXdCRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvR2Fsb2NrL0NTL2JlaG9tZS1zaXRlL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L2Jsb2NrLXRvb2xzL2xpYi9fY2h1bmtzLWVzL2hlbHBlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNUZXh0QmxvY2ssIGlzU3BhbiB9IGZyb20gXCJAcG9ydGFibGV0ZXh0L3NjaGVtYVwiO1xuaW1wb3J0IGlzRXF1YWwgZnJvbSBcImxvZGFzaC9pc0VxdWFsLmpzXCI7XG5pbXBvcnQgdW5pcSBmcm9tIFwibG9kYXNoL3VuaXEuanNcIjtcbmNvbnN0IG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmZ1bmN0aW9uIHJlc29sdmVKc1R5cGUodmFsKSB7XG4gIHN3aXRjaCAob2JqZWN0VG9TdHJpbmcuY2FsbCh2YWwpKSB7XG4gICAgY2FzZSBcIltvYmplY3QgRnVuY3Rpb25dXCI6XG4gICAgICByZXR1cm4gXCJmdW5jdGlvblwiO1xuICAgIGNhc2UgXCJbb2JqZWN0IERhdGVdXCI6XG4gICAgICByZXR1cm4gXCJkYXRlXCI7XG4gICAgY2FzZSBcIltvYmplY3QgUmVnRXhwXVwiOlxuICAgICAgcmV0dXJuIFwicmVnZXhwXCI7XG4gICAgY2FzZSBcIltvYmplY3QgQXJndW1lbnRzXVwiOlxuICAgICAgcmV0dXJuIFwiYXJndW1lbnRzXCI7XG4gICAgY2FzZSBcIltvYmplY3QgQXJyYXldXCI6XG4gICAgICByZXR1cm4gXCJhcnJheVwiO1xuICAgIGNhc2UgXCJbb2JqZWN0IFN0cmluZ11cIjpcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICB9XG4gIHJldHVybiB2YWwgPT09IG51bGwgPyBcIm51bGxcIiA6IHZhbCA9PT0gdm9pZCAwID8gXCJ1bmRlZmluZWRcIiA6IHZhbCAmJiB0eXBlb2YgdmFsID09IFwib2JqZWN0XCIgJiYgXCJub2RlVHlwZVwiIGluIHZhbCAmJiB2YWwubm9kZVR5cGUgPT09IDEgPyBcImVsZW1lbnRcIiA6IHZhbCA9PT0gT2JqZWN0KHZhbCkgPyBcIm9iamVjdFwiIDogdHlwZW9mIHZhbDtcbn1cbmZ1bmN0aW9uIGlzQXJiaXRyYXJ5VHlwZWRPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiBpc1JlY29yZChvYmplY3QpICYmIHR5cGVvZiBvYmplY3QuX3R5cGUgPT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGlzUmVjb3JkKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW5OZXN0ZWRCbG9ja3MoY29udGV4dCwgYmxvY2tzKSB7XG4gIHJldHVybiBibG9ja3MuZmxhdE1hcCgoYmxvY2spID0+IHtcbiAgICBpZiAoaXNCbG9ja0NvbnRhaW5lcihibG9jaykpXG4gICAgICByZXR1cm4gZmxhdHRlbk5lc3RlZEJsb2Nrcyhjb250ZXh0LCBbYmxvY2suYmxvY2tdKTtcbiAgICBpZiAoaXNUZXh0QmxvY2soY29udGV4dCwgYmxvY2spKSB7XG4gICAgICBjb25zdCBoYXNCbG9ja09iamVjdHMgPSBibG9jay5jaGlsZHJlbi5zb21lKChjaGlsZCkgPT4gY29udGV4dC5zY2hlbWEuYmxvY2tPYmplY3RzLnNvbWUoXG4gICAgICAgIChibG9ja09iamVjdCkgPT4gYmxvY2tPYmplY3QubmFtZSA9PT0gY2hpbGQuX3R5cGVcbiAgICAgICkpLCBoYXNCbG9ja3MgPSBibG9jay5jaGlsZHJlbi5zb21lKFxuICAgICAgICAoY2hpbGQpID0+IGNoaWxkLl90eXBlID09PSBcIl9fYmxvY2tcIiB8fCBjaGlsZC5fdHlwZSA9PT0gXCJibG9ja1wiXG4gICAgICApO1xuICAgICAgaWYgKGhhc0Jsb2NrT2JqZWN0cyB8fCBoYXNCbG9ja3MpIHtcbiAgICAgICAgY29uc3Qgc3BsaXRDaGlsZHJlbiA9IGdldFNwbGl0Q2hpbGRyZW4oY29udGV4dCwgYmxvY2spO1xuICAgICAgICByZXR1cm4gc3BsaXRDaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgc3BsaXRDaGlsZHJlblswXS50eXBlID09PSBcImNoaWxkcmVuXCIgJiYgaXNFcXVhbChzcGxpdENoaWxkcmVuWzBdLmNoaWxkcmVuLCBibG9jay5jaGlsZHJlbikgPyBbYmxvY2tdIDogc3BsaXRDaGlsZHJlbi5mbGF0TWFwKChzbGljZSkgPT4gc2xpY2UudHlwZSA9PT0gXCJibG9jayBvYmplY3RcIiA/IFtzbGljZS5ibG9ja10gOiBzbGljZS50eXBlID09PSBcImJsb2NrXCIgPyBmbGF0dGVuTmVzdGVkQmxvY2tzKGNvbnRleHQsIFtcbiAgICAgICAgICBzbGljZS5ibG9ja1xuICAgICAgICBdKSA6IHNsaWNlLmNoaWxkcmVuLmxlbmd0aCA+IDAgPyBzbGljZS5jaGlsZHJlbi5ldmVyeShcbiAgICAgICAgICAoY2hpbGQpID0+IGlzU3Bhbihjb250ZXh0LCBjaGlsZCkgJiYgY2hpbGQudGV4dC50cmltKCkgPT09IFwiXCJcbiAgICAgICAgKSA/IFtdIDogZmxhdHRlbk5lc3RlZEJsb2Nrcyhjb250ZXh0LCBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4uYmxvY2ssXG4gICAgICAgICAgICBjaGlsZHJlbjogc2xpY2UuY2hpbGRyZW5cbiAgICAgICAgICB9XG4gICAgICAgIF0pIDogW10pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtibG9ja107XG4gICAgfVxuICAgIHJldHVybiBbYmxvY2tdO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzQmxvY2tDb250YWluZXIoYmxvY2spIHtcbiAgcmV0dXJuIGJsb2NrLl90eXBlID09PSBcIl9fYmxvY2tcIiAmJiBpc0FyYml0cmFyeVR5cGVkT2JqZWN0KGJsb2NrLmJsb2NrKTtcbn1cbmZ1bmN0aW9uIGdldFNwbGl0Q2hpbGRyZW4oY29udGV4dCwgYmxvY2spIHtcbiAgcmV0dXJuIGJsb2NrLmNoaWxkcmVuLnJlZHVjZShcbiAgICAoc2xpY2VzLCBjaGlsZCkgPT4ge1xuICAgICAgY29uc3Qga25vd25JbmxpbmVPYmplY3QgPSBjb250ZXh0LnNjaGVtYS5pbmxpbmVPYmplY3RzLnNvbWUoXG4gICAgICAgIChpbmxpbmVPYmplY3QpID0+IGlubGluZU9iamVjdC5uYW1lID09PSBjaGlsZC5fdHlwZVxuICAgICAgKSwga25vd25CbG9ja09iamVjdCA9IGNvbnRleHQuc2NoZW1hLmJsb2NrT2JqZWN0cy5zb21lKFxuICAgICAgICAoYmxvY2tPYmplY3QpID0+IGJsb2NrT2JqZWN0Lm5hbWUgPT09IGNoaWxkLl90eXBlXG4gICAgICApLCBsYXN0U2xpY2UgPSBzbGljZXMucG9wKCk7XG4gICAgICByZXR1cm4gIWlzU3Bhbihjb250ZXh0LCBjaGlsZCkgJiYgIWtub3duSW5saW5lT2JqZWN0ICYmIGtub3duQmxvY2tPYmplY3QgPyBbXG4gICAgICAgIC4uLnNsaWNlcyxcbiAgICAgICAgLi4ubGFzdFNsaWNlID8gW2xhc3RTbGljZV0gOiBbXSxcbiAgICAgICAgeyB0eXBlOiBcImJsb2NrIG9iamVjdFwiLCBibG9jazogY2hpbGQgfVxuICAgICAgXSA6IGNoaWxkLl90eXBlID09PSBcIl9fYmxvY2tcIiA/IFtcbiAgICAgICAgLi4uc2xpY2VzLFxuICAgICAgICAuLi5sYXN0U2xpY2UgPyBbbGFzdFNsaWNlXSA6IFtdLFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJibG9jayBvYmplY3RcIixcbiAgICAgICAgICBibG9jazogY2hpbGQuYmxvY2tcbiAgICAgICAgfVxuICAgICAgXSA6IGNoaWxkLl90eXBlID09PSBcImJsb2NrXCIgPyBbXG4gICAgICAgIC4uLnNsaWNlcyxcbiAgICAgICAgLi4ubGFzdFNsaWNlID8gW2xhc3RTbGljZV0gOiBbXSxcbiAgICAgICAgeyB0eXBlOiBcImJsb2NrXCIsIGJsb2NrOiBjaGlsZCB9XG4gICAgICBdIDogbGFzdFNsaWNlICYmIGxhc3RTbGljZS50eXBlID09PSBcImNoaWxkcmVuXCIgPyBbXG4gICAgICAgIC4uLnNsaWNlcyxcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwiY2hpbGRyZW5cIixcbiAgICAgICAgICBjaGlsZHJlbjogWy4uLmxhc3RTbGljZS5jaGlsZHJlbiwgY2hpbGRdXG4gICAgICAgIH1cbiAgICAgIF0gOiBbXG4gICAgICAgIC4uLnNsaWNlcyxcbiAgICAgICAgLi4ubGFzdFNsaWNlID8gW2xhc3RTbGljZV0gOiBbXSxcbiAgICAgICAgeyB0eXBlOiBcImNoaWxkcmVuXCIsIGNoaWxkcmVuOiBbY2hpbGRdIH1cbiAgICAgIF07XG4gICAgfSxcbiAgICBbXVxuICApO1xufVxudmFyIHMgPSB7IDA6IDgyMDMsIDE6IDgyMDQsIDI6IDgyMDUsIDM6IDgyOTAsIDQ6IDgyOTEsIDU6IDgyODgsIDY6IDY1Mjc5LCA3OiA4Mjg5LCA4OiAxMTkxNTUsIDk6IDExOTE1NiwgYTogMTE5MTU3LCBiOiAxMTkxNTgsIGM6IDExOTE1OSwgZDogMTE5MTYwLCBlOiAxMTkxNjEsIGY6IDExOTE2MiB9LCBjID0geyAwOiA4MjAzLCAxOiA4MjA0LCAyOiA4MjA1LCAzOiA2NTI3OSB9O1xubmV3IEFycmF5KDQpLmZpbGwoU3RyaW5nLmZyb21Db2RlUG9pbnQoY1swXSkpLmpvaW4oXCJcIik7XG5PYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoYykubWFwKCh0KSA9PiB0LnJldmVyc2UoKSkpO1xuT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHMpLm1hcCgodCkgPT4gdC5yZXZlcnNlKCkpKTtcbnZhciBTID0gYCR7T2JqZWN0LnZhbHVlcyhzKS5tYXAoKHQpID0+IGBcXFxcdXske3QudG9TdHJpbmcoMTYpfX1gKS5qb2luKFwiXCIpfWAsIGYgPSBuZXcgUmVnRXhwKGBbJHtTfV17NCx9YCwgXCJndVwiKTtcbmZ1bmN0aW9uIF8odCkge1xuICB2YXIgZTtcbiAgcmV0dXJuIHsgY2xlYW5lZDogdC5yZXBsYWNlKGYsIFwiXCIpLCBlbmNvZGVkOiAoKGUgPSB0Lm1hdGNoKGYpKSA9PSBudWxsID8gdm9pZCAwIDogZVswXSkgfHwgXCJcIiB9O1xufVxuZnVuY3Rpb24gTyh0KSB7XG4gIHJldHVybiB0ICYmIEpTT04ucGFyc2UoXyhKU09OLnN0cmluZ2lmeSh0KSkuY2xlYW5lZCk7XG59XG5jb25zdCBQUkVTRVJWRV9XSElURVNQQUNFX1RBR1MgPSBbXCJwcmVcIiwgXCJ0ZXh0YXJlYVwiLCBcImNvZGVcIl0sIEJMT0NLX0RFRkFVTFRfU1RZTEUgPSBcIm5vcm1hbFwiLCBERUZBVUxUX0JMT0NLID0gT2JqZWN0LmZyZWV6ZSh7XG4gIF90eXBlOiBcImJsb2NrXCIsXG4gIG1hcmtEZWZzOiBbXSxcbiAgc3R5bGU6IEJMT0NLX0RFRkFVTFRfU1RZTEVcbn0pLCBERUZBVUxUX1NQQU4gPSBPYmplY3QuZnJlZXplKHtcbiAgX3R5cGU6IFwic3BhblwiLFxuICBtYXJrczogW11cbn0pLCBIVE1MX0JMT0NLX1RBR1MgPSB7XG4gIHA6IERFRkFVTFRfQkxPQ0ssXG4gIGJsb2NrcXVvdGU6IHsgLi4uREVGQVVMVF9CTE9DSywgc3R5bGU6IFwiYmxvY2txdW90ZVwiIH1cbn0sIEhUTUxfU1BBTl9UQUdTID0ge1xuICBzcGFuOiB7IG9iamVjdDogXCJ0ZXh0XCIgfVxufSwgSFRNTF9MSVNUX0NPTlRBSU5FUl9UQUdTID0ge1xuICBvbDogeyBvYmplY3Q6IG51bGwgfSxcbiAgdWw6IHsgb2JqZWN0OiBudWxsIH1cbn0sIEhUTUxfSEVBREVSX1RBR1MgPSB7XG4gIGgxOiB7IC4uLkRFRkFVTFRfQkxPQ0ssIHN0eWxlOiBcImgxXCIgfSxcbiAgaDI6IHsgLi4uREVGQVVMVF9CTE9DSywgc3R5bGU6IFwiaDJcIiB9LFxuICBoMzogeyAuLi5ERUZBVUxUX0JMT0NLLCBzdHlsZTogXCJoM1wiIH0sXG4gIGg0OiB7IC4uLkRFRkFVTFRfQkxPQ0ssIHN0eWxlOiBcImg0XCIgfSxcbiAgaDU6IHsgLi4uREVGQVVMVF9CTE9DSywgc3R5bGU6IFwiaDVcIiB9LFxuICBoNjogeyAuLi5ERUZBVUxUX0JMT0NLLCBzdHlsZTogXCJoNlwiIH1cbn0sIEhUTUxfTUlTQ19UQUdTID0ge1xuICBicjogeyAuLi5ERUZBVUxUX0JMT0NLLCBzdHlsZTogQkxPQ0tfREVGQVVMVF9TVFlMRSB9XG59LCBIVE1MX0RFQ09SQVRPUl9UQUdTID0ge1xuICBiOiBcInN0cm9uZ1wiLFxuICBzdHJvbmc6IFwic3Ryb25nXCIsXG4gIGk6IFwiZW1cIixcbiAgZW06IFwiZW1cIixcbiAgdTogXCJ1bmRlcmxpbmVcIixcbiAgczogXCJzdHJpa2UtdGhyb3VnaFwiLFxuICBzdHJpa2U6IFwic3RyaWtlLXRocm91Z2hcIixcbiAgZGVsOiBcInN0cmlrZS10aHJvdWdoXCIsXG4gIGNvZGU6IFwiY29kZVwiLFxuICBzdXA6IFwic3VwXCIsXG4gIHN1YjogXCJzdWJcIixcbiAgaW5zOiBcImluc1wiLFxuICBtYXJrOiBcIm1hcmtcIixcbiAgc21hbGw6IFwic21hbGxcIlxufSwgSFRNTF9MSVNUX0lURU1fVEFHUyA9IHtcbiAgbGk6IHtcbiAgICAuLi5ERUZBVUxUX0JMT0NLLFxuICAgIHN0eWxlOiBCTE9DS19ERUZBVUxUX1NUWUxFLFxuICAgIGxldmVsOiAxLFxuICAgIGxpc3RJdGVtOiBcImJ1bGxldFwiXG4gIH1cbn0sIEVMRU1FTlRfTUFQID0ge1xuICAuLi5IVE1MX0JMT0NLX1RBR1MsXG4gIC4uLkhUTUxfU1BBTl9UQUdTLFxuICAuLi5IVE1MX0xJU1RfQ09OVEFJTkVSX1RBR1MsXG4gIC4uLkhUTUxfTElTVF9JVEVNX1RBR1MsXG4gIC4uLkhUTUxfSEVBREVSX1RBR1MsXG4gIC4uLkhUTUxfTUlTQ19UQUdTXG59O1xudW5pcShcbiAgT2JqZWN0LnZhbHVlcyhFTEVNRU5UX01BUCkuZmlsdGVyKCh0YWcpID0+IFwic3R5bGVcIiBpbiB0YWcpLm1hcCgodGFnKSA9PiB0YWcuc3R5bGUpXG4pO1xudW5pcShcbiAgT2JqZWN0LnZhbHVlcyhIVE1MX0RFQ09SQVRPUl9UQUdTKVxuKTtcbmNvbnN0IF9YUGF0aFJlc3VsdCA9IHtcbiAgQk9PTEVBTl9UWVBFOiAzLFxuICBPUkRFUkVEX05PREVfSVRFUkFUT1JfVFlQRTogNSxcbiAgVU5PUkRFUkVEX05PREVfU05BUFNIT1RfVFlQRTogNlxufTtcbnZhciBwcmVwcm9jZXNzR0RvY3MgPSAoX2h0bWwsIGRvYywgb3B0aW9ucykgPT4ge1xuICBjb25zdCB3aGl0ZXNwYWNlT25QYXN0ZU1vZGUgPSBvcHRpb25zPy51bnN0YWJsZV93aGl0ZXNwYWNlT25QYXN0ZU1vZGUgfHwgXCJwcmVzZXJ2ZVwiO1xuICBsZXQgZ0RvY3NSb290T3JTaWJsaW5nTm9kZSA9IGRvYy5ldmFsdWF0ZShcbiAgICAnLy8qW0BpZCBhbmQgY29udGFpbnMoQGlkLCBcImRvY3MtaW50ZXJuYWwtZ3VpZFwiKV0nLFxuICAgIGRvYyxcbiAgICBudWxsLFxuICAgIF9YUGF0aFJlc3VsdC5PUkRFUkVEX05PREVfSVRFUkFUT1JfVFlQRSxcbiAgICBudWxsXG4gICkuaXRlcmF0ZU5leHQoKTtcbiAgaWYgKGdEb2NzUm9vdE9yU2libGluZ05vZGUpIHtcbiAgICBjb25zdCBpc1dyYXBwZWRSb290VGFnID0gdGFnTmFtZShnRG9jc1Jvb3RPclNpYmxpbmdOb2RlKSA9PT0gXCJiXCI7XG4gICAgc3dpdGNoIChpc1dyYXBwZWRSb290VGFnIHx8IChnRG9jc1Jvb3RPclNpYmxpbmdOb2RlID0gZG9jLmJvZHkpLCB3aGl0ZXNwYWNlT25QYXN0ZU1vZGUpIHtcbiAgICAgIGNhc2UgXCJub3JtYWxpemVcIjpcbiAgICAgICAgbm9ybWFsaXplV2hpdGVzcGFjZShnRG9jc1Jvb3RPclNpYmxpbmdOb2RlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicmVtb3ZlXCI6XG4gICAgICAgIHJlbW92ZUFsbFdoaXRlc3BhY2UoZ0RvY3NSb290T3JTaWJsaW5nTm9kZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBjaGlsZE5vZGVzID0gZG9jLmV2YWx1YXRlKFxuICAgICAgXCIvLypcIixcbiAgICAgIGRvYyxcbiAgICAgIG51bGwsXG4gICAgICBfWFBhdGhSZXN1bHQuVU5PUkRFUkVEX05PREVfU05BUFNIT1RfVFlQRSxcbiAgICAgIG51bGxcbiAgICApO1xuICAgIGZvciAobGV0IGkgPSBjaGlsZE5vZGVzLnNuYXBzaG90TGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGVsbSA9IGNoaWxkTm9kZXMuc25hcHNob3RJdGVtKGkpO1xuICAgICAgZWxtPy5zZXRBdHRyaWJ1dGUoXCJkYXRhLWlzLWdvb2dsZS1kb2NzXCIsIFwidHJ1ZVwiKSwgKGVsbT8ucGFyZW50RWxlbWVudCA9PT0gZ0RvY3NSb290T3JTaWJsaW5nTm9kZSB8fCAhaXNXcmFwcGVkUm9vdFRhZyAmJiBlbG0ucGFyZW50RWxlbWVudCA9PT0gZG9jLmJvZHkpICYmIChlbG0/LnNldEF0dHJpYnV0ZShcImRhdGEtaXMtcm9vdC1ub2RlXCIsIFwidHJ1ZVwiKSwgdGFnTmFtZShlbG0pKSwgdGFnTmFtZShlbG0pID09PSBcImxpXCIgJiYgZWxtLmZpcnN0Q2hpbGQgJiYgdGFnTmFtZShlbG0/LmZpcnN0Q2hpbGQpID09PSBcImltZ1wiICYmIGVsbS5yZW1vdmVDaGlsZChlbG0uZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBpc1dyYXBwZWRSb290VGFnICYmIGRvYy5ib2R5LmZpcnN0RWxlbWVudENoaWxkPy5yZXBsYWNlV2l0aChcbiAgICAgIC4uLkFycmF5LmZyb20oZ0RvY3NSb290T3JTaWJsaW5nTm9kZS5jaGlsZE5vZGVzKVxuICAgICksIGRvYztcbiAgfVxuICByZXR1cm4gZG9jO1xufTtcbmNvbnN0IHVud2FudGVkV29yZERvY3VtZW50UGF0aHMgPSBbXG4gIFwiL2h0bWwvdGV4dCgpXCIsXG4gIFwiL2h0bWwvaGVhZC90ZXh0KClcIixcbiAgXCIvaHRtbC9ib2R5L3RleHQoKVwiLFxuICBcIi9odG1sL2JvZHkvdWwvdGV4dCgpXCIsXG4gIFwiL2h0bWwvYm9keS9vbC90ZXh0KClcIixcbiAgXCIvL2NvbW1lbnQoKVwiLFxuICBcIi8vc3R5bGVcIixcbiAgXCIvL3htbFwiLFxuICBcIi8vc2NyaXB0XCIsXG4gIFwiLy9tZXRhXCIsXG4gIFwiLy9saW5rXCJcbl07XG52YXIgcHJlcHJvY2Vzc0hUTUwgPSAoX2h0bWwsIGRvYykgPT4ge1xuICBjb25zdCBib2R5VGV4dE5vZGVzID0gZG9jLmV2YWx1YXRlKFxuICAgIFwiL2h0bWwvYm9keS90ZXh0KClcIixcbiAgICBkb2MsXG4gICAgbnVsbCxcbiAgICBfWFBhdGhSZXN1bHQuVU5PUkRFUkVEX05PREVfU05BUFNIT1RfVFlQRSxcbiAgICBudWxsXG4gICk7XG4gIGZvciAobGV0IGkgPSBib2R5VGV4dE5vZGVzLnNuYXBzaG90TGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBub2RlID0gYm9keVRleHROb2Rlcy5zbmFwc2hvdEl0ZW0oaSksIHRleHQgPSBub2RlLnRleHRDb250ZW50IHx8IFwiXCI7XG4gICAgaWYgKHRleHQucmVwbGFjZSgvW15cXFNcXG5dKyQvZywgXCJcIikpIHtcbiAgICAgIGNvbnN0IG5ld05vZGUgPSBkb2MuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBuZXdOb2RlLmFwcGVuZENoaWxkKGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSksIG5vZGUucGFyZW50Tm9kZT8ucmVwbGFjZUNoaWxkKG5ld05vZGUsIG5vZGUpO1xuICAgIH0gZWxzZVxuICAgICAgbm9kZS5wYXJlbnROb2RlPy5yZW1vdmVDaGlsZChub2RlKTtcbiAgfVxuICBjb25zdCB1bndhbnRlZE5vZGVzID0gZG9jLmV2YWx1YXRlKFxuICAgIHVud2FudGVkV29yZERvY3VtZW50UGF0aHMuam9pbihcInxcIiksXG4gICAgZG9jLFxuICAgIG51bGwsXG4gICAgX1hQYXRoUmVzdWx0LlVOT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEUsXG4gICAgbnVsbFxuICApO1xuICBmb3IgKGxldCBpID0gdW53YW50ZWROb2Rlcy5zbmFwc2hvdExlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgdW53YW50ZWQgPSB1bndhbnRlZE5vZGVzLnNuYXBzaG90SXRlbShpKTtcbiAgICB1bndhbnRlZCAmJiB1bndhbnRlZC5wYXJlbnROb2RlPy5yZW1vdmVDaGlsZCh1bndhbnRlZCk7XG4gIH1cbiAgcmV0dXJuIGRvYztcbn0sIHByZXByb2Nlc3NOb3Rpb24gPSAoaHRtbCwgZG9jKSA9PiB7XG4gIGNvbnN0IE5PVElPTl9SRUdFWCA9IC88IS0tIG5vdGlvbnZjOi4qPy0tPi9nO1xuICBpZiAoaHRtbC5tYXRjaChOT1RJT05fUkVHRVgpKSB7XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IGRvYy5ldmFsdWF0ZShcbiAgICAgIFwiLy8qXCIsXG4gICAgICBkb2MsXG4gICAgICBudWxsLFxuICAgICAgX1hQYXRoUmVzdWx0LlVOT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEUsXG4gICAgICBudWxsXG4gICAgKTtcbiAgICBmb3IgKGxldCBpID0gY2hpbGROb2Rlcy5zbmFwc2hvdExlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgY2hpbGROb2Rlcy5zbmFwc2hvdEl0ZW0oaSk/LnNldEF0dHJpYnV0ZShcImRhdGEtaXMtbm90aW9uXCIsIFwidHJ1ZVwiKTtcbiAgICByZXR1cm4gZG9jO1xuICB9XG4gIHJldHVybiBkb2M7XG59LCBwcmVwcm9jZXNzV2hpdGVzcGFjZSA9IChfMiwgZG9jKSA9PiB7XG4gIGZ1bmN0aW9uIHByb2Nlc3NOb2RlKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gX1hQYXRoUmVzdWx0LkJPT0xFQU5fVFlQRSAmJiAhUFJFU0VSVkVfV0hJVEVTUEFDRV9UQUdTLmluY2x1ZGVzKFxuICAgICAgbm9kZS5wYXJlbnRFbGVtZW50Py50YWdOYW1lLnRvTG93ZXJDYXNlKCkgfHwgXCJcIlxuICAgICkpXG4gICAgICBub2RlLnRleHRDb250ZW50ID0gbm9kZS50ZXh0Q29udGVudD8ucmVwbGFjZSgvXFxzXFxzKy9nLCBcIiBcIikucmVwbGFjZSgvW1xcclxcbl0rL2csIFwiIFwiKSB8fCBcIlwiO1xuICAgIGVsc2VcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICBwcm9jZXNzTm9kZShub2RlLmNoaWxkTm9kZXNbaV0pO1xuICB9XG4gIHJldHVybiBwcm9jZXNzTm9kZShkb2MuYm9keSksIGRvYztcbn07XG5jb25zdCBXT1JEX0hUTUxfUkVHRVggPSAvKGNsYXNzPVwiP01zb3xzdHlsZT0oPzpcInwnKVteXCJdKj9cXGJtc28tfHc6V29yZERvY3VtZW50fDxvOlxcdys+fDxcXC9mb250PikvLCB1bndhbnRlZFBhdGhzID0gW1xuICBcIi8vbzpwXCIsXG4gIFwiLy9zcGFuW0BzdHlsZT0nbXNvLWxpc3Q6SWdub3JlJ11cIixcbiAgXCIvL3NwYW5bQHN0eWxlPSdtc28tbGlzdDogSWdub3JlJ11cIlxuXSwgbWFwcGVkUGF0aHMgPSBbXG4gIFwiLy9wW0BjbGFzcz0nTXNvVG9jSGVhZGluZyddXCIsXG4gIFwiLy9wW0BjbGFzcz0nTXNvVGl0bGUnXVwiLFxuICBcIi8vcFtAY2xhc3M9J01zb1RvYUhlYWRpbmcnXVwiLFxuICBcIi8vcFtAY2xhc3M9J01zb1N1YnRpdGxlJ11cIixcbiAgXCIvL3NwYW5bQGNsYXNzPSdNc29TdWJ0bGVFbXBoYXNpcyddXCIsXG4gIFwiLy9zcGFuW0BjbGFzcz0nTXNvSW50ZW5zZUVtcGhhc2lzJ11cIlxuXSwgZWxlbWVudE1hcCA9IHtcbiAgTXNvVG9jSGVhZGluZzogW1wiaDNcIl0sXG4gIE1zb1RpdGxlOiBbXCJoMVwiXSxcbiAgTXNvVG9hSGVhZGluZzogW1wiaDJcIl0sXG4gIE1zb1N1YnRpdGxlOiBbXCJoNVwiXSxcbiAgTXNvU3VidGxlRW1waGFzaXM6IFtcInNwYW5cIiwgXCJlbVwiXSxcbiAgTXNvSW50ZW5zZUVtcGhhc2lzOiBbXCJzcGFuXCIsIFwiZW1cIiwgXCJzdHJvbmdcIl1cbiAgLy8gUmVtb3ZlIGNydWZ0XG59O1xuZnVuY3Rpb24gaXNXb3JkSHRtbChodG1sKSB7XG4gIHJldHVybiBXT1JEX0hUTUxfUkVHRVgudGVzdChodG1sKTtcbn1cbnZhciBwcmVwcm9jZXNzV29yZCA9IChodG1sLCBkb2MpID0+IHtcbiAgaWYgKCFpc1dvcmRIdG1sKGh0bWwpKVxuICAgIHJldHVybiBkb2M7XG4gIGNvbnN0IHVud2FudGVkTm9kZXMgPSBkb2MuZXZhbHVhdGUoXG4gICAgdW53YW50ZWRQYXRocy5qb2luKFwifFwiKSxcbiAgICBkb2MsXG4gICAgKHByZWZpeCkgPT4gcHJlZml4ID09PSBcIm9cIiA/IFwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTpvZmZpY2U6b2ZmaWNlXCIgOiBudWxsLFxuICAgIF9YUGF0aFJlc3VsdC5VTk9SREVSRURfTk9ERV9TTkFQU0hPVF9UWVBFLFxuICAgIG51bGxcbiAgKTtcbiAgZm9yIChsZXQgaSA9IHVud2FudGVkTm9kZXMuc25hcHNob3RMZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IHVud2FudGVkID0gdW53YW50ZWROb2Rlcy5zbmFwc2hvdEl0ZW0oaSk7XG4gICAgdW53YW50ZWQ/LnBhcmVudE5vZGUgJiYgdW53YW50ZWQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh1bndhbnRlZCk7XG4gIH1cbiAgY29uc3QgbWFwcGVkRWxlbWVudHMgPSBkb2MuZXZhbHVhdGUoXG4gICAgbWFwcGVkUGF0aHMuam9pbihcInxcIiksXG4gICAgZG9jLFxuICAgIG51bGwsXG4gICAgX1hQYXRoUmVzdWx0LlVOT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEUsXG4gICAgbnVsbFxuICApO1xuICBmb3IgKGxldCBpID0gbWFwcGVkRWxlbWVudHMuc25hcHNob3RMZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IG1hcHBlZEVsbSA9IG1hcHBlZEVsZW1lbnRzLnNuYXBzaG90SXRlbShpKSwgdGFncyA9IGVsZW1lbnRNYXBbbWFwcGVkRWxtLmNsYXNzTmFtZV0sIHRleHQgPSBkb2MuY3JlYXRlVGV4dE5vZGUobWFwcGVkRWxtLnRleHRDb250ZW50IHx8IFwiXCIpO1xuICAgIGlmICghdGFncylcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IHBhcmVudEVsZW1lbnQgPSBkb2MuY3JlYXRlRWxlbWVudCh0YWdzWzBdKTtcbiAgICBsZXQgcGFyZW50ID0gcGFyZW50RWxlbWVudCwgY2hpbGQgPSBwYXJlbnRFbGVtZW50O1xuICAgIHRhZ3Muc2xpY2UoMSkuZm9yRWFjaCgodGFnKSA9PiB7XG4gICAgICBjaGlsZCA9IGRvYy5jcmVhdGVFbGVtZW50KHRhZyksIHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZCksIHBhcmVudCA9IGNoaWxkO1xuICAgIH0pLCBjaGlsZC5hcHBlbmRDaGlsZCh0ZXh0KSwgbWFwcGVkRWxtPy5wYXJlbnROb2RlPy5yZXBsYWNlQ2hpbGQocGFyZW50RWxlbWVudCwgbWFwcGVkRWxtKTtcbiAgfVxuICByZXR1cm4gZG9jO1xufSwgcHJlcHJvY2Vzc29ycyA9IFtcbiAgcHJlcHJvY2Vzc1doaXRlc3BhY2UsXG4gIHByZXByb2Nlc3NOb3Rpb24sXG4gIHByZXByb2Nlc3NXb3JkLFxuICBwcmVwcm9jZXNzR0RvY3MsXG4gIHByZXByb2Nlc3NIVE1MXG5dO1xuZnVuY3Rpb24gdGFnTmFtZShlbCkge1xuICBpZiAoZWwgJiYgXCJ0YWdOYW1lXCIgaW4gZWwpXG4gICAgcmV0dXJuIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHByZXByb2Nlc3MoaHRtbCwgcGFyc2VIdG1sLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNsZWFuSFRNTCA9IE8oaHRtbCksIGRvYyA9IHBhcnNlSHRtbChub3JtYWxpemVIdG1sQmVmb3JlUHJlcHJvY2VzcyhjbGVhbkhUTUwpKTtcbiAgcmV0dXJuIHByZXByb2Nlc3NvcnMuZm9yRWFjaCgocHJvY2Vzc29yKSA9PiB7XG4gICAgcHJvY2Vzc29yKGNsZWFuSFRNTCwgZG9jLCBvcHRpb25zKTtcbiAgfSksIGRvYztcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUh0bWxCZWZvcmVQcmVwcm9jZXNzKGh0bWwpIHtcbiAgcmV0dXJuIGh0bWwudHJpbSgpO1xufVxuZnVuY3Rpb24gZGVmYXVsdFBhcnNlSHRtbCgpIHtcbiAgaWYgKHJlc29sdmVKc1R5cGUoRE9NUGFyc2VyKSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlRoZSBuYXRpdmUgYERPTVBhcnNlcmAgZ2xvYmFsIHdoaWNoIHRoZSBgSHRtbGAgZGVzZXJpYWxpemVyIHVzZXMgYnkgZGVmYXVsdCBpcyBub3QgcHJlc2VudCBpbiB0aGlzIGVudmlyb25tZW50LiBZb3UgbXVzdCBzdXBwbHkgdGhlIGBvcHRpb25zLnBhcnNlSHRtbGAgZnVuY3Rpb24gaW5zdGVhZC5cIlxuICAgICk7XG4gIHJldHVybiAoaHRtbCkgPT4gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhodG1sLCBcInRleHQvaHRtbFwiKTtcbn1cbmZ1bmN0aW9uIG5leHRTcGFuKGJsb2NrLCBpbmRleCkge1xuICBjb25zdCBuZXh0ID0gYmxvY2suY2hpbGRyZW5baW5kZXggKyAxXTtcbiAgcmV0dXJuIG5leHQgJiYgbmV4dC5fdHlwZSA9PT0gXCJzcGFuXCIgPyBuZXh0IDogbnVsbDtcbn1cbmZ1bmN0aW9uIHByZXZTcGFuKGJsb2NrLCBpbmRleCkge1xuICBjb25zdCBwcmV2ID0gYmxvY2suY2hpbGRyZW5baW5kZXggLSAxXTtcbiAgcmV0dXJuIHByZXYgJiYgcHJldi5fdHlwZSA9PT0gXCJzcGFuXCIgPyBwcmV2IDogbnVsbDtcbn1cbmZ1bmN0aW9uIGlzV2hpdGVTcGFjZUNoYXIodGV4dCkge1xuICByZXR1cm4gW1wiXFx4QTBcIiwgXCIgXCJdLmluY2x1ZGVzKHRleHQpO1xufVxuZnVuY3Rpb24gdHJpbVdoaXRlc3BhY2Uoc2NoZW1hLCBibG9ja3MpIHtcbiAgcmV0dXJuIGJsb2Nrcy5mb3JFYWNoKChibG9jaykgPT4ge1xuICAgIGlzVGV4dEJsb2NrKHsgc2NoZW1hIH0sIGJsb2NrKSAmJiBibG9jay5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgIGlmICghaXNNaW5pbWFsU3BhbihjaGlsZCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IG5leHRDaGlsZCA9IG5leHRTcGFuKGJsb2NrLCBpbmRleCksIHByZXZDaGlsZCA9IHByZXZTcGFuKGJsb2NrLCBpbmRleCk7XG4gICAgICBpbmRleCA9PT0gMCAmJiAoY2hpbGQudGV4dCA9IGNoaWxkLnRleHQucmVwbGFjZSgvXlteXFxTXFxuXSsvZywgXCJcIikpLCBpbmRleCA9PT0gYmxvY2suY2hpbGRyZW4ubGVuZ3RoIC0gMSAmJiAoY2hpbGQudGV4dCA9IGNoaWxkLnRleHQucmVwbGFjZSgvW15cXFNcXG5dKyQvZywgXCJcIikpLCAvXFxzLy50ZXN0KGNoaWxkLnRleHQuc2xpY2UoTWF0aC5tYXgoMCwgY2hpbGQudGV4dC5sZW5ndGggLSAxKSkpICYmIG5leHRDaGlsZCAmJiBpc01pbmltYWxTcGFuKG5leHRDaGlsZCkgJiYgL1xccy8udGVzdChuZXh0Q2hpbGQudGV4dC5zbGljZSgwLCAxKSkgJiYgKGNoaWxkLnRleHQgPSBjaGlsZC50ZXh0LnJlcGxhY2UoL1teXFxTXFxuXSskL2csIFwiXCIpKSwgL1xccy8udGVzdChjaGlsZC50ZXh0LnNsaWNlKDAsIDEpKSAmJiBwcmV2Q2hpbGQgJiYgaXNNaW5pbWFsU3BhbihwcmV2Q2hpbGQpICYmIC9cXHMvLnRlc3QocHJldkNoaWxkLnRleHQuc2xpY2UoTWF0aC5tYXgoMCwgcHJldkNoaWxkLnRleHQubGVuZ3RoIC0gMSkpKSAmJiAoY2hpbGQudGV4dCA9IGNoaWxkLnRleHQucmVwbGFjZSgvXlteXFxTXFxuXSsvZywgXCJcIikpLCBjaGlsZC50ZXh0IHx8IGJsb2NrLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSksIHByZXZDaGlsZCAmJiBpc0VxdWFsKHByZXZDaGlsZC5tYXJrcywgY2hpbGQubWFya3MpICYmIGlzV2hpdGVTcGFjZUNoYXIoY2hpbGQudGV4dCkgPyAocHJldkNoaWxkLnRleHQgKz0gXCIgXCIsIGJsb2NrLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSkpIDogbmV4dENoaWxkICYmIGlzRXF1YWwobmV4dENoaWxkLm1hcmtzLCBjaGlsZC5tYXJrcykgJiYgaXNXaGl0ZVNwYWNlQ2hhcihjaGlsZC50ZXh0KSAmJiAobmV4dENoaWxkLnRleHQgPSBgICR7bmV4dENoaWxkLnRleHR9YCwgYmxvY2suY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKSk7XG4gICAgfSk7XG4gIH0pLCBibG9ja3M7XG59XG5mdW5jdGlvbiBlbnN1cmVSb290SXNCbG9ja3Moc2NoZW1hLCBvYmplY3RzKSB7XG4gIHJldHVybiBvYmplY3RzLnJlZHVjZSgoYmxvY2tzLCBub2RlLCBpLCBvcmlnaW5hbCkgPT4ge1xuICAgIGlmIChub2RlLl90eXBlID09PSBcImJsb2NrXCIpXG4gICAgICByZXR1cm4gYmxvY2tzLnB1c2gobm9kZSksIGJsb2NrcztcbiAgICBpZiAobm9kZS5fdHlwZSA9PT0gXCJfX2Jsb2NrXCIpXG4gICAgICByZXR1cm4gYmxvY2tzLnB1c2gobm9kZS5ibG9jayksIGJsb2NrcztcbiAgICBjb25zdCBsYXN0QmxvY2sgPSBibG9ja3NbYmxvY2tzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChpID4gMCAmJiAhaXNUZXh0QmxvY2soeyBzY2hlbWEgfSwgb3JpZ2luYWxbaSAtIDFdKSAmJiBpc1RleHRCbG9jayh7IHNjaGVtYSB9LCBsYXN0QmxvY2spKVxuICAgICAgcmV0dXJuIGxhc3RCbG9jay5jaGlsZHJlbi5wdXNoKG5vZGUpLCBibG9ja3M7XG4gICAgY29uc3QgYmxvY2sgPSB7XG4gICAgICAuLi5ERUZBVUxUX0JMT0NLLFxuICAgICAgY2hpbGRyZW46IFtub2RlXVxuICAgIH07XG4gICAgcmV0dXJuIGJsb2Nrcy5wdXNoKGJsb2NrKSwgYmxvY2tzO1xuICB9LCBbXSk7XG59XG5mdW5jdGlvbiBpc05vZGVMaXN0KG5vZGUpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChub2RlKSA9PT0gXCJbb2JqZWN0IE5vZGVMaXN0XVwiO1xufVxuZnVuY3Rpb24gaXNNaW5pbWFsU3Bhbihub2RlKSB7XG4gIHJldHVybiBub2RlLl90eXBlID09PSBcInNwYW5cIjtcbn1cbmZ1bmN0aW9uIGlzTWluaW1hbEJsb2NrKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX3R5cGUgPT09IFwiYmxvY2tcIjtcbn1cbmZ1bmN0aW9uIGlzUGxhY2Vob2xkZXJEZWNvcmF0b3Iobm9kZSkge1xuICByZXR1cm4gbm9kZS5fdHlwZSA9PT0gXCJfX2RlY29yYXRvclwiO1xufVxuZnVuY3Rpb24gaXNQbGFjZWhvbGRlckFubm90YXRpb24obm9kZSkge1xuICByZXR1cm4gbm9kZS5fdHlwZSA9PT0gXCJfX2Fubm90YXRpb25cIjtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7XG4gIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAxO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplV2hpdGVzcGFjZShyb290Tm9kZSkge1xuICBsZXQgZW1wdHlCbG9ja0NvdW50ID0gMCwgbGFzdFBhcmVudCA9IG51bGw7XG4gIGNvbnN0IG5vZGVzVG9SZW1vdmUgPSBbXTtcbiAgZm9yIChsZXQgY2hpbGQgPSByb290Tm9kZS5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgIGlmICghaXNFbGVtZW50KGNoaWxkKSkge1xuICAgICAgbm9ybWFsaXplV2hpdGVzcGFjZShjaGlsZCksIGVtcHR5QmxvY2tDb3VudCA9IDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgZWxtID0gY2hpbGQ7XG4gICAgaXNXaGl0ZXNwYWNlQmxvY2soZWxtKSA/IChsYXN0UGFyZW50ICYmIGVsbS5wYXJlbnRFbGVtZW50ID09PSBsYXN0UGFyZW50ID8gKGVtcHR5QmxvY2tDb3VudCsrLCBlbXB0eUJsb2NrQ291bnQgPiAxICYmIG5vZGVzVG9SZW1vdmUucHVzaChlbG0pKSA6IGVtcHR5QmxvY2tDb3VudCA9IDEsIGxhc3RQYXJlbnQgPSBlbG0ucGFyZW50RWxlbWVudCkgOiAobm9ybWFsaXplV2hpdGVzcGFjZShjaGlsZCksIGVtcHR5QmxvY2tDb3VudCA9IDApO1xuICB9XG4gIG5vZGVzVG9SZW1vdmUuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgIG5vZGUucGFyZW50RWxlbWVudD8ucmVtb3ZlQ2hpbGQobm9kZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVtb3ZlQWxsV2hpdGVzcGFjZShyb290Tm9kZSkge1xuICBjb25zdCBub2Rlc1RvUmVtb3ZlID0gW107XG4gIGZ1bmN0aW9uIGNvbGxlY3ROb2Rlc1RvUmVtb3ZlKGN1cnJlbnROb2RlKSB7XG4gICAgaWYgKGlzRWxlbWVudChjdXJyZW50Tm9kZSkpIHtcbiAgICAgIGNvbnN0IGVsbSA9IGN1cnJlbnROb2RlO1xuICAgICAgaWYgKHRhZ05hbWUoZWxtKSA9PT0gXCJiclwiICYmICh0YWdOYW1lKGVsbS5uZXh0RWxlbWVudFNpYmxpbmcpID09PSBcInBcIiB8fCB0YWdOYW1lKGVsbS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSA9PT0gXCJwXCIpKSB7XG4gICAgICAgIG5vZGVzVG9SZW1vdmUucHVzaChlbG0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoKHRhZ05hbWUoZWxtKSA9PT0gXCJwXCIgfHwgdGFnTmFtZShlbG0pID09PSBcImJyXCIpICYmIGVsbT8uZmlyc3RDaGlsZD8udGV4dENvbnRlbnQ/LnRyaW0oKSA9PT0gXCJcIikge1xuICAgICAgICBub2Rlc1RvUmVtb3ZlLnB1c2goZWxtKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgY2hpbGQgPSBlbG0uZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpXG4gICAgICAgIGNvbGxlY3ROb2Rlc1RvUmVtb3ZlKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgY29sbGVjdE5vZGVzVG9SZW1vdmUocm9vdE5vZGUpLCBub2Rlc1RvUmVtb3ZlLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICBub2RlLnBhcmVudEVsZW1lbnQ/LnJlbW92ZUNoaWxkKG5vZGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZUJsb2NrKGVsbSkge1xuICByZXR1cm4gW1wicFwiLCBcImJyXCJdLmluY2x1ZGVzKHRhZ05hbWUoZWxtKSB8fCBcIlwiKSAmJiAhZWxtLnRleHRDb250ZW50Py50cmltKCk7XG59XG5leHBvcnQge1xuICBCTE9DS19ERUZBVUxUX1NUWUxFLFxuICBERUZBVUxUX0JMT0NLLFxuICBERUZBVUxUX1NQQU4sXG4gIEhUTUxfQkxPQ0tfVEFHUyxcbiAgSFRNTF9ERUNPUkFUT1JfVEFHUyxcbiAgSFRNTF9IRUFERVJfVEFHUyxcbiAgSFRNTF9MSVNUX0NPTlRBSU5FUl9UQUdTLFxuICBIVE1MX0xJU1RfSVRFTV9UQUdTLFxuICBIVE1MX1NQQU5fVEFHUyxcbiAgZGVmYXVsdFBhcnNlSHRtbCxcbiAgZW5zdXJlUm9vdElzQmxvY2tzLFxuICBmbGF0dGVuTmVzdGVkQmxvY2tzLFxuICBpc0VsZW1lbnQsXG4gIGlzTWluaW1hbEJsb2NrLFxuICBpc01pbmltYWxTcGFuLFxuICBpc05vZGVMaXN0LFxuICBpc1BsYWNlaG9sZGVyQW5ub3RhdGlvbixcbiAgaXNQbGFjZWhvbGRlckRlY29yYXRvcixcbiAgcHJlcHJvY2VzcyxcbiAgcmVzb2x2ZUpzVHlwZSxcbiAgdGFnTmFtZSxcbiAgdHJpbVdoaXRlc3BhY2Vcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@portabletext/block-tools/lib/_chunks-es/helpers.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@portabletext/block-tools/lib/index.js":
/*!**************************************************************!*\
  !*** ../node_modules/@portabletext/block-tools/lib/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   htmlToBlocks: () => (/* binding */ htmlToBlocks),\n/* harmony export */   normalizeBlock: () => (/* binding */ normalizeBlock),\n/* harmony export */   randomKey: () => (/* binding */ randomKey)\n/* harmony export */ });\n/* harmony import */ var _portabletext_sanity_bridge__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @portabletext/sanity-bridge */ \"(ssr)/../node_modules/@portabletext/sanity-bridge/dist/index.js\");\n/* harmony import */ var _portabletext_schema__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @portabletext/schema */ \"(ssr)/../node_modules/@portabletext/schema/dist/index.js\");\n/* harmony import */ var lodash_flatten_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/flatten.js */ \"(ssr)/../node_modules/lodash/flatten.js\");\n/* harmony import */ var get_random_values_esm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! get-random-values-esm */ \"(ssr)/../node_modules/get-random-values-esm/index.mjs\");\n/* harmony import */ var _chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_chunks-es/helpers.js */ \"(ssr)/../node_modules/@portabletext/block-tools/lib/_chunks-es/helpers.js\");\n/* harmony import */ var lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isEqual.js */ \"(ssr)/../node_modules/lodash/isEqual.js\");\n\n\n\n\n\n\nfunction keyGenerator() {\n  return randomKey(12);\n}\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length);\n  return (0,get_random_values_esm__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(rnds8), rnds8;\n}\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i)\n  byteToHex[i] = (i + 256).toString(16).slice(1);\nfunction randomKey(length) {\n  return whatwgRNG(length).reduce((str, n) => str + byteToHex[n], \"\").slice(0, length);\n}\nconst LIST_CONTAINER_TAGS = Object.keys(_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.HTML_LIST_CONTAINER_TAGS);\nfunction isEmphasis$1(el) {\n  const style = (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isElement)(el) && el.getAttribute(\"style\");\n  return /font-style\\s*:\\s*italic/.test(style || \"\");\n}\nfunction isStrong$1(el) {\n  const style = (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isElement)(el) && el.getAttribute(\"style\");\n  return /font-weight\\s*:\\s*700/.test(style || \"\");\n}\nfunction isUnderline$1(el) {\n  if (!(0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isElement)(el) || (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(el.parentNode) === \"a\")\n    return !1;\n  const style = (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isElement)(el) && el.getAttribute(\"style\");\n  return /text-decoration\\s*:\\s*underline/.test(style || \"\");\n}\nfunction isStrikethrough(el) {\n  const style = (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isElement)(el) && el.getAttribute(\"style\");\n  return /text-decoration\\s*:\\s*(?:.*line-through.*;)/.test(style || \"\");\n}\nfunction isGoogleDocs(el) {\n  return (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isElement)(el) && !!el.getAttribute(\"data-is-google-docs\");\n}\nfunction isRootNode(el) {\n  return (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isElement)(el) && !!el.getAttribute(\"data-is-root-node\");\n}\nfunction getListItemStyle$1(el) {\n  const parentTag = (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(el.parentNode);\n  if (!(parentTag && !LIST_CONTAINER_TAGS.includes(parentTag)))\n    return (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(el.parentNode) === \"ul\" ? \"bullet\" : \"number\";\n}\nfunction getListItemLevel$1(el) {\n  let level = 0;\n  if ((0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(el) === \"li\") {\n    let parentNode = el.parentNode;\n    for (; parentNode; ) {\n      const parentTag = (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(parentNode);\n      parentTag && LIST_CONTAINER_TAGS.includes(parentTag) && level++, parentNode = parentNode.parentNode;\n    }\n  } else\n    level = 1;\n  return level;\n}\nconst blocks = {\n  ..._chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.HTML_BLOCK_TAGS,\n  ..._chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.HTML_HEADER_TAGS\n};\nfunction getBlockStyle(schema, el) {\n  const childTag = (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(el.firstChild), block = childTag && blocks[childTag];\n  return block ? schema.styles.some((style) => style.name === block.style) ? block.style : _chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.BLOCK_DEFAULT_STYLE : _chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.BLOCK_DEFAULT_STYLE;\n}\nfunction createGDocsRules(schema) {\n  return [\n    {\n      deserialize(el, next) {\n        if ((0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isElement)(el) && (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(el) === \"span\" && isGoogleDocs(el)) {\n          if (!el.textContent)\n            return !el.previousSibling && !el.nextSibling && el.setAttribute(\"data-lonely-child\", \"true\"), next(el.childNodes);\n          const span = {\n            ..._chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_SPAN,\n            marks: [],\n            text: el.textContent\n          };\n          return isStrong$1(el) && span.marks.push(\"strong\"), isUnderline$1(el) && span.marks.push(\"underline\"), isStrikethrough(el) && span.marks.push(\"strike-through\"), isEmphasis$1(el) && span.marks.push(\"em\"), span;\n        }\n      }\n    },\n    {\n      deserialize(el, next) {\n        if ((0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(el) === \"li\" && isGoogleDocs(el))\n          return {\n            ..._chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_BLOCK,\n            listItem: getListItemStyle$1(el),\n            level: getListItemLevel$1(el),\n            style: getBlockStyle(schema, el),\n            children: next(el.firstChild?.childNodes || [])\n          };\n      }\n    },\n    {\n      deserialize(el) {\n        if ((0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(el) === \"br\" && isGoogleDocs(el) && (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isElement)(el) && el.classList.contains(\"apple-interchange-newline\"))\n          return {\n            ..._chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_SPAN,\n            text: \"\"\n          };\n        if ((0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(el) === \"br\" && isGoogleDocs(el) && (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isElement)(el) && el?.parentNode?.textContent === \"\")\n          return {\n            ..._chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_SPAN,\n            text: \"\"\n          };\n        if ((0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(el) === \"br\" && isGoogleDocs(el) && (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isElement)(el) && isRootNode(el))\n          return {\n            ..._chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_SPAN,\n            text: \"\"\n          };\n      }\n    }\n  ];\n}\nconst whitespaceTextNodeRule = {\n  deserialize(node) {\n    return node.nodeName === \"#text\" && isWhitespaceTextNode(node) ? {\n      ..._chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_SPAN,\n      marks: [],\n      text: (node.textContent ?? \"\").replace(/\\s\\s+/g, \" \")\n    } : void 0;\n  }\n};\nfunction isWhitespaceTextNode(node) {\n  return (node.nodeType === 3 && (node.textContent || \"\").replace(/[\\r\\n]/g, \" \").replace(/\\s\\s+/g, \" \") === \" \" && node.nextSibling && node.nextSibling.nodeType !== 3 && node.previousSibling && node.previousSibling.nodeType !== 3 || node.textContent !== \" \") && (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(node.parentNode) !== \"body\";\n}\nfunction resolveListItem(schema, listNodeTagName) {\n  if (listNodeTagName === \"ul\" && schema.lists.some((list) => list.name === \"bullet\"))\n    return \"bullet\";\n  if (listNodeTagName === \"ol\" && schema.lists.some((list) => list.name === \"number\"))\n    return \"number\";\n}\nfunction createHTMLRules(schema, options) {\n  return [\n    whitespaceTextNodeRule,\n    {\n      // Pre element\n      deserialize(el) {\n        if ((0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(el) !== \"pre\")\n          return;\n        const isCodeEnabled = schema.styles.some(\n          (style) => style.name === \"code\"\n        );\n        return {\n          _type: \"block\",\n          style: \"normal\",\n          markDefs: [],\n          children: [\n            {\n              ..._chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_SPAN,\n              marks: isCodeEnabled ? [\"code\"] : [],\n              text: el.textContent || \"\"\n            }\n          ]\n        };\n      }\n    },\n    // Blockquote element\n    {\n      deserialize(el, next) {\n        if ((0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(el) !== \"blockquote\")\n          return;\n        const blocks2 = {\n          ..._chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.HTML_BLOCK_TAGS,\n          ..._chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.HTML_HEADER_TAGS\n        };\n        delete blocks2.blockquote;\n        const nonBlockquoteBlocks = Object.keys(blocks2), children = [];\n        return el.childNodes.forEach((node, index) => {\n          if (el.ownerDocument)\n            if (node.nodeType === 1 && nonBlockquoteBlocks.includes(\n              node.localName.toLowerCase()\n            )) {\n              const span = el.ownerDocument.createElement(\"span\"), previousChild = children[children.length - 1];\n              previousChild && previousChild.nodeType === 3 && previousChild.textContent?.trim() && span.appendChild(el.ownerDocument.createTextNode(\"\\r\")), node.childNodes.forEach((cn) => {\n                span.appendChild(cn.cloneNode(!0));\n              }), index !== el.childNodes.length && span.appendChild(el.ownerDocument.createTextNode(\"\\r\")), children.push(span);\n            } else\n              children.push(node);\n        }), {\n          _type: \"block\",\n          style: \"blockquote\",\n          markDefs: [],\n          children: next(children)\n        };\n      }\n    },\n    // Block elements\n    {\n      deserialize(el, next) {\n        const blocks2 = {\n          ..._chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.HTML_BLOCK_TAGS,\n          ..._chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.HTML_HEADER_TAGS\n        }, tag = (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(el);\n        let block = tag ? blocks2[tag] : void 0;\n        if (!block)\n          return;\n        if (el.parentNode && (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(el.parentNode) === \"li\")\n          return next(el.childNodes);\n        const blockStyle = block.style;\n        return schema.styles.some((style) => style.name === blockStyle) || (block = _chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_BLOCK), {\n          ...block,\n          children: next(el.childNodes)\n        };\n      }\n    },\n    // Ignore span tags\n    {\n      deserialize(el, next) {\n        const tag = (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(el);\n        if (!(!tag || !(tag in _chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.HTML_SPAN_TAGS)))\n          return next(el.childNodes);\n      }\n    },\n    // Ignore div tags\n    {\n      deserialize(el, next) {\n        if ((0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(el) === \"div\")\n          return next(el.childNodes);\n      }\n    },\n    // Ignore list containers\n    {\n      deserialize(el, next) {\n        const tag = (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(el);\n        if (!(!tag || !(tag in _chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.HTML_LIST_CONTAINER_TAGS)))\n          return next(el.childNodes);\n      }\n    },\n    // Deal with br's\n    {\n      deserialize(el) {\n        if ((0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(el) === \"br\")\n          return {\n            ..._chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_SPAN,\n            text: `\n`\n          };\n      }\n    },\n    // Deal with list items\n    {\n      deserialize(el, next, block) {\n        const tag = (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(el), listItem = tag ? _chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.HTML_LIST_ITEM_TAGS[tag] : void 0, parentTag = (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(el.parentNode) || \"\";\n        if (!listItem || !el.parentNode || !_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.HTML_LIST_CONTAINER_TAGS[parentTag])\n          return;\n        const enabledListItem = resolveListItem(schema, parentTag);\n        return enabledListItem ? (listItem.listItem = enabledListItem, {\n          ...listItem,\n          children: next(el.childNodes)\n        }) : block({ _type: \"block\", children: next(el.childNodes) });\n      }\n    },\n    // Deal with decorators - this is a limited set of known html elements that we know how to deserialize\n    {\n      deserialize(el, next) {\n        const decorator = _chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.HTML_DECORATOR_TAGS[(0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(el) || \"\"];\n        if (!(!decorator || !schema.decorators.some(\n          (decoratorType) => decoratorType.name === decorator\n        )))\n          return {\n            _type: \"__decorator\",\n            name: decorator,\n            children: next(el.childNodes)\n          };\n      }\n    },\n    // Special case for hyperlinks, add annotation (if allowed by schema),\n    // If not supported just write out the link text and href in plain text.\n    {\n      deserialize(el, next) {\n        if ((0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(el) !== \"a\")\n          return;\n        const linkEnabled = schema.annotations.some(\n          (annotation) => annotation.name === \"link\"\n        ), href = (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isElement)(el) && el.getAttribute(\"href\");\n        return href ? linkEnabled ? {\n          _type: \"__annotation\",\n          markDef: {\n            _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n            _type: \"link\",\n            href\n          },\n          children: next(el.childNodes)\n        } : el.appendChild(el.ownerDocument.createTextNode(` (${href})`)) && next(el.childNodes) : next(el.childNodes);\n      }\n    },\n    {\n      deserialize(el, next) {\n        if ((0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isElement)(el) && ((0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(el) === \"td\" || (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(el) === \"th\"))\n          return {\n            ..._chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_BLOCK,\n            children: next(el.childNodes)\n          };\n      }\n    },\n    {\n      deserialize(el) {\n        if ((0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isElement)(el) && (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(el) === \"img\") {\n          const src = el.getAttribute(\"src\") ?? void 0, alt = el.getAttribute(\"alt\") ?? void 0, props = Object.fromEntries(\n            Array.from(el.attributes).map((attr) => [attr.name, attr.value])\n          ), ancestorOfLonelyChild = el?.parentElement?.parentElement?.getAttribute(\"data-lonely-child\"), ancestorOfListItem = el.closest(\"li\") !== null;\n          if (ancestorOfLonelyChild && !ancestorOfListItem) {\n            const image2 = options.matchers?.image?.({\n              context: {\n                schema,\n                keyGenerator: options.keyGenerator ?? keyGenerator\n              },\n              props: {\n                ...props,\n                ...src ? { src } : {},\n                ...alt ? { alt } : {}\n              }\n            });\n            if (image2)\n              return {\n                _type: \"__block\",\n                block: image2\n              };\n          }\n          const inlineImage = options.matchers?.inlineImage?.({\n            context: {\n              schema,\n              keyGenerator: options.keyGenerator ?? keyGenerator\n            },\n            props: {\n              ...props,\n              ...src ? { src } : {},\n              ...alt ? { alt } : {}\n            }\n          });\n          if (inlineImage)\n            return inlineImage;\n          const image = options.matchers?.image?.({\n            context: {\n              schema,\n              keyGenerator: options.keyGenerator ?? keyGenerator\n            },\n            props: {\n              ...props,\n              ...src ? { src } : {},\n              ...alt ? { alt } : {}\n            }\n          });\n          if (image)\n            return {\n              _type: \"__block\",\n              block: image\n            };\n        }\n      }\n    }\n  ];\n}\nfunction isEmphasis(el) {\n  const style = (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isElement)(el) && el.getAttribute(\"style\");\n  return /font-style:italic/.test(style || \"\");\n}\nfunction isStrong(el) {\n  const style = (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isElement)(el) && el.getAttribute(\"style\");\n  return /font-weight:700/.test(style || \"\") || /font-weight:600/.test(style || \"\");\n}\nfunction isUnderline(el) {\n  const style = (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isElement)(el) && el.getAttribute(\"style\");\n  return /text-decoration:underline/.test(style || \"\");\n}\nfunction isNotion(el) {\n  return (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isElement)(el) && !!el.getAttribute(\"data-is-notion\");\n}\nfunction createNotionRules() {\n  return [\n    {\n      deserialize(el) {\n        if ((0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isElement)(el) && (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(el) === \"span\" && isNotion(el)) {\n          const span = {\n            ..._chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_SPAN,\n            marks: [],\n            text: el.textContent\n          };\n          return isStrong(el) && span.marks.push(\"strong\"), isUnderline(el) && span.marks.push(\"underline\"), isEmphasis(el) && span.marks.push(\"em\"), span;\n        }\n      }\n    }\n  ];\n}\nfunction getListItemStyle(el) {\n  const style = (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isElement)(el) && el.getAttribute(\"style\");\n  if (style && style.match(/lfo\\d+/))\n    return style.match(\"lfo1\") ? \"bullet\" : \"number\";\n}\nfunction getListItemLevel(el) {\n  const style = (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isElement)(el) && el.getAttribute(\"style\");\n  if (!style)\n    return;\n  const levelMatch = style.match(/level\\d+/);\n  if (!levelMatch)\n    return;\n  const [level] = levelMatch[0].match(/\\d/) || [];\n  return (level ? Number.parseInt(level, 10) : 1) || 1;\n}\nfunction isWordListElement(el) {\n  return (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isElement)(el) && el.className ? el.className === \"MsoListParagraphCxSpFirst\" || el.className === \"MsoListParagraphCxSpMiddle\" || el.className === \"MsoListParagraphCxSpLast\" : !1;\n}\nfunction createWordRules() {\n  return [\n    {\n      deserialize(el, next) {\n        if ((0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(el) === \"p\" && isWordListElement(el))\n          return {\n            ..._chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_BLOCK,\n            listItem: getListItemStyle(el),\n            level: getListItemLevel(el),\n            style: _chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.BLOCK_DEFAULT_STYLE,\n            children: next(el.childNodes)\n          };\n      }\n    }\n  ];\n}\nfunction createRules(schema, options) {\n  return [\n    ...createWordRules(),\n    ...createNotionRules(),\n    ...createGDocsRules(schema),\n    ...createHTMLRules(schema, options)\n  ];\n}\nclass HtmlDeserializer {\n  keyGenerator;\n  schema;\n  rules;\n  parseHtml;\n  _markDefs = [];\n  /**\n   * Create a new serializer respecting a Sanity block content type's schema\n   *\n   * @param blockContentType - Schema type for array containing _at least_ a block child type\n   * @param options - Options for the deserialization process\n   */\n  constructor(schema, options = {}) {\n    const { rules = [], unstable_whitespaceOnPasteMode = \"preserve\" } = options, standardRules = createRules(schema, {\n      keyGenerator: options.keyGenerator,\n      matchers: options.matchers\n    });\n    this.schema = schema, this.keyGenerator = options.keyGenerator ?? keyGenerator, this.rules = [...rules, ...standardRules];\n    const parseHtml = options.parseHtml || (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.defaultParseHtml)();\n    this.parseHtml = (html) => (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.preprocess)(html, parseHtml, { unstable_whitespaceOnPasteMode }).body;\n  }\n  /**\n   * Deserialize HTML.\n   *\n   * @param html - The HTML to deserialize, as a string\n   * @returns Array of blocks - either portable text blocks or other allowed blocks\n   */\n  deserialize = (html) => {\n    this._markDefs = [];\n    const { parseHtml } = this, fragment = parseHtml(html), children = Array.from(fragment.childNodes), blocks2 = (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.trimWhitespace)(\n      this.schema,\n      (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.flattenNestedBlocks)(\n        { schema: this.schema },\n        (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.ensureRootIsBlocks)(\n          this.schema,\n          this.deserializeElements(children)\n        )\n      )\n    );\n    return this._markDefs.length > 0 && blocks2.filter((block) => (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_4__.isTextBlock)({ schema: this.schema }, block)).forEach((block) => {\n      block.markDefs = block.markDefs || [], block.markDefs = block.markDefs.concat(\n        this._markDefs.filter((def) => lodash_flatten_js__WEBPACK_IMPORTED_MODULE_0__(\n          block.children.map((child) => child.marks || [])\n        ).includes(def._key))\n      );\n    }), blocks2.map((block) => (block._type === \"block\" && (block._type = this.schema.block.name), block));\n  };\n  /**\n   * Deserialize an array of DOM elements.\n   *\n   * @param elements - Array of DOM elements to deserialize\n   * @returns\n   */\n  deserializeElements = (elements = []) => {\n    let nodes = [];\n    return elements.forEach((element) => {\n      nodes = nodes.concat(this.deserializeElement(element));\n    }), nodes;\n  };\n  /**\n   * Deserialize a DOM element\n   *\n   * @param element - Deserialize a DOM element\n   * @returns\n   */\n  deserializeElement = (element) => {\n    const next = (elements) => {\n      if ((0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isNodeList)(elements))\n        return this.deserializeElements(Array.from(elements));\n      if (Array.isArray(elements))\n        return this.deserializeElements(elements);\n      if (elements)\n        return this.deserializeElement(elements);\n    }, block = (props) => ({\n      _type: \"__block\",\n      block: props\n    });\n    let node;\n    for (let i = 0; i < this.rules.length; i++) {\n      const rule = this.rules[i];\n      if (!rule.deserialize)\n        continue;\n      const ret = rule.deserialize(element, next, block), type = (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.resolveJsType)(ret);\n      if (type !== \"array\" && type !== \"object\" && type !== \"null\" && type !== \"undefined\")\n        throw new Error(\n          `A rule returned an invalid deserialized representation: \"${node}\".`\n        );\n      if (ret !== void 0) {\n        {\n          if (ret === null)\n            throw new Error(\"Deserializer rule returned `null`\");\n          Array.isArray(ret) ? node = ret : (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isPlaceholderDecorator)(ret) ? node = this.deserializeDecorator(ret) : (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isPlaceholderAnnotation)(ret) ? node = this.deserializeAnnotation(ret) : node = ret;\n        }\n        if (ret && !Array.isArray(ret) && (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isMinimalBlock)(ret) && \"listItem\" in ret) {\n          let parent = element.parentNode?.parentNode;\n          for (; parent && (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.tagName)(parent) === \"li\"; )\n            parent = parent.parentNode?.parentNode, ret.level = ret.level ? ret.level + 1 : 1;\n        }\n        ret && !Array.isArray(ret) && (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isMinimalBlock)(ret) && ret.style === \"blockquote\" && ret.children.forEach((child, index) => {\n          (0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isMinimalSpan)(child) && child.text === \"\\r\" && (child.text = `\n`, (index === 0 || index === ret.children.length - 1) && ret.children.splice(index, 1));\n        });\n        break;\n      }\n    }\n    return node || next(element.childNodes) || [];\n  };\n  /**\n   * Deserialize a `__decorator` type\n   * (an internal made up type to process decorators exclusively)\n   *\n   * @param decorator -\n   * @returns array of ...\n   */\n  deserializeDecorator = (decorator) => {\n    const { name } = decorator, applyDecorator = (node) => {\n      if ((0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isPlaceholderDecorator)(node))\n        return this.deserializeDecorator(node);\n      if ((0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isMinimalSpan)(node))\n        node.marks = node.marks || [], node.text.trim() && node.marks.unshift(name);\n      else if (\"children\" in node && Array.isArray(node.children)) {\n        const block = node;\n        block.children = block.children.map(applyDecorator);\n      }\n      return node;\n    };\n    return decorator.children.reduce((children, node) => {\n      const ret = applyDecorator(node);\n      return Array.isArray(ret) ? children.concat(ret) : (children.push(ret), children);\n    }, []);\n  };\n  /**\n   * Deserialize a `__annotation` object.\n   * (an internal made up type to process annotations exclusively)\n   *\n   * @param annotation -\n   * @returns Array of...\n   */\n  deserializeAnnotation = (annotation) => {\n    const { markDef } = annotation;\n    this._markDefs.push(markDef);\n    const applyAnnotation = (node) => {\n      if ((0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isPlaceholderAnnotation)(node))\n        return this.deserializeAnnotation(node);\n      if ((0,_chunks_es_helpers_js__WEBPACK_IMPORTED_MODULE_3__.isMinimalSpan)(node))\n        node.marks = node.marks || [], node.text.trim() && node.marks.unshift(markDef._key);\n      else if (\"children\" in node && Array.isArray(node.children)) {\n        const block = node;\n        block.children = block.children.map(applyAnnotation);\n      }\n      return node;\n    };\n    return annotation.children.reduce((children, node) => {\n      const ret = applyAnnotation(node);\n      return Array.isArray(ret) ? children.concat(ret) : (children.push(ret), children);\n    }, []);\n  };\n}\nfunction normalizeBlock(node, options = {}) {\n  const schema = {\n    block: {\n      name: options.blockTypeName || \"block\"\n    },\n    span: {\n      name: \"span\"\n    },\n    styles: [],\n    lists: [],\n    decorators: [],\n    annotations: [],\n    blockObjects: [],\n    inlineObjects: []\n  };\n  if (node._type !== (options.blockTypeName || \"block\"))\n    return \"_key\" in node ? node : {\n      ...node,\n      _key: options.keyGenerator ? options.keyGenerator() : keyGenerator()\n    };\n  const block = {\n    _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n    children: [],\n    markDefs: [],\n    ...node\n  }, lastChild = block.children[block.children.length - 1];\n  if (!lastChild)\n    return block.children = [\n      {\n        _type: \"span\",\n        _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n        text: \"\",\n        marks: []\n      }\n    ], block;\n  const usedMarkDefs = [], allowedDecorators = options.allowedDecorators && Array.isArray(options.allowedDecorators) ? options.allowedDecorators : !1;\n  return block.children = block.children.reduce(\n    (acc, child) => {\n      const previousChild = acc[acc.length - 1];\n      return previousChild && (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_4__.isSpan)({ schema }, child) && (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_4__.isSpan)({ schema }, previousChild) && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(previousChild.marks, child.marks) ? (lastChild && lastChild === child && child.text === \"\" && block.children.length > 1 || (previousChild.text += child.text), acc) : (acc.push(child), acc);\n    },\n    []\n  ).map((child) => {\n    if (!child)\n      throw new Error(\"missing child\");\n    return child._key = options.keyGenerator ? options.keyGenerator() : keyGenerator(), (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_4__.isSpan)({ schema }, child) && (child.marks ? allowedDecorators && (child.marks = child.marks.filter((mark) => {\n      const isAllowed = allowedDecorators.includes(mark), isUsed = block.markDefs?.some((def) => def._key === mark);\n      return isAllowed || isUsed;\n    })) : child.marks = [], usedMarkDefs.push(...child.marks)), child;\n  }), block.markDefs = (block.markDefs || []).filter(\n    (markDef) => usedMarkDefs.includes(markDef._key)\n  ), block;\n}\nfunction htmlToBlocks(html, schemaType, options = {}) {\n  const schema = isSanitySchema(schemaType) ? (0,_portabletext_sanity_bridge__WEBPACK_IMPORTED_MODULE_5__.sanitySchemaToPortableTextSchema)(schemaType) : schemaType;\n  return new HtmlDeserializer(schema, options).deserialize(html).map((block) => normalizeBlock(block, { keyGenerator: options.keyGenerator }));\n}\nfunction isSanitySchema(schema) {\n  return schema.hasOwnProperty(\"jsonType\");\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvYmxvY2stdG9vbHMvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUErRTtBQUNwQjtBQUNuQjtBQUNZO0FBQ29YO0FBQ2hZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlFQUFlO0FBQ3hCO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywyRUFBd0I7QUFDaEU7QUFDQSxnQkFBZ0IsZ0VBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdFQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLE9BQU8sZ0VBQVMsUUFBUSw4REFBTztBQUMvQjtBQUNBLGdCQUFnQixnRUFBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0VBQVM7QUFDekIsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQSxTQUFTLGdFQUFTO0FBQ2xCO0FBQ0E7QUFDQSxTQUFTLGdFQUFTO0FBQ2xCO0FBQ0E7QUFDQSxvQkFBb0IsOERBQU87QUFDM0I7QUFDQSxXQUFXLDhEQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLE1BQU0sOERBQU87QUFDYjtBQUNBLFdBQVcsWUFBWTtBQUN2Qix3QkFBd0IsOERBQU87QUFDL0I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssa0VBQWU7QUFDcEIsS0FBSyxtRUFBZ0I7QUFDckI7QUFDQTtBQUNBLG1CQUFtQiw4REFBTztBQUMxQiwyRkFBMkYsc0VBQW1CLEdBQUcsc0VBQW1CO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdFQUFTLFFBQVEsOERBQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrREFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksOERBQU87QUFDbkI7QUFDQSxl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LE9BQU87QUFDbkIsVUFBVSw2RUFBc0I7QUFDaEM7QUFDQSxVQUFVLG9FQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0EsVUFBVSw4RUFBdUI7QUFDakM7QUFDQSxVQUFVLG9FQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw0REFBTSxHQUFHLFFBQVEsWUFBWSw0REFBTSxHQUFHLFFBQVEsb0JBQW9CLDhDQUFPO0FBQ3ZHLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3Riw0REFBTSxHQUFHLFFBQVE7QUFDekc7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELDhDQUE4Qyw2RkFBZ0M7QUFDOUUsd0dBQXdHLG9DQUFvQztBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUtFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9HYWxvY2svQ1MvYmVob21lLXNpdGUvbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvYmxvY2stdG9vbHMvbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNhbml0eVNjaGVtYVRvUG9ydGFibGVUZXh0U2NoZW1hIH0gZnJvbSBcIkBwb3J0YWJsZXRleHQvc2FuaXR5LWJyaWRnZVwiO1xuaW1wb3J0IHsgaXNUZXh0QmxvY2ssIGlzU3BhbiB9IGZyb20gXCJAcG9ydGFibGV0ZXh0L3NjaGVtYVwiO1xuaW1wb3J0IGZsYXR0ZW4gZnJvbSBcImxvZGFzaC9mbGF0dGVuLmpzXCI7XG5pbXBvcnQgZ2V0UmFuZG9tVmFsdWVzIGZyb20gXCJnZXQtcmFuZG9tLXZhbHVlcy1lc21cIjtcbmltcG9ydCB7IGlzRWxlbWVudCwgdGFnTmFtZSwgREVGQVVMVF9TUEFOLCBERUZBVUxUX0JMT0NLLCBIVE1MX0hFQURFUl9UQUdTLCBIVE1MX0JMT0NLX1RBR1MsIEJMT0NLX0RFRkFVTFRfU1RZTEUsIEhUTUxfTElTVF9DT05UQUlORVJfVEFHUywgSFRNTF9TUEFOX1RBR1MsIEhUTUxfTElTVF9JVEVNX1RBR1MsIEhUTUxfREVDT1JBVE9SX1RBR1MsIGRlZmF1bHRQYXJzZUh0bWwsIHByZXByb2Nlc3MsIHRyaW1XaGl0ZXNwYWNlLCBmbGF0dGVuTmVzdGVkQmxvY2tzLCBlbnN1cmVSb290SXNCbG9ja3MsIHJlc29sdmVKc1R5cGUsIGlzUGxhY2Vob2xkZXJEZWNvcmF0b3IsIGlzUGxhY2Vob2xkZXJBbm5vdGF0aW9uLCBpc01pbmltYWxCbG9jaywgaXNNaW5pbWFsU3BhbiwgaXNOb2RlTGlzdCB9IGZyb20gXCIuL19jaHVua3MtZXMvaGVscGVycy5qc1wiO1xuaW1wb3J0IGlzRXF1YWwgZnJvbSBcImxvZGFzaC9pc0VxdWFsLmpzXCI7XG5mdW5jdGlvbiBrZXlHZW5lcmF0b3IoKSB7XG4gIHJldHVybiByYW5kb21LZXkoMTIpO1xufVxuZnVuY3Rpb24gd2hhdHdnUk5HKGxlbmd0aCA9IDE2KSB7XG4gIGNvbnN0IHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgcmV0dXJuIGdldFJhbmRvbVZhbHVlcyhybmRzOCksIHJuZHM4O1xufVxuY29uc3QgYnl0ZVRvSGV4ID0gW107XG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgKytpKVxuICBieXRlVG9IZXhbaV0gPSAoaSArIDI1NikudG9TdHJpbmcoMTYpLnNsaWNlKDEpO1xuZnVuY3Rpb24gcmFuZG9tS2V5KGxlbmd0aCkge1xuICByZXR1cm4gd2hhdHdnUk5HKGxlbmd0aCkucmVkdWNlKChzdHIsIG4pID0+IHN0ciArIGJ5dGVUb0hleFtuXSwgXCJcIikuc2xpY2UoMCwgbGVuZ3RoKTtcbn1cbmNvbnN0IExJU1RfQ09OVEFJTkVSX1RBR1MgPSBPYmplY3Qua2V5cyhIVE1MX0xJU1RfQ09OVEFJTkVSX1RBR1MpO1xuZnVuY3Rpb24gaXNFbXBoYXNpcyQxKGVsKSB7XG4gIGNvbnN0IHN0eWxlID0gaXNFbGVtZW50KGVsKSAmJiBlbC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgcmV0dXJuIC9mb250LXN0eWxlXFxzKjpcXHMqaXRhbGljLy50ZXN0KHN0eWxlIHx8IFwiXCIpO1xufVxuZnVuY3Rpb24gaXNTdHJvbmckMShlbCkge1xuICBjb25zdCBzdHlsZSA9IGlzRWxlbWVudChlbCkgJiYgZWwuZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XG4gIHJldHVybiAvZm9udC13ZWlnaHRcXHMqOlxccyo3MDAvLnRlc3Qoc3R5bGUgfHwgXCJcIik7XG59XG5mdW5jdGlvbiBpc1VuZGVybGluZSQxKGVsKSB7XG4gIGlmICghaXNFbGVtZW50KGVsKSB8fCB0YWdOYW1lKGVsLnBhcmVudE5vZGUpID09PSBcImFcIilcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IHN0eWxlID0gaXNFbGVtZW50KGVsKSAmJiBlbC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgcmV0dXJuIC90ZXh0LWRlY29yYXRpb25cXHMqOlxccyp1bmRlcmxpbmUvLnRlc3Qoc3R5bGUgfHwgXCJcIik7XG59XG5mdW5jdGlvbiBpc1N0cmlrZXRocm91Z2goZWwpIHtcbiAgY29uc3Qgc3R5bGUgPSBpc0VsZW1lbnQoZWwpICYmIGVsLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICByZXR1cm4gL3RleHQtZGVjb3JhdGlvblxccyo6XFxzKig/Oi4qbGluZS10aHJvdWdoLio7KS8udGVzdChzdHlsZSB8fCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGlzR29vZ2xlRG9jcyhlbCkge1xuICByZXR1cm4gaXNFbGVtZW50KGVsKSAmJiAhIWVsLmdldEF0dHJpYnV0ZShcImRhdGEtaXMtZ29vZ2xlLWRvY3NcIik7XG59XG5mdW5jdGlvbiBpc1Jvb3ROb2RlKGVsKSB7XG4gIHJldHVybiBpc0VsZW1lbnQoZWwpICYmICEhZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1pcy1yb290LW5vZGVcIik7XG59XG5mdW5jdGlvbiBnZXRMaXN0SXRlbVN0eWxlJDEoZWwpIHtcbiAgY29uc3QgcGFyZW50VGFnID0gdGFnTmFtZShlbC5wYXJlbnROb2RlKTtcbiAgaWYgKCEocGFyZW50VGFnICYmICFMSVNUX0NPTlRBSU5FUl9UQUdTLmluY2x1ZGVzKHBhcmVudFRhZykpKVxuICAgIHJldHVybiB0YWdOYW1lKGVsLnBhcmVudE5vZGUpID09PSBcInVsXCIgPyBcImJ1bGxldFwiIDogXCJudW1iZXJcIjtcbn1cbmZ1bmN0aW9uIGdldExpc3RJdGVtTGV2ZWwkMShlbCkge1xuICBsZXQgbGV2ZWwgPSAwO1xuICBpZiAodGFnTmFtZShlbCkgPT09IFwibGlcIikge1xuICAgIGxldCBwYXJlbnROb2RlID0gZWwucGFyZW50Tm9kZTtcbiAgICBmb3IgKDsgcGFyZW50Tm9kZTsgKSB7XG4gICAgICBjb25zdCBwYXJlbnRUYWcgPSB0YWdOYW1lKHBhcmVudE5vZGUpO1xuICAgICAgcGFyZW50VGFnICYmIExJU1RfQ09OVEFJTkVSX1RBR1MuaW5jbHVkZXMocGFyZW50VGFnKSAmJiBsZXZlbCsrLCBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfSBlbHNlXG4gICAgbGV2ZWwgPSAxO1xuICByZXR1cm4gbGV2ZWw7XG59XG5jb25zdCBibG9ja3MgPSB7XG4gIC4uLkhUTUxfQkxPQ0tfVEFHUyxcbiAgLi4uSFRNTF9IRUFERVJfVEFHU1xufTtcbmZ1bmN0aW9uIGdldEJsb2NrU3R5bGUoc2NoZW1hLCBlbCkge1xuICBjb25zdCBjaGlsZFRhZyA9IHRhZ05hbWUoZWwuZmlyc3RDaGlsZCksIGJsb2NrID0gY2hpbGRUYWcgJiYgYmxvY2tzW2NoaWxkVGFnXTtcbiAgcmV0dXJuIGJsb2NrID8gc2NoZW1hLnN0eWxlcy5zb21lKChzdHlsZSkgPT4gc3R5bGUubmFtZSA9PT0gYmxvY2suc3R5bGUpID8gYmxvY2suc3R5bGUgOiBCTE9DS19ERUZBVUxUX1NUWUxFIDogQkxPQ0tfREVGQVVMVF9TVFlMRTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUdEb2NzUnVsZXMoc2NoZW1hKSB7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgZGVzZXJpYWxpemUoZWwsIG5leHQpIHtcbiAgICAgICAgaWYgKGlzRWxlbWVudChlbCkgJiYgdGFnTmFtZShlbCkgPT09IFwic3BhblwiICYmIGlzR29vZ2xlRG9jcyhlbCkpIHtcbiAgICAgICAgICBpZiAoIWVsLnRleHRDb250ZW50KVxuICAgICAgICAgICAgcmV0dXJuICFlbC5wcmV2aW91c1NpYmxpbmcgJiYgIWVsLm5leHRTaWJsaW5nICYmIGVsLnNldEF0dHJpYnV0ZShcImRhdGEtbG9uZWx5LWNoaWxkXCIsIFwidHJ1ZVwiKSwgbmV4dChlbC5jaGlsZE5vZGVzKTtcbiAgICAgICAgICBjb25zdCBzcGFuID0ge1xuICAgICAgICAgICAgLi4uREVGQVVMVF9TUEFOLFxuICAgICAgICAgICAgbWFya3M6IFtdLFxuICAgICAgICAgICAgdGV4dDogZWwudGV4dENvbnRlbnRcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBpc1N0cm9uZyQxKGVsKSAmJiBzcGFuLm1hcmtzLnB1c2goXCJzdHJvbmdcIiksIGlzVW5kZXJsaW5lJDEoZWwpICYmIHNwYW4ubWFya3MucHVzaChcInVuZGVybGluZVwiKSwgaXNTdHJpa2V0aHJvdWdoKGVsKSAmJiBzcGFuLm1hcmtzLnB1c2goXCJzdHJpa2UtdGhyb3VnaFwiKSwgaXNFbXBoYXNpcyQxKGVsKSAmJiBzcGFuLm1hcmtzLnB1c2goXCJlbVwiKSwgc3BhbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgZGVzZXJpYWxpemUoZWwsIG5leHQpIHtcbiAgICAgICAgaWYgKHRhZ05hbWUoZWwpID09PSBcImxpXCIgJiYgaXNHb29nbGVEb2NzKGVsKSlcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uREVGQVVMVF9CTE9DSyxcbiAgICAgICAgICAgIGxpc3RJdGVtOiBnZXRMaXN0SXRlbVN0eWxlJDEoZWwpLFxuICAgICAgICAgICAgbGV2ZWw6IGdldExpc3RJdGVtTGV2ZWwkMShlbCksXG4gICAgICAgICAgICBzdHlsZTogZ2V0QmxvY2tTdHlsZShzY2hlbWEsIGVsKSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBuZXh0KGVsLmZpcnN0Q2hpbGQ/LmNoaWxkTm9kZXMgfHwgW10pXG4gICAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGRlc2VyaWFsaXplKGVsKSB7XG4gICAgICAgIGlmICh0YWdOYW1lKGVsKSA9PT0gXCJiclwiICYmIGlzR29vZ2xlRG9jcyhlbCkgJiYgaXNFbGVtZW50KGVsKSAmJiBlbC5jbGFzc0xpc3QuY29udGFpbnMoXCJhcHBsZS1pbnRlcmNoYW5nZS1uZXdsaW5lXCIpKVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5ERUZBVUxUX1NQQU4sXG4gICAgICAgICAgICB0ZXh0OiBcIlwiXG4gICAgICAgICAgfTtcbiAgICAgICAgaWYgKHRhZ05hbWUoZWwpID09PSBcImJyXCIgJiYgaXNHb29nbGVEb2NzKGVsKSAmJiBpc0VsZW1lbnQoZWwpICYmIGVsPy5wYXJlbnROb2RlPy50ZXh0Q29udGVudCA9PT0gXCJcIilcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uREVGQVVMVF9TUEFOLFxuICAgICAgICAgICAgdGV4dDogXCJcIlxuICAgICAgICAgIH07XG4gICAgICAgIGlmICh0YWdOYW1lKGVsKSA9PT0gXCJiclwiICYmIGlzR29vZ2xlRG9jcyhlbCkgJiYgaXNFbGVtZW50KGVsKSAmJiBpc1Jvb3ROb2RlKGVsKSlcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uREVGQVVMVF9TUEFOLFxuICAgICAgICAgICAgdGV4dDogXCJcIlxuICAgICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICBdO1xufVxuY29uc3Qgd2hpdGVzcGFjZVRleHROb2RlUnVsZSA9IHtcbiAgZGVzZXJpYWxpemUobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVOYW1lID09PSBcIiN0ZXh0XCIgJiYgaXNXaGl0ZXNwYWNlVGV4dE5vZGUobm9kZSkgPyB7XG4gICAgICAuLi5ERUZBVUxUX1NQQU4sXG4gICAgICBtYXJrczogW10sXG4gICAgICB0ZXh0OiAobm9kZS50ZXh0Q29udGVudCA/PyBcIlwiKS5yZXBsYWNlKC9cXHNcXHMrL2csIFwiIFwiKVxuICAgIH0gOiB2b2lkIDA7XG4gIH1cbn07XG5mdW5jdGlvbiBpc1doaXRlc3BhY2VUZXh0Tm9kZShub2RlKSB7XG4gIHJldHVybiAobm9kZS5ub2RlVHlwZSA9PT0gMyAmJiAobm9kZS50ZXh0Q29udGVudCB8fCBcIlwiKS5yZXBsYWNlKC9bXFxyXFxuXS9nLCBcIiBcIikucmVwbGFjZSgvXFxzXFxzKy9nLCBcIiBcIikgPT09IFwiIFwiICYmIG5vZGUubmV4dFNpYmxpbmcgJiYgbm9kZS5uZXh0U2libGluZy5ub2RlVHlwZSAhPT0gMyAmJiBub2RlLnByZXZpb3VzU2libGluZyAmJiBub2RlLnByZXZpb3VzU2libGluZy5ub2RlVHlwZSAhPT0gMyB8fCBub2RlLnRleHRDb250ZW50ICE9PSBcIiBcIikgJiYgdGFnTmFtZShub2RlLnBhcmVudE5vZGUpICE9PSBcImJvZHlcIjtcbn1cbmZ1bmN0aW9uIHJlc29sdmVMaXN0SXRlbShzY2hlbWEsIGxpc3ROb2RlVGFnTmFtZSkge1xuICBpZiAobGlzdE5vZGVUYWdOYW1lID09PSBcInVsXCIgJiYgc2NoZW1hLmxpc3RzLnNvbWUoKGxpc3QpID0+IGxpc3QubmFtZSA9PT0gXCJidWxsZXRcIikpXG4gICAgcmV0dXJuIFwiYnVsbGV0XCI7XG4gIGlmIChsaXN0Tm9kZVRhZ05hbWUgPT09IFwib2xcIiAmJiBzY2hlbWEubGlzdHMuc29tZSgobGlzdCkgPT4gbGlzdC5uYW1lID09PSBcIm51bWJlclwiKSlcbiAgICByZXR1cm4gXCJudW1iZXJcIjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUhUTUxSdWxlcyhzY2hlbWEsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFtcbiAgICB3aGl0ZXNwYWNlVGV4dE5vZGVSdWxlLFxuICAgIHtcbiAgICAgIC8vIFByZSBlbGVtZW50XG4gICAgICBkZXNlcmlhbGl6ZShlbCkge1xuICAgICAgICBpZiAodGFnTmFtZShlbCkgIT09IFwicHJlXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBpc0NvZGVFbmFibGVkID0gc2NoZW1hLnN0eWxlcy5zb21lKFxuICAgICAgICAgIChzdHlsZSkgPT4gc3R5bGUubmFtZSA9PT0gXCJjb2RlXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBfdHlwZTogXCJibG9ja1wiLFxuICAgICAgICAgIHN0eWxlOiBcIm5vcm1hbFwiLFxuICAgICAgICAgIG1hcmtEZWZzOiBbXSxcbiAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAuLi5ERUZBVUxUX1NQQU4sXG4gICAgICAgICAgICAgIG1hcmtzOiBpc0NvZGVFbmFibGVkID8gW1wiY29kZVwiXSA6IFtdLFxuICAgICAgICAgICAgICB0ZXh0OiBlbC50ZXh0Q29udGVudCB8fCBcIlwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQmxvY2txdW90ZSBlbGVtZW50XG4gICAge1xuICAgICAgZGVzZXJpYWxpemUoZWwsIG5leHQpIHtcbiAgICAgICAgaWYgKHRhZ05hbWUoZWwpICE9PSBcImJsb2NrcXVvdGVcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGJsb2NrczIgPSB7XG4gICAgICAgICAgLi4uSFRNTF9CTE9DS19UQUdTLFxuICAgICAgICAgIC4uLkhUTUxfSEVBREVSX1RBR1NcbiAgICAgICAgfTtcbiAgICAgICAgZGVsZXRlIGJsb2NrczIuYmxvY2txdW90ZTtcbiAgICAgICAgY29uc3Qgbm9uQmxvY2txdW90ZUJsb2NrcyA9IE9iamVjdC5rZXlzKGJsb2NrczIpLCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICByZXR1cm4gZWwuY2hpbGROb2Rlcy5mb3JFYWNoKChub2RlLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGlmIChlbC5vd25lckRvY3VtZW50KVxuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgJiYgbm9uQmxvY2txdW90ZUJsb2Nrcy5pbmNsdWRlcyhcbiAgICAgICAgICAgICAgbm9kZS5sb2NhbE5hbWUudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICBjb25zdCBzcGFuID0gZWwub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKSwgcHJldmlvdXNDaGlsZCA9IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICBwcmV2aW91c0NoaWxkICYmIHByZXZpb3VzQ2hpbGQubm9kZVR5cGUgPT09IDMgJiYgcHJldmlvdXNDaGlsZC50ZXh0Q29udGVudD8udHJpbSgpICYmIHNwYW4uYXBwZW5kQ2hpbGQoZWwub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcclwiKSksIG5vZGUuY2hpbGROb2Rlcy5mb3JFYWNoKChjbikgPT4ge1xuICAgICAgICAgICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQoY24uY2xvbmVOb2RlKCEwKSk7XG4gICAgICAgICAgICAgIH0pLCBpbmRleCAhPT0gZWwuY2hpbGROb2Rlcy5sZW5ndGggJiYgc3Bhbi5hcHBlbmRDaGlsZChlbC5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxyXCIpKSwgY2hpbGRyZW4ucHVzaChzcGFuKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICB9KSwge1xuICAgICAgICAgIF90eXBlOiBcImJsb2NrXCIsXG4gICAgICAgICAgc3R5bGU6IFwiYmxvY2txdW90ZVwiLFxuICAgICAgICAgIG1hcmtEZWZzOiBbXSxcbiAgICAgICAgICBjaGlsZHJlbjogbmV4dChjaGlsZHJlbilcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEJsb2NrIGVsZW1lbnRzXG4gICAge1xuICAgICAgZGVzZXJpYWxpemUoZWwsIG5leHQpIHtcbiAgICAgICAgY29uc3QgYmxvY2tzMiA9IHtcbiAgICAgICAgICAuLi5IVE1MX0JMT0NLX1RBR1MsXG4gICAgICAgICAgLi4uSFRNTF9IRUFERVJfVEFHU1xuICAgICAgICB9LCB0YWcgPSB0YWdOYW1lKGVsKTtcbiAgICAgICAgbGV0IGJsb2NrID0gdGFnID8gYmxvY2tzMlt0YWddIDogdm9pZCAwO1xuICAgICAgICBpZiAoIWJsb2NrKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgdGFnTmFtZShlbC5wYXJlbnROb2RlKSA9PT0gXCJsaVwiKVxuICAgICAgICAgIHJldHVybiBuZXh0KGVsLmNoaWxkTm9kZXMpO1xuICAgICAgICBjb25zdCBibG9ja1N0eWxlID0gYmxvY2suc3R5bGU7XG4gICAgICAgIHJldHVybiBzY2hlbWEuc3R5bGVzLnNvbWUoKHN0eWxlKSA9PiBzdHlsZS5uYW1lID09PSBibG9ja1N0eWxlKSB8fCAoYmxvY2sgPSBERUZBVUxUX0JMT0NLKSwge1xuICAgICAgICAgIC4uLmJsb2NrLFxuICAgICAgICAgIGNoaWxkcmVuOiBuZXh0KGVsLmNoaWxkTm9kZXMpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBJZ25vcmUgc3BhbiB0YWdzXG4gICAge1xuICAgICAgZGVzZXJpYWxpemUoZWwsIG5leHQpIHtcbiAgICAgICAgY29uc3QgdGFnID0gdGFnTmFtZShlbCk7XG4gICAgICAgIGlmICghKCF0YWcgfHwgISh0YWcgaW4gSFRNTF9TUEFOX1RBR1MpKSlcbiAgICAgICAgICByZXR1cm4gbmV4dChlbC5jaGlsZE5vZGVzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIElnbm9yZSBkaXYgdGFnc1xuICAgIHtcbiAgICAgIGRlc2VyaWFsaXplKGVsLCBuZXh0KSB7XG4gICAgICAgIGlmICh0YWdOYW1lKGVsKSA9PT0gXCJkaXZcIilcbiAgICAgICAgICByZXR1cm4gbmV4dChlbC5jaGlsZE5vZGVzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIElnbm9yZSBsaXN0IGNvbnRhaW5lcnNcbiAgICB7XG4gICAgICBkZXNlcmlhbGl6ZShlbCwgbmV4dCkge1xuICAgICAgICBjb25zdCB0YWcgPSB0YWdOYW1lKGVsKTtcbiAgICAgICAgaWYgKCEoIXRhZyB8fCAhKHRhZyBpbiBIVE1MX0xJU1RfQ09OVEFJTkVSX1RBR1MpKSlcbiAgICAgICAgICByZXR1cm4gbmV4dChlbC5jaGlsZE5vZGVzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIERlYWwgd2l0aCBicidzXG4gICAge1xuICAgICAgZGVzZXJpYWxpemUoZWwpIHtcbiAgICAgICAgaWYgKHRhZ05hbWUoZWwpID09PSBcImJyXCIpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLkRFRkFVTFRfU1BBTixcbiAgICAgICAgICAgIHRleHQ6IGBcbmBcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gRGVhbCB3aXRoIGxpc3QgaXRlbXNcbiAgICB7XG4gICAgICBkZXNlcmlhbGl6ZShlbCwgbmV4dCwgYmxvY2spIHtcbiAgICAgICAgY29uc3QgdGFnID0gdGFnTmFtZShlbCksIGxpc3RJdGVtID0gdGFnID8gSFRNTF9MSVNUX0lURU1fVEFHU1t0YWddIDogdm9pZCAwLCBwYXJlbnRUYWcgPSB0YWdOYW1lKGVsLnBhcmVudE5vZGUpIHx8IFwiXCI7XG4gICAgICAgIGlmICghbGlzdEl0ZW0gfHwgIWVsLnBhcmVudE5vZGUgfHwgIUhUTUxfTElTVF9DT05UQUlORVJfVEFHU1twYXJlbnRUYWddKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZW5hYmxlZExpc3RJdGVtID0gcmVzb2x2ZUxpc3RJdGVtKHNjaGVtYSwgcGFyZW50VGFnKTtcbiAgICAgICAgcmV0dXJuIGVuYWJsZWRMaXN0SXRlbSA/IChsaXN0SXRlbS5saXN0SXRlbSA9IGVuYWJsZWRMaXN0SXRlbSwge1xuICAgICAgICAgIC4uLmxpc3RJdGVtLFxuICAgICAgICAgIGNoaWxkcmVuOiBuZXh0KGVsLmNoaWxkTm9kZXMpXG4gICAgICAgIH0pIDogYmxvY2soeyBfdHlwZTogXCJibG9ja1wiLCBjaGlsZHJlbjogbmV4dChlbC5jaGlsZE5vZGVzKSB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIERlYWwgd2l0aCBkZWNvcmF0b3JzIC0gdGhpcyBpcyBhIGxpbWl0ZWQgc2V0IG9mIGtub3duIGh0bWwgZWxlbWVudHMgdGhhdCB3ZSBrbm93IGhvdyB0byBkZXNlcmlhbGl6ZVxuICAgIHtcbiAgICAgIGRlc2VyaWFsaXplKGVsLCBuZXh0KSB7XG4gICAgICAgIGNvbnN0IGRlY29yYXRvciA9IEhUTUxfREVDT1JBVE9SX1RBR1NbdGFnTmFtZShlbCkgfHwgXCJcIl07XG4gICAgICAgIGlmICghKCFkZWNvcmF0b3IgfHwgIXNjaGVtYS5kZWNvcmF0b3JzLnNvbWUoXG4gICAgICAgICAgKGRlY29yYXRvclR5cGUpID0+IGRlY29yYXRvclR5cGUubmFtZSA9PT0gZGVjb3JhdG9yXG4gICAgICAgICkpKVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJfX2RlY29yYXRvclwiLFxuICAgICAgICAgICAgbmFtZTogZGVjb3JhdG9yLFxuICAgICAgICAgICAgY2hpbGRyZW46IG5leHQoZWwuY2hpbGROb2RlcylcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBoeXBlcmxpbmtzLCBhZGQgYW5ub3RhdGlvbiAoaWYgYWxsb3dlZCBieSBzY2hlbWEpLFxuICAgIC8vIElmIG5vdCBzdXBwb3J0ZWQganVzdCB3cml0ZSBvdXQgdGhlIGxpbmsgdGV4dCBhbmQgaHJlZiBpbiBwbGFpbiB0ZXh0LlxuICAgIHtcbiAgICAgIGRlc2VyaWFsaXplKGVsLCBuZXh0KSB7XG4gICAgICAgIGlmICh0YWdOYW1lKGVsKSAhPT0gXCJhXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBsaW5rRW5hYmxlZCA9IHNjaGVtYS5hbm5vdGF0aW9ucy5zb21lKFxuICAgICAgICAgIChhbm5vdGF0aW9uKSA9PiBhbm5vdGF0aW9uLm5hbWUgPT09IFwibGlua1wiXG4gICAgICAgICksIGhyZWYgPSBpc0VsZW1lbnQoZWwpICYmIGVsLmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG4gICAgICAgIHJldHVybiBocmVmID8gbGlua0VuYWJsZWQgPyB7XG4gICAgICAgICAgX3R5cGU6IFwiX19hbm5vdGF0aW9uXCIsXG4gICAgICAgICAgbWFya0RlZjoge1xuICAgICAgICAgICAgX2tleTogb3B0aW9ucy5rZXlHZW5lcmF0b3IgPyBvcHRpb25zLmtleUdlbmVyYXRvcigpIDoga2V5R2VuZXJhdG9yKCksXG4gICAgICAgICAgICBfdHlwZTogXCJsaW5rXCIsXG4gICAgICAgICAgICBocmVmXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjaGlsZHJlbjogbmV4dChlbC5jaGlsZE5vZGVzKVxuICAgICAgICB9IDogZWwuYXBwZW5kQ2hpbGQoZWwub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShgICgke2hyZWZ9KWApKSAmJiBuZXh0KGVsLmNoaWxkTm9kZXMpIDogbmV4dChlbC5jaGlsZE5vZGVzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGRlc2VyaWFsaXplKGVsLCBuZXh0KSB7XG4gICAgICAgIGlmIChpc0VsZW1lbnQoZWwpICYmICh0YWdOYW1lKGVsKSA9PT0gXCJ0ZFwiIHx8IHRhZ05hbWUoZWwpID09PSBcInRoXCIpKVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5ERUZBVUxUX0JMT0NLLFxuICAgICAgICAgICAgY2hpbGRyZW46IG5leHQoZWwuY2hpbGROb2RlcylcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgZGVzZXJpYWxpemUoZWwpIHtcbiAgICAgICAgaWYgKGlzRWxlbWVudChlbCkgJiYgdGFnTmFtZShlbCkgPT09IFwiaW1nXCIpIHtcbiAgICAgICAgICBjb25zdCBzcmMgPSBlbC5nZXRBdHRyaWJ1dGUoXCJzcmNcIikgPz8gdm9pZCAwLCBhbHQgPSBlbC5nZXRBdHRyaWJ1dGUoXCJhbHRcIikgPz8gdm9pZCAwLCBwcm9wcyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgIEFycmF5LmZyb20oZWwuYXR0cmlidXRlcykubWFwKChhdHRyKSA9PiBbYXR0ci5uYW1lLCBhdHRyLnZhbHVlXSlcbiAgICAgICAgICApLCBhbmNlc3Rvck9mTG9uZWx5Q2hpbGQgPSBlbD8ucGFyZW50RWxlbWVudD8ucGFyZW50RWxlbWVudD8uZ2V0QXR0cmlidXRlKFwiZGF0YS1sb25lbHktY2hpbGRcIiksIGFuY2VzdG9yT2ZMaXN0SXRlbSA9IGVsLmNsb3Nlc3QoXCJsaVwiKSAhPT0gbnVsbDtcbiAgICAgICAgICBpZiAoYW5jZXN0b3JPZkxvbmVseUNoaWxkICYmICFhbmNlc3Rvck9mTGlzdEl0ZW0pIHtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlMiA9IG9wdGlvbnMubWF0Y2hlcnM/LmltYWdlPy4oe1xuICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgICAgIGtleUdlbmVyYXRvcjogb3B0aW9ucy5rZXlHZW5lcmF0b3IgPz8ga2V5R2VuZXJhdG9yXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgICAgICAgICAgLi4uc3JjID8geyBzcmMgfSA6IHt9LFxuICAgICAgICAgICAgICAgIC4uLmFsdCA/IHsgYWx0IH0gOiB7fVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpbWFnZTIpXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgX3R5cGU6IFwiX19ibG9ja1wiLFxuICAgICAgICAgICAgICAgIGJsb2NrOiBpbWFnZTJcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaW5saW5lSW1hZ2UgPSBvcHRpb25zLm1hdGNoZXJzPy5pbmxpbmVJbWFnZT8uKHtcbiAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgICBrZXlHZW5lcmF0b3I6IG9wdGlvbnMua2V5R2VuZXJhdG9yID8/IGtleUdlbmVyYXRvclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgIC4uLnByb3BzLFxuICAgICAgICAgICAgICAuLi5zcmMgPyB7IHNyYyB9IDoge30sXG4gICAgICAgICAgICAgIC4uLmFsdCA/IHsgYWx0IH0gOiB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChpbmxpbmVJbWFnZSlcbiAgICAgICAgICAgIHJldHVybiBpbmxpbmVJbWFnZTtcbiAgICAgICAgICBjb25zdCBpbWFnZSA9IG9wdGlvbnMubWF0Y2hlcnM/LmltYWdlPy4oe1xuICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAgIGtleUdlbmVyYXRvcjogb3B0aW9ucy5rZXlHZW5lcmF0b3IgPz8ga2V5R2VuZXJhdG9yXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgICAgICAgIC4uLnNyYyA/IHsgc3JjIH0gOiB7fSxcbiAgICAgICAgICAgICAgLi4uYWx0ID8geyBhbHQgfSA6IHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGltYWdlKVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgX3R5cGU6IFwiX19ibG9ja1wiLFxuICAgICAgICAgICAgICBibG9jazogaW1hZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIF07XG59XG5mdW5jdGlvbiBpc0VtcGhhc2lzKGVsKSB7XG4gIGNvbnN0IHN0eWxlID0gaXNFbGVtZW50KGVsKSAmJiBlbC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgcmV0dXJuIC9mb250LXN0eWxlOml0YWxpYy8udGVzdChzdHlsZSB8fCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGlzU3Ryb25nKGVsKSB7XG4gIGNvbnN0IHN0eWxlID0gaXNFbGVtZW50KGVsKSAmJiBlbC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgcmV0dXJuIC9mb250LXdlaWdodDo3MDAvLnRlc3Qoc3R5bGUgfHwgXCJcIikgfHwgL2ZvbnQtd2VpZ2h0OjYwMC8udGVzdChzdHlsZSB8fCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGlzVW5kZXJsaW5lKGVsKSB7XG4gIGNvbnN0IHN0eWxlID0gaXNFbGVtZW50KGVsKSAmJiBlbC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgcmV0dXJuIC90ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lLy50ZXN0KHN0eWxlIHx8IFwiXCIpO1xufVxuZnVuY3Rpb24gaXNOb3Rpb24oZWwpIHtcbiAgcmV0dXJuIGlzRWxlbWVudChlbCkgJiYgISFlbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWlzLW5vdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU5vdGlvblJ1bGVzKCkge1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIGRlc2VyaWFsaXplKGVsKSB7XG4gICAgICAgIGlmIChpc0VsZW1lbnQoZWwpICYmIHRhZ05hbWUoZWwpID09PSBcInNwYW5cIiAmJiBpc05vdGlvbihlbCkpIHtcbiAgICAgICAgICBjb25zdCBzcGFuID0ge1xuICAgICAgICAgICAgLi4uREVGQVVMVF9TUEFOLFxuICAgICAgICAgICAgbWFya3M6IFtdLFxuICAgICAgICAgICAgdGV4dDogZWwudGV4dENvbnRlbnRcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBpc1N0cm9uZyhlbCkgJiYgc3Bhbi5tYXJrcy5wdXNoKFwic3Ryb25nXCIpLCBpc1VuZGVybGluZShlbCkgJiYgc3Bhbi5tYXJrcy5wdXNoKFwidW5kZXJsaW5lXCIpLCBpc0VtcGhhc2lzKGVsKSAmJiBzcGFuLm1hcmtzLnB1c2goXCJlbVwiKSwgc3BhbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgXTtcbn1cbmZ1bmN0aW9uIGdldExpc3RJdGVtU3R5bGUoZWwpIHtcbiAgY29uc3Qgc3R5bGUgPSBpc0VsZW1lbnQoZWwpICYmIGVsLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICBpZiAoc3R5bGUgJiYgc3R5bGUubWF0Y2goL2xmb1xcZCsvKSlcbiAgICByZXR1cm4gc3R5bGUubWF0Y2goXCJsZm8xXCIpID8gXCJidWxsZXRcIiA6IFwibnVtYmVyXCI7XG59XG5mdW5jdGlvbiBnZXRMaXN0SXRlbUxldmVsKGVsKSB7XG4gIGNvbnN0IHN0eWxlID0gaXNFbGVtZW50KGVsKSAmJiBlbC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgaWYgKCFzdHlsZSlcbiAgICByZXR1cm47XG4gIGNvbnN0IGxldmVsTWF0Y2ggPSBzdHlsZS5tYXRjaCgvbGV2ZWxcXGQrLyk7XG4gIGlmICghbGV2ZWxNYXRjaClcbiAgICByZXR1cm47XG4gIGNvbnN0IFtsZXZlbF0gPSBsZXZlbE1hdGNoWzBdLm1hdGNoKC9cXGQvKSB8fCBbXTtcbiAgcmV0dXJuIChsZXZlbCA/IE51bWJlci5wYXJzZUludChsZXZlbCwgMTApIDogMSkgfHwgMTtcbn1cbmZ1bmN0aW9uIGlzV29yZExpc3RFbGVtZW50KGVsKSB7XG4gIHJldHVybiBpc0VsZW1lbnQoZWwpICYmIGVsLmNsYXNzTmFtZSA/IGVsLmNsYXNzTmFtZSA9PT0gXCJNc29MaXN0UGFyYWdyYXBoQ3hTcEZpcnN0XCIgfHwgZWwuY2xhc3NOYW1lID09PSBcIk1zb0xpc3RQYXJhZ3JhcGhDeFNwTWlkZGxlXCIgfHwgZWwuY2xhc3NOYW1lID09PSBcIk1zb0xpc3RQYXJhZ3JhcGhDeFNwTGFzdFwiIDogITE7XG59XG5mdW5jdGlvbiBjcmVhdGVXb3JkUnVsZXMoKSB7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgZGVzZXJpYWxpemUoZWwsIG5leHQpIHtcbiAgICAgICAgaWYgKHRhZ05hbWUoZWwpID09PSBcInBcIiAmJiBpc1dvcmRMaXN0RWxlbWVudChlbCkpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLkRFRkFVTFRfQkxPQ0ssXG4gICAgICAgICAgICBsaXN0SXRlbTogZ2V0TGlzdEl0ZW1TdHlsZShlbCksXG4gICAgICAgICAgICBsZXZlbDogZ2V0TGlzdEl0ZW1MZXZlbChlbCksXG4gICAgICAgICAgICBzdHlsZTogQkxPQ0tfREVGQVVMVF9TVFlMRSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBuZXh0KGVsLmNoaWxkTm9kZXMpXG4gICAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIF07XG59XG5mdW5jdGlvbiBjcmVhdGVSdWxlcyhzY2hlbWEsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFtcbiAgICAuLi5jcmVhdGVXb3JkUnVsZXMoKSxcbiAgICAuLi5jcmVhdGVOb3Rpb25SdWxlcygpLFxuICAgIC4uLmNyZWF0ZUdEb2NzUnVsZXMoc2NoZW1hKSxcbiAgICAuLi5jcmVhdGVIVE1MUnVsZXMoc2NoZW1hLCBvcHRpb25zKVxuICBdO1xufVxuY2xhc3MgSHRtbERlc2VyaWFsaXplciB7XG4gIGtleUdlbmVyYXRvcjtcbiAgc2NoZW1hO1xuICBydWxlcztcbiAgcGFyc2VIdG1sO1xuICBfbWFya0RlZnMgPSBbXTtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBzZXJpYWxpemVyIHJlc3BlY3RpbmcgYSBTYW5pdHkgYmxvY2sgY29udGVudCB0eXBlJ3Mgc2NoZW1hXG4gICAqXG4gICAqIEBwYXJhbSBibG9ja0NvbnRlbnRUeXBlIC0gU2NoZW1hIHR5cGUgZm9yIGFycmF5IGNvbnRhaW5pbmcgX2F0IGxlYXN0XyBhIGJsb2NrIGNoaWxkIHR5cGVcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgZGVzZXJpYWxpemF0aW9uIHByb2Nlc3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNjaGVtYSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBydWxlcyA9IFtdLCB1bnN0YWJsZV93aGl0ZXNwYWNlT25QYXN0ZU1vZGUgPSBcInByZXNlcnZlXCIgfSA9IG9wdGlvbnMsIHN0YW5kYXJkUnVsZXMgPSBjcmVhdGVSdWxlcyhzY2hlbWEsIHtcbiAgICAgIGtleUdlbmVyYXRvcjogb3B0aW9ucy5rZXlHZW5lcmF0b3IsXG4gICAgICBtYXRjaGVyczogb3B0aW9ucy5tYXRjaGVyc1xuICAgIH0pO1xuICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hLCB0aGlzLmtleUdlbmVyYXRvciA9IG9wdGlvbnMua2V5R2VuZXJhdG9yID8/IGtleUdlbmVyYXRvciwgdGhpcy5ydWxlcyA9IFsuLi5ydWxlcywgLi4uc3RhbmRhcmRSdWxlc107XG4gICAgY29uc3QgcGFyc2VIdG1sID0gb3B0aW9ucy5wYXJzZUh0bWwgfHwgZGVmYXVsdFBhcnNlSHRtbCgpO1xuICAgIHRoaXMucGFyc2VIdG1sID0gKGh0bWwpID0+IHByZXByb2Nlc3MoaHRtbCwgcGFyc2VIdG1sLCB7IHVuc3RhYmxlX3doaXRlc3BhY2VPblBhc3RlTW9kZSB9KS5ib2R5O1xuICB9XG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBIVE1MLlxuICAgKlxuICAgKiBAcGFyYW0gaHRtbCAtIFRoZSBIVE1MIHRvIGRlc2VyaWFsaXplLCBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJucyBBcnJheSBvZiBibG9ja3MgLSBlaXRoZXIgcG9ydGFibGUgdGV4dCBibG9ja3Mgb3Igb3RoZXIgYWxsb3dlZCBibG9ja3NcbiAgICovXG4gIGRlc2VyaWFsaXplID0gKGh0bWwpID0+IHtcbiAgICB0aGlzLl9tYXJrRGVmcyA9IFtdO1xuICAgIGNvbnN0IHsgcGFyc2VIdG1sIH0gPSB0aGlzLCBmcmFnbWVudCA9IHBhcnNlSHRtbChodG1sKSwgY2hpbGRyZW4gPSBBcnJheS5mcm9tKGZyYWdtZW50LmNoaWxkTm9kZXMpLCBibG9ja3MyID0gdHJpbVdoaXRlc3BhY2UoXG4gICAgICB0aGlzLnNjaGVtYSxcbiAgICAgIGZsYXR0ZW5OZXN0ZWRCbG9ja3MoXG4gICAgICAgIHsgc2NoZW1hOiB0aGlzLnNjaGVtYSB9LFxuICAgICAgICBlbnN1cmVSb290SXNCbG9ja3MoXG4gICAgICAgICAgdGhpcy5zY2hlbWEsXG4gICAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZUVsZW1lbnRzKGNoaWxkcmVuKVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5fbWFya0RlZnMubGVuZ3RoID4gMCAmJiBibG9ja3MyLmZpbHRlcigoYmxvY2spID0+IGlzVGV4dEJsb2NrKHsgc2NoZW1hOiB0aGlzLnNjaGVtYSB9LCBibG9jaykpLmZvckVhY2goKGJsb2NrKSA9PiB7XG4gICAgICBibG9jay5tYXJrRGVmcyA9IGJsb2NrLm1hcmtEZWZzIHx8IFtdLCBibG9jay5tYXJrRGVmcyA9IGJsb2NrLm1hcmtEZWZzLmNvbmNhdChcbiAgICAgICAgdGhpcy5fbWFya0RlZnMuZmlsdGVyKChkZWYpID0+IGZsYXR0ZW4oXG4gICAgICAgICAgYmxvY2suY2hpbGRyZW4ubWFwKChjaGlsZCkgPT4gY2hpbGQubWFya3MgfHwgW10pXG4gICAgICAgICkuaW5jbHVkZXMoZGVmLl9rZXkpKVxuICAgICAgKTtcbiAgICB9KSwgYmxvY2tzMi5tYXAoKGJsb2NrKSA9PiAoYmxvY2suX3R5cGUgPT09IFwiYmxvY2tcIiAmJiAoYmxvY2suX3R5cGUgPSB0aGlzLnNjaGVtYS5ibG9jay5uYW1lKSwgYmxvY2spKTtcbiAgfTtcbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIGFuIGFycmF5IG9mIERPTSBlbGVtZW50cy5cbiAgICpcbiAgICogQHBhcmFtIGVsZW1lbnRzIC0gQXJyYXkgb2YgRE9NIGVsZW1lbnRzIHRvIGRlc2VyaWFsaXplXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBkZXNlcmlhbGl6ZUVsZW1lbnRzID0gKGVsZW1lbnRzID0gW10pID0+IHtcbiAgICBsZXQgbm9kZXMgPSBbXTtcbiAgICByZXR1cm4gZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgbm9kZXMgPSBub2Rlcy5jb25jYXQodGhpcy5kZXNlcmlhbGl6ZUVsZW1lbnQoZWxlbWVudCkpO1xuICAgIH0pLCBub2RlcztcbiAgfTtcbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIGEgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIGVsZW1lbnQgLSBEZXNlcmlhbGl6ZSBhIERPTSBlbGVtZW50XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBkZXNlcmlhbGl6ZUVsZW1lbnQgPSAoZWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IG5leHQgPSAoZWxlbWVudHMpID0+IHtcbiAgICAgIGlmIChpc05vZGVMaXN0KGVsZW1lbnRzKSlcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemVFbGVtZW50cyhBcnJheS5mcm9tKGVsZW1lbnRzKSk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50cykpXG4gICAgICAgIHJldHVybiB0aGlzLmRlc2VyaWFsaXplRWxlbWVudHMoZWxlbWVudHMpO1xuICAgICAgaWYgKGVsZW1lbnRzKVxuICAgICAgICByZXR1cm4gdGhpcy5kZXNlcmlhbGl6ZUVsZW1lbnQoZWxlbWVudHMpO1xuICAgIH0sIGJsb2NrID0gKHByb3BzKSA9PiAoe1xuICAgICAgX3R5cGU6IFwiX19ibG9ja1wiLFxuICAgICAgYmxvY2s6IHByb3BzXG4gICAgfSk7XG4gICAgbGV0IG5vZGU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBydWxlID0gdGhpcy5ydWxlc1tpXTtcbiAgICAgIGlmICghcnVsZS5kZXNlcmlhbGl6ZSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCByZXQgPSBydWxlLmRlc2VyaWFsaXplKGVsZW1lbnQsIG5leHQsIGJsb2NrKSwgdHlwZSA9IHJlc29sdmVKc1R5cGUocmV0KTtcbiAgICAgIGlmICh0eXBlICE9PSBcImFycmF5XCIgJiYgdHlwZSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlICE9PSBcIm51bGxcIiAmJiB0eXBlICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEEgcnVsZSByZXR1cm5lZCBhbiBpbnZhbGlkIGRlc2VyaWFsaXplZCByZXByZXNlbnRhdGlvbjogXCIke25vZGV9XCIuYFxuICAgICAgICApO1xuICAgICAgaWYgKHJldCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAocmV0ID09PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVzZXJpYWxpemVyIHJ1bGUgcmV0dXJuZWQgYG51bGxgXCIpO1xuICAgICAgICAgIEFycmF5LmlzQXJyYXkocmV0KSA/IG5vZGUgPSByZXQgOiBpc1BsYWNlaG9sZGVyRGVjb3JhdG9yKHJldCkgPyBub2RlID0gdGhpcy5kZXNlcmlhbGl6ZURlY29yYXRvcihyZXQpIDogaXNQbGFjZWhvbGRlckFubm90YXRpb24ocmV0KSA/IG5vZGUgPSB0aGlzLmRlc2VyaWFsaXplQW5ub3RhdGlvbihyZXQpIDogbm9kZSA9IHJldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmV0ICYmICFBcnJheS5pc0FycmF5KHJldCkgJiYgaXNNaW5pbWFsQmxvY2socmV0KSAmJiBcImxpc3RJdGVtXCIgaW4gcmV0KSB7XG4gICAgICAgICAgbGV0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZT8ucGFyZW50Tm9kZTtcbiAgICAgICAgICBmb3IgKDsgcGFyZW50ICYmIHRhZ05hbWUocGFyZW50KSA9PT0gXCJsaVwiOyApXG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZT8ucGFyZW50Tm9kZSwgcmV0LmxldmVsID0gcmV0LmxldmVsID8gcmV0LmxldmVsICsgMSA6IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0ICYmICFBcnJheS5pc0FycmF5KHJldCkgJiYgaXNNaW5pbWFsQmxvY2socmV0KSAmJiByZXQuc3R5bGUgPT09IFwiYmxvY2txdW90ZVwiICYmIHJldC5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICBpc01pbmltYWxTcGFuKGNoaWxkKSAmJiBjaGlsZC50ZXh0ID09PSBcIlxcclwiICYmIChjaGlsZC50ZXh0ID0gYFxuYCwgKGluZGV4ID09PSAwIHx8IGluZGV4ID09PSByZXQuY2hpbGRyZW4ubGVuZ3RoIC0gMSkgJiYgcmV0LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlIHx8IG5leHQoZWxlbWVudC5jaGlsZE5vZGVzKSB8fCBbXTtcbiAgfTtcbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIGEgYF9fZGVjb3JhdG9yYCB0eXBlXG4gICAqIChhbiBpbnRlcm5hbCBtYWRlIHVwIHR5cGUgdG8gcHJvY2VzcyBkZWNvcmF0b3JzIGV4Y2x1c2l2ZWx5KVxuICAgKlxuICAgKiBAcGFyYW0gZGVjb3JhdG9yIC1cbiAgICogQHJldHVybnMgYXJyYXkgb2YgLi4uXG4gICAqL1xuICBkZXNlcmlhbGl6ZURlY29yYXRvciA9IChkZWNvcmF0b3IpID0+IHtcbiAgICBjb25zdCB7IG5hbWUgfSA9IGRlY29yYXRvciwgYXBwbHlEZWNvcmF0b3IgPSAobm9kZSkgPT4ge1xuICAgICAgaWYgKGlzUGxhY2Vob2xkZXJEZWNvcmF0b3Iobm9kZSkpXG4gICAgICAgIHJldHVybiB0aGlzLmRlc2VyaWFsaXplRGVjb3JhdG9yKG5vZGUpO1xuICAgICAgaWYgKGlzTWluaW1hbFNwYW4obm9kZSkpXG4gICAgICAgIG5vZGUubWFya3MgPSBub2RlLm1hcmtzIHx8IFtdLCBub2RlLnRleHQudHJpbSgpICYmIG5vZGUubWFya3MudW5zaGlmdChuYW1lKTtcbiAgICAgIGVsc2UgaWYgKFwiY2hpbGRyZW5cIiBpbiBub2RlICYmIEFycmF5LmlzQXJyYXkobm9kZS5jaGlsZHJlbikpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBub2RlO1xuICAgICAgICBibG9jay5jaGlsZHJlbiA9IGJsb2NrLmNoaWxkcmVuLm1hcChhcHBseURlY29yYXRvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIHJldHVybiBkZWNvcmF0b3IuY2hpbGRyZW4ucmVkdWNlKChjaGlsZHJlbiwgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgcmV0ID0gYXBwbHlEZWNvcmF0b3Iobm9kZSk7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShyZXQpID8gY2hpbGRyZW4uY29uY2F0KHJldCkgOiAoY2hpbGRyZW4ucHVzaChyZXQpLCBjaGlsZHJlbik7XG4gICAgfSwgW10pO1xuICB9O1xuICAvKipcbiAgICogRGVzZXJpYWxpemUgYSBgX19hbm5vdGF0aW9uYCBvYmplY3QuXG4gICAqIChhbiBpbnRlcm5hbCBtYWRlIHVwIHR5cGUgdG8gcHJvY2VzcyBhbm5vdGF0aW9ucyBleGNsdXNpdmVseSlcbiAgICpcbiAgICogQHBhcmFtIGFubm90YXRpb24gLVxuICAgKiBAcmV0dXJucyBBcnJheSBvZi4uLlxuICAgKi9cbiAgZGVzZXJpYWxpemVBbm5vdGF0aW9uID0gKGFubm90YXRpb24pID0+IHtcbiAgICBjb25zdCB7IG1hcmtEZWYgfSA9IGFubm90YXRpb247XG4gICAgdGhpcy5fbWFya0RlZnMucHVzaChtYXJrRGVmKTtcbiAgICBjb25zdCBhcHBseUFubm90YXRpb24gPSAobm9kZSkgPT4ge1xuICAgICAgaWYgKGlzUGxhY2Vob2xkZXJBbm5vdGF0aW9uKG5vZGUpKVxuICAgICAgICByZXR1cm4gdGhpcy5kZXNlcmlhbGl6ZUFubm90YXRpb24obm9kZSk7XG4gICAgICBpZiAoaXNNaW5pbWFsU3Bhbihub2RlKSlcbiAgICAgICAgbm9kZS5tYXJrcyA9IG5vZGUubWFya3MgfHwgW10sIG5vZGUudGV4dC50cmltKCkgJiYgbm9kZS5tYXJrcy51bnNoaWZ0KG1hcmtEZWYuX2tleSk7XG4gICAgICBlbHNlIGlmIChcImNoaWxkcmVuXCIgaW4gbm9kZSAmJiBBcnJheS5pc0FycmF5KG5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gbm9kZTtcbiAgICAgICAgYmxvY2suY2hpbGRyZW4gPSBibG9jay5jaGlsZHJlbi5tYXAoYXBwbHlBbm5vdGF0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgcmV0dXJuIGFubm90YXRpb24uY2hpbGRyZW4ucmVkdWNlKChjaGlsZHJlbiwgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgcmV0ID0gYXBwbHlBbm5vdGF0aW9uKG5vZGUpO1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocmV0KSA/IGNoaWxkcmVuLmNvbmNhdChyZXQpIDogKGNoaWxkcmVuLnB1c2gocmV0KSwgY2hpbGRyZW4pO1xuICAgIH0sIFtdKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUJsb2NrKG5vZGUsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBzY2hlbWEgPSB7XG4gICAgYmxvY2s6IHtcbiAgICAgIG5hbWU6IG9wdGlvbnMuYmxvY2tUeXBlTmFtZSB8fCBcImJsb2NrXCJcbiAgICB9LFxuICAgIHNwYW46IHtcbiAgICAgIG5hbWU6IFwic3BhblwiXG4gICAgfSxcbiAgICBzdHlsZXM6IFtdLFxuICAgIGxpc3RzOiBbXSxcbiAgICBkZWNvcmF0b3JzOiBbXSxcbiAgICBhbm5vdGF0aW9uczogW10sXG4gICAgYmxvY2tPYmplY3RzOiBbXSxcbiAgICBpbmxpbmVPYmplY3RzOiBbXVxuICB9O1xuICBpZiAobm9kZS5fdHlwZSAhPT0gKG9wdGlvbnMuYmxvY2tUeXBlTmFtZSB8fCBcImJsb2NrXCIpKVxuICAgIHJldHVybiBcIl9rZXlcIiBpbiBub2RlID8gbm9kZSA6IHtcbiAgICAgIC4uLm5vZGUsXG4gICAgICBfa2V5OiBvcHRpb25zLmtleUdlbmVyYXRvciA/IG9wdGlvbnMua2V5R2VuZXJhdG9yKCkgOiBrZXlHZW5lcmF0b3IoKVxuICAgIH07XG4gIGNvbnN0IGJsb2NrID0ge1xuICAgIF9rZXk6IG9wdGlvbnMua2V5R2VuZXJhdG9yID8gb3B0aW9ucy5rZXlHZW5lcmF0b3IoKSA6IGtleUdlbmVyYXRvcigpLFxuICAgIGNoaWxkcmVuOiBbXSxcbiAgICBtYXJrRGVmczogW10sXG4gICAgLi4ubm9kZVxuICB9LCBsYXN0Q2hpbGQgPSBibG9jay5jaGlsZHJlbltibG9jay5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgaWYgKCFsYXN0Q2hpbGQpXG4gICAgcmV0dXJuIGJsb2NrLmNoaWxkcmVuID0gW1xuICAgICAge1xuICAgICAgICBfdHlwZTogXCJzcGFuXCIsXG4gICAgICAgIF9rZXk6IG9wdGlvbnMua2V5R2VuZXJhdG9yID8gb3B0aW9ucy5rZXlHZW5lcmF0b3IoKSA6IGtleUdlbmVyYXRvcigpLFxuICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICBtYXJrczogW11cbiAgICAgIH1cbiAgICBdLCBibG9jaztcbiAgY29uc3QgdXNlZE1hcmtEZWZzID0gW10sIGFsbG93ZWREZWNvcmF0b3JzID0gb3B0aW9ucy5hbGxvd2VkRGVjb3JhdG9ycyAmJiBBcnJheS5pc0FycmF5KG9wdGlvbnMuYWxsb3dlZERlY29yYXRvcnMpID8gb3B0aW9ucy5hbGxvd2VkRGVjb3JhdG9ycyA6ICExO1xuICByZXR1cm4gYmxvY2suY2hpbGRyZW4gPSBibG9jay5jaGlsZHJlbi5yZWR1Y2UoXG4gICAgKGFjYywgY2hpbGQpID0+IHtcbiAgICAgIGNvbnN0IHByZXZpb3VzQ2hpbGQgPSBhY2NbYWNjLmxlbmd0aCAtIDFdO1xuICAgICAgcmV0dXJuIHByZXZpb3VzQ2hpbGQgJiYgaXNTcGFuKHsgc2NoZW1hIH0sIGNoaWxkKSAmJiBpc1NwYW4oeyBzY2hlbWEgfSwgcHJldmlvdXNDaGlsZCkgJiYgaXNFcXVhbChwcmV2aW91c0NoaWxkLm1hcmtzLCBjaGlsZC5tYXJrcykgPyAobGFzdENoaWxkICYmIGxhc3RDaGlsZCA9PT0gY2hpbGQgJiYgY2hpbGQudGV4dCA9PT0gXCJcIiAmJiBibG9jay5jaGlsZHJlbi5sZW5ndGggPiAxIHx8IChwcmV2aW91c0NoaWxkLnRleHQgKz0gY2hpbGQudGV4dCksIGFjYykgOiAoYWNjLnB1c2goY2hpbGQpLCBhY2MpO1xuICAgIH0sXG4gICAgW11cbiAgKS5tYXAoKGNoaWxkKSA9PiB7XG4gICAgaWYgKCFjaGlsZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgY2hpbGRcIik7XG4gICAgcmV0dXJuIGNoaWxkLl9rZXkgPSBvcHRpb25zLmtleUdlbmVyYXRvciA/IG9wdGlvbnMua2V5R2VuZXJhdG9yKCkgOiBrZXlHZW5lcmF0b3IoKSwgaXNTcGFuKHsgc2NoZW1hIH0sIGNoaWxkKSAmJiAoY2hpbGQubWFya3MgPyBhbGxvd2VkRGVjb3JhdG9ycyAmJiAoY2hpbGQubWFya3MgPSBjaGlsZC5tYXJrcy5maWx0ZXIoKG1hcmspID0+IHtcbiAgICAgIGNvbnN0IGlzQWxsb3dlZCA9IGFsbG93ZWREZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspLCBpc1VzZWQgPSBibG9jay5tYXJrRGVmcz8uc29tZSgoZGVmKSA9PiBkZWYuX2tleSA9PT0gbWFyayk7XG4gICAgICByZXR1cm4gaXNBbGxvd2VkIHx8IGlzVXNlZDtcbiAgICB9KSkgOiBjaGlsZC5tYXJrcyA9IFtdLCB1c2VkTWFya0RlZnMucHVzaCguLi5jaGlsZC5tYXJrcykpLCBjaGlsZDtcbiAgfSksIGJsb2NrLm1hcmtEZWZzID0gKGJsb2NrLm1hcmtEZWZzIHx8IFtdKS5maWx0ZXIoXG4gICAgKG1hcmtEZWYpID0+IHVzZWRNYXJrRGVmcy5pbmNsdWRlcyhtYXJrRGVmLl9rZXkpXG4gICksIGJsb2NrO1xufVxuZnVuY3Rpb24gaHRtbFRvQmxvY2tzKGh0bWwsIHNjaGVtYVR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBzY2hlbWEgPSBpc1Nhbml0eVNjaGVtYShzY2hlbWFUeXBlKSA/IHNhbml0eVNjaGVtYVRvUG9ydGFibGVUZXh0U2NoZW1hKHNjaGVtYVR5cGUpIDogc2NoZW1hVHlwZTtcbiAgcmV0dXJuIG5ldyBIdG1sRGVzZXJpYWxpemVyKHNjaGVtYSwgb3B0aW9ucykuZGVzZXJpYWxpemUoaHRtbCkubWFwKChibG9jaykgPT4gbm9ybWFsaXplQmxvY2soYmxvY2ssIHsga2V5R2VuZXJhdG9yOiBvcHRpb25zLmtleUdlbmVyYXRvciB9KSk7XG59XG5mdW5jdGlvbiBpc1Nhbml0eVNjaGVtYShzY2hlbWEpIHtcbiAgcmV0dXJuIHNjaGVtYS5oYXNPd25Qcm9wZXJ0eShcImpzb25UeXBlXCIpO1xufVxuZXhwb3J0IHtcbiAgaHRtbFRvQmxvY2tzLFxuICBub3JtYWxpemVCbG9jayxcbiAgcmFuZG9tS2V5XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@portabletext/block-tools/lib/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/selector.get-selection-text.js":
/*!******************************************************************************************!*\
  !*** ../node_modules/@portabletext/editor/lib/_chunks-es/selector.get-selection-text.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFocusBlock: () => (/* binding */ getFocusBlock),\n/* harmony export */   getFocusChild: () => (/* binding */ getFocusChild),\n/* harmony export */   getFocusSpan: () => (/* binding */ getFocusSpan),\n/* harmony export */   getFocusTextBlock: () => (/* binding */ getFocusTextBlock),\n/* harmony export */   getPreviousInlineObject: () => (/* binding */ getPreviousInlineObject),\n/* harmony export */   getSelectedValue: () => (/* binding */ getSelectedValue),\n/* harmony export */   getSelectionStartPoint: () => (/* binding */ getSelectionStartPoint),\n/* harmony export */   getSelectionText: () => (/* binding */ getSelectionText),\n/* harmony export */   isSelectionCollapsed: () => (/* binding */ isSelectionCollapsed),\n/* harmony export */   isSelectionExpanded: () => (/* binding */ isSelectionExpanded)\n/* harmony export */ });\n/* harmony import */ var _portabletext_schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @portabletext/schema */ \"(ssr)/../node_modules/@portabletext/schema/dist/index.js\");\n/* harmony import */ var _util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.get-text-block-text.js */ \"(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/util.get-text-block-text.js\");\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/../node_modules/@sanity/types/lib/index.mjs\");\n\n\n\nconst getFocusBlock = (snapshot) => {\n  if (!snapshot.context.selection)\n    return;\n  const key = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_0__.getBlockKeyFromSelectionPoint)(snapshot.context.selection.focus), index = key ? snapshot.blockIndexMap.get(key) : void 0, node = index !== void 0 ? snapshot.context.value.at(index) : void 0;\n  return node && key ? {\n    node,\n    path: [{\n      _key: key\n    }]\n  } : void 0;\n}, getFocusTextBlock = (snapshot) => {\n  const focusBlock = getFocusBlock(snapshot);\n  return focusBlock && (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_1__.isTextBlock)(snapshot.context, focusBlock.node) ? {\n    node: focusBlock.node,\n    path: focusBlock.path\n  } : void 0;\n}, getFocusChild = (snapshot) => {\n  if (!snapshot.context.selection)\n    return;\n  const focusBlock = getFocusTextBlock(snapshot);\n  if (!focusBlock)\n    return;\n  const key = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_0__.getChildKeyFromSelectionPoint)(snapshot.context.selection.focus), node = key ? focusBlock.node.children.find((span) => span._key === key) : void 0;\n  return node && key ? {\n    node,\n    path: [...focusBlock.path, \"children\", {\n      _key: key\n    }]\n  } : void 0;\n}, getFocusSpan = (snapshot) => {\n  const focusChild = getFocusChild(snapshot);\n  return focusChild && (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_1__.isSpan)(snapshot.context, focusChild.node) ? {\n    node: focusChild.node,\n    path: focusChild.path\n  } : void 0;\n}, getSelectionStartPoint = (snapshot) => {\n  if (snapshot.context.selection)\n    return snapshot.context.selection.backward ? snapshot.context.selection.focus : snapshot.context.selection.anchor;\n}, isSelectionCollapsed = (snapshot) => snapshot.context.selection ? JSON.stringify(snapshot.context.selection.anchor.path) === JSON.stringify(snapshot.context.selection.focus.path) && snapshot.context.selection?.anchor.offset === snapshot.context.selection?.focus.offset : !1, isSelectionExpanded = (snapshot) => !isSelectionCollapsed(snapshot), getSelectedValue = (snapshot) => {\n  const selection = snapshot.context.selection;\n  if (!selection)\n    return [];\n  const startPoint = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_0__.getSelectionStartPoint)(selection), endPoint = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_0__.getSelectionEndPoint)(selection), startBlockKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_0__.getBlockKeyFromSelectionPoint)(startPoint), endBlockKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_0__.getBlockKeyFromSelectionPoint)(endPoint);\n  if (!startBlockKey || !endBlockKey)\n    return [];\n  const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey), endBlockIndex = snapshot.blockIndexMap.get(endBlockKey);\n  if (startBlockIndex === void 0 || endBlockIndex === void 0)\n    return [];\n  const startBlock = snapshot.context.value.at(startBlockIndex), slicedStartBlock = startBlock ? (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_0__.sliceBlocks)({\n    context: snapshot.context,\n    blocks: [startBlock]\n  }).at(0) : void 0;\n  if (startBlockIndex === endBlockIndex)\n    return slicedStartBlock ? [slicedStartBlock] : [];\n  const endBlock = snapshot.context.value.at(endBlockIndex), slicedEndBlock = endBlock ? (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_0__.sliceBlocks)({\n    context: snapshot.context,\n    blocks: [endBlock]\n  }).at(0) : void 0, middleBlocks = snapshot.context.value.slice(startBlockIndex + 1, endBlockIndex);\n  return [...slicedStartBlock ? [slicedStartBlock] : [], ...middleBlocks, ...slicedEndBlock ? [slicedEndBlock] : []];\n}, getPreviousInlineObject = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot), selectionStartPoint = getSelectionStartPoint(snapshot), selectionStartPointChildKey = selectionStartPoint && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_2__.isKeySegment)(selectionStartPoint.path[2]) ? selectionStartPoint.path[2]._key : void 0;\n  if (!focusTextBlock || !selectionStartPointChildKey)\n    return;\n  let inlineObject;\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionStartPointChildKey)\n      break;\n    (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_1__.isSpan)(snapshot.context, child) || (inlineObject = {\n      node: child,\n      path: [...focusTextBlock.path, \"children\", {\n        _key: child._key\n      }]\n    });\n  }\n  return inlineObject;\n}, getSelectionText = (snapshot) => getSelectedValue(snapshot).reduce((text, block) => (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_1__.isTextBlock)(snapshot.context, block) ? text + block.children.reduce((text2, child) => (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_1__.isSpan)(snapshot.context, child) ? text2 + child.text : text2, \"\") : text, \"\");\n\n//# sourceMappingURL=selector.get-selection-text.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9fY2h1bmtzLWVzL3NlbGVjdG9yLmdldC1zZWxlY3Rpb24tdGV4dC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQTJEO0FBQ3lJO0FBQ3ZKO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkZBQTZCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSixDQUFDO0FBQ0Q7QUFDQSx1QkFBdUIsaUVBQVc7QUFDbEM7QUFDQTtBQUNBLElBQUk7QUFDSixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkZBQTZCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSixDQUFDO0FBQ0Q7QUFDQSx1QkFBdUIsNERBQU07QUFDN0I7QUFDQTtBQUNBLElBQUk7QUFDSixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0ZBQXdCLHdCQUF3QixrRkFBb0IsNkJBQTZCLDJGQUE2Qiw0QkFBNEIsMkZBQTZCO0FBQzVNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcseUVBQVc7QUFDNUc7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EseUZBQXlGLHlFQUFXO0FBQ3BHO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0QsbUtBQW1LLDJEQUFZO0FBQy9LO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNERBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDLHNGQUFzRixpRUFBVywyRUFBMkUsNERBQU07QUFZakw7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL0dhbG9jay9DUy9iZWhvbWUtc2l0ZS9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvc2VsZWN0b3IuZ2V0LXNlbGVjdGlvbi10ZXh0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzVGV4dEJsb2NrLCBpc1NwYW4gfSBmcm9tIFwiQHBvcnRhYmxldGV4dC9zY2hlbWFcIjtcbmltcG9ydCB7IGdldEJsb2NrS2V5RnJvbVNlbGVjdGlvblBvaW50LCBnZXRDaGlsZEtleUZyb21TZWxlY3Rpb25Qb2ludCwgZ2V0U2VsZWN0aW9uU3RhcnRQb2ludCBhcyBnZXRTZWxlY3Rpb25TdGFydFBvaW50JDEsIGdldFNlbGVjdGlvbkVuZFBvaW50LCBzbGljZUJsb2NrcyB9IGZyb20gXCIuL3V0aWwuZ2V0LXRleHQtYmxvY2stdGV4dC5qc1wiO1xuaW1wb3J0IHsgaXNLZXlTZWdtZW50IH0gZnJvbSBcIkBzYW5pdHkvdHlwZXNcIjtcbmNvbnN0IGdldEZvY3VzQmxvY2sgPSAoc25hcHNob3QpID0+IHtcbiAgaWYgKCFzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbilcbiAgICByZXR1cm47XG4gIGNvbnN0IGtleSA9IGdldEJsb2NrS2V5RnJvbVNlbGVjdGlvblBvaW50KHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmZvY3VzKSwgaW5kZXggPSBrZXkgPyBzbmFwc2hvdC5ibG9ja0luZGV4TWFwLmdldChrZXkpIDogdm9pZCAwLCBub2RlID0gaW5kZXggIT09IHZvaWQgMCA/IHNuYXBzaG90LmNvbnRleHQudmFsdWUuYXQoaW5kZXgpIDogdm9pZCAwO1xuICByZXR1cm4gbm9kZSAmJiBrZXkgPyB7XG4gICAgbm9kZSxcbiAgICBwYXRoOiBbe1xuICAgICAgX2tleToga2V5XG4gICAgfV1cbiAgfSA6IHZvaWQgMDtcbn0sIGdldEZvY3VzVGV4dEJsb2NrID0gKHNuYXBzaG90KSA9PiB7XG4gIGNvbnN0IGZvY3VzQmxvY2sgPSBnZXRGb2N1c0Jsb2NrKHNuYXBzaG90KTtcbiAgcmV0dXJuIGZvY3VzQmxvY2sgJiYgaXNUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgZm9jdXNCbG9jay5ub2RlKSA/IHtcbiAgICBub2RlOiBmb2N1c0Jsb2NrLm5vZGUsXG4gICAgcGF0aDogZm9jdXNCbG9jay5wYXRoXG4gIH0gOiB2b2lkIDA7XG59LCBnZXRGb2N1c0NoaWxkID0gKHNuYXBzaG90KSA9PiB7XG4gIGlmICghc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24pXG4gICAgcmV0dXJuO1xuICBjb25zdCBmb2N1c0Jsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soc25hcHNob3QpO1xuICBpZiAoIWZvY3VzQmxvY2spXG4gICAgcmV0dXJuO1xuICBjb25zdCBrZXkgPSBnZXRDaGlsZEtleUZyb21TZWxlY3Rpb25Qb2ludChzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5mb2N1cyksIG5vZGUgPSBrZXkgPyBmb2N1c0Jsb2NrLm5vZGUuY2hpbGRyZW4uZmluZCgoc3BhbikgPT4gc3Bhbi5fa2V5ID09PSBrZXkpIDogdm9pZCAwO1xuICByZXR1cm4gbm9kZSAmJiBrZXkgPyB7XG4gICAgbm9kZSxcbiAgICBwYXRoOiBbLi4uZm9jdXNCbG9jay5wYXRoLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgIF9rZXk6IGtleVxuICAgIH1dXG4gIH0gOiB2b2lkIDA7XG59LCBnZXRGb2N1c1NwYW4gPSAoc25hcHNob3QpID0+IHtcbiAgY29uc3QgZm9jdXNDaGlsZCA9IGdldEZvY3VzQ2hpbGQoc25hcHNob3QpO1xuICByZXR1cm4gZm9jdXNDaGlsZCAmJiBpc1NwYW4oc25hcHNob3QuY29udGV4dCwgZm9jdXNDaGlsZC5ub2RlKSA/IHtcbiAgICBub2RlOiBmb2N1c0NoaWxkLm5vZGUsXG4gICAgcGF0aDogZm9jdXNDaGlsZC5wYXRoXG4gIH0gOiB2b2lkIDA7XG59LCBnZXRTZWxlY3Rpb25TdGFydFBvaW50ID0gKHNuYXBzaG90KSA9PiB7XG4gIGlmIChzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbilcbiAgICByZXR1cm4gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uYmFja3dhcmQgPyBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5mb2N1cyA6IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmFuY2hvcjtcbn0sIGlzU2VsZWN0aW9uQ29sbGFwc2VkID0gKHNuYXBzaG90KSA9PiBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbiA/IEpTT04uc3RyaW5naWZ5KHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmFuY2hvci5wYXRoKSA9PT0gSlNPTi5zdHJpbmdpZnkoc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uZm9jdXMucGF0aCkgJiYgc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24/LmFuY2hvci5vZmZzZXQgPT09IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uPy5mb2N1cy5vZmZzZXQgOiAhMSwgaXNTZWxlY3Rpb25FeHBhbmRlZCA9IChzbmFwc2hvdCkgPT4gIWlzU2VsZWN0aW9uQ29sbGFwc2VkKHNuYXBzaG90KSwgZ2V0U2VsZWN0ZWRWYWx1ZSA9IChzbmFwc2hvdCkgPT4ge1xuICBjb25zdCBzZWxlY3Rpb24gPSBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbjtcbiAgaWYgKCFzZWxlY3Rpb24pXG4gICAgcmV0dXJuIFtdO1xuICBjb25zdCBzdGFydFBvaW50ID0gZ2V0U2VsZWN0aW9uU3RhcnRQb2ludCQxKHNlbGVjdGlvbiksIGVuZFBvaW50ID0gZ2V0U2VsZWN0aW9uRW5kUG9pbnQoc2VsZWN0aW9uKSwgc3RhcnRCbG9ja0tleSA9IGdldEJsb2NrS2V5RnJvbVNlbGVjdGlvblBvaW50KHN0YXJ0UG9pbnQpLCBlbmRCbG9ja0tleSA9IGdldEJsb2NrS2V5RnJvbVNlbGVjdGlvblBvaW50KGVuZFBvaW50KTtcbiAgaWYgKCFzdGFydEJsb2NrS2V5IHx8ICFlbmRCbG9ja0tleSlcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IHN0YXJ0QmxvY2tJbmRleCA9IHNuYXBzaG90LmJsb2NrSW5kZXhNYXAuZ2V0KHN0YXJ0QmxvY2tLZXkpLCBlbmRCbG9ja0luZGV4ID0gc25hcHNob3QuYmxvY2tJbmRleE1hcC5nZXQoZW5kQmxvY2tLZXkpO1xuICBpZiAoc3RhcnRCbG9ja0luZGV4ID09PSB2b2lkIDAgfHwgZW5kQmxvY2tJbmRleCA9PT0gdm9pZCAwKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3Qgc3RhcnRCbG9jayA9IHNuYXBzaG90LmNvbnRleHQudmFsdWUuYXQoc3RhcnRCbG9ja0luZGV4KSwgc2xpY2VkU3RhcnRCbG9jayA9IHN0YXJ0QmxvY2sgPyBzbGljZUJsb2Nrcyh7XG4gICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICBibG9ja3M6IFtzdGFydEJsb2NrXVxuICB9KS5hdCgwKSA6IHZvaWQgMDtcbiAgaWYgKHN0YXJ0QmxvY2tJbmRleCA9PT0gZW5kQmxvY2tJbmRleClcbiAgICByZXR1cm4gc2xpY2VkU3RhcnRCbG9jayA/IFtzbGljZWRTdGFydEJsb2NrXSA6IFtdO1xuICBjb25zdCBlbmRCbG9jayA9IHNuYXBzaG90LmNvbnRleHQudmFsdWUuYXQoZW5kQmxvY2tJbmRleCksIHNsaWNlZEVuZEJsb2NrID0gZW5kQmxvY2sgPyBzbGljZUJsb2Nrcyh7XG4gICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICBibG9ja3M6IFtlbmRCbG9ja11cbiAgfSkuYXQoMCkgOiB2b2lkIDAsIG1pZGRsZUJsb2NrcyA9IHNuYXBzaG90LmNvbnRleHQudmFsdWUuc2xpY2Uoc3RhcnRCbG9ja0luZGV4ICsgMSwgZW5kQmxvY2tJbmRleCk7XG4gIHJldHVybiBbLi4uc2xpY2VkU3RhcnRCbG9jayA/IFtzbGljZWRTdGFydEJsb2NrXSA6IFtdLCAuLi5taWRkbGVCbG9ja3MsIC4uLnNsaWNlZEVuZEJsb2NrID8gW3NsaWNlZEVuZEJsb2NrXSA6IFtdXTtcbn0sIGdldFByZXZpb3VzSW5saW5lT2JqZWN0ID0gKHNuYXBzaG90KSA9PiB7XG4gIGNvbnN0IGZvY3VzVGV4dEJsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soc25hcHNob3QpLCBzZWxlY3Rpb25TdGFydFBvaW50ID0gZ2V0U2VsZWN0aW9uU3RhcnRQb2ludChzbmFwc2hvdCksIHNlbGVjdGlvblN0YXJ0UG9pbnRDaGlsZEtleSA9IHNlbGVjdGlvblN0YXJ0UG9pbnQgJiYgaXNLZXlTZWdtZW50KHNlbGVjdGlvblN0YXJ0UG9pbnQucGF0aFsyXSkgPyBzZWxlY3Rpb25TdGFydFBvaW50LnBhdGhbMl0uX2tleSA6IHZvaWQgMDtcbiAgaWYgKCFmb2N1c1RleHRCbG9jayB8fCAhc2VsZWN0aW9uU3RhcnRQb2ludENoaWxkS2V5KVxuICAgIHJldHVybjtcbiAgbGV0IGlubGluZU9iamVjdDtcbiAgZm9yIChjb25zdCBjaGlsZCBvZiBmb2N1c1RleHRCbG9jay5ub2RlLmNoaWxkcmVuKSB7XG4gICAgaWYgKGNoaWxkLl9rZXkgPT09IHNlbGVjdGlvblN0YXJ0UG9pbnRDaGlsZEtleSlcbiAgICAgIGJyZWFrO1xuICAgIGlzU3BhbihzbmFwc2hvdC5jb250ZXh0LCBjaGlsZCkgfHwgKGlubGluZU9iamVjdCA9IHtcbiAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgcGF0aDogWy4uLmZvY3VzVGV4dEJsb2NrLnBhdGgsIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICB9XVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBpbmxpbmVPYmplY3Q7XG59LCBnZXRTZWxlY3Rpb25UZXh0ID0gKHNuYXBzaG90KSA9PiBnZXRTZWxlY3RlZFZhbHVlKHNuYXBzaG90KS5yZWR1Y2UoKHRleHQsIGJsb2NrKSA9PiBpc1RleHRCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBibG9jaykgPyB0ZXh0ICsgYmxvY2suY2hpbGRyZW4ucmVkdWNlKCh0ZXh0MiwgY2hpbGQpID0+IGlzU3BhbihzbmFwc2hvdC5jb250ZXh0LCBjaGlsZCkgPyB0ZXh0MiArIGNoaWxkLnRleHQgOiB0ZXh0MiwgXCJcIikgOiB0ZXh0LCBcIlwiKTtcbmV4cG9ydCB7XG4gIGdldEZvY3VzQmxvY2ssXG4gIGdldEZvY3VzQ2hpbGQsXG4gIGdldEZvY3VzU3BhbixcbiAgZ2V0Rm9jdXNUZXh0QmxvY2ssXG4gIGdldFByZXZpb3VzSW5saW5lT2JqZWN0LFxuICBnZXRTZWxlY3RlZFZhbHVlLFxuICBnZXRTZWxlY3Rpb25TdGFydFBvaW50LFxuICBnZXRTZWxlY3Rpb25UZXh0LFxuICBpc1NlbGVjdGlvbkNvbGxhcHNlZCxcbiAgaXNTZWxlY3Rpb25FeHBhbmRlZFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlbGVjdG9yLmdldC1zZWxlY3Rpb24tdGV4dC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/selector.get-selection-text.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/selector.get-text-before.js":
/*!***************************************************************************************!*\
  !*** ../node_modules/@portabletext/editor/lib/_chunks-es/selector.get-text-before.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBlockTextBefore: () => (/* binding */ getBlockTextBefore)\n/* harmony export */ });\n/* harmony import */ var _util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.get-text-block-text.js */ \"(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/util.get-text-block-text.js\");\n/* harmony import */ var _selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selector.get-selection-text.js */ \"(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/selector.get-selection-text.js\");\n\n\nconst getBlockTextBefore = (snapshot) => {\n  if (!snapshot.context.selection)\n    return \"\";\n  const startPoint = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_0__.getSelectionStartPoint)(snapshot.context.selection), block = (0,_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_1__.getFocusBlock)({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: startPoint,\n        focus: startPoint\n      }\n    }\n  });\n  if (!block)\n    return \"\";\n  const startOfBlock = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_0__.getBlockStartPoint)({\n    context: snapshot.context,\n    block\n  });\n  return (0,_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_1__.getSelectionText)({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: startOfBlock,\n        focus: startPoint\n      }\n    }\n  });\n};\n\n//# sourceMappingURL=selector.get-text-before.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9fY2h1bmtzLWVzL3NlbGVjdG9yLmdldC10ZXh0LWJlZm9yZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMkY7QUFDUjtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0ZBQXNCLHNDQUFzQyw4RUFBYTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUIsZ0ZBQWtCO0FBQ3pDO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsU0FBUyxpRkFBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9HYWxvY2svQ1MvYmVob21lLXNpdGUvbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9fY2h1bmtzLWVzL3NlbGVjdG9yLmdldC10ZXh0LWJlZm9yZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRTZWxlY3Rpb25TdGFydFBvaW50LCBnZXRCbG9ja1N0YXJ0UG9pbnQgfSBmcm9tIFwiLi91dGlsLmdldC10ZXh0LWJsb2NrLXRleHQuanNcIjtcbmltcG9ydCB7IGdldEZvY3VzQmxvY2ssIGdldFNlbGVjdGlvblRleHQgfSBmcm9tIFwiLi9zZWxlY3Rvci5nZXQtc2VsZWN0aW9uLXRleHQuanNcIjtcbmNvbnN0IGdldEJsb2NrVGV4dEJlZm9yZSA9IChzbmFwc2hvdCkgPT4ge1xuICBpZiAoIXNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uKVxuICAgIHJldHVybiBcIlwiO1xuICBjb25zdCBzdGFydFBvaW50ID0gZ2V0U2VsZWN0aW9uU3RhcnRQb2ludChzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbiksIGJsb2NrID0gZ2V0Rm9jdXNCbG9jayh7XG4gICAgLi4uc25hcHNob3QsXG4gICAgY29udGV4dDoge1xuICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICBhbmNob3I6IHN0YXJ0UG9pbnQsXG4gICAgICAgIGZvY3VzOiBzdGFydFBvaW50XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgaWYgKCFibG9jaylcbiAgICByZXR1cm4gXCJcIjtcbiAgY29uc3Qgc3RhcnRPZkJsb2NrID0gZ2V0QmxvY2tTdGFydFBvaW50KHtcbiAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgIGJsb2NrXG4gIH0pO1xuICByZXR1cm4gZ2V0U2VsZWN0aW9uVGV4dCh7XG4gICAgLi4uc25hcHNob3QsXG4gICAgY29udGV4dDoge1xuICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICBhbmNob3I6IHN0YXJ0T2ZCbG9jayxcbiAgICAgICAgZm9jdXM6IHN0YXJ0UG9pbnRcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcbmV4cG9ydCB7XG4gIGdldEJsb2NrVGV4dEJlZm9yZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlbGVjdG9yLmdldC10ZXh0LWJlZm9yZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/selector.get-text-before.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/selector.is-active-style.js":
/*!***************************************************************************************!*\
  !*** ../node_modules/@portabletext/editor/lib/_chunks-es/selector.is-active-style.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getActiveAnnotations: () => (/* binding */ getActiveAnnotations),\n/* harmony export */   getActiveAnnotationsMarks: () => (/* binding */ getActiveAnnotationsMarks),\n/* harmony export */   getActiveDecorators: () => (/* binding */ getActiveDecorators),\n/* harmony export */   getActiveListItem: () => (/* binding */ getActiveListItem),\n/* harmony export */   getActiveStyle: () => (/* binding */ getActiveStyle),\n/* harmony export */   getCaretWordSelection: () => (/* binding */ getCaretWordSelection),\n/* harmony export */   getFirstBlock: () => (/* binding */ getFirstBlock),\n/* harmony export */   getFocusBlockObject: () => (/* binding */ getFocusBlockObject),\n/* harmony export */   getFocusInlineObject: () => (/* binding */ getFocusInlineObject),\n/* harmony export */   getFocusListBlock: () => (/* binding */ getFocusListBlock),\n/* harmony export */   getLastBlock: () => (/* binding */ getLastBlock),\n/* harmony export */   getMarkState: () => (/* binding */ getMarkState),\n/* harmony export */   getNextBlock: () => (/* binding */ getNextBlock),\n/* harmony export */   getNextInlineObject: () => (/* binding */ getNextInlineObject),\n/* harmony export */   getPreviousBlock: () => (/* binding */ getPreviousBlock),\n/* harmony export */   getSelectedBlocks: () => (/* binding */ getSelectedBlocks),\n/* harmony export */   getSelectedSpans: () => (/* binding */ getSelectedSpans),\n/* harmony export */   getSelectedTextBlocks: () => (/* binding */ getSelectedTextBlocks),\n/* harmony export */   getSelectionEndBlock: () => (/* binding */ getSelectionEndBlock),\n/* harmony export */   getSelectionEndPoint: () => (/* binding */ getSelectionEndPoint),\n/* harmony export */   getSelectionStartBlock: () => (/* binding */ getSelectionStartBlock),\n/* harmony export */   getTrimmedSelection: () => (/* binding */ getTrimmedSelection),\n/* harmony export */   isActiveAnnotation: () => (/* binding */ isActiveAnnotation),\n/* harmony export */   isActiveDecorator: () => (/* binding */ isActiveDecorator),\n/* harmony export */   isActiveListItem: () => (/* binding */ isActiveListItem),\n/* harmony export */   isActiveStyle: () => (/* binding */ isActiveStyle),\n/* harmony export */   isAtTheEndOfBlock: () => (/* binding */ isAtTheEndOfBlock),\n/* harmony export */   isAtTheStartOfBlock: () => (/* binding */ isAtTheStartOfBlock),\n/* harmony export */   isOverlappingSelection: () => (/* binding */ isOverlappingSelection),\n/* harmony export */   isPointAfterSelection: () => (/* binding */ isPointAfterSelection),\n/* harmony export */   isPointBeforeSelection: () => (/* binding */ isPointBeforeSelection),\n/* harmony export */   isSelectingEntireBlocks: () => (/* binding */ isSelectingEntireBlocks)\n/* harmony export */ });\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/../node_modules/@sanity/types/lib/index.mjs\");\n/* harmony import */ var _selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selector.get-selection-text.js */ \"(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/selector.get-selection-text.js\");\n/* harmony import */ var _util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util.is-empty-text-block.js */ \"(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/util.is-empty-text-block.js\");\n/* harmony import */ var _portabletext_schema__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @portabletext/schema */ \"(ssr)/../node_modules/@portabletext/schema/dist/index.js\");\n/* harmony import */ var _util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.get-text-block-text.js */ \"(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/util.get-text-block-text.js\");\n\n\n\n\n\nconst getFocusInlineObject = (snapshot) => {\n  const focusChild = (0,_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_0__.getFocusChild)(snapshot);\n  return focusChild && !(0,_sanity_types__WEBPACK_IMPORTED_MODULE_1__.isPortableTextSpan)(focusChild.node) ? {\n    node: focusChild.node,\n    path: focusChild.path\n  } : void 0;\n}, getSelectedBlocks = (snapshot) => {\n  if (!snapshot.context.selection)\n    return [];\n  const selectedBlocks = [], startPoint = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getSelectionStartPoint)(snapshot.context.selection), endPoint = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getSelectionEndPoint)(snapshot.context.selection), startKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getBlockKeyFromSelectionPoint)(startPoint), endKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getBlockKeyFromSelectionPoint)(endPoint);\n  if (!startKey || !endKey)\n    return selectedBlocks;\n  const startBlockIndex = snapshot.blockIndexMap.get(startKey), endBlockIndex = snapshot.blockIndexMap.get(endKey);\n  if (startBlockIndex === void 0 || endBlockIndex === void 0)\n    return selectedBlocks;\n  const slicedValue = snapshot.context.value.slice(startBlockIndex, endBlockIndex + 1);\n  for (const block of slicedValue) {\n    if (block._key === startKey) {\n      if (selectedBlocks.push({\n        node: block,\n        path: [{\n          _key: block._key\n        }]\n      }), startKey === endKey)\n        break;\n      continue;\n    }\n    if (block._key === endKey) {\n      selectedBlocks.push({\n        node: block,\n        path: [{\n          _key: block._key\n        }]\n      });\n      break;\n    }\n    selectedBlocks.length > 0 && selectedBlocks.push({\n      node: block,\n      path: [{\n        _key: block._key\n      }]\n    });\n  }\n  return selectedBlocks;\n}, getSelectionEndBlock = (snapshot) => {\n  const endPoint = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getSelectionEndPoint)(snapshot.context.selection);\n  if (endPoint)\n    return (0,_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_0__.getFocusBlock)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: endPoint,\n          focus: endPoint\n        }\n      }\n    });\n}, getSelectionStartBlock = (snapshot) => {\n  const startPoint = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getSelectionStartPoint)(snapshot.context.selection);\n  if (startPoint)\n    return (0,_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_0__.getFocusBlock)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: startPoint,\n          focus: startPoint\n        }\n      }\n    });\n}, getSelectionEndPoint = (snapshot) => {\n  if (snapshot.context.selection)\n    return snapshot.context.selection.backward ? snapshot.context.selection.anchor : snapshot.context.selection.focus;\n};\nfunction isPointAfterSelection(point) {\n  return (snapshot) => {\n    if (!snapshot.context.selection)\n      return !1;\n    const endPoint = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getSelectionEndPoint)(snapshot.context.selection), endBlockKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getBlockKeyFromSelectionPoint)(endPoint), endChildKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getChildKeyFromSelectionPoint)(endPoint), pointBlockKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getBlockKeyFromSelectionPoint)(point), pointChildKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getChildKeyFromSelectionPoint)(point);\n    if (!pointBlockKey || !endBlockKey)\n      return !1;\n    const pointBlockIndex = snapshot.blockIndexMap.get(pointBlockKey), endBlockIndex = snapshot.blockIndexMap.get(endBlockKey);\n    if (pointBlockIndex === void 0 || endBlockIndex === void 0)\n      return !1;\n    if (pointBlockIndex > endBlockIndex)\n      return !0;\n    if (pointBlockIndex < endBlockIndex)\n      return !1;\n    const pointBlock = snapshot.context.value.at(pointBlockIndex);\n    if (!pointBlock || !(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_3__.isTextBlock)(snapshot.context, pointBlock))\n      return !1;\n    let pointChildIndex, endChildIndex, childIndex = -1;\n    for (const child of pointBlock.children) {\n      if (childIndex++, child._key === pointChildKey && child._key === endChildKey)\n        return point.offset > endPoint.offset;\n      if (child._key === pointChildKey && (pointChildIndex = childIndex), child._key === endChildKey && (endChildIndex = childIndex), pointChildIndex !== void 0 && endChildIndex !== void 0)\n        break;\n    }\n    return pointChildIndex === void 0 || endChildIndex === void 0 ? !1 : pointChildIndex > endChildIndex;\n  };\n}\nfunction isPointBeforeSelection(point) {\n  return (snapshot) => {\n    if (!snapshot.context.selection)\n      return !1;\n    const startPoint = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getSelectionStartPoint)(snapshot.context.selection), startBlockKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getBlockKeyFromSelectionPoint)(startPoint), startChildKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getChildKeyFromSelectionPoint)(startPoint), pointBlockKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getBlockKeyFromSelectionPoint)(point), pointChildKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getChildKeyFromSelectionPoint)(point);\n    if (!pointBlockKey || !startBlockKey)\n      return !1;\n    const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey), pointBlockIndex = snapshot.blockIndexMap.get(pointBlockKey);\n    if (startBlockIndex === void 0 || pointBlockIndex === void 0)\n      return !1;\n    if (pointBlockIndex < startBlockIndex)\n      return !0;\n    if (pointBlockIndex > startBlockIndex)\n      return !1;\n    const pointBlock = snapshot.context.value.at(pointBlockIndex);\n    if (!pointBlock || !(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_3__.isTextBlock)(snapshot.context, pointBlock))\n      return !1;\n    let pointChildIndex, startChildIndex, childIndex = -1;\n    for (const child of pointBlock.children) {\n      if (childIndex++, child._key === pointChildKey && child._key === startChildKey)\n        return point.offset < startPoint.offset;\n      if (child._key === pointChildKey && (pointChildIndex = childIndex), child._key === startChildKey && (startChildIndex = childIndex), pointChildIndex !== void 0 && startChildIndex !== void 0)\n        break;\n    }\n    return pointChildIndex === void 0 || startChildIndex === void 0 ? !1 : pointChildIndex < startChildIndex;\n  };\n}\nfunction isOverlappingSelection(selection) {\n  return (snapshot) => {\n    if (!selection || !snapshot.context.selection)\n      return !1;\n    const selectionStartPoint = (0,_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_0__.getSelectionStartPoint)({\n      context: {\n        ...snapshot.context,\n        selection\n      }\n    }), selectionEndPoint = getSelectionEndPoint({\n      context: {\n        ...snapshot.context,\n        selection\n      }\n    }), originalSelectionStartPoint = (0,_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_0__.getSelectionStartPoint)(snapshot), originalSelectionEndPoint = getSelectionEndPoint(snapshot);\n    if (!selectionStartPoint || !selectionEndPoint || !originalSelectionStartPoint || !originalSelectionEndPoint)\n      return !1;\n    const startPointEqualToOriginalStartPoint = (0,_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_4__.isEqualSelectionPoints)(selectionStartPoint, originalSelectionStartPoint), endPointEqualToOriginalEndPoint = (0,_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_4__.isEqualSelectionPoints)(selectionEndPoint, originalSelectionEndPoint);\n    if (startPointEqualToOriginalStartPoint && endPointEqualToOriginalEndPoint)\n      return !0;\n    const startPointBeforeSelection = isPointBeforeSelection(selectionStartPoint)(snapshot), startPointAfterSelection = isPointAfterSelection(selectionStartPoint)(snapshot), endPointBeforeSelection = isPointBeforeSelection(selectionEndPoint)(snapshot), endPointAfterSelection = isPointAfterSelection(selectionEndPoint)(snapshot), originalStartPointBeforeStartPoint = isPointBeforeSelection(originalSelectionStartPoint)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionStartPoint,\n          focus: selectionStartPoint\n        }\n      }\n    }), originalStartPointAfterStartPoint = isPointAfterSelection(originalSelectionStartPoint)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionStartPoint,\n          focus: selectionStartPoint\n        }\n      }\n    }), originalEndPointBeforeEndPoint = isPointBeforeSelection(originalSelectionEndPoint)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionEndPoint,\n          focus: selectionEndPoint\n        }\n      }\n    }), originalEndPointAfterEndPoint = isPointAfterSelection(originalSelectionEndPoint)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionEndPoint,\n          focus: selectionEndPoint\n        }\n      }\n    }), startPointEqualToOriginalEndPoint = (0,_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_4__.isEqualSelectionPoints)(selectionStartPoint, originalSelectionEndPoint), endPointEqualToOriginalStartPoint = (0,_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_4__.isEqualSelectionPoints)(selectionEndPoint, originalSelectionStartPoint);\n    return !endPointEqualToOriginalStartPoint && !startPointEqualToOriginalEndPoint && !originalStartPointBeforeStartPoint && !originalStartPointAfterStartPoint && !originalEndPointBeforeEndPoint && !originalEndPointAfterEndPoint || endPointBeforeSelection && !endPointEqualToOriginalStartPoint || startPointAfterSelection && !startPointEqualToOriginalEndPoint ? !1 : !originalStartPointBeforeStartPoint && originalStartPointAfterStartPoint && !originalEndPointBeforeEndPoint && originalEndPointAfterEndPoint ? !endPointEqualToOriginalStartPoint : originalStartPointBeforeStartPoint && !originalStartPointAfterStartPoint && originalEndPointBeforeEndPoint && !originalEndPointAfterEndPoint ? !startPointEqualToOriginalEndPoint : !startPointAfterSelection || !startPointBeforeSelection || !endPointAfterSelection || !endPointBeforeSelection;\n  };\n}\nconst isSelectingEntireBlocks = (snapshot) => {\n  if (!snapshot.context.selection)\n    return !1;\n  const startPoint = snapshot.context.selection.backward ? snapshot.context.selection.focus : snapshot.context.selection.anchor, endPoint = snapshot.context.selection.backward ? snapshot.context.selection.anchor : snapshot.context.selection.focus, startBlock = getSelectionStartBlock(snapshot), endBlock = getSelectionEndBlock(snapshot);\n  if (!startBlock || !endBlock)\n    return !1;\n  const startBlockStartPoint = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getBlockStartPoint)({\n    context: snapshot.context,\n    block: startBlock\n  }), endBlockEndPoint = (0,_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_4__.getBlockEndPoint)({\n    context: snapshot.context,\n    block: endBlock\n  });\n  return (0,_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_4__.isEqualSelectionPoints)(startBlockStartPoint, startPoint) && (0,_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_4__.isEqualSelectionPoints)(endBlockEndPoint, endPoint);\n};\nfunction isBlockPath(path) {\n  const firstSegment = path.at(0);\n  return path.length === 1 && firstSegment !== void 0 && isRecord(firstSegment) && \"_key\" in firstSegment && typeof firstSegment._key == \"string\";\n}\nfunction isRecord(value) {\n  return !!value && (typeof value == \"object\" || typeof value == \"function\");\n}\nfunction isSelectionExpanded(selection) {\n  return selection ? !(0,_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_4__.isSelectionCollapsed)(selection) : !1;\n}\nconst getNextSpan = (snapshot) => {\n  const selectionEndBlock = getSelectionEndBlock(snapshot), selectionEndPoint = getSelectionEndPoint(snapshot);\n  if (!selectionEndBlock || !selectionEndPoint || !(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_3__.isTextBlock)(snapshot.context, selectionEndBlock.node))\n    return;\n  const selectionEndPointChildKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getChildKeyFromSelectionPoint)(selectionEndPoint);\n  let endPointChildFound = !1, nextSpan;\n  for (const child of selectionEndBlock.node.children) {\n    if (child._key === selectionEndPointChildKey) {\n      endPointChildFound = !0;\n      continue;\n    }\n    if ((0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_3__.isSpan)(snapshot.context, child) && endPointChildFound) {\n      nextSpan = {\n        node: child,\n        path: [...selectionEndBlock.path, \"children\", {\n          _key: child._key\n        }]\n      };\n      break;\n    }\n  }\n  return nextSpan;\n}, getPreviousSpan = (snapshot) => {\n  const selectionStartBlock = getSelectionStartBlock(snapshot), selectionStartPoint = (0,_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_0__.getSelectionStartPoint)(snapshot);\n  if (!selectionStartBlock || !selectionStartPoint || !(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_3__.isTextBlock)(snapshot.context, selectionStartBlock.node))\n    return;\n  const selectionStartPointChildKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getChildKeyFromSelectionPoint)(selectionStartPoint);\n  let previousSpan;\n  for (const child of selectionStartBlock.node.children) {\n    if (child._key === selectionStartPointChildKey)\n      break;\n    (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_3__.isSpan)(snapshot.context, child) && (previousSpan = {\n      node: child,\n      path: [...selectionStartBlock.path, \"children\", {\n        _key: child._key\n      }]\n    });\n  }\n  return previousSpan;\n}, getSelectedSpans = (snapshot) => {\n  if (!snapshot.context.selection)\n    return [];\n  const selectedSpans = [], startPoint = (0,_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_0__.getSelectionStartPoint)(snapshot), endPoint = getSelectionEndPoint(snapshot);\n  if (!startPoint || !endPoint)\n    return selectedSpans;\n  const startBlockKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getBlockKeyFromSelectionPoint)(startPoint), endBlockKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getBlockKeyFromSelectionPoint)(endPoint), startSpanKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getChildKeyFromSelectionPoint)(startPoint), endSpanKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getChildKeyFromSelectionPoint)(endPoint);\n  if (!startBlockKey || !endBlockKey)\n    return selectedSpans;\n  const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey), endBlockIndex = snapshot.blockIndexMap.get(endBlockKey);\n  if (startBlockIndex === void 0 || endBlockIndex === void 0)\n    return selectedSpans;\n  const slicedValue = snapshot.context.value.slice(startBlockIndex, endBlockIndex + 1);\n  let startBlockFound = !1;\n  for (const block of slicedValue)\n    if (block._key === startBlockKey && (startBlockFound = !0), !!(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_3__.isTextBlock)(snapshot.context, block)) {\n      if (block._key === startBlockKey) {\n        for (const child of block.children)\n          if ((0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_3__.isSpan)(snapshot.context, child)) {\n            if (startSpanKey && child._key === startSpanKey) {\n              if (startPoint.offset < child.text.length && selectedSpans.push({\n                node: child,\n                path: [{\n                  _key: block._key\n                }, \"children\", {\n                  _key: child._key\n                }]\n              }), startSpanKey === endSpanKey)\n                break;\n              continue;\n            }\n            if (endSpanKey && child._key === endSpanKey) {\n              endPoint.offset > 0 && selectedSpans.push({\n                node: child,\n                path: [{\n                  _key: block._key\n                }, \"children\", {\n                  _key: child._key\n                }]\n              });\n              break;\n            }\n            selectedSpans.length > 0 && selectedSpans.push({\n              node: child,\n              path: [{\n                _key: block._key\n              }, \"children\", {\n                _key: child._key\n              }]\n            });\n          }\n        if (startBlockKey === endBlockKey)\n          break;\n        continue;\n      }\n      if (block._key === endBlockKey) {\n        for (const child of block.children)\n          if ((0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_3__.isSpan)(snapshot.context, child)) {\n            if (endSpanKey && child._key === endSpanKey) {\n              endPoint.offset > 0 && selectedSpans.push({\n                node: child,\n                path: [{\n                  _key: block._key\n                }, \"children\", {\n                  _key: child._key\n                }]\n              });\n              break;\n            }\n            selectedSpans.push({\n              node: child,\n              path: [{\n                _key: block._key\n              }, \"children\", {\n                _key: child._key\n              }]\n            });\n          }\n        break;\n      }\n      if (startBlockFound)\n        for (const child of block.children)\n          (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_3__.isSpan)(snapshot.context, child) && selectedSpans.push({\n            node: child,\n            path: [{\n              _key: block._key\n            }, \"children\", {\n              _key: child._key\n            }]\n          });\n    }\n  return selectedSpans;\n}, getMarkState = (snapshot) => {\n  if (!snapshot.context.selection)\n    return;\n  let selection = snapshot.context.selection;\n  if (!(0,_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_0__.getFocusTextBlock)(snapshot))\n    return;\n  if (isBlockPath(selection.anchor.path)) {\n    const spanSelectionPoint = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.blockOffsetToSpanSelectionPoint)({\n      context: snapshot.context,\n      blockOffset: {\n        path: selection.anchor.path,\n        offset: selection.anchor.offset\n      },\n      direction: selection.backward ? \"backward\" : \"forward\"\n    });\n    selection = spanSelectionPoint ? {\n      ...selection,\n      anchor: spanSelectionPoint\n    } : selection;\n  }\n  if (isBlockPath(selection.focus.path)) {\n    const spanSelectionPoint = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.blockOffsetToSpanSelectionPoint)({\n      context: snapshot.context,\n      blockOffset: {\n        path: selection.focus.path,\n        offset: selection.focus.offset\n      },\n      direction: selection.backward ? \"backward\" : \"forward\"\n    });\n    selection = spanSelectionPoint ? {\n      ...selection,\n      focus: spanSelectionPoint\n    } : selection;\n  }\n  const focusSpan = (0,_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_0__.getFocusSpan)({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection\n    }\n  });\n  if (!focusSpan)\n    return;\n  if (isSelectionExpanded(selection)) {\n    const selectedSpans = getSelectedSpans({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection\n      }\n    });\n    let index = 0, marks2 = [];\n    for (const span of selectedSpans) {\n      if (index === 0)\n        marks2 = span.node.marks ?? [];\n      else {\n        if (span.node.marks?.length === 0) {\n          marks2 = [];\n          continue;\n        }\n        marks2 = marks2.filter((mark) => (span.node.marks ?? []).some((spanMark) => spanMark === mark));\n      }\n      index++;\n    }\n    return {\n      state: \"unchanged\",\n      marks: marks2\n    };\n  }\n  const decorators = snapshot.context.schema.decorators.map((decorator) => decorator.name), marks = focusSpan.node.marks ?? [], marksWithoutAnnotations = marks.filter((mark) => decorators.includes(mark)), spanHasAnnotations = marks.length > marksWithoutAnnotations.length, spanIsEmpty = focusSpan.node.text.length === 0, atTheBeginningOfSpan = snapshot.context.selection.anchor.offset === 0, atTheEndOfSpan = snapshot.context.selection.anchor.offset === focusSpan.node.text.length, previousSpan = getPreviousSpan({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection\n    }\n  }), nextSpan = getNextSpan({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection\n    }\n  }), nextSpanAnnotations = nextSpan?.node?.marks?.filter((mark) => !decorators.includes(mark)) ?? [], spanAnnotations = marks.filter((mark) => !decorators.includes(mark)), previousSpanHasAnnotations = previousSpan ? previousSpan.node.marks?.some((mark) => !decorators.includes(mark)) : !1, previousSpanHasSameAnnotations = previousSpan ? previousSpan.node.marks?.filter((mark) => !decorators.includes(mark)).every((mark) => marks.includes(mark)) : !1, previousSpanHasSameAnnotation = previousSpan ? previousSpan.node.marks?.some((mark) => !decorators.includes(mark) && marks.includes(mark)) : !1, previousSpanHasSameMarks = previousSpan ? previousSpan.node.marks?.every((mark) => marks.includes(mark)) : !1, nextSpanSharesSomeAnnotations = spanAnnotations.some((mark) => nextSpanAnnotations?.includes(mark));\n  if (spanHasAnnotations && !spanIsEmpty) {\n    if (atTheBeginningOfSpan) {\n      if (previousSpanHasSameMarks)\n        return {\n          state: \"changed\",\n          previousMarks: marks,\n          marks: previousSpan?.node.marks ?? []\n        };\n      if (previousSpanHasSameAnnotations)\n        return {\n          state: \"changed\",\n          previousMarks: marks,\n          marks: previousSpan?.node.marks ?? []\n        };\n      if (previousSpanHasSameAnnotation)\n        return {\n          state: \"unchanged\",\n          previousMarks: marks,\n          marks: focusSpan.node.marks ?? []\n        };\n      if (!previousSpan)\n        return {\n          state: \"changed\",\n          previousMarks: marks,\n          marks: []\n        };\n    }\n    if (atTheEndOfSpan) {\n      if (nextSpan && nextSpanSharesSomeAnnotations && nextSpanAnnotations.length < spanAnnotations.length || !nextSpanSharesSomeAnnotations)\n        return {\n          state: \"changed\",\n          previousMarks: marks,\n          marks: nextSpan?.node.marks ?? []\n        };\n      if (!nextSpan)\n        return {\n          state: \"changed\",\n          previousMarks: marks,\n          marks: []\n        };\n    }\n  }\n  return atTheBeginningOfSpan && !spanIsEmpty && previousSpan ? previousSpanHasAnnotations ? {\n    state: \"changed\",\n    marks,\n    previousMarks: previousSpan?.node.marks ?? []\n  } : {\n    state: \"changed\",\n    previousMarks: marks,\n    marks: (previousSpan?.node.marks ?? []).filter((mark) => decorators.includes(mark))\n  } : {\n    state: \"unchanged\",\n    marks\n  };\n};\nfunction getActiveDecorators(snapshot) {\n  const schema = snapshot.context.schema, decoratorState = snapshot.decoratorState, markState = getMarkState(snapshot), decorators = schema.decorators.map((decorator) => decorator.name);\n  let activeDecorators = (markState?.marks ?? []).filter((mark) => decorators.includes(mark));\n  for (const decorator in decoratorState)\n    decoratorState[decorator] === !1 ? activeDecorators = activeDecorators.filter((activeDecorator) => activeDecorator !== decorator) : decoratorState[decorator] === !0 && (activeDecorators.includes(decorator) || activeDecorators.push(decorator));\n  return activeDecorators;\n}\nconst getTrimmedSelection = (snapshot) => {\n  if (!snapshot.context.selection)\n    return snapshot.context.selection;\n  const startPoint = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getSelectionStartPoint)(snapshot.context.selection), endPoint = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getSelectionEndPoint)(snapshot.context.selection), startBlockKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getBlockKeyFromSelectionPoint)(startPoint), startChildKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getChildKeyFromSelectionPoint)(startPoint), endBlockKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getBlockKeyFromSelectionPoint)(endPoint), endChildKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getChildKeyFromSelectionPoint)(endPoint);\n  if (!startBlockKey || !endBlockKey)\n    return snapshot.context.selection;\n  const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey), endBlockIndex = snapshot.blockIndexMap.get(endBlockKey);\n  if (startBlockIndex === void 0 || endBlockIndex === void 0)\n    return snapshot.context.selection;\n  const slicedValue = snapshot.context.value.slice(startBlockIndex, endBlockIndex + 1);\n  let startBlockFound = !1, adjustedStartPoint, trimStartPoint = !1, adjustedEndPoint, trimEndPoint = !1, previousPotentialEndpoint;\n  for (const block of slicedValue)\n    if (!(block._key === startBlockKey && (startBlockFound = !0, (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_3__.isTextBlock)(snapshot.context, block) && (0,_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_4__.isEmptyTextBlock)(snapshot.context, block))) && startBlockFound && (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_3__.isTextBlock)(snapshot.context, block)) {\n      if (block._key === endBlockKey && (0,_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_4__.isEmptyTextBlock)(snapshot.context, block))\n        break;\n      for (const child of block.children) {\n        if (child._key === endChildKey && (!(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_3__.isSpan)(snapshot.context, child) || endPoint.offset === 0)) {\n          adjustedEndPoint = previousPotentialEndpoint ? {\n            path: [{\n              _key: previousPotentialEndpoint.blockKey\n            }, \"children\", {\n              _key: previousPotentialEndpoint.span._key\n            }],\n            offset: previousPotentialEndpoint.span.text.length\n          } : void 0, trimEndPoint = !0;\n          break;\n        }\n        if (trimStartPoint) {\n          const lonelySpan = (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_3__.isSpan)(snapshot.context, child) && block.children.length === 1;\n          ((0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_3__.isSpan)(snapshot.context, child) && child.text.length > 0 || lonelySpan) && (adjustedStartPoint = {\n            path: [{\n              _key: block._key\n            }, \"children\", {\n              _key: child._key\n            }],\n            offset: 0\n          }, previousPotentialEndpoint = {\n            blockKey: block._key,\n            span: child\n          }, trimStartPoint = !1);\n          continue;\n        }\n        if (child._key === startChildKey) {\n          if (!(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_3__.isSpan)(snapshot.context, child)) {\n            trimStartPoint = !0;\n            continue;\n          }\n          if (startPoint.offset === child.text.length) {\n            trimStartPoint = !0, previousPotentialEndpoint = child.text.length > 0 ? {\n              blockKey: block._key,\n              span: child\n            } : previousPotentialEndpoint;\n            continue;\n          }\n        }\n        previousPotentialEndpoint = (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_3__.isSpan)(snapshot.context, child) && child.text.length > 0 ? {\n          blockKey: block._key,\n          span: child\n        } : previousPotentialEndpoint;\n      }\n      if (block._key === endBlockKey)\n        break;\n    }\n  const trimmedSelection = snapshot.context.selection.backward ? {\n    anchor: trimEndPoint && adjustedEndPoint ? adjustedEndPoint : endPoint,\n    focus: adjustedStartPoint ?? startPoint,\n    backward: !0\n  } : {\n    anchor: adjustedStartPoint ?? startPoint,\n    focus: trimEndPoint && adjustedEndPoint ? adjustedEndPoint : endPoint\n  };\n  if ((0,_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_0__.isSelectionCollapsed)({\n    context: {\n      ...snapshot.context,\n      selection: trimmedSelection\n    }\n  })) {\n    const focusTextBlock = (0,_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_0__.getFocusTextBlock)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: trimmedSelection\n      }\n    });\n    if (focusTextBlock && !(0,_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_4__.isEmptyTextBlock)(snapshot.context, focusTextBlock.node))\n      return null;\n  }\n  return trimmedSelection;\n}, getNextInlineObject = (snapshot) => {\n  const focusTextBlock = (0,_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_0__.getFocusTextBlock)(snapshot), selectionEndPoint = getSelectionEndPoint(snapshot), selectionEndPointChildKey = selectionEndPoint && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_1__.isKeySegment)(selectionEndPoint.path[2]) ? selectionEndPoint.path[2]._key : void 0;\n  if (!focusTextBlock || !selectionEndPointChildKey)\n    return;\n  let endPointChildFound = !1, inlineObject;\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionEndPointChildKey) {\n      endPointChildFound = !0;\n      continue;\n    }\n    if (!(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_3__.isSpan)(snapshot.context, child) && endPointChildFound) {\n      inlineObject = {\n        node: child,\n        path: [...focusTextBlock.path, \"children\", {\n          _key: child._key\n        }]\n      };\n      break;\n    }\n  }\n  return inlineObject;\n}, getCaretWordSelection = (snapshot) => {\n  if (!snapshot.context.selection || !(0,_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_0__.isSelectionCollapsed)(snapshot))\n    return null;\n  const focusTextBlock = (0,_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_0__.getFocusTextBlock)(snapshot), selectionStartPoint = (0,_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_0__.getSelectionStartPoint)(snapshot), selectionStartOffset = selectionStartPoint ? (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.spanSelectionPointToBlockOffset)({\n    context: snapshot.context,\n    selectionPoint: selectionStartPoint\n  }) : void 0;\n  if (!focusTextBlock || !selectionStartPoint || !selectionStartOffset)\n    return null;\n  const previousInlineObject = (0,_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_0__.getPreviousInlineObject)(snapshot), blockStartPoint = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getBlockStartPoint)({\n    context: snapshot.context,\n    block: focusTextBlock\n  }), textDirectlyBefore = (0,_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_0__.getSelectionText)({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: previousInlineObject ? {\n          path: previousInlineObject.path,\n          offset: 0\n        } : blockStartPoint,\n        focus: selectionStartPoint\n      }\n    }\n  }).split(/\\s+/).at(-1), nextInlineObject = getNextInlineObject(snapshot), blockEndPoint = (0,_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_4__.getBlockEndPoint)({\n    context: snapshot.context,\n    block: focusTextBlock\n  }), textDirectlyAfter = (0,_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_0__.getSelectionText)({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: selectionStartPoint,\n        focus: nextInlineObject ? {\n          path: nextInlineObject.path,\n          offset: 0\n        } : blockEndPoint\n      }\n    }\n  }).split(/\\s+/).at(0);\n  if ((textDirectlyBefore === void 0 || textDirectlyBefore === \"\") && (textDirectlyAfter === void 0 || textDirectlyAfter === \"\"))\n    return null;\n  const caretWordStartOffset = textDirectlyBefore ? {\n    ...selectionStartOffset,\n    offset: selectionStartOffset.offset - textDirectlyBefore.length\n  } : selectionStartOffset, caretWordEndOffset = textDirectlyAfter ? {\n    ...selectionStartOffset,\n    offset: selectionStartOffset.offset + textDirectlyAfter.length\n  } : selectionStartOffset, caretWordStartSelectionPoint = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.blockOffsetToSpanSelectionPoint)({\n    context: snapshot.context,\n    blockOffset: caretWordStartOffset,\n    direction: \"backward\"\n  }), caretWordEndSelectionPoint = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.blockOffsetToSpanSelectionPoint)({\n    context: snapshot.context,\n    blockOffset: caretWordEndOffset,\n    direction: \"forward\"\n  });\n  if (!caretWordStartSelectionPoint || !caretWordEndSelectionPoint)\n    return null;\n  const caretWordSelection = {\n    anchor: caretWordStartSelectionPoint,\n    focus: caretWordEndSelectionPoint\n  };\n  return (0,_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_0__.isSelectionExpanded)({\n    context: {\n      ...snapshot.context,\n      selection: caretWordSelection\n    }\n  }) ? caretWordSelection : null;\n};\nfunction getActiveAnnotationsMarks(snapshot) {\n  const schema = snapshot.context.schema;\n  return (getMarkState(snapshot)?.marks ?? []).filter((mark) => !schema.decorators.map((decorator) => decorator.name).includes(mark));\n}\nfunction isActiveAnnotation(annotation, options) {\n  return (snapshot) => {\n    if ((options?.mode ?? \"full\") === \"partial\")\n      return (0,_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_0__.getSelectedValue)(snapshot).flatMap((block) => (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_3__.isTextBlock)(snapshot.context, block) ? block.markDefs ?? [] : []).some((markDef) => markDef._type === annotation);\n    const selectionMarkDefs = getSelectedBlocks(snapshot).flatMap((block) => (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_3__.isTextBlock)(snapshot.context, block.node) ? block.node.markDefs ?? [] : []), activeAnnotations = getActiveAnnotationsMarks(snapshot);\n    return selectionMarkDefs.filter((markDef) => markDef._type === annotation && activeAnnotations.includes(markDef._key)).length > 0;\n  };\n}\nconst getFocusBlockObject = (snapshot) => {\n  const focusBlock = (0,_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_0__.getFocusBlock)(snapshot);\n  return focusBlock && !(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_3__.isTextBlock)(snapshot.context, focusBlock.node) ? {\n    node: focusBlock.node,\n    path: focusBlock.path\n  } : void 0;\n}, getNextBlock = (snapshot) => {\n  const selectionEndBlock = getSelectionEndBlock(snapshot);\n  if (!selectionEndBlock)\n    return;\n  const index = snapshot.blockIndexMap.get(selectionEndBlock.node._key);\n  if (index === void 0 || index === snapshot.context.value.length - 1)\n    return;\n  const nextBlock = snapshot.context.value.at(index + 1);\n  return nextBlock ? {\n    node: nextBlock,\n    path: [{\n      _key: nextBlock._key\n    }]\n  } : void 0;\n}, getPreviousBlock = (snapshot) => {\n  const selectionStartBlock = getSelectionStartBlock(snapshot);\n  if (!selectionStartBlock)\n    return;\n  const index = snapshot.blockIndexMap.get(selectionStartBlock.node._key);\n  if (index === void 0 || index === 0)\n    return;\n  const previousBlock = snapshot.context.value.at(index - 1);\n  return previousBlock ? {\n    node: previousBlock,\n    path: [{\n      _key: previousBlock._key\n    }]\n  } : void 0;\n}, getFirstBlock = (snapshot) => {\n  const node = snapshot.context.value[0];\n  return node ? {\n    node,\n    path: [{\n      _key: node._key\n    }]\n  } : void 0;\n}, getLastBlock = (snapshot) => {\n  const node = snapshot.context.value[snapshot.context.value.length - 1] ? snapshot.context.value[snapshot.context.value.length - 1] : void 0;\n  return node ? {\n    node,\n    path: [{\n      _key: node._key\n    }]\n  } : void 0;\n};\nfunction isAtTheEndOfBlock(block) {\n  return (snapshot) => {\n    if (!snapshot.context.selection || !(0,_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_0__.isSelectionCollapsed)(snapshot))\n      return !1;\n    const blockEndPoint = (0,_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_4__.getBlockEndPoint)({\n      context: snapshot.context,\n      block\n    });\n    return (0,_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_4__.isEqualSelectionPoints)(snapshot.context.selection.focus, blockEndPoint);\n  };\n}\nfunction isAtTheStartOfBlock(block) {\n  return (snapshot) => {\n    if (!snapshot.context.selection || !(0,_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_0__.isSelectionCollapsed)(snapshot))\n      return !1;\n    const blockStartPoint = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getBlockStartPoint)({\n      context: snapshot.context,\n      block\n    });\n    return (0,_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_4__.isEqualSelectionPoints)(snapshot.context.selection.focus, blockStartPoint);\n  };\n}\nconst getFocusListBlock = (snapshot) => {\n  const focusTextBlock = (0,_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_0__.getFocusTextBlock)(snapshot);\n  return focusTextBlock && (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.isListBlock)(snapshot.context, focusTextBlock.node) ? {\n    node: focusTextBlock.node,\n    path: focusTextBlock.path\n  } : void 0;\n};\nfunction isActiveDecorator(decorator) {\n  return (snapshot) => {\n    if ((0,_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_0__.isSelectionExpanded)(snapshot)) {\n      const selectedSpans = getSelectedSpans(snapshot);\n      return selectedSpans.length > 0 && selectedSpans.every((span) => span.node.marks?.includes(decorator));\n    }\n    return getActiveDecorators(snapshot).includes(decorator);\n  };\n}\nconst getActiveAnnotations = (snapshot) => {\n  if (!snapshot.context.selection)\n    return [];\n  const selectedBlocks = getSelectedBlocks(snapshot), activeAnnotations = (getMarkState(snapshot)?.marks ?? []).filter((mark) => !snapshot.context.schema.decorators.map((decorator) => decorator.name).includes(mark));\n  return selectedBlocks.flatMap((block) => (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_3__.isTextBlock)(snapshot.context, block.node) ? block.node.markDefs ?? [] : []).filter((markDef) => activeAnnotations.includes(markDef._key));\n}, getSelectedTextBlocks = (snapshot) => {\n  if (!snapshot.context.selection)\n    return [];\n  const selectedTextBlocks = [], startPoint = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getSelectionStartPoint)(snapshot.context.selection), endPoint = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getSelectionEndPoint)(snapshot.context.selection), startBlockKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getBlockKeyFromSelectionPoint)(startPoint), endBlockKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_2__.getBlockKeyFromSelectionPoint)(endPoint);\n  if (!startBlockKey || !endBlockKey)\n    return selectedTextBlocks;\n  const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey), endBlockIndex = snapshot.blockIndexMap.get(endBlockKey);\n  if (startBlockIndex === void 0 || endBlockIndex === void 0)\n    return selectedTextBlocks;\n  const slicedValue = snapshot.context.value.slice(startBlockIndex, endBlockIndex + 1);\n  for (const block of slicedValue) {\n    if (block._key === startBlockKey) {\n      if ((0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_3__.isTextBlock)(snapshot.context, block) && selectedTextBlocks.push({\n        node: block,\n        path: [{\n          _key: block._key\n        }]\n      }), startBlockKey === endBlockKey)\n        break;\n      continue;\n    }\n    if (block._key === endBlockKey) {\n      (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_3__.isTextBlock)(snapshot.context, block) && selectedTextBlocks.push({\n        node: block,\n        path: [{\n          _key: block._key\n        }]\n      });\n      break;\n    }\n    selectedTextBlocks.length > 0 && (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_3__.isTextBlock)(snapshot.context, block) && selectedTextBlocks.push({\n      node: block,\n      path: [{\n        _key: block._key\n      }]\n    });\n  }\n  return selectedTextBlocks;\n}, getActiveListItem = (snapshot) => {\n  if (!snapshot.context.selection)\n    return;\n  const selectedTextBlocks = getSelectedBlocks(snapshot).map((block) => block.node).filter((block) => (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_3__.isTextBlock)(snapshot.context, block)), firstTextBlock = selectedTextBlocks.at(0);\n  if (!firstTextBlock)\n    return;\n  const firstListItem = firstTextBlock.listItem;\n  if (firstListItem && selectedTextBlocks.every((block) => block.listItem === firstListItem))\n    return firstListItem;\n};\nfunction isActiveListItem(listItem) {\n  return (snapshot) => getActiveListItem(snapshot) === listItem;\n}\nconst getActiveStyle = (snapshot) => {\n  if (!snapshot.context.selection)\n    return;\n  const selectedTextBlocks = getSelectedBlocks(snapshot).map((block) => block.node).filter((block) => (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_3__.isTextBlock)(snapshot.context, block)), firstTextBlock = selectedTextBlocks.at(0);\n  if (!firstTextBlock)\n    return;\n  const firstStyle = firstTextBlock.style;\n  if (firstStyle && selectedTextBlocks.every((block) => block.style === firstStyle))\n    return firstStyle;\n};\nfunction isActiveStyle(style) {\n  return (snapshot) => getActiveStyle(snapshot) === style;\n}\n\n//# sourceMappingURL=selector.is-active-style.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9fY2h1bmtzLWVzL3NlbGVjdG9yLmlzLWFjdGl2ZS1zdHlsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlFO0FBQytQO0FBQy9MO0FBQ3RFO0FBQzZOO0FBQ3hSO0FBQ0EscUJBQXFCLDhFQUFhO0FBQ2xDLHdCQUF3QixpRUFBa0I7QUFDMUM7QUFDQTtBQUNBLElBQUk7QUFDSixDQUFDO0FBQ0Q7QUFDQTtBQUNBLDBDQUEwQyxvRkFBc0IseUNBQXlDLGtGQUFzQix5Q0FBeUMsMkZBQTZCLHVCQUF1QiwyRkFBNkI7QUFDelA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CLGtGQUFzQjtBQUN6QztBQUNBLFdBQVcsOEVBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QscUJBQXFCLG9GQUFzQjtBQUMzQztBQUNBLFdBQVcsOEVBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0ZBQXNCLDRDQUE0QywyRkFBNkIsMEJBQTBCLDJGQUE2Qiw0QkFBNEIsMkZBQTZCLHlCQUF5QiwyRkFBNkI7QUFDMVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUVBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9GQUFzQiw4Q0FBOEMsMkZBQTZCLDhCQUE4QiwyRkFBNkIsOEJBQThCLDJGQUE2Qix5QkFBeUIsMkZBQTZCO0FBQ3BTO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlFQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1RkFBd0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGlDQUFpQyx1RkFBd0I7QUFDOUQ7QUFDQTtBQUNBLGdEQUFnRCxvRkFBc0Isc0ZBQXNGLG9GQUFzQjtBQUNsTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyx1Q0FBdUMsb0ZBQXNCLHNGQUFzRixvRkFBc0I7QUFDOUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdGQUFrQjtBQUNqRDtBQUNBO0FBQ0EsR0FBRyxzQkFBc0IsOEVBQWdCO0FBQ3pDO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsU0FBUyxvRkFBc0Isc0NBQXNDLG9GQUFzQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0ZBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxpRUFBVztBQUM5RDtBQUNBLG9DQUFvQywyRkFBNkI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0REFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsc0ZBQXNGLHVGQUF3QjtBQUM5Ryx1REFBdUQsaUVBQVc7QUFDbEU7QUFDQSxzQ0FBc0MsMkZBQTZCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0REFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EseUNBQXlDLHVGQUF3QjtBQUNqRTtBQUNBO0FBQ0Esd0JBQXdCLDJGQUE2Qiw0QkFBNEIsMkZBQTZCLDJCQUEyQiwyRkFBNkIsMkJBQTJCLDJGQUE2QjtBQUM5TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGlFQUFXO0FBQzdFO0FBQ0E7QUFDQSxjQUFjLDREQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDREQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNERBQU07QUFDaEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLE9BQU8sa0ZBQWlCO0FBQ3hCO0FBQ0E7QUFDQSwrQkFBK0IsNkZBQStCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsK0JBQStCLDZGQUErQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxvQkFBb0IsNkVBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0ZBQXNCLHlDQUF5QyxrRkFBc0IsOENBQThDLDJGQUE2Qiw4QkFBOEIsMkZBQTZCLDRCQUE0QiwyRkFBNkIsMEJBQTBCLDJGQUE2QjtBQUNoVztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGlFQUFXLDZCQUE2Qiw4RUFBZ0Isa0RBQWtELGlFQUFXO0FBQ3RMLHdDQUF3Qyw4RUFBZ0I7QUFDeEQ7QUFDQTtBQUNBLDRDQUE0Qyw0REFBTTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDREQUFNO0FBQ25DLFdBQVcsNERBQU07QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNERBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDREQUFNO0FBQzFDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNLHFGQUFzQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCwyQkFBMkIsa0ZBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkJBQTJCLDhFQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QseUJBQXlCLGtGQUFpQixpSEFBaUgsMkRBQVk7QUFDdks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNERBQU07QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHNDQUFzQyxxRkFBc0I7QUFDNUQ7QUFDQSx5QkFBeUIsa0ZBQWlCLGtDQUFrQyx1RkFBd0IseURBQXlELDZGQUErQjtBQUM1TDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwrQkFBK0Isd0ZBQXVCLDhCQUE4QixnRkFBa0I7QUFDdEc7QUFDQTtBQUNBLEdBQUcsd0JBQXdCLGlGQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxHQUFHLHlGQUF5Riw4RUFBZ0I7QUFDNUc7QUFDQTtBQUNBLEdBQUcsdUJBQXVCLGlGQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSSx1REFBdUQsNkZBQStCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLEdBQUcsZ0NBQWdDLDZGQUErQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxvRkFBcUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUZBQWdCLDhCQUE4QixpRUFBVztBQUN0RSw2RUFBNkUsaUVBQVc7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsOEVBQWE7QUFDbEMsd0JBQXdCLGlFQUFXO0FBQ25DO0FBQ0E7QUFDQSxJQUFJO0FBQ0osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxxRkFBc0I7QUFDOUQ7QUFDQSwwQkFBMEIsOEVBQWdCO0FBQzFDO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsV0FBVyxvRkFBc0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MscUZBQXNCO0FBQzlEO0FBQ0EsNEJBQTRCLGdGQUFrQjtBQUM5QztBQUNBO0FBQ0EsS0FBSztBQUNMLFdBQVcsb0ZBQXNCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrRkFBaUI7QUFDMUMsMkJBQTJCLHlFQUFXO0FBQ3RDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvRkFBcUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaUVBQVc7QUFDdEQsQ0FBQztBQUNEO0FBQ0E7QUFDQSw4Q0FBOEMsb0ZBQXNCLHlDQUF5QyxrRkFBc0IsOENBQThDLDJGQUE2Qiw0QkFBNEIsMkZBQTZCO0FBQ3ZRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlFQUFXO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGlFQUFXO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLHFDQUFxQyxpRUFBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLHNHQUFzRyxpRUFBVztBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0csaUVBQVc7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBa0NFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9HYWxvY2svQ1MvYmVob21lLXNpdGUvbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9fY2h1bmtzLWVzL3NlbGVjdG9yLmlzLWFjdGl2ZS1zdHlsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1BvcnRhYmxlVGV4dFNwYW4sIGlzS2V5U2VnbWVudCB9IGZyb20gXCJAc2FuaXR5L3R5cGVzXCI7XG5pbXBvcnQgeyBnZXRGb2N1c0NoaWxkLCBnZXRGb2N1c0Jsb2NrLCBnZXRTZWxlY3Rpb25TdGFydFBvaW50IGFzIGdldFNlbGVjdGlvblN0YXJ0UG9pbnQkMSwgZ2V0Rm9jdXNUZXh0QmxvY2ssIGdldEZvY3VzU3BhbiwgaXNTZWxlY3Rpb25Db2xsYXBzZWQgYXMgaXNTZWxlY3Rpb25Db2xsYXBzZWQkMSwgZ2V0UHJldmlvdXNJbmxpbmVPYmplY3QsIGdldFNlbGVjdGlvblRleHQsIGlzU2VsZWN0aW9uRXhwYW5kZWQgYXMgaXNTZWxlY3Rpb25FeHBhbmRlZCQxLCBnZXRTZWxlY3RlZFZhbHVlIH0gZnJvbSBcIi4vc2VsZWN0b3IuZ2V0LXNlbGVjdGlvbi10ZXh0LmpzXCI7XG5pbXBvcnQgeyBpc0VxdWFsU2VsZWN0aW9uUG9pbnRzLCBnZXRCbG9ja0VuZFBvaW50LCBpc1NlbGVjdGlvbkNvbGxhcHNlZCwgaXNFbXB0eVRleHRCbG9jayB9IGZyb20gXCIuL3V0aWwuaXMtZW1wdHktdGV4dC1ibG9jay5qc1wiO1xuaW1wb3J0IHsgaXNUZXh0QmxvY2ssIGlzU3BhbiB9IGZyb20gXCJAcG9ydGFibGV0ZXh0L3NjaGVtYVwiO1xuaW1wb3J0IHsgZ2V0QmxvY2tLZXlGcm9tU2VsZWN0aW9uUG9pbnQsIGdldFNlbGVjdGlvblN0YXJ0UG9pbnQsIGdldFNlbGVjdGlvbkVuZFBvaW50IGFzIGdldFNlbGVjdGlvbkVuZFBvaW50JDEsIGdldENoaWxkS2V5RnJvbVNlbGVjdGlvblBvaW50LCBnZXRCbG9ja1N0YXJ0UG9pbnQsIGJsb2NrT2Zmc2V0VG9TcGFuU2VsZWN0aW9uUG9pbnQsIHNwYW5TZWxlY3Rpb25Qb2ludFRvQmxvY2tPZmZzZXQsIGlzTGlzdEJsb2NrIH0gZnJvbSBcIi4vdXRpbC5nZXQtdGV4dC1ibG9jay10ZXh0LmpzXCI7XG5jb25zdCBnZXRGb2N1c0lubGluZU9iamVjdCA9IChzbmFwc2hvdCkgPT4ge1xuICBjb25zdCBmb2N1c0NoaWxkID0gZ2V0Rm9jdXNDaGlsZChzbmFwc2hvdCk7XG4gIHJldHVybiBmb2N1c0NoaWxkICYmICFpc1BvcnRhYmxlVGV4dFNwYW4oZm9jdXNDaGlsZC5ub2RlKSA/IHtcbiAgICBub2RlOiBmb2N1c0NoaWxkLm5vZGUsXG4gICAgcGF0aDogZm9jdXNDaGlsZC5wYXRoXG4gIH0gOiB2b2lkIDA7XG59LCBnZXRTZWxlY3RlZEJsb2NrcyA9IChzbmFwc2hvdCkgPT4ge1xuICBpZiAoIXNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3Qgc2VsZWN0ZWRCbG9ja3MgPSBbXSwgc3RhcnRQb2ludCA9IGdldFNlbGVjdGlvblN0YXJ0UG9pbnQoc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24pLCBlbmRQb2ludCA9IGdldFNlbGVjdGlvbkVuZFBvaW50JDEoc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24pLCBzdGFydEtleSA9IGdldEJsb2NrS2V5RnJvbVNlbGVjdGlvblBvaW50KHN0YXJ0UG9pbnQpLCBlbmRLZXkgPSBnZXRCbG9ja0tleUZyb21TZWxlY3Rpb25Qb2ludChlbmRQb2ludCk7XG4gIGlmICghc3RhcnRLZXkgfHwgIWVuZEtleSlcbiAgICByZXR1cm4gc2VsZWN0ZWRCbG9ja3M7XG4gIGNvbnN0IHN0YXJ0QmxvY2tJbmRleCA9IHNuYXBzaG90LmJsb2NrSW5kZXhNYXAuZ2V0KHN0YXJ0S2V5KSwgZW5kQmxvY2tJbmRleCA9IHNuYXBzaG90LmJsb2NrSW5kZXhNYXAuZ2V0KGVuZEtleSk7XG4gIGlmIChzdGFydEJsb2NrSW5kZXggPT09IHZvaWQgMCB8fCBlbmRCbG9ja0luZGV4ID09PSB2b2lkIDApXG4gICAgcmV0dXJuIHNlbGVjdGVkQmxvY2tzO1xuICBjb25zdCBzbGljZWRWYWx1ZSA9IHNuYXBzaG90LmNvbnRleHQudmFsdWUuc2xpY2Uoc3RhcnRCbG9ja0luZGV4LCBlbmRCbG9ja0luZGV4ICsgMSk7XG4gIGZvciAoY29uc3QgYmxvY2sgb2Ygc2xpY2VkVmFsdWUpIHtcbiAgICBpZiAoYmxvY2suX2tleSA9PT0gc3RhcnRLZXkpIHtcbiAgICAgIGlmIChzZWxlY3RlZEJsb2Nrcy5wdXNoKHtcbiAgICAgICAgbm9kZTogYmxvY2ssXG4gICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICB9XVxuICAgICAgfSksIHN0YXJ0S2V5ID09PSBlbmRLZXkpXG4gICAgICAgIGJyZWFrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChibG9jay5fa2V5ID09PSBlbmRLZXkpIHtcbiAgICAgIHNlbGVjdGVkQmxvY2tzLnB1c2goe1xuICAgICAgICBub2RlOiBibG9jayxcbiAgICAgICAgcGF0aDogW3tcbiAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgIH1dXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBzZWxlY3RlZEJsb2Nrcy5sZW5ndGggPiAwICYmIHNlbGVjdGVkQmxvY2tzLnB1c2goe1xuICAgICAgbm9kZTogYmxvY2ssXG4gICAgICBwYXRoOiBbe1xuICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICB9XVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzZWxlY3RlZEJsb2Nrcztcbn0sIGdldFNlbGVjdGlvbkVuZEJsb2NrID0gKHNuYXBzaG90KSA9PiB7XG4gIGNvbnN0IGVuZFBvaW50ID0gZ2V0U2VsZWN0aW9uRW5kUG9pbnQkMShzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbik7XG4gIGlmIChlbmRQb2ludClcbiAgICByZXR1cm4gZ2V0Rm9jdXNCbG9jayh7XG4gICAgICAuLi5zbmFwc2hvdCxcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgICAgYW5jaG9yOiBlbmRQb2ludCxcbiAgICAgICAgICBmb2N1czogZW5kUG9pbnRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xufSwgZ2V0U2VsZWN0aW9uU3RhcnRCbG9jayA9IChzbmFwc2hvdCkgPT4ge1xuICBjb25zdCBzdGFydFBvaW50ID0gZ2V0U2VsZWN0aW9uU3RhcnRQb2ludChzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbik7XG4gIGlmIChzdGFydFBvaW50KVxuICAgIHJldHVybiBnZXRGb2N1c0Jsb2NrKHtcbiAgICAgIC4uLnNuYXBzaG90LFxuICAgICAgY29udGV4dDoge1xuICAgICAgICAuLi5zbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICBzZWxlY3Rpb246IHtcbiAgICAgICAgICBhbmNob3I6IHN0YXJ0UG9pbnQsXG4gICAgICAgICAgZm9jdXM6IHN0YXJ0UG9pbnRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xufSwgZ2V0U2VsZWN0aW9uRW5kUG9pbnQgPSAoc25hcHNob3QpID0+IHtcbiAgaWYgKHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uKVxuICAgIHJldHVybiBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5iYWNrd2FyZCA/IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmFuY2hvciA6IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmZvY3VzO1xufTtcbmZ1bmN0aW9uIGlzUG9pbnRBZnRlclNlbGVjdGlvbihwb2ludCkge1xuICByZXR1cm4gKHNuYXBzaG90KSA9PiB7XG4gICAgaWYgKCFzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbilcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBlbmRQb2ludCA9IGdldFNlbGVjdGlvbkVuZFBvaW50JDEoc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24pLCBlbmRCbG9ja0tleSA9IGdldEJsb2NrS2V5RnJvbVNlbGVjdGlvblBvaW50KGVuZFBvaW50KSwgZW5kQ2hpbGRLZXkgPSBnZXRDaGlsZEtleUZyb21TZWxlY3Rpb25Qb2ludChlbmRQb2ludCksIHBvaW50QmxvY2tLZXkgPSBnZXRCbG9ja0tleUZyb21TZWxlY3Rpb25Qb2ludChwb2ludCksIHBvaW50Q2hpbGRLZXkgPSBnZXRDaGlsZEtleUZyb21TZWxlY3Rpb25Qb2ludChwb2ludCk7XG4gICAgaWYgKCFwb2ludEJsb2NrS2V5IHx8ICFlbmRCbG9ja0tleSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBwb2ludEJsb2NrSW5kZXggPSBzbmFwc2hvdC5ibG9ja0luZGV4TWFwLmdldChwb2ludEJsb2NrS2V5KSwgZW5kQmxvY2tJbmRleCA9IHNuYXBzaG90LmJsb2NrSW5kZXhNYXAuZ2V0KGVuZEJsb2NrS2V5KTtcbiAgICBpZiAocG9pbnRCbG9ja0luZGV4ID09PSB2b2lkIDAgfHwgZW5kQmxvY2tJbmRleCA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuICExO1xuICAgIGlmIChwb2ludEJsb2NrSW5kZXggPiBlbmRCbG9ja0luZGV4KVxuICAgICAgcmV0dXJuICEwO1xuICAgIGlmIChwb2ludEJsb2NrSW5kZXggPCBlbmRCbG9ja0luZGV4KVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IHBvaW50QmxvY2sgPSBzbmFwc2hvdC5jb250ZXh0LnZhbHVlLmF0KHBvaW50QmxvY2tJbmRleCk7XG4gICAgaWYgKCFwb2ludEJsb2NrIHx8ICFpc1RleHRCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBwb2ludEJsb2NrKSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBsZXQgcG9pbnRDaGlsZEluZGV4LCBlbmRDaGlsZEluZGV4LCBjaGlsZEluZGV4ID0gLTE7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBwb2ludEJsb2NrLmNoaWxkcmVuKSB7XG4gICAgICBpZiAoY2hpbGRJbmRleCsrLCBjaGlsZC5fa2V5ID09PSBwb2ludENoaWxkS2V5ICYmIGNoaWxkLl9rZXkgPT09IGVuZENoaWxkS2V5KVxuICAgICAgICByZXR1cm4gcG9pbnQub2Zmc2V0ID4gZW5kUG9pbnQub2Zmc2V0O1xuICAgICAgaWYgKGNoaWxkLl9rZXkgPT09IHBvaW50Q2hpbGRLZXkgJiYgKHBvaW50Q2hpbGRJbmRleCA9IGNoaWxkSW5kZXgpLCBjaGlsZC5fa2V5ID09PSBlbmRDaGlsZEtleSAmJiAoZW5kQ2hpbGRJbmRleCA9IGNoaWxkSW5kZXgpLCBwb2ludENoaWxkSW5kZXggIT09IHZvaWQgMCAmJiBlbmRDaGlsZEluZGV4ICE9PSB2b2lkIDApXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnRDaGlsZEluZGV4ID09PSB2b2lkIDAgfHwgZW5kQ2hpbGRJbmRleCA9PT0gdm9pZCAwID8gITEgOiBwb2ludENoaWxkSW5kZXggPiBlbmRDaGlsZEluZGV4O1xuICB9O1xufVxuZnVuY3Rpb24gaXNQb2ludEJlZm9yZVNlbGVjdGlvbihwb2ludCkge1xuICByZXR1cm4gKHNuYXBzaG90KSA9PiB7XG4gICAgaWYgKCFzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbilcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBzdGFydFBvaW50ID0gZ2V0U2VsZWN0aW9uU3RhcnRQb2ludChzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbiksIHN0YXJ0QmxvY2tLZXkgPSBnZXRCbG9ja0tleUZyb21TZWxlY3Rpb25Qb2ludChzdGFydFBvaW50KSwgc3RhcnRDaGlsZEtleSA9IGdldENoaWxkS2V5RnJvbVNlbGVjdGlvblBvaW50KHN0YXJ0UG9pbnQpLCBwb2ludEJsb2NrS2V5ID0gZ2V0QmxvY2tLZXlGcm9tU2VsZWN0aW9uUG9pbnQocG9pbnQpLCBwb2ludENoaWxkS2V5ID0gZ2V0Q2hpbGRLZXlGcm9tU2VsZWN0aW9uUG9pbnQocG9pbnQpO1xuICAgIGlmICghcG9pbnRCbG9ja0tleSB8fCAhc3RhcnRCbG9ja0tleSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBzdGFydEJsb2NrSW5kZXggPSBzbmFwc2hvdC5ibG9ja0luZGV4TWFwLmdldChzdGFydEJsb2NrS2V5KSwgcG9pbnRCbG9ja0luZGV4ID0gc25hcHNob3QuYmxvY2tJbmRleE1hcC5nZXQocG9pbnRCbG9ja0tleSk7XG4gICAgaWYgKHN0YXJ0QmxvY2tJbmRleCA9PT0gdm9pZCAwIHx8IHBvaW50QmxvY2tJbmRleCA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuICExO1xuICAgIGlmIChwb2ludEJsb2NrSW5kZXggPCBzdGFydEJsb2NrSW5kZXgpXG4gICAgICByZXR1cm4gITA7XG4gICAgaWYgKHBvaW50QmxvY2tJbmRleCA+IHN0YXJ0QmxvY2tJbmRleClcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBwb2ludEJsb2NrID0gc25hcHNob3QuY29udGV4dC52YWx1ZS5hdChwb2ludEJsb2NrSW5kZXgpO1xuICAgIGlmICghcG9pbnRCbG9jayB8fCAhaXNUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgcG9pbnRCbG9jaykpXG4gICAgICByZXR1cm4gITE7XG4gICAgbGV0IHBvaW50Q2hpbGRJbmRleCwgc3RhcnRDaGlsZEluZGV4LCBjaGlsZEluZGV4ID0gLTE7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBwb2ludEJsb2NrLmNoaWxkcmVuKSB7XG4gICAgICBpZiAoY2hpbGRJbmRleCsrLCBjaGlsZC5fa2V5ID09PSBwb2ludENoaWxkS2V5ICYmIGNoaWxkLl9rZXkgPT09IHN0YXJ0Q2hpbGRLZXkpXG4gICAgICAgIHJldHVybiBwb2ludC5vZmZzZXQgPCBzdGFydFBvaW50Lm9mZnNldDtcbiAgICAgIGlmIChjaGlsZC5fa2V5ID09PSBwb2ludENoaWxkS2V5ICYmIChwb2ludENoaWxkSW5kZXggPSBjaGlsZEluZGV4KSwgY2hpbGQuX2tleSA9PT0gc3RhcnRDaGlsZEtleSAmJiAoc3RhcnRDaGlsZEluZGV4ID0gY2hpbGRJbmRleCksIHBvaW50Q2hpbGRJbmRleCAhPT0gdm9pZCAwICYmIHN0YXJ0Q2hpbGRJbmRleCAhPT0gdm9pZCAwKVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50Q2hpbGRJbmRleCA9PT0gdm9pZCAwIHx8IHN0YXJ0Q2hpbGRJbmRleCA9PT0gdm9pZCAwID8gITEgOiBwb2ludENoaWxkSW5kZXggPCBzdGFydENoaWxkSW5kZXg7XG4gIH07XG59XG5mdW5jdGlvbiBpc092ZXJsYXBwaW5nU2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICByZXR1cm4gKHNuYXBzaG90KSA9PiB7XG4gICAgaWYgKCFzZWxlY3Rpb24gfHwgIXNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IHNlbGVjdGlvblN0YXJ0UG9pbnQgPSBnZXRTZWxlY3Rpb25TdGFydFBvaW50JDEoe1xuICAgICAgY29udGV4dDoge1xuICAgICAgICAuLi5zbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH1cbiAgICB9KSwgc2VsZWN0aW9uRW5kUG9pbnQgPSBnZXRTZWxlY3Rpb25FbmRQb2ludCh7XG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfVxuICAgIH0pLCBvcmlnaW5hbFNlbGVjdGlvblN0YXJ0UG9pbnQgPSBnZXRTZWxlY3Rpb25TdGFydFBvaW50JDEoc25hcHNob3QpLCBvcmlnaW5hbFNlbGVjdGlvbkVuZFBvaW50ID0gZ2V0U2VsZWN0aW9uRW5kUG9pbnQoc25hcHNob3QpO1xuICAgIGlmICghc2VsZWN0aW9uU3RhcnRQb2ludCB8fCAhc2VsZWN0aW9uRW5kUG9pbnQgfHwgIW9yaWdpbmFsU2VsZWN0aW9uU3RhcnRQb2ludCB8fCAhb3JpZ2luYWxTZWxlY3Rpb25FbmRQb2ludClcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBzdGFydFBvaW50RXF1YWxUb09yaWdpbmFsU3RhcnRQb2ludCA9IGlzRXF1YWxTZWxlY3Rpb25Qb2ludHMoc2VsZWN0aW9uU3RhcnRQb2ludCwgb3JpZ2luYWxTZWxlY3Rpb25TdGFydFBvaW50KSwgZW5kUG9pbnRFcXVhbFRvT3JpZ2luYWxFbmRQb2ludCA9IGlzRXF1YWxTZWxlY3Rpb25Qb2ludHMoc2VsZWN0aW9uRW5kUG9pbnQsIG9yaWdpbmFsU2VsZWN0aW9uRW5kUG9pbnQpO1xuICAgIGlmIChzdGFydFBvaW50RXF1YWxUb09yaWdpbmFsU3RhcnRQb2ludCAmJiBlbmRQb2ludEVxdWFsVG9PcmlnaW5hbEVuZFBvaW50KVxuICAgICAgcmV0dXJuICEwO1xuICAgIGNvbnN0IHN0YXJ0UG9pbnRCZWZvcmVTZWxlY3Rpb24gPSBpc1BvaW50QmVmb3JlU2VsZWN0aW9uKHNlbGVjdGlvblN0YXJ0UG9pbnQpKHNuYXBzaG90KSwgc3RhcnRQb2ludEFmdGVyU2VsZWN0aW9uID0gaXNQb2ludEFmdGVyU2VsZWN0aW9uKHNlbGVjdGlvblN0YXJ0UG9pbnQpKHNuYXBzaG90KSwgZW5kUG9pbnRCZWZvcmVTZWxlY3Rpb24gPSBpc1BvaW50QmVmb3JlU2VsZWN0aW9uKHNlbGVjdGlvbkVuZFBvaW50KShzbmFwc2hvdCksIGVuZFBvaW50QWZ0ZXJTZWxlY3Rpb24gPSBpc1BvaW50QWZ0ZXJTZWxlY3Rpb24oc2VsZWN0aW9uRW5kUG9pbnQpKHNuYXBzaG90KSwgb3JpZ2luYWxTdGFydFBvaW50QmVmb3JlU3RhcnRQb2ludCA9IGlzUG9pbnRCZWZvcmVTZWxlY3Rpb24ob3JpZ2luYWxTZWxlY3Rpb25TdGFydFBvaW50KSh7XG4gICAgICAuLi5zbmFwc2hvdCxcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgICAgYW5jaG9yOiBzZWxlY3Rpb25TdGFydFBvaW50LFxuICAgICAgICAgIGZvY3VzOiBzZWxlY3Rpb25TdGFydFBvaW50XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSwgb3JpZ2luYWxTdGFydFBvaW50QWZ0ZXJTdGFydFBvaW50ID0gaXNQb2ludEFmdGVyU2VsZWN0aW9uKG9yaWdpbmFsU2VsZWN0aW9uU3RhcnRQb2ludCkoe1xuICAgICAgLi4uc25hcHNob3QsXG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICAgIGFuY2hvcjogc2VsZWN0aW9uU3RhcnRQb2ludCxcbiAgICAgICAgICBmb2N1czogc2VsZWN0aW9uU3RhcnRQb2ludFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksIG9yaWdpbmFsRW5kUG9pbnRCZWZvcmVFbmRQb2ludCA9IGlzUG9pbnRCZWZvcmVTZWxlY3Rpb24ob3JpZ2luYWxTZWxlY3Rpb25FbmRQb2ludCkoe1xuICAgICAgLi4uc25hcHNob3QsXG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICAgIGFuY2hvcjogc2VsZWN0aW9uRW5kUG9pbnQsXG4gICAgICAgICAgZm9jdXM6IHNlbGVjdGlvbkVuZFBvaW50XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSwgb3JpZ2luYWxFbmRQb2ludEFmdGVyRW5kUG9pbnQgPSBpc1BvaW50QWZ0ZXJTZWxlY3Rpb24ob3JpZ2luYWxTZWxlY3Rpb25FbmRQb2ludCkoe1xuICAgICAgLi4uc25hcHNob3QsXG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICAgIGFuY2hvcjogc2VsZWN0aW9uRW5kUG9pbnQsXG4gICAgICAgICAgZm9jdXM6IHNlbGVjdGlvbkVuZFBvaW50XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSwgc3RhcnRQb2ludEVxdWFsVG9PcmlnaW5hbEVuZFBvaW50ID0gaXNFcXVhbFNlbGVjdGlvblBvaW50cyhzZWxlY3Rpb25TdGFydFBvaW50LCBvcmlnaW5hbFNlbGVjdGlvbkVuZFBvaW50KSwgZW5kUG9pbnRFcXVhbFRvT3JpZ2luYWxTdGFydFBvaW50ID0gaXNFcXVhbFNlbGVjdGlvblBvaW50cyhzZWxlY3Rpb25FbmRQb2ludCwgb3JpZ2luYWxTZWxlY3Rpb25TdGFydFBvaW50KTtcbiAgICByZXR1cm4gIWVuZFBvaW50RXF1YWxUb09yaWdpbmFsU3RhcnRQb2ludCAmJiAhc3RhcnRQb2ludEVxdWFsVG9PcmlnaW5hbEVuZFBvaW50ICYmICFvcmlnaW5hbFN0YXJ0UG9pbnRCZWZvcmVTdGFydFBvaW50ICYmICFvcmlnaW5hbFN0YXJ0UG9pbnRBZnRlclN0YXJ0UG9pbnQgJiYgIW9yaWdpbmFsRW5kUG9pbnRCZWZvcmVFbmRQb2ludCAmJiAhb3JpZ2luYWxFbmRQb2ludEFmdGVyRW5kUG9pbnQgfHwgZW5kUG9pbnRCZWZvcmVTZWxlY3Rpb24gJiYgIWVuZFBvaW50RXF1YWxUb09yaWdpbmFsU3RhcnRQb2ludCB8fCBzdGFydFBvaW50QWZ0ZXJTZWxlY3Rpb24gJiYgIXN0YXJ0UG9pbnRFcXVhbFRvT3JpZ2luYWxFbmRQb2ludCA/ICExIDogIW9yaWdpbmFsU3RhcnRQb2ludEJlZm9yZVN0YXJ0UG9pbnQgJiYgb3JpZ2luYWxTdGFydFBvaW50QWZ0ZXJTdGFydFBvaW50ICYmICFvcmlnaW5hbEVuZFBvaW50QmVmb3JlRW5kUG9pbnQgJiYgb3JpZ2luYWxFbmRQb2ludEFmdGVyRW5kUG9pbnQgPyAhZW5kUG9pbnRFcXVhbFRvT3JpZ2luYWxTdGFydFBvaW50IDogb3JpZ2luYWxTdGFydFBvaW50QmVmb3JlU3RhcnRQb2ludCAmJiAhb3JpZ2luYWxTdGFydFBvaW50QWZ0ZXJTdGFydFBvaW50ICYmIG9yaWdpbmFsRW5kUG9pbnRCZWZvcmVFbmRQb2ludCAmJiAhb3JpZ2luYWxFbmRQb2ludEFmdGVyRW5kUG9pbnQgPyAhc3RhcnRQb2ludEVxdWFsVG9PcmlnaW5hbEVuZFBvaW50IDogIXN0YXJ0UG9pbnRBZnRlclNlbGVjdGlvbiB8fCAhc3RhcnRQb2ludEJlZm9yZVNlbGVjdGlvbiB8fCAhZW5kUG9pbnRBZnRlclNlbGVjdGlvbiB8fCAhZW5kUG9pbnRCZWZvcmVTZWxlY3Rpb247XG4gIH07XG59XG5jb25zdCBpc1NlbGVjdGluZ0VudGlyZUJsb2NrcyA9IChzbmFwc2hvdCkgPT4ge1xuICBpZiAoIXNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uKVxuICAgIHJldHVybiAhMTtcbiAgY29uc3Qgc3RhcnRQb2ludCA9IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmJhY2t3YXJkID8gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uZm9jdXMgOiBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5hbmNob3IsIGVuZFBvaW50ID0gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uYmFja3dhcmQgPyBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5hbmNob3IgOiBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5mb2N1cywgc3RhcnRCbG9jayA9IGdldFNlbGVjdGlvblN0YXJ0QmxvY2soc25hcHNob3QpLCBlbmRCbG9jayA9IGdldFNlbGVjdGlvbkVuZEJsb2NrKHNuYXBzaG90KTtcbiAgaWYgKCFzdGFydEJsb2NrIHx8ICFlbmRCbG9jaylcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IHN0YXJ0QmxvY2tTdGFydFBvaW50ID0gZ2V0QmxvY2tTdGFydFBvaW50KHtcbiAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgIGJsb2NrOiBzdGFydEJsb2NrXG4gIH0pLCBlbmRCbG9ja0VuZFBvaW50ID0gZ2V0QmxvY2tFbmRQb2ludCh7XG4gICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICBibG9jazogZW5kQmxvY2tcbiAgfSk7XG4gIHJldHVybiBpc0VxdWFsU2VsZWN0aW9uUG9pbnRzKHN0YXJ0QmxvY2tTdGFydFBvaW50LCBzdGFydFBvaW50KSAmJiBpc0VxdWFsU2VsZWN0aW9uUG9pbnRzKGVuZEJsb2NrRW5kUG9pbnQsIGVuZFBvaW50KTtcbn07XG5mdW5jdGlvbiBpc0Jsb2NrUGF0aChwYXRoKSB7XG4gIGNvbnN0IGZpcnN0U2VnbWVudCA9IHBhdGguYXQoMCk7XG4gIHJldHVybiBwYXRoLmxlbmd0aCA9PT0gMSAmJiBmaXJzdFNlZ21lbnQgIT09IHZvaWQgMCAmJiBpc1JlY29yZChmaXJzdFNlZ21lbnQpICYmIFwiX2tleVwiIGluIGZpcnN0U2VnbWVudCAmJiB0eXBlb2YgZmlyc3RTZWdtZW50Ll9rZXkgPT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGlzUmVjb3JkKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGlzU2VsZWN0aW9uRXhwYW5kZWQoc2VsZWN0aW9uKSB7XG4gIHJldHVybiBzZWxlY3Rpb24gPyAhaXNTZWxlY3Rpb25Db2xsYXBzZWQoc2VsZWN0aW9uKSA6ICExO1xufVxuY29uc3QgZ2V0TmV4dFNwYW4gPSAoc25hcHNob3QpID0+IHtcbiAgY29uc3Qgc2VsZWN0aW9uRW5kQmxvY2sgPSBnZXRTZWxlY3Rpb25FbmRCbG9jayhzbmFwc2hvdCksIHNlbGVjdGlvbkVuZFBvaW50ID0gZ2V0U2VsZWN0aW9uRW5kUG9pbnQoc25hcHNob3QpO1xuICBpZiAoIXNlbGVjdGlvbkVuZEJsb2NrIHx8ICFzZWxlY3Rpb25FbmRQb2ludCB8fCAhaXNUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgc2VsZWN0aW9uRW5kQmxvY2subm9kZSkpXG4gICAgcmV0dXJuO1xuICBjb25zdCBzZWxlY3Rpb25FbmRQb2ludENoaWxkS2V5ID0gZ2V0Q2hpbGRLZXlGcm9tU2VsZWN0aW9uUG9pbnQoc2VsZWN0aW9uRW5kUG9pbnQpO1xuICBsZXQgZW5kUG9pbnRDaGlsZEZvdW5kID0gITEsIG5leHRTcGFuO1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIHNlbGVjdGlvbkVuZEJsb2NrLm5vZGUuY2hpbGRyZW4pIHtcbiAgICBpZiAoY2hpbGQuX2tleSA9PT0gc2VsZWN0aW9uRW5kUG9pbnRDaGlsZEtleSkge1xuICAgICAgZW5kUG9pbnRDaGlsZEZvdW5kID0gITA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGlzU3BhbihzbmFwc2hvdC5jb250ZXh0LCBjaGlsZCkgJiYgZW5kUG9pbnRDaGlsZEZvdW5kKSB7XG4gICAgICBuZXh0U3BhbiA9IHtcbiAgICAgICAgbm9kZTogY2hpbGQsXG4gICAgICAgIHBhdGg6IFsuLi5zZWxlY3Rpb25FbmRCbG9jay5wYXRoLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICAgIH1dXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXh0U3Bhbjtcbn0sIGdldFByZXZpb3VzU3BhbiA9IChzbmFwc2hvdCkgPT4ge1xuICBjb25zdCBzZWxlY3Rpb25TdGFydEJsb2NrID0gZ2V0U2VsZWN0aW9uU3RhcnRCbG9jayhzbmFwc2hvdCksIHNlbGVjdGlvblN0YXJ0UG9pbnQgPSBnZXRTZWxlY3Rpb25TdGFydFBvaW50JDEoc25hcHNob3QpO1xuICBpZiAoIXNlbGVjdGlvblN0YXJ0QmxvY2sgfHwgIXNlbGVjdGlvblN0YXJ0UG9pbnQgfHwgIWlzVGV4dEJsb2NrKHNuYXBzaG90LmNvbnRleHQsIHNlbGVjdGlvblN0YXJ0QmxvY2subm9kZSkpXG4gICAgcmV0dXJuO1xuICBjb25zdCBzZWxlY3Rpb25TdGFydFBvaW50Q2hpbGRLZXkgPSBnZXRDaGlsZEtleUZyb21TZWxlY3Rpb25Qb2ludChzZWxlY3Rpb25TdGFydFBvaW50KTtcbiAgbGV0IHByZXZpb3VzU3BhbjtcbiAgZm9yIChjb25zdCBjaGlsZCBvZiBzZWxlY3Rpb25TdGFydEJsb2NrLm5vZGUuY2hpbGRyZW4pIHtcbiAgICBpZiAoY2hpbGQuX2tleSA9PT0gc2VsZWN0aW9uU3RhcnRQb2ludENoaWxkS2V5KVxuICAgICAgYnJlYWs7XG4gICAgaXNTcGFuKHNuYXBzaG90LmNvbnRleHQsIGNoaWxkKSAmJiAocHJldmlvdXNTcGFuID0ge1xuICAgICAgbm9kZTogY2hpbGQsXG4gICAgICBwYXRoOiBbLi4uc2VsZWN0aW9uU3RhcnRCbG9jay5wYXRoLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgfV1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcHJldmlvdXNTcGFuO1xufSwgZ2V0U2VsZWN0ZWRTcGFucyA9IChzbmFwc2hvdCkgPT4ge1xuICBpZiAoIXNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3Qgc2VsZWN0ZWRTcGFucyA9IFtdLCBzdGFydFBvaW50ID0gZ2V0U2VsZWN0aW9uU3RhcnRQb2ludCQxKHNuYXBzaG90KSwgZW5kUG9pbnQgPSBnZXRTZWxlY3Rpb25FbmRQb2ludChzbmFwc2hvdCk7XG4gIGlmICghc3RhcnRQb2ludCB8fCAhZW5kUG9pbnQpXG4gICAgcmV0dXJuIHNlbGVjdGVkU3BhbnM7XG4gIGNvbnN0IHN0YXJ0QmxvY2tLZXkgPSBnZXRCbG9ja0tleUZyb21TZWxlY3Rpb25Qb2ludChzdGFydFBvaW50KSwgZW5kQmxvY2tLZXkgPSBnZXRCbG9ja0tleUZyb21TZWxlY3Rpb25Qb2ludChlbmRQb2ludCksIHN0YXJ0U3BhbktleSA9IGdldENoaWxkS2V5RnJvbVNlbGVjdGlvblBvaW50KHN0YXJ0UG9pbnQpLCBlbmRTcGFuS2V5ID0gZ2V0Q2hpbGRLZXlGcm9tU2VsZWN0aW9uUG9pbnQoZW5kUG9pbnQpO1xuICBpZiAoIXN0YXJ0QmxvY2tLZXkgfHwgIWVuZEJsb2NrS2V5KVxuICAgIHJldHVybiBzZWxlY3RlZFNwYW5zO1xuICBjb25zdCBzdGFydEJsb2NrSW5kZXggPSBzbmFwc2hvdC5ibG9ja0luZGV4TWFwLmdldChzdGFydEJsb2NrS2V5KSwgZW5kQmxvY2tJbmRleCA9IHNuYXBzaG90LmJsb2NrSW5kZXhNYXAuZ2V0KGVuZEJsb2NrS2V5KTtcbiAgaWYgKHN0YXJ0QmxvY2tJbmRleCA9PT0gdm9pZCAwIHx8IGVuZEJsb2NrSW5kZXggPT09IHZvaWQgMClcbiAgICByZXR1cm4gc2VsZWN0ZWRTcGFucztcbiAgY29uc3Qgc2xpY2VkVmFsdWUgPSBzbmFwc2hvdC5jb250ZXh0LnZhbHVlLnNsaWNlKHN0YXJ0QmxvY2tJbmRleCwgZW5kQmxvY2tJbmRleCArIDEpO1xuICBsZXQgc3RhcnRCbG9ja0ZvdW5kID0gITE7XG4gIGZvciAoY29uc3QgYmxvY2sgb2Ygc2xpY2VkVmFsdWUpXG4gICAgaWYgKGJsb2NrLl9rZXkgPT09IHN0YXJ0QmxvY2tLZXkgJiYgKHN0YXJ0QmxvY2tGb3VuZCA9ICEwKSwgISFpc1RleHRCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBibG9jaykpIHtcbiAgICAgIGlmIChibG9jay5fa2V5ID09PSBzdGFydEJsb2NrS2V5KSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgYmxvY2suY2hpbGRyZW4pXG4gICAgICAgICAgaWYgKGlzU3BhbihzbmFwc2hvdC5jb250ZXh0LCBjaGlsZCkpIHtcbiAgICAgICAgICAgIGlmIChzdGFydFNwYW5LZXkgJiYgY2hpbGQuX2tleSA9PT0gc3RhcnRTcGFuS2V5KSB7XG4gICAgICAgICAgICAgIGlmIChzdGFydFBvaW50Lm9mZnNldCA8IGNoaWxkLnRleHQubGVuZ3RoICYmIHNlbGVjdGVkU3BhbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbm9kZTogY2hpbGQsXG4gICAgICAgICAgICAgICAgcGF0aDogW3tcbiAgICAgICAgICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgICAgICAgIF9rZXk6IGNoaWxkLl9rZXlcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICB9KSwgc3RhcnRTcGFuS2V5ID09PSBlbmRTcGFuS2V5KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmRTcGFuS2V5ICYmIGNoaWxkLl9rZXkgPT09IGVuZFNwYW5LZXkpIHtcbiAgICAgICAgICAgICAgZW5kUG9pbnQub2Zmc2V0ID4gMCAmJiBzZWxlY3RlZFNwYW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICAgICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZWN0ZWRTcGFucy5sZW5ndGggPiAwICYmIHNlbGVjdGVkU3BhbnMucHVzaCh7XG4gICAgICAgICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICAgICAgICBwYXRoOiBbe1xuICAgICAgICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRCbG9ja0tleSA9PT0gZW5kQmxvY2tLZXkpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGJsb2NrLl9rZXkgPT09IGVuZEJsb2NrS2V5KSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgYmxvY2suY2hpbGRyZW4pXG4gICAgICAgICAgaWYgKGlzU3BhbihzbmFwc2hvdC5jb250ZXh0LCBjaGlsZCkpIHtcbiAgICAgICAgICAgIGlmIChlbmRTcGFuS2V5ICYmIGNoaWxkLl9rZXkgPT09IGVuZFNwYW5LZXkpIHtcbiAgICAgICAgICAgICAgZW5kUG9pbnQub2Zmc2V0ID4gMCAmJiBzZWxlY3RlZFNwYW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICAgICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZWN0ZWRTcGFucy5wdXNoKHtcbiAgICAgICAgICAgICAgbm9kZTogY2hpbGQsXG4gICAgICAgICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0QmxvY2tGb3VuZClcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBibG9jay5jaGlsZHJlbilcbiAgICAgICAgICBpc1NwYW4oc25hcHNob3QuY29udGV4dCwgY2hpbGQpICYmIHNlbGVjdGVkU3BhbnMucHVzaCh7XG4gICAgICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICAgICAgICB9XVxuICAgICAgICAgIH0pO1xuICAgIH1cbiAgcmV0dXJuIHNlbGVjdGVkU3BhbnM7XG59LCBnZXRNYXJrU3RhdGUgPSAoc25hcHNob3QpID0+IHtcbiAgaWYgKCFzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbilcbiAgICByZXR1cm47XG4gIGxldCBzZWxlY3Rpb24gPSBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbjtcbiAgaWYgKCFnZXRGb2N1c1RleHRCbG9jayhzbmFwc2hvdCkpXG4gICAgcmV0dXJuO1xuICBpZiAoaXNCbG9ja1BhdGgoc2VsZWN0aW9uLmFuY2hvci5wYXRoKSkge1xuICAgIGNvbnN0IHNwYW5TZWxlY3Rpb25Qb2ludCA9IGJsb2NrT2Zmc2V0VG9TcGFuU2VsZWN0aW9uUG9pbnQoe1xuICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgIGJsb2NrT2Zmc2V0OiB7XG4gICAgICAgIHBhdGg6IHNlbGVjdGlvbi5hbmNob3IucGF0aCxcbiAgICAgICAgb2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldFxuICAgICAgfSxcbiAgICAgIGRpcmVjdGlvbjogc2VsZWN0aW9uLmJhY2t3YXJkID8gXCJiYWNrd2FyZFwiIDogXCJmb3J3YXJkXCJcbiAgICB9KTtcbiAgICBzZWxlY3Rpb24gPSBzcGFuU2VsZWN0aW9uUG9pbnQgPyB7XG4gICAgICAuLi5zZWxlY3Rpb24sXG4gICAgICBhbmNob3I6IHNwYW5TZWxlY3Rpb25Qb2ludFxuICAgIH0gOiBzZWxlY3Rpb247XG4gIH1cbiAgaWYgKGlzQmxvY2tQYXRoKHNlbGVjdGlvbi5mb2N1cy5wYXRoKSkge1xuICAgIGNvbnN0IHNwYW5TZWxlY3Rpb25Qb2ludCA9IGJsb2NrT2Zmc2V0VG9TcGFuU2VsZWN0aW9uUG9pbnQoe1xuICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgIGJsb2NrT2Zmc2V0OiB7XG4gICAgICAgIHBhdGg6IHNlbGVjdGlvbi5mb2N1cy5wYXRoLFxuICAgICAgICBvZmZzZXQ6IHNlbGVjdGlvbi5mb2N1cy5vZmZzZXRcbiAgICAgIH0sXG4gICAgICBkaXJlY3Rpb246IHNlbGVjdGlvbi5iYWNrd2FyZCA/IFwiYmFja3dhcmRcIiA6IFwiZm9yd2FyZFwiXG4gICAgfSk7XG4gICAgc2VsZWN0aW9uID0gc3BhblNlbGVjdGlvblBvaW50ID8ge1xuICAgICAgLi4uc2VsZWN0aW9uLFxuICAgICAgZm9jdXM6IHNwYW5TZWxlY3Rpb25Qb2ludFxuICAgIH0gOiBzZWxlY3Rpb247XG4gIH1cbiAgY29uc3QgZm9jdXNTcGFuID0gZ2V0Rm9jdXNTcGFuKHtcbiAgICAuLi5zbmFwc2hvdCxcbiAgICBjb250ZXh0OiB7XG4gICAgICAuLi5zbmFwc2hvdC5jb250ZXh0LFxuICAgICAgc2VsZWN0aW9uXG4gICAgfVxuICB9KTtcbiAgaWYgKCFmb2N1c1NwYW4pXG4gICAgcmV0dXJuO1xuICBpZiAoaXNTZWxlY3Rpb25FeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRTcGFucyA9IGdldFNlbGVjdGVkU3BhbnMoe1xuICAgICAgLi4uc25hcHNob3QsXG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBpbmRleCA9IDAsIG1hcmtzMiA9IFtdO1xuICAgIGZvciAoY29uc3Qgc3BhbiBvZiBzZWxlY3RlZFNwYW5zKSB7XG4gICAgICBpZiAoaW5kZXggPT09IDApXG4gICAgICAgIG1hcmtzMiA9IHNwYW4ubm9kZS5tYXJrcyA/PyBbXTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoc3Bhbi5ub2RlLm1hcmtzPy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBtYXJrczIgPSBbXTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBtYXJrczIgPSBtYXJrczIuZmlsdGVyKChtYXJrKSA9PiAoc3Bhbi5ub2RlLm1hcmtzID8/IFtdKS5zb21lKChzcGFuTWFyaykgPT4gc3Bhbk1hcmsgPT09IG1hcmspKTtcbiAgICAgIH1cbiAgICAgIGluZGV4Kys7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzdGF0ZTogXCJ1bmNoYW5nZWRcIixcbiAgICAgIG1hcmtzOiBtYXJrczJcbiAgICB9O1xuICB9XG4gIGNvbnN0IGRlY29yYXRvcnMgPSBzbmFwc2hvdC5jb250ZXh0LnNjaGVtYS5kZWNvcmF0b3JzLm1hcCgoZGVjb3JhdG9yKSA9PiBkZWNvcmF0b3IubmFtZSksIG1hcmtzID0gZm9jdXNTcGFuLm5vZGUubWFya3MgPz8gW10sIG1hcmtzV2l0aG91dEFubm90YXRpb25zID0gbWFya3MuZmlsdGVyKChtYXJrKSA9PiBkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspKSwgc3Bhbkhhc0Fubm90YXRpb25zID0gbWFya3MubGVuZ3RoID4gbWFya3NXaXRob3V0QW5ub3RhdGlvbnMubGVuZ3RoLCBzcGFuSXNFbXB0eSA9IGZvY3VzU3Bhbi5ub2RlLnRleHQubGVuZ3RoID09PSAwLCBhdFRoZUJlZ2lubmluZ09mU3BhbiA9IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgPT09IDAsIGF0VGhlRW5kT2ZTcGFuID0gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uYW5jaG9yLm9mZnNldCA9PT0gZm9jdXNTcGFuLm5vZGUudGV4dC5sZW5ndGgsIHByZXZpb3VzU3BhbiA9IGdldFByZXZpb3VzU3Bhbih7XG4gICAgLi4uc25hcHNob3QsXG4gICAgY29udGV4dDoge1xuICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgIHNlbGVjdGlvblxuICAgIH1cbiAgfSksIG5leHRTcGFuID0gZ2V0TmV4dFNwYW4oe1xuICAgIC4uLnNuYXBzaG90LFxuICAgIGNvbnRleHQ6IHtcbiAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICBzZWxlY3Rpb25cbiAgICB9XG4gIH0pLCBuZXh0U3BhbkFubm90YXRpb25zID0gbmV4dFNwYW4/Lm5vZGU/Lm1hcmtzPy5maWx0ZXIoKG1hcmspID0+ICFkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspKSA/PyBbXSwgc3BhbkFubm90YXRpb25zID0gbWFya3MuZmlsdGVyKChtYXJrKSA9PiAhZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSksIHByZXZpb3VzU3Bhbkhhc0Fubm90YXRpb25zID0gcHJldmlvdXNTcGFuID8gcHJldmlvdXNTcGFuLm5vZGUubWFya3M/LnNvbWUoKG1hcmspID0+ICFkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspKSA6ICExLCBwcmV2aW91c1NwYW5IYXNTYW1lQW5ub3RhdGlvbnMgPSBwcmV2aW91c1NwYW4gPyBwcmV2aW91c1NwYW4ubm9kZS5tYXJrcz8uZmlsdGVyKChtYXJrKSA9PiAhZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSkuZXZlcnkoKG1hcmspID0+IG1hcmtzLmluY2x1ZGVzKG1hcmspKSA6ICExLCBwcmV2aW91c1NwYW5IYXNTYW1lQW5ub3RhdGlvbiA9IHByZXZpb3VzU3BhbiA/IHByZXZpb3VzU3Bhbi5ub2RlLm1hcmtzPy5zb21lKChtYXJrKSA9PiAhZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSAmJiBtYXJrcy5pbmNsdWRlcyhtYXJrKSkgOiAhMSwgcHJldmlvdXNTcGFuSGFzU2FtZU1hcmtzID0gcHJldmlvdXNTcGFuID8gcHJldmlvdXNTcGFuLm5vZGUubWFya3M/LmV2ZXJ5KChtYXJrKSA9PiBtYXJrcy5pbmNsdWRlcyhtYXJrKSkgOiAhMSwgbmV4dFNwYW5TaGFyZXNTb21lQW5ub3RhdGlvbnMgPSBzcGFuQW5ub3RhdGlvbnMuc29tZSgobWFyaykgPT4gbmV4dFNwYW5Bbm5vdGF0aW9ucz8uaW5jbHVkZXMobWFyaykpO1xuICBpZiAoc3Bhbkhhc0Fubm90YXRpb25zICYmICFzcGFuSXNFbXB0eSkge1xuICAgIGlmIChhdFRoZUJlZ2lubmluZ09mU3Bhbikge1xuICAgICAgaWYgKHByZXZpb3VzU3Bhbkhhc1NhbWVNYXJrcylcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0ZTogXCJjaGFuZ2VkXCIsXG4gICAgICAgICAgcHJldmlvdXNNYXJrczogbWFya3MsXG4gICAgICAgICAgbWFya3M6IHByZXZpb3VzU3Bhbj8ubm9kZS5tYXJrcyA/PyBbXVxuICAgICAgICB9O1xuICAgICAgaWYgKHByZXZpb3VzU3Bhbkhhc1NhbWVBbm5vdGF0aW9ucylcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0ZTogXCJjaGFuZ2VkXCIsXG4gICAgICAgICAgcHJldmlvdXNNYXJrczogbWFya3MsXG4gICAgICAgICAgbWFya3M6IHByZXZpb3VzU3Bhbj8ubm9kZS5tYXJrcyA/PyBbXVxuICAgICAgICB9O1xuICAgICAgaWYgKHByZXZpb3VzU3Bhbkhhc1NhbWVBbm5vdGF0aW9uKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXRlOiBcInVuY2hhbmdlZFwiLFxuICAgICAgICAgIHByZXZpb3VzTWFya3M6IG1hcmtzLFxuICAgICAgICAgIG1hcmtzOiBmb2N1c1NwYW4ubm9kZS5tYXJrcyA/PyBbXVxuICAgICAgICB9O1xuICAgICAgaWYgKCFwcmV2aW91c1NwYW4pXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdGU6IFwiY2hhbmdlZFwiLFxuICAgICAgICAgIHByZXZpb3VzTWFya3M6IG1hcmtzLFxuICAgICAgICAgIG1hcmtzOiBbXVxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoYXRUaGVFbmRPZlNwYW4pIHtcbiAgICAgIGlmIChuZXh0U3BhbiAmJiBuZXh0U3BhblNoYXJlc1NvbWVBbm5vdGF0aW9ucyAmJiBuZXh0U3BhbkFubm90YXRpb25zLmxlbmd0aCA8IHNwYW5Bbm5vdGF0aW9ucy5sZW5ndGggfHwgIW5leHRTcGFuU2hhcmVzU29tZUFubm90YXRpb25zKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXRlOiBcImNoYW5nZWRcIixcbiAgICAgICAgICBwcmV2aW91c01hcmtzOiBtYXJrcyxcbiAgICAgICAgICBtYXJrczogbmV4dFNwYW4/Lm5vZGUubWFya3MgPz8gW11cbiAgICAgICAgfTtcbiAgICAgIGlmICghbmV4dFNwYW4pXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdGU6IFwiY2hhbmdlZFwiLFxuICAgICAgICAgIHByZXZpb3VzTWFya3M6IG1hcmtzLFxuICAgICAgICAgIG1hcmtzOiBbXVxuICAgICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXRUaGVCZWdpbm5pbmdPZlNwYW4gJiYgIXNwYW5Jc0VtcHR5ICYmIHByZXZpb3VzU3BhbiA/IHByZXZpb3VzU3Bhbkhhc0Fubm90YXRpb25zID8ge1xuICAgIHN0YXRlOiBcImNoYW5nZWRcIixcbiAgICBtYXJrcyxcbiAgICBwcmV2aW91c01hcmtzOiBwcmV2aW91c1NwYW4/Lm5vZGUubWFya3MgPz8gW11cbiAgfSA6IHtcbiAgICBzdGF0ZTogXCJjaGFuZ2VkXCIsXG4gICAgcHJldmlvdXNNYXJrczogbWFya3MsXG4gICAgbWFya3M6IChwcmV2aW91c1NwYW4/Lm5vZGUubWFya3MgPz8gW10pLmZpbHRlcigobWFyaykgPT4gZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSlcbiAgfSA6IHtcbiAgICBzdGF0ZTogXCJ1bmNoYW5nZWRcIixcbiAgICBtYXJrc1xuICB9O1xufTtcbmZ1bmN0aW9uIGdldEFjdGl2ZURlY29yYXRvcnMoc25hcHNob3QpIHtcbiAgY29uc3Qgc2NoZW1hID0gc25hcHNob3QuY29udGV4dC5zY2hlbWEsIGRlY29yYXRvclN0YXRlID0gc25hcHNob3QuZGVjb3JhdG9yU3RhdGUsIG1hcmtTdGF0ZSA9IGdldE1hcmtTdGF0ZShzbmFwc2hvdCksIGRlY29yYXRvcnMgPSBzY2hlbWEuZGVjb3JhdG9ycy5tYXAoKGRlY29yYXRvcikgPT4gZGVjb3JhdG9yLm5hbWUpO1xuICBsZXQgYWN0aXZlRGVjb3JhdG9ycyA9IChtYXJrU3RhdGU/Lm1hcmtzID8/IFtdKS5maWx0ZXIoKG1hcmspID0+IGRlY29yYXRvcnMuaW5jbHVkZXMobWFyaykpO1xuICBmb3IgKGNvbnN0IGRlY29yYXRvciBpbiBkZWNvcmF0b3JTdGF0ZSlcbiAgICBkZWNvcmF0b3JTdGF0ZVtkZWNvcmF0b3JdID09PSAhMSA/IGFjdGl2ZURlY29yYXRvcnMgPSBhY3RpdmVEZWNvcmF0b3JzLmZpbHRlcigoYWN0aXZlRGVjb3JhdG9yKSA9PiBhY3RpdmVEZWNvcmF0b3IgIT09IGRlY29yYXRvcikgOiBkZWNvcmF0b3JTdGF0ZVtkZWNvcmF0b3JdID09PSAhMCAmJiAoYWN0aXZlRGVjb3JhdG9ycy5pbmNsdWRlcyhkZWNvcmF0b3IpIHx8IGFjdGl2ZURlY29yYXRvcnMucHVzaChkZWNvcmF0b3IpKTtcbiAgcmV0dXJuIGFjdGl2ZURlY29yYXRvcnM7XG59XG5jb25zdCBnZXRUcmltbWVkU2VsZWN0aW9uID0gKHNuYXBzaG90KSA9PiB7XG4gIGlmICghc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24pXG4gICAgcmV0dXJuIHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uO1xuICBjb25zdCBzdGFydFBvaW50ID0gZ2V0U2VsZWN0aW9uU3RhcnRQb2ludChzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbiksIGVuZFBvaW50ID0gZ2V0U2VsZWN0aW9uRW5kUG9pbnQkMShzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbiksIHN0YXJ0QmxvY2tLZXkgPSBnZXRCbG9ja0tleUZyb21TZWxlY3Rpb25Qb2ludChzdGFydFBvaW50KSwgc3RhcnRDaGlsZEtleSA9IGdldENoaWxkS2V5RnJvbVNlbGVjdGlvblBvaW50KHN0YXJ0UG9pbnQpLCBlbmRCbG9ja0tleSA9IGdldEJsb2NrS2V5RnJvbVNlbGVjdGlvblBvaW50KGVuZFBvaW50KSwgZW5kQ2hpbGRLZXkgPSBnZXRDaGlsZEtleUZyb21TZWxlY3Rpb25Qb2ludChlbmRQb2ludCk7XG4gIGlmICghc3RhcnRCbG9ja0tleSB8fCAhZW5kQmxvY2tLZXkpXG4gICAgcmV0dXJuIHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uO1xuICBjb25zdCBzdGFydEJsb2NrSW5kZXggPSBzbmFwc2hvdC5ibG9ja0luZGV4TWFwLmdldChzdGFydEJsb2NrS2V5KSwgZW5kQmxvY2tJbmRleCA9IHNuYXBzaG90LmJsb2NrSW5kZXhNYXAuZ2V0KGVuZEJsb2NrS2V5KTtcbiAgaWYgKHN0YXJ0QmxvY2tJbmRleCA9PT0gdm9pZCAwIHx8IGVuZEJsb2NrSW5kZXggPT09IHZvaWQgMClcbiAgICByZXR1cm4gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb247XG4gIGNvbnN0IHNsaWNlZFZhbHVlID0gc25hcHNob3QuY29udGV4dC52YWx1ZS5zbGljZShzdGFydEJsb2NrSW5kZXgsIGVuZEJsb2NrSW5kZXggKyAxKTtcbiAgbGV0IHN0YXJ0QmxvY2tGb3VuZCA9ICExLCBhZGp1c3RlZFN0YXJ0UG9pbnQsIHRyaW1TdGFydFBvaW50ID0gITEsIGFkanVzdGVkRW5kUG9pbnQsIHRyaW1FbmRQb2ludCA9ICExLCBwcmV2aW91c1BvdGVudGlhbEVuZHBvaW50O1xuICBmb3IgKGNvbnN0IGJsb2NrIG9mIHNsaWNlZFZhbHVlKVxuICAgIGlmICghKGJsb2NrLl9rZXkgPT09IHN0YXJ0QmxvY2tLZXkgJiYgKHN0YXJ0QmxvY2tGb3VuZCA9ICEwLCBpc1RleHRCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBibG9jaykgJiYgaXNFbXB0eVRleHRCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBibG9jaykpKSAmJiBzdGFydEJsb2NrRm91bmQgJiYgaXNUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgYmxvY2spKSB7XG4gICAgICBpZiAoYmxvY2suX2tleSA9PT0gZW5kQmxvY2tLZXkgJiYgaXNFbXB0eVRleHRCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBibG9jaykpXG4gICAgICAgIGJyZWFrO1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBibG9jay5jaGlsZHJlbikge1xuICAgICAgICBpZiAoY2hpbGQuX2tleSA9PT0gZW5kQ2hpbGRLZXkgJiYgKCFpc1NwYW4oc25hcHNob3QuY29udGV4dCwgY2hpbGQpIHx8IGVuZFBvaW50Lm9mZnNldCA9PT0gMCkpIHtcbiAgICAgICAgICBhZGp1c3RlZEVuZFBvaW50ID0gcHJldmlvdXNQb3RlbnRpYWxFbmRwb2ludCA/IHtcbiAgICAgICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgICAgIF9rZXk6IHByZXZpb3VzUG90ZW50aWFsRW5kcG9pbnQuYmxvY2tLZXlcbiAgICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgICBfa2V5OiBwcmV2aW91c1BvdGVudGlhbEVuZHBvaW50LnNwYW4uX2tleVxuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBvZmZzZXQ6IHByZXZpb3VzUG90ZW50aWFsRW5kcG9pbnQuc3Bhbi50ZXh0Lmxlbmd0aFxuICAgICAgICAgIH0gOiB2b2lkIDAsIHRyaW1FbmRQb2ludCA9ICEwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmltU3RhcnRQb2ludCkge1xuICAgICAgICAgIGNvbnN0IGxvbmVseVNwYW4gPSBpc1NwYW4oc25hcHNob3QuY29udGV4dCwgY2hpbGQpICYmIGJsb2NrLmNoaWxkcmVuLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAoaXNTcGFuKHNuYXBzaG90LmNvbnRleHQsIGNoaWxkKSAmJiBjaGlsZC50ZXh0Lmxlbmd0aCA+IDAgfHwgbG9uZWx5U3BhbikgJiYgKGFkanVzdGVkU3RhcnRQb2ludCA9IHtcbiAgICAgICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICAgIH0sIHByZXZpb3VzUG90ZW50aWFsRW5kcG9pbnQgPSB7XG4gICAgICAgICAgICBibG9ja0tleTogYmxvY2suX2tleSxcbiAgICAgICAgICAgIHNwYW46IGNoaWxkXG4gICAgICAgICAgfSwgdHJpbVN0YXJ0UG9pbnQgPSAhMSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkLl9rZXkgPT09IHN0YXJ0Q2hpbGRLZXkpIHtcbiAgICAgICAgICBpZiAoIWlzU3BhbihzbmFwc2hvdC5jb250ZXh0LCBjaGlsZCkpIHtcbiAgICAgICAgICAgIHRyaW1TdGFydFBvaW50ID0gITA7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXJ0UG9pbnQub2Zmc2V0ID09PSBjaGlsZC50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdHJpbVN0YXJ0UG9pbnQgPSAhMCwgcHJldmlvdXNQb3RlbnRpYWxFbmRwb2ludCA9IGNoaWxkLnRleHQubGVuZ3RoID4gMCA/IHtcbiAgICAgICAgICAgICAgYmxvY2tLZXk6IGJsb2NrLl9rZXksXG4gICAgICAgICAgICAgIHNwYW46IGNoaWxkXG4gICAgICAgICAgICB9IDogcHJldmlvdXNQb3RlbnRpYWxFbmRwb2ludDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c1BvdGVudGlhbEVuZHBvaW50ID0gaXNTcGFuKHNuYXBzaG90LmNvbnRleHQsIGNoaWxkKSAmJiBjaGlsZC50ZXh0Lmxlbmd0aCA+IDAgPyB7XG4gICAgICAgICAgYmxvY2tLZXk6IGJsb2NrLl9rZXksXG4gICAgICAgICAgc3BhbjogY2hpbGRcbiAgICAgICAgfSA6IHByZXZpb3VzUG90ZW50aWFsRW5kcG9pbnQ7XG4gICAgICB9XG4gICAgICBpZiAoYmxvY2suX2tleSA9PT0gZW5kQmxvY2tLZXkpXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgY29uc3QgdHJpbW1lZFNlbGVjdGlvbiA9IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmJhY2t3YXJkID8ge1xuICAgIGFuY2hvcjogdHJpbUVuZFBvaW50ICYmIGFkanVzdGVkRW5kUG9pbnQgPyBhZGp1c3RlZEVuZFBvaW50IDogZW5kUG9pbnQsXG4gICAgZm9jdXM6IGFkanVzdGVkU3RhcnRQb2ludCA/PyBzdGFydFBvaW50LFxuICAgIGJhY2t3YXJkOiAhMFxuICB9IDoge1xuICAgIGFuY2hvcjogYWRqdXN0ZWRTdGFydFBvaW50ID8/IHN0YXJ0UG9pbnQsXG4gICAgZm9jdXM6IHRyaW1FbmRQb2ludCAmJiBhZGp1c3RlZEVuZFBvaW50ID8gYWRqdXN0ZWRFbmRQb2ludCA6IGVuZFBvaW50XG4gIH07XG4gIGlmIChpc1NlbGVjdGlvbkNvbGxhcHNlZCQxKHtcbiAgICBjb250ZXh0OiB7XG4gICAgICAuLi5zbmFwc2hvdC5jb250ZXh0LFxuICAgICAgc2VsZWN0aW9uOiB0cmltbWVkU2VsZWN0aW9uXG4gICAgfVxuICB9KSkge1xuICAgIGNvbnN0IGZvY3VzVGV4dEJsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soe1xuICAgICAgLi4uc25hcHNob3QsXG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgIHNlbGVjdGlvbjogdHJpbW1lZFNlbGVjdGlvblxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChmb2N1c1RleHRCbG9jayAmJiAhaXNFbXB0eVRleHRCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBmb2N1c1RleHRCbG9jay5ub2RlKSlcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB0cmltbWVkU2VsZWN0aW9uO1xufSwgZ2V0TmV4dElubGluZU9iamVjdCA9IChzbmFwc2hvdCkgPT4ge1xuICBjb25zdCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHNuYXBzaG90KSwgc2VsZWN0aW9uRW5kUG9pbnQgPSBnZXRTZWxlY3Rpb25FbmRQb2ludChzbmFwc2hvdCksIHNlbGVjdGlvbkVuZFBvaW50Q2hpbGRLZXkgPSBzZWxlY3Rpb25FbmRQb2ludCAmJiBpc0tleVNlZ21lbnQoc2VsZWN0aW9uRW5kUG9pbnQucGF0aFsyXSkgPyBzZWxlY3Rpb25FbmRQb2ludC5wYXRoWzJdLl9rZXkgOiB2b2lkIDA7XG4gIGlmICghZm9jdXNUZXh0QmxvY2sgfHwgIXNlbGVjdGlvbkVuZFBvaW50Q2hpbGRLZXkpXG4gICAgcmV0dXJuO1xuICBsZXQgZW5kUG9pbnRDaGlsZEZvdW5kID0gITEsIGlubGluZU9iamVjdDtcbiAgZm9yIChjb25zdCBjaGlsZCBvZiBmb2N1c1RleHRCbG9jay5ub2RlLmNoaWxkcmVuKSB7XG4gICAgaWYgKGNoaWxkLl9rZXkgPT09IHNlbGVjdGlvbkVuZFBvaW50Q2hpbGRLZXkpIHtcbiAgICAgIGVuZFBvaW50Q2hpbGRGb3VuZCA9ICEwO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICghaXNTcGFuKHNuYXBzaG90LmNvbnRleHQsIGNoaWxkKSAmJiBlbmRQb2ludENoaWxkRm91bmQpIHtcbiAgICAgIGlubGluZU9iamVjdCA9IHtcbiAgICAgICAgbm9kZTogY2hpbGQsXG4gICAgICAgIHBhdGg6IFsuLi5mb2N1c1RleHRCbG9jay5wYXRoLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICAgIH1dXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmxpbmVPYmplY3Q7XG59LCBnZXRDYXJldFdvcmRTZWxlY3Rpb24gPSAoc25hcHNob3QpID0+IHtcbiAgaWYgKCFzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbiB8fCAhaXNTZWxlY3Rpb25Db2xsYXBzZWQkMShzbmFwc2hvdCkpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGZvY3VzVGV4dEJsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soc25hcHNob3QpLCBzZWxlY3Rpb25TdGFydFBvaW50ID0gZ2V0U2VsZWN0aW9uU3RhcnRQb2ludCQxKHNuYXBzaG90KSwgc2VsZWN0aW9uU3RhcnRPZmZzZXQgPSBzZWxlY3Rpb25TdGFydFBvaW50ID8gc3BhblNlbGVjdGlvblBvaW50VG9CbG9ja09mZnNldCh7XG4gICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICBzZWxlY3Rpb25Qb2ludDogc2VsZWN0aW9uU3RhcnRQb2ludFxuICB9KSA6IHZvaWQgMDtcbiAgaWYgKCFmb2N1c1RleHRCbG9jayB8fCAhc2VsZWN0aW9uU3RhcnRQb2ludCB8fCAhc2VsZWN0aW9uU3RhcnRPZmZzZXQpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IHByZXZpb3VzSW5saW5lT2JqZWN0ID0gZ2V0UHJldmlvdXNJbmxpbmVPYmplY3Qoc25hcHNob3QpLCBibG9ja1N0YXJ0UG9pbnQgPSBnZXRCbG9ja1N0YXJ0UG9pbnQoe1xuICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgYmxvY2s6IGZvY3VzVGV4dEJsb2NrXG4gIH0pLCB0ZXh0RGlyZWN0bHlCZWZvcmUgPSBnZXRTZWxlY3Rpb25UZXh0KHtcbiAgICAuLi5zbmFwc2hvdCxcbiAgICBjb250ZXh0OiB7XG4gICAgICAuLi5zbmFwc2hvdC5jb250ZXh0LFxuICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgIGFuY2hvcjogcHJldmlvdXNJbmxpbmVPYmplY3QgPyB7XG4gICAgICAgICAgcGF0aDogcHJldmlvdXNJbmxpbmVPYmplY3QucGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfSA6IGJsb2NrU3RhcnRQb2ludCxcbiAgICAgICAgZm9jdXM6IHNlbGVjdGlvblN0YXJ0UG9pbnRcbiAgICAgIH1cbiAgICB9XG4gIH0pLnNwbGl0KC9cXHMrLykuYXQoLTEpLCBuZXh0SW5saW5lT2JqZWN0ID0gZ2V0TmV4dElubGluZU9iamVjdChzbmFwc2hvdCksIGJsb2NrRW5kUG9pbnQgPSBnZXRCbG9ja0VuZFBvaW50KHtcbiAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgIGJsb2NrOiBmb2N1c1RleHRCbG9ja1xuICB9KSwgdGV4dERpcmVjdGx5QWZ0ZXIgPSBnZXRTZWxlY3Rpb25UZXh0KHtcbiAgICAuLi5zbmFwc2hvdCxcbiAgICBjb250ZXh0OiB7XG4gICAgICAuLi5zbmFwc2hvdC5jb250ZXh0LFxuICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgIGFuY2hvcjogc2VsZWN0aW9uU3RhcnRQb2ludCxcbiAgICAgICAgZm9jdXM6IG5leHRJbmxpbmVPYmplY3QgPyB7XG4gICAgICAgICAgcGF0aDogbmV4dElubGluZU9iamVjdC5wYXRoLFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9IDogYmxvY2tFbmRQb2ludFxuICAgICAgfVxuICAgIH1cbiAgfSkuc3BsaXQoL1xccysvKS5hdCgwKTtcbiAgaWYgKCh0ZXh0RGlyZWN0bHlCZWZvcmUgPT09IHZvaWQgMCB8fCB0ZXh0RGlyZWN0bHlCZWZvcmUgPT09IFwiXCIpICYmICh0ZXh0RGlyZWN0bHlBZnRlciA9PT0gdm9pZCAwIHx8IHRleHREaXJlY3RseUFmdGVyID09PSBcIlwiKSlcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgY2FyZXRXb3JkU3RhcnRPZmZzZXQgPSB0ZXh0RGlyZWN0bHlCZWZvcmUgPyB7XG4gICAgLi4uc2VsZWN0aW9uU3RhcnRPZmZzZXQsXG4gICAgb2Zmc2V0OiBzZWxlY3Rpb25TdGFydE9mZnNldC5vZmZzZXQgLSB0ZXh0RGlyZWN0bHlCZWZvcmUubGVuZ3RoXG4gIH0gOiBzZWxlY3Rpb25TdGFydE9mZnNldCwgY2FyZXRXb3JkRW5kT2Zmc2V0ID0gdGV4dERpcmVjdGx5QWZ0ZXIgPyB7XG4gICAgLi4uc2VsZWN0aW9uU3RhcnRPZmZzZXQsXG4gICAgb2Zmc2V0OiBzZWxlY3Rpb25TdGFydE9mZnNldC5vZmZzZXQgKyB0ZXh0RGlyZWN0bHlBZnRlci5sZW5ndGhcbiAgfSA6IHNlbGVjdGlvblN0YXJ0T2Zmc2V0LCBjYXJldFdvcmRTdGFydFNlbGVjdGlvblBvaW50ID0gYmxvY2tPZmZzZXRUb1NwYW5TZWxlY3Rpb25Qb2ludCh7XG4gICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICBibG9ja09mZnNldDogY2FyZXRXb3JkU3RhcnRPZmZzZXQsXG4gICAgZGlyZWN0aW9uOiBcImJhY2t3YXJkXCJcbiAgfSksIGNhcmV0V29yZEVuZFNlbGVjdGlvblBvaW50ID0gYmxvY2tPZmZzZXRUb1NwYW5TZWxlY3Rpb25Qb2ludCh7XG4gICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICBibG9ja09mZnNldDogY2FyZXRXb3JkRW5kT2Zmc2V0LFxuICAgIGRpcmVjdGlvbjogXCJmb3J3YXJkXCJcbiAgfSk7XG4gIGlmICghY2FyZXRXb3JkU3RhcnRTZWxlY3Rpb25Qb2ludCB8fCAhY2FyZXRXb3JkRW5kU2VsZWN0aW9uUG9pbnQpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGNhcmV0V29yZFNlbGVjdGlvbiA9IHtcbiAgICBhbmNob3I6IGNhcmV0V29yZFN0YXJ0U2VsZWN0aW9uUG9pbnQsXG4gICAgZm9jdXM6IGNhcmV0V29yZEVuZFNlbGVjdGlvblBvaW50XG4gIH07XG4gIHJldHVybiBpc1NlbGVjdGlvbkV4cGFuZGVkJDEoe1xuICAgIGNvbnRleHQ6IHtcbiAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICBzZWxlY3Rpb246IGNhcmV0V29yZFNlbGVjdGlvblxuICAgIH1cbiAgfSkgPyBjYXJldFdvcmRTZWxlY3Rpb24gOiBudWxsO1xufTtcbmZ1bmN0aW9uIGdldEFjdGl2ZUFubm90YXRpb25zTWFya3Moc25hcHNob3QpIHtcbiAgY29uc3Qgc2NoZW1hID0gc25hcHNob3QuY29udGV4dC5zY2hlbWE7XG4gIHJldHVybiAoZ2V0TWFya1N0YXRlKHNuYXBzaG90KT8ubWFya3MgPz8gW10pLmZpbHRlcigobWFyaykgPT4gIXNjaGVtYS5kZWNvcmF0b3JzLm1hcCgoZGVjb3JhdG9yKSA9PiBkZWNvcmF0b3IubmFtZSkuaW5jbHVkZXMobWFyaykpO1xufVxuZnVuY3Rpb24gaXNBY3RpdmVBbm5vdGF0aW9uKGFubm90YXRpb24sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIChzbmFwc2hvdCkgPT4ge1xuICAgIGlmICgob3B0aW9ucz8ubW9kZSA/PyBcImZ1bGxcIikgPT09IFwicGFydGlhbFwiKVxuICAgICAgcmV0dXJuIGdldFNlbGVjdGVkVmFsdWUoc25hcHNob3QpLmZsYXRNYXAoKGJsb2NrKSA9PiBpc1RleHRCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBibG9jaykgPyBibG9jay5tYXJrRGVmcyA/PyBbXSA6IFtdKS5zb21lKChtYXJrRGVmKSA9PiBtYXJrRGVmLl90eXBlID09PSBhbm5vdGF0aW9uKTtcbiAgICBjb25zdCBzZWxlY3Rpb25NYXJrRGVmcyA9IGdldFNlbGVjdGVkQmxvY2tzKHNuYXBzaG90KS5mbGF0TWFwKChibG9jaykgPT4gaXNUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgYmxvY2subm9kZSkgPyBibG9jay5ub2RlLm1hcmtEZWZzID8/IFtdIDogW10pLCBhY3RpdmVBbm5vdGF0aW9ucyA9IGdldEFjdGl2ZUFubm90YXRpb25zTWFya3Moc25hcHNob3QpO1xuICAgIHJldHVybiBzZWxlY3Rpb25NYXJrRGVmcy5maWx0ZXIoKG1hcmtEZWYpID0+IG1hcmtEZWYuX3R5cGUgPT09IGFubm90YXRpb24gJiYgYWN0aXZlQW5ub3RhdGlvbnMuaW5jbHVkZXMobWFya0RlZi5fa2V5KSkubGVuZ3RoID4gMDtcbiAgfTtcbn1cbmNvbnN0IGdldEZvY3VzQmxvY2tPYmplY3QgPSAoc25hcHNob3QpID0+IHtcbiAgY29uc3QgZm9jdXNCbG9jayA9IGdldEZvY3VzQmxvY2soc25hcHNob3QpO1xuICByZXR1cm4gZm9jdXNCbG9jayAmJiAhaXNUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgZm9jdXNCbG9jay5ub2RlKSA/IHtcbiAgICBub2RlOiBmb2N1c0Jsb2NrLm5vZGUsXG4gICAgcGF0aDogZm9jdXNCbG9jay5wYXRoXG4gIH0gOiB2b2lkIDA7XG59LCBnZXROZXh0QmxvY2sgPSAoc25hcHNob3QpID0+IHtcbiAgY29uc3Qgc2VsZWN0aW9uRW5kQmxvY2sgPSBnZXRTZWxlY3Rpb25FbmRCbG9jayhzbmFwc2hvdCk7XG4gIGlmICghc2VsZWN0aW9uRW5kQmxvY2spXG4gICAgcmV0dXJuO1xuICBjb25zdCBpbmRleCA9IHNuYXBzaG90LmJsb2NrSW5kZXhNYXAuZ2V0KHNlbGVjdGlvbkVuZEJsb2NrLm5vZGUuX2tleSk7XG4gIGlmIChpbmRleCA9PT0gdm9pZCAwIHx8IGluZGV4ID09PSBzbmFwc2hvdC5jb250ZXh0LnZhbHVlLmxlbmd0aCAtIDEpXG4gICAgcmV0dXJuO1xuICBjb25zdCBuZXh0QmxvY2sgPSBzbmFwc2hvdC5jb250ZXh0LnZhbHVlLmF0KGluZGV4ICsgMSk7XG4gIHJldHVybiBuZXh0QmxvY2sgPyB7XG4gICAgbm9kZTogbmV4dEJsb2NrLFxuICAgIHBhdGg6IFt7XG4gICAgICBfa2V5OiBuZXh0QmxvY2suX2tleVxuICAgIH1dXG4gIH0gOiB2b2lkIDA7XG59LCBnZXRQcmV2aW91c0Jsb2NrID0gKHNuYXBzaG90KSA9PiB7XG4gIGNvbnN0IHNlbGVjdGlvblN0YXJ0QmxvY2sgPSBnZXRTZWxlY3Rpb25TdGFydEJsb2NrKHNuYXBzaG90KTtcbiAgaWYgKCFzZWxlY3Rpb25TdGFydEJsb2NrKVxuICAgIHJldHVybjtcbiAgY29uc3QgaW5kZXggPSBzbmFwc2hvdC5ibG9ja0luZGV4TWFwLmdldChzZWxlY3Rpb25TdGFydEJsb2NrLm5vZGUuX2tleSk7XG4gIGlmIChpbmRleCA9PT0gdm9pZCAwIHx8IGluZGV4ID09PSAwKVxuICAgIHJldHVybjtcbiAgY29uc3QgcHJldmlvdXNCbG9jayA9IHNuYXBzaG90LmNvbnRleHQudmFsdWUuYXQoaW5kZXggLSAxKTtcbiAgcmV0dXJuIHByZXZpb3VzQmxvY2sgPyB7XG4gICAgbm9kZTogcHJldmlvdXNCbG9jayxcbiAgICBwYXRoOiBbe1xuICAgICAgX2tleTogcHJldmlvdXNCbG9jay5fa2V5XG4gICAgfV1cbiAgfSA6IHZvaWQgMDtcbn0sIGdldEZpcnN0QmxvY2sgPSAoc25hcHNob3QpID0+IHtcbiAgY29uc3Qgbm9kZSA9IHNuYXBzaG90LmNvbnRleHQudmFsdWVbMF07XG4gIHJldHVybiBub2RlID8ge1xuICAgIG5vZGUsXG4gICAgcGF0aDogW3tcbiAgICAgIF9rZXk6IG5vZGUuX2tleVxuICAgIH1dXG4gIH0gOiB2b2lkIDA7XG59LCBnZXRMYXN0QmxvY2sgPSAoc25hcHNob3QpID0+IHtcbiAgY29uc3Qgbm9kZSA9IHNuYXBzaG90LmNvbnRleHQudmFsdWVbc25hcHNob3QuY29udGV4dC52YWx1ZS5sZW5ndGggLSAxXSA/IHNuYXBzaG90LmNvbnRleHQudmFsdWVbc25hcHNob3QuY29udGV4dC52YWx1ZS5sZW5ndGggLSAxXSA6IHZvaWQgMDtcbiAgcmV0dXJuIG5vZGUgPyB7XG4gICAgbm9kZSxcbiAgICBwYXRoOiBbe1xuICAgICAgX2tleTogbm9kZS5fa2V5XG4gICAgfV1cbiAgfSA6IHZvaWQgMDtcbn07XG5mdW5jdGlvbiBpc0F0VGhlRW5kT2ZCbG9jayhibG9jaykge1xuICByZXR1cm4gKHNuYXBzaG90KSA9PiB7XG4gICAgaWYgKCFzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbiB8fCAhaXNTZWxlY3Rpb25Db2xsYXBzZWQkMShzbmFwc2hvdCkpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgYmxvY2tFbmRQb2ludCA9IGdldEJsb2NrRW5kUG9pbnQoe1xuICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgIGJsb2NrXG4gICAgfSk7XG4gICAgcmV0dXJuIGlzRXF1YWxTZWxlY3Rpb25Qb2ludHMoc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uZm9jdXMsIGJsb2NrRW5kUG9pbnQpO1xuICB9O1xufVxuZnVuY3Rpb24gaXNBdFRoZVN0YXJ0T2ZCbG9jayhibG9jaykge1xuICByZXR1cm4gKHNuYXBzaG90KSA9PiB7XG4gICAgaWYgKCFzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbiB8fCAhaXNTZWxlY3Rpb25Db2xsYXBzZWQkMShzbmFwc2hvdCkpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgYmxvY2tTdGFydFBvaW50ID0gZ2V0QmxvY2tTdGFydFBvaW50KHtcbiAgICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgICBibG9ja1xuICAgIH0pO1xuICAgIHJldHVybiBpc0VxdWFsU2VsZWN0aW9uUG9pbnRzKHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLCBibG9ja1N0YXJ0UG9pbnQpO1xuICB9O1xufVxuY29uc3QgZ2V0Rm9jdXNMaXN0QmxvY2sgPSAoc25hcHNob3QpID0+IHtcbiAgY29uc3QgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayhzbmFwc2hvdCk7XG4gIHJldHVybiBmb2N1c1RleHRCbG9jayAmJiBpc0xpc3RCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBmb2N1c1RleHRCbG9jay5ub2RlKSA/IHtcbiAgICBub2RlOiBmb2N1c1RleHRCbG9jay5ub2RlLFxuICAgIHBhdGg6IGZvY3VzVGV4dEJsb2NrLnBhdGhcbiAgfSA6IHZvaWQgMDtcbn07XG5mdW5jdGlvbiBpc0FjdGl2ZURlY29yYXRvcihkZWNvcmF0b3IpIHtcbiAgcmV0dXJuIChzbmFwc2hvdCkgPT4ge1xuICAgIGlmIChpc1NlbGVjdGlvbkV4cGFuZGVkJDEoc25hcHNob3QpKSB7XG4gICAgICBjb25zdCBzZWxlY3RlZFNwYW5zID0gZ2V0U2VsZWN0ZWRTcGFucyhzbmFwc2hvdCk7XG4gICAgICByZXR1cm4gc2VsZWN0ZWRTcGFucy5sZW5ndGggPiAwICYmIHNlbGVjdGVkU3BhbnMuZXZlcnkoKHNwYW4pID0+IHNwYW4ubm9kZS5tYXJrcz8uaW5jbHVkZXMoZGVjb3JhdG9yKSk7XG4gICAgfVxuICAgIHJldHVybiBnZXRBY3RpdmVEZWNvcmF0b3JzKHNuYXBzaG90KS5pbmNsdWRlcyhkZWNvcmF0b3IpO1xuICB9O1xufVxuY29uc3QgZ2V0QWN0aXZlQW5ub3RhdGlvbnMgPSAoc25hcHNob3QpID0+IHtcbiAgaWYgKCFzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbilcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IHNlbGVjdGVkQmxvY2tzID0gZ2V0U2VsZWN0ZWRCbG9ja3Moc25hcHNob3QpLCBhY3RpdmVBbm5vdGF0aW9ucyA9IChnZXRNYXJrU3RhdGUoc25hcHNob3QpPy5tYXJrcyA/PyBbXSkuZmlsdGVyKChtYXJrKSA9PiAhc25hcHNob3QuY29udGV4dC5zY2hlbWEuZGVjb3JhdG9ycy5tYXAoKGRlY29yYXRvcikgPT4gZGVjb3JhdG9yLm5hbWUpLmluY2x1ZGVzKG1hcmspKTtcbiAgcmV0dXJuIHNlbGVjdGVkQmxvY2tzLmZsYXRNYXAoKGJsb2NrKSA9PiBpc1RleHRCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBibG9jay5ub2RlKSA/IGJsb2NrLm5vZGUubWFya0RlZnMgPz8gW10gOiBbXSkuZmlsdGVyKChtYXJrRGVmKSA9PiBhY3RpdmVBbm5vdGF0aW9ucy5pbmNsdWRlcyhtYXJrRGVmLl9rZXkpKTtcbn0sIGdldFNlbGVjdGVkVGV4dEJsb2NrcyA9IChzbmFwc2hvdCkgPT4ge1xuICBpZiAoIXNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3Qgc2VsZWN0ZWRUZXh0QmxvY2tzID0gW10sIHN0YXJ0UG9pbnQgPSBnZXRTZWxlY3Rpb25TdGFydFBvaW50KHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uKSwgZW5kUG9pbnQgPSBnZXRTZWxlY3Rpb25FbmRQb2ludCQxKHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uKSwgc3RhcnRCbG9ja0tleSA9IGdldEJsb2NrS2V5RnJvbVNlbGVjdGlvblBvaW50KHN0YXJ0UG9pbnQpLCBlbmRCbG9ja0tleSA9IGdldEJsb2NrS2V5RnJvbVNlbGVjdGlvblBvaW50KGVuZFBvaW50KTtcbiAgaWYgKCFzdGFydEJsb2NrS2V5IHx8ICFlbmRCbG9ja0tleSlcbiAgICByZXR1cm4gc2VsZWN0ZWRUZXh0QmxvY2tzO1xuICBjb25zdCBzdGFydEJsb2NrSW5kZXggPSBzbmFwc2hvdC5ibG9ja0luZGV4TWFwLmdldChzdGFydEJsb2NrS2V5KSwgZW5kQmxvY2tJbmRleCA9IHNuYXBzaG90LmJsb2NrSW5kZXhNYXAuZ2V0KGVuZEJsb2NrS2V5KTtcbiAgaWYgKHN0YXJ0QmxvY2tJbmRleCA9PT0gdm9pZCAwIHx8IGVuZEJsb2NrSW5kZXggPT09IHZvaWQgMClcbiAgICByZXR1cm4gc2VsZWN0ZWRUZXh0QmxvY2tzO1xuICBjb25zdCBzbGljZWRWYWx1ZSA9IHNuYXBzaG90LmNvbnRleHQudmFsdWUuc2xpY2Uoc3RhcnRCbG9ja0luZGV4LCBlbmRCbG9ja0luZGV4ICsgMSk7XG4gIGZvciAoY29uc3QgYmxvY2sgb2Ygc2xpY2VkVmFsdWUpIHtcbiAgICBpZiAoYmxvY2suX2tleSA9PT0gc3RhcnRCbG9ja0tleSkge1xuICAgICAgaWYgKGlzVGV4dEJsb2NrKHNuYXBzaG90LmNvbnRleHQsIGJsb2NrKSAmJiBzZWxlY3RlZFRleHRCbG9ja3MucHVzaCh7XG4gICAgICAgIG5vZGU6IGJsb2NrLFxuICAgICAgICBwYXRoOiBbe1xuICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgfV1cbiAgICAgIH0pLCBzdGFydEJsb2NrS2V5ID09PSBlbmRCbG9ja0tleSlcbiAgICAgICAgYnJlYWs7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGJsb2NrLl9rZXkgPT09IGVuZEJsb2NrS2V5KSB7XG4gICAgICBpc1RleHRCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBibG9jaykgJiYgc2VsZWN0ZWRUZXh0QmxvY2tzLnB1c2goe1xuICAgICAgICBub2RlOiBibG9jayxcbiAgICAgICAgcGF0aDogW3tcbiAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgIH1dXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBzZWxlY3RlZFRleHRCbG9ja3MubGVuZ3RoID4gMCAmJiBpc1RleHRCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBibG9jaykgJiYgc2VsZWN0ZWRUZXh0QmxvY2tzLnB1c2goe1xuICAgICAgbm9kZTogYmxvY2ssXG4gICAgICBwYXRoOiBbe1xuICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICB9XVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzZWxlY3RlZFRleHRCbG9ja3M7XG59LCBnZXRBY3RpdmVMaXN0SXRlbSA9IChzbmFwc2hvdCkgPT4ge1xuICBpZiAoIXNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uKVxuICAgIHJldHVybjtcbiAgY29uc3Qgc2VsZWN0ZWRUZXh0QmxvY2tzID0gZ2V0U2VsZWN0ZWRCbG9ja3Moc25hcHNob3QpLm1hcCgoYmxvY2spID0+IGJsb2NrLm5vZGUpLmZpbHRlcigoYmxvY2spID0+IGlzVGV4dEJsb2NrKHNuYXBzaG90LmNvbnRleHQsIGJsb2NrKSksIGZpcnN0VGV4dEJsb2NrID0gc2VsZWN0ZWRUZXh0QmxvY2tzLmF0KDApO1xuICBpZiAoIWZpcnN0VGV4dEJsb2NrKVxuICAgIHJldHVybjtcbiAgY29uc3QgZmlyc3RMaXN0SXRlbSA9IGZpcnN0VGV4dEJsb2NrLmxpc3RJdGVtO1xuICBpZiAoZmlyc3RMaXN0SXRlbSAmJiBzZWxlY3RlZFRleHRCbG9ja3MuZXZlcnkoKGJsb2NrKSA9PiBibG9jay5saXN0SXRlbSA9PT0gZmlyc3RMaXN0SXRlbSkpXG4gICAgcmV0dXJuIGZpcnN0TGlzdEl0ZW07XG59O1xuZnVuY3Rpb24gaXNBY3RpdmVMaXN0SXRlbShsaXN0SXRlbSkge1xuICByZXR1cm4gKHNuYXBzaG90KSA9PiBnZXRBY3RpdmVMaXN0SXRlbShzbmFwc2hvdCkgPT09IGxpc3RJdGVtO1xufVxuY29uc3QgZ2V0QWN0aXZlU3R5bGUgPSAoc25hcHNob3QpID0+IHtcbiAgaWYgKCFzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbilcbiAgICByZXR1cm47XG4gIGNvbnN0IHNlbGVjdGVkVGV4dEJsb2NrcyA9IGdldFNlbGVjdGVkQmxvY2tzKHNuYXBzaG90KS5tYXAoKGJsb2NrKSA9PiBibG9jay5ub2RlKS5maWx0ZXIoKGJsb2NrKSA9PiBpc1RleHRCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBibG9jaykpLCBmaXJzdFRleHRCbG9jayA9IHNlbGVjdGVkVGV4dEJsb2Nrcy5hdCgwKTtcbiAgaWYgKCFmaXJzdFRleHRCbG9jaylcbiAgICByZXR1cm47XG4gIGNvbnN0IGZpcnN0U3R5bGUgPSBmaXJzdFRleHRCbG9jay5zdHlsZTtcbiAgaWYgKGZpcnN0U3R5bGUgJiYgc2VsZWN0ZWRUZXh0QmxvY2tzLmV2ZXJ5KChibG9jaykgPT4gYmxvY2suc3R5bGUgPT09IGZpcnN0U3R5bGUpKVxuICAgIHJldHVybiBmaXJzdFN0eWxlO1xufTtcbmZ1bmN0aW9uIGlzQWN0aXZlU3R5bGUoc3R5bGUpIHtcbiAgcmV0dXJuIChzbmFwc2hvdCkgPT4gZ2V0QWN0aXZlU3R5bGUoc25hcHNob3QpID09PSBzdHlsZTtcbn1cbmV4cG9ydCB7XG4gIGdldEFjdGl2ZUFubm90YXRpb25zLFxuICBnZXRBY3RpdmVBbm5vdGF0aW9uc01hcmtzLFxuICBnZXRBY3RpdmVEZWNvcmF0b3JzLFxuICBnZXRBY3RpdmVMaXN0SXRlbSxcbiAgZ2V0QWN0aXZlU3R5bGUsXG4gIGdldENhcmV0V29yZFNlbGVjdGlvbixcbiAgZ2V0Rmlyc3RCbG9jayxcbiAgZ2V0Rm9jdXNCbG9ja09iamVjdCxcbiAgZ2V0Rm9jdXNJbmxpbmVPYmplY3QsXG4gIGdldEZvY3VzTGlzdEJsb2NrLFxuICBnZXRMYXN0QmxvY2ssXG4gIGdldE1hcmtTdGF0ZSxcbiAgZ2V0TmV4dEJsb2NrLFxuICBnZXROZXh0SW5saW5lT2JqZWN0LFxuICBnZXRQcmV2aW91c0Jsb2NrLFxuICBnZXRTZWxlY3RlZEJsb2NrcyxcbiAgZ2V0U2VsZWN0ZWRTcGFucyxcbiAgZ2V0U2VsZWN0ZWRUZXh0QmxvY2tzLFxuICBnZXRTZWxlY3Rpb25FbmRCbG9jayxcbiAgZ2V0U2VsZWN0aW9uRW5kUG9pbnQsXG4gIGdldFNlbGVjdGlvblN0YXJ0QmxvY2ssXG4gIGdldFRyaW1tZWRTZWxlY3Rpb24sXG4gIGlzQWN0aXZlQW5ub3RhdGlvbixcbiAgaXNBY3RpdmVEZWNvcmF0b3IsXG4gIGlzQWN0aXZlTGlzdEl0ZW0sXG4gIGlzQWN0aXZlU3R5bGUsXG4gIGlzQXRUaGVFbmRPZkJsb2NrLFxuICBpc0F0VGhlU3RhcnRPZkJsb2NrLFxuICBpc092ZXJsYXBwaW5nU2VsZWN0aW9uLFxuICBpc1BvaW50QWZ0ZXJTZWxlY3Rpb24sXG4gIGlzUG9pbnRCZWZvcmVTZWxlY3Rpb24sXG4gIGlzU2VsZWN0aW5nRW50aXJlQmxvY2tzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VsZWN0b3IuaXMtYWN0aXZlLXN0eWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/selector.is-active-style.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/use-editor.js":
/*!*************************************************************************!*\
  !*** ../node_modules/@portabletext/editor/lib/_chunks-es/use-editor.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EditorContext: () => (/* binding */ EditorContext),\n/* harmony export */   useEditor: () => (/* binding */ useEditor)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n\nfunction getGlobalScope() {\n  if (typeof globalThis < \"u\") return globalThis;\n  if (typeof window < \"u\") return window;\n  if (typeof self < \"u\") return self;\n  if (typeof global < \"u\") return global;\n  throw new Error(\"@portabletext/editor: could not locate global scope\");\n}\nconst globalScope = getGlobalScope();\nfunction createGloballyScopedContext(key, defaultValue) {\n  const symbol = Symbol.for(key);\n  return typeof document > \"u\" ? (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(defaultValue) : (globalScope[symbol] = globalScope[symbol] ?? (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(defaultValue), globalScope[symbol]);\n}\nconst EditorContext = createGloballyScopedContext(\"@portabletext/editor/context/editor\", null);\nfunction useEditor() {\n  const editor = react__WEBPACK_IMPORTED_MODULE_0__.useContext(EditorContext);\n  if (!editor)\n    throw new Error(\"No Editor set. Use EditorProvider to set one.\");\n  return editor;\n}\n\n//# sourceMappingURL=use-editor.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9fY2h1bmtzLWVzL3VzZS1lZGl0b3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG9EQUFhLCtEQUErRCxvREFBYTtBQUMxSDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNkNBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL0dhbG9jay9DUy9iZWhvbWUtc2l0ZS9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvdXNlLWVkaXRvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gZ2V0R2xvYmFsU2NvcGUoKSB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA8IFwidVwiKSByZXR1cm4gZ2xvYmFsVGhpcztcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPCBcInVcIikgcmV0dXJuIHdpbmRvdztcbiAgaWYgKHR5cGVvZiBzZWxmIDwgXCJ1XCIpIHJldHVybiBzZWxmO1xuICBpZiAodHlwZW9mIGdsb2JhbCA8IFwidVwiKSByZXR1cm4gZ2xvYmFsO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJAcG9ydGFibGV0ZXh0L2VkaXRvcjogY291bGQgbm90IGxvY2F0ZSBnbG9iYWwgc2NvcGVcIik7XG59XG5jb25zdCBnbG9iYWxTY29wZSA9IGdldEdsb2JhbFNjb3BlKCk7XG5mdW5jdGlvbiBjcmVhdGVHbG9iYWxseVNjb3BlZENvbnRleHQoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgY29uc3Qgc3ltYm9sID0gU3ltYm9sLmZvcihrZXkpO1xuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ID4gXCJ1XCIgPyBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSkgOiAoZ2xvYmFsU2NvcGVbc3ltYm9sXSA9IGdsb2JhbFNjb3BlW3N5bWJvbF0gPz8gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUpLCBnbG9iYWxTY29wZVtzeW1ib2xdKTtcbn1cbmNvbnN0IEVkaXRvckNvbnRleHQgPSBjcmVhdGVHbG9iYWxseVNjb3BlZENvbnRleHQoXCJAcG9ydGFibGV0ZXh0L2VkaXRvci9jb250ZXh0L2VkaXRvclwiLCBudWxsKTtcbmZ1bmN0aW9uIHVzZUVkaXRvcigpIHtcbiAgY29uc3QgZWRpdG9yID0gUmVhY3QudXNlQ29udGV4dChFZGl0b3JDb250ZXh0KTtcbiAgaWYgKCFlZGl0b3IpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gRWRpdG9yIHNldC4gVXNlIEVkaXRvclByb3ZpZGVyIHRvIHNldCBvbmUuXCIpO1xuICByZXR1cm4gZWRpdG9yO1xufVxuZXhwb3J0IHtcbiAgRWRpdG9yQ29udGV4dCxcbiAgdXNlRWRpdG9yXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWVkaXRvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/use-editor.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/util.child-selection-point-to-block-offset.js":
/*!*********************************************************************************************************!*\
  !*** ../node_modules/@portabletext/editor/lib/_chunks-es/util.child-selection-point-to-block-offset.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blockOffsetToBlockSelectionPoint: () => (/* binding */ blockOffsetToBlockSelectionPoint),\n/* harmony export */   blockOffsetToSelectionPoint: () => (/* binding */ blockOffsetToSelectionPoint),\n/* harmony export */   blockOffsetsToSelection: () => (/* binding */ blockOffsetsToSelection),\n/* harmony export */   childSelectionPointToBlockOffset: () => (/* binding */ childSelectionPointToBlockOffset)\n/* harmony export */ });\n/* harmony import */ var _util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.get-text-block-text.js */ \"(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/util.get-text-block-text.js\");\n/* harmony import */ var _portabletext_schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @portabletext/schema */ \"(ssr)/../node_modules/@portabletext/schema/dist/index.js\");\n\n\nfunction blockOffsetToBlockSelectionPoint({\n  context,\n  blockOffset\n}) {\n  let selectionPoint;\n  for (const block of context.value)\n    if (block._key === blockOffset.path[0]._key) {\n      selectionPoint = {\n        path: [{\n          _key: block._key\n        }],\n        offset: blockOffset.offset\n      };\n      break;\n    }\n  return selectionPoint;\n}\nfunction blockOffsetToSelectionPoint({\n  context,\n  blockOffset,\n  direction\n}) {\n  return (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_0__.blockOffsetToSpanSelectionPoint)({\n    context,\n    blockOffset,\n    direction\n  }) || blockOffsetToBlockSelectionPoint({\n    context,\n    blockOffset\n  });\n}\nfunction blockOffsetsToSelection({\n  context,\n  offsets,\n  backward\n}) {\n  const anchor = blockOffsetToSelectionPoint({\n    context,\n    blockOffset: offsets.anchor,\n    direction: backward ? \"backward\" : \"forward\"\n  }), focus = blockOffsetToSelectionPoint({\n    context,\n    blockOffset: offsets.focus,\n    direction: backward ? \"forward\" : \"backward\"\n  });\n  return !anchor || !focus ? null : {\n    anchor,\n    focus,\n    backward\n  };\n}\nfunction childSelectionPointToBlockOffset({\n  context,\n  selectionPoint\n}) {\n  let offset = 0;\n  const blockKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_0__.getBlockKeyFromSelectionPoint)(selectionPoint), childKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_0__.getChildKeyFromSelectionPoint)(selectionPoint);\n  if (!(!blockKey || !childKey)) {\n    for (const block of context.value)\n      if (block._key === blockKey && (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_1__.isTextBlock)(context, block))\n        for (const child of block.children) {\n          if (child._key === childKey)\n            return {\n              path: [{\n                _key: block._key\n              }],\n              offset: offset + selectionPoint.offset\n            };\n          (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_1__.isSpan)(context, child) && (offset += child.text.length);\n        }\n  }\n}\n\n//# sourceMappingURL=util.child-selection-point-to-block-offset.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9fY2h1bmtzLWVzL3V0aWwuY2hpbGQtc2VsZWN0aW9uLXBvaW50LXRvLWJsb2NrLW9mZnNldC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBOEk7QUFDbkY7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxTQUFTLDZGQUErQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxtQkFBbUIsMkZBQTZCLDZCQUE2QiwyRkFBNkI7QUFDMUc7QUFDQTtBQUNBLHFDQUFxQyxpRUFBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxVQUFVLDREQUFNO0FBQ2hCO0FBQ0E7QUFDQTtBQU1FO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9HYWxvY2svQ1MvYmVob21lLXNpdGUvbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9fY2h1bmtzLWVzL3V0aWwuY2hpbGQtc2VsZWN0aW9uLXBvaW50LXRvLWJsb2NrLW9mZnNldC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBibG9ja09mZnNldFRvU3BhblNlbGVjdGlvblBvaW50LCBnZXRCbG9ja0tleUZyb21TZWxlY3Rpb25Qb2ludCwgZ2V0Q2hpbGRLZXlGcm9tU2VsZWN0aW9uUG9pbnQgfSBmcm9tIFwiLi91dGlsLmdldC10ZXh0LWJsb2NrLXRleHQuanNcIjtcbmltcG9ydCB7IGlzVGV4dEJsb2NrLCBpc1NwYW4gfSBmcm9tIFwiQHBvcnRhYmxldGV4dC9zY2hlbWFcIjtcbmZ1bmN0aW9uIGJsb2NrT2Zmc2V0VG9CbG9ja1NlbGVjdGlvblBvaW50KHtcbiAgY29udGV4dCxcbiAgYmxvY2tPZmZzZXRcbn0pIHtcbiAgbGV0IHNlbGVjdGlvblBvaW50O1xuICBmb3IgKGNvbnN0IGJsb2NrIG9mIGNvbnRleHQudmFsdWUpXG4gICAgaWYgKGJsb2NrLl9rZXkgPT09IGJsb2NrT2Zmc2V0LnBhdGhbMF0uX2tleSkge1xuICAgICAgc2VsZWN0aW9uUG9pbnQgPSB7XG4gICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICB9XSxcbiAgICAgICAgb2Zmc2V0OiBibG9ja09mZnNldC5vZmZzZXRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICB9XG4gIHJldHVybiBzZWxlY3Rpb25Qb2ludDtcbn1cbmZ1bmN0aW9uIGJsb2NrT2Zmc2V0VG9TZWxlY3Rpb25Qb2ludCh7XG4gIGNvbnRleHQsXG4gIGJsb2NrT2Zmc2V0LFxuICBkaXJlY3Rpb25cbn0pIHtcbiAgcmV0dXJuIGJsb2NrT2Zmc2V0VG9TcGFuU2VsZWN0aW9uUG9pbnQoe1xuICAgIGNvbnRleHQsXG4gICAgYmxvY2tPZmZzZXQsXG4gICAgZGlyZWN0aW9uXG4gIH0pIHx8IGJsb2NrT2Zmc2V0VG9CbG9ja1NlbGVjdGlvblBvaW50KHtcbiAgICBjb250ZXh0LFxuICAgIGJsb2NrT2Zmc2V0XG4gIH0pO1xufVxuZnVuY3Rpb24gYmxvY2tPZmZzZXRzVG9TZWxlY3Rpb24oe1xuICBjb250ZXh0LFxuICBvZmZzZXRzLFxuICBiYWNrd2FyZFxufSkge1xuICBjb25zdCBhbmNob3IgPSBibG9ja09mZnNldFRvU2VsZWN0aW9uUG9pbnQoe1xuICAgIGNvbnRleHQsXG4gICAgYmxvY2tPZmZzZXQ6IG9mZnNldHMuYW5jaG9yLFxuICAgIGRpcmVjdGlvbjogYmFja3dhcmQgPyBcImJhY2t3YXJkXCIgOiBcImZvcndhcmRcIlxuICB9KSwgZm9jdXMgPSBibG9ja09mZnNldFRvU2VsZWN0aW9uUG9pbnQoe1xuICAgIGNvbnRleHQsXG4gICAgYmxvY2tPZmZzZXQ6IG9mZnNldHMuZm9jdXMsXG4gICAgZGlyZWN0aW9uOiBiYWNrd2FyZCA/IFwiZm9yd2FyZFwiIDogXCJiYWNrd2FyZFwiXG4gIH0pO1xuICByZXR1cm4gIWFuY2hvciB8fCAhZm9jdXMgPyBudWxsIDoge1xuICAgIGFuY2hvcixcbiAgICBmb2N1cyxcbiAgICBiYWNrd2FyZFxuICB9O1xufVxuZnVuY3Rpb24gY2hpbGRTZWxlY3Rpb25Qb2ludFRvQmxvY2tPZmZzZXQoe1xuICBjb250ZXh0LFxuICBzZWxlY3Rpb25Qb2ludFxufSkge1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgY29uc3QgYmxvY2tLZXkgPSBnZXRCbG9ja0tleUZyb21TZWxlY3Rpb25Qb2ludChzZWxlY3Rpb25Qb2ludCksIGNoaWxkS2V5ID0gZ2V0Q2hpbGRLZXlGcm9tU2VsZWN0aW9uUG9pbnQoc2VsZWN0aW9uUG9pbnQpO1xuICBpZiAoISghYmxvY2tLZXkgfHwgIWNoaWxkS2V5KSkge1xuICAgIGZvciAoY29uc3QgYmxvY2sgb2YgY29udGV4dC52YWx1ZSlcbiAgICAgIGlmIChibG9jay5fa2V5ID09PSBibG9ja0tleSAmJiBpc1RleHRCbG9jayhjb250ZXh0LCBibG9jaykpXG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgYmxvY2suY2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoY2hpbGQuX2tleSA9PT0gY2hpbGRLZXkpXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBwYXRoOiBbe1xuICAgICAgICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0ICsgc2VsZWN0aW9uUG9pbnQub2Zmc2V0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGlzU3Bhbihjb250ZXh0LCBjaGlsZCkgJiYgKG9mZnNldCArPSBjaGlsZC50ZXh0Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgfVxufVxuZXhwb3J0IHtcbiAgYmxvY2tPZmZzZXRUb0Jsb2NrU2VsZWN0aW9uUG9pbnQsXG4gIGJsb2NrT2Zmc2V0VG9TZWxlY3Rpb25Qb2ludCxcbiAgYmxvY2tPZmZzZXRzVG9TZWxlY3Rpb24sXG4gIGNoaWxkU2VsZWN0aW9uUG9pbnRUb0Jsb2NrT2Zmc2V0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5jaGlsZC1zZWxlY3Rpb24tcG9pbnQtdG8tYmxvY2stb2Zmc2V0LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/util.child-selection-point-to-block-offset.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/util.get-text-block-text.js":
/*!***************************************************************************************!*\
  !*** ../node_modules/@portabletext/editor/lib/_chunks-es/util.get-text-block-text.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blockOffsetToSpanSelectionPoint: () => (/* binding */ blockOffsetToSpanSelectionPoint),\n/* harmony export */   defaultKeyGenerator: () => (/* binding */ defaultKeyGenerator),\n/* harmony export */   getBlockKeyFromSelectionPoint: () => (/* binding */ getBlockKeyFromSelectionPoint),\n/* harmony export */   getBlockStartPoint: () => (/* binding */ getBlockStartPoint),\n/* harmony export */   getChildKeyFromSelectionPoint: () => (/* binding */ getChildKeyFromSelectionPoint),\n/* harmony export */   getSelectionEndPoint: () => (/* binding */ getSelectionEndPoint),\n/* harmony export */   getSelectionStartPoint: () => (/* binding */ getSelectionStartPoint),\n/* harmony export */   getTextBlockText: () => (/* binding */ getTextBlockText),\n/* harmony export */   isKeyedSegment: () => (/* binding */ isKeyedSegment),\n/* harmony export */   isListBlock: () => (/* binding */ isListBlock),\n/* harmony export */   isTypedObject: () => (/* binding */ isTypedObject),\n/* harmony export */   parseAnnotation: () => (/* binding */ parseAnnotation),\n/* harmony export */   parseBlock: () => (/* binding */ parseBlock),\n/* harmony export */   parseBlocks: () => (/* binding */ parseBlocks),\n/* harmony export */   parseInlineObject: () => (/* binding */ parseInlineObject),\n/* harmony export */   parseSpan: () => (/* binding */ parseSpan),\n/* harmony export */   sliceBlocks: () => (/* binding */ sliceBlocks),\n/* harmony export */   spanSelectionPointToBlockOffset: () => (/* binding */ spanSelectionPointToBlockOffset)\n/* harmony export */ });\n/* harmony import */ var _portabletext_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @portabletext/schema */ \"(ssr)/../node_modules/@portabletext/schema/dist/index.js\");\n/* harmony import */ var get_random_values_esm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! get-random-values-esm */ \"(ssr)/../node_modules/get-random-values-esm/index.mjs\");\n\n\nfunction getBlockStartPoint({\n  context,\n  block\n}) {\n  return (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_0__.isTextBlock)(context, block.node) ? {\n    path: [...block.path, \"children\", {\n      _key: block.node.children[0]._key\n    }],\n    offset: 0\n  } : {\n    path: block.path,\n    offset: 0\n  };\n}\nfunction isKeyedSegment(segment) {\n  return typeof segment == \"object\" && segment !== null && \"_key\" in segment;\n}\nfunction getBlockKeyFromSelectionPoint(point) {\n  const blockPathSegment = point.path.at(0);\n  if (isKeyedSegment(blockPathSegment))\n    return blockPathSegment._key;\n}\nfunction getChildKeyFromSelectionPoint(point) {\n  const childPathSegment = point.path.at(2);\n  if (isKeyedSegment(childPathSegment))\n    return childPathSegment._key;\n}\nfunction blockOffsetToSpanSelectionPoint({\n  context,\n  blockOffset,\n  direction\n}) {\n  let offsetLeft = blockOffset.offset, selectionPoint, skippedInlineObject = !1;\n  for (const block of context.value)\n    if (block._key === blockOffset.path[0]._key && (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_0__.isTextBlock)(context, block))\n      for (const child of block.children) {\n        if (direction === \"forward\") {\n          if (!(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_0__.isSpan)(context, child))\n            continue;\n          if (offsetLeft <= child.text.length) {\n            selectionPoint = {\n              path: [...blockOffset.path, \"children\", {\n                _key: child._key\n              }],\n              offset: offsetLeft\n            };\n            break;\n          }\n          offsetLeft -= child.text.length;\n          continue;\n        }\n        if (!(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_0__.isSpan)(context, child)) {\n          skippedInlineObject = !0;\n          continue;\n        }\n        if (offsetLeft === 0 && selectionPoint && !skippedInlineObject) {\n          skippedInlineObject && (selectionPoint = {\n            path: [...blockOffset.path, \"children\", {\n              _key: child._key\n            }],\n            offset: 0\n          });\n          break;\n        }\n        if (offsetLeft > child.text.length) {\n          offsetLeft -= child.text.length;\n          continue;\n        }\n        if (offsetLeft <= child.text.length && (selectionPoint = {\n          path: [...blockOffset.path, \"children\", {\n            _key: child._key\n          }],\n          offset: offsetLeft\n        }, offsetLeft -= child.text.length, offsetLeft !== 0))\n          break;\n      }\n  return selectionPoint;\n}\nfunction spanSelectionPointToBlockOffset({\n  context,\n  selectionPoint\n}) {\n  let offset = 0;\n  const blockKey = getBlockKeyFromSelectionPoint(selectionPoint), spanKey = getChildKeyFromSelectionPoint(selectionPoint);\n  if (!(!blockKey || !spanKey)) {\n    for (const block of context.value)\n      if (block._key === blockKey && (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_0__.isTextBlock)(context, block)) {\n        for (const child of block.children)\n          if ((0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_0__.isSpan)(context, child)) {\n            if (child._key === spanKey)\n              return {\n                path: [{\n                  _key: block._key\n                }],\n                offset: offset + selectionPoint.offset\n              };\n            offset += child.text.length;\n          }\n      }\n  }\n}\nfunction isTypedObject(object) {\n  return isRecord(object) && typeof object._type == \"string\";\n}\nfunction isRecord(value) {\n  return !!value && (typeof value == \"object\" || typeof value == \"function\");\n}\nfunction parseBlocks({\n  context,\n  blocks,\n  options\n}) {\n  return Array.isArray(blocks) ? blocks.flatMap((block) => {\n    const parsedBlock = parseBlock({\n      context,\n      block,\n      options\n    });\n    return parsedBlock ? [parsedBlock] : [];\n  }) : [];\n}\nfunction parseBlock({\n  context,\n  block,\n  options\n}) {\n  return parseTextBlock({\n    block,\n    context,\n    options\n  }) ?? parseBlockObject({\n    blockObject: block,\n    context,\n    options\n  });\n}\nfunction parseBlockObject({\n  blockObject,\n  context,\n  options\n}) {\n  if (!isTypedObject(blockObject))\n    return;\n  const schemaType = context.schema.blockObjects.find(({\n    name\n  }) => name === blockObject._type);\n  if (schemaType)\n    return parseObject({\n      object: blockObject,\n      context: {\n        keyGenerator: context.keyGenerator,\n        schemaType\n      },\n      options\n    });\n}\nfunction isListBlock(context, block) {\n  return (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_0__.isTextBlock)(context, block) && block.level !== void 0 && block.listItem !== void 0;\n}\nfunction parseTextBlock({\n  block,\n  context,\n  options\n}) {\n  if (!isTypedObject(block))\n    return;\n  const customFields = {};\n  for (const key of Object.keys(block))\n    key === \"_type\" || key === \"_key\" || key === \"children\" || key === \"markDefs\" || key === \"style\" || key === \"listItem\" || key === \"level\" || (options.validateFields ? context.schema.block.fields?.some((field) => field.name === key) && (customFields[key] = block[key]) : customFields[key] = block[key]);\n  if (block._type !== context.schema.block.name)\n    return;\n  const _key = typeof block._key == \"string\" ? block._key : context.keyGenerator(), unparsedMarkDefs = Array.isArray(block.markDefs) ? block.markDefs : [], markDefKeyMap = /* @__PURE__ */ new Map(), markDefs = unparsedMarkDefs.flatMap((markDef) => {\n    if (!isTypedObject(markDef))\n      return [];\n    const schemaType = context.schema.annotations.find(({\n      name\n    }) => name === markDef._type);\n    if (!schemaType)\n      return [];\n    if (typeof markDef._key != \"string\")\n      return [];\n    const parsedAnnotation = parseObject({\n      object: markDef,\n      context: {\n        schemaType,\n        keyGenerator: context.keyGenerator\n      },\n      options\n    });\n    return parsedAnnotation ? (markDefKeyMap.set(markDef._key, parsedAnnotation._key), [parsedAnnotation]) : [];\n  }), children = (Array.isArray(block.children) ? block.children : []).map((child) => parseSpan({\n    span: child,\n    context,\n    markDefKeyMap,\n    options\n  }) ?? parseInlineObject({\n    inlineObject: child,\n    context,\n    options\n  })).filter((child) => child !== void 0), marks = children.flatMap((child) => child.marks ?? []), parsedBlock = {\n    _type: context.schema.block.name,\n    _key,\n    children: children.length > 0 ? children : [{\n      _key: context.keyGenerator(),\n      _type: context.schema.span.name,\n      text: \"\",\n      marks: []\n    }],\n    markDefs: options.removeUnusedMarkDefs ? markDefs.filter((markDef) => marks.includes(markDef._key)) : markDefs,\n    ...customFields\n  };\n  if (typeof block.style == \"string\" && context.schema.styles.find((style) => style.name === block.style))\n    parsedBlock.style = block.style;\n  else {\n    const defaultStyle = context.schema.styles.at(0)?.name;\n    defaultStyle !== void 0 ? parsedBlock.style = defaultStyle : console.error(\"Expected default style\");\n  }\n  return typeof block.listItem == \"string\" && context.schema.lists.find((list) => list.name === block.listItem) && (parsedBlock.listItem = block.listItem), typeof block.level == \"number\" && (parsedBlock.level = block.level), parsedBlock;\n}\nfunction parseSpan({\n  span,\n  context,\n  markDefKeyMap,\n  options\n}) {\n  if (!isTypedObject(span))\n    return;\n  const customFields = {};\n  for (const key of Object.keys(span))\n    key !== \"_type\" && key !== \"_key\" && key !== \"text\" && key !== \"marks\" && (customFields[key] = span[key]);\n  if (span._type !== context.schema.span.name || span._type !== \"span\")\n    return;\n  const marks = (Array.isArray(span.marks) ? span.marks : []).flatMap((mark) => {\n    if (typeof mark != \"string\")\n      return [];\n    const markDefKey = markDefKeyMap.get(mark);\n    return markDefKey !== void 0 ? [markDefKey] : context.schema.decorators.some((decorator) => decorator.name === mark) ? [mark] : [];\n  });\n  return {\n    _type: \"span\",\n    _key: typeof span._key == \"string\" ? span._key : context.keyGenerator(),\n    text: typeof span.text == \"string\" ? span.text : \"\",\n    marks,\n    ...options.validateFields ? {} : customFields\n  };\n}\nfunction parseInlineObject({\n  inlineObject,\n  context,\n  options\n}) {\n  if (!isTypedObject(inlineObject))\n    return;\n  const schemaType = context.schema.inlineObjects.find(({\n    name\n  }) => name === inlineObject._type);\n  if (schemaType)\n    return parseObject({\n      object: inlineObject,\n      context: {\n        keyGenerator: context.keyGenerator,\n        schemaType\n      },\n      options\n    });\n}\nfunction parseAnnotation({\n  annotation,\n  context,\n  options\n}) {\n  if (!isTypedObject(annotation))\n    return;\n  const schemaType = context.schema.annotations.find(({\n    name\n  }) => name === annotation._type);\n  if (schemaType)\n    return parseObject({\n      object: annotation,\n      context: {\n        keyGenerator: context.keyGenerator,\n        schemaType\n      },\n      options\n    });\n}\nfunction parseObject({\n  object,\n  context,\n  options\n}) {\n  const {\n    _type,\n    _key,\n    ...customFields\n  } = object, values = options.validateFields ? context.schemaType.fields.reduce((fieldValues, field) => {\n    const fieldValue = object[field.name];\n    return fieldValue !== void 0 && (fieldValues[field.name] = fieldValue), fieldValues;\n  }, {}) : customFields;\n  return {\n    _type: context.schemaType.name,\n    _key: typeof object._key == \"string\" ? object._key : context.keyGenerator(),\n    ...values\n  };\n}\nconst defaultKeyGenerator = () => randomKey(12), getByteHexTable = /* @__PURE__ */ (() => {\n  let table;\n  return () => {\n    if (table)\n      return table;\n    table = [];\n    for (let i = 0; i < 256; ++i)\n      table[i] = (i + 256).toString(16).slice(1);\n    return table;\n  };\n})();\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length);\n  return (0,get_random_values_esm__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(rnds8), rnds8;\n}\nfunction randomKey(length) {\n  const table = getByteHexTable();\n  return whatwgRNG(length).reduce((str, n) => str + table[n], \"\").slice(0, length);\n}\nfunction getSelectionEndPoint(selection) {\n  return selection ? selection.backward ? selection.anchor : selection.focus : null;\n}\nfunction getSelectionStartPoint(selection) {\n  return selection ? selection.backward ? selection.focus : selection.anchor : null;\n}\nfunction sliceBlocks({\n  context,\n  blocks\n}) {\n  const slice = [];\n  if (!context.selection)\n    return slice;\n  let startBlock;\n  const middleBlocks = [];\n  let endBlock;\n  const startPoint = getSelectionStartPoint(context.selection), endPoint = getSelectionEndPoint(context.selection), startBlockKey = getBlockKeyFromSelectionPoint(startPoint), startChildKey = getChildKeyFromSelectionPoint(startPoint), endBlockKey = getBlockKeyFromSelectionPoint(endPoint), endChildKey = getChildKeyFromSelectionPoint(endPoint);\n  if (!startBlockKey || !endBlockKey)\n    return slice;\n  for (const block of blocks) {\n    if (!(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_0__.isTextBlock)(context, block) && block._key === startBlockKey && block._key === endBlockKey) {\n      startBlock = block;\n      break;\n    }\n    if (block._key === startBlockKey) {\n      if (!(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_0__.isTextBlock)(context, block)) {\n        startBlock = block;\n        continue;\n      }\n      if (startChildKey) {\n        for (const child of block.children) {\n          if (child._key === startChildKey) {\n            if ((0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_0__.isSpan)(context, child)) {\n              const text = child._key === endChildKey ? child.text.slice(startPoint.offset, endPoint.offset) : child.text.slice(startPoint.offset);\n              startBlock = {\n                ...block,\n                children: [{\n                  ...child,\n                  text\n                }]\n              };\n            } else\n              startBlock = {\n                ...block,\n                children: [child]\n              };\n            if (block._key === endBlockKey && startChildKey === endChildKey)\n              break;\n            continue;\n          }\n          if (startBlock && (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_0__.isTextBlock)(context, startBlock) && (endChildKey && child._key === endChildKey && (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_0__.isSpan)(context, child) ? startBlock.children.push({\n            ...child,\n            text: child.text.slice(0, endPoint.offset)\n          }) : startBlock.children.push(child), block._key === endBlockKey && endChildKey && child._key === endChildKey))\n            break;\n        }\n        if (startBlockKey === endBlockKey)\n          break;\n        continue;\n      }\n      if (startBlock = block, startBlockKey === endBlockKey)\n        break;\n    }\n    if (block._key === endBlockKey) {\n      if (!(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_0__.isTextBlock)(context, block)) {\n        endBlock = block;\n        break;\n      }\n      if (endChildKey) {\n        endBlock = {\n          ...block,\n          children: []\n        };\n        for (const child of block.children)\n          if (endBlock && (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_0__.isTextBlock)(context, endBlock)) {\n            if (child._key === endChildKey && (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_0__.isSpan)(context, child)) {\n              endBlock.children.push({\n                ...child,\n                text: child.text.slice(0, endPoint.offset)\n              });\n              break;\n            }\n            if (endBlock.children.push(child), endChildKey && child._key === endChildKey)\n              break;\n          }\n        break;\n      }\n      endBlock = block;\n      break;\n    }\n    startBlock && middleBlocks.push(parseBlock({\n      context: {\n        ...context,\n        keyGenerator: defaultKeyGenerator\n      },\n      block,\n      options: {\n        removeUnusedMarkDefs: !0,\n        validateFields: !1\n      }\n    }) ?? block);\n  }\n  const parsedStartBlock = startBlock ? parseBlock({\n    context: {\n      ...context,\n      keyGenerator: defaultKeyGenerator\n    },\n    block: startBlock,\n    options: {\n      removeUnusedMarkDefs: !0,\n      validateFields: !1\n    }\n  }) : void 0, parsedEndBlock = endBlock ? parseBlock({\n    context: {\n      ...context,\n      keyGenerator: defaultKeyGenerator\n    },\n    block: endBlock,\n    options: {\n      removeUnusedMarkDefs: !0,\n      validateFields: !1\n    }\n  }) : void 0;\n  return [...parsedStartBlock ? [parsedStartBlock] : [], ...middleBlocks, ...parsedEndBlock ? [parsedEndBlock] : []];\n}\nfunction getTextBlockText(block) {\n  return block.children.map((child) => child.text ?? \"\").join(\"\");\n}\n\n//# sourceMappingURL=util.get-text-block-text.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9fY2h1bmtzLWVzL3V0aWwuZ2V0LXRleHQtYmxvY2stdGV4dC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEyRDtBQUNQO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxTQUFTLGlFQUFXO0FBQ3BCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxtREFBbUQsaUVBQVc7QUFDOUQ7QUFDQTtBQUNBLGVBQWUsNERBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNERBQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlFQUFXO0FBQ2hEO0FBQ0EsY0FBYyw0REFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFNBQVMsaUVBQVc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsU0FBUyxpRUFBZTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxpRUFBVztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUVBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDREQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlFQUFXLHVFQUF1RSw0REFBTTtBQUNwSDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpRUFBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVc7QUFDckMsOENBQThDLDREQUFNO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFvQkU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL0dhbG9jay9DUy9iZWhvbWUtc2l0ZS9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvdXRpbC5nZXQtdGV4dC1ibG9jay10ZXh0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzVGV4dEJsb2NrLCBpc1NwYW4gfSBmcm9tIFwiQHBvcnRhYmxldGV4dC9zY2hlbWFcIjtcbmltcG9ydCBnZXRSYW5kb21WYWx1ZXMgZnJvbSBcImdldC1yYW5kb20tdmFsdWVzLWVzbVwiO1xuZnVuY3Rpb24gZ2V0QmxvY2tTdGFydFBvaW50KHtcbiAgY29udGV4dCxcbiAgYmxvY2tcbn0pIHtcbiAgcmV0dXJuIGlzVGV4dEJsb2NrKGNvbnRleHQsIGJsb2NrLm5vZGUpID8ge1xuICAgIHBhdGg6IFsuLi5ibG9jay5wYXRoLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgIF9rZXk6IGJsb2NrLm5vZGUuY2hpbGRyZW5bMF0uX2tleVxuICAgIH1dLFxuICAgIG9mZnNldDogMFxuICB9IDoge1xuICAgIHBhdGg6IGJsb2NrLnBhdGgsXG4gICAgb2Zmc2V0OiAwXG4gIH07XG59XG5mdW5jdGlvbiBpc0tleWVkU2VnbWVudChzZWdtZW50KSB7XG4gIHJldHVybiB0eXBlb2Ygc2VnbWVudCA9PSBcIm9iamVjdFwiICYmIHNlZ21lbnQgIT09IG51bGwgJiYgXCJfa2V5XCIgaW4gc2VnbWVudDtcbn1cbmZ1bmN0aW9uIGdldEJsb2NrS2V5RnJvbVNlbGVjdGlvblBvaW50KHBvaW50KSB7XG4gIGNvbnN0IGJsb2NrUGF0aFNlZ21lbnQgPSBwb2ludC5wYXRoLmF0KDApO1xuICBpZiAoaXNLZXllZFNlZ21lbnQoYmxvY2tQYXRoU2VnbWVudCkpXG4gICAgcmV0dXJuIGJsb2NrUGF0aFNlZ21lbnQuX2tleTtcbn1cbmZ1bmN0aW9uIGdldENoaWxkS2V5RnJvbVNlbGVjdGlvblBvaW50KHBvaW50KSB7XG4gIGNvbnN0IGNoaWxkUGF0aFNlZ21lbnQgPSBwb2ludC5wYXRoLmF0KDIpO1xuICBpZiAoaXNLZXllZFNlZ21lbnQoY2hpbGRQYXRoU2VnbWVudCkpXG4gICAgcmV0dXJuIGNoaWxkUGF0aFNlZ21lbnQuX2tleTtcbn1cbmZ1bmN0aW9uIGJsb2NrT2Zmc2V0VG9TcGFuU2VsZWN0aW9uUG9pbnQoe1xuICBjb250ZXh0LFxuICBibG9ja09mZnNldCxcbiAgZGlyZWN0aW9uXG59KSB7XG4gIGxldCBvZmZzZXRMZWZ0ID0gYmxvY2tPZmZzZXQub2Zmc2V0LCBzZWxlY3Rpb25Qb2ludCwgc2tpcHBlZElubGluZU9iamVjdCA9ICExO1xuICBmb3IgKGNvbnN0IGJsb2NrIG9mIGNvbnRleHQudmFsdWUpXG4gICAgaWYgKGJsb2NrLl9rZXkgPT09IGJsb2NrT2Zmc2V0LnBhdGhbMF0uX2tleSAmJiBpc1RleHRCbG9jayhjb250ZXh0LCBibG9jaykpXG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGJsb2NrLmNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IFwiZm9yd2FyZFwiKSB7XG4gICAgICAgICAgaWYgKCFpc1NwYW4oY29udGV4dCwgY2hpbGQpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgaWYgKG9mZnNldExlZnQgPD0gY2hpbGQudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvblBvaW50ID0ge1xuICAgICAgICAgICAgICBwYXRoOiBbLi4uYmxvY2tPZmZzZXQucGF0aCwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXRMZWZ0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9mZnNldExlZnQgLT0gY2hpbGQudGV4dC5sZW5ndGg7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1NwYW4oY29udGV4dCwgY2hpbGQpKSB7XG4gICAgICAgICAgc2tpcHBlZElubGluZU9iamVjdCA9ICEwO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXRMZWZ0ID09PSAwICYmIHNlbGVjdGlvblBvaW50ICYmICFza2lwcGVkSW5saW5lT2JqZWN0KSB7XG4gICAgICAgICAgc2tpcHBlZElubGluZU9iamVjdCAmJiAoc2VsZWN0aW9uUG9pbnQgPSB7XG4gICAgICAgICAgICBwYXRoOiBbLi4uYmxvY2tPZmZzZXQucGF0aCwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICAgIF9rZXk6IGNoaWxkLl9rZXlcbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldExlZnQgPiBjaGlsZC50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgIG9mZnNldExlZnQgLT0gY2hpbGQudGV4dC5sZW5ndGg7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldExlZnQgPD0gY2hpbGQudGV4dC5sZW5ndGggJiYgKHNlbGVjdGlvblBvaW50ID0ge1xuICAgICAgICAgIHBhdGg6IFsuLi5ibG9ja09mZnNldC5wYXRoLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgIF9rZXk6IGNoaWxkLl9rZXlcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldExlZnRcbiAgICAgICAgfSwgb2Zmc2V0TGVmdCAtPSBjaGlsZC50ZXh0Lmxlbmd0aCwgb2Zmc2V0TGVmdCAhPT0gMCkpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIHJldHVybiBzZWxlY3Rpb25Qb2ludDtcbn1cbmZ1bmN0aW9uIHNwYW5TZWxlY3Rpb25Qb2ludFRvQmxvY2tPZmZzZXQoe1xuICBjb250ZXh0LFxuICBzZWxlY3Rpb25Qb2ludFxufSkge1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgY29uc3QgYmxvY2tLZXkgPSBnZXRCbG9ja0tleUZyb21TZWxlY3Rpb25Qb2ludChzZWxlY3Rpb25Qb2ludCksIHNwYW5LZXkgPSBnZXRDaGlsZEtleUZyb21TZWxlY3Rpb25Qb2ludChzZWxlY3Rpb25Qb2ludCk7XG4gIGlmICghKCFibG9ja0tleSB8fCAhc3BhbktleSkpIHtcbiAgICBmb3IgKGNvbnN0IGJsb2NrIG9mIGNvbnRleHQudmFsdWUpXG4gICAgICBpZiAoYmxvY2suX2tleSA9PT0gYmxvY2tLZXkgJiYgaXNUZXh0QmxvY2soY29udGV4dCwgYmxvY2spKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgYmxvY2suY2hpbGRyZW4pXG4gICAgICAgICAgaWYgKGlzU3Bhbihjb250ZXh0LCBjaGlsZCkpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5fa2V5ID09PSBzcGFuS2V5KVxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQgKyBzZWxlY3Rpb25Qb2ludC5vZmZzZXRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG9mZnNldCArPSBjaGlsZC50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGlzVHlwZWRPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiBpc1JlY29yZChvYmplY3QpICYmIHR5cGVvZiBvYmplY3QuX3R5cGUgPT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGlzUmVjb3JkKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQmxvY2tzKHtcbiAgY29udGV4dCxcbiAgYmxvY2tzLFxuICBvcHRpb25zXG59KSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGJsb2NrcykgPyBibG9ja3MuZmxhdE1hcCgoYmxvY2spID0+IHtcbiAgICBjb25zdCBwYXJzZWRCbG9jayA9IHBhcnNlQmxvY2soe1xuICAgICAgY29udGV4dCxcbiAgICAgIGJsb2NrLFxuICAgICAgb3B0aW9uc1xuICAgIH0pO1xuICAgIHJldHVybiBwYXJzZWRCbG9jayA/IFtwYXJzZWRCbG9ja10gOiBbXTtcbiAgfSkgOiBbXTtcbn1cbmZ1bmN0aW9uIHBhcnNlQmxvY2soe1xuICBjb250ZXh0LFxuICBibG9jayxcbiAgb3B0aW9uc1xufSkge1xuICByZXR1cm4gcGFyc2VUZXh0QmxvY2soe1xuICAgIGJsb2NrLFxuICAgIGNvbnRleHQsXG4gICAgb3B0aW9uc1xuICB9KSA/PyBwYXJzZUJsb2NrT2JqZWN0KHtcbiAgICBibG9ja09iamVjdDogYmxvY2ssXG4gICAgY29udGV4dCxcbiAgICBvcHRpb25zXG4gIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VCbG9ja09iamVjdCh7XG4gIGJsb2NrT2JqZWN0LFxuICBjb250ZXh0LFxuICBvcHRpb25zXG59KSB7XG4gIGlmICghaXNUeXBlZE9iamVjdChibG9ja09iamVjdCkpXG4gICAgcmV0dXJuO1xuICBjb25zdCBzY2hlbWFUeXBlID0gY29udGV4dC5zY2hlbWEuYmxvY2tPYmplY3RzLmZpbmQoKHtcbiAgICBuYW1lXG4gIH0pID0+IG5hbWUgPT09IGJsb2NrT2JqZWN0Ll90eXBlKTtcbiAgaWYgKHNjaGVtYVR5cGUpXG4gICAgcmV0dXJuIHBhcnNlT2JqZWN0KHtcbiAgICAgIG9iamVjdDogYmxvY2tPYmplY3QsXG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIGtleUdlbmVyYXRvcjogY29udGV4dC5rZXlHZW5lcmF0b3IsXG4gICAgICAgIHNjaGVtYVR5cGVcbiAgICAgIH0sXG4gICAgICBvcHRpb25zXG4gICAgfSk7XG59XG5mdW5jdGlvbiBpc0xpc3RCbG9jayhjb250ZXh0LCBibG9jaykge1xuICByZXR1cm4gaXNUZXh0QmxvY2soY29udGV4dCwgYmxvY2spICYmIGJsb2NrLmxldmVsICE9PSB2b2lkIDAgJiYgYmxvY2subGlzdEl0ZW0gIT09IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHBhcnNlVGV4dEJsb2NrKHtcbiAgYmxvY2ssXG4gIGNvbnRleHQsXG4gIG9wdGlvbnNcbn0pIHtcbiAgaWYgKCFpc1R5cGVkT2JqZWN0KGJsb2NrKSlcbiAgICByZXR1cm47XG4gIGNvbnN0IGN1c3RvbUZpZWxkcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhibG9jaykpXG4gICAga2V5ID09PSBcIl90eXBlXCIgfHwga2V5ID09PSBcIl9rZXlcIiB8fCBrZXkgPT09IFwiY2hpbGRyZW5cIiB8fCBrZXkgPT09IFwibWFya0RlZnNcIiB8fCBrZXkgPT09IFwic3R5bGVcIiB8fCBrZXkgPT09IFwibGlzdEl0ZW1cIiB8fCBrZXkgPT09IFwibGV2ZWxcIiB8fCAob3B0aW9ucy52YWxpZGF0ZUZpZWxkcyA/IGNvbnRleHQuc2NoZW1hLmJsb2NrLmZpZWxkcz8uc29tZSgoZmllbGQpID0+IGZpZWxkLm5hbWUgPT09IGtleSkgJiYgKGN1c3RvbUZpZWxkc1trZXldID0gYmxvY2tba2V5XSkgOiBjdXN0b21GaWVsZHNba2V5XSA9IGJsb2NrW2tleV0pO1xuICBpZiAoYmxvY2suX3R5cGUgIT09IGNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWUpXG4gICAgcmV0dXJuO1xuICBjb25zdCBfa2V5ID0gdHlwZW9mIGJsb2NrLl9rZXkgPT0gXCJzdHJpbmdcIiA/IGJsb2NrLl9rZXkgOiBjb250ZXh0LmtleUdlbmVyYXRvcigpLCB1bnBhcnNlZE1hcmtEZWZzID0gQXJyYXkuaXNBcnJheShibG9jay5tYXJrRGVmcykgPyBibG9jay5tYXJrRGVmcyA6IFtdLCBtYXJrRGVmS2V5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgbWFya0RlZnMgPSB1bnBhcnNlZE1hcmtEZWZzLmZsYXRNYXAoKG1hcmtEZWYpID0+IHtcbiAgICBpZiAoIWlzVHlwZWRPYmplY3QobWFya0RlZikpXG4gICAgICByZXR1cm4gW107XG4gICAgY29uc3Qgc2NoZW1hVHlwZSA9IGNvbnRleHQuc2NoZW1hLmFubm90YXRpb25zLmZpbmQoKHtcbiAgICAgIG5hbWVcbiAgICB9KSA9PiBuYW1lID09PSBtYXJrRGVmLl90eXBlKTtcbiAgICBpZiAoIXNjaGVtYVR5cGUpXG4gICAgICByZXR1cm4gW107XG4gICAgaWYgKHR5cGVvZiBtYXJrRGVmLl9rZXkgIT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCBwYXJzZWRBbm5vdGF0aW9uID0gcGFyc2VPYmplY3Qoe1xuICAgICAgb2JqZWN0OiBtYXJrRGVmLFxuICAgICAgY29udGV4dDoge1xuICAgICAgICBzY2hlbWFUeXBlLFxuICAgICAgICBrZXlHZW5lcmF0b3I6IGNvbnRleHQua2V5R2VuZXJhdG9yXG4gICAgICB9LFxuICAgICAgb3B0aW9uc1xuICAgIH0pO1xuICAgIHJldHVybiBwYXJzZWRBbm5vdGF0aW9uID8gKG1hcmtEZWZLZXlNYXAuc2V0KG1hcmtEZWYuX2tleSwgcGFyc2VkQW5ub3RhdGlvbi5fa2V5KSwgW3BhcnNlZEFubm90YXRpb25dKSA6IFtdO1xuICB9KSwgY2hpbGRyZW4gPSAoQXJyYXkuaXNBcnJheShibG9jay5jaGlsZHJlbikgPyBibG9jay5jaGlsZHJlbiA6IFtdKS5tYXAoKGNoaWxkKSA9PiBwYXJzZVNwYW4oe1xuICAgIHNwYW46IGNoaWxkLFxuICAgIGNvbnRleHQsXG4gICAgbWFya0RlZktleU1hcCxcbiAgICBvcHRpb25zXG4gIH0pID8/IHBhcnNlSW5saW5lT2JqZWN0KHtcbiAgICBpbmxpbmVPYmplY3Q6IGNoaWxkLFxuICAgIGNvbnRleHQsXG4gICAgb3B0aW9uc1xuICB9KSkuZmlsdGVyKChjaGlsZCkgPT4gY2hpbGQgIT09IHZvaWQgMCksIG1hcmtzID0gY2hpbGRyZW4uZmxhdE1hcCgoY2hpbGQpID0+IGNoaWxkLm1hcmtzID8/IFtdKSwgcGFyc2VkQmxvY2sgPSB7XG4gICAgX3R5cGU6IGNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWUsXG4gICAgX2tleSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4ubGVuZ3RoID4gMCA/IGNoaWxkcmVuIDogW3tcbiAgICAgIF9rZXk6IGNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgICBfdHlwZTogY29udGV4dC5zY2hlbWEuc3Bhbi5uYW1lLFxuICAgICAgdGV4dDogXCJcIixcbiAgICAgIG1hcmtzOiBbXVxuICAgIH1dLFxuICAgIG1hcmtEZWZzOiBvcHRpb25zLnJlbW92ZVVudXNlZE1hcmtEZWZzID8gbWFya0RlZnMuZmlsdGVyKChtYXJrRGVmKSA9PiBtYXJrcy5pbmNsdWRlcyhtYXJrRGVmLl9rZXkpKSA6IG1hcmtEZWZzLFxuICAgIC4uLmN1c3RvbUZpZWxkc1xuICB9O1xuICBpZiAodHlwZW9mIGJsb2NrLnN0eWxlID09IFwic3RyaW5nXCIgJiYgY29udGV4dC5zY2hlbWEuc3R5bGVzLmZpbmQoKHN0eWxlKSA9PiBzdHlsZS5uYW1lID09PSBibG9jay5zdHlsZSkpXG4gICAgcGFyc2VkQmxvY2suc3R5bGUgPSBibG9jay5zdHlsZTtcbiAgZWxzZSB7XG4gICAgY29uc3QgZGVmYXVsdFN0eWxlID0gY29udGV4dC5zY2hlbWEuc3R5bGVzLmF0KDApPy5uYW1lO1xuICAgIGRlZmF1bHRTdHlsZSAhPT0gdm9pZCAwID8gcGFyc2VkQmxvY2suc3R5bGUgPSBkZWZhdWx0U3R5bGUgOiBjb25zb2xlLmVycm9yKFwiRXhwZWN0ZWQgZGVmYXVsdCBzdHlsZVwiKTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIGJsb2NrLmxpc3RJdGVtID09IFwic3RyaW5nXCIgJiYgY29udGV4dC5zY2hlbWEubGlzdHMuZmluZCgobGlzdCkgPT4gbGlzdC5uYW1lID09PSBibG9jay5saXN0SXRlbSkgJiYgKHBhcnNlZEJsb2NrLmxpc3RJdGVtID0gYmxvY2subGlzdEl0ZW0pLCB0eXBlb2YgYmxvY2subGV2ZWwgPT0gXCJudW1iZXJcIiAmJiAocGFyc2VkQmxvY2subGV2ZWwgPSBibG9jay5sZXZlbCksIHBhcnNlZEJsb2NrO1xufVxuZnVuY3Rpb24gcGFyc2VTcGFuKHtcbiAgc3BhbixcbiAgY29udGV4dCxcbiAgbWFya0RlZktleU1hcCxcbiAgb3B0aW9uc1xufSkge1xuICBpZiAoIWlzVHlwZWRPYmplY3Qoc3BhbikpXG4gICAgcmV0dXJuO1xuICBjb25zdCBjdXN0b21GaWVsZHMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc3BhbikpXG4gICAga2V5ICE9PSBcIl90eXBlXCIgJiYga2V5ICE9PSBcIl9rZXlcIiAmJiBrZXkgIT09IFwidGV4dFwiICYmIGtleSAhPT0gXCJtYXJrc1wiICYmIChjdXN0b21GaWVsZHNba2V5XSA9IHNwYW5ba2V5XSk7XG4gIGlmIChzcGFuLl90eXBlICE9PSBjb250ZXh0LnNjaGVtYS5zcGFuLm5hbWUgfHwgc3Bhbi5fdHlwZSAhPT0gXCJzcGFuXCIpXG4gICAgcmV0dXJuO1xuICBjb25zdCBtYXJrcyA9IChBcnJheS5pc0FycmF5KHNwYW4ubWFya3MpID8gc3Bhbi5tYXJrcyA6IFtdKS5mbGF0TWFwKChtYXJrKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBtYXJrICE9IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gW107XG4gICAgY29uc3QgbWFya0RlZktleSA9IG1hcmtEZWZLZXlNYXAuZ2V0KG1hcmspO1xuICAgIHJldHVybiBtYXJrRGVmS2V5ICE9PSB2b2lkIDAgPyBbbWFya0RlZktleV0gOiBjb250ZXh0LnNjaGVtYS5kZWNvcmF0b3JzLnNvbWUoKGRlY29yYXRvcikgPT4gZGVjb3JhdG9yLm5hbWUgPT09IG1hcmspID8gW21hcmtdIDogW107XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIF90eXBlOiBcInNwYW5cIixcbiAgICBfa2V5OiB0eXBlb2Ygc3Bhbi5fa2V5ID09IFwic3RyaW5nXCIgPyBzcGFuLl9rZXkgOiBjb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgIHRleHQ6IHR5cGVvZiBzcGFuLnRleHQgPT0gXCJzdHJpbmdcIiA/IHNwYW4udGV4dCA6IFwiXCIsXG4gICAgbWFya3MsXG4gICAgLi4ub3B0aW9ucy52YWxpZGF0ZUZpZWxkcyA/IHt9IDogY3VzdG9tRmllbGRzXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZUlubGluZU9iamVjdCh7XG4gIGlubGluZU9iamVjdCxcbiAgY29udGV4dCxcbiAgb3B0aW9uc1xufSkge1xuICBpZiAoIWlzVHlwZWRPYmplY3QoaW5saW5lT2JqZWN0KSlcbiAgICByZXR1cm47XG4gIGNvbnN0IHNjaGVtYVR5cGUgPSBjb250ZXh0LnNjaGVtYS5pbmxpbmVPYmplY3RzLmZpbmQoKHtcbiAgICBuYW1lXG4gIH0pID0+IG5hbWUgPT09IGlubGluZU9iamVjdC5fdHlwZSk7XG4gIGlmIChzY2hlbWFUeXBlKVxuICAgIHJldHVybiBwYXJzZU9iamVjdCh7XG4gICAgICBvYmplY3Q6IGlubGluZU9iamVjdCxcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAga2V5R2VuZXJhdG9yOiBjb250ZXh0LmtleUdlbmVyYXRvcixcbiAgICAgICAgc2NoZW1hVHlwZVxuICAgICAgfSxcbiAgICAgIG9wdGlvbnNcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlQW5ub3RhdGlvbih7XG4gIGFubm90YXRpb24sXG4gIGNvbnRleHQsXG4gIG9wdGlvbnNcbn0pIHtcbiAgaWYgKCFpc1R5cGVkT2JqZWN0KGFubm90YXRpb24pKVxuICAgIHJldHVybjtcbiAgY29uc3Qgc2NoZW1hVHlwZSA9IGNvbnRleHQuc2NoZW1hLmFubm90YXRpb25zLmZpbmQoKHtcbiAgICBuYW1lXG4gIH0pID0+IG5hbWUgPT09IGFubm90YXRpb24uX3R5cGUpO1xuICBpZiAoc2NoZW1hVHlwZSlcbiAgICByZXR1cm4gcGFyc2VPYmplY3Qoe1xuICAgICAgb2JqZWN0OiBhbm5vdGF0aW9uLFxuICAgICAgY29udGV4dDoge1xuICAgICAgICBrZXlHZW5lcmF0b3I6IGNvbnRleHQua2V5R2VuZXJhdG9yLFxuICAgICAgICBzY2hlbWFUeXBlXG4gICAgICB9LFxuICAgICAgb3B0aW9uc1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VPYmplY3Qoe1xuICBvYmplY3QsXG4gIGNvbnRleHQsXG4gIG9wdGlvbnNcbn0pIHtcbiAgY29uc3Qge1xuICAgIF90eXBlLFxuICAgIF9rZXksXG4gICAgLi4uY3VzdG9tRmllbGRzXG4gIH0gPSBvYmplY3QsIHZhbHVlcyA9IG9wdGlvbnMudmFsaWRhdGVGaWVsZHMgPyBjb250ZXh0LnNjaGVtYVR5cGUuZmllbGRzLnJlZHVjZSgoZmllbGRWYWx1ZXMsIGZpZWxkKSA9PiB7XG4gICAgY29uc3QgZmllbGRWYWx1ZSA9IG9iamVjdFtmaWVsZC5uYW1lXTtcbiAgICByZXR1cm4gZmllbGRWYWx1ZSAhPT0gdm9pZCAwICYmIChmaWVsZFZhbHVlc1tmaWVsZC5uYW1lXSA9IGZpZWxkVmFsdWUpLCBmaWVsZFZhbHVlcztcbiAgfSwge30pIDogY3VzdG9tRmllbGRzO1xuICByZXR1cm4ge1xuICAgIF90eXBlOiBjb250ZXh0LnNjaGVtYVR5cGUubmFtZSxcbiAgICBfa2V5OiB0eXBlb2Ygb2JqZWN0Ll9rZXkgPT0gXCJzdHJpbmdcIiA/IG9iamVjdC5fa2V5IDogY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAuLi52YWx1ZXNcbiAgfTtcbn1cbmNvbnN0IGRlZmF1bHRLZXlHZW5lcmF0b3IgPSAoKSA9PiByYW5kb21LZXkoMTIpLCBnZXRCeXRlSGV4VGFibGUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgbGV0IHRhYmxlO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGlmICh0YWJsZSlcbiAgICAgIHJldHVybiB0YWJsZTtcbiAgICB0YWJsZSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyArK2kpXG4gICAgICB0YWJsZVtpXSA9IChpICsgMjU2KS50b1N0cmluZygxNikuc2xpY2UoMSk7XG4gICAgcmV0dXJuIHRhYmxlO1xuICB9O1xufSkoKTtcbmZ1bmN0aW9uIHdoYXR3Z1JORyhsZW5ndGggPSAxNikge1xuICBjb25zdCBybmRzOCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gIHJldHVybiBnZXRSYW5kb21WYWx1ZXMocm5kczgpLCBybmRzODtcbn1cbmZ1bmN0aW9uIHJhbmRvbUtleShsZW5ndGgpIHtcbiAgY29uc3QgdGFibGUgPSBnZXRCeXRlSGV4VGFibGUoKTtcbiAgcmV0dXJuIHdoYXR3Z1JORyhsZW5ndGgpLnJlZHVjZSgoc3RyLCBuKSA9PiBzdHIgKyB0YWJsZVtuXSwgXCJcIikuc2xpY2UoMCwgbGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbkVuZFBvaW50KHNlbGVjdGlvbikge1xuICByZXR1cm4gc2VsZWN0aW9uID8gc2VsZWN0aW9uLmJhY2t3YXJkID8gc2VsZWN0aW9uLmFuY2hvciA6IHNlbGVjdGlvbi5mb2N1cyA6IG51bGw7XG59XG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25TdGFydFBvaW50KHNlbGVjdGlvbikge1xuICByZXR1cm4gc2VsZWN0aW9uID8gc2VsZWN0aW9uLmJhY2t3YXJkID8gc2VsZWN0aW9uLmZvY3VzIDogc2VsZWN0aW9uLmFuY2hvciA6IG51bGw7XG59XG5mdW5jdGlvbiBzbGljZUJsb2Nrcyh7XG4gIGNvbnRleHQsXG4gIGJsb2Nrc1xufSkge1xuICBjb25zdCBzbGljZSA9IFtdO1xuICBpZiAoIWNvbnRleHQuc2VsZWN0aW9uKVxuICAgIHJldHVybiBzbGljZTtcbiAgbGV0IHN0YXJ0QmxvY2s7XG4gIGNvbnN0IG1pZGRsZUJsb2NrcyA9IFtdO1xuICBsZXQgZW5kQmxvY2s7XG4gIGNvbnN0IHN0YXJ0UG9pbnQgPSBnZXRTZWxlY3Rpb25TdGFydFBvaW50KGNvbnRleHQuc2VsZWN0aW9uKSwgZW5kUG9pbnQgPSBnZXRTZWxlY3Rpb25FbmRQb2ludChjb250ZXh0LnNlbGVjdGlvbiksIHN0YXJ0QmxvY2tLZXkgPSBnZXRCbG9ja0tleUZyb21TZWxlY3Rpb25Qb2ludChzdGFydFBvaW50KSwgc3RhcnRDaGlsZEtleSA9IGdldENoaWxkS2V5RnJvbVNlbGVjdGlvblBvaW50KHN0YXJ0UG9pbnQpLCBlbmRCbG9ja0tleSA9IGdldEJsb2NrS2V5RnJvbVNlbGVjdGlvblBvaW50KGVuZFBvaW50KSwgZW5kQ2hpbGRLZXkgPSBnZXRDaGlsZEtleUZyb21TZWxlY3Rpb25Qb2ludChlbmRQb2ludCk7XG4gIGlmICghc3RhcnRCbG9ja0tleSB8fCAhZW5kQmxvY2tLZXkpXG4gICAgcmV0dXJuIHNsaWNlO1xuICBmb3IgKGNvbnN0IGJsb2NrIG9mIGJsb2Nrcykge1xuICAgIGlmICghaXNUZXh0QmxvY2soY29udGV4dCwgYmxvY2spICYmIGJsb2NrLl9rZXkgPT09IHN0YXJ0QmxvY2tLZXkgJiYgYmxvY2suX2tleSA9PT0gZW5kQmxvY2tLZXkpIHtcbiAgICAgIHN0YXJ0QmxvY2sgPSBibG9jaztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoYmxvY2suX2tleSA9PT0gc3RhcnRCbG9ja0tleSkge1xuICAgICAgaWYgKCFpc1RleHRCbG9jayhjb250ZXh0LCBibG9jaykpIHtcbiAgICAgICAgc3RhcnRCbG9jayA9IGJsb2NrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydENoaWxkS2V5KSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgYmxvY2suY2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoY2hpbGQuX2tleSA9PT0gc3RhcnRDaGlsZEtleSkge1xuICAgICAgICAgICAgaWYgKGlzU3Bhbihjb250ZXh0LCBjaGlsZCkpIHtcbiAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGNoaWxkLl9rZXkgPT09IGVuZENoaWxkS2V5ID8gY2hpbGQudGV4dC5zbGljZShzdGFydFBvaW50Lm9mZnNldCwgZW5kUG9pbnQub2Zmc2V0KSA6IGNoaWxkLnRleHQuc2xpY2Uoc3RhcnRQb2ludC5vZmZzZXQpO1xuICAgICAgICAgICAgICBzdGFydEJsb2NrID0ge1xuICAgICAgICAgICAgICAgIC4uLmJsb2NrLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgICAgICAgICAgLi4uY2hpbGQsXG4gICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBzdGFydEJsb2NrID0ge1xuICAgICAgICAgICAgICAgIC4uLmJsb2NrLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbY2hpbGRdXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoYmxvY2suX2tleSA9PT0gZW5kQmxvY2tLZXkgJiYgc3RhcnRDaGlsZEtleSA9PT0gZW5kQ2hpbGRLZXkpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGFydEJsb2NrICYmIGlzVGV4dEJsb2NrKGNvbnRleHQsIHN0YXJ0QmxvY2spICYmIChlbmRDaGlsZEtleSAmJiBjaGlsZC5fa2V5ID09PSBlbmRDaGlsZEtleSAmJiBpc1NwYW4oY29udGV4dCwgY2hpbGQpID8gc3RhcnRCbG9jay5jaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgIC4uLmNoaWxkLFxuICAgICAgICAgICAgdGV4dDogY2hpbGQudGV4dC5zbGljZSgwLCBlbmRQb2ludC5vZmZzZXQpXG4gICAgICAgICAgfSkgOiBzdGFydEJsb2NrLmNoaWxkcmVuLnB1c2goY2hpbGQpLCBibG9jay5fa2V5ID09PSBlbmRCbG9ja0tleSAmJiBlbmRDaGlsZEtleSAmJiBjaGlsZC5fa2V5ID09PSBlbmRDaGlsZEtleSkpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRCbG9ja0tleSA9PT0gZW5kQmxvY2tLZXkpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0QmxvY2sgPSBibG9jaywgc3RhcnRCbG9ja0tleSA9PT0gZW5kQmxvY2tLZXkpXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoYmxvY2suX2tleSA9PT0gZW5kQmxvY2tLZXkpIHtcbiAgICAgIGlmICghaXNUZXh0QmxvY2soY29udGV4dCwgYmxvY2spKSB7XG4gICAgICAgIGVuZEJsb2NrID0gYmxvY2s7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGVuZENoaWxkS2V5KSB7XG4gICAgICAgIGVuZEJsb2NrID0ge1xuICAgICAgICAgIC4uLmJsb2NrLFxuICAgICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGJsb2NrLmNoaWxkcmVuKVxuICAgICAgICAgIGlmIChlbmRCbG9jayAmJiBpc1RleHRCbG9jayhjb250ZXh0LCBlbmRCbG9jaykpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5fa2V5ID09PSBlbmRDaGlsZEtleSAmJiBpc1NwYW4oY29udGV4dCwgY2hpbGQpKSB7XG4gICAgICAgICAgICAgIGVuZEJsb2NrLmNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgICAgIC4uLmNoaWxkLFxuICAgICAgICAgICAgICAgIHRleHQ6IGNoaWxkLnRleHQuc2xpY2UoMCwgZW5kUG9pbnQub2Zmc2V0KVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kQmxvY2suY2hpbGRyZW4ucHVzaChjaGlsZCksIGVuZENoaWxkS2V5ICYmIGNoaWxkLl9rZXkgPT09IGVuZENoaWxkS2V5KVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZW5kQmxvY2sgPSBibG9jaztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBzdGFydEJsb2NrICYmIG1pZGRsZUJsb2Nrcy5wdXNoKHBhcnNlQmxvY2soe1xuICAgICAgY29udGV4dDoge1xuICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICBrZXlHZW5lcmF0b3I6IGRlZmF1bHRLZXlHZW5lcmF0b3JcbiAgICAgIH0sXG4gICAgICBibG9jayxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcmVtb3ZlVW51c2VkTWFya0RlZnM6ICEwLFxuICAgICAgICB2YWxpZGF0ZUZpZWxkczogITFcbiAgICAgIH1cbiAgICB9KSA/PyBibG9jayk7XG4gIH1cbiAgY29uc3QgcGFyc2VkU3RhcnRCbG9jayA9IHN0YXJ0QmxvY2sgPyBwYXJzZUJsb2NrKHtcbiAgICBjb250ZXh0OiB7XG4gICAgICAuLi5jb250ZXh0LFxuICAgICAga2V5R2VuZXJhdG9yOiBkZWZhdWx0S2V5R2VuZXJhdG9yXG4gICAgfSxcbiAgICBibG9jazogc3RhcnRCbG9jayxcbiAgICBvcHRpb25zOiB7XG4gICAgICByZW1vdmVVbnVzZWRNYXJrRGVmczogITAsXG4gICAgICB2YWxpZGF0ZUZpZWxkczogITFcbiAgICB9XG4gIH0pIDogdm9pZCAwLCBwYXJzZWRFbmRCbG9jayA9IGVuZEJsb2NrID8gcGFyc2VCbG9jayh7XG4gICAgY29udGV4dDoge1xuICAgICAgLi4uY29udGV4dCxcbiAgICAgIGtleUdlbmVyYXRvcjogZGVmYXVsdEtleUdlbmVyYXRvclxuICAgIH0sXG4gICAgYmxvY2s6IGVuZEJsb2NrLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHJlbW92ZVVudXNlZE1hcmtEZWZzOiAhMCxcbiAgICAgIHZhbGlkYXRlRmllbGRzOiAhMVxuICAgIH1cbiAgfSkgOiB2b2lkIDA7XG4gIHJldHVybiBbLi4ucGFyc2VkU3RhcnRCbG9jayA/IFtwYXJzZWRTdGFydEJsb2NrXSA6IFtdLCAuLi5taWRkbGVCbG9ja3MsIC4uLnBhcnNlZEVuZEJsb2NrID8gW3BhcnNlZEVuZEJsb2NrXSA6IFtdXTtcbn1cbmZ1bmN0aW9uIGdldFRleHRCbG9ja1RleHQoYmxvY2spIHtcbiAgcmV0dXJuIGJsb2NrLmNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IGNoaWxkLnRleHQgPz8gXCJcIikuam9pbihcIlwiKTtcbn1cbmV4cG9ydCB7XG4gIGJsb2NrT2Zmc2V0VG9TcGFuU2VsZWN0aW9uUG9pbnQsXG4gIGRlZmF1bHRLZXlHZW5lcmF0b3IsXG4gIGdldEJsb2NrS2V5RnJvbVNlbGVjdGlvblBvaW50LFxuICBnZXRCbG9ja1N0YXJ0UG9pbnQsXG4gIGdldENoaWxkS2V5RnJvbVNlbGVjdGlvblBvaW50LFxuICBnZXRTZWxlY3Rpb25FbmRQb2ludCxcbiAgZ2V0U2VsZWN0aW9uU3RhcnRQb2ludCxcbiAgZ2V0VGV4dEJsb2NrVGV4dCxcbiAgaXNLZXllZFNlZ21lbnQsXG4gIGlzTGlzdEJsb2NrLFxuICBpc1R5cGVkT2JqZWN0LFxuICBwYXJzZUFubm90YXRpb24sXG4gIHBhcnNlQmxvY2ssXG4gIHBhcnNlQmxvY2tzLFxuICBwYXJzZUlubGluZU9iamVjdCxcbiAgcGFyc2VTcGFuLFxuICBzbGljZUJsb2NrcyxcbiAgc3BhblNlbGVjdGlvblBvaW50VG9CbG9ja09mZnNldFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuZ2V0LXRleHQtYmxvY2stdGV4dC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/util.get-text-block-text.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/util.is-empty-text-block.js":
/*!***************************************************************************************!*\
  !*** ../node_modules/@portabletext/editor/lib/_chunks-es/util.is-empty-text-block.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBlockEndPoint: () => (/* binding */ getBlockEndPoint),\n/* harmony export */   isEmptyTextBlock: () => (/* binding */ isEmptyTextBlock),\n/* harmony export */   isEqualSelectionPoints: () => (/* binding */ isEqualSelectionPoints),\n/* harmony export */   isSelectionCollapsed: () => (/* binding */ isSelectionCollapsed)\n/* harmony export */ });\n/* harmony import */ var _portabletext_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @portabletext/schema */ \"(ssr)/../node_modules/@portabletext/schema/dist/index.js\");\n/* harmony import */ var _util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.get-text-block-text.js */ \"(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/util.get-text-block-text.js\");\n\n\nfunction getBlockEndPoint({\n  context,\n  block\n}) {\n  if ((0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_0__.isTextBlock)(context, block.node)) {\n    const lastChild = block.node.children[block.node.children.length - 1];\n    if (lastChild)\n      return {\n        path: [...block.path, \"children\", {\n          _key: lastChild._key\n        }],\n        offset: (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_0__.isSpan)(context, lastChild) ? lastChild.text.length : 0\n      };\n  }\n  return {\n    path: block.path,\n    offset: 0\n  };\n}\nfunction isSelectionCollapsed(selection) {\n  return selection ? JSON.stringify(selection.anchor.path) === JSON.stringify(selection.focus.path) && selection.anchor.offset === selection.focus.offset : !1;\n}\nfunction isEqualSelectionPoints(a, b) {\n  return a.offset === b.offset && JSON.stringify(a.path) === JSON.stringify(b.path);\n}\nfunction isEmptyTextBlock(context, block) {\n  if (!(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_0__.isTextBlock)(context, block))\n    return !1;\n  const onlyText = block.children.every((child) => (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_0__.isSpan)(context, child)), blockText = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_1__.getTextBlockText)(block);\n  return onlyText && blockText === \"\";\n}\n\n//# sourceMappingURL=util.is-empty-text-block.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9fY2h1bmtzLWVzL3V0aWwuaXMtZW1wdHktdGV4dC1ibG9jay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMkQ7QUFDTTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTUFBTSxpRUFBVztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGdCQUFnQiw0REFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxpRUFBVztBQUNsQjtBQUNBLG1EQUFtRCw0REFBTSwrQkFBK0IsOEVBQWdCO0FBQ3hHO0FBQ0E7QUFNRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvR2Fsb2NrL0NTL2JlaG9tZS1zaXRlL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L2VkaXRvci9saWIvX2NodW5rcy1lcy91dGlsLmlzLWVtcHR5LXRleHQtYmxvY2suanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNUZXh0QmxvY2ssIGlzU3BhbiB9IGZyb20gXCJAcG9ydGFibGV0ZXh0L3NjaGVtYVwiO1xuaW1wb3J0IHsgZ2V0VGV4dEJsb2NrVGV4dCB9IGZyb20gXCIuL3V0aWwuZ2V0LXRleHQtYmxvY2stdGV4dC5qc1wiO1xuZnVuY3Rpb24gZ2V0QmxvY2tFbmRQb2ludCh7XG4gIGNvbnRleHQsXG4gIGJsb2NrXG59KSB7XG4gIGlmIChpc1RleHRCbG9jayhjb250ZXh0LCBibG9jay5ub2RlKSkge1xuICAgIGNvbnN0IGxhc3RDaGlsZCA9IGJsb2NrLm5vZGUuY2hpbGRyZW5bYmxvY2subm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICBpZiAobGFzdENoaWxkKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDogWy4uLmJsb2NrLnBhdGgsIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgIF9rZXk6IGxhc3RDaGlsZC5fa2V5XG4gICAgICAgIH1dLFxuICAgICAgICBvZmZzZXQ6IGlzU3Bhbihjb250ZXh0LCBsYXN0Q2hpbGQpID8gbGFzdENoaWxkLnRleHQubGVuZ3RoIDogMFxuICAgICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHBhdGg6IGJsb2NrLnBhdGgsXG4gICAgb2Zmc2V0OiAwXG4gIH07XG59XG5mdW5jdGlvbiBpc1NlbGVjdGlvbkNvbGxhcHNlZChzZWxlY3Rpb24pIHtcbiAgcmV0dXJuIHNlbGVjdGlvbiA/IEpTT04uc3RyaW5naWZ5KHNlbGVjdGlvbi5hbmNob3IucGF0aCkgPT09IEpTT04uc3RyaW5naWZ5KHNlbGVjdGlvbi5mb2N1cy5wYXRoKSAmJiBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldCA9PT0gc2VsZWN0aW9uLmZvY3VzLm9mZnNldCA6ICExO1xufVxuZnVuY3Rpb24gaXNFcXVhbFNlbGVjdGlvblBvaW50cyhhLCBiKSB7XG4gIHJldHVybiBhLm9mZnNldCA9PT0gYi5vZmZzZXQgJiYgSlNPTi5zdHJpbmdpZnkoYS5wYXRoKSA9PT0gSlNPTi5zdHJpbmdpZnkoYi5wYXRoKTtcbn1cbmZ1bmN0aW9uIGlzRW1wdHlUZXh0QmxvY2soY29udGV4dCwgYmxvY2spIHtcbiAgaWYgKCFpc1RleHRCbG9jayhjb250ZXh0LCBibG9jaykpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBvbmx5VGV4dCA9IGJsb2NrLmNoaWxkcmVuLmV2ZXJ5KChjaGlsZCkgPT4gaXNTcGFuKGNvbnRleHQsIGNoaWxkKSksIGJsb2NrVGV4dCA9IGdldFRleHRCbG9ja1RleHQoYmxvY2spO1xuICByZXR1cm4gb25seVRleHQgJiYgYmxvY2tUZXh0ID09PSBcIlwiO1xufVxuZXhwb3J0IHtcbiAgZ2V0QmxvY2tFbmRQb2ludCxcbiAgaXNFbXB0eVRleHRCbG9jayxcbiAgaXNFcXVhbFNlbGVjdGlvblBvaW50cyxcbiAgaXNTZWxlY3Rpb25Db2xsYXBzZWRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmlzLWVtcHR5LXRleHQtYmxvY2suanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/util.is-empty-text-block.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/util.merge-text-blocks.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/@portabletext/editor/lib/_chunks-es/util.merge-text-blocks.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mergeTextBlocks: () => (/* binding */ mergeTextBlocks)\n/* harmony export */ });\n/* harmony import */ var _portabletext_schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @portabletext/schema */ \"(ssr)/../node_modules/@portabletext/schema/dist/index.js\");\n/* harmony import */ var _util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.get-text-block-text.js */ \"(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/util.get-text-block-text.js\");\n\n\nfunction mergeTextBlocks({\n  context,\n  targetBlock,\n  incomingBlock\n}) {\n  const parsedIncomingBlock = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_0__.parseBlock)({\n    context,\n    block: incomingBlock,\n    options: {\n      removeUnusedMarkDefs: !0,\n      validateFields: !1\n    }\n  });\n  return !parsedIncomingBlock || !(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_1__.isTextBlock)(context, parsedIncomingBlock) ? targetBlock : {\n    ...targetBlock,\n    children: [...targetBlock.children, ...parsedIncomingBlock.children],\n    markDefs: [...targetBlock.markDefs ?? [], ...parsedIncomingBlock.markDefs ?? []]\n  };\n}\n\n//# sourceMappingURL=util.merge-text-blocks.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9fY2h1bmtzLWVzL3V0aWwubWVyZ2UtdGV4dC1ibG9ja3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW1EO0FBQ1E7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOEJBQThCLHdFQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxrQ0FBa0MsaUVBQVc7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9HYWxvY2svQ1MvYmVob21lLXNpdGUvbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9fY2h1bmtzLWVzL3V0aWwubWVyZ2UtdGV4dC1ibG9ja3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNUZXh0QmxvY2sgfSBmcm9tIFwiQHBvcnRhYmxldGV4dC9zY2hlbWFcIjtcbmltcG9ydCB7IHBhcnNlQmxvY2sgfSBmcm9tIFwiLi91dGlsLmdldC10ZXh0LWJsb2NrLXRleHQuanNcIjtcbmZ1bmN0aW9uIG1lcmdlVGV4dEJsb2Nrcyh7XG4gIGNvbnRleHQsXG4gIHRhcmdldEJsb2NrLFxuICBpbmNvbWluZ0Jsb2NrXG59KSB7XG4gIGNvbnN0IHBhcnNlZEluY29taW5nQmxvY2sgPSBwYXJzZUJsb2NrKHtcbiAgICBjb250ZXh0LFxuICAgIGJsb2NrOiBpbmNvbWluZ0Jsb2NrLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHJlbW92ZVVudXNlZE1hcmtEZWZzOiAhMCxcbiAgICAgIHZhbGlkYXRlRmllbGRzOiAhMVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiAhcGFyc2VkSW5jb21pbmdCbG9jayB8fCAhaXNUZXh0QmxvY2soY29udGV4dCwgcGFyc2VkSW5jb21pbmdCbG9jaykgPyB0YXJnZXRCbG9jayA6IHtcbiAgICAuLi50YXJnZXRCbG9jayxcbiAgICBjaGlsZHJlbjogWy4uLnRhcmdldEJsb2NrLmNoaWxkcmVuLCAuLi5wYXJzZWRJbmNvbWluZ0Jsb2NrLmNoaWxkcmVuXSxcbiAgICBtYXJrRGVmczogWy4uLnRhcmdldEJsb2NrLm1hcmtEZWZzID8/IFtdLCAuLi5wYXJzZWRJbmNvbWluZ0Jsb2NrLm1hcmtEZWZzID8/IFtdXVxuICB9O1xufVxuZXhwb3J0IHtcbiAgbWVyZ2VUZXh0QmxvY2tzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5tZXJnZS10ZXh0LWJsb2Nrcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/util.merge-text-blocks.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/util.slice-text-block.js":
/*!************************************************************************************!*\
  !*** ../node_modules/@portabletext/editor/lib/_chunks-es/util.slice-text-block.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   selectionPointToBlockOffset: () => (/* binding */ selectionPointToBlockOffset),\n/* harmony export */   sliceTextBlock: () => (/* binding */ sliceTextBlock)\n/* harmony export */ });\n/* harmony import */ var _util_child_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.child-selection-point-to-block-offset.js */ \"(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/util.child-selection-point-to-block-offset.js\");\n/* harmony import */ var _util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.get-text-block-text.js */ \"(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/util.get-text-block-text.js\");\n/* harmony import */ var _portabletext_schema__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @portabletext/schema */ \"(ssr)/../node_modules/@portabletext/schema/dist/index.js\");\n\n\n\nfunction selectionPointToBlockOffset({\n  context,\n  selectionPoint\n}) {\n  const blockKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_0__.getBlockKeyFromSelectionPoint)(selectionPoint);\n  return selectionPoint.path.length === 1 && blockKey !== void 0 ? {\n    path: [{\n      _key: blockKey\n    }],\n    offset: selectionPoint.offset\n  } : (0,_util_child_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_1__.childSelectionPointToBlockOffset)({\n    context,\n    selectionPoint\n  });\n}\nfunction sliceTextBlock({\n  context,\n  block\n}) {\n  const startPoint = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_0__.getSelectionStartPoint)(context.selection), endPoint = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_0__.getSelectionEndPoint)(context.selection);\n  if (!startPoint || !endPoint)\n    return block;\n  const startBlockKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_0__.getBlockKeyFromSelectionPoint)(startPoint), endBlockKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_0__.getBlockKeyFromSelectionPoint)(endPoint);\n  if (startBlockKey !== endBlockKey || startBlockKey !== block._key)\n    return block;\n  const startChildKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_0__.getChildKeyFromSelectionPoint)(startPoint), endChildKey = (0,_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_0__.getChildKeyFromSelectionPoint)(endPoint);\n  if (!startChildKey || !endChildKey)\n    return block;\n  let startChildFound = !1;\n  const children = [];\n  for (const child of block.children) {\n    if (child._key === startChildKey) {\n      if (startChildFound = !0, (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_2__.isSpan)(context, child)) {\n        const text = child._key === endChildKey ? child.text.slice(startPoint.offset, endPoint.offset) : child.text.slice(startPoint.offset);\n        children.push({\n          ...child,\n          text\n        });\n      } else\n        children.push(child);\n      if (startChildKey === endChildKey)\n        break;\n      continue;\n    }\n    if (child._key === endChildKey) {\n      (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_2__.isSpan)(context, child) ? children.push({\n        ...child,\n        text: child.text.slice(0, endPoint.offset)\n      }) : children.push(child);\n      break;\n    }\n    startChildFound && children.push(child);\n  }\n  return {\n    ...block,\n    children\n  };\n}\n\n//# sourceMappingURL=util.slice-text-block.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9fY2h1bmtzLWVzL3V0aWwuc2xpY2UtdGV4dC1ibG9jay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFtRztBQUN3RDtBQUM3RztBQUM5QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CLDJGQUE2QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJLEVBQUUsZ0hBQWdDO0FBQ3RDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QscUJBQXFCLG9GQUFzQixnQ0FBZ0Msa0ZBQW9CO0FBQy9GO0FBQ0E7QUFDQSx3QkFBd0IsMkZBQTZCLDRCQUE0QiwyRkFBNkI7QUFDOUc7QUFDQTtBQUNBLHdCQUF3QiwyRkFBNkIsNEJBQTRCLDJGQUE2QjtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNERBQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNERBQU07QUFDWjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9HYWxvY2svQ1MvYmVob21lLXNpdGUvbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9fY2h1bmtzLWVzL3V0aWwuc2xpY2UtdGV4dC1ibG9jay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjaGlsZFNlbGVjdGlvblBvaW50VG9CbG9ja09mZnNldCB9IGZyb20gXCIuL3V0aWwuY2hpbGQtc2VsZWN0aW9uLXBvaW50LXRvLWJsb2NrLW9mZnNldC5qc1wiO1xuaW1wb3J0IHsgZ2V0QmxvY2tLZXlGcm9tU2VsZWN0aW9uUG9pbnQsIGdldFNlbGVjdGlvblN0YXJ0UG9pbnQsIGdldFNlbGVjdGlvbkVuZFBvaW50LCBnZXRDaGlsZEtleUZyb21TZWxlY3Rpb25Qb2ludCB9IGZyb20gXCIuL3V0aWwuZ2V0LXRleHQtYmxvY2stdGV4dC5qc1wiO1xuaW1wb3J0IHsgaXNTcGFuIH0gZnJvbSBcIkBwb3J0YWJsZXRleHQvc2NoZW1hXCI7XG5mdW5jdGlvbiBzZWxlY3Rpb25Qb2ludFRvQmxvY2tPZmZzZXQoe1xuICBjb250ZXh0LFxuICBzZWxlY3Rpb25Qb2ludFxufSkge1xuICBjb25zdCBibG9ja0tleSA9IGdldEJsb2NrS2V5RnJvbVNlbGVjdGlvblBvaW50KHNlbGVjdGlvblBvaW50KTtcbiAgcmV0dXJuIHNlbGVjdGlvblBvaW50LnBhdGgubGVuZ3RoID09PSAxICYmIGJsb2NrS2V5ICE9PSB2b2lkIDAgPyB7XG4gICAgcGF0aDogW3tcbiAgICAgIF9rZXk6IGJsb2NrS2V5XG4gICAgfV0sXG4gICAgb2Zmc2V0OiBzZWxlY3Rpb25Qb2ludC5vZmZzZXRcbiAgfSA6IGNoaWxkU2VsZWN0aW9uUG9pbnRUb0Jsb2NrT2Zmc2V0KHtcbiAgICBjb250ZXh0LFxuICAgIHNlbGVjdGlvblBvaW50XG4gIH0pO1xufVxuZnVuY3Rpb24gc2xpY2VUZXh0QmxvY2soe1xuICBjb250ZXh0LFxuICBibG9ja1xufSkge1xuICBjb25zdCBzdGFydFBvaW50ID0gZ2V0U2VsZWN0aW9uU3RhcnRQb2ludChjb250ZXh0LnNlbGVjdGlvbiksIGVuZFBvaW50ID0gZ2V0U2VsZWN0aW9uRW5kUG9pbnQoY29udGV4dC5zZWxlY3Rpb24pO1xuICBpZiAoIXN0YXJ0UG9pbnQgfHwgIWVuZFBvaW50KVxuICAgIHJldHVybiBibG9jaztcbiAgY29uc3Qgc3RhcnRCbG9ja0tleSA9IGdldEJsb2NrS2V5RnJvbVNlbGVjdGlvblBvaW50KHN0YXJ0UG9pbnQpLCBlbmRCbG9ja0tleSA9IGdldEJsb2NrS2V5RnJvbVNlbGVjdGlvblBvaW50KGVuZFBvaW50KTtcbiAgaWYgKHN0YXJ0QmxvY2tLZXkgIT09IGVuZEJsb2NrS2V5IHx8IHN0YXJ0QmxvY2tLZXkgIT09IGJsb2NrLl9rZXkpXG4gICAgcmV0dXJuIGJsb2NrO1xuICBjb25zdCBzdGFydENoaWxkS2V5ID0gZ2V0Q2hpbGRLZXlGcm9tU2VsZWN0aW9uUG9pbnQoc3RhcnRQb2ludCksIGVuZENoaWxkS2V5ID0gZ2V0Q2hpbGRLZXlGcm9tU2VsZWN0aW9uUG9pbnQoZW5kUG9pbnQpO1xuICBpZiAoIXN0YXJ0Q2hpbGRLZXkgfHwgIWVuZENoaWxkS2V5KVxuICAgIHJldHVybiBibG9jaztcbiAgbGV0IHN0YXJ0Q2hpbGRGb3VuZCA9ICExO1xuICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIGJsb2NrLmNoaWxkcmVuKSB7XG4gICAgaWYgKGNoaWxkLl9rZXkgPT09IHN0YXJ0Q2hpbGRLZXkpIHtcbiAgICAgIGlmIChzdGFydENoaWxkRm91bmQgPSAhMCwgaXNTcGFuKGNvbnRleHQsIGNoaWxkKSkge1xuICAgICAgICBjb25zdCB0ZXh0ID0gY2hpbGQuX2tleSA9PT0gZW5kQ2hpbGRLZXkgPyBjaGlsZC50ZXh0LnNsaWNlKHN0YXJ0UG9pbnQub2Zmc2V0LCBlbmRQb2ludC5vZmZzZXQpIDogY2hpbGQudGV4dC5zbGljZShzdGFydFBvaW50Lm9mZnNldCk7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgIC4uLmNoaWxkLFxuICAgICAgICAgIHRleHRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICBpZiAoc3RhcnRDaGlsZEtleSA9PT0gZW5kQ2hpbGRLZXkpXG4gICAgICAgIGJyZWFrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjaGlsZC5fa2V5ID09PSBlbmRDaGlsZEtleSkge1xuICAgICAgaXNTcGFuKGNvbnRleHQsIGNoaWxkKSA/IGNoaWxkcmVuLnB1c2goe1xuICAgICAgICAuLi5jaGlsZCxcbiAgICAgICAgdGV4dDogY2hpbGQudGV4dC5zbGljZSgwLCBlbmRQb2ludC5vZmZzZXQpXG4gICAgICB9KSA6IGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHN0YXJ0Q2hpbGRGb3VuZCAmJiBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLmJsb2NrLFxuICAgIGNoaWxkcmVuXG4gIH07XG59XG5leHBvcnQge1xuICBzZWxlY3Rpb25Qb2ludFRvQmxvY2tPZmZzZXQsXG4gIHNsaWNlVGV4dEJsb2NrXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5zbGljZS10ZXh0LWJsb2NrLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/util.slice-text-block.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@portabletext/editor/lib/behaviors/index.js":
/*!*******************************************************************!*\
  !*** ../node_modules/@portabletext/editor/lib/behaviors/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defineBehavior: () => (/* binding */ defineBehavior),\n/* harmony export */   effect: () => (/* binding */ effect),\n/* harmony export */   execute: () => (/* binding */ execute),\n/* harmony export */   forward: () => (/* binding */ forward),\n/* harmony export */   raise: () => (/* binding */ raise)\n/* harmony export */ });\nfunction execute(event) {\n  return {\n    type: \"execute\",\n    event\n  };\n}\nfunction forward(event) {\n  return {\n    type: \"forward\",\n    event\n  };\n}\nfunction raise(event) {\n  return {\n    type: \"raise\",\n    event\n  };\n}\nfunction effect(effect2) {\n  return {\n    type: \"effect\",\n    effect: effect2\n  };\n}\nfunction defineBehavior(behavior) {\n  return behavior;\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9iZWhhdmlvcnMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvR2Fsb2NrL0NTL2JlaG9tZS1zaXRlL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L2VkaXRvci9saWIvYmVoYXZpb3JzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGV4ZWN1dGUoZXZlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImV4ZWN1dGVcIixcbiAgICBldmVudFxuICB9O1xufVxuZnVuY3Rpb24gZm9yd2FyZChldmVudCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZm9yd2FyZFwiLFxuICAgIGV2ZW50XG4gIH07XG59XG5mdW5jdGlvbiByYWlzZShldmVudCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwicmFpc2VcIixcbiAgICBldmVudFxuICB9O1xufVxuZnVuY3Rpb24gZWZmZWN0KGVmZmVjdDIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVmZmVjdFwiLFxuICAgIGVmZmVjdDogZWZmZWN0MlxuICB9O1xufVxuZnVuY3Rpb24gZGVmaW5lQmVoYXZpb3IoYmVoYXZpb3IpIHtcbiAgcmV0dXJuIGJlaGF2aW9yO1xufVxuZXhwb3J0IHtcbiAgZGVmaW5lQmVoYXZpb3IsXG4gIGVmZmVjdCxcbiAgZXhlY3V0ZSxcbiAgZm9yd2FyZCxcbiAgcmFpc2Vcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@portabletext/editor/lib/behaviors/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@portabletext/editor/lib/index.js":
/*!*********************************************************!*\
  !*** ../node_modules/@portabletext/editor/lib/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EditorEventListener: () => (/* binding */ EditorEventListener),\n/* harmony export */   EditorProvider: () => (/* binding */ EditorProvider),\n/* harmony export */   PortableTextEditable: () => (/* binding */ PortableTextEditable),\n/* harmony export */   PortableTextEditor: () => (/* binding */ PortableTextEditor),\n/* harmony export */   defineSchema: () => (/* reexport safe */ _portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.defineSchema),\n/* harmony export */   keyGenerator: () => (/* reexport safe */ _chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.defaultKeyGenerator),\n/* harmony export */   useEditor: () => (/* reexport safe */ _chunks_es_use_editor_js__WEBPACK_IMPORTED_MODULE_13__.useEditor),\n/* harmony export */   useEditorSelector: () => (/* binding */ useEditorSelector),\n/* harmony export */   usePortableTextEditor: () => (/* binding */ usePortableTextEditor),\n/* harmony export */   usePortableTextEditorSelection: () => (/* binding */ usePortableTextEditorSelection)\n/* harmony export */ });\n/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-compiler-runtime */ \"(ssr)/../node_modules/react-compiler-runtime/dist/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/../node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _chunks_es_use_editor_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./_chunks-es/use-editor.js */ \"(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/use-editor.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/../node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _xstate_react__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @xstate/react */ \"(ssr)/../node_modules/@xstate/react/dist/xstate-react.development.esm.js\");\n/* harmony import */ var lodash_noop_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/noop.js */ \"(ssr)/../node_modules/lodash/noop.js\");\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! slate */ \"(ssr)/../node_modules/slate/dist/index.es.js\");\n/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! slate-react */ \"(ssr)/../node_modules/@portabletext/editor/node_modules/slate-react/dist/index.es.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! debug */ \"(ssr)/../node_modules/debug/src/index.js\");\n/* harmony import */ var slate_dom__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! slate-dom */ \"(ssr)/../node_modules/slate-dom/dist/index.es.js\");\n/* harmony import */ var _chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./_chunks-es/util.is-empty-text-block.js */ \"(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/util.is-empty-text-block.js\");\n/* harmony import */ var _chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./_chunks-es/util.get-text-block-text.js */ \"(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/util.get-text-block-text.js\");\n/* harmony import */ var lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/isEqual.js */ \"(ssr)/../node_modules/lodash/isEqual.js\");\n/* harmony import */ var _portabletext_schema__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @portabletext/schema */ \"(ssr)/../node_modules/@portabletext/schema/dist/index.js\");\n/* harmony import */ var _chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./_chunks-es/selector.is-active-style.js */ \"(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/selector.is-active-style.js\");\n/* harmony import */ var _chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./_chunks-es/selector.get-selection-text.js */ \"(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/selector.get-selection-text.js\");\n/* harmony import */ var _behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./behaviors/index.js */ \"(ssr)/../node_modules/@portabletext/editor/lib/behaviors/index.js\");\n/* harmony import */ var lodash_uniq_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash/uniq.js */ \"(ssr)/../node_modules/lodash/uniq.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! xstate */ \"(ssr)/../node_modules/xstate/dist/xstate.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! xstate */ \"(ssr)/../node_modules/xstate/dist/assign-fb4707fe.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! xstate */ \"(ssr)/../node_modules/xstate/actors/dist/xstate-actors.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! xstate */ \"(ssr)/../node_modules/xstate/dist/raise-f7b216be.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! xstate */ \"(ssr)/../node_modules/xstate/dist/log-368dd776.development.esm.js\");\n/* harmony import */ var _portabletext_sanity_bridge__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! @portabletext/sanity-bridge */ \"(ssr)/../node_modules/@portabletext/sanity-bridge/dist/index.js\");\n/* harmony import */ var _portabletext_block_tools__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! @portabletext/block-tools */ \"(ssr)/../node_modules/@portabletext/block-tools/lib/index.js\");\n/* harmony import */ var _portabletext_to_html__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! @portabletext/to-html */ \"(ssr)/../node_modules/@portabletext/to-html/dist/pt-to-html.mjs\");\n/* harmony import */ var _sanity_schema__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! @sanity/schema */ \"(ssr)/../node_modules/@sanity/schema/lib/index.mjs\");\n/* harmony import */ var lodash_flatten_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash/flatten.js */ \"(ssr)/../node_modules/lodash/flatten.js\");\n/* harmony import */ var lodash_omit_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash/omit.js */ \"(ssr)/../node_modules/lodash/omit.js\");\n/* harmony import */ var _portabletext_patches__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! @portabletext/patches */ \"(ssr)/../node_modules/@portabletext/patches/dist/index.js\");\n/* harmony import */ var _chunks_es_util_child_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./_chunks-es/util.child-selection-point-to-block-offset.js */ \"(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/util.child-selection-point-to-block-offset.js\");\n/* harmony import */ var _chunks_es_util_slice_text_block_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./_chunks-es/util.slice-text-block.js */ \"(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/util.slice-text-block.js\");\n/* harmony import */ var lodash_get_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash/get.js */ \"(ssr)/../node_modules/lodash/get.js\");\n/* harmony import */ var lodash_isUndefined_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash/isUndefined.js */ \"(ssr)/../node_modules/lodash/isUndefined.js\");\n/* harmony import */ var lodash_omitBy_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lodash/omitBy.js */ \"(ssr)/../node_modules/lodash/omitBy.js\");\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! immer */ \"(ssr)/../node_modules/immer/dist/immer.mjs\");\n/* harmony import */ var _portabletext_keyboard_shortcuts__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! @portabletext/keyboard-shortcuts */ \"(ssr)/../node_modules/@portabletext/keyboard-shortcuts/dist/index.js\");\n/* harmony import */ var lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lodash/isPlainObject.js */ \"(ssr)/../node_modules/lodash/isPlainObject.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! rxjs */ \"(ssr)/../node_modules/rxjs/dist/cjs/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction EditorEventListener(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(4), editor = (0,_chunks_es_use_editor_js__WEBPACK_IMPORTED_MODULE_13__.useEditor)();\n  let t0, t1;\n  return $[0] !== editor || $[1] !== props.on ? (t0 = () => {\n    const subscription = editor.on(\"*\", props.on);\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, t1 = [editor, props.on], $[0] = editor, $[1] = props.on, $[2] = t0, $[3] = t1) : (t0 = $[2], t1 = $[3]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(t0, t1), null;\n}\nconst rootName = \"sanity-pte:\";\ndebug__WEBPACK_IMPORTED_MODULE_4__(rootName);\nfunction debugWithName(name) {\n  const namespace = `${rootName}${name}`;\n  return debug__WEBPACK_IMPORTED_MODULE_4__ && debug__WEBPACK_IMPORTED_MODULE_4__.enabled(namespace) ? debug__WEBPACK_IMPORTED_MODULE_4__(namespace) : debug__WEBPACK_IMPORTED_MODULE_4__(rootName);\n}\nconst VOID_CHILD_KEY = \"void-child\";\nfunction keepObjectEquality(object, keyMap) {\n  const value = keyMap[object._key];\n  return value && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__(object, value) ? value : (keyMap[object._key] = object, object);\n}\nfunction toSlateValue(value, {\n  schemaTypes\n}, keyMap = {}) {\n  return value && Array.isArray(value) ? value.map((block) => {\n    const {\n      _type,\n      _key,\n      ...rest\n    } = block;\n    if (block && block._type === schemaTypes.block.name) {\n      const textBlock = block;\n      let hasInlines = !1;\n      const hasMissingStyle = typeof textBlock.style > \"u\", hasMissingMarkDefs = typeof textBlock.markDefs > \"u\", hasMissingChildren = typeof textBlock.children > \"u\", children = (textBlock.children || []).map((child) => {\n        const {\n          _type: cType,\n          _key: cKey,\n          ...cRest\n        } = child;\n        return cType !== \"span\" ? (hasInlines = !0, keepObjectEquality({\n          _type: cType,\n          _key: cKey,\n          children: [{\n            _key: VOID_CHILD_KEY,\n            _type: \"span\",\n            text: \"\",\n            marks: []\n          }],\n          value: cRest,\n          __inline: !0\n        }, keyMap)) : child;\n      });\n      return !hasMissingStyle && !hasMissingMarkDefs && !hasMissingChildren && !hasInlines && slate__WEBPACK_IMPORTED_MODULE_14__.Element.isElement(block) ? block : (hasMissingStyle && (rest.style = schemaTypes.styles[0].name), keepObjectEquality({\n        _type,\n        _key,\n        ...rest,\n        children\n      }, keyMap));\n    }\n    return keepObjectEquality({\n      _type,\n      _key,\n      children: [{\n        _key: VOID_CHILD_KEY,\n        _type: \"span\",\n        text: \"\",\n        marks: []\n      }],\n      value: rest\n    }, keyMap);\n  }) : [];\n}\nfunction fromSlateValue(value, textBlockType, keyMap = {}) {\n  return value.map((block) => {\n    const {\n      _key,\n      _type\n    } = block;\n    if (!_key || !_type)\n      throw new Error(\"Not a valid block\");\n    if (_type === textBlockType && \"children\" in block && Array.isArray(block.children) && _key) {\n      let hasInlines = !1;\n      const children = block.children.map((child) => {\n        const {\n          _type: _cType\n        } = child;\n        if (\"value\" in child && _cType !== \"span\") {\n          hasInlines = !0;\n          const {\n            value: v,\n            _key: k,\n            _type: t,\n            __inline: _i,\n            children: _c,\n            ...rest\n          } = child;\n          return keepObjectEquality({\n            ...rest,\n            ...v,\n            _key: k,\n            _type: t\n          }, keyMap);\n        }\n        return child;\n      });\n      return hasInlines ? keepObjectEquality({\n        ...block,\n        children,\n        _key,\n        _type\n      }, keyMap) : block;\n    }\n    const blockValue = \"value\" in block && block.value;\n    return keepObjectEquality({\n      _key,\n      _type,\n      ...typeof blockValue == \"object\" ? blockValue : {}\n    }, keyMap);\n  });\n}\nfunction isEqualToEmptyEditor(children, schemaTypes) {\n  return children === void 0 || children && Array.isArray(children) && children.length === 0 || children && Array.isArray(children) && children.length === 1 && slate__WEBPACK_IMPORTED_MODULE_14__.Element.isElement(children[0]) && children[0]._type === schemaTypes.block.name && \"style\" in children[0] && children[0].style === schemaTypes.styles[0].name && !(\"listItem\" in children[0]) && Array.isArray(children[0].children) && children[0].children.length === 1 && slate__WEBPACK_IMPORTED_MODULE_14__.Text.isText(children[0].children[0]) && children[0].children[0]._type === \"span\" && !children[0].children[0].marks?.join(\"\") && children[0].children[0].text === \"\";\n}\nfunction getFocusBlock({\n  editor\n}) {\n  if (!editor.selection)\n    return [void 0, void 0];\n  try {\n    return slate__WEBPACK_IMPORTED_MODULE_14__.Editor.node(editor, editor.selection.focus.path.slice(0, 1)) ?? [void 0, void 0];\n  } catch {\n    return [void 0, void 0];\n  }\n}\nfunction getFocusSpan({\n  editor\n}) {\n  if (!editor.selection)\n    return [void 0, void 0];\n  try {\n    const [focusBlock] = getFocusBlock({\n      editor\n    });\n    if (!focusBlock)\n      return [void 0, void 0];\n    if (!editor.isTextBlock(focusBlock))\n      return [void 0, void 0];\n    const [node, path] = slate__WEBPACK_IMPORTED_MODULE_14__.Editor.node(editor, editor.selection.focus.path.slice(0, 2));\n    if (editor.isTextSpan(node))\n      return [node, path];\n  } catch {\n    return [void 0, void 0];\n  }\n  return [void 0, void 0];\n}\nfunction getSelectionStartBlock({\n  editor\n}) {\n  if (!editor.selection)\n    return [void 0, void 0];\n  const selectionStartPoint = slate__WEBPACK_IMPORTED_MODULE_14__.Range.start(editor.selection);\n  return getPointBlock({\n    editor,\n    point: selectionStartPoint\n  });\n}\nfunction getSelectionEndBlock({\n  editor\n}) {\n  if (!editor.selection)\n    return [void 0, void 0];\n  const selectionEndPoint = slate__WEBPACK_IMPORTED_MODULE_14__.Range.end(editor.selection);\n  return getPointBlock({\n    editor,\n    point: selectionEndPoint\n  });\n}\nfunction getPointBlock({\n  editor,\n  point\n}) {\n  try {\n    const [block] = slate__WEBPACK_IMPORTED_MODULE_14__.Editor.node(editor, point.path.slice(0, 1)) ?? [void 0, void 0];\n    return block ? [block, point.path.slice(0, 1)] : [void 0, void 0];\n  } catch {\n    return [void 0, void 0];\n  }\n}\nfunction getFocusChild({\n  editor\n}) {\n  const [focusBlock, focusBlockPath] = getFocusBlock({\n    editor\n  }), childIndex = editor.selection?.focus.path.at(1);\n  if (!focusBlock || !focusBlockPath || childIndex === void 0)\n    return [void 0, void 0];\n  try {\n    const focusChild = slate__WEBPACK_IMPORTED_MODULE_14__.Node.child(focusBlock, childIndex);\n    return focusChild ? [focusChild, [...focusBlockPath, childIndex]] : [void 0, void 0];\n  } catch {\n    return [void 0, void 0];\n  }\n}\nfunction getPointChild({\n  editor,\n  point\n}) {\n  const [block, blockPath] = getPointBlock({\n    editor,\n    point\n  }), childIndex = point.path.at(1);\n  if (!block || !blockPath || childIndex === void 0)\n    return [void 0, void 0];\n  try {\n    const pointChild = slate__WEBPACK_IMPORTED_MODULE_14__.Node.child(block, childIndex);\n    return pointChild ? [pointChild, [...blockPath, childIndex]] : [void 0, void 0];\n  } catch {\n    return [void 0, void 0];\n  }\n}\nfunction getFirstBlock({\n  editor\n}) {\n  if (editor.children.length === 0)\n    return [void 0, void 0];\n  const firstBlockPath = slate__WEBPACK_IMPORTED_MODULE_14__.Editor.start(editor, []).path.at(0);\n  try {\n    return firstBlockPath !== void 0 ? slate__WEBPACK_IMPORTED_MODULE_14__.Editor.node(editor, [firstBlockPath]) ?? [void 0, void 0] : [void 0, void 0];\n  } catch {\n    return [void 0, void 0];\n  }\n}\nfunction getLastBlock({\n  editor\n}) {\n  if (editor.children.length === 0)\n    return [void 0, void 0];\n  const lastBlockPath = slate__WEBPACK_IMPORTED_MODULE_14__.Editor.end(editor, []).path.at(0);\n  try {\n    return lastBlockPath !== void 0 ? slate__WEBPACK_IMPORTED_MODULE_14__.Editor.node(editor, [lastBlockPath]) ?? [void 0, void 0] : [void 0, void 0];\n  } catch {\n    return [void 0, void 0];\n  }\n}\nfunction getNodeBlock({\n  editor,\n  schema,\n  node\n}) {\n  if (slate__WEBPACK_IMPORTED_MODULE_14__.Editor.isEditor(node))\n    return;\n  if (isBlockElement({\n    editor,\n    schema\n  }, node))\n    return elementToBlock({\n      schema,\n      element: node\n    });\n  const parent = Array.from(slate__WEBPACK_IMPORTED_MODULE_14__.Editor.nodes(editor, {\n    mode: \"highest\",\n    at: [],\n    match: (n) => isBlockElement({\n      editor,\n      schema\n    }, n) && n.children.some((child) => child._key === node._key)\n  })).at(0)?.at(0);\n  return slate__WEBPACK_IMPORTED_MODULE_14__.Element.isElement(parent) ? elementToBlock({\n    schema,\n    element: parent\n  }) : void 0;\n}\nfunction elementToBlock({\n  schema,\n  element\n}) {\n  return fromSlateValue([element], schema.block.name)?.at(0);\n}\nfunction isBlockElement({\n  editor,\n  schema\n}, node) {\n  return slate__WEBPACK_IMPORTED_MODULE_14__.Element.isElement(node) && !editor.isInline(node) && (schema.block.name === node._type || schema.blockObjects.some((blockObject) => blockObject.name === node._type));\n}\nfunction isListItemActive({\n  editor,\n  listItem\n}) {\n  if (!editor.selection)\n    return !1;\n  const selectedBlocks = [...slate__WEBPACK_IMPORTED_MODULE_14__.Editor.nodes(editor, {\n    at: editor.selection,\n    match: (node) => editor.isTextBlock(node)\n  })];\n  return selectedBlocks.length > 0 ? selectedBlocks.every(([node]) => editor.isListBlock(node) && node.listItem === listItem) : !1;\n}\nfunction isStyleActive({\n  editor,\n  style\n}) {\n  if (!editor.selection)\n    return !1;\n  const selectedBlocks = [...slate__WEBPACK_IMPORTED_MODULE_14__.Editor.nodes(editor, {\n    at: editor.selection,\n    match: (node) => editor.isTextBlock(node)\n  })];\n  return selectedBlocks.length > 0 ? selectedBlocks.every(([node]) => node.style === style) : !1;\n}\nfunction slateRangeToSelection({\n  schema,\n  editor,\n  range\n}) {\n  const [anchorBlock] = getPointBlock({\n    editor,\n    point: range.anchor\n  }), [focusBlock] = getPointBlock({\n    editor,\n    point: range.focus\n  });\n  if (!anchorBlock || !focusBlock)\n    return null;\n  const [anchorChild] = anchorBlock._type === schema.block.name ? getPointChild({\n    editor,\n    point: range.anchor\n  }) : [void 0, void 0], [focusChild] = focusBlock._type === schema.block.name ? getPointChild({\n    editor,\n    point: range.focus\n  }) : [void 0, void 0], selection = {\n    anchor: {\n      path: [{\n        _key: anchorBlock._key\n      }],\n      offset: range.anchor.offset\n    },\n    focus: {\n      path: [{\n        _key: focusBlock._key\n      }],\n      offset: range.focus.offset\n    },\n    backward: slate__WEBPACK_IMPORTED_MODULE_14__.Range.isBackward(range)\n  };\n  return anchorChild && (selection.anchor.path.push(\"children\"), selection.anchor.path.push({\n    _key: anchorChild._key\n  })), focusChild && (selection.focus.path.push(\"children\"), selection.focus.path.push({\n    _key: focusChild._key\n  })), selection;\n}\nfunction getEventPosition({\n  editorActor,\n  slateEditor,\n  event\n}) {\n  if (editorActor.getSnapshot().matches({\n    setup: \"setting up\"\n  }))\n    return;\n  const eventNode = getEventNode({\n    slateEditor,\n    event\n  });\n  if (!eventNode)\n    return;\n  const eventBlock = getNodeBlock({\n    editor: slateEditor,\n    schema: editorActor.getSnapshot().context.schema,\n    node: eventNode\n  }), eventPositionBlock = getEventPositionBlock({\n    node: eventNode,\n    slateEditor,\n    event\n  }), eventSelection = getEventSelection({\n    schema: editorActor.getSnapshot().context.schema,\n    slateEditor,\n    event\n  });\n  if (eventBlock && eventPositionBlock && !eventSelection && !slate__WEBPACK_IMPORTED_MODULE_14__.Editor.isEditor(eventNode))\n    return {\n      block: eventPositionBlock,\n      isEditor: !1,\n      selection: {\n        anchor: (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.getBlockStartPoint)({\n          context: editorActor.getSnapshot().context,\n          block: {\n            node: eventBlock,\n            path: [{\n              _key: eventBlock._key\n            }]\n          }\n        }),\n        focus: (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.getBlockEndPoint)({\n          context: editorActor.getSnapshot().context,\n          block: {\n            node: eventBlock,\n            path: [{\n              _key: eventBlock._key\n            }]\n          }\n        })\n      }\n    };\n  if (!eventPositionBlock || !eventSelection)\n    return;\n  const eventSelectionFocusBlockKey = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.getBlockKeyFromSelectionPoint)(eventSelection.focus);\n  if (eventSelectionFocusBlockKey !== void 0)\n    return (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.isSelectionCollapsed)(eventSelection) && eventBlock && eventSelectionFocusBlockKey !== eventBlock._key ? {\n      block: eventPositionBlock,\n      isEditor: !1,\n      selection: {\n        anchor: (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.getBlockStartPoint)({\n          context: editorActor.getSnapshot().context,\n          block: {\n            node: eventBlock,\n            path: [{\n              _key: eventBlock._key\n            }]\n          }\n        }),\n        focus: (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.getBlockEndPoint)({\n          context: editorActor.getSnapshot().context,\n          block: {\n            node: eventBlock,\n            path: [{\n              _key: eventBlock._key\n            }]\n          }\n        })\n      }\n    } : {\n      block: eventPositionBlock,\n      isEditor: slate__WEBPACK_IMPORTED_MODULE_14__.Editor.isEditor(eventNode),\n      selection: eventSelection\n    };\n}\nfunction getEventNode({\n  slateEditor,\n  event\n}) {\n  return slate_dom__WEBPACK_IMPORTED_MODULE_17__.DOMEditor.hasTarget(slateEditor, event.target) ? slate_dom__WEBPACK_IMPORTED_MODULE_17__.DOMEditor.toSlateNode(slateEditor, event.target) : void 0;\n}\nfunction getEventPositionBlock({\n  node,\n  slateEditor,\n  event\n}) {\n  const [firstBlock] = getFirstBlock({\n    editor: slateEditor\n  });\n  if (!firstBlock)\n    return;\n  const firstBlockRect = slate_dom__WEBPACK_IMPORTED_MODULE_17__.DOMEditor.toDOMNode(slateEditor, firstBlock).getBoundingClientRect();\n  if (event.pageY < firstBlockRect.top)\n    return \"start\";\n  const [lastBlock] = getLastBlock({\n    editor: slateEditor\n  });\n  if (!lastBlock)\n    return;\n  const lastBlockRef = slate_dom__WEBPACK_IMPORTED_MODULE_17__.DOMEditor.toDOMNode(slateEditor, lastBlock).getBoundingClientRect();\n  if (event.pageY > lastBlockRef.bottom)\n    return \"end\";\n  const elementRect = slate_dom__WEBPACK_IMPORTED_MODULE_17__.DOMEditor.toDOMNode(slateEditor, node).getBoundingClientRect(), top = elementRect.top, height = elementRect.height;\n  return Math.abs(top - event.pageY) < height / 2 ? \"start\" : \"end\";\n}\nfunction getEventSelection({\n  schema,\n  slateEditor,\n  event\n}) {\n  const range = getSlateRangeFromEvent(slateEditor, event);\n  return range ? slateRangeToSelection({\n    schema,\n    editor: slateEditor,\n    range\n  }) : null;\n}\nfunction getSlateRangeFromEvent(editor, event) {\n  if (!event.target || !(0,slate_dom__WEBPACK_IMPORTED_MODULE_17__.isDOMNode)(event.target))\n    return;\n  const window2 = slate_dom__WEBPACK_IMPORTED_MODULE_17__.DOMEditor.getWindow(editor);\n  let domRange;\n  if (window2.document.caretPositionFromPoint !== void 0) {\n    const position = window2.document.caretPositionFromPoint(event.clientX, event.clientY);\n    if (position)\n      try {\n        domRange = window2.document.createRange(), domRange.setStart(position.offsetNode, position.offset), domRange.setEnd(position.offsetNode, position.offset);\n      } catch {\n      }\n  } else if (window2.document.caretRangeFromPoint !== void 0)\n    domRange = window2.document.caretRangeFromPoint(event.clientX, event.clientY) ?? void 0;\n  else {\n    console.warn(\"Neither caretPositionFromPoint nor caretRangeFromPoint is supported\");\n    return;\n  }\n  if (!domRange)\n    return;\n  let range;\n  try {\n    range = slate_dom__WEBPACK_IMPORTED_MODULE_17__.DOMEditor.toSlateRange(editor, domRange, {\n      exactMatch: !1,\n      // It can still throw even with this option set to true\n      suppressThrow: !1\n    });\n  } catch {\n  }\n  return range;\n}\nfunction normalizePoint(point, value) {\n  if (!point || !value)\n    return null;\n  const newPath = [];\n  let newOffset = point.offset || 0;\n  const blockKey = typeof point.path[0] == \"object\" && \"_key\" in point.path[0] && point.path[0]._key, childKey = typeof point.path[2] == \"object\" && \"_key\" in point.path[2] && point.path[2]._key, block = value.find((blk) => blk._key === blockKey);\n  if (block)\n    newPath.push({\n      _key: block._key\n    });\n  else\n    return null;\n  if (block && point.path[1] === \"children\") {\n    if (!block.children || Array.isArray(block.children) && block.children.length === 0)\n      return null;\n    const child = Array.isArray(block.children) && block.children.find((cld) => cld._key === childKey);\n    if (child)\n      newPath.push(\"children\"), newPath.push({\n        _key: child._key\n      }), newOffset = child.text && child.text.length >= point.offset ? point.offset : child.text && child.text.length || 0;\n    else\n      return null;\n  }\n  return {\n    path: newPath,\n    offset: newOffset\n  };\n}\nfunction normalizeSelection(selection, value) {\n  if (!selection || !value || value.length === 0)\n    return null;\n  let newAnchor = null, newFocus = null;\n  const {\n    anchor,\n    focus\n  } = selection;\n  return anchor && value.find((blk) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__({\n    _key: blk._key\n  }, anchor.path[0])) && (newAnchor = normalizePoint(anchor, value)), focus && value.find((blk) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__({\n    _key: blk._key\n  }, focus.path[0])) && (newFocus = normalizePoint(focus, value)), newAnchor && newFocus ? {\n    anchor: newAnchor,\n    focus: newFocus,\n    backward: selection.backward\n  } : null;\n}\nfunction toSlateRange(snapshot) {\n  if (!snapshot.context.selection)\n    return null;\n  if ((0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.isEqualSelectionPoints)(snapshot.context.selection.anchor, snapshot.context.selection.focus)) {\n    const anchorPoint2 = toSlateSelectionPoint(snapshot, snapshot.context.selection.anchor, snapshot.context.selection.backward ? \"forward\" : \"backward\");\n    return anchorPoint2 ? {\n      anchor: anchorPoint2,\n      focus: anchorPoint2\n    } : null;\n  }\n  const anchorPoint = toSlateSelectionPoint(snapshot, snapshot.context.selection.anchor, snapshot.context.selection.backward ? \"forward\" : \"backward\"), focusPoint = toSlateSelectionPoint(snapshot, snapshot.context.selection.focus, snapshot.context.selection.backward ? \"backward\" : \"forward\");\n  return !anchorPoint || !focusPoint ? null : {\n    anchor: anchorPoint,\n    focus: focusPoint\n  };\n}\nfunction toSlateSelectionPoint(snapshot, selectionPoint, direction) {\n  const blockKey = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.getBlockKeyFromSelectionPoint)(selectionPoint);\n  if (!blockKey)\n    return;\n  const blockIndex = snapshot.blockIndexMap.get(blockKey);\n  if (blockIndex === void 0)\n    return;\n  const block = snapshot.context.value.at(blockIndex);\n  if (!block)\n    return;\n  if (!(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(snapshot.context, block))\n    return {\n      path: [blockIndex, 0],\n      offset: 0\n    };\n  let childKey = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.getChildKeyFromSelectionPoint)({\n    path: selectionPoint.path\n  });\n  const spanSelectionPoint = childKey ? void 0 : (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.blockOffsetToSpanSelectionPoint)({\n    context: {\n      schema: snapshot.context.schema,\n      value: [block]\n    },\n    blockOffset: {\n      path: [{\n        _key: blockKey\n      }],\n      offset: selectionPoint.offset\n    },\n    direction\n  });\n  if (childKey = spanSelectionPoint ? (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.getChildKeyFromSelectionPoint)(spanSelectionPoint) : childKey, !childKey)\n    return {\n      path: [blockIndex, 0],\n      offset: 0\n    };\n  let offset = spanSelectionPoint?.offset ?? selectionPoint.offset, childPath = [], childIndex = -1, pathChild;\n  for (const child of block.children)\n    if (childIndex++, child._key === childKey) {\n      pathChild = child, (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isSpan)(snapshot.context, child) ? childPath = [childIndex] : (childPath = [childIndex, 0], offset = 0);\n      break;\n    }\n  return childPath.length === 0 ? {\n    path: [blockIndex, 0],\n    offset: 0\n  } : {\n    path: [blockIndex].concat(childPath),\n    offset: (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isSpan)(snapshot.context, pathChild) ? Math.min(pathChild.text.length, offset) : offset\n  };\n}\nconst EditorActorContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({});\nfunction DropIndicator() {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(1);\n  let t0;\n  return $[0] === Symbol.for(\"react.memo_cache_sentinel\") ? (t0 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { contentEditable: !1, className: \"pt-drop-indicator\", style: {\n    position: \"absolute\",\n    width: \"100%\",\n    height: 1,\n    borderBottom: \"1px solid currentColor\",\n    zIndex: 5\n  }, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", {}) }), $[0] = t0) : t0 = $[0], t0;\n}\nfunction RenderDefaultBlockObject(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(4);\n  let t0;\n  $[0] === Symbol.for(\"react.memo_cache_sentinel\") ? (t0 = {\n    userSelect: \"none\"\n  }, $[0] = t0) : t0 = $[0];\n  let t1;\n  return $[1] !== props.blockObject._key || $[2] !== props.blockObject._type ? (t1 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { style: t0, children: [\n    \"[\",\n    props.blockObject._type,\n    \": \",\n    props.blockObject._key,\n    \"]\"\n  ] }), $[1] = props.blockObject._key, $[2] = props.blockObject._type, $[3] = t1) : t1 = $[3], t1;\n}\nfunction RenderDefaultInlineObject(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(4);\n  let t0;\n  $[0] === Symbol.for(\"react.memo_cache_sentinel\") ? (t0 = {\n    userSelect: \"none\"\n  }, $[0] = t0) : t0 = $[0];\n  let t1;\n  return $[1] !== props.inlineObject._key || $[2] !== props.inlineObject._type ? (t1 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"span\", { style: t0, children: [\n    \"[\",\n    props.inlineObject._type,\n    \": \",\n    props.inlineObject._key,\n    \"]\"\n  ] }), $[1] = props.inlineObject._key, $[2] = props.inlineObject._type, $[3] = t1) : t1 = $[3], t1;\n}\nfunction createEditorPriority(config) {\n  return {\n    id: (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.defaultKeyGenerator)(),\n    name: config?.name,\n    reference: config?.reference\n  };\n}\nconst corePriority = createEditorPriority({\n  name: \"core\"\n});\nfunction getDragSelection({\n  eventSelection,\n  snapshot\n}) {\n  let dragSelection = eventSelection;\n  if ((0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getFocusInlineObject)({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: eventSelection\n    }\n  }))\n    return dragSelection;\n  const draggingCollapsedSelection = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.isSelectionCollapsed)({\n    context: {\n      ...snapshot.context,\n      selection: eventSelection\n    }\n  }), draggedTextBlock = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusTextBlock)({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: eventSelection\n    }\n  }), draggedSpan = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusSpan)({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: eventSelection\n    }\n  });\n  draggingCollapsedSelection && draggedTextBlock && draggedSpan && (dragSelection = {\n    anchor: (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.getBlockStartPoint)({\n      context: snapshot.context,\n      block: draggedTextBlock\n    }),\n    focus: (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.getBlockEndPoint)({\n      context: snapshot.context,\n      block: draggedTextBlock\n    })\n  });\n  const selectedBlocks = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getSelectedBlocks)(snapshot);\n  if (snapshot.context.selection && (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.isSelectionExpanded)(snapshot) && selectedBlocks.length > 1) {\n    const selectionStartBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getSelectionStartBlock)(snapshot), selectionEndBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getSelectionEndBlock)(snapshot);\n    if (!selectionStartBlock || !selectionEndBlock)\n      return dragSelection;\n    const selectionStartPoint = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.getBlockStartPoint)({\n      context: snapshot.context,\n      block: selectionStartBlock\n    }), selectionEndPoint = (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.getBlockEndPoint)({\n      context: snapshot.context,\n      block: selectionEndBlock\n    });\n    (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.isOverlappingSelection)(eventSelection)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionStartPoint,\n          focus: selectionEndPoint\n        }\n      }\n    }) && (dragSelection = {\n      anchor: selectionStartPoint,\n      focus: selectionEndPoint\n    });\n  }\n  return dragSelection;\n}\nfunction createCoreBlockElementBehaviorsConfig({\n  key,\n  onSetDragPositionBlock\n}) {\n  return [{\n    behavior: (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n      on: \"drag.dragover\",\n      guard: ({\n        snapshot,\n        event\n      }) => {\n        const dropFocusBlock = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusBlock)({\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: event.position.selection\n          }\n        });\n        if (!dropFocusBlock || dropFocusBlock.node._key !== key)\n          return !1;\n        const dragOrigin = event.dragOrigin;\n        if (!dragOrigin)\n          return !1;\n        const dragSelection = getDragSelection({\n          eventSelection: dragOrigin.selection,\n          snapshot\n        });\n        return (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getSelectedBlocks)({\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: dragSelection\n          }\n        }).some((draggedBlock) => draggedBlock.node._key === key) ? !1 : (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.isSelectingEntireBlocks)({\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: dragSelection\n          }\n        });\n      },\n      actions: [({\n        event\n      }) => [{\n        type: \"effect\",\n        effect: () => {\n          onSetDragPositionBlock(event.position.block);\n        }\n      }]]\n    }),\n    priority: createEditorPriority({\n      reference: {\n        priority: corePriority,\n        importance: \"lower\"\n      }\n    })\n  }, {\n    behavior: (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n      on: \"drag.*\",\n      guard: ({\n        event\n      }) => event.type !== \"drag.dragover\",\n      actions: [({\n        event\n      }) => [{\n        type: \"effect\",\n        effect: () => {\n          onSetDragPositionBlock(void 0);\n        }\n      }, (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.forward)(event)]]\n    }),\n    priority: createEditorPriority({\n      reference: {\n        priority: corePriority,\n        importance: \"lower\"\n      }\n    })\n  }];\n}\nfunction useCoreBlockElementBehaviors(t0) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(5), {\n    key,\n    onSetDragPositionBlock\n  } = t0, editorActor = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(EditorActorContext);\n  let t1, t2;\n  $[0] !== editorActor || $[1] !== key || $[2] !== onSetDragPositionBlock ? (t1 = () => {\n    const behaviorConfigs = createCoreBlockElementBehaviorsConfig({\n      key,\n      onSetDragPositionBlock\n    });\n    for (const behaviorConfig of behaviorConfigs)\n      editorActor.send({\n        type: \"add behavior\",\n        behaviorConfig\n      });\n    return () => {\n      for (const behaviorConfig_0 of behaviorConfigs)\n        editorActor.send({\n          type: \"remove behavior\",\n          behaviorConfig: behaviorConfig_0\n        });\n    };\n  }, t2 = [editorActor, key, onSetDragPositionBlock], $[0] = editorActor, $[1] = key, $[2] = onSetDragPositionBlock, $[3] = t1, $[4] = t2) : (t1 = $[3], t2 = $[4]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(t1, t2);\n}\nfunction RenderBlockObject(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(35), [dragPositionBlock, setDragPositionBlock] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(), blockObjectRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null), selected = (0,slate_react__WEBPACK_IMPORTED_MODULE_22__.useSelected)();\n  let t0;\n  $[0] !== selected ? (t0 = (editor) => selected && editor.selection !== null && slate__WEBPACK_IMPORTED_MODULE_14__.Range.isCollapsed(editor.selection), $[0] = selected, $[1] = t0) : t0 = $[1];\n  const focused = (0,slate_react__WEBPACK_IMPORTED_MODULE_22__.useSlateSelector)(t0);\n  let t1;\n  $[2] !== props.element._key ? (t1 = {\n    key: props.element._key,\n    onSetDragPositionBlock: setDragPositionBlock\n  }, $[2] = props.element._key, $[3] = t1) : t1 = $[3], useCoreBlockElementBehaviors(t1);\n  let t2;\n  if ($[4] !== props.element._type || $[5] !== props.legacySchema.blockObjects) {\n    let t32;\n    $[7] !== props.element._type ? (t32 = (schemaType) => schemaType.name === props.element._type, $[7] = props.element._type, $[8] = t32) : t32 = $[8], t2 = props.legacySchema.blockObjects.find(t32), $[4] = props.element._type, $[5] = props.legacySchema.blockObjects, $[6] = t2;\n  } else\n    t2 = $[6];\n  const legacySchemaType = t2;\n  legacySchemaType || console.error(`Unable to find Block Object \"${props.element._type}\" in Schema`);\n  let t3;\n  $[9] !== props.blockObject || $[10] !== props.element._key || $[11] !== props.element._type ? (t3 = props.blockObject ?? {\n    _key: props.element._key,\n    _type: props.element._type\n  }, $[9] = props.blockObject, $[10] = props.element._key, $[11] = props.element._type, $[12] = t3) : t3 = $[12];\n  const blockObject = t3;\n  let t4;\n  $[13] !== dragPositionBlock ? (t4 = dragPositionBlock === \"start\" ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DropIndicator, {}) : null, $[13] = dragPositionBlock, $[14] = t4) : t4 = $[14];\n  const t5 = !props.readOnly;\n  let t6;\n  $[15] !== blockObject || $[16] !== focused || $[17] !== legacySchemaType || $[18] !== props.element._key || $[19] !== props.renderBlock || $[20] !== selected ? (t6 = props.renderBlock && legacySchemaType ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderBlock$1, { renderBlock: props.renderBlock, editorElementRef: blockObjectRef, focused, path: [{\n    _key: props.element._key\n  }], schemaType: legacySchemaType, selected, type: legacySchemaType, value: blockObject, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderDefaultBlockObject, { blockObject }) }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderDefaultBlockObject, { blockObject }), $[15] = blockObject, $[16] = focused, $[17] = legacySchemaType, $[18] = props.element._key, $[19] = props.renderBlock, $[20] = selected, $[21] = t6) : t6 = $[21];\n  let t7;\n  $[22] !== t5 || $[23] !== t6 ? (t7 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { ref: blockObjectRef, contentEditable: !1, draggable: t5, children: t6 }), $[22] = t5, $[23] = t6, $[24] = t7) : t7 = $[24];\n  let t8;\n  $[25] !== dragPositionBlock ? (t8 = dragPositionBlock === \"end\" ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DropIndicator, {}) : null, $[25] = dragPositionBlock, $[26] = t8) : t8 = $[26];\n  let t9;\n  return $[27] !== props.attributes || $[28] !== props.children || $[29] !== props.element._key || $[30] !== props.element._type || $[31] !== t4 || $[32] !== t7 || $[33] !== t8 ? (t9 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { ...props.attributes, className: \"pt-block pt-object-block\", \"data-block-key\": props.element._key, \"data-block-name\": props.element._type, \"data-block-type\": \"object\", children: [\n    t4,\n    props.children,\n    t7,\n    t8\n  ] }), $[27] = props.attributes, $[28] = props.children, $[29] = props.element._key, $[30] = props.element._type, $[31] = t4, $[32] = t7, $[33] = t8, $[34] = t9) : t9 = $[34], t9;\n}\nfunction RenderBlock$1({\n  renderBlock,\n  children,\n  editorElementRef,\n  focused,\n  path,\n  schemaType,\n  selected,\n  type,\n  value\n}) {\n  return renderBlock({\n    children,\n    editorElementRef,\n    focused,\n    path,\n    schemaType,\n    selected,\n    type,\n    value\n  });\n}\nfunction RenderInlineObject(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(32), inlineObjectRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null), slateEditor = (0,slate_react__WEBPACK_IMPORTED_MODULE_22__.useSlateStatic)(), selected = (0,slate_react__WEBPACK_IMPORTED_MODULE_22__.useSelected)();\n  let t0;\n  $[0] !== selected ? (t0 = (editor) => selected && editor.selection !== null && slate__WEBPACK_IMPORTED_MODULE_14__.Range.isCollapsed(editor.selection), $[0] = selected, $[1] = t0) : t0 = $[1];\n  const focused = (0,slate_react__WEBPACK_IMPORTED_MODULE_22__.useSlateSelector)(t0);\n  let t1;\n  if ($[2] !== props.element._type || $[3] !== props.legacySchema.inlineObjects) {\n    let t22;\n    $[5] !== props.element._type ? (t22 = (inlineObject) => inlineObject.name === props.element._type, $[5] = props.element._type, $[6] = t22) : t22 = $[6], t1 = props.legacySchema.inlineObjects.find(t22), $[2] = props.element._type, $[3] = props.legacySchema.inlineObjects, $[4] = t1;\n  } else\n    t1 = $[4];\n  const legacySchemaType = t1;\n  legacySchemaType || console.error(`Unable to find Inline Object \"${props.element._type}\" in Schema`);\n  let t2;\n  if ($[7] !== props.element || $[8] !== slateEditor) {\n    const path = slate_dom__WEBPACK_IMPORTED_MODULE_17__.DOMEditor.findPath(slateEditor, props.element);\n    t2 = getPointBlock({\n      editor: slateEditor,\n      point: {\n        path,\n        offset: 0\n      }\n    }), $[7] = props.element, $[8] = slateEditor, $[9] = t2;\n  } else\n    t2 = $[9];\n  const [block] = t2;\n  block || console.error(`Unable to find parent block of inline object ${props.element._key}`);\n  let t3;\n  $[10] !== props.element ? (t3 = \"value\" in props.element && typeof props.element.value == \"object\" ? props.element.value : {}, $[10] = props.element, $[11] = t3) : t3 = $[11];\n  let t4;\n  $[12] !== props.element._key || $[13] !== props.element._type || $[14] !== t3 ? (t4 = {\n    _key: props.element._key,\n    _type: props.element._type,\n    ...t3\n  }, $[12] = props.element._key, $[13] = props.element._type, $[14] = t3, $[15] = t4) : t4 = $[15];\n  const inlineObject_0 = t4, t5 = !props.readOnly;\n  let t6;\n  $[16] === Symbol.for(\"react.memo_cache_sentinel\") ? (t6 = {\n    display: \"inline-block\"\n  }, $[16] = t6) : t6 = $[16];\n  let t7;\n  $[17] !== block || $[18] !== focused || $[19] !== inlineObject_0 || $[20] !== legacySchemaType || $[21] !== props.element._key || $[22] !== props.renderChild || $[23] !== selected ? (t7 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { ref: inlineObjectRef, style: t6, children: props.renderChild && block && legacySchemaType ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderChild$1, { renderChild: props.renderChild, annotations: [], editorElementRef: inlineObjectRef, selected, focused, path: [{\n    _key: block._key\n  }, \"children\", {\n    _key: props.element._key\n  }], schemaType: legacySchemaType, value: inlineObject_0, type: legacySchemaType, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderDefaultInlineObject, { inlineObject: inlineObject_0 }) }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderDefaultInlineObject, { inlineObject: inlineObject_0 }) }), $[17] = block, $[18] = focused, $[19] = inlineObject_0, $[20] = legacySchemaType, $[21] = props.element._key, $[22] = props.renderChild, $[23] = selected, $[24] = t7) : t7 = $[24];\n  let t8;\n  return $[25] !== inlineObject_0._key || $[26] !== inlineObject_0._type || $[27] !== props.attributes || $[28] !== props.children || $[29] !== t5 || $[30] !== t7 ? (t8 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"span\", { ...props.attributes, draggable: t5, className: \"pt-inline-object\", \"data-child-key\": inlineObject_0._key, \"data-child-name\": inlineObject_0._type, \"data-child-type\": \"object\", children: [\n    props.children,\n    t7\n  ] }), $[25] = inlineObject_0._key, $[26] = inlineObject_0._type, $[27] = props.attributes, $[28] = props.children, $[29] = t5, $[30] = t7, $[31] = t8) : t8 = $[31], t8;\n}\nfunction RenderChild$1({\n  renderChild,\n  annotations,\n  children,\n  editorElementRef,\n  focused,\n  path,\n  schemaType,\n  selected,\n  value,\n  type\n}) {\n  return renderChild({\n    annotations,\n    children,\n    editorElementRef,\n    focused,\n    path,\n    schemaType,\n    selected,\n    value,\n    type\n  });\n}\nfunction RenderTextBlock(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(77), [dragPositionBlock, setDragPositionBlock] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(), blockRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null), selected = (0,slate_react__WEBPACK_IMPORTED_MODULE_22__.useSelected)();\n  let t0;\n  $[0] !== selected ? (t0 = (editor) => selected && editor.selection !== null && slate__WEBPACK_IMPORTED_MODULE_14__.Range.isCollapsed(editor.selection), $[0] = selected, $[1] = t0) : t0 = $[1];\n  const focused = (0,slate_react__WEBPACK_IMPORTED_MODULE_22__.useSlateSelector)(t0);\n  let t1;\n  $[2] !== props.element._key ? (t1 = {\n    key: props.element._key,\n    onSetDragPositionBlock: setDragPositionBlock\n  }, $[2] = props.element._key, $[3] = t1) : t1 = $[3], useCoreBlockElementBehaviors(t1);\n  let t2;\n  $[4] !== props.textBlock._key ? (t2 = (editor_0) => editor_0.listIndexMap.get(props.textBlock._key), $[4] = props.textBlock._key, $[5] = t2) : t2 = $[5];\n  const listIndex = (0,slate_react__WEBPACK_IMPORTED_MODULE_22__.useSlateSelector)(t2);\n  let children = props.children;\n  if (props.renderStyle && props.textBlock.style) {\n    let t32;\n    $[6] !== props.legacySchema || $[7] !== props.textBlock.style ? (t32 = props.textBlock.style !== void 0 ? props.legacySchema.styles.find((style) => style.value === props.textBlock.style) : void 0, $[6] = props.legacySchema, $[7] = props.textBlock.style, $[8] = t32) : t32 = $[8];\n    const legacyStyleSchemaType = t32;\n    if (legacyStyleSchemaType) {\n      let t42;\n      $[9] !== props.textBlock._key ? (t42 = [{\n        _key: props.textBlock._key\n      }], $[9] = props.textBlock._key, $[10] = t42) : t42 = $[10];\n      let t52;\n      $[11] !== children || $[12] !== focused || $[13] !== legacyStyleSchemaType || $[14] !== props.renderStyle || $[15] !== props.textBlock || $[16] !== selected || $[17] !== t42 ? (t52 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderStyle, { renderStyle: props.renderStyle, block: props.textBlock, editorElementRef: blockRef, focused, path: t42, schemaType: legacyStyleSchemaType, selected, value: props.textBlock.style, children }), $[11] = children, $[12] = focused, $[13] = legacyStyleSchemaType, $[14] = props.renderStyle, $[15] = props.textBlock, $[16] = selected, $[17] = t42, $[18] = t52) : t52 = $[18], children = t52;\n    } else\n      console.error(`Unable to find Schema type for text block style ${props.textBlock.style}`);\n  }\n  if (props.renderListItem && props.textBlock.listItem) {\n    let t32;\n    if ($[19] !== props.legacySchema.lists || $[20] !== props.textBlock.listItem) {\n      let t42;\n      $[22] !== props.textBlock.listItem ? (t42 = (list) => list.value === props.textBlock.listItem, $[22] = props.textBlock.listItem, $[23] = t42) : t42 = $[23], t32 = props.legacySchema.lists.find(t42), $[19] = props.legacySchema.lists, $[20] = props.textBlock.listItem, $[21] = t32;\n    } else\n      t32 = $[21];\n    const legacyListItemSchemaType = t32;\n    if (legacyListItemSchemaType) {\n      const t42 = props.textBlock.level ?? 1;\n      let t52;\n      $[24] !== props.textBlock._key ? (t52 = [{\n        _key: props.textBlock._key\n      }], $[24] = props.textBlock._key, $[25] = t52) : t52 = $[25];\n      let t62;\n      $[26] !== children || $[27] !== focused || $[28] !== legacyListItemSchemaType || $[29] !== props.renderListItem || $[30] !== props.textBlock || $[31] !== selected || $[32] !== t42 || $[33] !== t52 ? (t62 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderListItem, { renderListItem: props.renderListItem, block: props.textBlock, editorElementRef: blockRef, focused, level: t42, path: t52, selected, value: props.textBlock.listItem, schemaType: legacyListItemSchemaType, children }), $[26] = children, $[27] = focused, $[28] = legacyListItemSchemaType, $[29] = props.renderListItem, $[30] = props.textBlock, $[31] = selected, $[32] = t42, $[33] = t52, $[34] = t62) : t62 = $[34], children = t62;\n    } else\n      console.error(`Unable to find Schema type for text block list item ${props.textBlock.listItem}`);\n  }\n  const t3 = props.attributes;\n  let t4;\n  $[35] !== props.textBlock.style ? (t4 = props.textBlock.style ? [`pt-text-block-style-${props.textBlock.style}`] : [], $[35] = props.textBlock.style, $[36] = t4) : t4 = $[36];\n  let t5;\n  $[37] !== props.textBlock.level || $[38] !== props.textBlock.listItem ? (t5 = props.textBlock.listItem ? [\"pt-list-item\", `pt-list-item-${props.textBlock.listItem}`, `pt-list-item-level-${props.textBlock.level ?? 1}`] : [], $[37] = props.textBlock.level, $[38] = props.textBlock.listItem, $[39] = t5) : t5 = $[39];\n  let t6;\n  $[40] !== t4 || $[41] !== t5 ? (t6 = [\"pt-block\", \"pt-text-block\", ...t4, ...t5], $[40] = t4, $[41] = t5, $[42] = t6) : t6 = $[42];\n  const t7 = t6.join(\" \");\n  let t8;\n  $[43] !== props.textBlock.listItem ? (t8 = props.textBlock.listItem !== void 0 ? {\n    \"data-list-item\": props.textBlock.listItem\n  } : {}, $[43] = props.textBlock.listItem, $[44] = t8) : t8 = $[44];\n  let t9;\n  $[45] !== props.textBlock.level ? (t9 = props.textBlock.level !== void 0 ? {\n    \"data-level\": props.textBlock.level\n  } : {}, $[45] = props.textBlock.level, $[46] = t9) : t9 = $[46];\n  let t10;\n  $[47] !== props.textBlock.style ? (t10 = props.textBlock.style !== void 0 ? {\n    \"data-style\": props.textBlock.style\n  } : {}, $[47] = props.textBlock.style, $[48] = t10) : t10 = $[48];\n  let t11;\n  $[49] !== listIndex ? (t11 = listIndex !== void 0 ? {\n    \"data-list-index\": listIndex\n  } : {}, $[49] = listIndex, $[50] = t11) : t11 = $[50];\n  let t12;\n  $[51] !== dragPositionBlock ? (t12 = dragPositionBlock === \"start\" ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DropIndicator, {}) : null, $[51] = dragPositionBlock, $[52] = t12) : t12 = $[52];\n  let t13;\n  $[53] !== children || $[54] !== focused || $[55] !== props.legacySchema || $[56] !== props.renderBlock || $[57] !== props.textBlock || $[58] !== selected ? (t13 = props.renderBlock ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderBlock, { renderBlock: props.renderBlock, editorElementRef: blockRef, focused, level: props.textBlock.level, listItem: props.textBlock.listItem, path: [{\n    _key: props.textBlock._key\n  }], selected, schemaType: props.legacySchema.block, style: props.textBlock.style, type: props.legacySchema.block, value: props.textBlock, children }) : children, $[53] = children, $[54] = focused, $[55] = props.legacySchema, $[56] = props.renderBlock, $[57] = props.textBlock, $[58] = selected, $[59] = t13) : t13 = $[59];\n  let t14;\n  $[60] !== t13 ? (t14 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { ref: blockRef, children: t13 }), $[60] = t13, $[61] = t14) : t14 = $[61];\n  let t15;\n  $[62] !== dragPositionBlock ? (t15 = dragPositionBlock === \"end\" ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DropIndicator, {}) : null, $[62] = dragPositionBlock, $[63] = t15) : t15 = $[63];\n  let t16;\n  return $[64] !== props.attributes || $[65] !== props.spellCheck || $[66] !== props.textBlock._key || $[67] !== props.textBlock._type || $[68] !== t10 || $[69] !== t11 || $[70] !== t12 || $[71] !== t14 || $[72] !== t15 || $[73] !== t7 || $[74] !== t8 || $[75] !== t9 ? (t16 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { ...t3, className: t7, spellCheck: props.spellCheck, \"data-block-key\": props.textBlock._key, \"data-block-name\": props.textBlock._type, \"data-block-type\": \"text\", ...t8, ...t9, ...t10, ...t11, children: [\n    t12,\n    t14,\n    t15\n  ] }), $[64] = props.attributes, $[65] = props.spellCheck, $[66] = props.textBlock._key, $[67] = props.textBlock._type, $[68] = t10, $[69] = t11, $[70] = t12, $[71] = t14, $[72] = t15, $[73] = t7, $[74] = t8, $[75] = t9, $[76] = t16) : t16 = $[76], t16;\n}\nfunction RenderBlock({\n  renderBlock,\n  children,\n  editorElementRef,\n  focused,\n  level,\n  listItem,\n  path,\n  selected,\n  style,\n  schemaType,\n  type,\n  value\n}) {\n  return renderBlock({\n    children,\n    editorElementRef,\n    focused,\n    level,\n    listItem,\n    path,\n    selected,\n    style,\n    schemaType,\n    type,\n    value\n  });\n}\nfunction RenderListItem({\n  renderListItem,\n  block,\n  children,\n  editorElementRef,\n  focused,\n  level,\n  path,\n  schemaType,\n  selected,\n  value\n}) {\n  return renderListItem({\n    block,\n    children,\n    editorElementRef,\n    focused,\n    level,\n    path,\n    schemaType,\n    selected,\n    value\n  });\n}\nfunction RenderStyle({\n  renderStyle,\n  block,\n  children,\n  editorElementRef,\n  focused,\n  path,\n  schemaType,\n  selected,\n  value\n}) {\n  return renderStyle({\n    block,\n    children,\n    editorElementRef,\n    focused,\n    path,\n    schemaType,\n    selected,\n    value\n  });\n}\nfunction RenderElement(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(34), editorActor = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(EditorActorContext), schema = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_23__.useSelector)(editorActor, _temp$3), legacySchema = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_23__.useSelector)(editorActor, _temp2$2), slateStatic = (0,slate_react__WEBPACK_IMPORTED_MODULE_22__.useSlateStatic)();\n  if (\"__inline\" in props.element && props.element.__inline === !0) {\n    let t02;\n    return $[0] !== legacySchema || $[1] !== props.attributes || $[2] !== props.children || $[3] !== props.element || $[4] !== props.readOnly || $[5] !== props.renderChild || $[6] !== schema ? (t02 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderInlineObject, { attributes: props.attributes, element: props.element, legacySchema, readOnly: props.readOnly, renderChild: props.renderChild, schema, children: props.children }), $[0] = legacySchema, $[1] = props.attributes, $[2] = props.children, $[3] = props.element, $[4] = props.readOnly, $[5] = props.renderChild, $[6] = schema, $[7] = t02) : t02 = $[7], t02;\n  }\n  let block, t0;\n  if ($[8] !== props.element._key || $[9] !== schema || $[10] !== slateStatic.blockIndexMap || $[11] !== slateStatic.value) {\n    const blockIndex = slateStatic.blockIndexMap.get(props.element._key);\n    block = blockIndex !== void 0 ? slateStatic.value.at(blockIndex) : void 0, t0 = (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)({\n      schema\n    }, block), $[8] = props.element._key, $[9] = schema, $[10] = slateStatic.blockIndexMap, $[11] = slateStatic.value, $[12] = block, $[13] = t0;\n  } else\n    block = $[12], t0 = $[13];\n  if (t0) {\n    let t12;\n    return $[14] !== block || $[15] !== legacySchema || $[16] !== props.attributes || $[17] !== props.children || $[18] !== props.element || $[19] !== props.readOnly || $[20] !== props.renderBlock || $[21] !== props.renderListItem || $[22] !== props.renderStyle || $[23] !== props.spellCheck ? (t12 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderTextBlock, { attributes: props.attributes, element: props.element, legacySchema, readOnly: props.readOnly, renderBlock: props.renderBlock, renderListItem: props.renderListItem, renderStyle: props.renderStyle, spellCheck: props.spellCheck, textBlock: block, children: props.children }), $[14] = block, $[15] = legacySchema, $[16] = props.attributes, $[17] = props.children, $[18] = props.element, $[19] = props.readOnly, $[20] = props.renderBlock, $[21] = props.renderListItem, $[22] = props.renderStyle, $[23] = props.spellCheck, $[24] = t12) : t12 = $[24], t12;\n  }\n  let t1;\n  return $[25] !== block || $[26] !== legacySchema || $[27] !== props.attributes || $[28] !== props.children || $[29] !== props.element || $[30] !== props.readOnly || $[31] !== props.renderBlock || $[32] !== schema ? (t1 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderBlockObject, { attributes: props.attributes, blockObject: block, element: props.element, legacySchema, readOnly: props.readOnly, renderBlock: props.renderBlock, schema, children: props.children }), $[25] = block, $[26] = legacySchema, $[27] = props.attributes, $[28] = props.children, $[29] = props.element, $[30] = props.readOnly, $[31] = props.renderBlock, $[32] = schema, $[33] = t1) : t1 = $[33], t1;\n}\nfunction _temp2$2(s_0) {\n  return s_0.context.getLegacySchema();\n}\nfunction _temp$3(s) {\n  return s.context.schema;\n}\nfunction defaultCompare(a, b) {\n  return a === b;\n}\nfunction useEditorSelector(editor, selector, t0) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(3), compare = t0 === void 0 ? defaultCompare : t0;\n  let t1;\n  return $[0] !== editor || $[1] !== selector ? (t1 = (editorActorSnapshot) => {\n    const snapshot = getEditorSnapshot({\n      editorActorSnapshot,\n      slateEditorInstance: editor._internal.slateEditor.instance\n    });\n    return selector(snapshot);\n  }, $[0] = editor, $[1] = selector, $[2] = t1) : t1 = $[2], (0,_xstate_react__WEBPACK_IMPORTED_MODULE_23__.useSelector)(editor._internal.editorActor, t1, compare);\n}\nfunction getEditorSnapshot({\n  editorActorSnapshot,\n  slateEditorInstance\n}) {\n  const selection = slateEditorInstance.selection ? slateRangeToSelection({\n    schema: editorActorSnapshot.context.schema,\n    editor: slateEditorInstance,\n    range: slateEditorInstance.selection\n  }) : null;\n  return {\n    blockIndexMap: slateEditorInstance.blockIndexMap,\n    context: {\n      converters: [...editorActorSnapshot.context.converters],\n      keyGenerator: editorActorSnapshot.context.keyGenerator,\n      readOnly: editorActorSnapshot.matches({\n        \"edit mode\": \"read only\"\n      }),\n      schema: editorActorSnapshot.context.schema,\n      selection,\n      value: slateEditorInstance.value\n    },\n    decoratorState: slateEditorInstance.decoratorState\n  };\n}\nfunction RenderSpan(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(40), slateEditor = (0,slate_react__WEBPACK_IMPORTED_MODULE_22__.useSlateStatic)(), editorActor = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(EditorActorContext), legacySchema = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_23__.useSelector)(editorActor, _temp$2), spanRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  let t0;\n  $[0] !== props.leaf._key || $[1] !== slateEditor ? (t0 = (editorActorSnapshot) => {\n    const snapshot = getEditorSnapshot({\n      editorActorSnapshot,\n      slateEditorInstance: slateEditor\n    });\n    if (!snapshot.context.selection || !(0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.isSelectionCollapsed)(snapshot))\n      return !1;\n    const focusedSpan = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusSpan)(snapshot);\n    return focusedSpan ? focusedSpan.node._key === props.leaf._key : !1;\n  }, $[0] = props.leaf._key, $[1] = slateEditor, $[2] = t0) : t0 = $[2];\n  const focused = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_23__.useSelector)(editorActor, t0);\n  let t1;\n  $[3] !== props.children.props.parent || $[4] !== props.leaf._key || $[5] !== props.leaf.text || $[6] !== slateEditor ? (t1 = (editorActorSnapshot_0) => {\n    const snapshot_0 = getEditorSnapshot({\n      editorActorSnapshot: editorActorSnapshot_0,\n      slateEditorInstance: slateEditor\n    });\n    if (!snapshot_0.context.selection)\n      return !1;\n    const parent = props.children.props.parent, block = parent && (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(snapshot_0.context, parent) ? parent : void 0, spanSelection = block ? {\n      anchor: {\n        path: [{\n          _key: block._key\n        }, \"children\", {\n          _key: props.leaf._key\n        }],\n        offset: 0\n      },\n      focus: {\n        path: [{\n          _key: block._key\n        }, \"children\", {\n          _key: props.leaf._key\n        }],\n        offset: props.leaf.text.length\n      }\n    } : null;\n    return (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.isOverlappingSelection)(spanSelection)(snapshot_0);\n  }, $[3] = props.children.props.parent, $[4] = props.leaf._key, $[5] = props.leaf.text, $[6] = slateEditor, $[7] = t1) : t1 = $[7];\n  const selected = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_23__.useSelector)(editorActor, t1), parent_0 = props.children.props.parent, block_0 = parent_0 && slateEditor.isTextBlock(parent_0) ? parent_0 : void 0;\n  let t2;\n  $[8] !== block_0 || $[9] !== props.leaf._key ? (t2 = block_0 ? [{\n    _key: block_0._key\n  }, \"children\", {\n    _key: props.leaf._key\n  }] : void 0, $[8] = block_0, $[9] = props.leaf._key, $[10] = t2) : t2 = $[10];\n  const path = t2;\n  let annotationMarkDefs, children;\n  if ($[11] !== block_0 || $[12] !== editorActor || $[13] !== focused || $[14] !== legacySchema || $[15] !== path || $[16] !== props.children || $[17] !== props.leaf.marks || $[18] !== props.renderAnnotation || $[19] !== props.renderDecorator || $[20] !== selected) {\n    const decoratorSchemaTypes = editorActor.getSnapshot().context.schema.decorators.map(_temp2$1), decorators = lodash_uniq_js__WEBPACK_IMPORTED_MODULE_6__((props.leaf.marks ?? []).filter((mark) => decoratorSchemaTypes.includes(mark)));\n    annotationMarkDefs = (props.leaf.marks ?? []).flatMap((mark_0) => {\n      if (decoratorSchemaTypes.includes(mark_0))\n        return [];\n      const markDef_0 = block_0?.markDefs?.find((markDef) => markDef._key === mark_0);\n      return markDef_0 ? [markDef_0] : [];\n    }), children = props.children;\n    for (const mark_1 of decorators) {\n      const legacyDecoratorSchemaType = legacySchema.decorators.find((dec) => dec.value === mark_1);\n      path && legacyDecoratorSchemaType && props.renderDecorator && (children = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderDecorator, { renderDecorator: props.renderDecorator, editorElementRef: spanRef, focused, path, selected, schemaType: legacyDecoratorSchemaType, value: mark_1, type: legacyDecoratorSchemaType, children }));\n    }\n    for (const annotationMarkDef of annotationMarkDefs) {\n      const legacyAnnotationSchemaType = legacySchema.annotations.find((t) => t.name === annotationMarkDef._type);\n      legacyAnnotationSchemaType && (block_0 && path && props.renderAnnotation ? children = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { ref: spanRef, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderAnnotation, { renderAnnotation: props.renderAnnotation, block: block_0, editorElementRef: spanRef, focused, path, selected, schemaType: legacyAnnotationSchemaType, value: annotationMarkDef, type: legacyAnnotationSchemaType, children }) }) : children = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { ref: spanRef, children }));\n    }\n    $[11] = block_0, $[12] = editorActor, $[13] = focused, $[14] = legacySchema, $[15] = path, $[16] = props.children, $[17] = props.leaf.marks, $[18] = props.renderAnnotation, $[19] = props.renderDecorator, $[20] = selected, $[21] = annotationMarkDefs, $[22] = children;\n  } else\n    annotationMarkDefs = $[21], children = $[22];\n  if (block_0 && path && props.renderChild) {\n    let t32;\n    if ($[23] !== block_0.children || $[24] !== props.leaf) {\n      let t4;\n      $[26] !== props.leaf ? (t4 = (_child) => _child._key === props.leaf._key, $[26] = props.leaf, $[27] = t4) : t4 = $[27], t32 = block_0.children.find(t4), $[23] = block_0.children, $[24] = props.leaf, $[25] = t32;\n    } else\n      t32 = $[25];\n    const child = t32;\n    if (child) {\n      let t4;\n      $[28] !== annotationMarkDefs || $[29] !== child || $[30] !== children || $[31] !== focused || $[32] !== legacySchema.span || $[33] !== path || $[34] !== props.renderChild || $[35] !== selected ? (t4 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderChild, { renderChild: props.renderChild, annotations: annotationMarkDefs, editorElementRef: spanRef, focused, path, schemaType: legacySchema.span, selected, value: child, type: legacySchema.span, children }), $[28] = annotationMarkDefs, $[29] = child, $[30] = children, $[31] = focused, $[32] = legacySchema.span, $[33] = path, $[34] = props.renderChild, $[35] = selected, $[36] = t4) : t4 = $[36], children = t4;\n    }\n  }\n  let t3;\n  return $[37] !== children || $[38] !== props.attributes ? (t3 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { ...props.attributes, ref: spanRef, children }), $[37] = children, $[38] = props.attributes, $[39] = t3) : t3 = $[39], t3;\n}\nfunction _temp2$1(decorator) {\n  return decorator.name;\n}\nfunction _temp$2(s) {\n  return s.context.getLegacySchema();\n}\nfunction RenderAnnotation({\n  renderAnnotation,\n  block,\n  children,\n  editorElementRef,\n  focused,\n  path,\n  schemaType,\n  selected,\n  value,\n  type\n}) {\n  return renderAnnotation({\n    block,\n    children,\n    editorElementRef,\n    focused,\n    path,\n    schemaType,\n    selected,\n    value,\n    type\n  });\n}\nfunction RenderDecorator({\n  renderDecorator,\n  children,\n  editorElementRef,\n  focused,\n  path,\n  schemaType,\n  selected,\n  value,\n  type\n}) {\n  return renderDecorator({\n    children,\n    editorElementRef,\n    focused,\n    path,\n    schemaType,\n    selected,\n    value,\n    type\n  });\n}\nfunction RenderChild({\n  renderChild,\n  annotations,\n  children,\n  editorElementRef,\n  focused,\n  path,\n  schemaType,\n  selected,\n  value,\n  type\n}) {\n  return renderChild({\n    annotations,\n    children,\n    editorElementRef,\n    focused,\n    path,\n    schemaType,\n    selected,\n    value,\n    type\n  });\n}\nconst PLACEHOLDER_STYLE = {\n  position: \"absolute\",\n  userSelect: \"none\",\n  pointerEvents: \"none\",\n  left: 0,\n  right: 0\n};\nfunction RenderLeaf(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(12), editorActor = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(EditorActorContext), schema = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_23__.useSelector)(editorActor, _temp$1);\n  if (props.leaf._type !== schema.span.name)\n    return props.children;\n  let t0;\n  $[0] !== props ? (t0 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderSpan, { ...props }), $[0] = props, $[1] = t0) : t0 = $[1];\n  let renderedSpan = t0;\n  if (props.renderPlaceholder && props.leaf.placeholder && props.text.text === \"\") {\n    let t1;\n    $[2] !== props.renderPlaceholder ? (t1 = props.renderPlaceholder(), $[2] = props.renderPlaceholder, $[3] = t1) : t1 = $[3];\n    let t2;\n    $[4] !== t1 ? (t2 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { style: PLACEHOLDER_STYLE, contentEditable: !1, children: t1 }), $[4] = t1, $[5] = t2) : t2 = $[5];\n    let t3;\n    return $[6] !== renderedSpan || $[7] !== t2 ? (t3 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [\n      t2,\n      renderedSpan\n    ] }), $[6] = renderedSpan, $[7] = t2, $[8] = t3) : t3 = $[8], t3;\n  }\n  const rangeDecoration = props.leaf.rangeDecoration;\n  if (rangeDecoration) {\n    let t1;\n    $[9] !== rangeDecoration || $[10] !== renderedSpan ? (t1 = rangeDecoration.component({\n      children: renderedSpan\n    }), $[9] = rangeDecoration, $[10] = renderedSpan, $[11] = t1) : t1 = $[11], renderedSpan = t1;\n  }\n  return renderedSpan;\n}\nfunction _temp$1(s) {\n  return s.context.schema;\n}\nfunction RenderText(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(5);\n  let t0;\n  return $[0] !== props.attributes || $[1] !== props.children || $[2] !== props.text._key || $[3] !== props.text._type ? (t0 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { ...props.attributes, \"data-child-key\": props.text._key, \"data-child-name\": props.text._type, \"data-child-type\": \"span\", children: props.children }), $[0] = props.attributes, $[1] = props.children, $[2] = props.text._key, $[3] = props.text._type, $[4] = t0) : t0 = $[4], t0;\n}\nconst PortableTextEditorContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null), usePortableTextEditor = () => {\n  const editor = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(PortableTextEditorContext);\n  if (!editor)\n    throw new Error(\"The `usePortableTextEditor` hook must be used inside the <PortableTextEditor> component's context.\");\n  return editor;\n}, IS_MAC = typeof window < \"u\" && /Mac|iPod|iPhone|iPad/.test(window.navigator.userAgent), modifiers = {\n  alt: \"altKey\",\n  control: \"ctrlKey\",\n  meta: \"metaKey\",\n  shift: \"shiftKey\"\n}, aliases = {\n  add: \"+\",\n  break: \"pause\",\n  cmd: \"meta\",\n  command: \"meta\",\n  ctl: \"control\",\n  ctrl: \"control\",\n  del: \"delete\",\n  down: \"arrowdown\",\n  esc: \"escape\",\n  ins: \"insert\",\n  left: \"arrowleft\",\n  mod: IS_MAC ? \"meta\" : \"control\",\n  opt: \"alt\",\n  option: \"alt\",\n  return: \"enter\",\n  right: \"arrowright\",\n  space: \" \",\n  spacebar: \" \",\n  up: \"arrowup\",\n  win: \"meta\",\n  windows: \"meta\"\n}, keyCodes = {\n  backspace: 8,\n  tab: 9,\n  enter: 13,\n  shift: 16,\n  control: 17,\n  alt: 18,\n  pause: 19,\n  capslock: 20,\n  escape: 27,\n  \" \": 32,\n  pageup: 33,\n  pagedown: 34,\n  end: 35,\n  home: 36,\n  arrowleft: 37,\n  arrowup: 38,\n  arrowright: 39,\n  arrowdown: 40,\n  insert: 45,\n  delete: 46,\n  meta: 91,\n  numlock: 144,\n  scrolllock: 145,\n  \";\": 186,\n  \"=\": 187,\n  \",\": 188,\n  \"-\": 189,\n  \".\": 190,\n  \"/\": 191,\n  \"`\": 192,\n  \"[\": 219,\n  \"\\\\\": 220,\n  \"]\": 221,\n  \"'\": 222,\n  f1: 112,\n  f2: 113,\n  f3: 114,\n  f4: 115,\n  f5: 116,\n  f6: 117,\n  f7: 118,\n  f8: 119,\n  f9: 120,\n  f10: 121,\n  f11: 122,\n  f12: 123,\n  f13: 124,\n  f14: 125,\n  f15: 126,\n  f16: 127,\n  f17: 128,\n  f18: 129,\n  f19: 130,\n  f20: 131\n};\nfunction isHotkey(hotkey, event) {\n  return compareHotkey(parseHotkey(hotkey), event);\n}\nfunction parseHotkey(hotkey) {\n  const parsedHotkey = {\n    altKey: !1,\n    ctrlKey: !1,\n    metaKey: !1,\n    shiftKey: !1\n  }, hotkeySegments = hotkey.replace(\"++\", \"+add\").split(\"+\");\n  for (const rawHotkeySegment of hotkeySegments) {\n    const optional = rawHotkeySegment.endsWith(\"?\") && rawHotkeySegment.length > 1, hotkeySegment = optional ? rawHotkeySegment.slice(0, -1) : rawHotkeySegment, keyName = toKeyName(hotkeySegment), modifier = modifiers[keyName], alias = aliases[hotkeySegment], code2 = keyCodes[keyName];\n    if (hotkeySegment.length > 1 && modifier === void 0 && alias === void 0 && code2 === void 0)\n      throw new TypeError(`Unknown modifier: \"${hotkeySegment}\"`);\n    (hotkeySegments.length === 1 || modifier === void 0) && (parsedHotkey.key = keyName, parsedHotkey.keyCode = toKeyCode(hotkeySegment)), modifier !== void 0 && (parsedHotkey[modifier] = optional ? null : !0);\n  }\n  return parsedHotkey;\n}\nfunction compareHotkey(parsedHotkey, event) {\n  return (parsedHotkey.altKey == null || parsedHotkey.altKey === event.altKey) && (parsedHotkey.ctrlKey == null || parsedHotkey.ctrlKey === event.ctrlKey) && (parsedHotkey.metaKey == null || parsedHotkey.metaKey === event.metaKey) && (parsedHotkey.shiftKey == null || parsedHotkey.shiftKey === event.shiftKey) ? parsedHotkey.keyCode !== void 0 && event.keyCode !== void 0 ? parsedHotkey.keyCode === 91 && event.keyCode === 93 ? !0 : parsedHotkey.keyCode === event.keyCode : parsedHotkey.keyCode === event.keyCode || parsedHotkey.key === event.key.toLowerCase() : !1;\n}\nfunction toKeyCode(name) {\n  const keyName = toKeyName(name);\n  return keyCodes[keyName] ?? keyName.toUpperCase().charCodeAt(0);\n}\nfunction toKeyName(name) {\n  const keyName = name.toLowerCase();\n  return aliases[keyName] ?? keyName;\n}\nconst debug$f = debugWithName(\"plugin:withHotKeys\");\nfunction createWithHotkeys(editorActor, portableTextEditor, hotkeysFromOptions) {\n  const reservedHotkeys = [\"enter\", \"tab\", \"shift\", \"delete\", \"end\"], activeHotkeys = hotkeysFromOptions ?? {};\n  return function(editor) {\n    return editor.pteWithHotKeys = (event) => {\n      Object.keys(activeHotkeys).forEach((cat) => {\n        if (cat === \"marks\")\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey))\n              throw new Error(`The hotkey ${hotkey} is reserved!`);\n            if (isHotkey(hotkey, event.nativeEvent)) {\n              event.preventDefault();\n              const possibleMark = activeHotkeys[cat];\n              if (possibleMark) {\n                const mark = possibleMark[hotkey];\n                debug$f(`HotKey ${hotkey} to toggle ${mark}`), editorActor.send({\n                  type: \"behavior event\",\n                  behaviorEvent: {\n                    type: \"decorator.toggle\",\n                    decorator: mark\n                  },\n                  editor\n                });\n              }\n            }\n          }\n        if (cat === \"custom\")\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey))\n              throw new Error(`The hotkey ${hotkey} is reserved!`);\n            if (isHotkey(hotkey, event.nativeEvent)) {\n              const possibleCommand = activeHotkeys[cat];\n              if (possibleCommand) {\n                const command = possibleCommand[hotkey];\n                command(event, portableTextEditor);\n              }\n            }\n          }\n      });\n    }, editor;\n  };\n}\nfunction moveRangeByOperation(range, operation) {\n  const anchor = slate__WEBPACK_IMPORTED_MODULE_14__.Point.transform(range.anchor, operation), focus = slate__WEBPACK_IMPORTED_MODULE_14__.Point.transform(range.focus, operation);\n  return anchor === null || focus === null ? null : slate__WEBPACK_IMPORTED_MODULE_14__.Point.equals(anchor, range.anchor) && slate__WEBPACK_IMPORTED_MODULE_14__.Point.equals(focus, range.focus) ? range : {\n    anchor,\n    focus\n  };\n}\nconst slateOperationCallback = ({\n  input,\n  sendBack\n}) => {\n  const originalApply = input.slateEditor.apply;\n  return input.slateEditor.apply = (op) => {\n    op.type !== \"set_selection\" && sendBack({\n      type: \"slate operation\",\n      operation: op\n    }), originalApply(op);\n  }, () => {\n    input.slateEditor.apply = originalApply;\n  };\n}, rangeDecorationsMachine = (0,xstate__WEBPACK_IMPORTED_MODULE_24__.setup)({\n  types: {\n    context: {},\n    input: {},\n    events: {}\n  },\n  actions: {\n    \"update pending range decorations\": (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n      pendingRangeDecorations: ({\n        context,\n        event\n      }) => event.type !== \"range decorations updated\" ? context.pendingRangeDecorations : event.rangeDecorations\n    }),\n    \"set up initial range decorations\": ({\n      context\n    }) => {\n      const rangeDecorationState = [];\n      for (const rangeDecoration of context.pendingRangeDecorations) {\n        const slateRange = toSlateRange({\n          context: {\n            schema: context.schema,\n            value: context.slateEditor.value,\n            selection: rangeDecoration.selection\n          },\n          blockIndexMap: context.slateEditor.blockIndexMap\n        });\n        if (!slate__WEBPACK_IMPORTED_MODULE_14__.Range.isRange(slateRange)) {\n          rangeDecoration.onMoved?.({\n            newSelection: null,\n            rangeDecoration,\n            origin: \"local\"\n          });\n          continue;\n        }\n        rangeDecorationState.push({\n          rangeDecoration,\n          ...slateRange\n        });\n      }\n      context.slateEditor.decoratedRanges = rangeDecorationState;\n    },\n    \"update range decorations\": ({\n      context,\n      event\n    }) => {\n      if (event.type !== \"range decorations updated\")\n        return;\n      const rangeDecorationState = [];\n      for (const rangeDecoration of event.rangeDecorations) {\n        const slateRange = toSlateRange({\n          context: {\n            schema: context.schema,\n            value: context.slateEditor.value,\n            selection: rangeDecoration.selection\n          },\n          blockIndexMap: context.slateEditor.blockIndexMap\n        });\n        if (!slate__WEBPACK_IMPORTED_MODULE_14__.Range.isRange(slateRange)) {\n          rangeDecoration.onMoved?.({\n            newSelection: null,\n            rangeDecoration,\n            origin: \"local\"\n          });\n          continue;\n        }\n        rangeDecorationState.push({\n          rangeDecoration,\n          ...slateRange\n        });\n      }\n      context.slateEditor.decoratedRanges = rangeDecorationState;\n    },\n    \"move range decorations\": ({\n      context,\n      event\n    }) => {\n      if (event.type !== \"slate operation\")\n        return;\n      const rangeDecorationState = [];\n      for (const decoratedRange of context.slateEditor.decoratedRanges) {\n        const slateRange = toSlateRange({\n          context: {\n            schema: context.schema,\n            value: context.slateEditor.value,\n            selection: decoratedRange.rangeDecoration.selection\n          },\n          blockIndexMap: context.slateEditor.blockIndexMap\n        });\n        if (!slate__WEBPACK_IMPORTED_MODULE_14__.Range.isRange(slateRange)) {\n          decoratedRange.rangeDecoration.onMoved?.({\n            newSelection: null,\n            rangeDecoration: decoratedRange.rangeDecoration,\n            origin: \"local\"\n          });\n          continue;\n        }\n        let newRange;\n        if (newRange = moveRangeByOperation(slateRange, event.operation), newRange && newRange !== slateRange || newRange === null && slateRange) {\n          const newRangeSelection = newRange ? slateRangeToSelection({\n            schema: context.schema,\n            editor: context.slateEditor,\n            range: newRange\n          }) : null;\n          decoratedRange.rangeDecoration.onMoved?.({\n            newSelection: newRangeSelection,\n            rangeDecoration: decoratedRange.rangeDecoration,\n            origin: \"local\"\n          });\n        }\n        newRange !== null && rangeDecorationState.push({\n          ...newRange || slateRange,\n          rangeDecoration: {\n            ...decoratedRange.rangeDecoration,\n            selection: slateRangeToSelection({\n              schema: context.schema,\n              editor: context.slateEditor,\n              range: newRange\n            })\n          }\n        });\n      }\n      context.slateEditor.decoratedRanges = rangeDecorationState;\n    },\n    \"assign readOnly\": (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n      readOnly: ({\n        context,\n        event\n      }) => event.type !== \"update read only\" ? context.readOnly : event.readOnly\n    }),\n    \"update decorate\": (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n      decorate: ({\n        context\n      }) => ({\n        fn: createDecorate(context.schema, context.slateEditor)\n      })\n    })\n  },\n  actors: {\n    \"slate operation listener\": (0,xstate__WEBPACK_IMPORTED_MODULE_26__.fromCallback)(slateOperationCallback)\n  },\n  guards: {\n    \"has pending range decorations\": ({\n      context\n    }) => context.pendingRangeDecorations.length > 0,\n    \"has range decorations\": ({\n      context\n    }) => context.slateEditor.decoratedRanges.length > 0,\n    \"has different decorations\": ({\n      context,\n      event\n    }) => {\n      if (event.type !== \"range decorations updated\")\n        return !1;\n      const existingRangeDecorations = context.slateEditor.decoratedRanges.map((decoratedRange) => ({\n        anchor: decoratedRange.rangeDecoration.selection?.anchor,\n        focus: decoratedRange.rangeDecoration.selection?.focus,\n        payload: decoratedRange.rangeDecoration.payload\n      })), newRangeDecorations = event.rangeDecorations.map((rangeDecoration) => ({\n        anchor: rangeDecoration.selection?.anchor,\n        focus: rangeDecoration.selection?.focus,\n        payload: rangeDecoration.payload\n      }));\n      return !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__(existingRangeDecorations, newRangeDecorations);\n    },\n    \"not read only\": ({\n      context\n    }) => !context.readOnly,\n    \"should skip setup\": ({\n      context\n    }) => context.skipSetup\n  }\n}).createMachine({\n  id: \"range decorations\",\n  context: ({\n    input\n  }) => ({\n    readOnly: input.readOnly,\n    pendingRangeDecorations: input.rangeDecorations,\n    decoratedRanges: [],\n    skipSetup: input.skipSetup,\n    schema: input.schema,\n    slateEditor: input.slateEditor,\n    decorate: {\n      fn: createDecorate(input.schema, input.slateEditor)\n    }\n  }),\n  invoke: {\n    src: \"slate operation listener\",\n    input: ({\n      context\n    }) => ({\n      slateEditor: context.slateEditor\n    })\n  },\n  on: {\n    \"update read only\": {\n      actions: [\"assign readOnly\"]\n    }\n  },\n  initial: \"setting up\",\n  states: {\n    \"setting up\": {\n      always: [{\n        guard: (0,xstate__WEBPACK_IMPORTED_MODULE_27__.d)([\"should skip setup\", \"has pending range decorations\"]),\n        target: \"ready\",\n        actions: [\"set up initial range decorations\", \"update decorate\"]\n      }, {\n        guard: \"should skip setup\",\n        target: \"ready\"\n      }],\n      on: {\n        \"range decorations updated\": {\n          actions: [\"update pending range decorations\"]\n        },\n        ready: [{\n          target: \"ready\",\n          guard: \"has pending range decorations\",\n          actions: [\"set up initial range decorations\", \"update decorate\"]\n        }, {\n          target: \"ready\"\n        }]\n      }\n    },\n    ready: {\n      initial: \"idle\",\n      on: {\n        \"range decorations updated\": {\n          target: \".idle\",\n          guard: \"has different decorations\",\n          actions: [\"update range decorations\", \"update decorate\"]\n        }\n      },\n      states: {\n        idle: {\n          on: {\n            \"slate operation\": {\n              target: \"moving range decorations\",\n              guard: (0,xstate__WEBPACK_IMPORTED_MODULE_27__.d)([\"has range decorations\", \"not read only\"])\n            }\n          }\n        },\n        \"moving range decorations\": {\n          entry: [\"move range decorations\"],\n          always: {\n            target: \"idle\"\n          }\n        }\n      }\n    }\n  }\n});\nfunction createDecorate(schema, slateEditor) {\n  return function([node, path]) {\n    if (isEqualToEmptyEditor(slateEditor.children, schema))\n      return [{\n        anchor: {\n          path: [0, 0],\n          offset: 0\n        },\n        focus: {\n          path: [0, 0],\n          offset: 0\n        },\n        placeholder: !0\n      }];\n    if (path.length === 0)\n      return [];\n    if (!slate__WEBPACK_IMPORTED_MODULE_14__.Element.isElement(node) || node.children.length === 0)\n      return [];\n    const blockIndex = path.at(0);\n    return blockIndex === void 0 ? [] : slateEditor.decoratedRanges.filter((decoratedRange) => slate__WEBPACK_IMPORTED_MODULE_14__.Range.isCollapsed(decoratedRange) ? node.children.some((_, childIndex) => slate__WEBPACK_IMPORTED_MODULE_14__.Path.equals(decoratedRange.anchor.path, [blockIndex, childIndex]) && slate__WEBPACK_IMPORTED_MODULE_14__.Path.equals(decoratedRange.focus.path, [blockIndex, childIndex])) : slate__WEBPACK_IMPORTED_MODULE_14__.Range.intersection(decoratedRange, {\n      anchor: {\n        path,\n        offset: 0\n      },\n      focus: {\n        path,\n        offset: 0\n      }\n    }) || slate__WEBPACK_IMPORTED_MODULE_14__.Range.includes(decoratedRange, path));\n  };\n}\nconst RelayActorContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({}), debug$e = debugWithName(\"validate selection machine\"), validateSelectionSetup = (0,xstate__WEBPACK_IMPORTED_MODULE_24__.setup)({\n  types: {\n    context: {},\n    input: {},\n    events: {}\n  },\n  guards: {\n    \"pending operations\": ({\n      context\n    }) => context.slateEditor.operations.length > 0\n  }\n}), validateSelectionAction = validateSelectionSetup.createAction(({\n  context,\n  event\n}) => {\n  validateSelection(context.slateEditor, event.editorElement);\n}), validateSelectionMachine = validateSelectionSetup.createMachine({\n  id: \"validate selection\",\n  context: ({\n    input\n  }) => ({\n    slateEditor: input.slateEditor\n  }),\n  initial: \"idle\",\n  states: {\n    idle: {\n      on: {\n        \"validate selection\": [{\n          guard: \"pending operations\",\n          target: \"waiting\"\n        }, {\n          actions: [validateSelectionAction],\n          target: \"idle\"\n        }]\n      }\n    },\n    waiting: {\n      after: {\n        0: [{\n          guard: \"pending operations\",\n          target: \".\",\n          reenter: !0\n        }, {\n          target: \"idle\",\n          actions: [validateSelectionAction]\n        }]\n      },\n      on: {\n        \"validate selection\": {\n          target: \".\",\n          reenter: !0\n        }\n      }\n    }\n  }\n});\nfunction validateSelection(slateEditor, editorElement) {\n  if (!slateEditor.selection)\n    return;\n  let root;\n  try {\n    root = slate_react__WEBPACK_IMPORTED_MODULE_22__.ReactEditor.findDocumentOrShadowRoot(slateEditor);\n  } catch {\n  }\n  if (!root || editorElement !== root.activeElement)\n    return;\n  const domSelection = slate_react__WEBPACK_IMPORTED_MODULE_22__.ReactEditor.getWindow(slateEditor).getSelection();\n  if (!domSelection || domSelection.rangeCount === 0)\n    return;\n  const existingDOMRange = domSelection.getRangeAt(0);\n  try {\n    const newDOMRange = slate_react__WEBPACK_IMPORTED_MODULE_22__.ReactEditor.toDOMRange(slateEditor, slateEditor.selection);\n    (newDOMRange.startOffset !== existingDOMRange.startOffset || newDOMRange.endOffset !== existingDOMRange.endOffset) && (debug$e(\"DOM range out of sync, validating selection\"), domSelection?.removeAllRanges(), domSelection.addRange(newDOMRange));\n  } catch {\n    debug$e(\"Could not resolve selection, selecting top document\"), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.deselect(slateEditor), slateEditor.children.length > 0 && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(slateEditor, slate__WEBPACK_IMPORTED_MODULE_14__.Editor.start(slateEditor, [])), slateEditor.onChange();\n  }\n}\nconst IS_PROCESSING_REMOTE_CHANGES = /* @__PURE__ */ new WeakMap(), KEY_TO_SLATE_ELEMENT = /* @__PURE__ */ new WeakMap(), KEY_TO_VALUE_ELEMENT = /* @__PURE__ */ new WeakMap(), SLATE_TO_PORTABLE_TEXT_RANGE = /* @__PURE__ */ new WeakMap(), debug$d = debugWithName(\"component:Editable\"), PortableTextEditable = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(function(props, forwardedRef) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(174);\n  let hotkeys, onBeforeInput, onBlur, onClick, onCopy, onCut, onDrag, onDragEnd, onDragEnter, onDragLeave, onDragOver, onDragStart, onDrop, onFocus, onPaste, propsSelection, rangeDecorations, renderAnnotation, renderBlock, renderChild, renderDecorator, renderListItem, renderPlaceholder, renderStyle, restProps, scrollSelectionIntoView, spellCheck;\n  $[0] !== props ? ({\n    hotkeys,\n    onBlur,\n    onFocus,\n    onBeforeInput,\n    onPaste,\n    onCopy,\n    onCut,\n    onClick,\n    onDragStart,\n    onDrag,\n    onDragEnd,\n    onDragEnter,\n    onDragOver,\n    onDrop,\n    onDragLeave,\n    rangeDecorations,\n    renderAnnotation,\n    renderBlock,\n    renderChild,\n    renderDecorator,\n    renderListItem,\n    renderPlaceholder,\n    renderStyle,\n    selection: propsSelection,\n    scrollSelectionIntoView,\n    spellCheck,\n    ...restProps\n  } = props, $[0] = props, $[1] = hotkeys, $[2] = onBeforeInput, $[3] = onBlur, $[4] = onClick, $[5] = onCopy, $[6] = onCut, $[7] = onDrag, $[8] = onDragEnd, $[9] = onDragEnter, $[10] = onDragLeave, $[11] = onDragOver, $[12] = onDragStart, $[13] = onDrop, $[14] = onFocus, $[15] = onPaste, $[16] = propsSelection, $[17] = rangeDecorations, $[18] = renderAnnotation, $[19] = renderBlock, $[20] = renderChild, $[21] = renderDecorator, $[22] = renderListItem, $[23] = renderPlaceholder, $[24] = renderStyle, $[25] = restProps, $[26] = scrollSelectionIntoView, $[27] = spellCheck) : (hotkeys = $[1], onBeforeInput = $[2], onBlur = $[3], onClick = $[4], onCopy = $[5], onCut = $[6], onDrag = $[7], onDragEnd = $[8], onDragEnter = $[9], onDragLeave = $[10], onDragOver = $[11], onDragStart = $[12], onDrop = $[13], onFocus = $[14], onPaste = $[15], propsSelection = $[16], rangeDecorations = $[17], renderAnnotation = $[18], renderBlock = $[19], renderChild = $[20], renderDecorator = $[21], renderListItem = $[22], renderPlaceholder = $[23], renderStyle = $[24], restProps = $[25], scrollSelectionIntoView = $[26], spellCheck = $[27]);\n  const portableTextEditor = usePortableTextEditor(), [hasInvalidValue, setHasInvalidValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), editorActor = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(EditorActorContext), relayActor = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(RelayActorContext), readOnly = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_23__.useSelector)(editorActor, _temp), slateEditor = (0,slate_react__WEBPACK_IMPORTED_MODULE_22__.useSlate)();\n  let t0;\n  $[28] !== slateEditor ? (t0 = {\n    input: {\n      slateEditor\n    }\n  }, $[28] = slateEditor, $[29] = t0) : t0 = $[29];\n  const validateSelectionActor = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_23__.useActorRef)(validateSelectionMachine, t0);\n  let t1;\n  $[30] !== rangeDecorations ? (t1 = rangeDecorations ?? [], $[30] = rangeDecorations, $[31] = t1) : t1 = $[31];\n  let t2;\n  $[32] !== editorActor ? (t2 = editorActor.getSnapshot(), $[32] = editorActor, $[33] = t2) : t2 = $[33];\n  const t3 = !editorActor.getSnapshot().matches({\n    setup: \"setting up\"\n  });\n  let t4;\n  $[34] !== readOnly || $[35] !== slateEditor || $[36] !== t1 || $[37] !== t2.context.schema || $[38] !== t3 ? (t4 = {\n    input: {\n      rangeDecorations: t1,\n      readOnly,\n      schema: t2.context.schema,\n      slateEditor,\n      skipSetup: t3\n    }\n  }, $[34] = readOnly, $[35] = slateEditor, $[36] = t1, $[37] = t2.context.schema, $[38] = t3, $[39] = t4) : t4 = $[39];\n  const rangeDecorationsActor = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_23__.useActorRef)(rangeDecorationsMachine, t4), decorate = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_23__.useSelector)(rangeDecorationsActor, _temp2);\n  let t5, t6;\n  $[40] !== rangeDecorationsActor || $[41] !== readOnly ? (t5 = () => {\n    rangeDecorationsActor.send({\n      type: \"update read only\",\n      readOnly\n    });\n  }, t6 = [rangeDecorationsActor, readOnly], $[40] = rangeDecorationsActor, $[41] = readOnly, $[42] = t5, $[43] = t6) : (t5 = $[42], t6 = $[43]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(t5, t6);\n  let t7, t8;\n  $[44] !== rangeDecorations || $[45] !== rangeDecorationsActor ? (t7 = () => {\n    rangeDecorationsActor.send({\n      type: \"range decorations updated\",\n      rangeDecorations: rangeDecorations ?? []\n    });\n  }, t8 = [rangeDecorationsActor, rangeDecorations], $[44] = rangeDecorations, $[45] = rangeDecorationsActor, $[46] = t7, $[47] = t8) : (t7 = $[46], t8 = $[47]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(t7, t8);\n  bb0: {\n    if (readOnly)\n      break bb0;\n    createWithHotkeys(editorActor, portableTextEditor, hotkeys)(slateEditor);\n  }\n  let t10;\n  $[48] !== readOnly || $[49] !== renderBlock || $[50] !== renderChild || $[51] !== renderListItem || $[52] !== renderStyle || $[53] !== spellCheck ? (t10 = (eProps) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderElement, { ...eProps, readOnly, renderBlock, renderChild, renderListItem, renderStyle, spellCheck }), $[48] = readOnly, $[49] = renderBlock, $[50] = renderChild, $[51] = renderListItem, $[52] = renderStyle, $[53] = spellCheck, $[54] = t10) : t10 = $[54];\n  const renderElement = t10;\n  let t11;\n  $[55] !== readOnly || $[56] !== renderAnnotation || $[57] !== renderChild || $[58] !== renderDecorator || $[59] !== renderPlaceholder ? (t11 = (leafProps) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderLeaf, { ...leafProps, readOnly, renderAnnotation, renderChild, renderDecorator, renderPlaceholder }), $[55] = readOnly, $[56] = renderAnnotation, $[57] = renderChild, $[58] = renderDecorator, $[59] = renderPlaceholder, $[60] = t11) : t11 = $[60];\n  const renderLeaf = t11, renderText = _temp3;\n  let t12;\n  $[61] !== editorActor || $[62] !== propsSelection || $[63] !== slateEditor ? (t12 = () => {\n    if (propsSelection) {\n      debug$d(`Selection from props ${JSON.stringify(propsSelection)}`);\n      const normalizedSelection = normalizeSelection(propsSelection, fromSlateValue(slateEditor.children, editorActor.getSnapshot().context.schema.block.name));\n      if (normalizedSelection !== null) {\n        debug$d(`Normalized selection from props ${JSON.stringify(normalizedSelection)}`);\n        const slateRange = toSlateRange({\n          context: {\n            schema: editorActor.getSnapshot().context.schema,\n            value: slateEditor.value,\n            selection: normalizedSelection\n          },\n          blockIndexMap: slateEditor.blockIndexMap\n        });\n        slateRange && (slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(slateEditor, slateRange), slateEditor.operations.some(_temp4) || editorActor.send({\n          type: \"update selection\",\n          selection: normalizedSelection\n        }), slateEditor.onChange());\n      }\n    }\n  }, $[61] = editorActor, $[62] = propsSelection, $[63] = slateEditor, $[64] = t12) : t12 = $[64];\n  const restoreSelectionFromProps = t12;\n  let t13, t14;\n  $[65] !== editorActor || $[66] !== rangeDecorationsActor || $[67] !== restoreSelectionFromProps ? (t13 = () => {\n    const onReady = editorActor.on(\"ready\", () => {\n      rangeDecorationsActor.send({\n        type: \"ready\"\n      }), restoreSelectionFromProps();\n    }), onInvalidValue = editorActor.on(\"invalid value\", () => {\n      setHasInvalidValue(!0);\n    }), onValueChanged = editorActor.on(\"value changed\", () => {\n      setHasInvalidValue(!1);\n    });\n    return () => {\n      onReady.unsubscribe(), onInvalidValue.unsubscribe(), onValueChanged.unsubscribe();\n    };\n  }, t14 = [rangeDecorationsActor, editorActor, restoreSelectionFromProps], $[65] = editorActor, $[66] = rangeDecorationsActor, $[67] = restoreSelectionFromProps, $[68] = t13, $[69] = t14) : (t13 = $[68], t14 = $[69]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(t13, t14);\n  let t15, t16;\n  $[70] !== hasInvalidValue || $[71] !== propsSelection || $[72] !== restoreSelectionFromProps ? (t15 = () => {\n    propsSelection && !hasInvalidValue && restoreSelectionFromProps();\n  }, t16 = [hasInvalidValue, propsSelection, restoreSelectionFromProps], $[70] = hasInvalidValue, $[71] = propsSelection, $[72] = restoreSelectionFromProps, $[73] = t15, $[74] = t16) : (t15 = $[73], t16 = $[74]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(t15, t16);\n  let t17;\n  $[75] !== editorActor || $[76] !== onCopy || $[77] !== slateEditor ? (t17 = (event) => {\n    if (onCopy)\n      onCopy(event) !== void 0 && event.preventDefault();\n    else if (event.nativeEvent.clipboardData) {\n      event.stopPropagation(), event.preventDefault();\n      const selection = slateEditor.selection ? slateRangeToSelection({\n        schema: editorActor.getSnapshot().context.schema,\n        editor: slateEditor,\n        range: slateEditor.selection\n      }) : void 0, position = selection ? {\n        selection\n      } : void 0;\n      if (!position) {\n        console.warn(\"Could not find position for copy event\");\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"clipboard.copy\",\n          originEvent: {\n            dataTransfer: event.nativeEvent.clipboardData\n          },\n          position\n        },\n        editor: slateEditor,\n        nativeEvent: event\n      });\n    }\n  }, $[75] = editorActor, $[76] = onCopy, $[77] = slateEditor, $[78] = t17) : t17 = $[78];\n  const handleCopy = t17;\n  let t18;\n  $[79] !== editorActor || $[80] !== onCut || $[81] !== slateEditor ? (t18 = (event_0) => {\n    if (onCut)\n      onCut(event_0) !== void 0 && event_0.preventDefault();\n    else if (event_0.nativeEvent.clipboardData) {\n      event_0.stopPropagation(), event_0.preventDefault();\n      const selection_0 = editorActor.getSnapshot().context.selection, position_0 = selection_0 ? {\n        selection: selection_0\n      } : void 0;\n      if (!position_0) {\n        console.warn(\"Could not find position for cut event\");\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"clipboard.cut\",\n          originEvent: {\n            dataTransfer: event_0.nativeEvent.clipboardData\n          },\n          position: position_0\n        },\n        editor: slateEditor,\n        nativeEvent: event_0\n      });\n    }\n  }, $[79] = editorActor, $[80] = onCut, $[81] = slateEditor, $[82] = t18) : t18 = $[82];\n  const handleCut = t18;\n  let t19;\n  $[83] !== editorActor || $[84] !== onPaste || $[85] !== portableTextEditor || $[86] !== relayActor || $[87] !== slateEditor ? (t19 = (event_1) => {\n    const value = fromSlateValue(slateEditor.children, editorActor.getSnapshot().context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(slateEditor)), path = (slateEditor.selection ? slateRangeToSelection({\n      schema: editorActor.getSnapshot().context.schema,\n      editor: slateEditor,\n      range: slateEditor.selection\n    }) : null)?.focus.path || [], onPasteResult = onPaste?.({\n      event: event_1,\n      value,\n      path,\n      schemaTypes: portableTextEditor.schemaTypes\n    });\n    if (onPasteResult || !slateEditor.selection)\n      event_1.preventDefault(), relayActor.send({\n        type: \"loading\"\n      }), Promise.resolve(onPasteResult).then((result_1) => {\n        if (debug$d(\"Custom paste function from client resolved\", result_1), !result_1 || !result_1.insert) {\n          debug$d(\"No result from custom paste handler, pasting normally\");\n          const selection_1 = editorActor.getSnapshot().context.selection, position_1 = selection_1 ? {\n            selection: selection_1\n          } : void 0;\n          if (!position_1) {\n            console.warn(\"Could not find position for paste event\");\n            return;\n          }\n          editorActor.send({\n            type: \"behavior event\",\n            behaviorEvent: {\n              type: \"clipboard.paste\",\n              originEvent: {\n                dataTransfer: event_1.clipboardData\n              },\n              position: position_1\n            },\n            editor: slateEditor,\n            nativeEvent: event_1\n          });\n        } else\n          result_1.insert ? editorActor.send({\n            type: \"behavior event\",\n            behaviorEvent: {\n              type: \"insert.blocks\",\n              blocks: (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.parseBlocks)({\n                context: {\n                  keyGenerator: editorActor.getSnapshot().context.keyGenerator,\n                  schema: editorActor.getSnapshot().context.schema\n                },\n                blocks: result_1.insert,\n                options: {\n                  removeUnusedMarkDefs: !0,\n                  validateFields: !1\n                }\n              }),\n              placement: \"auto\"\n            },\n            editor: slateEditor\n          }) : console.warn(\"Your onPaste function returned something unexpected:\", result_1);\n      }).catch(_temp5).finally(() => {\n        relayActor.send({\n          type: \"done loading\"\n        });\n      });\n    else if (event_1.nativeEvent.clipboardData) {\n      event_1.preventDefault(), event_1.stopPropagation();\n      const selection_2 = editorActor.getSnapshot().context.selection, position_2 = selection_2 ? {\n        selection: selection_2\n      } : void 0;\n      if (!position_2) {\n        console.warn(\"Could not find position for paste event\");\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"clipboard.paste\",\n          originEvent: {\n            dataTransfer: event_1.nativeEvent.clipboardData\n          },\n          position: position_2\n        },\n        editor: slateEditor,\n        nativeEvent: event_1\n      });\n    }\n    debug$d(\"No result from custom paste handler, pasting normally\");\n  }, $[83] = editorActor, $[84] = onPaste, $[85] = portableTextEditor, $[86] = relayActor, $[87] = slateEditor, $[88] = t19) : t19 = $[88];\n  const handlePaste = t19;\n  let t20;\n  $[89] !== editorActor || $[90] !== onFocus || $[91] !== relayActor || $[92] !== slateEditor ? (t20 = (event_2) => {\n    onFocus && onFocus(event_2), event_2.isDefaultPrevented() || (relayActor.send({\n      type: \"focused\",\n      event: event_2\n    }), !slateEditor.selection && isEqualToEmptyEditor(slateEditor.children, editorActor.getSnapshot().context.schema) && (slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(slateEditor, slate__WEBPACK_IMPORTED_MODULE_14__.Editor.start(slateEditor, [])), slateEditor.onChange()));\n  }, $[89] = editorActor, $[90] = onFocus, $[91] = relayActor, $[92] = slateEditor, $[93] = t20) : t20 = $[93];\n  const handleOnFocus = t20;\n  let t21;\n  $[94] !== editorActor || $[95] !== onClick || $[96] !== slateEditor ? (t21 = (event_3) => {\n    if (onClick && onClick(event_3), event_3.isDefaultPrevented() || event_3.isPropagationStopped())\n      return;\n    const position_3 = getEventPosition({\n      editorActor,\n      slateEditor,\n      event: event_3.nativeEvent\n    });\n    position_3 && editorActor.send({\n      type: \"behavior event\",\n      behaviorEvent: {\n        type: \"mouse.click\",\n        position: position_3\n      },\n      editor: slateEditor,\n      nativeEvent: event_3\n    });\n  }, $[94] = editorActor, $[95] = onClick, $[96] = slateEditor, $[97] = t21) : t21 = $[97];\n  const handleClick = t21;\n  let t22;\n  $[98] !== onBlur || $[99] !== relayActor ? (t22 = (event_4) => {\n    onBlur && onBlur(event_4), event_4.isPropagationStopped() || relayActor.send({\n      type: \"blurred\",\n      event: event_4\n    });\n  }, $[98] = onBlur, $[99] = relayActor, $[100] = t22) : t22 = $[100];\n  const handleOnBlur = t22;\n  let t23;\n  $[101] !== onBeforeInput ? (t23 = (event_5) => {\n    onBeforeInput && onBeforeInput(event_5);\n  }, $[101] = onBeforeInput, $[102] = t23) : t23 = $[102];\n  const handleOnBeforeInput = t23;\n  let t24;\n  $[103] !== editorActor || $[104] !== props || $[105] !== slateEditor ? (t24 = (event_6) => {\n    props.onKeyDown && props.onKeyDown(event_6), event_6.isDefaultPrevented() || slateEditor.pteWithHotKeys(event_6), event_6.isDefaultPrevented() || editorActor.send({\n      type: \"behavior event\",\n      behaviorEvent: {\n        type: \"keyboard.keydown\",\n        originEvent: {\n          key: event_6.key,\n          code: event_6.code,\n          altKey: event_6.altKey,\n          ctrlKey: event_6.ctrlKey,\n          metaKey: event_6.metaKey,\n          shiftKey: event_6.shiftKey\n        }\n      },\n      editor: slateEditor,\n      nativeEvent: event_6\n    });\n  }, $[103] = editorActor, $[104] = props, $[105] = slateEditor, $[106] = t24) : t24 = $[106];\n  const handleKeyDown = t24;\n  let t25;\n  $[107] !== editorActor || $[108] !== props || $[109] !== slateEditor ? (t25 = (event_7) => {\n    props.onKeyUp && props.onKeyUp(event_7), event_7.isDefaultPrevented() || editorActor.send({\n      type: \"behavior event\",\n      behaviorEvent: {\n        type: \"keyboard.keyup\",\n        originEvent: {\n          key: event_7.key,\n          code: event_7.code,\n          altKey: event_7.altKey,\n          ctrlKey: event_7.ctrlKey,\n          metaKey: event_7.metaKey,\n          shiftKey: event_7.shiftKey\n        }\n      },\n      editor: slateEditor,\n      nativeEvent: event_7\n    });\n  }, $[107] = editorActor, $[108] = props, $[109] = slateEditor, $[110] = t25) : t25 = $[110];\n  const handleKeyUp = t25;\n  let t26;\n  bb1: {\n    if (scrollSelectionIntoView === void 0) {\n      t26 = void 0;\n      break bb1;\n    }\n    if (scrollSelectionIntoView === null) {\n      t26 = lodash_noop_js__WEBPACK_IMPORTED_MODULE_3__;\n      break bb1;\n    }\n    let t272;\n    $[111] !== portableTextEditor || $[112] !== scrollSelectionIntoView ? (t272 = (_editor, domRange) => {\n      scrollSelectionIntoView(portableTextEditor, domRange);\n    }, $[111] = portableTextEditor, $[112] = scrollSelectionIntoView, $[113] = t272) : t272 = $[113], t26 = t272;\n  }\n  const scrollSelectionIntoViewToSlate = t26;\n  let t27, t28;\n  $[114] !== editorActor || $[115] !== slateEditor ? (t27 = () => {\n    const window2 = slate_react__WEBPACK_IMPORTED_MODULE_22__.ReactEditor.getWindow(slateEditor), onDragEnd_0 = () => {\n      editorActor.send({\n        type: \"dragend\"\n      });\n    }, onDrop_0 = () => {\n      editorActor.send({\n        type: \"drop\"\n      });\n    };\n    return window2.document.addEventListener(\"dragend\", onDragEnd_0), window2.document.addEventListener(\"drop\", onDrop_0), () => {\n      window2.document.removeEventListener(\"dragend\", onDragEnd_0), window2.document.removeEventListener(\"drop\", onDrop_0);\n    };\n  }, t28 = [slateEditor, editorActor], $[114] = editorActor, $[115] = slateEditor, $[116] = t27, $[117] = t28) : (t27 = $[116], t28 = $[117]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(t27, t28);\n  let t29;\n  $[118] !== editorActor || $[119] !== onDragStart || $[120] !== slateEditor ? (t29 = (event_8) => {\n    if (onDragStart?.(event_8), event_8.isDefaultPrevented() || event_8.isPropagationStopped())\n      return;\n    const position_4 = getEventPosition({\n      editorActor,\n      slateEditor,\n      event: event_8.nativeEvent\n    });\n    if (!position_4) {\n      console.warn(\"Could not find position for dragstart event\");\n      return;\n    }\n    return editorActor.send({\n      type: \"dragstart\",\n      origin: position_4\n    }), editorActor.send({\n      type: \"behavior event\",\n      behaviorEvent: {\n        type: \"drag.dragstart\",\n        originEvent: {\n          clientX: event_8.clientX,\n          clientY: event_8.clientY,\n          dataTransfer: event_8.dataTransfer\n        },\n        position: position_4\n      },\n      editor: slateEditor\n    }), !0;\n  }, $[118] = editorActor, $[119] = onDragStart, $[120] = slateEditor, $[121] = t29) : t29 = $[121];\n  const handleDragStart = t29;\n  let t30;\n  $[122] !== editorActor || $[123] !== onDrag || $[124] !== slateEditor ? (t30 = (event_9) => {\n    if (onDrag?.(event_9), !(event_9.isDefaultPrevented() || event_9.isPropagationStopped() || !getEventPosition({\n      editorActor,\n      slateEditor,\n      event: event_9.nativeEvent\n    })))\n      return editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"drag.drag\",\n          originEvent: {\n            dataTransfer: event_9.dataTransfer\n          }\n        },\n        editor: slateEditor\n      }), !0;\n  }, $[122] = editorActor, $[123] = onDrag, $[124] = slateEditor, $[125] = t30) : t30 = $[125];\n  const handleDrag = t30;\n  let t31;\n  $[126] !== editorActor || $[127] !== onDragEnd || $[128] !== slateEditor ? (t31 = (event_10) => {\n    if (onDragEnd?.(event_10), !(event_10.isDefaultPrevented() || event_10.isPropagationStopped()))\n      return editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"drag.dragend\",\n          originEvent: {\n            dataTransfer: event_10.dataTransfer\n          }\n        },\n        editor: slateEditor\n      }), !0;\n  }, $[126] = editorActor, $[127] = onDragEnd, $[128] = slateEditor, $[129] = t31) : t31 = $[129];\n  const handleDragEnd = t31;\n  let t32;\n  $[130] !== editorActor || $[131] !== onDragEnter || $[132] !== slateEditor ? (t32 = (event_11) => {\n    if (onDragEnter?.(event_11), event_11.isDefaultPrevented() || event_11.isPropagationStopped())\n      return;\n    const position_6 = getEventPosition({\n      editorActor,\n      slateEditor,\n      event: event_11.nativeEvent\n    });\n    if (position_6)\n      return editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"drag.dragenter\",\n          originEvent: {\n            dataTransfer: event_11.dataTransfer\n          },\n          position: position_6\n        },\n        editor: slateEditor\n      }), !0;\n  }, $[130] = editorActor, $[131] = onDragEnter, $[132] = slateEditor, $[133] = t32) : t32 = $[133];\n  const handleDragEnter = t32;\n  let t33;\n  $[134] !== editorActor || $[135] !== onDragOver || $[136] !== slateEditor ? (t33 = (event_12) => {\n    if (onDragOver?.(event_12), event_12.isDefaultPrevented() || event_12.isPropagationStopped())\n      return;\n    const position_7 = getEventPosition({\n      editorActor,\n      slateEditor,\n      event: event_12.nativeEvent\n    });\n    if (position_7)\n      return editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"drag.dragover\",\n          originEvent: {\n            dataTransfer: event_12.dataTransfer\n          },\n          dragOrigin: editorActor.getSnapshot().context.internalDrag?.origin,\n          position: position_7\n        },\n        editor: slateEditor,\n        nativeEvent: event_12\n      }), !0;\n  }, $[134] = editorActor, $[135] = onDragOver, $[136] = slateEditor, $[137] = t33) : t33 = $[137];\n  const handleDragOver = t33;\n  let t34;\n  $[138] !== editorActor || $[139] !== onDrop || $[140] !== slateEditor ? (t34 = (event_13) => {\n    if (onDrop?.(event_13), event_13.isDefaultPrevented() || event_13.isPropagationStopped())\n      return;\n    const position_8 = getEventPosition({\n      editorActor,\n      slateEditor,\n      event: event_13.nativeEvent\n    });\n    if (!position_8) {\n      console.warn(\"Could not find position for drop event\");\n      return;\n    }\n    return editorActor.send({\n      type: \"behavior event\",\n      behaviorEvent: {\n        type: \"drag.drop\",\n        originEvent: {\n          dataTransfer: event_13.dataTransfer\n        },\n        dragOrigin: editorActor.getSnapshot().context.internalDrag?.origin,\n        position: position_8\n      },\n      editor: slateEditor,\n      nativeEvent: event_13\n    }), !0;\n  }, $[138] = editorActor, $[139] = onDrop, $[140] = slateEditor, $[141] = t34) : t34 = $[141];\n  const handleDrop = t34;\n  let t35;\n  $[142] !== editorActor || $[143] !== onDragLeave || $[144] !== slateEditor ? (t35 = (event_14) => {\n    if (onDragLeave?.(event_14), !(event_14.isDefaultPrevented() || event_14.isPropagationStopped() || !getEventPosition({\n      editorActor,\n      slateEditor,\n      event: event_14.nativeEvent\n    })))\n      return editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"drag.dragleave\",\n          originEvent: {\n            dataTransfer: event_14.dataTransfer\n          }\n        },\n        editor: slateEditor\n      }), !0;\n  }, $[142] = editorActor, $[143] = onDragLeave, $[144] = slateEditor, $[145] = t35) : t35 = $[145];\n  const handleDragLeave = t35;\n  let t36;\n  $[146] !== forwardedRef || $[147] !== validateSelectionActor ? (t36 = (editorElement) => {\n    if (typeof forwardedRef == \"function\" ? forwardedRef(editorElement) : forwardedRef && (forwardedRef.current = editorElement), editorElement) {\n      const mutationObserver = new MutationObserver(() => {\n        validateSelectionActor.send({\n          type: \"validate selection\",\n          editorElement\n        });\n      });\n      return mutationObserver.observe(editorElement, {\n        attributeOldValue: !1,\n        attributes: !1,\n        characterData: !1,\n        childList: !0,\n        subtree: !0\n      }), () => {\n        mutationObserver.disconnect();\n      };\n    }\n  }, $[146] = forwardedRef, $[147] = validateSelectionActor, $[148] = t36) : t36 = $[148];\n  const callbackRef = t36;\n  if (!portableTextEditor)\n    return null;\n  let t37;\n  return $[149] !== callbackRef || $[150] !== decorate || $[151] !== handleClick || $[152] !== handleCopy || $[153] !== handleCut || $[154] !== handleDrag || $[155] !== handleDragEnd || $[156] !== handleDragEnter || $[157] !== handleDragLeave || $[158] !== handleDragOver || $[159] !== handleDragStart || $[160] !== handleDrop || $[161] !== handleKeyDown || $[162] !== handleKeyUp || $[163] !== handleOnBeforeInput || $[164] !== handleOnBlur || $[165] !== handleOnFocus || $[166] !== handlePaste || $[167] !== hasInvalidValue || $[168] !== readOnly || $[169] !== renderElement || $[170] !== renderLeaf || $[171] !== restProps || $[172] !== scrollSelectionIntoViewToSlate ? (t37 = hasInvalidValue ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(slate_react__WEBPACK_IMPORTED_MODULE_22__.Editable, { ...restProps, ref: callbackRef, \"data-read-only\": readOnly, autoFocus: !1, className: restProps.className || \"pt-editable\", decorate, onBlur: handleOnBlur, onCopy: handleCopy, onCut: handleCut, onClick: handleClick, onDOMBeforeInput: handleOnBeforeInput, onDragStart: handleDragStart, onDrag: handleDrag, onDragEnd: handleDragEnd, onDragEnter: handleDragEnter, onDragOver: handleDragOver, onDrop: handleDrop, onDragLeave: handleDragLeave, onFocus: handleOnFocus, onKeyDown: handleKeyDown, onKeyUp: handleKeyUp, onPaste: handlePaste, readOnly, renderPlaceholder: void 0, renderElement, renderLeaf, renderText, scrollSelectionIntoView: scrollSelectionIntoViewToSlate }), $[149] = callbackRef, $[150] = decorate, $[151] = handleClick, $[152] = handleCopy, $[153] = handleCut, $[154] = handleDrag, $[155] = handleDragEnd, $[156] = handleDragEnter, $[157] = handleDragLeave, $[158] = handleDragOver, $[159] = handleDragStart, $[160] = handleDrop, $[161] = handleKeyDown, $[162] = handleKeyUp, $[163] = handleOnBeforeInput, $[164] = handleOnBlur, $[165] = handleOnFocus, $[166] = handlePaste, $[167] = hasInvalidValue, $[168] = readOnly, $[169] = renderElement, $[170] = renderLeaf, $[171] = restProps, $[172] = scrollSelectionIntoViewToSlate, $[173] = t37) : t37 = $[173], t37;\n});\nPortableTextEditable.displayName = \"ForwardRef(PortableTextEditable)\";\nfunction _temp(s) {\n  return s.matches({\n    \"edit mode\": \"read only\"\n  });\n}\nfunction _temp2(s_0) {\n  return s_0.context.decorate?.fn;\n}\nfunction _temp3(props_0) {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderText, { ...props_0 });\n}\nfunction _temp4(o) {\n  return o.type === \"set_selection\";\n}\nfunction _temp5(error) {\n  return console.warn(error), error;\n}\nconst forEachActor = (actorRef, callback) => {\n  callback(actorRef);\n  const children = actorRef.getSnapshot().children;\n  children && Object.values(children).forEach((child) => {\n    forEachActor(child, callback);\n  });\n};\nfunction stopActor(actorRef) {\n  const persistedSnapshots = [];\n  forEachActor(actorRef, (ref) => {\n    persistedSnapshots.push([ref, ref.getSnapshot()]), ref.observers = /* @__PURE__ */ new Set();\n  });\n  const systemSnapshot = actorRef.system.getSnapshot?.();\n  actorRef.stop(), actorRef.system._snapshot = systemSnapshot, persistedSnapshots.forEach(([ref, snapshot]) => {\n    ref._processingStatus = 0, ref._snapshot = snapshot;\n  });\n}\nconst converterJson = {\n  mimeType: \"application/json\",\n  serialize: ({\n    snapshot,\n    event\n  }) => {\n    const portableTextConverter = snapshot.context.converters.find((converter) => converter.mimeType === \"application/x-portable-text\");\n    return portableTextConverter ? {\n      ...portableTextConverter.serialize({\n        snapshot,\n        event\n      }),\n      mimeType: \"application/json\",\n      originEvent: event.originEvent\n    } : {\n      type: \"serialization.failure\",\n      mimeType: \"application/json\",\n      originEvent: event.originEvent,\n      reason: \"No application/x-portable-text Converter found\"\n    };\n  },\n  deserialize: ({\n    snapshot,\n    event\n  }) => {\n    const portableTextConverter = snapshot.context.converters.find((converter) => converter.mimeType === \"application/x-portable-text\");\n    return portableTextConverter ? {\n      ...portableTextConverter.deserialize({\n        snapshot,\n        event\n      }),\n      mimeType: \"application/json\"\n    } : {\n      type: \"deserialization.failure\",\n      mimeType: \"application/json\",\n      reason: \"No application/x-portable-text Converter found\"\n    };\n  }\n}, converterPortableText = {\n  mimeType: \"application/x-portable-text\",\n  serialize: ({\n    snapshot,\n    event\n  }) => {\n    if (!snapshot.context.selection)\n      return {\n        type: \"serialization.failure\",\n        mimeType: \"application/x-portable-text\",\n        originEvent: event.originEvent,\n        reason: \"No selection\"\n      };\n    const blocks = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getSelectedValue)(snapshot);\n    return blocks.length === 0 ? {\n      type: \"serialization.failure\",\n      mimeType: \"application/x-portable-text\",\n      reason: \"No blocks serialized\",\n      originEvent: event.originEvent\n    } : {\n      type: \"serialization.success\",\n      data: JSON.stringify(blocks),\n      mimeType: \"application/x-portable-text\",\n      originEvent: event.originEvent\n    };\n  },\n  deserialize: ({\n    snapshot,\n    event\n  }) => {\n    const blocks = JSON.parse(event.data);\n    if (!Array.isArray(blocks))\n      return {\n        type: \"deserialization.failure\",\n        mimeType: \"application/x-portable-text\",\n        reason: \"Data is not an array\"\n      };\n    const parsedBlocks = blocks.flatMap((block) => {\n      const parsedBlock = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.parseBlock)({\n        context: snapshot.context,\n        block,\n        options: {\n          removeUnusedMarkDefs: !0,\n          validateFields: !1\n        }\n      });\n      return parsedBlock ? [parsedBlock] : [];\n    });\n    return parsedBlocks.length === 0 && blocks.length > 0 ? {\n      type: \"deserialization.failure\",\n      mimeType: \"application/x-portable-text\",\n      reason: \"No blocks were parsed\"\n    } : {\n      type: \"deserialization.success\",\n      data: parsedBlocks,\n      mimeType: \"application/x-portable-text\"\n    };\n  }\n};\nfunction createConverterTextHtml(legacySchema) {\n  return {\n    mimeType: \"text/html\",\n    serialize: ({\n      snapshot,\n      event\n    }) => {\n      if (!snapshot.context.selection)\n        return {\n          type: \"serialization.failure\",\n          mimeType: \"text/html\",\n          originEvent: event.originEvent,\n          reason: \"No selection\"\n        };\n      const blocks = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getSelectedValue)(snapshot), html = (0,_portabletext_to_html__WEBPACK_IMPORTED_MODULE_28__.toHTML)(blocks, {\n        onMissingComponent: !1,\n        components: {\n          unknownType: ({\n            children\n          }) => children !== void 0 ? `${children}` : \"\"\n        }\n      });\n      return html === \"\" ? {\n        type: \"serialization.failure\",\n        mimeType: \"text/html\",\n        originEvent: event.originEvent,\n        reason: \"Serialized HTML is empty\"\n      } : {\n        type: \"serialization.success\",\n        data: html,\n        mimeType: \"text/html\",\n        originEvent: event.originEvent\n      };\n    },\n    deserialize: ({\n      snapshot,\n      event\n    }) => {\n      const parsedBlocks = (0,_portabletext_block_tools__WEBPACK_IMPORTED_MODULE_29__.htmlToBlocks)(event.data, legacySchema.portableText, {\n        keyGenerator: snapshot.context.keyGenerator,\n        unstable_whitespaceOnPasteMode: legacySchema.block.options.unstable_whitespaceOnPasteMode\n      }).flatMap((block) => {\n        const parsedBlock = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.parseBlock)({\n          context: snapshot.context,\n          block,\n          options: {\n            removeUnusedMarkDefs: !0,\n            validateFields: !1\n          }\n        });\n        return parsedBlock ? [parsedBlock] : [];\n      });\n      return parsedBlocks.length === 0 ? {\n        type: \"deserialization.failure\",\n        mimeType: \"text/html\",\n        reason: \"No blocks deserialized\"\n      } : {\n        type: \"deserialization.success\",\n        data: parsedBlocks,\n        mimeType: \"text/html\"\n      };\n    }\n  };\n}\nfunction createConverterTextPlain(legacySchema) {\n  return {\n    mimeType: \"text/plain\",\n    serialize: ({\n      snapshot,\n      event\n    }) => snapshot.context.selection ? {\n      type: \"serialization.success\",\n      data: (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getSelectedValue)(snapshot).map((block) => (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(snapshot.context, block) ? block.children.map((child) => child._type === snapshot.context.schema.span.name ? child.text : event.originEvent === \"drag.dragstart\" ? `[${snapshot.context.schema.inlineObjects.find((inlineObjectType) => inlineObjectType.name === child._type)?.title ?? \"Object\"}]` : \"\").join(\"\") : event.originEvent === \"drag.dragstart\" ? `[${snapshot.context.schema.blockObjects.find((blockObjectType) => blockObjectType.name === block._type)?.title ?? \"Object\"}]` : \"\").filter((block) => block !== \"\").join(`\n\n`),\n      mimeType: \"text/plain\",\n      originEvent: event.originEvent\n    } : {\n      type: \"serialization.failure\",\n      mimeType: \"text/plain\",\n      originEvent: event.originEvent,\n      reason: \"No selection\"\n    },\n    deserialize: ({\n      snapshot,\n      event\n    }) => {\n      const textToHtml = `<html><body>${escapeHtml(event.data).split(/\\n{2,}/).map((line) => line ? `<p>${line.replace(/(?:\\r\\n|\\r|\\n)/g, \"<br/>\")}</p>` : \"<p></p>\").join(\"\")}</body></html>`, parsedBlocks = (0,_portabletext_block_tools__WEBPACK_IMPORTED_MODULE_29__.htmlToBlocks)(textToHtml, legacySchema.portableText, {\n        keyGenerator: snapshot.context.keyGenerator\n      }).flatMap((block) => {\n        const parsedBlock = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.parseBlock)({\n          context: snapshot.context,\n          block,\n          options: {\n            removeUnusedMarkDefs: !0,\n            validateFields: !1\n          }\n        });\n        return parsedBlock ? [parsedBlock] : [];\n      });\n      return parsedBlocks.length === 0 ? {\n        type: \"deserialization.failure\",\n        mimeType: \"text/plain\",\n        reason: \"No blocks deserialized\"\n      } : {\n        type: \"deserialization.success\",\n        data: parsedBlocks,\n        mimeType: \"text/plain\"\n      };\n    }\n  };\n}\nconst entityMap = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\",\n  \"/\": \"&#x2F;\",\n  \"`\": \"&#x60;\",\n  \"=\": \"&#x3D;\"\n};\nfunction escapeHtml(str) {\n  return String(str).replace(/[&<>\"'`=/]/g, (s) => entityMap[s]);\n}\nfunction createCoreConverters(legacySchema) {\n  return [converterJson, converterPortableText, createConverterTextHtml(legacySchema), createConverterTextPlain(legacySchema)];\n}\nfunction compileType(rawType) {\n  return _sanity_schema__WEBPACK_IMPORTED_MODULE_30__.Schema.compile({\n    name: \"blockTypeSchema\",\n    types: [rawType]\n  }).get(rawType.name);\n}\nconst levelIndexMaps = /* @__PURE__ */ new Map();\nfunction buildIndexMaps(context, {\n  blockIndexMap,\n  listIndexMap\n}) {\n  blockIndexMap.clear(), listIndexMap.clear(), levelIndexMaps.clear();\n  let previousListItem;\n  for (let blockIndex = 0; blockIndex < context.value.length; blockIndex++) {\n    const block = context.value.at(blockIndex);\n    if (block === void 0)\n      continue;\n    if (blockIndexMap.set(block._key, blockIndex), !(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(context, block)) {\n      levelIndexMaps.clear(), previousListItem = void 0;\n      continue;\n    }\n    if (block.listItem === void 0 || block.level === void 0) {\n      levelIndexMaps.clear(), previousListItem = void 0;\n      continue;\n    }\n    if (!previousListItem) {\n      const levelIndexMap2 = levelIndexMaps.get(block.listItem) ?? /* @__PURE__ */ new Map();\n      levelIndexMap2.set(block.level, 1), levelIndexMaps.set(block.listItem, levelIndexMap2), listIndexMap.set(block._key, 1), previousListItem = {\n        listItem: block.listItem,\n        level: block.level\n      };\n      continue;\n    }\n    if (previousListItem.listItem === block.listItem && previousListItem.level < block.level) {\n      const levelIndexMap2 = levelIndexMaps.get(block.listItem) ?? /* @__PURE__ */ new Map();\n      levelIndexMap2.set(block.level, 1), levelIndexMaps.set(block.listItem, levelIndexMap2), listIndexMap.set(block._key, 1), previousListItem = {\n        listItem: block.listItem,\n        level: block.level\n      };\n      continue;\n    }\n    levelIndexMaps.forEach((levelIndexMap2, listItem) => {\n      if (listItem === block.listItem)\n        return;\n      const levelsToDelete = [];\n      levelIndexMap2.forEach((_, level) => {\n        level >= block.level && levelsToDelete.push(level);\n      }), levelsToDelete.forEach((level) => {\n        levelIndexMap2.delete(level);\n      });\n    });\n    const levelIndexMap = levelIndexMaps.get(block.listItem) ?? /* @__PURE__ */ new Map(), levelCounter = levelIndexMap.get(block.level) ?? 0;\n    levelIndexMap.set(block.level, levelCounter + 1), levelIndexMaps.set(block.listItem, levelIndexMap), listIndexMap.set(block._key, levelCounter + 1), previousListItem = {\n      listItem: block.listItem,\n      level: block.level\n    };\n  }\n}\nfunction createPlaceholderBlock(context) {\n  return {\n    _type: context.schema.block.name,\n    _key: context.keyGenerator(),\n    style: context.schema.styles[0].name ?? \"normal\",\n    markDefs: [],\n    children: [{\n      _type: context.schema.span.name,\n      _key: context.keyGenerator(),\n      text: \"\",\n      marks: []\n    }]\n  };\n}\nfunction getPreviousSpan({\n  editor,\n  blockPath,\n  spanPath\n}) {\n  let previousSpan;\n  for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_14__.Node.children(editor, blockPath, {\n    reverse: !0\n  }))\n    if (editor.isTextSpan(child) && slate__WEBPACK_IMPORTED_MODULE_14__.Path.isBefore(childPath, spanPath)) {\n      previousSpan = child;\n      break;\n    }\n  return previousSpan;\n}\nfunction getNextSpan({\n  editor,\n  blockPath,\n  spanPath\n}) {\n  let nextSpan;\n  for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_14__.Node.children(editor, blockPath))\n    if (editor.isTextSpan(child) && slate__WEBPACK_IMPORTED_MODULE_14__.Path.isAfter(childPath, spanPath)) {\n      nextSpan = child;\n      break;\n    }\n  return nextSpan;\n}\nfunction withRemoteChanges(editor, fn) {\n  const prev = isChangingRemotely(editor) || !1;\n  IS_PROCESSING_REMOTE_CHANGES.set(editor, !0), fn(), IS_PROCESSING_REMOTE_CHANGES.set(editor, prev);\n}\nfunction isChangingRemotely(editor) {\n  return IS_PROCESSING_REMOTE_CHANGES.get(editor);\n}\nconst IS_UDOING = /* @__PURE__ */ new WeakMap(), IS_REDOING = /* @__PURE__ */ new WeakMap();\nfunction withUndoing(editor, fn) {\n  const prev = isUndoing(editor);\n  IS_UDOING.set(editor, !0), fn(), IS_UDOING.set(editor, prev);\n}\nfunction isUndoing(editor) {\n  return IS_UDOING.get(editor) ?? !1;\n}\nfunction setIsUndoing(editor, isUndoing2) {\n  IS_UDOING.set(editor, isUndoing2);\n}\nfunction withRedoing(editor, fn) {\n  const prev = isRedoing(editor);\n  IS_REDOING.set(editor, !0), fn(), IS_REDOING.set(editor, prev);\n}\nfunction isRedoing(editor) {\n  return IS_REDOING.get(editor) ?? !1;\n}\nfunction setIsRedoing(editor, isRedoing2) {\n  IS_REDOING.set(editor, isRedoing2);\n}\nconst debug$c = debugWithName(\"plugin:withPortableTextMarkModel\");\nfunction createWithPortableTextMarkModel(editorActor) {\n  return function(editor) {\n    const {\n      apply: apply2,\n      normalizeNode\n    } = editor, decorators = editorActor.getSnapshot().context.schema.decorators.map((t) => t.name);\n    return editor.normalizeNode = (nodeEntry) => {\n      const [node, path] = nodeEntry;\n      if (editor.isTextBlock(node)) {\n        const children = slate__WEBPACK_IMPORTED_MODULE_14__.Node.children(editor, path);\n        for (const [child, childPath] of children) {\n          const nextNode = node.children[childPath[1] + 1];\n          if (editor.isTextSpan(child) && editor.isTextSpan(nextNode) && child.marks?.every((mark) => nextNode.marks?.includes(mark)) && nextNode.marks?.every((mark) => child.marks?.includes(mark))) {\n            debug$c(\"Merging spans\", JSON.stringify(child, null, 2), JSON.stringify(nextNode, null, 2)), editorActor.send({\n              type: \"normalizing\"\n            }), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.mergeNodes(editor, {\n              at: [childPath[0], childPath[1] + 1],\n              voids: !0\n            }), editorActor.send({\n              type: \"done normalizing\"\n            });\n            return;\n          }\n        }\n      }\n      if (editor.isTextBlock(node) && !Array.isArray(node.markDefs)) {\n        debug$c(\"Adding .markDefs to block node\"), editorActor.send({\n          type: \"normalizing\"\n        }), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {\n          markDefs: []\n        }, {\n          at: path\n        }), editorActor.send({\n          type: \"done normalizing\"\n        });\n        return;\n      }\n      if (editor.isTextSpan(node) && !Array.isArray(node.marks)) {\n        debug$c(\"Adding .marks to span node\"), editorActor.send({\n          type: \"normalizing\"\n        }), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {\n          marks: []\n        }, {\n          at: path\n        }), editorActor.send({\n          type: \"done normalizing\"\n        });\n        return;\n      }\n      if (editor.isTextSpan(node)) {\n        const blockPath = slate__WEBPACK_IMPORTED_MODULE_14__.Path.parent(path), [block] = slate__WEBPACK_IMPORTED_MODULE_14__.Editor.node(editor, blockPath), decorators2 = editorActor.getSnapshot().context.schema.decorators.map((decorator) => decorator.name), annotations = node.marks?.filter((mark) => !decorators2.includes(mark));\n        if (editor.isTextBlock(block) && node.text === \"\" && annotations && annotations.length > 0) {\n          debug$c(\"Removing annotations from empty span node\"), editorActor.send({\n            type: \"normalizing\"\n          }), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {\n            marks: node.marks?.filter((mark) => decorators2.includes(mark))\n          }, {\n            at: path\n          }), editorActor.send({\n            type: \"done normalizing\"\n          });\n          return;\n        }\n      }\n      if (editor.isTextBlock(node)) {\n        const decorators2 = editorActor.getSnapshot().context.schema.decorators.map((decorator) => decorator.name);\n        for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_14__.Node.children(editor, path))\n          if (editor.isTextSpan(child)) {\n            const marks = child.marks ?? [], orphanedAnnotations = marks.filter((mark) => !decorators2.includes(mark) && !node.markDefs?.find((def) => def._key === mark));\n            if (orphanedAnnotations.length > 0) {\n              debug$c(\"Removing orphaned annotations from span node\"), editorActor.send({\n                type: \"normalizing\"\n              }), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {\n                marks: marks.filter((mark) => !orphanedAnnotations.includes(mark))\n              }, {\n                at: childPath\n              }), editorActor.send({\n                type: \"done normalizing\"\n              });\n              return;\n            }\n          }\n      }\n      if (editor.isTextSpan(node)) {\n        const blockPath = slate__WEBPACK_IMPORTED_MODULE_14__.Path.parent(path), [block] = slate__WEBPACK_IMPORTED_MODULE_14__.Editor.node(editor, blockPath);\n        if (editor.isTextBlock(block)) {\n          const decorators2 = editorActor.getSnapshot().context.schema.decorators.map((decorator) => decorator.name), marks = node.marks ?? [], orphanedAnnotations = marks.filter((mark) => !decorators2.includes(mark) && !block.markDefs?.find((def) => def._key === mark));\n          if (orphanedAnnotations.length > 0) {\n            debug$c(\"Removing orphaned annotations from span node\"), editorActor.send({\n              type: \"normalizing\"\n            }), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {\n              marks: marks.filter((mark) => !orphanedAnnotations.includes(mark))\n            }, {\n              at: path\n            }), editorActor.send({\n              type: \"done normalizing\"\n            });\n            return;\n          }\n        }\n      }\n      if (editor.isTextBlock(node)) {\n        const markDefs = node.markDefs ?? [], markDefKeys = /* @__PURE__ */ new Set(), newMarkDefs = [];\n        for (const markDef of markDefs)\n          markDefKeys.has(markDef._key) || (markDefKeys.add(markDef._key), newMarkDefs.push(markDef));\n        if (markDefs.length !== newMarkDefs.length) {\n          debug$c(\"Removing duplicate markDefs\"), editorActor.send({\n            type: \"normalizing\"\n          }), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {\n            markDefs: newMarkDefs\n          }, {\n            at: path\n          }), editorActor.send({\n            type: \"done normalizing\"\n          });\n          return;\n        }\n      }\n      if (editor.isTextBlock(node) && !editor.operations.some((op) => op.type === \"merge_node\" && \"markDefs\" in op.properties && op.path.length === 1)) {\n        const newMarkDefs = (node.markDefs || []).filter((def) => node.children.find((child) => slate__WEBPACK_IMPORTED_MODULE_14__.Text.isText(child) && Array.isArray(child.marks) && child.marks.includes(def._key)));\n        if (node.markDefs && !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__(newMarkDefs, node.markDefs)) {\n          debug$c(\"Removing markDef not in use\"), editorActor.send({\n            type: \"normalizing\"\n          }), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {\n            markDefs: newMarkDefs\n          }, {\n            at: path\n          }), editorActor.send({\n            type: \"done normalizing\"\n          });\n          return;\n        }\n      }\n      normalizeNode(nodeEntry);\n    }, editor.apply = (op) => {\n      if (isChangingRemotely(editor)) {\n        apply2(op);\n        return;\n      }\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply2(op);\n        return;\n      }\n      if (op.type === \"set_selection\" && op.properties && op.newProperties && op.properties.anchor && op.properties.focus && op.newProperties.anchor && op.newProperties.focus) {\n        const previousSelectionIsCollapsed = slate__WEBPACK_IMPORTED_MODULE_14__.Range.isCollapsed({\n          anchor: op.properties.anchor,\n          focus: op.properties.focus\n        }), newSelectionIsCollapsed = slate__WEBPACK_IMPORTED_MODULE_14__.Range.isCollapsed({\n          anchor: op.newProperties.anchor,\n          focus: op.newProperties.focus\n        });\n        if (previousSelectionIsCollapsed && newSelectionIsCollapsed) {\n          const focusSpan = Array.from(slate__WEBPACK_IMPORTED_MODULE_14__.Editor.nodes(editor, {\n            mode: \"lowest\",\n            at: op.properties.focus,\n            match: (n) => editor.isTextSpan(n),\n            voids: !1\n          }))[0]?.[0], newFocusSpan = Array.from(slate__WEBPACK_IMPORTED_MODULE_14__.Editor.nodes(editor, {\n            mode: \"lowest\",\n            at: op.newProperties.focus,\n            match: (n) => editor.isTextSpan(n),\n            voids: !1\n          }))[0]?.[0], movedToNextSpan = focusSpan && newFocusSpan && op.newProperties.focus.path[0] === op.properties.focus.path[0] && op.newProperties.focus.path[1] === op.properties.focus.path[1] + 1 && focusSpan.text.length === op.properties.focus.offset && op.newProperties.focus.offset === 0, movedToPreviousSpan = focusSpan && newFocusSpan && op.newProperties.focus.path[0] === op.properties.focus.path[0] && op.newProperties.focus.path[1] === op.properties.focus.path[1] - 1 && op.properties.focus.offset === 0 && newFocusSpan.text.length === op.newProperties.focus.offset;\n          !movedToNextSpan && !movedToPreviousSpan && (editor.decoratorState = {});\n        }\n      }\n      if (op.type === \"remove_text\") {\n        const {\n          selection\n        } = editor;\n        if (selection && slate__WEBPACK_IMPORTED_MODULE_14__.Range.isExpanded(selection)) {\n          const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_14__.Editor.node(editor, selection, {\n            depth: 1\n          }), [span, spanPath] = Array.from(slate__WEBPACK_IMPORTED_MODULE_14__.Editor.nodes(editor, {\n            mode: \"lowest\",\n            at: {\n              path: op.path,\n              offset: op.offset\n            },\n            match: (n) => editor.isTextSpan(n),\n            voids: !1\n          }))[0] ?? [void 0, void 0];\n          if (span && block && (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(editorActor.getSnapshot().context, block)) {\n            const markDefs = block.markDefs ?? [], marks = span.marks ?? [], spanHasAnnotations = marks.some((mark) => markDefs.find((markDef) => markDef._key === mark)), deletingFromTheEnd = op.offset + op.text.length === span.text.length, deletingAllText = op.offset === 0 && deletingFromTheEnd, previousSpan = getPreviousSpan({\n              editor,\n              blockPath,\n              spanPath\n            }), nextSpan = getNextSpan({\n              editor,\n              blockPath,\n              spanPath\n            }), previousSpanHasSameAnnotation = previousSpan ? previousSpan.marks?.some((mark) => !decorators.includes(mark) && marks.includes(mark)) : !1, nextSpanHasSameAnnotation = nextSpan ? nextSpan.marks?.some((mark) => !decorators.includes(mark) && marks.includes(mark)) : !1;\n            if (spanHasAnnotations && deletingAllText && !previousSpanHasSameAnnotation && !nextSpanHasSameAnnotation) {\n              const snapshot = getEditorSnapshot({\n                editorActorSnapshot: editorActor.getSnapshot(),\n                slateEditorInstance: editor\n              });\n              slate__WEBPACK_IMPORTED_MODULE_14__.Editor.withoutNormalizing(editor, () => {\n                apply2(op), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {\n                  marks: (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getActiveDecorators)(snapshot)\n                }, {\n                  at: op.path\n                });\n              }), editor.onChange();\n              return;\n            }\n          }\n        }\n      }\n      if (op.type === \"merge_node\" && op.path.length === 1 && \"markDefs\" in op.properties && op.properties._type === editorActor.getSnapshot().context.schema.block.name && Array.isArray(op.properties.markDefs) && op.properties.markDefs.length > 0 && op.path[0] - 1 >= 0) {\n        const [targetBlock, targetPath] = slate__WEBPACK_IMPORTED_MODULE_14__.Editor.node(editor, [op.path[0] - 1]);\n        if (editor.isTextBlock(targetBlock)) {\n          const oldDefs = Array.isArray(targetBlock.markDefs) && targetBlock.markDefs || [], newMarkDefs = lodash_uniq_js__WEBPACK_IMPORTED_MODULE_6__([...oldDefs, ...op.properties.markDefs]);\n          debug$c(\"Copying markDefs over to merged block\", op), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {\n            markDefs: newMarkDefs\n          }, {\n            at: targetPath,\n            voids: !1\n          }), apply2(op);\n          return;\n        }\n      }\n      apply2(op);\n    }, editor;\n  };\n}\nconst removeDecoratorOperationImplementation = ({\n  operation\n}) => {\n  const editor = operation.editor, mark = operation.decorator, {\n    selection\n  } = editor;\n  if (selection) {\n    if (slate__WEBPACK_IMPORTED_MODULE_14__.Range.isExpanded(selection))\n      slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {}, {\n        match: slate__WEBPACK_IMPORTED_MODULE_14__.Text.isText,\n        split: !0,\n        hanging: !0\n      }), editor.selection && [...slate__WEBPACK_IMPORTED_MODULE_14__.Editor.nodes(editor, {\n        at: editor.selection,\n        match: slate__WEBPACK_IMPORTED_MODULE_14__.Text.isText\n      })].forEach(([node, path]) => {\n        const block = editor.children[path[0]];\n        slate__WEBPACK_IMPORTED_MODULE_14__.Element.isElement(block) && block.children.includes(node) && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {\n          marks: (Array.isArray(node.marks) ? node.marks : []).filter((eMark) => eMark !== mark),\n          _type: \"span\"\n        }, {\n          at: path\n        });\n      });\n    else {\n      const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_14__.Editor.node(editor, selection, {\n        depth: 1\n      }), lonelyEmptySpan = editor.isTextBlock(block) && block.children.length === 1 && editor.isTextSpan(block.children[0]) && block.children[0].text === \"\" ? block.children[0] : void 0;\n      if (lonelyEmptySpan) {\n        const existingMarksWithoutDecorator = (lonelyEmptySpan.marks ?? []).filter((existingMark) => existingMark !== mark);\n        slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {\n          marks: existingMarksWithoutDecorator\n        }, {\n          at: blockPath,\n          match: (node) => editor.isTextSpan(node)\n        });\n      } else\n        editor.decoratorState[mark] = !1;\n    }\n    if (editor.selection) {\n      const selection2 = editor.selection;\n      editor.selection = {\n        ...selection2\n      };\n    }\n  }\n};\nfunction cloneDiff(diff2) {\n  const [type, patch] = diff2;\n  return [type, patch];\n}\nfunction getCommonOverlap(textA, textB) {\n  let text1 = textA, text2 = textB;\n  const text1Length = text1.length, text2Length = text2.length;\n  if (text1Length === 0 || text2Length === 0) return 0;\n  text1Length > text2Length ? text1 = text1.substring(text1Length - text2Length) : text1Length < text2Length && (text2 = text2.substring(0, text1Length));\n  const textLength = Math.min(text1Length, text2Length);\n  if (text1 === text2) return textLength;\n  let best = 0, length = 1;\n  for (let found = 0; found !== -1; ) {\n    const pattern = text1.substring(textLength - length);\n    if (found = text2.indexOf(pattern), found === -1) return best;\n    length += found, (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) && (best = length, length++);\n  }\n  return best;\n}\nfunction getCommonPrefix(text1, text2) {\n  if (!text1 || !text2 || text1[0] !== text2[0]) return 0;\n  let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerStart = 0;\n  for (; pointerMin < pointerMid; ) text1.substring(pointerStart, pointerMid) === text2.substring(pointerStart, pointerMid) ? (pointerMin = pointerMid, pointerStart = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);\n  return pointerMid;\n}\nfunction getCommonSuffix(text1, text2) {\n  if (!text1 || !text2 || text1[text1.length - 1] !== text2[text2.length - 1]) return 0;\n  let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerEnd = 0;\n  for (; pointerMin < pointerMid; ) text1.substring(text1.length - pointerMid, text1.length - pointerEnd) === text2.substring(text2.length - pointerMid, text2.length - pointerEnd) ? (pointerMin = pointerMid, pointerEnd = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);\n  return pointerMid;\n}\nfunction isHighSurrogate(char) {\n  const charCode = char.charCodeAt(0);\n  return charCode >= 55296 && charCode <= 56319;\n}\nfunction isLowSurrogate(char) {\n  const charCode = char.charCodeAt(0);\n  return charCode >= 56320 && charCode <= 57343;\n}\nfunction bisect(text1, text2, deadline) {\n  const text1Length = text1.length, text2Length = text2.length, maxD = Math.ceil((text1Length + text2Length) / 2), vOffset = maxD, vLength = 2 * maxD, v1 = new Array(vLength), v2 = new Array(vLength);\n  for (let x = 0; x < vLength; x++) v1[x] = -1, v2[x] = -1;\n  v1[vOffset + 1] = 0, v2[vOffset + 1] = 0;\n  const delta = text1Length - text2Length, front = delta % 2 !== 0;\n  let k1start = 0, k1end = 0, k2start = 0, k2end = 0;\n  for (let d = 0; d < maxD && !(Date.now() > deadline); d++) {\n    for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      const k1Offset = vOffset + k1;\n      let x1;\n      k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1] ? x1 = v1[k1Offset + 1] : x1 = v1[k1Offset - 1] + 1;\n      let y1 = x1 - k1;\n      for (; x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1); ) x1++, y1++;\n      if (v1[k1Offset] = x1, x1 > text1Length) k1end += 2;\n      else if (y1 > text2Length) k1start += 2;\n      else if (front) {\n        const k2Offset = vOffset + delta - k1;\n        if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {\n          const x2 = text1Length - v2[k2Offset];\n          if (x1 >= x2) return bisectSplit(text1, text2, x1, y1, deadline);\n        }\n      }\n    }\n    for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      const k2Offset = vOffset + k2;\n      let x2;\n      k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1] ? x2 = v2[k2Offset + 1] : x2 = v2[k2Offset - 1] + 1;\n      let y2 = x2 - k2;\n      for (; x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1); ) x2++, y2++;\n      if (v2[k2Offset] = x2, x2 > text1Length) k2end += 2;\n      else if (y2 > text2Length) k2start += 2;\n      else if (!front) {\n        const k1Offset = vOffset + delta - k2;\n        if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {\n          const x1 = v1[k1Offset], y1 = vOffset + x1 - k1Offset;\n          if (x2 = text1Length - x2, x1 >= x2) return bisectSplit(text1, text2, x1, y1, deadline);\n        }\n      }\n    }\n  }\n  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n}\nfunction bisectSplit(text1, text2, x, y, deadline) {\n  const text1a = text1.substring(0, x), text2a = text2.substring(0, y), text1b = text1.substring(x), text2b = text2.substring(y), diffs = doDiff(text1a, text2a, {\n    checkLines: !1,\n    deadline\n  }), diffsb = doDiff(text1b, text2b, {\n    checkLines: !1,\n    deadline\n  });\n  return diffs.concat(diffsb);\n}\nfunction findHalfMatch(text1, text2, timeout = 1) {\n  if (timeout <= 0) return null;\n  const longText = text1.length > text2.length ? text1 : text2, shortText = text1.length > text2.length ? text2 : text1;\n  if (longText.length < 4 || shortText.length * 2 < longText.length) return null;\n  const halfMatch1 = halfMatchI(longText, shortText, Math.ceil(longText.length / 4)), halfMatch2 = halfMatchI(longText, shortText, Math.ceil(longText.length / 2));\n  let halfMatch;\n  if (halfMatch1 && halfMatch2) halfMatch = halfMatch1[4].length > halfMatch2[4].length ? halfMatch1 : halfMatch2;\n  else {\n    if (!halfMatch1 && !halfMatch2) return null;\n    halfMatch2 ? halfMatch1 || (halfMatch = halfMatch2) : halfMatch = halfMatch1;\n  }\n  if (!halfMatch) throw new Error(\"Unable to find a half match.\");\n  let text1A, text1B, text2A, text2B;\n  text1.length > text2.length ? (text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3]) : (text2A = halfMatch[0], text2B = halfMatch[1], text1A = halfMatch[2], text1B = halfMatch[3]);\n  const midCommon = halfMatch[4];\n  return [text1A, text1B, text2A, text2B, midCommon];\n}\nfunction halfMatchI(longText, shortText, i) {\n  const seed = longText.slice(i, i + Math.floor(longText.length / 4));\n  let j = -1, bestCommon = \"\", bestLongTextA, bestLongTextB, bestShortTextA, bestShortTextB;\n  for (; (j = shortText.indexOf(seed, j + 1)) !== -1; ) {\n    const prefixLength = getCommonPrefix(longText.slice(i), shortText.slice(j)), suffixLength = getCommonSuffix(longText.slice(0, i), shortText.slice(0, j));\n    bestCommon.length < suffixLength + prefixLength && (bestCommon = shortText.slice(j - suffixLength, j) + shortText.slice(j, j + prefixLength), bestLongTextA = longText.slice(0, i - suffixLength), bestLongTextB = longText.slice(i + prefixLength), bestShortTextA = shortText.slice(0, j - suffixLength), bestShortTextB = shortText.slice(j + prefixLength));\n  }\n  return bestCommon.length * 2 >= longText.length ? [bestLongTextA || \"\", bestLongTextB || \"\", bestShortTextA || \"\", bestShortTextB || \"\", bestCommon || \"\"] : null;\n}\nfunction charsToLines(diffs, lineArray) {\n  for (let x = 0; x < diffs.length; x++) {\n    const chars = diffs[x][1], text = [];\n    for (let y = 0; y < chars.length; y++) text[y] = lineArray[chars.charCodeAt(y)];\n    diffs[x][1] = text.join(\"\");\n  }\n}\nfunction linesToChars(textA, textB) {\n  const lineArray = [], lineHash = {};\n  lineArray[0] = \"\";\n  function diffLinesToMunge(text) {\n    let chars = \"\", lineStart = 0, lineEnd = -1, lineArrayLength = lineArray.length;\n    for (; lineEnd < text.length - 1; ) {\n      lineEnd = text.indexOf(`\n`, lineStart), lineEnd === -1 && (lineEnd = text.length - 1);\n      let line = text.slice(lineStart, lineEnd + 1);\n      (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) ? chars += String.fromCharCode(lineHash[line]) : (lineArrayLength === maxLines && (line = text.slice(lineStart), lineEnd = text.length), chars += String.fromCharCode(lineArrayLength), lineHash[line] = lineArrayLength, lineArray[lineArrayLength++] = line), lineStart = lineEnd + 1;\n    }\n    return chars;\n  }\n  let maxLines = 4e4;\n  const chars1 = diffLinesToMunge(textA);\n  maxLines = 65535;\n  const chars2 = diffLinesToMunge(textB);\n  return {\n    chars1,\n    chars2,\n    lineArray\n  };\n}\nfunction doLineModeDiff(textA, textB, opts) {\n  let text1 = textA, text2 = textB;\n  const a = linesToChars(text1, text2);\n  text1 = a.chars1, text2 = a.chars2;\n  const linearray = a.lineArray;\n  let diffs = doDiff(text1, text2, {\n    checkLines: !1,\n    deadline: opts.deadline\n  });\n  charsToLines(diffs, linearray), diffs = cleanupSemantic(diffs), diffs.push([DIFF_EQUAL, \"\"]);\n  let pointer = 0, countDelete = 0, countInsert = 0, textDelete = \"\", textInsert = \"\";\n  for (; pointer < diffs.length; ) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        countInsert++, textInsert += diffs[pointer][1];\n        break;\n      case DIFF_DELETE:\n        countDelete++, textDelete += diffs[pointer][1];\n        break;\n      case DIFF_EQUAL:\n        if (countDelete >= 1 && countInsert >= 1) {\n          diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert), pointer = pointer - countDelete - countInsert;\n          const aa = doDiff(textDelete, textInsert, {\n            checkLines: !1,\n            deadline: opts.deadline\n          });\n          for (let j = aa.length - 1; j >= 0; j--) diffs.splice(pointer, 0, aa[j]);\n          pointer += aa.length;\n        }\n        countInsert = 0, countDelete = 0, textDelete = \"\", textInsert = \"\";\n        break;\n      default:\n        throw new Error(\"Unknown diff operation.\");\n    }\n    pointer++;\n  }\n  return diffs.pop(), diffs;\n}\nfunction computeDiff(text1, text2, opts) {\n  let diffs;\n  if (!text1) return [[DIFF_INSERT, text2]];\n  if (!text2) return [[DIFF_DELETE, text1]];\n  const longtext = text1.length > text2.length ? text1 : text2, shorttext = text1.length > text2.length ? text2 : text1, i = longtext.indexOf(shorttext);\n  if (i !== -1) return diffs = [[DIFF_INSERT, longtext.substring(0, i)], [DIFF_EQUAL, shorttext], [DIFF_INSERT, longtext.substring(i + shorttext.length)]], text1.length > text2.length && (diffs[0][0] = DIFF_DELETE, diffs[2][0] = DIFF_DELETE), diffs;\n  if (shorttext.length === 1) return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n  const halfMatch = findHalfMatch(text1, text2);\n  if (halfMatch) {\n    const text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3], midCommon = halfMatch[4], diffsA = doDiff(text1A, text2A, opts), diffsB = doDiff(text1B, text2B, opts);\n    return diffsA.concat([[DIFF_EQUAL, midCommon]], diffsB);\n  }\n  return opts.checkLines && text1.length > 100 && text2.length > 100 ? doLineModeDiff(text1, text2, opts) : bisect(text1, text2, opts.deadline);\n}\nvar __defProp$2 = Object.defineProperty, __getOwnPropSymbols$2 = Object.getOwnPropertySymbols, __hasOwnProp$2 = Object.prototype.hasOwnProperty, __propIsEnum$2 = Object.prototype.propertyIsEnumerable, __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value\n}) : obj[key] = value, __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {})) __hasOwnProp$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2) for (var prop of __getOwnPropSymbols$2(b)) __propIsEnum$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);\n  return a;\n};\nconst DIFF_DELETE = -1, DIFF_INSERT = 1, DIFF_EQUAL = 0;\nfunction diff(textA, textB, opts) {\n  if (textA === null || textB === null) throw new Error(\"Null input. (diff)\");\n  const diffs = doDiff(textA, textB, createInternalOpts(opts || {}));\n  return adjustDiffForSurrogatePairs(diffs), diffs;\n}\nfunction doDiff(textA, textB, options) {\n  let text1 = textA, text2 = textB;\n  if (text1 === text2) return text1 ? [[DIFF_EQUAL, text1]] : [];\n  let commonlength = getCommonPrefix(text1, text2);\n  const commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength), text2 = text2.substring(commonlength), commonlength = getCommonSuffix(text1, text2);\n  const commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength), text2 = text2.substring(0, text2.length - commonlength);\n  let diffs = computeDiff(text1, text2, options);\n  return commonprefix && diffs.unshift([DIFF_EQUAL, commonprefix]), commonsuffix && diffs.push([DIFF_EQUAL, commonsuffix]), diffs = cleanupMerge(diffs), diffs;\n}\nfunction createDeadLine(timeout) {\n  let t = 1;\n  return typeof timeout < \"u\" && (t = timeout <= 0 ? Number.MAX_VALUE : timeout), Date.now() + t * 1e3;\n}\nfunction createInternalOpts(opts) {\n  return __spreadValues$2({\n    checkLines: !0,\n    deadline: createDeadLine(opts.timeout || 1)\n  }, opts);\n}\nfunction combineChar(data, char, dir) {\n  return dir === 1 ? data + char : char + data;\n}\nfunction splitChar(data, dir) {\n  return dir === 1 ? [data.substring(0, data.length - 1), data[data.length - 1]] : [data.substring(1), data[0]];\n}\nfunction hasSharedChar(diffs, i, j, dir) {\n  return dir === 1 ? diffs[i][1][diffs[i][1].length - 1] === diffs[j][1][diffs[j][1].length - 1] : diffs[i][1][0] === diffs[j][1][0];\n}\nfunction deisolateChar(diffs, i, dir) {\n  const inv = dir === 1 ? -1 : 1;\n  let insertIdx = null, deleteIdx = null, j = i + dir;\n  for (; j >= 0 && j < diffs.length && (insertIdx === null || deleteIdx === null); j += dir) {\n    const [op, text2] = diffs[j];\n    if (text2.length !== 0) {\n      if (op === DIFF_INSERT) {\n        insertIdx === null && (insertIdx = j);\n        continue;\n      } else if (op === DIFF_DELETE) {\n        deleteIdx === null && (deleteIdx = j);\n        continue;\n      } else if (op === DIFF_EQUAL) {\n        if (insertIdx === null && deleteIdx === null) {\n          const [rest, char2] = splitChar(diffs[i][1], dir);\n          diffs[i][1] = rest, diffs[j][1] = combineChar(diffs[j][1], char2, inv);\n          return;\n        }\n        break;\n      }\n    }\n  }\n  if (insertIdx !== null && deleteIdx !== null && hasSharedChar(diffs, insertIdx, deleteIdx, dir)) {\n    const [insertText, insertChar] = splitChar(diffs[insertIdx][1], inv), [deleteText2] = splitChar(diffs[deleteIdx][1], inv);\n    diffs[insertIdx][1] = insertText, diffs[deleteIdx][1] = deleteText2, diffs[i][1] = combineChar(diffs[i][1], insertChar, dir);\n    return;\n  }\n  const [text, char] = splitChar(diffs[i][1], dir);\n  diffs[i][1] = text, insertIdx === null ? (diffs.splice(j, 0, [DIFF_INSERT, char]), deleteIdx !== null && deleteIdx >= j && deleteIdx++) : diffs[insertIdx][1] = combineChar(diffs[insertIdx][1], char, inv), deleteIdx === null ? diffs.splice(j, 0, [DIFF_DELETE, char]) : diffs[deleteIdx][1] = combineChar(diffs[deleteIdx][1], char, inv);\n}\nfunction adjustDiffForSurrogatePairs(diffs) {\n  for (let i = 0; i < diffs.length; i++) {\n    const [diffType, diffText] = diffs[i];\n    if (diffText.length === 0) continue;\n    const firstChar = diffText[0], lastChar = diffText[diffText.length - 1];\n    isHighSurrogate(lastChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, 1), isLowSurrogate(firstChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, -1);\n  }\n  for (let i = 0; i < diffs.length; i++) diffs[i][1].length === 0 && diffs.splice(i, 1);\n}\nfunction cleanupSemantic(rawDiffs) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2)), hasChanges = !1;\n  const equalities = [];\n  let equalitiesLength = 0, lastEquality = null, pointer = 0, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0;\n  for (; pointer < diffs.length; ) diffs[pointer][0] === DIFF_EQUAL ? (equalities[equalitiesLength++] = pointer, lengthInsertions1 = lengthInsertions2, lengthDeletions1 = lengthDeletions2, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = diffs[pointer][1]) : (diffs[pointer][0] === DIFF_INSERT ? lengthInsertions2 += diffs[pointer][1].length : lengthDeletions2 += diffs[pointer][1].length, lastEquality && lastEquality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastEquality.length <= Math.max(lengthInsertions2, lengthDeletions2) && (diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = null, hasChanges = !0)), pointer++;\n  for (hasChanges && (diffs = cleanupMerge(diffs)), diffs = cleanupSemanticLossless(diffs), pointer = 1; pointer < diffs.length; ) {\n    if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {\n      const deletion = diffs[pointer - 1][1], insertion = diffs[pointer][1], overlapLength1 = getCommonOverlap(deletion, insertion), overlapLength2 = getCommonOverlap(insertion, deletion);\n      overlapLength1 >= overlapLength2 ? (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) && (diffs.splice(pointer, 0, [DIFF_EQUAL, insertion.substring(0, overlapLength1)]), diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1), diffs[pointer + 1][1] = insertion.substring(overlapLength1), pointer++) : (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) && (diffs.splice(pointer, 0, [DIFF_EQUAL, deletion.substring(0, overlapLength2)]), diffs[pointer - 1][0] = DIFF_INSERT, diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2), diffs[pointer + 1][0] = DIFF_DELETE, diffs[pointer + 1][1] = deletion.substring(overlapLength2), pointer++), pointer++;\n    }\n    pointer++;\n  }\n  return diffs;\n}\nconst nonAlphaNumericRegex = /[^a-zA-Z0-9]/, whitespaceRegex = /\\s/, linebreakRegex = /[\\r\\n]/, blanklineEndRegex = /\\n\\r?\\n$/, blanklineStartRegex = /^\\r?\\n\\r?\\n/;\nfunction cleanupSemanticLossless(rawDiffs) {\n  const diffs = rawDiffs.map((diff2) => cloneDiff(diff2));\n  function diffCleanupSemanticScore(one, two) {\n    if (!one || !two) return 6;\n    const char1 = one.charAt(one.length - 1), char2 = two.charAt(0), nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex), nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex), whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex), whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex), lineBreak1 = whitespace1 && char1.match(linebreakRegex), lineBreak2 = whitespace2 && char2.match(linebreakRegex), blankLine1 = lineBreak1 && one.match(blanklineEndRegex), blankLine2 = lineBreak2 && two.match(blanklineStartRegex);\n    return blankLine1 || blankLine2 ? 5 : lineBreak1 || lineBreak2 ? 4 : nonAlphaNumeric1 && !whitespace1 && whitespace2 ? 3 : whitespace1 || whitespace2 ? 2 : nonAlphaNumeric1 || nonAlphaNumeric2 ? 1 : 0;\n  }\n  let pointer = 1;\n  for (; pointer < diffs.length - 1; ) {\n    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n      let equality1 = diffs[pointer - 1][1], edit = diffs[pointer][1], equality2 = diffs[pointer + 1][1];\n      const commonOffset = getCommonSuffix(equality1, edit);\n      if (commonOffset) {\n        const commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset), edit = commonString + edit.substring(0, edit.length - commonOffset), equality2 = commonString + equality2;\n      }\n      let bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2, bestScore = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);\n      for (; edit.charAt(0) === equality2.charAt(0); ) {\n        equality1 += edit.charAt(0), edit = edit.substring(1) + equality2.charAt(0), equality2 = equality2.substring(1);\n        const score = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);\n        score >= bestScore && (bestScore = score, bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2);\n      }\n      diffs[pointer - 1][1] !== bestEquality1 && (bestEquality1 ? diffs[pointer - 1][1] = bestEquality1 : (diffs.splice(pointer - 1, 1), pointer--), diffs[pointer][1] = bestEdit, bestEquality2 ? diffs[pointer + 1][1] = bestEquality2 : (diffs.splice(pointer + 1, 1), pointer--));\n    }\n    pointer++;\n  }\n  return diffs;\n}\nfunction cleanupMerge(rawDiffs) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2));\n  diffs.push([DIFF_EQUAL, \"\"]);\n  let pointer = 0, countDelete = 0, countInsert = 0, textDelete = \"\", textInsert = \"\", commonlength;\n  for (; pointer < diffs.length; ) switch (diffs[pointer][0]) {\n    case DIFF_INSERT:\n      countInsert++, textInsert += diffs[pointer][1], pointer++;\n      break;\n    case DIFF_DELETE:\n      countDelete++, textDelete += diffs[pointer][1], pointer++;\n      break;\n    case DIFF_EQUAL:\n      countDelete + countInsert > 1 ? (countDelete !== 0 && countInsert !== 0 && (commonlength = getCommonPrefix(textInsert, textDelete), commonlength !== 0 && (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL ? diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength) : (diffs.splice(0, 0, [DIFF_EQUAL, textInsert.substring(0, commonlength)]), pointer++), textInsert = textInsert.substring(commonlength), textDelete = textDelete.substring(commonlength)), commonlength = getCommonSuffix(textInsert, textDelete), commonlength !== 0 && (diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1], textInsert = textInsert.substring(0, textInsert.length - commonlength), textDelete = textDelete.substring(0, textDelete.length - commonlength))), pointer -= countDelete + countInsert, diffs.splice(pointer, countDelete + countInsert), textDelete.length && (diffs.splice(pointer, 0, [DIFF_DELETE, textDelete]), pointer++), textInsert.length && (diffs.splice(pointer, 0, [DIFF_INSERT, textInsert]), pointer++), pointer++) : pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL ? (diffs[pointer - 1][1] += diffs[pointer][1], diffs.splice(pointer, 1)) : pointer++, countInsert = 0, countDelete = 0, textDelete = \"\", textInsert = \"\";\n      break;\n    default:\n      throw new Error(\"Unknown diff operation\");\n  }\n  diffs[diffs.length - 1][1] === \"\" && diffs.pop();\n  let hasChanges = !1;\n  for (pointer = 1; pointer < diffs.length - 1; ) diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL && (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1] ? (diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length), diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1], diffs.splice(pointer - 1, 1), hasChanges = !0) : diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1] && (diffs[pointer - 1][1] += diffs[pointer + 1][1], diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1], diffs.splice(pointer + 1, 1), hasChanges = !0)), pointer++;\n  return hasChanges && (diffs = cleanupMerge(diffs)), diffs;\n}\nfunction trueCount(...args) {\n  return args.reduce((n, bool) => n + (bool ? 1 : 0), 0);\n}\nfunction cleanupEfficiency(rawDiffs, editCost = 4) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2)), hasChanges = !1;\n  const equalities = [];\n  let equalitiesLength = 0, lastEquality = null, pointer = 0, preIns = !1, preDel = !1, postIns = !1, postDel = !1;\n  for (; pointer < diffs.length; ) diffs[pointer][0] === DIFF_EQUAL ? (diffs[pointer][1].length < editCost && (postIns || postDel) ? (equalities[equalitiesLength++] = pointer, preIns = postIns, preDel = postDel, lastEquality = diffs[pointer][1]) : (equalitiesLength = 0, lastEquality = null), postIns = !1, postDel = !1) : (diffs[pointer][0] === DIFF_DELETE ? postDel = !0 : postIns = !0, lastEquality && (preIns && preDel && postIns && postDel || lastEquality.length < editCost / 2 && trueCount(preIns, preDel, postIns, postDel) === 3) && (diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, lastEquality = null, preIns && preDel ? (postIns = !0, postDel = !0, equalitiesLength = 0) : (equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, postIns = !1, postDel = !1), hasChanges = !0)), pointer++;\n  return hasChanges && (diffs = cleanupMerge(diffs)), diffs;\n}\nvar __defProp$1 = Object.defineProperty, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value\n}) : obj[key] = value, __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {})) __hasOwnProp$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1) for (var prop of __getOwnPropSymbols$1(b)) __propIsEnum$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);\n  return a;\n};\nconst DEFAULT_OPTIONS = {\n  /**\n   * At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n   */\n  threshold: 0.5,\n  /**\n   * How far to search for a match (0 = exact location, 1000+ = broad match).\n   * A match this many characters away from the expected location will add\n   * 1.0 to the score (0.0 is a perfect match).\n   */\n  distance: 1e3\n};\nfunction applyDefaults(options) {\n  return __spreadValues$1(__spreadValues$1({}, DEFAULT_OPTIONS), options);\n}\nconst MAX_BITS$1 = 32;\nfunction bitap(text, pattern, loc, opts = {}) {\n  if (pattern.length > MAX_BITS$1) throw new Error(\"Pattern too long for this browser.\");\n  const options = applyDefaults(opts), s = getAlphabetFromPattern(pattern);\n  function getBitapScore(e, x) {\n    const accuracy = e / pattern.length, proximity = Math.abs(loc - x);\n    return options.distance ? accuracy + proximity / options.distance : proximity ? 1 : accuracy;\n  }\n  let scoreThreshold = options.threshold, bestLoc = text.indexOf(pattern, loc);\n  bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold), bestLoc = text.lastIndexOf(pattern, loc + pattern.length), bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold)));\n  const matchmask = 1 << pattern.length - 1;\n  bestLoc = -1;\n  let binMin, binMid, binMax = pattern.length + text.length, lastRd = [];\n  for (let d = 0; d < pattern.length; d++) {\n    for (binMin = 0, binMid = binMax; binMin < binMid; ) getBitapScore(d, loc + binMid) <= scoreThreshold ? binMin = binMid : binMax = binMid, binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    binMax = binMid;\n    let start = Math.max(1, loc - binMid + 1);\n    const finish = Math.min(loc + binMid, text.length) + pattern.length, rd = new Array(finish + 2);\n    rd[finish + 1] = (1 << d) - 1;\n    for (let j = finish; j >= start; j--) {\n      const charMatch = s[text.charAt(j - 1)];\n      if (d === 0 ? rd[j] = (rd[j + 1] << 1 | 1) & charMatch : rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((lastRd[j + 1] | lastRd[j]) << 1 | 1) | lastRd[j + 1], rd[j] & matchmask) {\n        const score = getBitapScore(d, j - 1);\n        if (score <= scoreThreshold) if (scoreThreshold = score, bestLoc = j - 1, bestLoc > loc) start = Math.max(1, 2 * loc - bestLoc);\n        else break;\n      }\n    }\n    if (getBitapScore(d + 1, loc) > scoreThreshold) break;\n    lastRd = rd;\n  }\n  return bestLoc;\n}\nfunction getAlphabetFromPattern(pattern) {\n  const s = {};\n  for (let i = 0; i < pattern.length; i++) s[pattern.charAt(i)] = 0;\n  for (let i = 0; i < pattern.length; i++) s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;\n  return s;\n}\nfunction match(text, pattern, searchLocation, options = {}) {\n  if (text === null || pattern === null || searchLocation === null) throw new Error(\"Null input. (match())\");\n  const loc = Math.max(0, Math.min(searchLocation, text.length));\n  if (text === pattern) return 0;\n  if (text.length) {\n    if (text.substring(loc, loc + pattern.length) === pattern) return loc;\n  } else return -1;\n  return bitap(text, pattern, loc, options);\n}\nfunction diffText1(diffs) {\n  const text = [];\n  for (let x = 0; x < diffs.length; x++) diffs[x][0] !== DIFF_INSERT && (text[x] = diffs[x][1]);\n  return text.join(\"\");\n}\nfunction diffText2(diffs) {\n  const text = [];\n  for (let x = 0; x < diffs.length; x++) diffs[x][0] !== DIFF_DELETE && (text[x] = diffs[x][1]);\n  return text.join(\"\");\n}\nfunction levenshtein(diffs) {\n  let leven = 0, insertions = 0, deletions = 0;\n  for (let x = 0; x < diffs.length; x++) {\n    const op = diffs[x][0], data = diffs[x][1];\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length;\n        break;\n      case DIFF_DELETE:\n        deletions += data.length;\n        break;\n      case DIFF_EQUAL:\n        leven += Math.max(insertions, deletions), insertions = 0, deletions = 0;\n        break;\n      default:\n        throw new Error(\"Unknown diff operation.\");\n    }\n  }\n  return leven += Math.max(insertions, deletions), leven;\n}\nfunction xIndex(diffs, location) {\n  let chars1 = 0, chars2 = 0, lastChars1 = 0, lastChars2 = 0, x;\n  for (x = 0; x < diffs.length && (diffs[x][0] !== DIFF_INSERT && (chars1 += diffs[x][1].length), diffs[x][0] !== DIFF_DELETE && (chars2 += diffs[x][1].length), !(chars1 > location)); x++) lastChars1 = chars1, lastChars2 = chars2;\n  return diffs.length !== x && diffs[x][0] === DIFF_DELETE ? lastChars2 : lastChars2 + (location - lastChars1);\n}\nfunction countUtf8Bytes(str) {\n  let bytes = 0;\n  for (let i = 0; i < str.length; i++) {\n    const codePoint = str.codePointAt(i);\n    if (typeof codePoint > \"u\") throw new Error(\"Failed to get codepoint\");\n    bytes += utf8len(codePoint);\n  }\n  return bytes;\n}\nfunction adjustIndiciesToUcs2(patches, base, options = {}) {\n  let byteOffset = 0, idx = 0;\n  function advanceTo(target) {\n    for (; byteOffset < target; ) {\n      const codePoint = base.codePointAt(idx);\n      if (typeof codePoint > \"u\") return idx;\n      byteOffset += utf8len(codePoint), codePoint > 65535 ? idx += 2 : idx += 1;\n    }\n    if (!options.allowExceedingIndices && byteOffset !== target) throw new Error(\"Failed to determine byte offset\");\n    return idx;\n  }\n  const adjusted = [];\n  for (const patch of patches) adjusted.push({\n    diffs: patch.diffs.map((diff2) => cloneDiff(diff2)),\n    start1: advanceTo(patch.start1),\n    start2: advanceTo(patch.start2),\n    utf8Start1: patch.utf8Start1,\n    utf8Start2: patch.utf8Start2,\n    length1: patch.length1,\n    length2: patch.length2,\n    utf8Length1: patch.utf8Length1,\n    utf8Length2: patch.utf8Length2\n  });\n  return adjusted;\n}\nfunction utf8len(codePoint) {\n  return codePoint <= 127 ? 1 : codePoint <= 2047 ? 2 : codePoint <= 65535 ? 3 : 4;\n}\nconst MAX_BITS = 32, DEFAULT_MARGIN = 4;\nfunction addPadding(patches, margin = DEFAULT_MARGIN) {\n  const paddingLength = margin;\n  let nullPadding = \"\";\n  for (let x = 1; x <= paddingLength; x++) nullPadding += String.fromCharCode(x);\n  for (const p of patches) p.start1 += paddingLength, p.start2 += paddingLength, p.utf8Start1 += paddingLength, p.utf8Start2 += paddingLength;\n  let patch = patches[0], diffs = patch.diffs;\n  if (diffs.length === 0 || diffs[0][0] !== DIFF_EQUAL) diffs.unshift([DIFF_EQUAL, nullPadding]), patch.start1 -= paddingLength, patch.start2 -= paddingLength, patch.utf8Start1 -= paddingLength, patch.utf8Start2 -= paddingLength, patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;\n  else if (paddingLength > diffs[0][1].length) {\n    const firstDiffLength = diffs[0][1].length, extraLength = paddingLength - firstDiffLength;\n    diffs[0][1] = nullPadding.substring(firstDiffLength) + diffs[0][1], patch.start1 -= extraLength, patch.start2 -= extraLength, patch.utf8Start1 -= extraLength, patch.utf8Start2 -= extraLength, patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;\n  }\n  if (patch = patches[patches.length - 1], diffs = patch.diffs, diffs.length === 0 || diffs[diffs.length - 1][0] !== DIFF_EQUAL) diffs.push([DIFF_EQUAL, nullPadding]), patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;\n  else if (paddingLength > diffs[diffs.length - 1][1].length) {\n    const extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength), patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;\n  }\n  return nullPadding;\n}\nfunction createPatchObject(start1, start2) {\n  return {\n    diffs: [],\n    start1,\n    start2,\n    utf8Start1: start1,\n    utf8Start2: start2,\n    length1: 0,\n    length2: 0,\n    utf8Length1: 0,\n    utf8Length2: 0\n  };\n}\nfunction splitMax(patches, margin = DEFAULT_MARGIN) {\n  const patchSize = MAX_BITS;\n  for (let x = 0; x < patches.length; x++) {\n    if (patches[x].length1 <= patchSize) continue;\n    const bigpatch = patches[x];\n    patches.splice(x--, 1);\n    let start1 = bigpatch.start1, start2 = bigpatch.start2, preContext = \"\";\n    for (; bigpatch.diffs.length !== 0; ) {\n      const patch = createPatchObject(start1 - preContext.length, start2 - preContext.length);\n      let empty = !0;\n      if (preContext !== \"\") {\n        const precontextByteCount = countUtf8Bytes(preContext);\n        patch.length1 = preContext.length, patch.utf8Length1 = precontextByteCount, patch.length2 = preContext.length, patch.utf8Length2 = precontextByteCount, patch.diffs.push([DIFF_EQUAL, preContext]);\n      }\n      for (; bigpatch.diffs.length !== 0 && patch.length1 < patchSize - margin; ) {\n        const diffType = bigpatch.diffs[0][0];\n        let diffText = bigpatch.diffs[0][1], diffTextByteCount = countUtf8Bytes(diffText);\n        if (diffType === DIFF_INSERT) {\n          patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length;\n          const diff2 = bigpatch.diffs.shift();\n          diff2 && patch.diffs.push(diff2), empty = !1;\n        } else diffType === DIFF_DELETE && patch.diffs.length === 1 && patch.diffs[0][0] === DIFF_EQUAL && diffText.length > 2 * patchSize ? (patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, empty = !1, patch.diffs.push([diffType, diffText]), bigpatch.diffs.shift()) : (diffText = diffText.substring(0, patchSize - patch.length1 - margin), diffTextByteCount = countUtf8Bytes(diffText), patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, diffType === DIFF_EQUAL ? (patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length) : empty = !1, patch.diffs.push([diffType, diffText]), diffText === bigpatch.diffs[0][1] ? bigpatch.diffs.shift() : bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diffText.length));\n      }\n      preContext = diffText2(patch.diffs), preContext = preContext.substring(preContext.length - margin);\n      const postContext = diffText1(bigpatch.diffs).substring(0, margin), postContextByteCount = countUtf8Bytes(postContext);\n      postContext !== \"\" && (patch.length1 += postContext.length, patch.length2 += postContext.length, patch.utf8Length1 += postContextByteCount, patch.utf8Length2 += postContextByteCount, patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL ? patch.diffs[patch.diffs.length - 1][1] += postContext : patch.diffs.push([DIFF_EQUAL, postContext])), empty || patches.splice(++x, 0, patch);\n    }\n  }\n}\nfunction apply(patches, originalText, opts = {}) {\n  if (typeof patches == \"string\") throw new Error(\"Patches must be an array - pass the patch to `parsePatch()` first\");\n  let text = originalText;\n  if (patches.length === 0) return [text, []];\n  const parsed = adjustIndiciesToUcs2(patches, text, {\n    allowExceedingIndices: opts.allowExceedingIndices\n  }), margin = opts.margin || DEFAULT_MARGIN, deleteThreshold = opts.deleteThreshold || 0.4, nullPadding = addPadding(parsed, margin);\n  text = nullPadding + text + nullPadding, splitMax(parsed, margin);\n  let delta = 0;\n  const results = [];\n  for (let x = 0; x < parsed.length; x++) {\n    const expectedLoc = parsed[x].start2 + delta, text1 = diffText1(parsed[x].diffs);\n    let startLoc, endLoc = -1;\n    if (text1.length > MAX_BITS ? (startLoc = match(text, text1.substring(0, MAX_BITS), expectedLoc), startLoc !== -1 && (endLoc = match(text, text1.substring(text1.length - MAX_BITS), expectedLoc + text1.length - MAX_BITS), (endLoc === -1 || startLoc >= endLoc) && (startLoc = -1))) : startLoc = match(text, text1, expectedLoc), startLoc === -1) results[x] = !1, delta -= parsed[x].length2 - parsed[x].length1;\n    else {\n      results[x] = !0, delta = startLoc - expectedLoc;\n      let text2;\n      if (endLoc === -1 ? text2 = text.substring(startLoc, startLoc + text1.length) : text2 = text.substring(startLoc, endLoc + MAX_BITS), text1 === text2) text = text.substring(0, startLoc) + diffText2(parsed[x].diffs) + text.substring(startLoc + text1.length);\n      else {\n        let diffs = diff(text1, text2, {\n          checkLines: !1\n        });\n        if (text1.length > MAX_BITS && levenshtein(diffs) / text1.length > deleteThreshold) results[x] = !1;\n        else {\n          diffs = cleanupSemanticLossless(diffs);\n          let index1 = 0, index2 = 0;\n          for (let y = 0; y < parsed[x].diffs.length; y++) {\n            const mod = parsed[x].diffs[y];\n            mod[0] !== DIFF_EQUAL && (index2 = xIndex(diffs, index1)), mod[0] === DIFF_INSERT ? text = text.substring(0, startLoc + index2) + mod[1] + text.substring(startLoc + index2) : mod[0] === DIFF_DELETE && (text = text.substring(0, startLoc + index2) + text.substring(startLoc + xIndex(diffs, index1 + mod[1].length))), mod[0] !== DIFF_DELETE && (index1 += mod[1].length);\n          }\n        }\n      }\n    }\n  }\n  return text = text.substring(nullPadding.length, text.length - nullPadding.length), [text, results];\n}\nconst patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\nfunction parse(textline) {\n  if (!textline) return [];\n  const patches = [], lines = textline.split(`\n`);\n  let textPointer = 0;\n  for (; textPointer < lines.length; ) {\n    const m = lines[textPointer].match(patchHeader);\n    if (!m) throw new Error(`Invalid patch string: ${lines[textPointer]}`);\n    const patch = createPatchObject(toInt(m[1]), toInt(m[3]));\n    for (patches.push(patch), m[2] === \"\" ? (patch.start1--, patch.utf8Start1--, patch.length1 = 1, patch.utf8Length1 = 1) : m[2] === \"0\" ? (patch.length1 = 0, patch.utf8Length1 = 0) : (patch.start1--, patch.utf8Start1--, patch.utf8Length1 = toInt(m[2]), patch.length1 = patch.utf8Length1), m[4] === \"\" ? (patch.start2--, patch.utf8Start2--, patch.length2 = 1, patch.utf8Length2 = 1) : m[4] === \"0\" ? (patch.length2 = 0, patch.utf8Length2 = 0) : (patch.start2--, patch.utf8Start2--, patch.utf8Length2 = toInt(m[4]), patch.length2 = patch.utf8Length2), textPointer++; textPointer < lines.length; ) {\n      const currentLine = lines[textPointer], sign = currentLine.charAt(0);\n      if (sign === \"@\") break;\n      if (sign === \"\") {\n        textPointer++;\n        continue;\n      }\n      let line;\n      try {\n        line = decodeURI(currentLine.slice(1));\n      } catch {\n        throw new Error(`Illegal escape in parse: ${currentLine}`);\n      }\n      const utf8Diff = countUtf8Bytes(line) - line.length;\n      if (sign === \"-\") patch.diffs.push([DIFF_DELETE, line]), patch.length1 -= utf8Diff;\n      else if (sign === \"+\") patch.diffs.push([DIFF_INSERT, line]), patch.length2 -= utf8Diff;\n      else if (sign === \" \") patch.diffs.push([DIFF_EQUAL, line]), patch.length1 -= utf8Diff, patch.length2 -= utf8Diff;\n      else throw new Error(`Invalid patch mode \"${sign}\" in: ${line}`);\n      textPointer++;\n    }\n  }\n  return patches;\n}\nfunction toInt(num) {\n  return parseInt(num, 10);\n}\nconst CURRENT_UNDO_STEP = /* @__PURE__ */ new WeakMap();\nfunction getCurrentUndoStepId(editor) {\n  return CURRENT_UNDO_STEP.get(editor)?.undoStepId;\n}\nfunction createUndoStep(editor) {\n  CURRENT_UNDO_STEP.set(editor, {\n    undoStepId: (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.defaultKeyGenerator)()\n  });\n}\nfunction clearUndoStep(editor) {\n  CURRENT_UNDO_STEP.set(editor, void 0);\n}\nconst debug$b = debugWithName(\"plugin:withUndoRedo\"), SAVING = /* @__PURE__ */ new WeakMap(), REMOTE_PATCHES = /* @__PURE__ */ new WeakMap(), UNDO_STEP_LIMIT = 1e3, isSaving = (editor) => {\n  const state = SAVING.get(editor);\n  return state === void 0 ? !0 : state;\n}, getRemotePatches = (editor) => (REMOTE_PATCHES.get(editor) || REMOTE_PATCHES.set(editor, []), REMOTE_PATCHES.get(editor) || []);\nfunction createWithUndoRedo(options) {\n  const {\n    editorActor\n  } = options;\n  return (editor) => {\n    let previousSnapshot = fromSlateValue(editor.children, editorActor.getSnapshot().context.schema.block.name);\n    const remotePatches = getRemotePatches(editor);\n    let previousUndoStepId = getCurrentUndoStepId(editor);\n    options.subscriptions.push(() => {\n      debug$b(\"Subscribing to patches\");\n      const sub = editorActor.on(\"patches\", ({\n        patches,\n        snapshot\n      }) => {\n        let reset = !1;\n        patches.forEach((patch) => {\n          if (!reset && patch.origin !== \"local\" && remotePatches) {\n            if (patch.type === \"unset\" && patch.path.length === 0) {\n              debug$b(\"Someone else cleared the content, resetting undo/redo history\"), editor.history = {\n                undos: [],\n                redos: []\n              }, remotePatches.splice(0, remotePatches.length), SAVING.set(editor, !0), reset = !0;\n              return;\n            }\n            remotePatches.push({\n              patch,\n              time: /* @__PURE__ */ new Date(),\n              snapshot,\n              previousSnapshot\n            });\n          }\n        }), previousSnapshot = snapshot;\n      });\n      return () => {\n        debug$b(\"Unsubscribing to patches\"), sub.unsubscribe();\n      };\n    }), editor.history = {\n      undos: [],\n      redos: []\n    };\n    const {\n      apply: apply2\n    } = editor;\n    return editor.apply = (op) => {\n      if (editorActor.getSnapshot().matches({\n        \"edit mode\": \"read only\"\n      })) {\n        apply2(op);\n        return;\n      }\n      if (isChangingRemotely(editor)) {\n        apply2(op);\n        return;\n      }\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply2(op);\n        return;\n      }\n      const {\n        operations,\n        history\n      } = editor, {\n        undos\n      } = history, step = undos[undos.length - 1], lastOp = step && step.operations && step.operations[step.operations.length - 1], overwrite = shouldOverwrite(op, lastOp), save = isSaving(editor), currentUndoStepId = getCurrentUndoStepId(editor);\n      let merge = currentUndoStepId === previousUndoStepId;\n      if (save) {\n        if (step ? operations.length === 0 && (merge = currentUndoStepId === void 0 && previousUndoStepId === void 0 ? shouldMerge(op, lastOp) || overwrite : merge) : merge = !1, step && merge)\n          step.operations.push(op);\n        else {\n          const newStep = {\n            operations: [...editor.selection === null ? [] : [createSelectOperation(editor)], op],\n            timestamp: /* @__PURE__ */ new Date()\n          };\n          undos.push(newStep), debug$b(\"Created new undo step\", step);\n        }\n        for (; undos.length > UNDO_STEP_LIMIT; )\n          undos.shift();\n        shouldClear(op) && (history.redos = []);\n      }\n      previousUndoStepId = currentUndoStepId, apply2(op);\n    }, editor;\n  };\n}\nconst historyUndoOperationImplementation = ({\n  operation\n}) => {\n  const editor = operation.editor, {\n    undos\n  } = editor.history, remotePatches = getRemotePatches(editor);\n  if (undos.length > 0) {\n    const step = undos[undos.length - 1];\n    if (debug$b(\"Undoing\", step), step.operations.length > 0) {\n      const otherPatches = remotePatches.filter((item) => item.time >= step.timestamp);\n      let transformedOperations = step.operations;\n      otherPatches.forEach((item) => {\n        transformedOperations = lodash_flatten_js__WEBPACK_IMPORTED_MODULE_7__(transformedOperations.map((op) => transformOperation(editor, item.patch, op, item.snapshot, item.previousSnapshot)));\n      });\n      const reversedOperations = transformedOperations.map(slate__WEBPACK_IMPORTED_MODULE_14__.Operation.inverse).reverse();\n      try {\n        slate__WEBPACK_IMPORTED_MODULE_14__.Editor.withoutNormalizing(editor, () => {\n          withUndoing(editor, () => {\n            withoutSaving(editor, () => {\n              reversedOperations.forEach((op) => {\n                editor.apply(op);\n              });\n            });\n          });\n        });\n      } catch (err) {\n        debug$b(\"Could not perform undo step\", err), remotePatches.splice(0, remotePatches.length), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.deselect(editor), editor.history = {\n          undos: [],\n          redos: []\n        }, SAVING.set(editor, !0), setIsUndoing(editor, !1), editor.onChange();\n        return;\n      }\n      editor.history.redos.push(step), editor.history.undos.pop();\n    }\n  }\n}, historyRedoOperationImplementation = ({\n  operation\n}) => {\n  const editor = operation.editor, {\n    redos\n  } = editor.history, remotePatches = getRemotePatches(editor);\n  if (redos.length > 0) {\n    const step = redos[redos.length - 1];\n    if (debug$b(\"Redoing\", step), step.operations.length > 0) {\n      const otherPatches = remotePatches.filter((item) => item.time >= step.timestamp);\n      let transformedOperations = step.operations;\n      otherPatches.forEach((item) => {\n        transformedOperations = lodash_flatten_js__WEBPACK_IMPORTED_MODULE_7__(transformedOperations.map((op) => transformOperation(editor, item.patch, op, item.snapshot, item.previousSnapshot)));\n      });\n      try {\n        slate__WEBPACK_IMPORTED_MODULE_14__.Editor.withoutNormalizing(editor, () => {\n          withRedoing(editor, () => {\n            withoutSaving(editor, () => {\n              transformedOperations.forEach((op) => {\n                editor.apply(op);\n              });\n            });\n          });\n        });\n      } catch (err) {\n        debug$b(\"Could not perform redo step\", err), remotePatches.splice(0, remotePatches.length), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.deselect(editor), editor.history = {\n          undos: [],\n          redos: []\n        }, SAVING.set(editor, !0), setIsRedoing(editor, !1), editor.onChange();\n        return;\n      }\n      editor.history.undos.push(step), editor.history.redos.pop();\n    }\n  }\n};\nfunction transformOperation(editor, patch, operation, snapshot, previousSnapshot) {\n  const transformedOperation = {\n    ...operation\n  };\n  if (patch.type === \"insert\" && patch.path.length === 1) {\n    const insertBlockIndex = (snapshot || []).findIndex((blk) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__({\n      _key: blk._key\n    }, patch.path[0]));\n    return debug$b(`Adjusting block path (+${patch.items.length}) for '${transformedOperation.type}' operation and patch '${patch.type}'`), [adjustBlockPath(transformedOperation, patch.items.length, insertBlockIndex)];\n  }\n  if (patch.type === \"unset\" && patch.path.length === 1) {\n    const unsetBlockIndex = (previousSnapshot || []).findIndex((blk) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__({\n      _key: blk._key\n    }, patch.path[0]));\n    return \"path\" in transformedOperation && Array.isArray(transformedOperation.path) && transformedOperation.path[0] === unsetBlockIndex ? (debug$b(\"Skipping transformation that targeted removed block\"), []) : [adjustBlockPath(transformedOperation, -1, unsetBlockIndex)];\n  }\n  if (patch.type === \"unset\" && patch.path.length === 0)\n    return debug$b(`Adjusting selection for unset everything patch and ${operation.type} operation`), [];\n  if (patch.type === \"diffMatchPatch\") {\n    const operationTargetBlock = findOperationTargetBlock(editor, transformedOperation);\n    return !operationTargetBlock || !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__({\n      _key: operationTargetBlock._key\n    }, patch.path[0]) ? [transformedOperation] : (parse(patch.value).forEach((diffPatch) => {\n      let adjustOffsetBy = 0, changedOffset = diffPatch.utf8Start1;\n      const {\n        diffs\n      } = diffPatch;\n      if (diffs.forEach((diff2, index) => {\n        const [diffType, text] = diff2;\n        diffType === DIFF_INSERT ? (adjustOffsetBy += text.length, changedOffset += text.length) : diffType === DIFF_DELETE ? (adjustOffsetBy -= text.length, changedOffset -= text.length) : diffType === DIFF_EQUAL && (diffs.slice(index).every(([dType]) => dType === DIFF_EQUAL) || (changedOffset += text.length));\n      }), transformedOperation.type === \"insert_text\" && changedOffset < transformedOperation.offset && (transformedOperation.offset += adjustOffsetBy), transformedOperation.type === \"remove_text\" && changedOffset <= transformedOperation.offset - transformedOperation.text.length && (transformedOperation.offset += adjustOffsetBy), transformedOperation.type === \"set_selection\") {\n        const currentFocus = transformedOperation.properties?.focus ? {\n          ...transformedOperation.properties.focus\n        } : void 0, currentAnchor = transformedOperation?.properties?.anchor ? {\n          ...transformedOperation.properties.anchor\n        } : void 0, newFocus = transformedOperation?.newProperties?.focus ? {\n          ...transformedOperation.newProperties.focus\n        } : void 0, newAnchor = transformedOperation?.newProperties?.anchor ? {\n          ...transformedOperation.newProperties.anchor\n        } : void 0;\n        (currentFocus && currentAnchor || newFocus && newAnchor) && ([currentFocus, currentAnchor, newFocus, newAnchor].forEach((point) => {\n          point && changedOffset < point.offset && (point.offset += adjustOffsetBy);\n        }), currentFocus && currentAnchor && (transformedOperation.properties = {\n          focus: currentFocus,\n          anchor: currentAnchor\n        }), newFocus && newAnchor && (transformedOperation.newProperties = {\n          focus: newFocus,\n          anchor: newAnchor\n        }));\n      }\n    }), [transformedOperation]);\n  }\n  return [transformedOperation];\n}\nfunction adjustBlockPath(operation, level, blockIndex) {\n  const transformedOperation = {\n    ...operation\n  };\n  if (blockIndex >= 0 && transformedOperation.type !== \"set_selection\" && Array.isArray(transformedOperation.path) && transformedOperation.path[0] >= blockIndex + level && transformedOperation.path[0] + level > -1) {\n    const newPath = [transformedOperation.path[0] + level, ...transformedOperation.path.slice(1)];\n    transformedOperation.path = newPath;\n  }\n  if (transformedOperation.type === \"set_selection\") {\n    const currentFocus = transformedOperation.properties?.focus ? {\n      ...transformedOperation.properties.focus\n    } : void 0, currentAnchor = transformedOperation?.properties?.anchor ? {\n      ...transformedOperation.properties.anchor\n    } : void 0, newFocus = transformedOperation?.newProperties?.focus ? {\n      ...transformedOperation.newProperties.focus\n    } : void 0, newAnchor = transformedOperation?.newProperties?.anchor ? {\n      ...transformedOperation.newProperties.anchor\n    } : void 0;\n    (currentFocus && currentAnchor || newFocus && newAnchor) && ([currentFocus, currentAnchor, newFocus, newAnchor].forEach((point) => {\n      point && point.path[0] >= blockIndex + level && point.path[0] + level > -1 && (point.path = [point.path[0] + level, ...point.path.slice(1)]);\n    }), currentFocus && currentAnchor && (transformedOperation.properties = {\n      focus: currentFocus,\n      anchor: currentAnchor\n    }), newFocus && newAnchor && (transformedOperation.newProperties = {\n      focus: newFocus,\n      anchor: newAnchor\n    }));\n  }\n  return transformedOperation;\n}\nconst shouldMerge = (op, prev) => !!(op.type === \"set_selection\" || prev && op.type === \"insert_text\" && prev.type === \"insert_text\" && op.offset === prev.offset + prev.text.length && slate__WEBPACK_IMPORTED_MODULE_14__.Path.equals(op.path, prev.path) && op.text !== \" \" || prev && op.type === \"remove_text\" && prev.type === \"remove_text\" && op.offset + op.text.length === prev.offset && slate__WEBPACK_IMPORTED_MODULE_14__.Path.equals(op.path, prev.path)), shouldOverwrite = (op, prev) => !!(prev && op.type === \"set_selection\" && prev.type === \"set_selection\"), shouldClear = (op) => op.type !== \"set_selection\";\nfunction withoutSaving(editor, fn) {\n  const prev = isSaving(editor);\n  SAVING.set(editor, !1), fn(), SAVING.set(editor, prev);\n}\nfunction createSelectOperation(editor) {\n  return {\n    type: \"set_selection\",\n    properties: {\n      ...editor.selection\n    },\n    newProperties: {\n      ...editor.selection\n    }\n  };\n}\nfunction findOperationTargetBlock(editor, operation) {\n  let block;\n  return operation.type === \"set_selection\" && editor.selection ? block = editor.children[editor.selection.focus.path[0]] : \"path\" in operation && (block = editor.children[operation.path[0]]), block;\n}\nconst addAnnotationOperationImplementation = ({\n  context,\n  operation\n}) => {\n  const parsedAnnotation = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.parseAnnotation)({\n    annotation: {\n      _type: operation.annotation.name,\n      ...operation.annotation.value\n    },\n    context,\n    options: {\n      validateFields: !0\n    }\n  });\n  if (!parsedAnnotation)\n    throw new Error(`Failed to parse annotation ${JSON.stringify(operation.annotation)}`);\n  const editor = operation.editor;\n  if (!editor.selection || slate__WEBPACK_IMPORTED_MODULE_14__.Range.isCollapsed(editor.selection))\n    return;\n  const selectedBlocks = slate__WEBPACK_IMPORTED_MODULE_14__.Editor.nodes(editor, {\n    at: editor.selection,\n    match: (node) => editor.isTextBlock(node),\n    reverse: slate__WEBPACK_IMPORTED_MODULE_14__.Range.isBackward(editor.selection)\n  });\n  let blockIndex = 0;\n  for (const [block, blockPath] of selectedBlocks) {\n    if (block.children.length === 0 || block.children.length === 1 && block.children[0].text === \"\")\n      continue;\n    const annotationKey = blockIndex === 0 ? parsedAnnotation._key : context.keyGenerator(), markDefs = block.markDefs ?? [];\n    markDefs.find((markDef) => markDef._type === parsedAnnotation._type && markDef._key === annotationKey) === void 0 && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {\n      markDefs: [...markDefs, {\n        ...parsedAnnotation,\n        _key: annotationKey\n      }]\n    }, {\n      at: blockPath\n    }), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {}, {\n      match: slate__WEBPACK_IMPORTED_MODULE_14__.Text.isText,\n      split: !0\n    });\n    const children = slate__WEBPACK_IMPORTED_MODULE_14__.Node.children(editor, blockPath);\n    for (const [span, path] of children) {\n      if (!editor.isTextSpan(span) || !slate__WEBPACK_IMPORTED_MODULE_14__.Range.includes(editor.selection, path))\n        continue;\n      const marks = span.marks ?? [];\n      slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {\n        marks: [...marks, annotationKey]\n      }, {\n        at: path\n      });\n    }\n    blockIndex++;\n  }\n}, removeAnnotationOperationImplementation = ({\n  operation\n}) => {\n  const editor = operation.editor;\n  if (editor.selection)\n    if (slate__WEBPACK_IMPORTED_MODULE_14__.Range.isCollapsed(editor.selection)) {\n      const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_14__.Editor.node(editor, editor.selection, {\n        depth: 1\n      });\n      if (!editor.isTextBlock(block))\n        return;\n      const potentialAnnotations = (block.markDefs ?? []).filter((markDef) => markDef._type === operation.annotation.name), [selectedChild, selectedChildPath] = slate__WEBPACK_IMPORTED_MODULE_14__.Editor.node(editor, editor.selection, {\n        depth: 2\n      });\n      if (!editor.isTextSpan(selectedChild))\n        return;\n      const annotationToRemove = selectedChild.marks?.find((mark) => potentialAnnotations.some((markDef) => markDef._key === mark));\n      if (!annotationToRemove)\n        return;\n      const previousSpansWithSameAnnotation = [];\n      for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_14__.Node.children(editor, blockPath, {\n        reverse: !0\n      }))\n        if (editor.isTextSpan(child) && slate__WEBPACK_IMPORTED_MODULE_14__.Path.isBefore(childPath, selectedChildPath))\n          if (child.marks?.includes(annotationToRemove))\n            previousSpansWithSameAnnotation.push([child, childPath]);\n          else\n            break;\n      const nextSpansWithSameAnnotation = [];\n      for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_14__.Node.children(editor, blockPath))\n        if (editor.isTextSpan(child) && slate__WEBPACK_IMPORTED_MODULE_14__.Path.isAfter(childPath, selectedChildPath))\n          if (child.marks?.includes(annotationToRemove))\n            nextSpansWithSameAnnotation.push([child, childPath]);\n          else\n            break;\n      for (const [child, childPath] of [...previousSpansWithSameAnnotation, [selectedChild, selectedChildPath], ...nextSpansWithSameAnnotation])\n        slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {\n          marks: child.marks?.filter((mark) => mark !== annotationToRemove)\n        }, {\n          at: childPath\n        });\n    } else {\n      slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {}, {\n        match: (node) => editor.isTextSpan(node),\n        split: !0,\n        hanging: !0\n      });\n      const blocks = slate__WEBPACK_IMPORTED_MODULE_14__.Editor.nodes(editor, {\n        at: editor.selection,\n        match: (node) => editor.isTextBlock(node)\n      });\n      for (const [block, blockPath] of blocks) {\n        const children = slate__WEBPACK_IMPORTED_MODULE_14__.Node.children(editor, blockPath);\n        for (const [child, childPath] of children) {\n          if (!editor.isTextSpan(child) || !slate__WEBPACK_IMPORTED_MODULE_14__.Range.includes(editor.selection, childPath))\n            continue;\n          const markDefs = block.markDefs ?? [], marks = child.marks ?? [], marksWithoutAnnotation = marks.filter((mark) => markDefs.find((markDef2) => markDef2._key === mark)?._type !== operation.annotation.name);\n          marksWithoutAnnotation.length !== marks.length && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {\n            marks: marksWithoutAnnotation\n          }, {\n            at: childPath\n          });\n        }\n      }\n    }\n}, blockSetOperationImplementation = ({\n  context,\n  operation\n}) => {\n  const blockIndex = operation.editor.blockIndexMap.get(operation.at[0]._key);\n  if (blockIndex === void 0)\n    throw new Error(`Unable to find block index for block at ${JSON.stringify(operation.at)}`);\n  const block = operation.editor.value.at(blockIndex);\n  if (!block)\n    throw new Error(`Unable to find block at ${JSON.stringify(operation.at)}`);\n  const {\n    _type,\n    ...filteredProps\n  } = operation.props, updatedBlock = {\n    ...block,\n    ...filteredProps\n  }, parsedBlock = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.parseBlock)({\n    context,\n    block: updatedBlock,\n    options: {\n      removeUnusedMarkDefs: !1,\n      validateFields: !0\n    }\n  });\n  if (!parsedBlock)\n    throw new Error(`Unable to update block at ${JSON.stringify(operation.at)}`);\n  const slateBlock = toSlateValue([parsedBlock], {\n    schemaTypes: context.schema\n  })?.at(0);\n  if (!slateBlock)\n    throw new Error(\"Unable to convert block to Slate value\");\n  slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(operation.editor, slateBlock, {\n    at: [blockIndex]\n  });\n}, blockUnsetOperationImplementation = ({\n  context,\n  operation\n}) => {\n  const location = toSlateRange({\n    context: {\n      schema: context.schema,\n      value: operation.editor.value,\n      selection: {\n        anchor: {\n          path: operation.at,\n          offset: 0\n        },\n        focus: {\n          path: operation.at,\n          offset: 0\n        }\n      }\n    },\n    blockIndexMap: operation.editor.blockIndexMap\n  });\n  if (!location)\n    throw new Error(`Unable to convert ${JSON.stringify(operation.at)} into a Slate Range`);\n  const block = slate__WEBPACK_IMPORTED_MODULE_14__.Editor.node(operation.editor, location, {\n    depth: 1\n  })?.[0];\n  if (!block)\n    throw new Error(`Unable to find block at ${JSON.stringify(operation.at)}`);\n  const parsedBlock = fromSlateValue([block], context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(operation.editor)).at(0);\n  if (!parsedBlock)\n    throw new Error(`Unable to parse block at ${JSON.stringify(operation.at)}`);\n  if ((0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(context, parsedBlock)) {\n    const propsToRemove = operation.props.filter((prop) => prop !== \"_type\"), updatedTextBlock = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.parseBlock)({\n      context,\n      block: lodash_omit_js__WEBPACK_IMPORTED_MODULE_8__(parsedBlock, propsToRemove),\n      options: {\n        removeUnusedMarkDefs: !0,\n        validateFields: !0\n      }\n    });\n    if (!updatedTextBlock)\n      throw new Error(`Unable to update block at ${JSON.stringify(operation.at)}`);\n    const propsToSet = {};\n    for (const prop of propsToRemove)\n      prop in updatedTextBlock ? propsToSet[prop] = updatedTextBlock[prop] : propsToSet[prop] = void 0;\n    slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(operation.editor, propsToSet, {\n      at: location\n    });\n    return;\n  }\n  const updatedBlockObject = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.parseBlock)({\n    context,\n    block: lodash_omit_js__WEBPACK_IMPORTED_MODULE_8__(parsedBlock, operation.props.filter((prop) => prop !== \"_type\")),\n    options: {\n      removeUnusedMarkDefs: !0,\n      validateFields: !0\n    }\n  });\n  if (!updatedBlockObject)\n    throw new Error(`Unable to update block at ${JSON.stringify(operation.at)}`);\n  const {\n    _type,\n    _key,\n    ...props\n  } = updatedBlockObject;\n  slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(operation.editor, {\n    _type,\n    _key,\n    value: props\n  }, {\n    at: location\n  });\n}, childSetOperationImplementation = ({\n  context,\n  operation\n}) => {\n  const location = toSlateRange({\n    context: {\n      schema: context.schema,\n      value: operation.editor.value,\n      selection: {\n        anchor: {\n          path: operation.at,\n          offset: 0\n        },\n        focus: {\n          path: operation.at,\n          offset: 0\n        }\n      }\n    },\n    blockIndexMap: operation.editor.blockIndexMap\n  });\n  if (!location)\n    throw new Error(`Unable to convert ${JSON.stringify(operation.at)} into a Slate Range`);\n  const childEntry = slate__WEBPACK_IMPORTED_MODULE_14__.Editor.node(operation.editor, location, {\n    depth: 2\n  }), child = childEntry?.[0], childPath = childEntry?.[1];\n  if (!child || !childPath)\n    throw new Error(`Unable to find child at ${JSON.stringify(operation.at)}`);\n  if (operation.editor.isTextSpan(child)) {\n    const {\n      _type,\n      text,\n      ...rest\n    } = operation.props;\n    slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(operation.editor, {\n      ...child,\n      ...rest\n    }, {\n      at: childPath\n    }), typeof text == \"string\" && child.text !== text && (operation.editor.apply({\n      type: \"remove_text\",\n      path: childPath,\n      offset: 0,\n      text: child.text\n    }), operation.editor.apply({\n      type: \"insert_text\",\n      path: childPath,\n      offset: 0,\n      text\n    }));\n    return;\n  }\n  if (slate__WEBPACK_IMPORTED_MODULE_14__.Element.isElement(child)) {\n    const definition = context.schema.inlineObjects.find((definition2) => definition2.name === child._type);\n    if (!definition)\n      throw new Error(`Unable to find schema definition for Inline Object type ${child._type}`);\n    const value = \"value\" in child && typeof child.value == \"object\" ? child.value : {}, {\n      _type,\n      _key,\n      ...rest\n    } = operation.props;\n    for (const prop in rest)\n      definition.fields.some((field) => field.name === prop) || delete rest[prop];\n    slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(operation.editor, {\n      ...child,\n      _key: typeof _key == \"string\" ? _key : child._key,\n      value: {\n        ...value,\n        ...rest\n      }\n    }, {\n      at: childPath\n    });\n    return;\n  }\n  throw new Error(`Unable to determine the type of child at ${JSON.stringify(operation.at)}`);\n}, childUnsetOperationImplementation = ({\n  context,\n  operation\n}) => {\n  const location = toSlateRange({\n    context: {\n      schema: context.schema,\n      value: operation.editor.value,\n      selection: {\n        anchor: {\n          path: operation.at,\n          offset: 0\n        },\n        focus: {\n          path: operation.at,\n          offset: 0\n        }\n      }\n    },\n    blockIndexMap: operation.editor.blockIndexMap\n  });\n  if (!location)\n    throw new Error(`Unable to convert ${JSON.stringify(operation.at)} into a Slate Range`);\n  const childEntry = slate__WEBPACK_IMPORTED_MODULE_14__.Editor.node(operation.editor, location, {\n    depth: 2\n  }), child = childEntry?.[0], childPath = childEntry?.[1];\n  if (!child || !childPath)\n    throw new Error(`Unable to find child at ${JSON.stringify(operation.at)}`);\n  if (operation.editor.isTextSpan(child)) {\n    operation.props.includes(\"text\") && operation.editor.apply({\n      type: \"remove_text\",\n      path: childPath,\n      offset: 0,\n      text: child.text\n    });\n    const newNode = {};\n    for (const prop of operation.props)\n      if (prop !== \"_type\") {\n        if (prop === \"_key\") {\n          newNode._key = context.keyGenerator();\n          continue;\n        }\n        newNode[prop] = null;\n      }\n    slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(operation.editor, newNode, {\n      at: childPath\n    });\n    return;\n  }\n  if (slate__WEBPACK_IMPORTED_MODULE_14__.Element.isElement(child)) {\n    const value = \"value\" in child && typeof child.value == \"object\" ? child.value : {}, patches = operation.props.map((prop) => ({\n      type: \"unset\",\n      path: [prop]\n    })), newValue = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.applyAll)(value, patches);\n    slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(operation.editor, {\n      ...child,\n      _key: operation.props.includes(\"_key\") ? context.keyGenerator() : child._key,\n      value: newValue\n    }, {\n      at: childPath\n    });\n    return;\n  }\n  throw new Error(`Unable to determine the type of child at ${JSON.stringify(operation.at)}`);\n}, decoratorAddOperationImplementation = ({\n  context,\n  operation\n}) => {\n  const editor = operation.editor, mark = operation.decorator, value = fromSlateValue(editor.children, context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), manualAnchor = operation.at?.anchor ? (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.blockOffsetToSpanSelectionPoint)({\n    context: {\n      ...context,\n      value\n    },\n    blockOffset: operation.at.anchor,\n    direction: \"backward\"\n  }) : void 0, manualFocus = operation.at?.focus ? (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.blockOffsetToSpanSelectionPoint)({\n    context: {\n      ...context,\n      value\n    },\n    blockOffset: operation.at.focus,\n    direction: \"forward\"\n  }) : void 0, manualSelection = manualAnchor && manualFocus ? {\n    anchor: manualAnchor,\n    focus: manualFocus\n  } : void 0, selection = manualSelection ? toSlateRange({\n    context: {\n      schema: context.schema,\n      value: operation.editor.value,\n      selection: manualSelection\n    },\n    blockIndexMap: operation.editor.blockIndexMap\n  }) ?? editor.selection : editor.selection;\n  if (!selection)\n    return;\n  const editorSelection = slateRangeToSelection({\n    schema: context.schema,\n    editor,\n    range: selection\n  }), anchorOffset = editorSelection ? (0,_chunks_es_util_slice_text_block_js__WEBPACK_IMPORTED_MODULE_32__.selectionPointToBlockOffset)({\n    context: {\n      ...context,\n      value\n    },\n    selectionPoint: editorSelection.anchor\n  }) : void 0, focusOffset = editorSelection ? (0,_chunks_es_util_slice_text_block_js__WEBPACK_IMPORTED_MODULE_32__.selectionPointToBlockOffset)({\n    context: {\n      ...context,\n      value\n    },\n    selectionPoint: editorSelection.focus\n  }) : void 0;\n  if (!anchorOffset || !focusOffset)\n    throw new Error(\"Unable to find anchor or focus offset\");\n  if (slate__WEBPACK_IMPORTED_MODULE_14__.Range.isExpanded(selection)) {\n    slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {}, {\n      at: selection,\n      match: slate__WEBPACK_IMPORTED_MODULE_14__.Text.isText,\n      split: !0,\n      hanging: !0\n    });\n    const newValue = fromSlateValue(editor.children, context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), newSelection = (0,_chunks_es_util_child_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_33__.blockOffsetsToSelection)({\n      context: {\n        ...context,\n        value: newValue\n      },\n      offsets: {\n        anchor: anchorOffset,\n        focus: focusOffset\n      },\n      backward: editorSelection?.backward\n    }), trimmedSelection = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getTrimmedSelection)({\n      blockIndexMap: editor.blockIndexMap,\n      context: {\n        converters: [],\n        keyGenerator: context.keyGenerator,\n        readOnly: !1,\n        schema: context.schema,\n        selection: newSelection,\n        value: newValue\n      },\n      decoratorState: editor.decoratorState\n    });\n    if (!trimmedSelection)\n      throw new Error(\"Unable to find trimmed selection\");\n    const newRange = toSlateRange({\n      context: {\n        schema: context.schema,\n        value: operation.editor.value,\n        selection: trimmedSelection\n      },\n      blockIndexMap: operation.editor.blockIndexMap\n    });\n    if (!newRange)\n      throw new Error(\"Unable to find new selection\");\n    const splitTextNodes = slate__WEBPACK_IMPORTED_MODULE_14__.Range.isRange(newRange) ? [...slate__WEBPACK_IMPORTED_MODULE_14__.Editor.nodes(editor, {\n      at: newRange,\n      match: (node) => slate__WEBPACK_IMPORTED_MODULE_14__.Text.isText(node)\n    })] : [];\n    for (const [node, path] of splitTextNodes) {\n      const marks = [...(Array.isArray(node.marks) ? node.marks : []).filter((eMark) => eMark !== mark), mark];\n      slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {\n        marks\n      }, {\n        at: path,\n        match: slate__WEBPACK_IMPORTED_MODULE_14__.Text.isText,\n        split: !0,\n        hanging: !0\n      });\n    }\n  } else {\n    if (!Array.from(slate__WEBPACK_IMPORTED_MODULE_14__.Editor.nodes(editor, {\n      at: selection,\n      match: (node) => editor.isTextSpan(node)\n    }))?.at(0))\n      return;\n    const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_14__.Editor.node(editor, selection, {\n      depth: 1\n    }), lonelyEmptySpan = editor.isTextBlock(block) && block.children.length === 1 && editor.isTextSpan(block.children[0]) && block.children[0].text === \"\" ? block.children[0] : void 0;\n    if (lonelyEmptySpan) {\n      const existingMarks = lonelyEmptySpan.marks ?? [], existingMarksWithoutDecorator = existingMarks.filter((existingMark) => existingMark !== mark);\n      slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {\n        marks: existingMarks.length === existingMarksWithoutDecorator.length ? [...existingMarks, mark] : existingMarksWithoutDecorator\n      }, {\n        at: blockPath,\n        match: (node) => editor.isTextSpan(node)\n      });\n    } else\n      editor.decoratorState[mark] = !0;\n  }\n  if (editor.selection) {\n    const selection2 = editor.selection;\n    editor.selection = {\n      ...selection2\n    };\n  }\n}, deleteOperationImplementation = ({\n  context,\n  operation\n}) => {\n  const anchorBlockKey = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.getBlockKeyFromSelectionPoint)(operation.at.anchor), focusBlockKey = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.getBlockKeyFromSelectionPoint)(operation.at.focus), startBlockKey = operation.at.backward ? focusBlockKey : anchorBlockKey, endBlockKey = operation.at.backward ? anchorBlockKey : focusBlockKey, endOffset = operation.at.backward ? operation.at.focus.offset : operation.at.anchor.offset;\n  if (!startBlockKey)\n    throw new Error(\"Failed to get start block key\");\n  if (!endBlockKey)\n    throw new Error(\"Failed to get end block key\");\n  const startBlockIndex = operation.editor.blockIndexMap.get(startBlockKey);\n  if (startBlockIndex === void 0)\n    throw new Error(\"Failed to get start block index\");\n  const startBlock = operation.editor.value.at(startBlockIndex);\n  if (!startBlock)\n    throw new Error(\"Failed to get start block\");\n  const endBlockIndex = operation.editor.blockIndexMap.get(endBlockKey);\n  if (endBlockIndex === void 0)\n    throw new Error(\"Failed to get end block index\");\n  const endBlock = operation.editor.value.at(endBlockIndex);\n  if (!endBlock)\n    throw new Error(\"Failed to get end block\");\n  if (operation.unit === \"block\") {\n    slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.removeNodes(operation.editor, {\n      at: {\n        anchor: {\n          path: [startBlockIndex],\n          offset: 0\n        },\n        focus: {\n          path: [endBlockIndex],\n          offset: 0\n        }\n      },\n      mode: \"highest\"\n    }), operation.editor.children.length === 0 && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertNodes(operation.editor, createPlaceholderBlock(context));\n    return;\n  }\n  const range = toSlateRange({\n    context: {\n      schema: context.schema,\n      value: operation.editor.value,\n      selection: operation.at\n    },\n    blockIndexMap: operation.editor.blockIndexMap\n  });\n  if (!range)\n    throw new Error(`Failed to get Slate Range for selection ${JSON.stringify(operation.at)}`);\n  if (operation.direction === \"backward\" && operation.unit === \"line\") {\n    const parentBlockEntry = slate__WEBPACK_IMPORTED_MODULE_14__.Editor.above(operation.editor, {\n      match: (n) => slate__WEBPACK_IMPORTED_MODULE_14__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_14__.Editor.isBlock(operation.editor, n),\n      at: range\n    });\n    if (parentBlockEntry) {\n      const [, parentBlockPath] = parentBlockEntry, parentElementRange = slate__WEBPACK_IMPORTED_MODULE_14__.Editor.range(operation.editor, parentBlockPath, range.anchor), currentLineRange = findCurrentLineRange(operation.editor, parentElementRange);\n      if (!slate__WEBPACK_IMPORTED_MODULE_14__.Range.isCollapsed(currentLineRange)) {\n        slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.delete(operation.editor, {\n          at: currentLineRange\n        });\n        return;\n      }\n    }\n  }\n  const hanging = (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(context, endBlock) && endOffset === 0;\n  (0,slate__WEBPACK_IMPORTED_MODULE_14__.deleteText)(operation.editor, {\n    at: range,\n    reverse: operation.direction === \"backward\",\n    unit: operation.unit,\n    hanging\n  }), operation.editor.selection && (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(context, startBlock) && (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(context, endBlock) && (0,slate__WEBPACK_IMPORTED_MODULE_14__.setSelection)(operation.editor, {\n    anchor: operation.editor.selection.focus,\n    focus: operation.editor.selection.focus\n  });\n};\nfunction findCurrentLineRange(editor, parentRange) {\n  const parentRangeBoundary = slate__WEBPACK_IMPORTED_MODULE_14__.Editor.range(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Range.end(parentRange)), positions = Array.from(slate__WEBPACK_IMPORTED_MODULE_14__.Editor.positions(editor, {\n    at: parentRange\n  }));\n  let left = 0, right = positions.length, middle = Math.floor(right / 2);\n  if (rangesAreOnSameLine(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Editor.range(editor, positions[left]), parentRangeBoundary))\n    return slate__WEBPACK_IMPORTED_MODULE_14__.Editor.range(editor, positions[left], parentRangeBoundary);\n  if (positions.length < 2)\n    return slate__WEBPACK_IMPORTED_MODULE_14__.Editor.range(editor, positions[positions.length - 1], parentRangeBoundary);\n  for (; middle !== positions.length && middle !== left; )\n    rangesAreOnSameLine(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Editor.range(editor, positions[middle]), parentRangeBoundary) ? right = middle : left = middle, middle = Math.floor((left + right) / 2);\n  return slate__WEBPACK_IMPORTED_MODULE_14__.Editor.range(editor, positions[left], parentRangeBoundary);\n}\nfunction rangesAreOnSameLine(editor, range1, range2) {\n  const rect1 = slate_dom__WEBPACK_IMPORTED_MODULE_17__.DOMEditor.toDOMRange(editor, range1).getBoundingClientRect(), rect2 = slate_dom__WEBPACK_IMPORTED_MODULE_17__.DOMEditor.toDOMRange(editor, range2).getBoundingClientRect();\n  return domRectsIntersect(rect1, rect2) && domRectsIntersect(rect2, rect1);\n}\nfunction domRectsIntersect(rect, compareRect) {\n  const middle = (compareRect.top + compareRect.bottom) / 2;\n  return rect.top <= middle && rect.bottom >= middle;\n}\nconst insertBlockOperationImplementation = ({\n  context,\n  operation\n}) => {\n  const parsedBlock = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.parseBlock)({\n    block: operation.block,\n    context,\n    options: {\n      removeUnusedMarkDefs: !0,\n      validateFields: !0\n    }\n  });\n  if (!parsedBlock)\n    throw new Error(`Failed to parse block ${JSON.stringify(operation.block)}`);\n  const fragment = toSlateValue([parsedBlock], {\n    schemaTypes: context.schema\n  })[0];\n  if (!fragment)\n    throw new Error(`Failed to convert block to Slate fragment ${JSON.stringify(parsedBlock)}`);\n  insertBlock({\n    context,\n    block: fragment,\n    placement: operation.placement,\n    select: operation.select ?? \"start\",\n    editor: operation.editor\n  });\n};\nfunction insertBlock({\n  context,\n  block,\n  placement,\n  select,\n  editor\n}) {\n  const [startBlock, startBlockPath] = getSelectionStartBlock({\n    editor\n  }), [endBlock, endBlockPath] = getSelectionEndBlock({\n    editor\n  });\n  if (!editor.selection || !startBlock || !startBlockPath || !endBlock || !endBlockPath) {\n    select !== \"none\" && slate_dom__WEBPACK_IMPORTED_MODULE_17__.DOMEditor.focus(editor);\n    const [lastBlock, lastBlockPath] = getLastBlock({\n      editor\n    });\n    if (placement === \"before\")\n      slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertNodes(editor, [block], {\n        at: [0]\n      }), select === \"start\" ? slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Editor.start(editor, [0])) : select === \"end\" && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Editor.end(editor, [0]));\n    else if (placement === \"after\") {\n      const nextPath = lastBlockPath ? [lastBlockPath[0] + 1] : [0];\n      slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertNodes(editor, [block], {\n        at: nextPath\n      }), select === \"start\" ? slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Editor.start(editor, nextPath)) : select === \"end\" && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Editor.end(editor, nextPath));\n    } else {\n      if (lastBlock && isEqualToEmptyEditor([lastBlock], context.schema)) {\n        slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.removeNodes(editor, {\n          at: lastBlockPath\n        }), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertNodes(editor, [block], {\n          at: lastBlockPath,\n          select: !1\n        }), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.deselect(editor), select === \"start\" ? slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Editor.start(editor, lastBlockPath)) : select === \"end\" && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Editor.end(editor, lastBlockPath));\n        return;\n      }\n      if (editor.isTextBlock(block) && lastBlock && editor.isTextBlock(lastBlock)) {\n        const selectionBefore = slate__WEBPACK_IMPORTED_MODULE_14__.Editor.end(editor, lastBlockPath);\n        slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertFragment(editor, [block], {\n          at: slate__WEBPACK_IMPORTED_MODULE_14__.Editor.end(editor, lastBlockPath)\n        }), select === \"start\" ? slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, selectionBefore) : select === \"none\" && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.deselect(editor);\n        return;\n      }\n      const nextPath = lastBlockPath ? [lastBlockPath[0] + 1] : [0];\n      slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertNodes(editor, [block], {\n        at: nextPath,\n        select: !1\n      }), select === \"start\" ? slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Editor.start(editor, nextPath)) : select === \"end\" && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Editor.end(editor, nextPath));\n    }\n  } else if (placement === \"before\") {\n    const currentSelection = editor.selection, selectionStartPoint = slate__WEBPACK_IMPORTED_MODULE_14__.Range.start(currentSelection);\n    slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertNodes(editor, [block], {\n      at: [selectionStartPoint.path[0]],\n      select: !1\n    }), select === \"start\" ? slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Editor.start(editor, [selectionStartPoint.path[0]])) : select === \"end\" && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Editor.end(editor, [selectionStartPoint.path[0]]));\n  } else if (placement === \"after\") {\n    const currentSelection = editor.selection, nextPath = [slate__WEBPACK_IMPORTED_MODULE_14__.Range.end(currentSelection).path[0] + 1];\n    slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertNodes(editor, [block], {\n      at: nextPath,\n      select: !1\n    }), select === \"start\" ? slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Editor.start(editor, nextPath)) : select === \"end\" && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Editor.end(editor, nextPath));\n  } else {\n    const currentSelection = editor.selection, endBlockEndPoint = slate__WEBPACK_IMPORTED_MODULE_14__.Editor.start(editor, endBlockPath);\n    if (slate__WEBPACK_IMPORTED_MODULE_14__.Range.isExpanded(currentSelection) && !editor.isTextBlock(block)) {\n      slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.delete(editor, {\n        at: currentSelection\n      });\n      const newSelection = editor.selection, [focusBlock, focusBlockPath] = getFocusBlock({\n        editor\n      });\n      slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertNodes(editor, [block], {\n        voids: !0\n      });\n      const adjustedSelection = newSelection.anchor.offset === 0 ? slate__WEBPACK_IMPORTED_MODULE_14__.Range.transform(newSelection, {\n        type: \"insert_node\",\n        node: block,\n        path: [newSelection.anchor.path[0]]\n      }) : newSelection;\n      select === \"none\" && adjustedSelection && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, adjustedSelection), focusBlock && isEqualToEmptyEditor([focusBlock], context.schema) && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.removeNodes(editor, {\n        at: focusBlockPath\n      });\n      return;\n    }\n    if (editor.isTextBlock(endBlock) && editor.isTextBlock(block)) {\n      const selectionStartPoint = slate__WEBPACK_IMPORTED_MODULE_14__.Range.start(currentSelection);\n      if (isEqualToEmptyEditor([endBlock], context.schema)) {\n        const currentSelection2 = editor.selection;\n        slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertNodes(editor, [block], {\n          at: endBlockPath,\n          select: !1\n        }), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.removeNodes(editor, {\n          at: slate__WEBPACK_IMPORTED_MODULE_14__.Path.next(endBlockPath)\n        }), select === \"start\" ? slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, selectionStartPoint) : select === \"end\" ? slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Editor.end(editor, endBlockPath)) : slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, currentSelection2);\n        return;\n      }\n      const endBlockChildKeys = endBlock.children.map((child) => child._key), endBlockMarkDefsKeys = endBlock.markDefs?.map((markDef) => markDef._key) ?? [], markDefKeyMap = /* @__PURE__ */ new Map(), adjustedMarkDefs = block.markDefs?.map((markDef) => {\n        if (endBlockMarkDefsKeys.includes(markDef._key)) {\n          const newKey = context.keyGenerator();\n          return markDefKeyMap.set(markDef._key, newKey), {\n            ...markDef,\n            _key: newKey\n          };\n        }\n        return markDef;\n      }), adjustedChildren = block.children.map((child) => {\n        if ((0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isSpan)(context, child)) {\n          const marks = child.marks?.map((mark) => markDefKeyMap.get(mark) || mark) ?? [];\n          if (!lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__(child.marks, marks))\n            return {\n              ...child,\n              _key: endBlockChildKeys.includes(child._key) ? context.keyGenerator() : child._key,\n              marks\n            };\n        }\n        return endBlockChildKeys.includes(child._key) ? {\n          ...child,\n          _key: context.keyGenerator()\n        } : child;\n      });\n      slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {\n        markDefs: [...endBlock.markDefs ?? [], ...adjustedMarkDefs ?? []]\n      }, {\n        at: endBlockPath\n      });\n      const adjustedBlock = lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__(block.children, adjustedChildren) ? block : {\n        ...block,\n        children: adjustedChildren\n      };\n      if (select === \"end\") {\n        slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertFragment(editor, [adjustedBlock], {\n          voids: !0\n        });\n        return;\n      }\n      slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertFragment(editor, [adjustedBlock], {\n        at: currentSelection,\n        voids: !0\n      }), select === \"start\" ? slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, selectionStartPoint) : slate__WEBPACK_IMPORTED_MODULE_14__.Point.equals(selectionStartPoint, endBlockEndPoint) || slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, selectionStartPoint);\n    } else if (editor.isTextBlock(endBlock)) {\n      const endBlockStartPoint = slate__WEBPACK_IMPORTED_MODULE_14__.Editor.start(editor, endBlockPath), endBlockEndPoint2 = slate__WEBPACK_IMPORTED_MODULE_14__.Editor.end(editor, endBlockPath), selectionStartPoint = slate__WEBPACK_IMPORTED_MODULE_14__.Range.start(currentSelection), selectionEndPoint = slate__WEBPACK_IMPORTED_MODULE_14__.Range.end(currentSelection);\n      if (slate__WEBPACK_IMPORTED_MODULE_14__.Range.isCollapsed(currentSelection) && slate__WEBPACK_IMPORTED_MODULE_14__.Point.equals(selectionStartPoint, endBlockStartPoint))\n        slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertNodes(editor, [block], {\n          at: endBlockPath,\n          select: !1\n        }), (select === \"start\" || select === \"end\") && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Editor.start(editor, endBlockPath)), (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.isEmptyTextBlock)(context, endBlock) && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.removeNodes(editor, {\n          at: slate__WEBPACK_IMPORTED_MODULE_14__.Path.next(endBlockPath)\n        });\n      else if (slate__WEBPACK_IMPORTED_MODULE_14__.Range.isCollapsed(currentSelection) && slate__WEBPACK_IMPORTED_MODULE_14__.Point.equals(selectionEndPoint, endBlockEndPoint2)) {\n        const nextPath = [endBlockPath[0] + 1];\n        slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertNodes(editor, [block], {\n          at: nextPath,\n          select: !1\n        }), (select === \"start\" || select === \"end\") && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Editor.start(editor, nextPath));\n      } else if (slate__WEBPACK_IMPORTED_MODULE_14__.Range.isExpanded(currentSelection) && slate__WEBPACK_IMPORTED_MODULE_14__.Point.equals(selectionStartPoint, endBlockStartPoint) && slate__WEBPACK_IMPORTED_MODULE_14__.Point.equals(selectionEndPoint, endBlockEndPoint2))\n        slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertFragment(editor, [block], {\n          at: currentSelection\n        }), select === \"start\" ? slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Editor.start(editor, endBlockPath)) : select === \"end\" && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Editor.end(editor, endBlockPath));\n      else if (slate__WEBPACK_IMPORTED_MODULE_14__.Range.isExpanded(currentSelection) && slate__WEBPACK_IMPORTED_MODULE_14__.Point.equals(selectionStartPoint, endBlockStartPoint))\n        slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertFragment(editor, [block], {\n          at: currentSelection\n        }), select === \"start\" ? slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Editor.start(editor, endBlockPath)) : select === \"end\" && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Editor.end(editor, endBlockPath));\n      else if (slate__WEBPACK_IMPORTED_MODULE_14__.Range.isExpanded(currentSelection) && slate__WEBPACK_IMPORTED_MODULE_14__.Point.equals(selectionEndPoint, endBlockEndPoint2))\n        slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertFragment(editor, [block], {\n          at: currentSelection\n        }), select === \"start\" ? slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Editor.start(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Path.next(endBlockPath))) : select === \"end\" && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Editor.end(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Path.next(endBlockPath)));\n      else {\n        const currentSelection2 = editor.selection, [focusChild] = getFocusChild({\n          editor\n        });\n        if (focusChild && editor.isTextSpan(focusChild))\n          slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.splitNodes(editor, {\n            at: currentSelection2\n          }), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertFragment(editor, [block], {\n            at: currentSelection2\n          }), select === \"start\" || select === \"end\" ? slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, [endBlockPath[0] + 1]) : slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, currentSelection2);\n        else {\n          const nextPath = [endBlockPath[0] + 1];\n          slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertNodes(editor, [block], {\n            at: nextPath,\n            select: !1\n          }), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, currentSelection2), select === \"start\" ? slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Editor.start(editor, nextPath)) : select === \"end\" && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Editor.end(editor, nextPath));\n        }\n      }\n    } else {\n      slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertNodes(editor, [block], {\n        select: !1\n      });\n      const nextPath = [endBlockPath[0] + 1];\n      select === \"start\" ? slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Editor.start(editor, nextPath)) : select === \"end\" && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_14__.Editor.end(editor, nextPath));\n    }\n  }\n}\nconst insertChildOperationImplementation = ({\n  context,\n  operation\n}) => {\n  const focus = operation.editor.selection?.focus, focusBlockIndex = focus?.path.at(0), focusChildIndex = focus?.path.at(1);\n  if (focusBlockIndex === void 0 || focusChildIndex === void 0)\n    throw new Error(\"Unable to insert child without a focus\");\n  const [focusBlock, focusBlockPath] = getFocusBlock({\n    editor: operation.editor\n  });\n  if (!focus || !focusBlock || !focusBlockPath)\n    throw new Error(\"Unable to insert child without a focus block\");\n  if (!(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(context, focusBlock))\n    throw new Error(\"Unable to insert child into a non-text block\");\n  const markDefs = focusBlock.markDefs ?? [], markDefKeyMap = /* @__PURE__ */ new Map();\n  for (const markDef of markDefs)\n    markDefKeyMap.set(markDef._key, markDef._key);\n  const span = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.parseSpan)({\n    span: operation.child,\n    context,\n    markDefKeyMap,\n    options: {\n      validateFields: !0\n    }\n  });\n  if (span) {\n    const [focusSpan] = getFocusSpan({\n      editor: operation.editor\n    });\n    focusSpan ? slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertNodes(operation.editor, span, {\n      at: focus,\n      select: !0\n    }) : slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertNodes(operation.editor, span, {\n      at: [focusBlockIndex, focusChildIndex + 1],\n      select: !0\n    }), slate_dom__WEBPACK_IMPORTED_MODULE_17__.EDITOR_TO_PENDING_SELECTION.set(operation.editor, operation.editor.selection);\n    return;\n  }\n  const inlineObject = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.parseInlineObject)({\n    inlineObject: operation.child,\n    context,\n    options: {\n      validateFields: !0\n    }\n  });\n  if (inlineObject) {\n    const {\n      _key,\n      _type,\n      ...rest\n    } = inlineObject;\n    slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertNodes(operation.editor, {\n      _key,\n      _type,\n      children: [{\n        _key: VOID_CHILD_KEY,\n        _type: \"span\",\n        text: \"\",\n        marks: []\n      }],\n      value: rest,\n      __inline: !0\n    }, {\n      at: [focusBlockIndex, focusChildIndex + 1],\n      select: !0\n    });\n    return;\n  }\n  throw new Error(\"Unable to parse child\");\n}, insertTextOperationImplementation = ({\n  operation\n}) => {\n  slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertText(operation.editor, operation.text);\n}, moveBackwardOperationImplementation = ({\n  operation\n}) => {\n  slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.move(operation.editor, {\n    unit: \"character\",\n    distance: operation.distance,\n    reverse: !0\n  });\n}, moveBlockOperationImplementation = ({\n  operation\n}) => {\n  const originKey = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.getBlockKeyFromSelectionPoint)({\n    path: operation.at\n  });\n  if (!originKey)\n    throw new Error(\"Failed to get block key from selection point\");\n  const originBlockIndex = operation.editor.blockIndexMap.get(originKey);\n  if (originBlockIndex === void 0)\n    throw new Error(\"Failed to get block index from block key\");\n  const destinationKey = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.getBlockKeyFromSelectionPoint)({\n    path: operation.to\n  });\n  if (!destinationKey)\n    throw new Error(\"Failed to get block key from selection point\");\n  const destinationBlockIndex = operation.editor.blockIndexMap.get(destinationKey);\n  if (destinationBlockIndex === void 0)\n    throw new Error(\"Failed to get block index from block key\");\n  slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.moveNodes(operation.editor, {\n    at: [originBlockIndex],\n    to: [destinationBlockIndex],\n    mode: \"highest\"\n  });\n}, moveForwardOperationImplementation = ({\n  operation\n}) => {\n  slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.move(operation.editor, {\n    unit: \"character\",\n    distance: operation.distance\n  });\n}, selectOperationImplementation = ({\n  context,\n  operation\n}) => {\n  const newSelection = toSlateRange({\n    context: {\n      schema: context.schema,\n      value: operation.editor.value,\n      selection: operation.at\n    },\n    blockIndexMap: operation.editor.blockIndexMap\n  });\n  newSelection ? slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(operation.editor, newSelection) : slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.deselect(operation.editor), slate_dom__WEBPACK_IMPORTED_MODULE_17__.IS_FOCUSED.get(operation.editor) && slate_dom__WEBPACK_IMPORTED_MODULE_17__.IS_READ_ONLY.get(operation.editor) && slate_dom__WEBPACK_IMPORTED_MODULE_17__.IS_FOCUSED.set(operation.editor, !1);\n}, behaviorOperationImplementations = {\n  \"annotation.add\": addAnnotationOperationImplementation,\n  \"annotation.remove\": removeAnnotationOperationImplementation,\n  \"block.set\": blockSetOperationImplementation,\n  \"block.unset\": blockUnsetOperationImplementation,\n  \"child.set\": childSetOperationImplementation,\n  \"child.unset\": childUnsetOperationImplementation,\n  \"decorator.add\": decoratorAddOperationImplementation,\n  \"decorator.remove\": removeDecoratorOperationImplementation,\n  delete: deleteOperationImplementation,\n  \"history.redo\": historyRedoOperationImplementation,\n  \"history.undo\": historyUndoOperationImplementation,\n  \"insert.block\": insertBlockOperationImplementation,\n  \"insert.child\": insertChildOperationImplementation,\n  \"insert.text\": insertTextOperationImplementation,\n  \"move.backward\": moveBackwardOperationImplementation,\n  \"move.block\": moveBlockOperationImplementation,\n  \"move.forward\": moveForwardOperationImplementation,\n  select: selectOperationImplementation\n};\nfunction performOperation({\n  context,\n  operation\n}) {\n  slate__WEBPACK_IMPORTED_MODULE_14__.Editor.withoutNormalizing(operation.editor, () => {\n    try {\n      switch (operation.type) {\n        case \"annotation.add\": {\n          behaviorOperationImplementations[\"annotation.add\"]({\n            context,\n            operation\n          });\n          break;\n        }\n        case \"annotation.remove\": {\n          behaviorOperationImplementations[\"annotation.remove\"]({\n            context,\n            operation\n          });\n          break;\n        }\n        case \"block.set\": {\n          behaviorOperationImplementations[\"block.set\"]({\n            context,\n            operation\n          });\n          break;\n        }\n        case \"block.unset\": {\n          behaviorOperationImplementations[\"block.unset\"]({\n            context,\n            operation\n          });\n          break;\n        }\n        case \"child.set\": {\n          behaviorOperationImplementations[\"child.set\"]({\n            context,\n            operation\n          });\n          break;\n        }\n        case \"child.unset\": {\n          behaviorOperationImplementations[\"child.unset\"]({\n            context,\n            operation\n          });\n          break;\n        }\n        case \"decorator.add\": {\n          behaviorOperationImplementations[\"decorator.add\"]({\n            context,\n            operation\n          });\n          break;\n        }\n        case \"decorator.remove\": {\n          behaviorOperationImplementations[\"decorator.remove\"]({\n            context,\n            operation\n          });\n          break;\n        }\n        case \"delete\": {\n          behaviorOperationImplementations.delete({\n            context,\n            operation\n          });\n          break;\n        }\n        case \"history.redo\": {\n          behaviorOperationImplementations[\"history.redo\"]({\n            context,\n            operation\n          });\n          break;\n        }\n        case \"history.undo\": {\n          behaviorOperationImplementations[\"history.undo\"]({\n            context,\n            operation\n          });\n          break;\n        }\n        case \"insert.block\": {\n          behaviorOperationImplementations[\"insert.block\"]({\n            context,\n            operation\n          });\n          break;\n        }\n        case \"insert.child\": {\n          behaviorOperationImplementations[\"insert.child\"]({\n            context,\n            operation\n          });\n          break;\n        }\n        case \"insert.text\": {\n          behaviorOperationImplementations[\"insert.text\"]({\n            context,\n            operation\n          });\n          break;\n        }\n        case \"move.backward\": {\n          behaviorOperationImplementations[\"move.backward\"]({\n            context,\n            operation\n          });\n          break;\n        }\n        case \"move.block\": {\n          behaviorOperationImplementations[\"move.block\"]({\n            context,\n            operation\n          });\n          break;\n        }\n        case \"move.forward\": {\n          behaviorOperationImplementations[\"move.forward\"]({\n            context,\n            operation\n          });\n          break;\n        }\n        default: {\n          behaviorOperationImplementations.select({\n            context,\n            operation\n          });\n          break;\n        }\n      }\n    } catch (error) {\n      console.error(new Error(`Executing \"${operation.type}\" failed due to: ${error.message}`));\n    }\n  });\n}\nconst IS_PERFORMING_OPERATION = /* @__PURE__ */ new WeakMap();\nfunction withPerformingBehaviorOperation(editor, fn) {\n  const prev = IS_PERFORMING_OPERATION.get(editor);\n  IS_PERFORMING_OPERATION.set(editor, !0), fn(), IS_PERFORMING_OPERATION.set(editor, prev);\n}\nfunction isPerformingBehaviorOperation(editor) {\n  return IS_PERFORMING_OPERATION.get(editor) ?? !1;\n}\nfunction createWithEventListeners(editorActor) {\n  return function(editor) {\n    if (editorActor.getSnapshot().context.maxBlocks !== void 0)\n      return editor;\n    const {\n      delete: editorDelete,\n      select\n    } = editor;\n    return editor.delete = (options) => {\n      if (isPerformingBehaviorOperation(editor)) {\n        editorDelete(options);\n        return;\n      }\n      const at = options?.at ?? editor.selection;\n      if (!at) {\n        console.error(\"Unexpected call to .delete(...) without `at` option\");\n        return;\n      }\n      const range = slate__WEBPACK_IMPORTED_MODULE_14__.Editor.range(editor, at), selection = slateRangeToSelection({\n        schema: editorActor.getSnapshot().context.schema,\n        editor,\n        range\n      });\n      if (!selection) {\n        console.error(\"Unexpected call to .delete(...) with invalid `at` option\");\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"delete\",\n          at: selection,\n          direction: options?.reverse ? \"backward\" : \"forward\",\n          unit: options?.unit\n        },\n        editor\n      });\n    }, editor.deleteBackward = (unit) => {\n      if (isPerformingBehaviorOperation(editor)) {\n        console.error(\"Unexpected call to .deleteBackward(...)\");\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"delete.backward\",\n          unit\n        },\n        editor\n      });\n    }, editor.deleteForward = (unit) => {\n      if (isPerformingBehaviorOperation(editor)) {\n        console.error(\"Unexpected call to .deleteForward(...)\");\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"delete.forward\",\n          unit\n        },\n        editor\n      });\n    }, editor.insertBreak = () => {\n      if (isPerformingBehaviorOperation(editor)) {\n        console.error(\"Unexpected call to .insertBreak(...)\");\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"insert.break\"\n        },\n        editor\n      });\n    }, editor.insertData = (dataTransfer) => {\n      if (isPerformingBehaviorOperation(editor)) {\n        console.error(\"Unexpected call to .insertData(...)\");\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"input.*\",\n          originEvent: {\n            dataTransfer\n          }\n        },\n        editor\n      });\n    }, editor.insertSoftBreak = () => {\n      if (isPerformingBehaviorOperation(editor)) {\n        performOperation({\n          context: {\n            keyGenerator: editorActor.getSnapshot().context.keyGenerator,\n            schema: editorActor.getSnapshot().context.schema\n          },\n          operation: {\n            type: \"insert.text\",\n            text: `\n`,\n            editor\n          }\n        });\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"insert.soft break\"\n        },\n        editor\n      });\n    }, editor.insertText = (text) => {\n      if (isPerformingBehaviorOperation(editor)) {\n        performOperation({\n          context: {\n            keyGenerator: editorActor.getSnapshot().context.keyGenerator,\n            schema: editorActor.getSnapshot().context.schema\n          },\n          operation: {\n            type: \"insert.text\",\n            text,\n            editor\n          }\n        });\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"insert.text\",\n          text\n        },\n        editor\n      });\n    }, editor.redo = () => {\n      if (isPerformingBehaviorOperation(editor)) {\n        performOperation({\n          context: {\n            keyGenerator: editorActor.getSnapshot().context.keyGenerator,\n            schema: editorActor.getSnapshot().context.schema\n          },\n          operation: {\n            type: \"history.redo\",\n            editor\n          }\n        });\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"history.redo\"\n        },\n        editor\n      });\n    }, editor.select = (location) => {\n      if (isPerformingBehaviorOperation(editor)) {\n        select(location);\n        return;\n      }\n      const range = slate__WEBPACK_IMPORTED_MODULE_14__.Editor.range(editor, location);\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"select\",\n          at: slateRangeToSelection({\n            schema: editorActor.getSnapshot().context.schema,\n            editor,\n            range\n          })\n        },\n        editor\n      });\n    }, editor.setFragmentData = () => {\n      console.error(\"Unexpected call to .setFragmentData(...)\");\n    }, editor.undo = () => {\n      if (isPerformingBehaviorOperation(editor)) {\n        performOperation({\n          context: {\n            keyGenerator: editorActor.getSnapshot().context.keyGenerator,\n            schema: editorActor.getSnapshot().context.schema\n          },\n          operation: {\n            type: \"history.undo\",\n            editor\n          }\n        });\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"history.undo\"\n        },\n        editor\n      });\n    }, editor;\n  };\n}\nfunction createWithMaxBlocks(editorActor) {\n  return function(editor) {\n    const {\n      apply: apply2\n    } = editor;\n    return editor.apply = (operation) => {\n      if (editorActor.getSnapshot().matches({\n        \"edit mode\": \"read only\"\n      })) {\n        apply2(operation);\n        return;\n      }\n      if (isChangingRemotely(editor)) {\n        apply2(operation);\n        return;\n      }\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply2(operation);\n        return;\n      }\n      const rows = editorActor.getSnapshot().context.maxBlocks ?? -1;\n      rows > 0 && editor.children.length >= rows && (operation.type === \"insert_node\" || operation.type === \"split_node\") && operation.path.length === 1 || apply2(operation);\n    }, editor;\n  };\n}\nfunction createWithObjectKeys(editorActor) {\n  return function(editor) {\n    const {\n      apply: apply2,\n      normalizeNode\n    } = editor;\n    return editor.apply = (operation) => {\n      if (isChangingRemotely(editor)) {\n        apply2(operation);\n        return;\n      }\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply2(operation);\n        return;\n      }\n      if (operation.type === \"split_node\") {\n        const existingKeys = [...slate__WEBPACK_IMPORTED_MODULE_14__.Node.descendants(editor)].map(([node]) => node._key);\n        apply2({\n          ...operation,\n          properties: {\n            ...operation.properties,\n            _key: operation.properties._key === void 0 || existingKeys.includes(operation.properties._key) ? editorActor.getSnapshot().context.keyGenerator() : operation.properties._key\n          }\n        });\n        return;\n      }\n      if (operation.type === \"insert_node\" && !slate__WEBPACK_IMPORTED_MODULE_14__.Editor.isEditor(operation.node)) {\n        const existingKeys = [...slate__WEBPACK_IMPORTED_MODULE_14__.Node.descendants(editor)].map(([node]) => node._key);\n        apply2({\n          ...operation,\n          node: {\n            ...operation.node,\n            _key: operation.node._key === void 0 || existingKeys.includes(operation.node._key) ? editorActor.getSnapshot().context.keyGenerator() : operation.node._key\n          }\n        });\n        return;\n      }\n      if (operation.type === \"merge_node\") {\n        const index = operation.path[operation.path.length - 1], prevPath = slate__WEBPACK_IMPORTED_MODULE_14__.Path.previous(operation.path), prevIndex = prevPath[prevPath.length - 1];\n        if (operation.path.length !== 1 || prevPath.length !== 1) {\n          apply2(operation);\n          return;\n        }\n        const block = editor.value.at(index), previousBlock = editor.value.at(prevIndex);\n        if (!block || !previousBlock) {\n          apply2(operation);\n          return;\n        }\n        if (!(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(editorActor.getSnapshot().context, block) || !(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(editorActor.getSnapshot().context, previousBlock)) {\n          apply2(operation);\n          return;\n        }\n        const previousBlockChildKeys = previousBlock.children.map((child) => child._key), previousBlockMarkDefKeys = previousBlock.markDefs?.map((markDef) => markDef._key) ?? [], markDefKeyMap = /* @__PURE__ */ new Map(), adjustedMarkDefs = block.markDefs?.map((markDef) => {\n          if (previousBlockMarkDefKeys.includes(markDef._key)) {\n            const newKey = editorActor.getSnapshot().context.keyGenerator();\n            return markDefKeyMap.set(markDef._key, newKey), {\n              ...markDef,\n              _key: newKey\n            };\n          }\n          return markDef;\n        });\n        let childIndex = 0;\n        for (const child of block.children) {\n          if ((0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isSpan)(editorActor.getSnapshot().context, child)) {\n            const marks = child.marks?.map((mark) => markDefKeyMap.get(mark) || mark) ?? [];\n            lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__(child.marks, marks) || slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {\n              marks\n            }, {\n              at: [index, childIndex]\n            });\n          }\n          previousBlockChildKeys.includes(child._key) && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {\n            _key: editorActor.getSnapshot().context.keyGenerator()\n          }, {\n            at: [index, childIndex]\n          }), childIndex++;\n        }\n        apply2({\n          ...operation,\n          properties: {\n            ...operation.properties,\n            // Make sure the adjusted markDefs are carried along for the merge\n            // operation\n            markDefs: adjustedMarkDefs\n          }\n        });\n        return;\n      }\n      apply2(operation);\n    }, editor.normalizeNode = (entry) => {\n      const [node, path] = entry;\n      if (slate__WEBPACK_IMPORTED_MODULE_14__.Element.isElement(node) && node._type === editorActor.getSnapshot().context.schema.block.name) {\n        if (!node._key) {\n          editorActor.send({\n            type: \"normalizing\"\n          }), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {\n            _key: editorActor.getSnapshot().context.keyGenerator()\n          }, {\n            at: path\n          }), editorActor.send({\n            type: \"done normalizing\"\n          });\n          return;\n        }\n        for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_14__.Node.children(editor, path))\n          if (!child._key) {\n            editorActor.send({\n              type: \"normalizing\"\n            }), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {\n              _key: editorActor.getSnapshot().context.keyGenerator()\n            }, {\n              at: childPath\n            }), editorActor.send({\n              type: \"done normalizing\"\n            });\n            return;\n          }\n      }\n      normalizeNode(entry);\n    }, editor;\n  };\n}\nfunction createApplyPatch(schema) {\n  return (editor, patch) => {\n    let changed = !1;\n    try {\n      switch (patch.type) {\n        case \"insert\":\n          changed = insertPatch(editor, patch, schema);\n          break;\n        case \"unset\":\n          changed = unsetPatch(editor, patch);\n          break;\n        case \"set\":\n          changed = setPatch(editor, patch);\n          break;\n        case \"diffMatchPatch\":\n          changed = diffMatchPatch(editor, patch);\n          break;\n      }\n    } catch (err) {\n      console.error(err);\n    }\n    return changed;\n  };\n}\nfunction diffMatchPatch(editor, patch) {\n  const block = findBlock(editor.children, patch.path);\n  if (!block)\n    return !1;\n  const child = findBlockChild(block, patch.path);\n  if (!child || !(block && editor.isTextBlock(block.node) && patch.path.length === 4 && patch.path[1] === \"children\" && patch.path[3] === \"text\") || !slate__WEBPACK_IMPORTED_MODULE_14__.Text.isText(child.node))\n    return !1;\n  const patches = parse(patch.value), [newValue] = apply(patches, child.node.text, {\n    allowExceedingIndices: !0\n  }), diff$1 = cleanupEfficiency(diff(child.node.text, newValue), 5);\n  let offset = 0;\n  for (const [op, text] of diff$1)\n    op === DIFF_INSERT ? (editor.apply({\n      type: \"insert_text\",\n      path: [block.index, child.index],\n      offset,\n      text\n    }), offset += text.length) : op === DIFF_DELETE ? editor.apply({\n      type: \"remove_text\",\n      path: [block.index, child.index],\n      offset,\n      text\n    }) : op === DIFF_EQUAL && (offset += text.length);\n  return !0;\n}\nfunction insertPatch(editor, patch, schema) {\n  const block = findBlock(editor.children, patch.path);\n  if (!block || patch.path.length > 1 && patch.path[1] !== \"children\")\n    return !1;\n  if (patch.path.length === 1) {\n    const {\n      items: items2,\n      position: position2\n    } = patch, blocksToInsert = toSlateValue(items2, {\n      schemaTypes: schema\n    }, KEY_TO_SLATE_ELEMENT.get(editor)), targetBlockIndex = block.index, normalizedIdx2 = position2 === \"after\" ? targetBlockIndex + 1 : targetBlockIndex, editorWasEmptyBefore = isEqualToEmptyEditor(editor.children, schema);\n    return slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertNodes(editor, blocksToInsert, {\n      at: [normalizedIdx2]\n    }), editorWasEmptyBefore && typeof patch.path[0] == \"number\" && patch.path[0] === 0 && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.removeNodes(editor, {\n      at: [position2 === \"before\" ? targetBlockIndex + 1 : targetBlockIndex]\n    }), !0;\n  }\n  const {\n    items,\n    position\n  } = patch, targetChild = findBlockChild(block, patch.path);\n  if (!targetChild)\n    return !1;\n  const childrenToInsert = toSlateValue([{\n    ...block.node,\n    children: items\n  }], {\n    schemaTypes: schema\n  }, KEY_TO_SLATE_ELEMENT.get(editor)), normalizedIdx = position === \"after\" ? targetChild.index + 1 : targetChild.index, childInsertPath = [block.index, normalizedIdx];\n  return childrenToInsert && slate__WEBPACK_IMPORTED_MODULE_14__.Element.isElement(childrenToInsert[0]) && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertNodes(editor, childrenToInsert[0].children, {\n    at: childInsertPath\n  }), !0;\n}\nfunction setPatch(editor, patch) {\n  let value = patch.value;\n  typeof patch.path[3] == \"string\" && (value = {}, value[patch.path[3]] = patch.value);\n  const block = findBlock(editor.children, patch.path);\n  if (!block)\n    return !1;\n  const isTextBlock2 = editor.isTextBlock(block.node);\n  if (isTextBlock2 && patch.path.length > 1 && patch.path[1] !== \"children\")\n    return !1;\n  const child = findBlockChild(block, patch.path);\n  if (isTextBlock2 && child) {\n    if (slate__WEBPACK_IMPORTED_MODULE_14__.Text.isText(child.node))\n      if (slate__WEBPACK_IMPORTED_MODULE_14__.Text.isText(value)) {\n        const oldText = child.node.text, newText = value.text;\n        oldText !== newText && (editor.apply({\n          type: \"remove_text\",\n          path: [block.index, child.index],\n          offset: 0,\n          text: oldText\n        }), editor.apply({\n          type: \"insert_text\",\n          path: [block.index, child.index],\n          offset: 0,\n          text: newText\n        }), editor.onChange());\n      } else {\n        const propPath = patch.path.slice(3), propEntry = propPath.at(0);\n        if (propEntry === void 0 || typeof propEntry == \"string\" && [\"_key\", \"_type\", \"text\"].includes(propEntry))\n          return !1;\n        const newNode = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.applyAll)(child.node, [{\n          ...patch,\n          path: propPath\n        }]);\n        slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, newNode, {\n          at: [block.index, child.index]\n        });\n      }\n    else {\n      const propPath = patch.path.slice(3), reservedProps = [\"_key\", \"_type\", \"children\", \"__inline\"], propEntry = propPath.at(0);\n      if (propEntry === void 0 || typeof propEntry == \"string\" && reservedProps.includes(propEntry))\n        return !1;\n      const value2 = \"value\" in child.node && typeof child.node.value == \"object\" ? child.node.value : {}, newValue = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.applyAll)(value2, [{\n        ...patch,\n        path: patch.path.slice(3)\n      }]);\n      slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {\n        ...child.node,\n        value: newValue\n      }, {\n        at: [block.index, child.index]\n      });\n    }\n    return !0;\n  } else if (slate__WEBPACK_IMPORTED_MODULE_14__.Element.isElement(block.node) && patch.path.length === 1) {\n    const {\n      children,\n      ...nextRest\n    } = value, {\n      children: _prevChildren,\n      ...prevRest\n    } = block.node || {\n      children: void 0\n    };\n    editor.apply({\n      type: \"set_node\",\n      path: [block.index],\n      properties: {\n        ...prevRest\n      },\n      newProperties: nextRest\n    });\n    const blockNode = block.node;\n    blockNode.children.forEach((child2, childIndex) => {\n      editor.apply({\n        type: \"remove_node\",\n        path: [block.index, blockNode.children.length - 1 - childIndex],\n        node: child2\n      });\n    }), Array.isArray(children) && children.forEach((child2, childIndex) => {\n      editor.apply({\n        type: \"insert_node\",\n        path: [block.index, childIndex],\n        node: child2\n      });\n    });\n  } else if (block && \"value\" in block.node)\n    if (patch.path.length > 1 && patch.path[1] !== \"children\") {\n      const newVal = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.applyAll)(block.node.value, [{\n        ...patch,\n        path: patch.path.slice(1)\n      }]);\n      slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {\n        ...block.node,\n        value: newVal\n      }, {\n        at: [block.index]\n      });\n    } else\n      return !1;\n  return !0;\n}\nfunction unsetPatch(editor, patch) {\n  if (patch.path.length === 0) {\n    const previousSelection = editor.selection;\n    slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.deselect(editor);\n    const children = slate__WEBPACK_IMPORTED_MODULE_14__.Node.children(editor, [], {\n      reverse: !0\n    });\n    for (const [_, path] of children)\n      slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.removeNodes(editor, {\n        at: path\n      });\n    return slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertNodes(editor, editor.pteCreateTextBlock({\n      decorators: []\n    })), previousSelection && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, {\n      anchor: {\n        path: [0, 0],\n        offset: 0\n      },\n      focus: {\n        path: [0, 0],\n        offset: 0\n      }\n    }), editor.onChange(), !0;\n  }\n  const block = findBlock(editor.children, patch.path);\n  if (!block)\n    return !1;\n  if (patch.path.length === 1) {\n    if (editor.children.length === 1) {\n      const previousSelection = editor.selection;\n      return slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.deselect(editor), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.removeNodes(editor, {\n        at: [block.index]\n      }), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertNodes(editor, editor.pteCreateTextBlock({\n        decorators: []\n      })), previousSelection && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, {\n        anchor: {\n          path: [0, 0],\n          offset: 0\n        },\n        focus: {\n          path: [0, 0],\n          offset: 0\n        }\n      }), editor.onChange(), !0;\n    }\n    return slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.removeNodes(editor, {\n      at: [block.index]\n    }), !0;\n  }\n  const child = findBlockChild(block, patch.path);\n  if (editor.isTextBlock(block.node) && child && patch.path[1] === \"children\" && patch.path.length === 3)\n    return slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.removeNodes(editor, {\n      at: [block.index, child.index]\n    }), !0;\n  if (child && !slate__WEBPACK_IMPORTED_MODULE_14__.Text.isText(child.node)) {\n    const propEntry = patch.path.slice(3).at(0);\n    if (propEntry === void 0 || typeof propEntry == \"string\" && [\"_key\", \"_type\", \"children\", \"__inline\"].includes(propEntry))\n      return !1;\n    const value = \"value\" in child.node && typeof child.node.value == \"object\" ? child.node.value : {}, newValue = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.applyAll)(value, [{\n      ...patch,\n      path: patch.path.slice(3)\n    }]);\n    return slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {\n      ...child.node,\n      value: newValue\n    }, {\n      at: [block.index, child.index]\n    }), !0;\n  }\n  if (child && slate__WEBPACK_IMPORTED_MODULE_14__.Text.isText(child.node)) {\n    const propPath = patch.path.slice(3), propEntry = propPath.at(0);\n    if (propEntry === void 0 || typeof propEntry == \"string\" && [\"_key\", \"_type\"].includes(propEntry))\n      return !1;\n    if (typeof propEntry == \"string\" && propEntry === \"text\")\n      return editor.apply({\n        type: \"remove_text\",\n        path: [block.index, child.index],\n        offset: 0,\n        text: child.node.text\n      }), !0;\n    const newNode = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.applyAll)(child.node, [{\n      ...patch,\n      path: propPath\n    }]), newKeys = Object.keys(newNode), removedProperties = Object.keys(child.node).filter((property) => !newKeys.includes(property));\n    return slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.unsetNodes(editor, removedProperties, {\n      at: [block.index, child.index]\n    }), !0;\n  }\n  if (!child) {\n    if (\"value\" in block.node) {\n      const newVal = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.applyAll)(block.node.value, [{\n        ...patch,\n        path: patch.path.slice(1)\n      }]);\n      return slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {\n        ...block.node,\n        value: newVal\n      }, {\n        at: [block.index]\n      }), !0;\n    }\n    return !1;\n  }\n  return !1;\n}\nfunction findBlock(children, path) {\n  let blockIndex = -1;\n  const block = children.find((node, index) => {\n    const isMatch = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.isKeyedSegment)(path[0]) ? node._key === path[0]._key : index === path[0];\n    return isMatch && (blockIndex = index), isMatch;\n  });\n  if (block)\n    return {\n      node: block,\n      index: blockIndex\n    };\n}\nfunction findBlockChild(block, path) {\n  const blockNode = block.node;\n  if (!slate__WEBPACK_IMPORTED_MODULE_14__.Element.isElement(blockNode) || path[1] !== \"children\")\n    return;\n  let childIndex = -1;\n  const child = blockNode.children.find((node, index) => {\n    const isMatch = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.isKeyedSegment)(path[2]) ? node._key === path[2]._key : index === path[2];\n    return isMatch && (childIndex = index), isMatch;\n  });\n  if (child)\n    return {\n      node: child,\n      index: childIndex\n    };\n}\nfunction insertTextPatch(schema, children, operation, beforeValue) {\n  const block = (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)({\n    schema\n  }, children[operation.path[0]]) && children[operation.path[0]];\n  if (!block)\n    throw new Error(\"Could not find block\");\n  const textChild = (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)({\n    schema\n  }, block) && (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isSpan)({\n    schema\n  }, block.children[operation.path[1]]) && block.children[operation.path[1]];\n  if (!textChild)\n    throw new Error(\"Could not find child\");\n  const path = [{\n    _key: block._key\n  }, \"children\", {\n    _key: textChild._key\n  }, \"text\"], prevBlock = beforeValue[operation.path[0]], prevChild = (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)({\n    schema\n  }, prevBlock) && prevBlock.children[operation.path[1]], prevText = (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isSpan)({\n    schema\n  }, prevChild) ? prevChild.text : \"\", patch = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.diffMatchPatch)(prevText, textChild.text, path);\n  return patch.value.length ? [patch] : [];\n}\nfunction removeTextPatch(schema, children, operation, beforeValue) {\n  const block = children[operation.path[0]];\n  if (!block)\n    throw new Error(\"Could not find block\");\n  const child = (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)({\n    schema\n  }, block) && block.children[operation.path[1]] || void 0, textChild = (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isSpan)({\n    schema\n  }, child) ? child : void 0;\n  if (child && !textChild)\n    throw new Error(\"Expected span\");\n  if (!textChild)\n    throw new Error(\"Could not find child\");\n  const path = [{\n    _key: block._key\n  }, \"children\", {\n    _key: textChild._key\n  }, \"text\"], beforeBlock = beforeValue[operation.path[0]], prevTextChild = (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)({\n    schema\n  }, beforeBlock) && beforeBlock.children[operation.path[1]], prevText = (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isSpan)({\n    schema\n  }, prevTextChild) && prevTextChild.text, patch = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.diffMatchPatch)(prevText || \"\", textChild.text, path);\n  return patch.value ? [patch] : [];\n}\nfunction setNodePatch(schema, children, operation) {\n  if (operation.path.length === 1) {\n    const block = children[operation.path[0]];\n    if (typeof block._key != \"string\")\n      throw new Error(\"Expected block to have a _key\");\n    const setNode = lodash_omitBy_js__WEBPACK_IMPORTED_MODULE_11__({\n      ...children[operation.path[0]],\n      ...operation.newProperties\n    }, lodash_isUndefined_js__WEBPACK_IMPORTED_MODULE_10__);\n    return [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.set)(fromSlateValue([setNode], schema.block.name)[0], [{\n      _key: block._key\n    }])];\n  } else if (operation.path.length === 2) {\n    const block = children[operation.path[0]];\n    if ((0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)({\n      schema\n    }, block)) {\n      const child = block.children[operation.path[1]];\n      if (child) {\n        const blockKey = block._key, childKey = child._key, patches = [], keys = Object.keys(operation.newProperties);\n        return keys.forEach((keyName) => {\n          if (keys.length === 1 && keyName === \"_key\") {\n            const val = lodash_get_js__WEBPACK_IMPORTED_MODULE_9__(operation.newProperties, keyName);\n            patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.set)(val, [{\n              _key: blockKey\n            }, \"children\", block.children.indexOf(child), keyName]));\n          } else {\n            const val = lodash_get_js__WEBPACK_IMPORTED_MODULE_9__(operation.newProperties, keyName);\n            patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.set)(val, [{\n              _key: blockKey\n            }, \"children\", {\n              _key: childKey\n            }, keyName]));\n          }\n        }), patches;\n      }\n      throw new Error(\"Could not find a valid child\");\n    }\n    throw new Error(\"Could not find a valid block\");\n  } else\n    throw new Error(`Unexpected path encountered: ${JSON.stringify(operation.path)}`);\n}\nfunction insertNodePatch(schema, children, operation, beforeValue) {\n  const block = beforeValue[operation.path[0]];\n  if (operation.path.length === 1) {\n    const position = operation.path[0] === 0 ? \"before\" : \"after\", beforeBlock = beforeValue[operation.path[0] - 1], targetKey = operation.path[0] === 0 ? block?._key : beforeBlock?._key;\n    return targetKey ? [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.insert)([fromSlateValue([operation.node], schema.block.name)[0]], position, [{\n      _key: targetKey\n    }])] : [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.setIfMissing)(beforeValue, []), (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.insert)([fromSlateValue([operation.node], schema.block.name)[0]], \"before\", [operation.path[0]])];\n  } else if ((0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)({\n    schema\n  }, block) && operation.path.length === 2 && children[operation.path[0]]) {\n    const position = block.children.length === 0 || !block.children[operation.path[1] - 1] ? \"before\" : \"after\", node = {\n      ...operation.node\n    };\n    !node._type && slate__WEBPACK_IMPORTED_MODULE_14__.Text.isText(node) && (node._type = \"span\", node.marks = []);\n    const child = fromSlateValue([{\n      _key: \"bogus\",\n      _type: schema.block.name,\n      children: [node]\n    }], schema.block.name)[0].children[0];\n    return [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.insert)([child], position, [{\n      _key: block._key\n    }, \"children\", block.children.length <= 1 || !block.children[operation.path[1] - 1] ? 0 : {\n      _key: block.children[operation.path[1] - 1]._key\n    }])];\n  }\n  return [];\n}\nfunction splitNodePatch(schema, children, operation, beforeValue) {\n  const patches = [], splitBlock = children[operation.path[0]];\n  if (!(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)({\n    schema\n  }, splitBlock))\n    throw new Error(`Block with path ${JSON.stringify(operation.path[0])} is not a text block and can't be split`);\n  if (operation.path.length === 1) {\n    const oldBlock = beforeValue[operation.path[0]];\n    if ((0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)({\n      schema\n    }, oldBlock)) {\n      const targetValue = fromSlateValue([children[operation.path[0] + 1]], schema.block.name)[0];\n      targetValue && (patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.insert)([targetValue], \"after\", [{\n        _key: splitBlock._key\n      }])), oldBlock.children.slice(operation.position).forEach((span) => {\n        const path = [{\n          _key: oldBlock._key\n        }, \"children\", {\n          _key: span._key\n        }];\n        patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)(path));\n      }));\n    }\n    return patches;\n  }\n  if (operation.path.length === 2) {\n    const splitSpan = splitBlock.children[operation.path[1]];\n    if ((0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isSpan)({\n      schema\n    }, splitSpan)) {\n      const targetSpans = fromSlateValue([{\n        ...splitBlock,\n        children: splitBlock.children.slice(operation.path[1] + 1, operation.path[1] + 2)\n      }], schema.block.name)[0].children;\n      patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.insert)(targetSpans, \"after\", [{\n        _key: splitBlock._key\n      }, \"children\", {\n        _key: splitSpan._key\n      }])), patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.set)(splitSpan.text, [{\n        _key: splitBlock._key\n      }, \"children\", {\n        _key: splitSpan._key\n      }, \"text\"]));\n    }\n    return patches;\n  }\n  return patches;\n}\nfunction removeNodePatch(schema, beforeValue, operation) {\n  const block = beforeValue[operation.path[0]];\n  if (operation.path.length === 1) {\n    if (block && block._key)\n      return [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([{\n        _key: block._key\n      }])];\n    throw new Error(\"Block not found\");\n  } else if ((0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)({\n    schema\n  }, block) && operation.path.length === 2) {\n    const spanToRemove = block.children[operation.path[1]];\n    return spanToRemove ? block.children.filter((span) => span._key === operation.node._key).length > 1 ? (console.warn(`Multiple spans have \\`_key\\` ${operation.node._key}. It's ambiguous which one to remove.`, JSON.stringify(block, null, 2)), []) : [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([{\n      _key: block._key\n    }, \"children\", {\n      _key: spanToRemove._key\n    }])] : [];\n  } else\n    return [];\n}\nfunction mergeNodePatch(schema, children, operation, beforeValue) {\n  const patches = [], block = beforeValue[operation.path[0]], updatedBlock = children[operation.path[0]];\n  if (operation.path.length === 1)\n    if (block?._key) {\n      const newBlock = fromSlateValue([children[operation.path[0] - 1]], schema.block.name)[0];\n      patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.set)(newBlock, [{\n        _key: newBlock._key\n      }])), patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([{\n        _key: block._key\n      }]));\n    } else\n      throw new Error(\"Target key not found!\");\n  else if ((0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)({\n    schema\n  }, block) && (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)({\n    schema\n  }, updatedBlock) && operation.path.length === 2) {\n    const updatedSpan = updatedBlock.children[operation.path[1] - 1] && (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isSpan)({\n      schema\n    }, updatedBlock.children[operation.path[1] - 1]) ? updatedBlock.children[operation.path[1] - 1] : void 0, removedSpan = block.children[operation.path[1]] && (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isSpan)({\n      schema\n    }, block.children[operation.path[1]]) ? block.children[operation.path[1]] : void 0;\n    updatedSpan && (block.children.filter((span) => span._key === updatedSpan._key).length === 1 ? patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.set)(updatedSpan.text, [{\n      _key: block._key\n    }, \"children\", {\n      _key: updatedSpan._key\n    }, \"text\"])) : console.warn(`Multiple spans have \\`_key\\` ${updatedSpan._key}. It's ambiguous which one to update.`, JSON.stringify(block, null, 2))), removedSpan && (block.children.filter((span) => span._key === removedSpan._key).length === 1 ? patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([{\n      _key: block._key\n    }, \"children\", {\n      _key: removedSpan._key\n    }])) : console.warn(`Multiple spans have \\`_key\\` ${removedSpan._key}. It's ambiguous which one to remove.`, JSON.stringify(block, null, 2)));\n  }\n  return patches;\n}\nfunction moveNodePatch(schema, beforeValue, operation) {\n  const patches = [], block = beforeValue[operation.path[0]], targetBlock = beforeValue[operation.newPath[0]];\n  if (!targetBlock)\n    return patches;\n  if (operation.path.length === 1) {\n    const position = operation.path[0] > operation.newPath[0] ? \"before\" : \"after\";\n    patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([{\n      _key: block._key\n    }])), patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.insert)([fromSlateValue([block], schema.block.name)[0]], position, [{\n      _key: targetBlock._key\n    }]));\n  } else if (operation.path.length === 2 && (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)({\n    schema\n  }, block) && (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)({\n    schema\n  }, targetBlock)) {\n    const child = block.children[operation.path[1]], targetChild = targetBlock.children[operation.newPath[1]], position = operation.newPath[1] === targetBlock.children.length ? \"after\" : \"before\", childToInsert = fromSlateValue([block], schema.block.name)[0].children[operation.path[1]];\n    patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([{\n      _key: block._key\n    }, \"children\", {\n      _key: child._key\n    }])), patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.insert)([childToInsert], position, [{\n      _key: targetBlock._key\n    }, \"children\", {\n      _key: targetChild._key\n    }]));\n  }\n  return patches;\n}\nconst PATCHING = /* @__PURE__ */ new WeakMap();\nfunction withoutPatching(editor, fn) {\n  const prev = isPatching(editor);\n  PATCHING.set(editor, !1), fn(), PATCHING.set(editor, prev);\n}\nfunction isPatching(editor) {\n  return PATCHING.get(editor);\n}\nconst debug$a = debugWithName(\"plugin:withPatches\");\nfunction createWithPatches({\n  editorActor,\n  relayActor,\n  subscriptions\n}) {\n  let previousChildren;\n  const applyPatch = createApplyPatch(editorActor.getSnapshot().context.schema);\n  return function(editor) {\n    IS_PROCESSING_REMOTE_CHANGES.set(editor, !1), PATCHING.set(editor, !0), previousChildren = [...editor.children];\n    const {\n      apply: apply2\n    } = editor;\n    let bufferedPatches = [];\n    const handleBufferedRemotePatches = () => {\n      if (bufferedPatches.length === 0)\n        return;\n      const patches = bufferedPatches;\n      bufferedPatches = [];\n      let changed = !1;\n      withRemoteChanges(editor, () => {\n        slate__WEBPACK_IMPORTED_MODULE_14__.Editor.withoutNormalizing(editor, () => {\n          withoutPatching(editor, () => {\n            withoutSaving(editor, () => {\n              for (const patch of patches) {\n                debug$a.enabled && debug$a(`Handling remote patch ${JSON.stringify(patch)}`);\n                try {\n                  changed = applyPatch(editor, patch);\n                } catch (error) {\n                  console.error(`Applying patch ${JSON.stringify(patch)} failed due to: ${error.message}`);\n                }\n              }\n            });\n          });\n        }), changed && (editor.normalize(), editor.onChange());\n      });\n    }, handlePatches = ({\n      patches\n    }) => {\n      const remotePatches = patches.filter((p) => p.origin !== \"local\");\n      remotePatches.length !== 0 && (bufferedPatches = bufferedPatches.concat(remotePatches), handleBufferedRemotePatches());\n    };\n    return subscriptions.push(() => {\n      debug$a(\"Subscribing to remote patches\");\n      const sub = editorActor.on(\"patches\", handlePatches);\n      return () => {\n        debug$a(\"Unsubscribing to remote patches\"), sub.unsubscribe();\n      };\n    }), editor.apply = (operation) => {\n      let patches = [];\n      previousChildren = editor.children;\n      const editorWasEmpty = isEqualToEmptyEditor(previousChildren, editorActor.getSnapshot().context.schema);\n      apply2(operation);\n      const editorIsEmpty = isEqualToEmptyEditor(editor.children, editorActor.getSnapshot().context.schema);\n      if (!isPatching(editor))\n        return editor;\n      switch (editorWasEmpty && !editorIsEmpty && operation.type !== \"set_selection\" && patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.insert)(previousChildren, \"before\", [0])), operation.type) {\n        case \"insert_text\":\n          patches = [...patches, ...insertTextPatch(editorActor.getSnapshot().context.schema, editor.children, operation, previousChildren)];\n          break;\n        case \"remove_text\":\n          patches = [...patches, ...removeTextPatch(editorActor.getSnapshot().context.schema, editor.children, operation, previousChildren)];\n          break;\n        case \"remove_node\":\n          patches = [...patches, ...removeNodePatch(editorActor.getSnapshot().context.schema, previousChildren, operation)];\n          break;\n        case \"split_node\":\n          patches = [...patches, ...splitNodePatch(editorActor.getSnapshot().context.schema, editor.children, operation, previousChildren)];\n          break;\n        case \"insert_node\":\n          patches = [...patches, ...insertNodePatch(editorActor.getSnapshot().context.schema, editor.children, operation, previousChildren)];\n          break;\n        case \"set_node\":\n          patches = [...patches, ...setNodePatch(editorActor.getSnapshot().context.schema, editor.children, operation)];\n          break;\n        case \"merge_node\":\n          patches = [...patches, ...mergeNodePatch(editorActor.getSnapshot().context.schema, editor.children, operation, previousChildren)];\n          break;\n        case \"move_node\":\n          patches = [...patches, ...moveNodePatch(editorActor.getSnapshot().context.schema, previousChildren, operation)];\n          break;\n      }\n      if (!editorWasEmpty && editorIsEmpty && [\"merge_node\", \"set_node\", \"remove_text\", \"remove_node\"].includes(operation.type) && (patches = [...patches, (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([])], relayActor.send({\n        type: \"unset\",\n        previousValue: fromSlateValue(previousChildren, editorActor.getSnapshot().context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(editor))\n      })), editorWasEmpty && patches.length > 0 && (patches = [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.setIfMissing)([], []), ...patches]), patches.length > 0)\n        for (const patch of patches)\n          editorActor.send({\n            type: \"internal.patch\",\n            patch: {\n              ...patch,\n              origin: \"local\"\n            },\n            operationId: getCurrentUndoStepId(editor),\n            value: editor.value\n          });\n      return editor;\n    }, editor;\n  };\n}\nconst debug$9 = debugWithName(\"plugin:withPlaceholderBlock\");\nfunction createWithPlaceholderBlock(editorActor) {\n  return function(editor) {\n    const {\n      apply: apply2\n    } = editor;\n    return editor.apply = (op) => {\n      if (editorActor.getSnapshot().matches({\n        \"edit mode\": \"read only\"\n      })) {\n        apply2(op);\n        return;\n      }\n      if (isChangingRemotely(editor)) {\n        apply2(op);\n        return;\n      }\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply2(op);\n        return;\n      }\n      if (op.type === \"remove_node\") {\n        const blockIndex = op.path.at(0), isLonelyBlock = op.path.length === 1 && blockIndex === 0 && editor.children.length === 1, isBlockObject = op.node._type !== editorActor.getSnapshot().context.schema.block.name;\n        isLonelyBlock && isBlockObject && (debug$9(\"Adding placeholder block\"), slate__WEBPACK_IMPORTED_MODULE_14__.Editor.insertNode(editor, editor.pteCreateTextBlock({\n          decorators: []\n        })));\n      }\n      apply2(op);\n    }, editor;\n  };\n}\nconst debug$8 = debugWithName(\"plugin:withSchemaTypes\");\nfunction createWithSchemaTypes({\n  editorActor\n}) {\n  return function(editor) {\n    editor.isTextBlock = (value) => slate__WEBPACK_IMPORTED_MODULE_14__.Editor.isEditor(value) ? !1 : (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(editorActor.getSnapshot().context, value), editor.isTextSpan = (value) => slate__WEBPACK_IMPORTED_MODULE_14__.Editor.isEditor(value) ? !1 : (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isSpan)(editorActor.getSnapshot().context, value), editor.isListBlock = (value) => slate__WEBPACK_IMPORTED_MODULE_14__.Editor.isEditor(value) ? !1 : (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.isListBlock)(editorActor.getSnapshot().context, value), editor.isVoid = (element) => slate__WEBPACK_IMPORTED_MODULE_14__.Editor.isEditor(element) ? !1 : editorActor.getSnapshot().context.schema.block.name !== element._type && (editorActor.getSnapshot().context.schema.blockObjects.map((obj) => obj.name).includes(element._type) || editorActor.getSnapshot().context.schema.inlineObjects.map((obj) => obj.name).includes(element._type)), editor.isInline = (element) => slate__WEBPACK_IMPORTED_MODULE_14__.Editor.isEditor(element) ? !1 : editorActor.getSnapshot().context.schema.inlineObjects.map((obj) => obj.name).includes(element._type) && \"__inline\" in element && element.__inline === !0;\n    const {\n      normalizeNode\n    } = editor;\n    return editor.normalizeNode = (entry) => {\n      const [node, path] = entry;\n      if (node._type === void 0 && path.length === 2) {\n        debug$8(\"Setting span type on text node without a type\");\n        const span = node, key = span._key || editorActor.getSnapshot().context.keyGenerator();\n        editorActor.send({\n          type: \"normalizing\"\n        }), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {\n          ...span,\n          _type: editorActor.getSnapshot().context.schema.span.name,\n          _key: key\n        }, {\n          at: path\n        }), editorActor.send({\n          type: \"done normalizing\"\n        });\n        return;\n      }\n      if (node._key === void 0 && (path.length === 1 || path.length === 2)) {\n        debug$8(\"Setting missing key on child node without a key\");\n        const key = editorActor.getSnapshot().context.keyGenerator();\n        editorActor.send({\n          type: \"normalizing\"\n        }), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(editor, {\n          _key: key\n        }, {\n          at: path\n        }), editorActor.send({\n          type: \"done normalizing\"\n        });\n        return;\n      }\n      normalizeNode(entry);\n    }, editor;\n  };\n}\nfunction createWithUtils({\n  editorActor\n}) {\n  return function(editor) {\n    return editor.pteCreateTextBlock = (options) => toSlateValue([{\n      _type: editorActor.getSnapshot().context.schema.block.name,\n      _key: editorActor.getSnapshot().context.keyGenerator(),\n      style: editorActor.getSnapshot().context.schema.styles[0].name || \"normal\",\n      ...options.listItem ? {\n        listItem: options.listItem\n      } : {},\n      ...options.level ? {\n        level: options.level\n      } : {},\n      markDefs: [],\n      children: [{\n        _type: \"span\",\n        _key: editorActor.getSnapshot().context.keyGenerator(),\n        text: \"\",\n        marks: options.decorators.filter((decorator) => editorActor.getSnapshot().context.schema.decorators.find(({\n          name\n        }) => name === decorator))\n      }]\n    }], {\n      schemaTypes: editorActor.getSnapshot().context.schema\n    })[0], editor;\n  };\n}\nfunction pluginUpdateSelection({\n  editor,\n  editorActor\n}) {\n  const updateSelection = () => {\n    if (editor.selection) {\n      const existingSelection = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);\n      if (existingSelection)\n        editorActor.send({\n          type: \"update selection\",\n          selection: existingSelection\n        });\n      else {\n        const selection = slateRangeToSelection({\n          schema: editorActor.getSnapshot().context.schema,\n          editor,\n          range: editor.selection\n        });\n        SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, selection), editorActor.send({\n          type: \"update selection\",\n          selection\n        });\n      }\n    } else\n      editorActor.send({\n        type: \"update selection\",\n        selection: null\n      });\n  }, {\n    onChange\n  } = editor;\n  return editor.onChange = () => {\n    onChange(), editorActor.getSnapshot().matches({\n      setup: \"setting up\"\n    }) || updateSelection();\n  }, editor;\n}\nfunction isEditorNode(node) {\n  return typeof node == \"object\" && node !== null ? !(\"_type\" in node) && \"children\" in node && Array.isArray(node.children) : !1;\n}\nfunction isTextBlockNode(context, node) {\n  return (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.isTypedObject)(node) && node._type === context.schema.block.name;\n}\nfunction isSpanNode(context, node) {\n  return typeof node != \"object\" || node === null || \"children\" in node ? !1 : \"_type\" in node ? node._type === context.schema.span.name : \"text\" in node;\n}\nfunction isPartialSpanNode(node) {\n  return typeof node == \"object\" && node !== null && \"text\" in node && typeof node.text == \"string\";\n}\nfunction isObjectNode(context, node) {\n  return !isEditorNode(node) && !isTextBlockNode(context, node) && !isSpanNode(context, node) && !isPartialSpanNode(node);\n}\nfunction getBlock(root, path) {\n  const index = path.at(0);\n  if (!(index === void 0 || path.length !== 1))\n    return root.children.at(index);\n}\nfunction getNode(context, root, path) {\n  if (path.length === 0)\n    return root;\n  if (path.length === 1)\n    return getBlock(root, path);\n  if (path.length === 2) {\n    const block = getBlock(root, path.slice(0, 1));\n    return !block || !isTextBlockNode(context, block) ? void 0 : block.children.at(path[1]) || void 0;\n  }\n}\nfunction getSpan(context, root, path) {\n  const node = getNode(context, root, path);\n  if (node && isSpanNode(context, node))\n    return node;\n}\nfunction getParent(context, root, path) {\n  if (path.length === 0)\n    return;\n  const parentPath = path.slice(0, -1);\n  if (parentPath.length === 0)\n    return root;\n  const blockIndex = parentPath.at(0);\n  if (blockIndex === void 0 || parentPath.length !== 1)\n    return;\n  const block = root.children.at(blockIndex);\n  if (block && isTextBlockNode(context, block))\n    return block;\n}\nfunction applyOperationToPortableText(context, value, operation) {\n  const draft = (0,immer__WEBPACK_IMPORTED_MODULE_34__.createDraft)({\n    children: value\n  });\n  try {\n    applyOperationToPortableTextDraft(context, draft, operation);\n  } catch (e) {\n    console.error(e);\n  }\n  return (0,immer__WEBPACK_IMPORTED_MODULE_34__.finishDraft)(draft).children;\n}\nfunction applyOperationToPortableTextDraft(context, root, operation) {\n  switch (operation.type) {\n    case \"insert_node\": {\n      const {\n        path,\n        node: insertedNode\n      } = operation, parent = getParent(context, root, path), index = path[path.length - 1];\n      if (!parent || index > parent.children.length)\n        break;\n      if (path.length === 1) {\n        if (isTextBlockNode(context, insertedNode)) {\n          parent.children.splice(index, 0, {\n            ...insertedNode,\n            children: insertedNode.children.map((child) => \"__inline\" in child ? {\n              _key: child._key,\n              _type: child._type,\n              ...\"value\" in child && typeof child.value == \"object\" ? child.value : {}\n            } : child)\n          });\n          break;\n        }\n        if (slate__WEBPACK_IMPORTED_MODULE_14__.Element.isElement(insertedNode) && !(\"__inline\" in insertedNode)) {\n          parent.children.splice(index, 0, {\n            _key: insertedNode._key,\n            _type: insertedNode._type,\n            ...\"value\" in insertedNode && typeof insertedNode.value == \"object\" ? insertedNode.value : {}\n          });\n          break;\n        }\n      }\n      if (path.length === 2) {\n        if (!isTextBlockNode(context, parent))\n          break;\n        if (isPartialSpanNode(insertedNode)) {\n          parent.children.splice(index, 0, insertedNode);\n          break;\n        }\n        if (\"__inline\" in insertedNode) {\n          parent.children.splice(index, 0, {\n            _key: insertedNode._key,\n            _type: insertedNode._type,\n            ...\"value\" in insertedNode && typeof insertedNode.value == \"object\" ? insertedNode.value : {}\n          });\n          break;\n        }\n      }\n      break;\n    }\n    case \"insert_text\": {\n      const {\n        path,\n        offset,\n        text\n      } = operation;\n      if (text.length === 0) break;\n      const span = getSpan(context, root, path);\n      if (!span)\n        break;\n      const before = span.text.slice(0, offset), after = span.text.slice(offset);\n      span.text = before + text + after;\n      break;\n    }\n    case \"merge_node\": {\n      const {\n        path\n      } = operation, node = getNode(context, root, path), prevPath = slate__WEBPACK_IMPORTED_MODULE_14__.Path.previous(path), prev = getNode(context, root, prevPath), parent = getParent(context, root, path);\n      if (!node || !prev || !parent)\n        break;\n      const index = path[path.length - 1];\n      if (isPartialSpanNode(node) && isPartialSpanNode(prev))\n        prev.text += node.text;\n      else if (isTextBlockNode(context, node) && isTextBlockNode(context, prev))\n        prev.children.push(...node.children);\n      else\n        break;\n      parent.children.splice(index, 1);\n      break;\n    }\n    case \"move_node\": {\n      const {\n        path,\n        newPath\n      } = operation;\n      if (slate__WEBPACK_IMPORTED_MODULE_14__.Path.isAncestor(path, newPath))\n        break;\n      const node = getNode(context, root, path), parent = getParent(context, root, path), index = path[path.length - 1];\n      if (!node || !parent)\n        break;\n      parent.children.splice(index, 1);\n      const truePath = slate__WEBPACK_IMPORTED_MODULE_14__.Path.transform(path, operation), newParent = getNode(context, root, slate__WEBPACK_IMPORTED_MODULE_14__.Path.parent(truePath)), newIndex = truePath[truePath.length - 1];\n      if (!newParent || !(\"children\" in newParent) || !Array.isArray(newParent.children))\n        break;\n      newParent.children.splice(newIndex, 0, node);\n      break;\n    }\n    case \"remove_node\": {\n      const {\n        path\n      } = operation, index = path[path.length - 1];\n      getParent(context, root, path)?.children.splice(index, 1);\n      break;\n    }\n    case \"remove_text\": {\n      const {\n        path,\n        offset,\n        text\n      } = operation;\n      if (text.length === 0)\n        break;\n      const span = getSpan(context, root, path);\n      if (!span)\n        break;\n      const before = span.text.slice(0, offset), after = span.text.slice(offset + text.length);\n      span.text = before + after;\n      break;\n    }\n    case \"set_node\": {\n      const {\n        path,\n        properties,\n        newProperties\n      } = operation, node = getNode(context, root, path);\n      if (!node || isEditorNode(node))\n        break;\n      if (isObjectNode(context, node)) {\n        const valueBefore = \"value\" in properties && typeof properties.value == \"object\" ? properties.value : {}, valueAfter = \"value\" in newProperties && typeof newProperties.value == \"object\" ? newProperties.value : {};\n        for (const key in newProperties) {\n          if (key === \"value\")\n            continue;\n          const value = newProperties[key];\n          value == null ? delete node[key] : node[key] = value;\n        }\n        for (const key in properties)\n          key !== \"value\" && (newProperties.hasOwnProperty(key) || delete node[key]);\n        for (const key in valueAfter) {\n          const value = valueAfter[key];\n          value == null ? delete node[key] : node[key] = value;\n        }\n        for (const key in valueBefore)\n          valueAfter.hasOwnProperty(key) || delete node[key];\n        break;\n      }\n      if (isTextBlockNode(context, node)) {\n        for (const key in newProperties) {\n          if (key === \"children\" || key === \"text\")\n            break;\n          const value = newProperties[key];\n          value == null ? delete node[key] : node[key] = value;\n        }\n        for (const key in properties)\n          newProperties.hasOwnProperty(key) || delete node[key];\n        break;\n      }\n      if (isPartialSpanNode(node)) {\n        for (const key in newProperties) {\n          if (key === \"text\")\n            break;\n          const value = newProperties[key];\n          value == null ? delete node[key] : node[key] = value;\n        }\n        for (const key in properties)\n          newProperties.hasOwnProperty(key) || delete node[key];\n        break;\n      }\n      break;\n    }\n    case \"split_node\": {\n      const {\n        path,\n        position,\n        properties\n      } = operation;\n      if (path.length === 0)\n        break;\n      const parent = getParent(context, root, path), index = path[path.length - 1];\n      if (!parent)\n        break;\n      if (isEditorNode(parent)) {\n        const block = getBlock(root, path);\n        if (!block || !isTextBlockNode(context, block))\n          break;\n        const before = block.children.slice(0, position), after = block.children.slice(position);\n        block.children = before;\n        const newTextBlockNode = {\n          ...properties,\n          children: after,\n          _type: context.schema.block.name\n        };\n        parent.children.splice(index + 1, 0, newTextBlockNode);\n        break;\n      }\n      if (isTextBlockNode(context, parent)) {\n        const node = getNode(context, root, path);\n        if (!node || !isSpanNode(context, node))\n          break;\n        const before = node.text.slice(0, position), after = node.text.slice(position);\n        node.text = before;\n        const newSpanNode = {\n          ...properties,\n          text: after\n        };\n        parent.children.splice(index + 1, 0, newSpanNode);\n      }\n      break;\n    }\n  }\n  return root;\n}\nfunction pluginUpdateValue(context, editor) {\n  const {\n    apply: apply2\n  } = editor;\n  return editor.apply = (operation) => {\n    if (operation.type === \"set_selection\") {\n      apply2(operation);\n      return;\n    }\n    if (editor.value = applyOperationToPortableText(context, editor.value, operation), operation.type === \"insert_text\" || operation.type === \"remove_text\") {\n      apply2(operation);\n      return;\n    }\n    buildIndexMaps({\n      schema: context.schema,\n      value: editor.value\n    }, {\n      blockIndexMap: editor.blockIndexMap,\n      listIndexMap: editor.listIndexMap\n    }), apply2(operation);\n  }, editor;\n}\nconst withPlugins = (editor, options) => {\n  const e = editor, {\n    editorActor,\n    relayActor\n  } = options, withObjectKeys = createWithObjectKeys(editorActor), withSchemaTypes = createWithSchemaTypes({\n    editorActor\n  }), withPatches = createWithPatches({\n    editorActor,\n    relayActor,\n    subscriptions: options.subscriptions\n  }), withMaxBlocks = createWithMaxBlocks(editorActor), withUndoRedo = createWithUndoRedo({\n    editorActor,\n    subscriptions: options.subscriptions\n  }), withPortableTextMarkModel = createWithPortableTextMarkModel(editorActor), withPlaceholderBlock = createWithPlaceholderBlock(editorActor), withUtils = createWithUtils({\n    editorActor\n  });\n  return createWithEventListeners(editorActor)(withSchemaTypes(withObjectKeys(withPortableTextMarkModel(withPlaceholderBlock(withUtils(withMaxBlocks(withUndoRedo(withPatches(pluginUpdateValue(editorActor.getSnapshot().context, pluginUpdateSelection({\n    editorActor,\n    editor: e\n  })))))))))));\n}, debug$7 = debugWithName(\"setup\");\nfunction createSlateEditor(config) {\n  debug$7(\"Creating new Slate editor instance\");\n  const instance = withPlugins((0,slate_react__WEBPACK_IMPORTED_MODULE_22__.withReact)((0,slate__WEBPACK_IMPORTED_MODULE_14__.createEditor)()), {\n    editorActor: config.editorActor,\n    relayActor: config.relayActor,\n    subscriptions: config.subscriptions\n  });\n  KEY_TO_VALUE_ELEMENT.set(instance, {}), KEY_TO_SLATE_ELEMENT.set(instance, {}), instance.decoratedRanges = [], instance.decoratorState = {};\n  const placeholderBlock = createPlaceholderBlock(config.editorActor.getSnapshot().context);\n  instance.value = [placeholderBlock], instance.blockIndexMap = /* @__PURE__ */ new Map(), instance.listIndexMap = /* @__PURE__ */ new Map(), buildIndexMaps({\n    schema: config.editorActor.getSnapshot().context.schema,\n    value: instance.value\n  }, {\n    blockIndexMap: instance.blockIndexMap,\n    listIndexMap: instance.listIndexMap\n  });\n  const initialValue = toSlateValue(instance.value, {\n    schemaTypes: config.editorActor.getSnapshot().context.schema\n  });\n  return {\n    instance,\n    initialValue\n  };\n}\nfunction createEditorDom(sendBack, slateEditor) {\n  return {\n    getBlockNodes: (snapshot) => getBlockNodes(slateEditor, snapshot),\n    getChildNodes: (snapshot) => getChildNodes(slateEditor, snapshot),\n    setDragGhost: ({\n      event,\n      ghost\n    }) => setDragGhost({\n      sendBack,\n      event,\n      ghost\n    })\n  };\n}\nfunction getBlockNodes(slateEditor, snapshot) {\n  if (!snapshot.context.selection)\n    return [];\n  const range = toSlateRange(snapshot);\n  if (!range)\n    return [];\n  try {\n    return Array.from(slate__WEBPACK_IMPORTED_MODULE_14__.Editor.nodes(slateEditor, {\n      at: range,\n      mode: \"highest\",\n      match: (n) => !slate__WEBPACK_IMPORTED_MODULE_14__.Editor.isEditor(n)\n    })).map(([blockNode]) => slate_dom__WEBPACK_IMPORTED_MODULE_17__.DOMEditor.toDOMNode(slateEditor, blockNode));\n  } catch {\n    return [];\n  }\n}\nfunction getChildNodes(slateEditor, snapshot) {\n  if (!snapshot.context.selection)\n    return [];\n  const range = toSlateRange(snapshot);\n  if (!range)\n    return [];\n  try {\n    return Array.from(slate__WEBPACK_IMPORTED_MODULE_14__.Editor.nodes(slateEditor, {\n      at: range,\n      mode: \"lowest\",\n      match: (n) => !slate__WEBPACK_IMPORTED_MODULE_14__.Editor.isEditor(n)\n    })).map(([childNode]) => slate_dom__WEBPACK_IMPORTED_MODULE_17__.DOMEditor.toDOMNode(slateEditor, childNode));\n  } catch {\n    return [];\n  }\n}\nfunction setDragGhost({\n  sendBack,\n  event,\n  ghost\n}) {\n  event.originEvent.dataTransfer.setDragImage(ghost.element, ghost.x, ghost.y), sendBack({\n    type: \"set drag ghost\",\n    ghost: ghost.element\n  });\n}\nconst addAnnotationOnCollapsedSelection = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"annotation.add\",\n  guard: ({\n    snapshot\n  }) => {\n    if (!(0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.isSelectionCollapsed)(snapshot))\n      return !1;\n    const caretWordSelection = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getCaretWordSelection)(snapshot);\n    return !caretWordSelection || !(0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.isSelectionExpanded)({\n      context: {\n        ...snapshot.context,\n        selection: caretWordSelection\n      }\n    }) ? !1 : {\n      caretWordSelection\n    };\n  },\n  actions: [({\n    event\n  }, {\n    caretWordSelection\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"select\",\n    at: caretWordSelection\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"annotation.add\",\n    annotation: event.annotation\n  })]]\n}), preventOverlappingAnnotations = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  // Given an `annotation.add` event\n  on: \"annotation.add\",\n  // When the annotation is active in the selection\n  guard: ({\n    snapshot,\n    event\n  }) => (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.isActiveAnnotation)(event.annotation.name, {\n    mode: \"partial\"\n  })(snapshot),\n  // Then the existing annotation is removed\n  actions: [({\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"annotation.remove\",\n    annotation: event.annotation\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)(event)]]\n}), coreAnnotationBehaviors = [addAnnotationOnCollapsedSelection, preventOverlappingAnnotations], defaultKeyboardShortcuts = {\n  arrowDown: (0,_portabletext_keyboard_shortcuts__WEBPACK_IMPORTED_MODULE_35__.createKeyboardShortcut)({\n    default: [{\n      key: \"ArrowDown\",\n      alt: !1,\n      ctrl: !1,\n      meta: !1,\n      shift: !1\n    }]\n  }),\n  arrowUp: (0,_portabletext_keyboard_shortcuts__WEBPACK_IMPORTED_MODULE_35__.createKeyboardShortcut)({\n    default: [{\n      key: \"ArrowUp\",\n      alt: !1,\n      ctrl: !1,\n      meta: !1,\n      shift: !1\n    }]\n  }),\n  backspace: (0,_portabletext_keyboard_shortcuts__WEBPACK_IMPORTED_MODULE_35__.createKeyboardShortcut)({\n    default: [{\n      key: \"Backspace\",\n      alt: !1,\n      ctrl: !1,\n      meta: !1,\n      shift: !1\n    }]\n  }),\n  break: (0,_portabletext_keyboard_shortcuts__WEBPACK_IMPORTED_MODULE_35__.createKeyboardShortcut)({\n    default: [{\n      key: \"Enter\",\n      shift: !1\n    }]\n  }),\n  lineBreak: (0,_portabletext_keyboard_shortcuts__WEBPACK_IMPORTED_MODULE_35__.createKeyboardShortcut)({\n    default: [{\n      key: \"Enter\",\n      shift: !0\n    }]\n  }),\n  decorators: {\n    strong: _portabletext_keyboard_shortcuts__WEBPACK_IMPORTED_MODULE_35__.bold,\n    em: _portabletext_keyboard_shortcuts__WEBPACK_IMPORTED_MODULE_35__.italic,\n    underline: _portabletext_keyboard_shortcuts__WEBPACK_IMPORTED_MODULE_35__.underline,\n    code: _portabletext_keyboard_shortcuts__WEBPACK_IMPORTED_MODULE_35__.code\n  },\n  delete: (0,_portabletext_keyboard_shortcuts__WEBPACK_IMPORTED_MODULE_35__.createKeyboardShortcut)({\n    default: [{\n      key: \"Delete\",\n      alt: !1,\n      ctrl: !1,\n      meta: !1,\n      shift: !1\n    }]\n  }),\n  history: {\n    undo: _portabletext_keyboard_shortcuts__WEBPACK_IMPORTED_MODULE_35__.undo,\n    redo: _portabletext_keyboard_shortcuts__WEBPACK_IMPORTED_MODULE_35__.redo\n  },\n  tab: (0,_portabletext_keyboard_shortcuts__WEBPACK_IMPORTED_MODULE_35__.createKeyboardShortcut)({\n    default: [{\n      key: \"Tab\",\n      alt: !1,\n      ctrl: !1,\n      meta: !1,\n      shift: !1\n    }]\n  }),\n  shiftTab: (0,_portabletext_keyboard_shortcuts__WEBPACK_IMPORTED_MODULE_35__.createKeyboardShortcut)({\n    default: [{\n      key: \"Tab\",\n      alt: !1,\n      ctrl: !1,\n      meta: !1,\n      shift: !0\n    }]\n  })\n}, arrowDownOnLonelyBlockObject = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"keyboard.keydown\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    if (!defaultKeyboardShortcuts.arrowDown.guard(event.originEvent) || !(0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.isSelectionCollapsed)(snapshot))\n      return !1;\n    const focusBlockObject = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getFocusBlockObject)(snapshot), nextBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getNextBlock)(snapshot);\n    return focusBlockObject && !nextBlock;\n  },\n  actions: [({\n    snapshot\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"insert.block\",\n    block: {\n      _type: snapshot.context.schema.block.name\n    },\n    placement: \"after\"\n  })]]\n}), arrowUpOnLonelyBlockObject = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"keyboard.keydown\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    if (!defaultKeyboardShortcuts.arrowUp.guard(event.originEvent) || !(0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.isSelectionCollapsed)(snapshot))\n      return !1;\n    const focusBlockObject = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getFocusBlockObject)(snapshot), previousBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getPreviousBlock)(snapshot);\n    return focusBlockObject && !previousBlock;\n  },\n  actions: [({\n    snapshot\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"insert.block\",\n    block: {\n      _type: snapshot.context.schema.block.name\n    },\n    placement: \"before\"\n  })]]\n}), breakingBlockObject = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"insert.break\",\n  guard: ({\n    snapshot\n  }) => {\n    const focusBlockObject = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getFocusBlockObject)(snapshot);\n    return (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.isSelectionCollapsed)(snapshot) && focusBlockObject !== void 0;\n  },\n  actions: [({\n    snapshot\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"insert.block\",\n    block: {\n      _type: snapshot.context.schema.block.name\n    },\n    placement: \"after\"\n  })]]\n}), clickingAboveLonelyBlockObject = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"mouse.click\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    if (snapshot.context.readOnly || snapshot.context.selection && !(0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.isSelectionCollapsed)(snapshot))\n      return !1;\n    const focusBlockObject = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getFocusBlockObject)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: event.position.selection\n      }\n    }), previousBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getPreviousBlock)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: event.position.selection\n      }\n    });\n    return event.position.isEditor && event.position.block === \"start\" && focusBlockObject && !previousBlock;\n  },\n  actions: [({\n    snapshot,\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"select\",\n    at: event.position.selection\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"insert.block\",\n    block: {\n      _type: snapshot.context.schema.block.name\n    },\n    placement: \"before\",\n    select: \"start\"\n  })]]\n}), clickingBelowLonelyBlockObject = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"mouse.click\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    if (snapshot.context.readOnly || snapshot.context.selection && !(0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.isSelectionCollapsed)(snapshot))\n      return !1;\n    const focusBlockObject = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getFocusBlockObject)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: event.position.selection\n      }\n    }), nextBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getNextBlock)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: event.position.selection\n      }\n    });\n    return event.position.isEditor && event.position.block === \"end\" && focusBlockObject && !nextBlock;\n  },\n  actions: [({\n    snapshot,\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"select\",\n    at: event.position.selection\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"insert.block\",\n    block: {\n      _type: snapshot.context.schema.block.name\n    },\n    placement: \"after\",\n    select: \"start\"\n  })]]\n}), deletingEmptyTextBlockAfterBlockObject = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"delete.backward\",\n  guard: ({\n    snapshot\n  }) => {\n    const focusTextBlock = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusTextBlock)(snapshot), selectionCollapsed = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.isSelectionCollapsed)(snapshot), previousBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getPreviousBlock)(snapshot);\n    return !focusTextBlock || !selectionCollapsed || !previousBlock ? !1 : (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.isEmptyTextBlock)(snapshot.context, focusTextBlock.node) && !(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(snapshot.context, previousBlock.node) ? {\n      focusTextBlock,\n      previousBlock\n    } : !1;\n  },\n  actions: [(_, {\n    focusTextBlock,\n    previousBlock\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"delete.block\",\n    at: focusTextBlock.path\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"select\",\n    at: {\n      anchor: {\n        path: previousBlock.path,\n        offset: 0\n      },\n      focus: {\n        path: previousBlock.path,\n        offset: 0\n      }\n    }\n  })]]\n}), deletingEmptyTextBlockBeforeBlockObject = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"delete.forward\",\n  guard: ({\n    snapshot\n  }) => {\n    const focusTextBlock = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusTextBlock)(snapshot), selectionCollapsed = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.isSelectionCollapsed)(snapshot), nextBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getNextBlock)(snapshot);\n    return !focusTextBlock || !selectionCollapsed || !nextBlock ? !1 : (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.isEmptyTextBlock)(snapshot.context, focusTextBlock.node) && !(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(snapshot.context, nextBlock.node) ? {\n      focusTextBlock,\n      nextBlock\n    } : !1;\n  },\n  actions: [(_, {\n    focusTextBlock,\n    nextBlock\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"delete.block\",\n    at: focusTextBlock.path\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"select\",\n    at: {\n      anchor: {\n        path: nextBlock.path,\n        offset: 0\n      },\n      focus: {\n        path: nextBlock.path,\n        offset: 0\n      }\n    }\n  })]]\n}), coreBlockObjectBehaviors = {\n  arrowDownOnLonelyBlockObject,\n  arrowUpOnLonelyBlockObject,\n  breakingBlockObject,\n  clickingAboveLonelyBlockObject,\n  clickingBelowLonelyBlockObject,\n  deletingEmptyTextBlockAfterBlockObject,\n  deletingEmptyTextBlockBeforeBlockObject\n}, coreDecoratorBehaviors = {\n  strongShortcut: (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"keyboard.keydown\",\n    guard: ({\n      snapshot,\n      event\n    }) => defaultKeyboardShortcuts.decorators.strong.guard(event.originEvent) && snapshot.context.schema.decorators.some((decorator) => decorator.name === \"strong\"),\n    actions: [() => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"decorator.toggle\",\n      decorator: \"strong\"\n    })]]\n  }),\n  emShortcut: (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"keyboard.keydown\",\n    guard: ({\n      snapshot,\n      event\n    }) => defaultKeyboardShortcuts.decorators.em.guard(event.originEvent) && snapshot.context.schema.decorators.some((decorator) => decorator.name === \"em\"),\n    actions: [() => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"decorator.toggle\",\n      decorator: \"em\"\n    })]]\n  }),\n  underlineShortcut: (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"keyboard.keydown\",\n    guard: ({\n      snapshot,\n      event\n    }) => defaultKeyboardShortcuts.decorators.underline.guard(event.originEvent) && snapshot.context.schema.decorators.some((decorator) => decorator.name === \"underline\"),\n    actions: [() => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"decorator.toggle\",\n      decorator: \"underline\"\n    })]]\n  }),\n  codeShortcut: (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"keyboard.keydown\",\n    guard: ({\n      snapshot,\n      event\n    }) => defaultKeyboardShortcuts.decorators.code.guard(event.originEvent) && snapshot.context.schema.decorators.some((decorator) => decorator.name === \"code\"),\n    actions: [() => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"decorator.toggle\",\n      decorator: \"code\"\n    })]]\n  })\n};\nfunction getCompoundClientRect(nodes) {\n  if (nodes.length === 0)\n    return new DOMRect(0, 0, 0, 0);\n  const elements = nodes.filter((node) => node instanceof Element), firstRect = elements.at(0)?.getBoundingClientRect();\n  if (!firstRect)\n    return new DOMRect(0, 0, 0, 0);\n  let left = firstRect.left, top = firstRect.top, right = firstRect.right, bottom = firstRect.bottom;\n  for (let i = 1; i < elements.length; i++) {\n    const rect = elements[i].getBoundingClientRect();\n    left = Math.min(left, rect.left), top = Math.min(top, rect.top), right = Math.max(right, rect.right), bottom = Math.max(bottom, rect.bottom);\n  }\n  return new DOMRect(left, top, right - left, bottom - top);\n}\nconst coreDndBehaviors = [\n  /**\n   * Core Behavior that:\n   * 1. Calculates and selects a \"drag selection\"\n   * 2. Constructs and sets a drag ghost element\n   * 3. Forwards the dragstart event\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"drag.dragstart\",\n    guard: ({\n      snapshot,\n      dom,\n      event\n    }) => {\n      const dragSelection = getDragSelection({\n        snapshot,\n        eventSelection: event.position.selection\n      }), selectingEntireBlocks = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.isSelectingEntireBlocks)({\n        ...snapshot,\n        context: {\n          ...snapshot.context,\n          selection: dragSelection\n        }\n      }), draggedDomNodes = {\n        blockNodes: dom.getBlockNodes({\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: dragSelection\n          }\n        }),\n        childNodes: dom.getChildNodes({\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: dragSelection\n          }\n        })\n      };\n      return {\n        dragSelection,\n        draggedDomNodes,\n        selectingEntireBlocks\n      };\n    },\n    actions: [({\n      dom,\n      event\n    }, {\n      dragSelection,\n      draggedDomNodes,\n      selectingEntireBlocks\n    }) => {\n      const dragGhost = document.createElement(\"div\");\n      if (selectingEntireBlocks) {\n        const clonedBlockNodes = draggedDomNodes.blockNodes.map((node) => node.cloneNode(!0));\n        for (const block of clonedBlockNodes)\n          block instanceof HTMLElement && (block.style.position = \"relative\"), dragGhost.appendChild(block);\n        const customGhost = dragGhost.querySelector(\"[data-pt-drag-ghost-element]\");\n        if (customGhost && dragGhost.replaceChildren(customGhost), dragGhost.setAttribute(\"data-dragged\", \"\"), dragGhost.style.position = \"absolute\", dragGhost.style.left = \"-99999px\", dragGhost.style.boxSizing = \"border-box\", document.body.appendChild(dragGhost), customGhost) {\n          const customGhostRect = customGhost.getBoundingClientRect(), x = event.originEvent.clientX - customGhostRect.left, y = event.originEvent.clientY - customGhostRect.top;\n          return dragGhost.style.width = `${customGhostRect.width}px`, dragGhost.style.height = `${customGhostRect.height}px`, [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n            type: \"select\",\n            at: dragSelection\n          }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.effect)(() => {\n            dom.setDragGhost({\n              event,\n              ghost: {\n                element: dragGhost,\n                x,\n                y\n              }\n            });\n          }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.forward)(event)];\n        } else {\n          const blocksDomRect = getCompoundClientRect(draggedDomNodes.blockNodes), x = event.originEvent.clientX - blocksDomRect.left, y = event.originEvent.clientY - blocksDomRect.top;\n          return dragGhost.style.width = `${blocksDomRect.width}px`, dragGhost.style.height = `${blocksDomRect.height}px`, [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n            type: \"select\",\n            at: dragSelection\n          }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.effect)(() => {\n            dom.setDragGhost({\n              event,\n              ghost: {\n                element: dragGhost,\n                x,\n                y\n              }\n            });\n          }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.forward)(event)];\n        }\n      } else {\n        const clonedChildNodes = draggedDomNodes.childNodes.map((node) => node.cloneNode(!0));\n        for (const child of clonedChildNodes)\n          dragGhost.appendChild(child);\n        dragGhost.style.position = \"absolute\", dragGhost.style.left = \"-99999px\", dragGhost.style.boxSizing = \"border-box\", document.body.appendChild(dragGhost);\n        const childrenDomRect = getCompoundClientRect(draggedDomNodes.childNodes), x = event.originEvent.clientX - childrenDomRect.left, y = event.originEvent.clientY - childrenDomRect.top;\n        return dragGhost.style.width = `${childrenDomRect.width}px`, dragGhost.style.height = `${childrenDomRect.height}px`, [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n          type: \"select\",\n          at: dragSelection\n        }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.effect)(() => {\n          dom.setDragGhost({\n            event,\n            ghost: {\n              element: dragGhost,\n              x,\n              y\n            }\n          });\n        }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.forward)(event)];\n      }\n    }]\n  }),\n  /**\n   * When dragging over the drag origin, we don't want to show the caret in the\n   * text.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"drag.dragover\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      const dragOrigin = event.dragOrigin;\n      return dragOrigin ? (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.isOverlappingSelection)(event.position.selection)({\n        ...snapshot,\n        context: {\n          ...snapshot.context,\n          selection: dragOrigin.selection\n        }\n      }) : !1;\n    },\n    actions: []\n  }),\n  /**\n   * If the drop position overlaps the drag origin, then the event should be\n   * cancelled.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"drag.drop\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      const dragOrigin = event.dragOrigin, dropPosition = event.position.selection;\n      return dragOrigin ? (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.isOverlappingSelection)(dropPosition)({\n        ...snapshot,\n        context: {\n          ...snapshot.context,\n          selection: dragOrigin.selection\n        }\n      }) : !1;\n    },\n    actions: []\n  }),\n  /**\n   * If we drop and have access to a drag origin, then we can deserialize\n   * without creating a new selection.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"drag.drop\",\n    guard: ({\n      event\n    }) => event.dragOrigin !== void 0,\n    actions: [({\n      event\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"deserialize\",\n      originEvent: event\n    })]]\n  }),\n  /**\n   * Otherwise, we should to create a new selection.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"drag.drop\",\n    actions: [({\n      event\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"select\",\n      at: event.position.selection\n    }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"deserialize\",\n      originEvent: event\n    })]]\n  }),\n  /**\n   * Core Behavior that uses the drag origin to mimic a move operation during\n   * internal dragging.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"deserialization.success\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      if (event.originEvent.type !== \"drag.drop\" || event.originEvent.dragOrigin === void 0)\n        return !1;\n      const dragOrigin = event.originEvent.dragOrigin, dragSelection = getDragSelection({\n        eventSelection: dragOrigin.selection,\n        snapshot\n      }), dropPosition = event.originEvent.position.selection, droppingOnDragOrigin = dragOrigin ? (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.isOverlappingSelection)(dropPosition)({\n        ...snapshot,\n        context: {\n          ...snapshot.context,\n          selection: dragSelection\n        }\n      }) : !1, draggingEntireBlocks = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.isSelectingEntireBlocks)({\n        ...snapshot,\n        context: {\n          ...snapshot.context,\n          selection: dragSelection\n        }\n      }), draggedBlocks = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getSelectedBlocks)({\n        ...snapshot,\n        context: {\n          ...snapshot.context,\n          selection: dragSelection\n        }\n      });\n      return droppingOnDragOrigin ? !1 : {\n        dropPosition,\n        draggingEntireBlocks,\n        draggedBlocks,\n        dragOrigin,\n        originEvent: event.originEvent\n      };\n    },\n    actions: [({\n      event\n    }, {\n      draggingEntireBlocks,\n      draggedBlocks,\n      dragOrigin,\n      dropPosition,\n      originEvent\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"select\",\n      at: dropPosition\n    }), ...draggingEntireBlocks ? draggedBlocks.map((block) => (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"delete.block\",\n      at: block.path\n    })) : [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"delete\",\n      at: dragOrigin.selection\n    })], (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"insert.blocks\",\n      blocks: event.data,\n      placement: draggingEntireBlocks ? originEvent.position.block === \"start\" ? \"before\" : originEvent.position.block === \"end\" ? \"after\" : \"auto\" : \"auto\"\n    })]]\n  })\n], coreInsertBehaviors = [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"insert.text\",\n  guard: ({\n    snapshot\n  }) => {\n    if (!(0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusSpan)(snapshot))\n      return !1;\n    const markState = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getMarkState)(snapshot), activeDecorators = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getActiveDecorators)(snapshot), activeAnnotations = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getActiveAnnotationsMarks)(snapshot);\n    if (markState && markState.state === \"unchanged\") {\n      const markStateDecorators = (markState.marks ?? []).filter((mark) => snapshot.context.schema.decorators.map((decorator) => decorator.name).includes(mark));\n      if (markStateDecorators.length === activeDecorators.length && markStateDecorators.every((mark) => activeDecorators.includes(mark)))\n        return !1;\n    }\n    return {\n      activeDecorators,\n      activeAnnotations\n    };\n  },\n  actions: [({\n    snapshot,\n    event\n  }, {\n    activeDecorators,\n    activeAnnotations\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"insert.child\",\n    child: {\n      _type: snapshot.context.schema.span.name,\n      text: event.text,\n      marks: [...activeDecorators, ...activeAnnotations]\n    }\n  })]]\n})], breakingAtTheEndOfTextBlock = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"insert.break\",\n  guard: ({\n    snapshot\n  }) => {\n    const focusTextBlock = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusTextBlock)(snapshot), selectionCollapsed = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.isSelectionCollapsed)(snapshot);\n    if (!snapshot.context.selection || !focusTextBlock || !selectionCollapsed)\n      return !1;\n    const atTheEndOfBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.isAtTheEndOfBlock)(focusTextBlock)(snapshot), focusListItem = focusTextBlock.node.listItem, focusLevel = focusTextBlock.node.level;\n    return atTheEndOfBlock ? {\n      focusListItem,\n      focusLevel\n    } : !1;\n  },\n  actions: [({\n    snapshot\n  }, {\n    focusListItem,\n    focusLevel\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"insert.block\",\n    block: {\n      _type: snapshot.context.schema.block.name,\n      children: [{\n        _type: snapshot.context.schema.span.name,\n        text: \"\",\n        marks: []\n      }],\n      markDefs: [],\n      listItem: focusListItem,\n      level: focusLevel,\n      style: snapshot.context.schema.styles[0]?.name\n    },\n    placement: \"after\"\n  })]]\n}), breakingAtTheStartOfTextBlock = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"insert.break\",\n  guard: ({\n    snapshot\n  }) => {\n    const focusTextBlock = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusTextBlock)(snapshot), selectionCollapsed = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.isSelectionCollapsed)(snapshot);\n    if (!snapshot.context.selection || !focusTextBlock || !selectionCollapsed)\n      return !1;\n    const focusSpan = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusSpan)(snapshot), focusDecorators = focusSpan?.node.marks?.filter((mark) => snapshot.context.schema.decorators.some((decorator) => decorator.name === mark) ?? []), focusAnnotations = focusSpan?.node.marks?.filter((mark) => !snapshot.context.schema.decorators.some((decorator) => decorator.name === mark)) ?? [], focusListItem = focusTextBlock.node.listItem, focusLevel = focusTextBlock.node.level;\n    return (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.isAtTheStartOfBlock)(focusTextBlock)(snapshot) ? {\n      focusAnnotations,\n      focusDecorators,\n      focusListItem,\n      focusLevel\n    } : !1;\n  },\n  actions: [({\n    snapshot\n  }, {\n    focusAnnotations,\n    focusDecorators,\n    focusListItem,\n    focusLevel\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"insert.block\",\n    block: {\n      _type: snapshot.context.schema.block.name,\n      children: [{\n        _type: snapshot.context.schema.span.name,\n        marks: focusAnnotations.length === 0 ? focusDecorators : [],\n        text: \"\"\n      }],\n      listItem: focusListItem,\n      level: focusLevel,\n      style: snapshot.context.schema.styles[0]?.name\n    },\n    placement: \"before\",\n    select: \"none\"\n  })]]\n}), breakingEntireDocument = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"insert.break\",\n  guard: ({\n    snapshot\n  }) => {\n    if (!snapshot.context.selection || !(0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.isSelectionExpanded)(snapshot))\n      return !1;\n    const firstBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getFirstBlock)(snapshot), lastBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getLastBlock)(snapshot);\n    if (!firstBlock || !lastBlock)\n      return !1;\n    const firstBlockStartPoint = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.getBlockStartPoint)({\n      context: snapshot.context,\n      block: firstBlock\n    }), selectionStartPoint = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.getSelectionStartPoint)(snapshot.context.selection), lastBlockEndPoint = (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.getBlockEndPoint)({\n      context: snapshot.context,\n      block: lastBlock\n    }), selectionEndPoint = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.getSelectionEndPoint)(snapshot.context.selection);\n    return (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.isEqualSelectionPoints)(firstBlockStartPoint, selectionStartPoint) && (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.isEqualSelectionPoints)(lastBlockEndPoint, selectionEndPoint) ? {\n      selection: snapshot.context.selection\n    } : !1;\n  },\n  actions: [(_, {\n    selection\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"delete\",\n    at: selection\n  })]]\n}), breakingEntireBlocks = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"insert.break\",\n  guard: ({\n    snapshot\n  }) => {\n    if (!snapshot.context.selection || !(0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.isSelectionExpanded)(snapshot))\n      return !1;\n    const selectedBlocks = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getSelectedBlocks)(snapshot), selectionStartBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getSelectionStartBlock)(snapshot), selectionEndBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getSelectionEndBlock)(snapshot);\n    if (!selectionStartBlock || !selectionEndBlock)\n      return !1;\n    const startBlockStartPoint = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.getBlockStartPoint)({\n      context: snapshot.context,\n      block: selectionStartBlock\n    }), selectionStartPoint = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.getSelectionStartPoint)(snapshot.context.selection), endBlockEndPoint = (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.getBlockEndPoint)({\n      context: snapshot.context,\n      block: selectionEndBlock\n    }), selectionEndPoint = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.getSelectionEndPoint)(snapshot.context.selection);\n    return (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.isEqualSelectionPoints)(selectionStartPoint, startBlockStartPoint) && (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.isEqualSelectionPoints)(selectionEndPoint, endBlockEndPoint) ? {\n      selectedBlocks\n    } : !1;\n  },\n  actions: [({\n    snapshot\n  }, {\n    selectedBlocks\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"insert.block\",\n    block: {\n      _type: snapshot.context.schema.block.name,\n      children: [{\n        _type: snapshot.context.schema.span.name,\n        text: \"\",\n        marks: []\n      }]\n    },\n    placement: \"before\",\n    select: \"start\"\n  }), ...selectedBlocks.map((block) => (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"delete.block\",\n    at: block.path\n  }))]]\n}), breakingInlineObject = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"insert.break\",\n  guard: ({\n    snapshot\n  }) => {\n    const selectionCollapsed = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.isSelectionCollapsed)(snapshot), focusInlineObject = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getFocusInlineObject)(snapshot);\n    return selectionCollapsed && focusInlineObject;\n  },\n  actions: [() => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"move.forward\",\n    distance: 1\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"split\"\n  })]]\n}), coreInsertBreakBehaviors = {\n  breakingAtTheEndOfTextBlock,\n  breakingAtTheStartOfTextBlock,\n  breakingEntireDocument,\n  breakingEntireBlocks,\n  breakingInlineObject\n};\nfunction isAtTheBeginningOfBlock({\n  context,\n  block\n}) {\n  return !(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(context, block) || !context.selection || !(0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.isSelectionCollapsed)(context.selection) ? !1 : (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.getChildKeyFromSelectionPoint)(context.selection.focus) === block.children[0]._key && context.selection.focus.offset === 0;\n}\nconst MAX_LIST_LEVEL = 10, clearListOnBackspace = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"delete.backward\",\n  guard: ({\n    snapshot\n  }) => {\n    const focusTextBlock = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusTextBlock)(snapshot);\n    return !focusTextBlock || focusTextBlock.node.level !== 1 || !isAtTheBeginningOfBlock({\n      context: snapshot.context,\n      block: focusTextBlock.node\n    }) ? !1 : {\n      focusTextBlock\n    };\n  },\n  actions: [(_, {\n    focusTextBlock\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"block.unset\",\n    props: [\"listItem\", \"level\"],\n    at: focusTextBlock.path\n  })]]\n}), unindentListOnBackspace = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"delete.backward\",\n  guard: ({\n    snapshot\n  }) => {\n    const selectionCollapsed = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.isSelectionCollapsed)(snapshot), focusTextBlock = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusTextBlock)(snapshot), focusSpan = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusSpan)(snapshot);\n    return !selectionCollapsed || !focusTextBlock || !focusSpan ? !1 : focusTextBlock.node.children[0]._key === focusSpan.node._key && snapshot.context.selection?.focus.offset === 0 && focusTextBlock.node.level !== void 0 && focusTextBlock.node.level > 1 ? {\n      focusTextBlock,\n      level: focusTextBlock.node.level - 1\n    } : !1;\n  },\n  actions: [(_, {\n    focusTextBlock,\n    level\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"block.set\",\n    props: {\n      level\n    },\n    at: focusTextBlock.path\n  })]]\n}), mergeTextIntoListOnDelete = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"delete.forward\",\n  guard: ({\n    snapshot\n  }) => {\n    const focusListBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getFocusListBlock)(snapshot), nextBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getNextBlock)(snapshot);\n    return !focusListBlock || !nextBlock || !(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(snapshot.context, nextBlock.node) || !(0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.isEmptyTextBlock)(snapshot.context, focusListBlock.node) ? !1 : {\n      focusListBlock,\n      nextBlock\n    };\n  },\n  actions: [(_, {\n    nextBlock\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"insert.block\",\n    block: nextBlock.node,\n    placement: \"auto\",\n    select: \"start\"\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"delete.block\",\n    at: nextBlock.path\n  })]]\n}), mergeTextIntoListOnBackspace = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"delete.backward\",\n  guard: ({\n    snapshot\n  }) => {\n    const focusTextBlock = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusTextBlock)(snapshot), previousBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getPreviousBlock)(snapshot);\n    if (!focusTextBlock || !previousBlock || !isAtTheBeginningOfBlock({\n      context: snapshot.context,\n      block: focusTextBlock.node\n    }) || !(0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.isListBlock)(snapshot.context, previousBlock.node) || !(0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.isEmptyTextBlock)(snapshot.context, previousBlock.node))\n      return !1;\n    const previousBlockEndPoint = (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.getBlockEndPoint)({\n      context: snapshot.context,\n      block: previousBlock\n    });\n    return {\n      focusTextBlock,\n      previousBlockEndPoint\n    };\n  },\n  actions: [(_, {\n    focusTextBlock,\n    previousBlockEndPoint\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"select\",\n    at: {\n      anchor: previousBlockEndPoint,\n      focus: previousBlockEndPoint\n    }\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"insert.block\",\n    block: focusTextBlock.node,\n    placement: \"auto\",\n    select: \"start\"\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"delete.block\",\n    at: focusTextBlock.path\n  })]]\n}), deletingListFromStart = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"delete\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    const blocksToDelete = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getSelectedBlocks)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: event.at\n      }\n    });\n    if (blocksToDelete.length < 2)\n      return !1;\n    const startBlock = blocksToDelete.at(0)?.node, middleBlocks = blocksToDelete.slice(1, -1), endBlock = blocksToDelete.at(-1)?.node;\n    if (!(0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.isListBlock)(snapshot.context, startBlock) || !(0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.isListBlock)(snapshot.context, endBlock))\n      return !1;\n    const deleteStartPoint = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getSelectionStartPoint)({\n      context: {\n        ...snapshot.context,\n        selection: event.at\n      }\n    }), deleteEndPoint = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getSelectionEndPoint)({\n      context: {\n        ...snapshot.context,\n        selection: event.at\n      }\n    });\n    if (!deleteStartPoint || !deleteEndPoint)\n      return !1;\n    const startBlockStartPoint = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.getBlockStartPoint)({\n      context: snapshot.context,\n      block: {\n        node: startBlock,\n        path: [{\n          _key: startBlock._key\n        }]\n      }\n    });\n    if (!(0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.isEqualSelectionPoints)(deleteStartPoint, startBlockStartPoint))\n      return !1;\n    const startBlockEndPoint = (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.getBlockEndPoint)({\n      context: snapshot.context,\n      block: {\n        node: startBlock,\n        path: [{\n          _key: startBlock._key\n        }]\n      }\n    }), endBlockEndPoint = (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.getBlockEndPoint)({\n      context: snapshot.context,\n      block: {\n        node: endBlock,\n        path: [{\n          _key: endBlock._key\n        }]\n      }\n    }), slicedEndBlock = (0,_chunks_es_util_slice_text_block_js__WEBPACK_IMPORTED_MODULE_32__.sliceTextBlock)({\n      context: {\n        schema: snapshot.context.schema,\n        selection: {\n          anchor: deleteEndPoint,\n          focus: endBlockEndPoint\n        }\n      },\n      block: endBlock\n    });\n    return {\n      startBlockStartPoint,\n      startBlockEndPoint,\n      middleBlocks,\n      endBlock,\n      slicedEndBlock\n    };\n  },\n  actions: [(_, {\n    startBlockStartPoint,\n    startBlockEndPoint,\n    middleBlocks,\n    endBlock,\n    slicedEndBlock\n  }) => [\n    // All block in between can safely be deleted.\n    ...middleBlocks.map((block) => (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"delete.block\",\n      at: block.path\n    })),\n    // The last block is deleted as well.\n    (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"delete.block\",\n      at: [{\n        _key: endBlock._key\n      }]\n    }),\n    // But in case the delete operation didn't reach all the way to the end\n    // of it, we first place the caret at the end of the start block...\n    (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"select\",\n      at: {\n        anchor: startBlockEndPoint,\n        focus: startBlockEndPoint\n      }\n    }),\n    // ...and insert the rest of the end block at the end of it.\n    (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"insert.block\",\n      block: slicedEndBlock,\n      placement: \"auto\",\n      select: \"none\"\n    }),\n    // And finally, we delete the original text of the start block.\n    (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"delete\",\n      at: {\n        anchor: startBlockStartPoint,\n        focus: startBlockEndPoint\n      }\n    })\n  ]]\n}), clearListOnEnter = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"insert.break\",\n  guard: ({\n    snapshot\n  }) => {\n    const selectionCollapsed = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.isSelectionCollapsed)(snapshot), focusListBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getFocusListBlock)(snapshot);\n    return !selectionCollapsed || !focusListBlock || !(0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.isEmptyTextBlock)(snapshot.context, focusListBlock.node) ? !1 : {\n      focusListBlock\n    };\n  },\n  actions: [(_, {\n    focusListBlock\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"block.unset\",\n    props: [\"listItem\", \"level\"],\n    at: focusListBlock.path\n  })]]\n}), indentListOnTab = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"keyboard.keydown\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    if (!defaultKeyboardShortcuts.tab.guard(event.originEvent))\n      return !1;\n    const selectedBlocks = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getSelectedBlocks)(snapshot), selectedListBlocks = selectedBlocks.flatMap((block) => (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.isListBlock)(snapshot.context, block.node) ? [{\n      node: block.node,\n      path: block.path\n    }] : []);\n    return selectedListBlocks.length === selectedBlocks.length ? {\n      selectedListBlocks\n    } : !1;\n  },\n  actions: [(_, {\n    selectedListBlocks\n  }) => selectedListBlocks.map((selectedListBlock) => (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"block.set\",\n    props: {\n      level: Math.min(MAX_LIST_LEVEL, Math.max(1, selectedListBlock.node.level + 1))\n    },\n    at: selectedListBlock.path\n  }))]\n}), unindentListOnShiftTab = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"keyboard.keydown\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    if (!defaultKeyboardShortcuts.shiftTab.guard(event.originEvent))\n      return !1;\n    const selectedBlocks = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getSelectedBlocks)(snapshot), selectedListBlocks = selectedBlocks.flatMap((block) => (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.isListBlock)(snapshot.context, block.node) ? [{\n      node: block.node,\n      path: block.path\n    }] : []);\n    return selectedListBlocks.length === selectedBlocks.length ? {\n      selectedListBlocks\n    } : !1;\n  },\n  actions: [(_, {\n    selectedListBlocks\n  }) => selectedListBlocks.map((selectedListBlock) => (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"block.set\",\n    props: {\n      level: Math.min(MAX_LIST_LEVEL, Math.max(1, selectedListBlock.node.level - 1))\n    },\n    at: selectedListBlock.path\n  }))]\n}), inheritListLevel = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"insert.blocks\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    const focusListBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getFocusListBlock)(snapshot);\n    if (!focusListBlock)\n      return !1;\n    const firstInsertedBlock = event.blocks.at(0), secondInsertedBlock = event.blocks.at(1), insertedListBlock = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.isListBlock)(snapshot.context, firstInsertedBlock) ? firstInsertedBlock : (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.isListBlock)(snapshot.context, secondInsertedBlock) ? secondInsertedBlock : void 0;\n    if (!insertedListBlock)\n      return !1;\n    const levelDifference = focusListBlock.node.level - insertedListBlock.level;\n    return levelDifference === 0 ? !1 : {\n      levelDifference,\n      insertedListBlock\n    };\n  },\n  actions: [({\n    snapshot,\n    event\n  }, {\n    levelDifference,\n    insertedListBlock\n  }) => {\n    let adjustLevel = !0, listStartBlockFound = !1;\n    return [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      ...event,\n      blocks: event.blocks.map((block) => (block._key === insertedListBlock._key && (listStartBlockFound = !0), adjustLevel ? listStartBlockFound && adjustLevel && (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.isListBlock)(snapshot.context, block) ? {\n        ...block,\n        level: Math.min(MAX_LIST_LEVEL, Math.max(1, block.level + levelDifference))\n      } : (listStartBlockFound && (adjustLevel = !1), block) : block))\n    })];\n  }]\n}), inheritListItem = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"insert.blocks\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    const focusListBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getFocusListBlock)(snapshot);\n    if (!focusListBlock || (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.isEmptyTextBlock)(snapshot.context, focusListBlock.node))\n      return !1;\n    const firstInsertedBlock = event.blocks.at(0), secondInsertedBlock = event.blocks.at(1), insertedListBlock = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.isListBlock)(snapshot.context, firstInsertedBlock) ? firstInsertedBlock : (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.isListBlock)(snapshot.context, secondInsertedBlock) ? secondInsertedBlock : void 0;\n    return !insertedListBlock || focusListBlock.node.level !== insertedListBlock.level || focusListBlock.node.listItem === insertedListBlock.listItem ? !1 : {\n      listItem: focusListBlock.node.listItem,\n      insertedListBlock\n    };\n  },\n  actions: [({\n    snapshot,\n    event\n  }, {\n    listItem,\n    insertedListBlock\n  }) => {\n    let adjustListItem = !0, listStartBlockFound = !1;\n    return [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      ...event,\n      blocks: event.blocks.map((block) => (block._key === insertedListBlock._key && (listStartBlockFound = !0), adjustListItem ? listStartBlockFound && adjustListItem && (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.isListBlock)(snapshot.context, block) ? {\n        ...block,\n        listItem: block.level === insertedListBlock.level ? listItem : block.listItem\n      } : (listStartBlockFound && (adjustListItem = !1), block) : block))\n    })];\n  }]\n}), inheritListProperties = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"insert.block\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    if (event.placement !== \"auto\" || event.block._type !== snapshot.context.schema.block.name || event.block.listItem !== void 0)\n      return !1;\n    const focusListBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getFocusListBlock)(snapshot);\n    return !focusListBlock || !(0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.isEmptyTextBlock)(snapshot.context, focusListBlock.node) ? !1 : {\n      level: focusListBlock.node.level,\n      listItem: focusListBlock.node.listItem\n    };\n  },\n  actions: [({\n    event\n  }, {\n    level,\n    listItem\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    ...event,\n    block: {\n      ...event.block,\n      level,\n      listItem\n    }\n  })]]\n}), coreListBehaviors = {\n  clearListOnBackspace,\n  unindentListOnBackspace,\n  mergeTextIntoListOnDelete,\n  mergeTextIntoListOnBackspace,\n  deletingListFromStart,\n  clearListOnEnter,\n  indentListOnTab,\n  unindentListOnShiftTab,\n  inheritListLevel,\n  inheritListItem,\n  inheritListProperties\n}, coreBehaviorsConfig = [...coreAnnotationBehaviors, coreDecoratorBehaviors.strongShortcut, coreDecoratorBehaviors.emShortcut, coreDecoratorBehaviors.underlineShortcut, coreDecoratorBehaviors.codeShortcut, ...coreDndBehaviors, coreBlockObjectBehaviors.clickingAboveLonelyBlockObject, coreBlockObjectBehaviors.clickingBelowLonelyBlockObject, coreBlockObjectBehaviors.arrowDownOnLonelyBlockObject, coreBlockObjectBehaviors.arrowUpOnLonelyBlockObject, coreBlockObjectBehaviors.breakingBlockObject, coreBlockObjectBehaviors.deletingEmptyTextBlockAfterBlockObject, coreBlockObjectBehaviors.deletingEmptyTextBlockBeforeBlockObject, ...coreInsertBehaviors, coreListBehaviors.clearListOnBackspace, coreListBehaviors.unindentListOnBackspace, coreListBehaviors.mergeTextIntoListOnDelete, coreListBehaviors.mergeTextIntoListOnBackspace, coreListBehaviors.deletingListFromStart, coreListBehaviors.clearListOnEnter, coreListBehaviors.indentListOnTab, coreListBehaviors.unindentListOnShiftTab, coreListBehaviors.inheritListLevel, coreListBehaviors.inheritListItem, coreListBehaviors.inheritListProperties, coreInsertBreakBehaviors.breakingAtTheEndOfTextBlock, coreInsertBreakBehaviors.breakingAtTheStartOfTextBlock, coreInsertBreakBehaviors.breakingEntireDocument, coreInsertBreakBehaviors.breakingEntireBlocks, coreInsertBreakBehaviors.breakingInlineObject].map((behavior) => ({\n  behavior,\n  priority: corePriority\n}));\nfunction withoutNormalizingConditional(editor, predicate, fn) {\n  predicate() ? slate__WEBPACK_IMPORTED_MODULE_14__.Editor.withoutNormalizing(editor, fn) : fn();\n}\nconst abstractAnnotationBehaviors = [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"annotation.set\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    const blockKey = event.at[0]._key, markDefKey = event.at[2]._key, block = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusTextBlock)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: {\n            path: [{\n              _key: blockKey\n            }],\n            offset: 0\n          },\n          focus: {\n            path: [{\n              _key: blockKey\n            }],\n            offset: 0\n          }\n        }\n      }\n    });\n    if (!block)\n      return !1;\n    const updatedMarkDefs = block.node.markDefs?.map((markDef) => markDef._key === markDefKey ? {\n      ...markDef,\n      ...event.props\n    } : markDef);\n    return {\n      blockKey,\n      updatedMarkDefs\n    };\n  },\n  actions: [(_, {\n    blockKey,\n    updatedMarkDefs\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"block.set\",\n    at: [{\n      _key: blockKey\n    }],\n    props: {\n      markDefs: updatedMarkDefs\n    }\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"annotation.toggle\",\n  guard: ({\n    snapshot,\n    event\n  }) => (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.isActiveAnnotation)(event.annotation.name)(snapshot),\n  actions: [({\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"annotation.remove\",\n    annotation: event.annotation\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"annotation.toggle\",\n  guard: ({\n    snapshot,\n    event\n  }) => !(0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.isActiveAnnotation)(event.annotation.name)(snapshot),\n  actions: [({\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"annotation.add\",\n    annotation: event.annotation\n  })]]\n})], abstractDecoratorBehaviors = [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"decorator.toggle\",\n  guard: ({\n    snapshot,\n    event\n  }) => (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.isActiveDecorator)(event.decorator)(snapshot),\n  actions: [({\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"decorator.remove\",\n    decorator: event.decorator\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"decorator.toggle\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    const manualSelection = event.at ? (0,_chunks_es_util_child_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_33__.blockOffsetsToSelection)({\n      context: snapshot.context,\n      offsets: event.at\n    }) : null;\n    return manualSelection ? !(0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.isActiveDecorator)(event.decorator)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: manualSelection\n      }\n    }) : !(0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.isActiveDecorator)(event.decorator)(snapshot);\n  },\n  actions: [({\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    ...event,\n    type: \"decorator.add\"\n  })]]\n})], abstractDeleteBehaviors = [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"delete.backward\",\n  guard: ({\n    snapshot\n  }) => snapshot.context.selection ? {\n    selection: snapshot.context.selection\n  } : !1,\n  actions: [({\n    event\n  }, {\n    selection\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"delete\",\n    direction: \"backward\",\n    unit: event.unit,\n    at: selection\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"delete\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    if (event.direction !== \"backward\")\n      return !1;\n    const previousBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getPreviousBlock)(snapshot), focusTextBlock = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusTextBlock)(snapshot);\n    if (!previousBlock || !focusTextBlock || !(0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.isAtTheStartOfBlock)(focusTextBlock)(snapshot))\n      return !1;\n    const previousBlockEndPoint = (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.getBlockEndPoint)({\n      context: snapshot.context,\n      block: previousBlock\n    });\n    return (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(snapshot.context, previousBlock.node) ? {\n      previousBlockEndPoint,\n      focusTextBlock\n    } : !1;\n  },\n  actions: [(_, {\n    previousBlockEndPoint,\n    focusTextBlock\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"delete.block\",\n    at: focusTextBlock.path\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"select\",\n    at: {\n      anchor: previousBlockEndPoint,\n      focus: previousBlockEndPoint\n    }\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"insert.block\",\n    block: focusTextBlock.node,\n    placement: \"auto\",\n    select: \"start\"\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"delete.forward\",\n  guard: ({\n    snapshot\n  }) => snapshot.context.selection ? {\n    selection: snapshot.context.selection\n  } : !1,\n  actions: [({\n    event\n  }, {\n    selection\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"delete\",\n    direction: \"forward\",\n    unit: event.unit,\n    at: selection\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"delete\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    if (event.direction !== \"forward\")\n      return !1;\n    const nextBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getNextBlock)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: event.at\n      }\n    }), focusTextBlock = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusTextBlock)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: event.at\n      }\n    });\n    if (!nextBlock || !focusTextBlock || !(0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.isEmptyTextBlock)(snapshot.context, focusTextBlock.node))\n      return !1;\n    const nextBlockStartPoint = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.getBlockStartPoint)({\n      context: snapshot.context,\n      block: nextBlock\n    });\n    return {\n      focusTextBlock,\n      nextBlockStartPoint\n    };\n  },\n  actions: [(_, {\n    focusTextBlock,\n    nextBlockStartPoint\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"delete.block\",\n    at: focusTextBlock.path\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"select\",\n    at: {\n      anchor: nextBlockStartPoint,\n      focus: nextBlockStartPoint\n    }\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"delete\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    if (event.direction !== \"forward\")\n      return !1;\n    const nextBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getNextBlock)(snapshot), focusTextBlock = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusTextBlock)(snapshot);\n    return !nextBlock || !focusTextBlock || !(0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.isAtTheEndOfBlock)(focusTextBlock)(snapshot) || !(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(snapshot.context, nextBlock.node) ? !1 : {\n      nextBlock\n    };\n  },\n  actions: [(_, {\n    nextBlock\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"delete.block\",\n    at: nextBlock.path\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"insert.block\",\n    block: nextBlock.node,\n    placement: \"auto\",\n    select: \"none\"\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"delete.block\",\n  actions: [({\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"delete\",\n    at: {\n      anchor: {\n        path: event.at,\n        offset: 0\n      },\n      focus: {\n        path: event.at,\n        offset: 0\n      }\n    },\n    unit: \"block\"\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"delete.child\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    const focusChild = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusChild)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: {\n            path: event.at,\n            offset: 0\n          },\n          focus: {\n            path: event.at,\n            offset: 0\n          }\n        }\n      }\n    });\n    return focusChild ? (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isSpan)(snapshot.context, focusChild.node) ? {\n      selection: {\n        anchor: {\n          path: event.at,\n          offset: 0\n        },\n        focus: {\n          path: event.at,\n          offset: focusChild.node.text.length\n        }\n      }\n    } : {\n      selection: {\n        anchor: {\n          path: event.at,\n          offset: 0\n        },\n        focus: {\n          path: event.at,\n          offset: 0\n        }\n      }\n    } : !1;\n  },\n  actions: [(_, {\n    selection\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"delete\",\n    at: selection\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"delete.text\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    const selection = (0,_chunks_es_util_child_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_33__.blockOffsetsToSelection)({\n      context: snapshot.context,\n      offsets: event.at\n    });\n    if (!selection)\n      return !1;\n    const trimmedSelection = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getTrimmedSelection)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        value: snapshot.context.value,\n        selection\n      }\n    });\n    return trimmedSelection ? {\n      selection: trimmedSelection\n    } : !1;\n  },\n  actions: [(_, {\n    selection\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"delete\",\n    at: selection\n  })]]\n})], abstractDeserializeBehaviors = [\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"deserialize\",\n    guard: ({\n      event\n    }) => {\n      const portableText = event.originEvent.originEvent.dataTransfer.getData(\"application/x-portable-text\");\n      if (portableText)\n        return {\n          type: \"deserialize.data\",\n          mimeType: \"application/x-portable-text\",\n          data: portableText,\n          originEvent: event.originEvent\n        };\n      const json = event.originEvent.originEvent.dataTransfer.getData(\"application/json\");\n      if (json)\n        return {\n          type: \"deserialize.data\",\n          mimeType: \"application/json\",\n          data: json,\n          originEvent: event.originEvent\n        };\n      const html = event.originEvent.originEvent.dataTransfer.getData(\"text/html\");\n      if (html)\n        return {\n          type: \"deserialize.data\",\n          mimeType: \"text/html\",\n          data: html,\n          originEvent: event.originEvent\n        };\n      const text = event.originEvent.originEvent.dataTransfer.getData(\"text/plain\");\n      return text ? {\n        type: \"deserialize.data\",\n        mimeType: \"text/plain\",\n        data: text,\n        originEvent: event.originEvent\n      } : !1;\n    },\n    actions: [(_, deserializeEvent) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)(deserializeEvent)]]\n  }),\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"deserialize\",\n    actions: [({\n      event\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"deserialization.failure\",\n      mimeType: \"*/*\",\n      reason: \"No Behavior was able to handle the incoming data\",\n      originEvent: event.originEvent\n    })]]\n  }),\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"deserialize.data\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      const converter = snapshot.context.converters.find((converter2) => converter2.mimeType === event.mimeType);\n      return converter ? converter.deserialize({\n        snapshot,\n        event: {\n          type: \"deserialize\",\n          data: event.data\n        }\n      }) : !1;\n    },\n    actions: [({\n      event\n    }, deserializeEvent) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      ...deserializeEvent,\n      originEvent: event.originEvent\n    })]]\n  }),\n  /**\n   * If we are pasting text/plain into a text block then we can probably\n   * assume that the intended behavior is that the pasted text inherits\n   * formatting from the text it's pasted into.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"deserialization.success\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      if ((0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusTextBlock)(snapshot) && event.mimeType === \"text/plain\" && event.originEvent.type === \"clipboard.paste\") {\n        const activeDecorators = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getActiveDecorators)(snapshot);\n        return {\n          activeAnnotations: (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getActiveAnnotations)(snapshot),\n          activeDecorators,\n          textRuns: event.data.flatMap((block) => (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(snapshot.context, block) ? [(0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.getTextBlockText)(block)] : [])\n        };\n      }\n      return !1;\n    },\n    actions: [(_, {\n      activeAnnotations,\n      activeDecorators,\n      textRuns\n    }) => textRuns.flatMap((textRun, index) => index !== textRuns.length - 1 ? [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"insert.span\",\n      text: textRun,\n      decorators: activeDecorators,\n      annotations: activeAnnotations.map(({\n        _key,\n        _type,\n        ...value\n      }) => ({\n        name: _type,\n        value\n      }))\n    }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"insert.break\"\n    })] : [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"insert.span\",\n      text: textRun,\n      decorators: activeDecorators,\n      annotations: activeAnnotations.map(({\n        _key,\n        _type,\n        ...value\n      }) => ({\n        name: _type,\n        value\n      }))\n    })])]\n  }),\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"deserialization.success\",\n    actions: [({\n      event\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"insert.blocks\",\n      blocks: event.data,\n      placement: \"auto\"\n    })]]\n  }),\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"deserialization.failure\",\n    guard: ({\n      event\n    }) => {\n      if (event.mimeType === \"application/x-portable-text\") {\n        const json = event.originEvent.originEvent.dataTransfer.getData(\"application/json\");\n        if (json)\n          return {\n            type: \"deserialize.data\",\n            mimeType: \"application/json\",\n            data: json,\n            originEvent: event.originEvent\n          };\n      }\n      if (event.mimeType === \"application/json\") {\n        const html = event.originEvent.originEvent.dataTransfer.getData(\"text/html\");\n        if (html)\n          return {\n            type: \"deserialize.data\",\n            mimeType: \"text/html\",\n            data: html,\n            originEvent: event.originEvent\n          };\n      }\n      if (event.mimeType === \"text/html\") {\n        const text = event.originEvent.originEvent.dataTransfer.getData(\"text/plain\");\n        if (text)\n          return {\n            type: \"deserialize.data\",\n            mimeType: \"text/plain\",\n            data: text,\n            originEvent: event.originEvent\n          };\n      }\n      return !1;\n    },\n    actions: [(_, deserializeDataEvent) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)(deserializeDataEvent)]]\n  }),\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"deserialization.failure\",\n    actions: [({\n      event\n    }) => [{\n      type: \"effect\",\n      effect: () => {\n        console.warn(`Deserialization of ${event.mimeType} failed with reason \"${event.reason}\"`);\n      }\n    }]]\n  })\n], abstractInsertBehaviors = [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"insert.blocks\",\n  guard: ({\n    event\n  }) => {\n    const onlyBlock = event.blocks.length === 1 ? event.blocks.at(0) : void 0;\n    return onlyBlock ? {\n      onlyBlock\n    } : !1;\n  },\n  actions: [({\n    event\n  }, {\n    onlyBlock\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"insert.block\",\n    block: onlyBlock,\n    placement: event.placement,\n    select: event.select ?? \"end\"\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"insert.blocks\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    if (event.placement !== \"before\")\n      return !1;\n    const firstBlockKey = event.blocks.at(0)?._key ?? snapshot.context.keyGenerator(), lastBlockKey = event.blocks.at(-1)?._key ?? snapshot.context.keyGenerator();\n    return {\n      firstBlockKey,\n      lastBlockKey\n    };\n  },\n  actions: [({\n    snapshot,\n    event\n  }, {\n    firstBlockKey,\n    lastBlockKey\n  }) => [...event.blocks.map((block, index) => (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"insert.block\",\n    block,\n    placement: index === 0 ? \"before\" : \"after\",\n    select: index !== event.blocks.length - 1 ? \"end\" : \"none\"\n  })), ...event.select === \"none\" ? [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"select\",\n    at: snapshot.context.selection\n  })] : event.select === \"start\" ? [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"select.block\",\n    at: [{\n      _key: firstBlockKey\n    }],\n    select: \"start\"\n  })] : [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"select.block\",\n    at: [{\n      _key: lastBlockKey\n    }],\n    select: \"end\"\n  })]]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"insert.blocks\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    if (event.placement !== \"after\")\n      return !1;\n    const firstBlockKey = event.blocks.at(0)?._key ?? snapshot.context.keyGenerator(), lastBlockKey = event.blocks.at(-1)?._key ?? snapshot.context.keyGenerator();\n    return {\n      firstBlockKey,\n      lastBlockKey\n    };\n  },\n  actions: [({\n    snapshot,\n    event\n  }, {\n    firstBlockKey,\n    lastBlockKey\n  }) => [...event.blocks.map((block, index) => (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"insert.block\",\n    block,\n    placement: \"after\",\n    select: index !== event.blocks.length - 1 ? \"end\" : \"none\"\n  })), ...event.select === \"none\" ? [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"select\",\n    at: snapshot.context.selection\n  })] : event.select === \"start\" ? [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"select.block\",\n    at: [{\n      _key: firstBlockKey\n    }],\n    select: \"start\"\n  })] : [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"select.block\",\n    at: [{\n      _key: lastBlockKey\n    }],\n    select: \"end\"\n  })]]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"insert.blocks\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    if (event.placement !== \"auto\")\n      return !1;\n    const focusTextBlock = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusTextBlock)(snapshot);\n    if (!focusTextBlock || !(0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.isEmptyTextBlock)(snapshot.context, focusTextBlock.node))\n      return !1;\n    const firstBlockKey = event.blocks.at(0)?._key ?? snapshot.context.keyGenerator(), lastBlockKey = event.blocks.at(-1)?._key ?? snapshot.context.keyGenerator();\n    return {\n      focusTextBlock,\n      firstBlockKey,\n      lastBlockKey\n    };\n  },\n  actions: [({\n    event\n  }, {\n    firstBlockKey,\n    lastBlockKey\n  }) => [...event.blocks.map((block, index) => (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"insert.block\",\n    block,\n    placement: index === 0 ? \"auto\" : \"after\",\n    select: index !== event.blocks.length - 1 ? \"end\" : \"none\"\n  })), ...event.select === \"none\" || event.select === \"start\" ? [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"select.block\",\n    at: [{\n      _key: firstBlockKey\n    }],\n    select: \"start\"\n  })] : [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"select.block\",\n    at: [{\n      _key: lastBlockKey\n    }],\n    select: \"end\"\n  })]]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"insert.blocks\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    if (event.placement !== \"auto\")\n      return !1;\n    const focusTextBlock = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusTextBlock)(snapshot);\n    if (!focusTextBlock || !snapshot.context.selection)\n      return !1;\n    const focusBlockStartPoint = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.getBlockStartPoint)({\n      context: snapshot.context,\n      block: focusTextBlock\n    }), focusBlockEndPoint = (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.getBlockEndPoint)({\n      context: snapshot.context,\n      block: focusTextBlock\n    }), focusTextBlockAfter = (0,_chunks_es_util_slice_text_block_js__WEBPACK_IMPORTED_MODULE_32__.sliceTextBlock)({\n      context: {\n        schema: snapshot.context.schema,\n        selection: {\n          anchor: snapshot.context.selection.focus,\n          focus: focusBlockEndPoint\n        }\n      },\n      block: focusTextBlock.node\n    });\n    return {\n      firstBlockKey: event.blocks.at(0)?._key ?? snapshot.context.keyGenerator(),\n      focusBlockStartPoint,\n      focusBlockEndPoint,\n      focusTextBlockAfter,\n      selection: snapshot.context.selection\n    };\n  },\n  actions: [({\n    event\n  }, {\n    focusBlockEndPoint,\n    focusTextBlockAfter,\n    selection,\n    firstBlockKey,\n    focusBlockStartPoint\n  }) => [...event.blocks.flatMap((block, index) => index === 0 ? [...(0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.isEqualSelectionPoints)(selection.focus, focusBlockEndPoint) ? [] : [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"delete\",\n    at: {\n      anchor: selection.focus,\n      focus: focusBlockEndPoint\n    }\n  })], (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"insert.block\",\n    block,\n    placement: \"auto\",\n    select: \"end\"\n  })] : index === event.blocks.length - 1 ? [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"insert.block\",\n    block,\n    placement: \"after\",\n    select: \"end\"\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"insert.block\",\n    block: focusTextBlockAfter,\n    placement: \"auto\",\n    select: event.select === \"end\" ? \"none\" : \"end\"\n  })] : [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"insert.block\",\n    block,\n    placement: \"after\",\n    select: \"end\"\n  })]), ...event.select === \"none\" ? [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"select\",\n    at: selection\n  })] : event.select === \"start\" ? [(0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.isEqualSelectionPoints)(selection.focus, focusBlockStartPoint) ? (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"select.block\",\n    at: [{\n      _key: firstBlockKey\n    }],\n    select: \"start\"\n  }) : (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"select\",\n    at: {\n      anchor: selection.focus,\n      focus: selection.focus\n    }\n  })] : []]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"insert.blocks\",\n  guard: ({\n    event\n  }) => event.placement === \"auto\",\n  actions: [({\n    event\n  }) => event.blocks.map((block, index) => (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"insert.block\",\n    block,\n    placement: index === 0 ? \"auto\" : \"after\",\n    select: event.select ?? \"end\"\n  }))]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"insert.break\",\n  actions: [() => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"split\"\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"insert.child\",\n  guard: ({\n    snapshot\n  }) => {\n    const lastBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getLastBlock)(snapshot);\n    return !lastBlock || snapshot.context.selection ? !1 : {\n      lastBlockEndPoint: (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.getBlockEndPoint)({\n        context: snapshot.context,\n        block: lastBlock\n      })\n    };\n  },\n  actions: [({\n    event\n  }, {\n    lastBlockEndPoint\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"select\",\n    at: {\n      anchor: lastBlockEndPoint,\n      focus: lastBlockEndPoint\n    }\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)(event)]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"insert.child\",\n  guard: ({\n    snapshot\n  }) => {\n    const focusTextBlock = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusTextBlock)(snapshot);\n    return snapshot.context.selection && !focusTextBlock;\n  },\n  actions: [({\n    snapshot,\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"insert.block\",\n    block: {\n      _type: snapshot.context.schema.block.name,\n      children: [{\n        _type: snapshot.context.schema.span.name,\n        text: \"\",\n        marks: []\n      }]\n    },\n    placement: \"auto\",\n    select: \"end\"\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)(event)]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"insert.inline object\",\n  actions: [({\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"insert.child\",\n    child: {\n      _type: event.inlineObject.name,\n      ...event.inlineObject.value\n    }\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"insert.soft break\",\n  actions: [() => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"insert.text\",\n    text: `\n`\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"insert.span\",\n  guard: ({\n    snapshot\n  }) => !(0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusTextBlock)(snapshot),\n  actions: [({\n    snapshot,\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"insert.block\",\n    block: {\n      _type: snapshot.context.schema.block.name,\n      children: [{\n        _type: snapshot.context.schema.span.name,\n        text: \"\",\n        marks: []\n      }]\n    },\n    placement: \"auto\",\n    select: \"end\"\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)(event)]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"insert.span\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    const focusTextBlock = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusTextBlock)(snapshot);\n    return {\n      markDefs: event.annotations?.map((annotation) => ({\n        _type: annotation.name,\n        _key: snapshot.context.keyGenerator(),\n        ...annotation.value\n      })) ?? [],\n      focusTextBlock\n    };\n  },\n  actions: [({\n    snapshot,\n    event\n  }, {\n    markDefs,\n    focusTextBlock\n  }) => [...focusTextBlock ? [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"block.set\",\n    at: focusTextBlock.path,\n    props: {\n      markDefs: [...focusTextBlock.node.markDefs ?? [], ...markDefs]\n    }\n  })] : [], (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"insert.child\",\n    child: {\n      _type: snapshot.context.schema.span.name,\n      text: event.text,\n      marks: [...event.decorators ?? [], ...markDefs.map((markDef) => markDef._key)]\n    }\n  })]]\n})], shiftLeft = (0,_portabletext_keyboard_shortcuts__WEBPACK_IMPORTED_MODULE_35__.createKeyboardShortcut)({\n  default: [{\n    key: \"ArrowLeft\",\n    shift: !0,\n    meta: !1,\n    ctrl: !1,\n    alt: !1\n  }]\n}), abstractKeyboardBehaviors = [\n  /**\n   * When Backspace is pressed on an inline object, Slate will raise a\n   * `delete.backward` event with `unit: 'block'`. This is wrong and this\n   * Behavior adjusts that.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"keyboard.keydown\",\n    guard: ({\n      snapshot,\n      event\n    }) => defaultKeyboardShortcuts.backspace.guard(event.originEvent) && (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.isSelectionCollapsed)(snapshot) && (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getFocusInlineObject)(snapshot),\n    actions: [() => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"delete.backward\",\n      unit: \"character\"\n    })]]\n  }),\n  /**\n   * When Delete is pressed on an inline object, Slate will raise a\n   * `delete.forward` event with `unit: 'block'`. This is wrong and this\n   * Behavior adjusts that.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"keyboard.keydown\",\n    guard: ({\n      snapshot,\n      event\n    }) => defaultKeyboardShortcuts.delete.guard(event.originEvent) && (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.isSelectionCollapsed)(snapshot) && (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getFocusInlineObject)(snapshot),\n    actions: [() => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"delete.forward\",\n      unit: \"character\"\n    })]]\n  }),\n  /**\n   * Allow raising an `insert.break` event when pressing Enter on an inline\n   * object.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"keyboard.keydown\",\n    guard: ({\n      snapshot,\n      event\n    }) => defaultKeyboardShortcuts.break.guard(event.originEvent) && (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.isSelectionCollapsed)(snapshot) && (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getFocusInlineObject)(snapshot),\n    actions: [() => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"insert.break\"\n    })]]\n  }),\n  /**\n   * On Firefox, Enter might collapse the selection. To mitigate this, we\n   * `raise` an `insert.break` event manually.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"keyboard.keydown\",\n    guard: ({\n      snapshot,\n      event\n    }) => defaultKeyboardShortcuts.break.guard(event.originEvent) && (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.isSelectionExpanded)(snapshot),\n    actions: [() => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"insert.break\"\n    })]]\n  }),\n  /**\n   * On WebKit, Shift+Enter results in an `insertParagraph` input event rather\n   * than an `insertLineBreak` input event. This Behavior makes sure we catch\n   * that `keyboard.keydown` event beforehand and raise an `insert.soft break` manually.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"keyboard.keydown\",\n    guard: ({\n      event\n    }) => defaultKeyboardShortcuts.lineBreak.guard(event.originEvent),\n    actions: [() => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"insert.soft break\"\n    })]]\n  }),\n  /**\n   * Manual handling of undo shortcuts.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"keyboard.keydown\",\n    guard: ({\n      event\n    }) => defaultKeyboardShortcuts.history.undo.guard(event.originEvent),\n    actions: [() => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"history.undo\"\n    })]]\n  }),\n  /**\n   * Manual handling of redo shortcuts.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"keyboard.keydown\",\n    guard: ({\n      event\n    }) => defaultKeyboardShortcuts.history.redo.guard(event.originEvent),\n    actions: [() => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"history.redo\"\n    })]]\n  }),\n  /**\n   * Fix edge case where Shift+ArrowLeft didn't reduce a selection hanging\n   * onto an empty text block.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"keyboard.keydown\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      if (!snapshot.context.selection || !shiftLeft.guard(event.originEvent))\n        return !1;\n      const focusBlock = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusBlock)(snapshot);\n      if (!focusBlock)\n        return !1;\n      const previousBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getPreviousBlock)({\n        ...snapshot,\n        context: {\n          ...snapshot.context,\n          selection: {\n            anchor: {\n              path: focusBlock.path,\n              offset: 0\n            },\n            focus: {\n              path: focusBlock.path,\n              offset: 0\n            }\n          }\n        }\n      });\n      return previousBlock && (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(snapshot.context, focusBlock.node) && snapshot.context.selection.focus.offset === 0 && (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.isEmptyTextBlock)(snapshot.context, focusBlock.node) ? {\n        previousBlock,\n        selection: snapshot.context.selection\n      } : !1;\n    },\n    actions: [({\n      snapshot\n    }, {\n      previousBlock,\n      selection\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"select\",\n      at: {\n        anchor: selection.anchor,\n        focus: (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.getBlockEndPoint)({\n          context: snapshot.context,\n          block: previousBlock\n        })\n      }\n    })]]\n  })\n], abstractListItemBehaviors = [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"list item.add\",\n  guard: ({\n    snapshot,\n    event\n  }) => snapshot.context.schema.lists.some((list) => list.name === event.listItem) ? {\n    selectedTextBlocks: (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getSelectedTextBlocks)(snapshot)\n  } : !1,\n  actions: [({\n    event\n  }, {\n    selectedTextBlocks\n  }) => selectedTextBlocks.map((block) => (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"block.set\",\n    at: block.path,\n    props: {\n      level: block.node.level ?? 1,\n      listItem: event.listItem\n    }\n  }))]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"list item.remove\",\n  guard: ({\n    snapshot\n  }) => ({\n    selectedTextBlocks: (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getSelectedTextBlocks)(snapshot)\n  }),\n  actions: [(_, {\n    selectedTextBlocks\n  }) => selectedTextBlocks.map((block) => (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"block.unset\",\n    at: block.path,\n    props: [\"level\", \"listItem\"]\n  }))]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"list item.toggle\",\n  guard: ({\n    snapshot,\n    event\n  }) => (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.isActiveListItem)(event.listItem)(snapshot),\n  actions: [({\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"list item.remove\",\n    listItem: event.listItem\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"list item.toggle\",\n  guard: ({\n    snapshot,\n    event\n  }) => !(0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.isActiveListItem)(event.listItem)(snapshot),\n  actions: [({\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"list item.add\",\n    listItem: event.listItem\n  })]]\n})], abstractMoveBehaviors = [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"move.block up\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    const previousBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getPreviousBlock)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: {\n            path: event.at,\n            offset: 0\n          },\n          focus: {\n            path: event.at,\n            offset: 0\n          }\n        }\n      }\n    });\n    return previousBlock ? {\n      previousBlock\n    } : !1;\n  },\n  actions: [({\n    event\n  }, {\n    previousBlock\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"move.block\",\n    at: event.at,\n    to: previousBlock.path\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"move.block down\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    const nextBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getNextBlock)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: {\n            path: event.at,\n            offset: 0\n          },\n          focus: {\n            path: event.at,\n            offset: 0\n          }\n        }\n      }\n    });\n    return nextBlock ? {\n      nextBlock\n    } : !1;\n  },\n  actions: [({\n    event\n  }, {\n    nextBlock\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"move.block\",\n    at: event.at,\n    to: nextBlock.path\n  })]]\n})], abstractSelectBehaviors = [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"select.block\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    if (event.select !== \"end\")\n      return !1;\n    const block = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusBlock)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: {\n            path: event.at,\n            offset: 0\n          },\n          focus: {\n            path: event.at,\n            offset: 0\n          }\n        }\n      }\n    });\n    return block ? {\n      blockEndPoint: (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.getBlockEndPoint)({\n        context: snapshot.context,\n        block\n      })\n    } : !1;\n  },\n  actions: [(_, {\n    blockEndPoint\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"select\",\n    at: {\n      anchor: blockEndPoint,\n      focus: blockEndPoint\n    }\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"select.block\",\n  actions: [({\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"select\",\n    at: {\n      anchor: {\n        path: event.at,\n        offset: 0\n      },\n      focus: {\n        path: event.at,\n        offset: 0\n      }\n    }\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"select.previous block\",\n  guard: ({\n    snapshot\n  }) => {\n    const previousBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getPreviousBlock)(snapshot);\n    return previousBlock ? {\n      previousBlock\n    } : !1;\n  },\n  actions: [({\n    event\n  }, {\n    previousBlock\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"select.block\",\n    at: previousBlock.path,\n    select: event.select\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"select.next block\",\n  guard: ({\n    snapshot\n  }) => {\n    const nextBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getNextBlock)(snapshot);\n    return nextBlock ? {\n      nextBlock\n    } : !1;\n  },\n  actions: [({\n    event\n  }, {\n    nextBlock\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"select.block\",\n    at: nextBlock.path,\n    select: event.select\n  })]]\n})], abstractSerializeBehaviors = [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"serialize\",\n  actions: [({\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"serialize.data\",\n    mimeType: \"application/x-portable-text\",\n    originEvent: event.originEvent\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"serialize.data\",\n    mimeType: \"application/json\",\n    originEvent: event.originEvent\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"serialize.data\",\n    mimeType: \"text/html\",\n    originEvent: event.originEvent\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"serialize.data\",\n    mimeType: \"text/plain\",\n    originEvent: event.originEvent\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"serialize.data\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    const converter = snapshot.context.converters.find((converter2) => converter2.mimeType === event.mimeType);\n    return converter ? converter.serialize({\n      snapshot,\n      event: {\n        type: \"serialize\",\n        originEvent: event.originEvent.type\n      }\n    }) : !1;\n  },\n  actions: [({\n    event\n  }, serializeEvent) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    ...serializeEvent,\n    originEvent: event.originEvent\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"serialization.success\",\n  actions: [({\n    event\n  }) => [{\n    type: \"effect\",\n    effect: () => {\n      event.originEvent.originEvent.dataTransfer.setData(event.mimeType, event.data);\n    }\n  }]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"serialization.failure\",\n  actions: [({\n    event\n  }) => [{\n    type: \"effect\",\n    effect: () => {\n      console.warn(`Serialization of ${event.mimeType} failed with reason \"${event.reason}\"`);\n    }\n  }]]\n})], abstractSplitBehaviors = [\n  /**\n   * You can't split an inline object.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"split\",\n    guard: ({\n      snapshot\n    }) => (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.isSelectionCollapsed)(snapshot.context.selection) && (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getFocusInlineObject)(snapshot),\n    actions: []\n  }),\n  /**\n   * You can't split a block object.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"split\",\n    guard: ({\n      snapshot\n    }) => (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.isSelectionCollapsed)(snapshot.context.selection) && (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getFocusBlockObject)(snapshot),\n    actions: []\n  }),\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"split\",\n    guard: ({\n      snapshot\n    }) => {\n      const selection = snapshot.context.selection;\n      if (!selection || (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.isSelectionCollapsed)(selection))\n        return !1;\n      const selectionStartBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getSelectionStartBlock)(snapshot), selectionEndBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getSelectionEndBlock)(snapshot);\n      return !selectionStartBlock || !selectionEndBlock ? !1 : !(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(snapshot.context, selectionStartBlock.node) && (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(snapshot.context, selectionEndBlock.node) ? {\n        selection\n      } : !1;\n    },\n    actions: [(_, {\n      selection\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"delete\",\n      at: selection\n    })]]\n  }),\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"split\",\n    guard: ({\n      snapshot\n    }) => {\n      const selection = snapshot.context.selection;\n      if (!selection || (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.isSelectionCollapsed)(selection))\n        return !1;\n      const selectionStartBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getSelectionStartBlock)(snapshot), selectionEndBlock = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getSelectionEndBlock)(snapshot);\n      if (!selectionStartBlock || !selectionEndBlock || selectionStartBlock.node._key === selectionEndBlock.node._key)\n        return !1;\n      const startPoint = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.getSelectionStartPoint)(selection), startBlockEndPoint = (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.getBlockEndPoint)({\n        context: snapshot.context,\n        block: selectionStartBlock\n      }), endPoint = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.getSelectionEndPoint)(selection), endBlockStartPoint = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.getBlockStartPoint)({\n        context: snapshot.context,\n        block: selectionEndBlock\n      }), blocksInBetween = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getSelectedValue)(snapshot).filter((block) => block._key !== selectionStartBlock.node._key && block._key !== selectionEndBlock.node._key);\n      return {\n        startPoint,\n        startBlockEndPoint,\n        endPoint,\n        endBlockStartPoint,\n        blocksInBetween\n      };\n    },\n    actions: [(_, {\n      startPoint,\n      startBlockEndPoint,\n      endPoint,\n      endBlockStartPoint,\n      blocksInBetween\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"delete\",\n      at: {\n        anchor: startPoint,\n        focus: startBlockEndPoint\n      }\n    }), ...blocksInBetween.map((block) => (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"delete.block\",\n      at: [{\n        _key: block._key\n      }]\n    })), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"delete\",\n      at: {\n        anchor: endBlockStartPoint,\n        focus: endPoint\n      }\n    })]]\n  }),\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"split\",\n    guard: ({\n      snapshot\n    }) => {\n      const selection = snapshot.context.selection;\n      return !selection || (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.isSelectionCollapsed)(selection) ? !1 : {\n        selection\n      };\n    },\n    actions: [(_, {\n      selection\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"delete\",\n      at: selection\n    }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"split\"\n    })]]\n  }),\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n    on: \"split\",\n    guard: ({\n      snapshot\n    }) => {\n      const selection = snapshot.context.selection;\n      if (!selection || !(0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.isSelectionCollapsed)(selection))\n        return !1;\n      const selectionStartPoint = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.getSelectionStartPoint)(selection), focusTextBlock = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusTextBlock)(snapshot);\n      if (!focusTextBlock)\n        return !1;\n      const blockEndPoint = (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.getBlockEndPoint)({\n        context: snapshot.context,\n        block: focusTextBlock\n      }), newTextBlockSelection = {\n        anchor: selectionStartPoint,\n        focus: blockEndPoint\n      }, newTextBlock = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.parseBlock)({\n        block: (0,_chunks_es_util_slice_text_block_js__WEBPACK_IMPORTED_MODULE_32__.sliceTextBlock)({\n          context: {\n            ...snapshot.context,\n            selection: newTextBlockSelection\n          },\n          block: focusTextBlock.node\n        }),\n        context: snapshot.context,\n        options: {\n          removeUnusedMarkDefs: !0,\n          validateFields: !1\n        }\n      });\n      return newTextBlock ? {\n        newTextBlock,\n        newTextBlockSelection\n      } : !1;\n    },\n    actions: [(_, {\n      newTextBlock,\n      newTextBlockSelection\n    }) => (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_16__.isSelectionCollapsed)(newTextBlockSelection) ? [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"insert.block\",\n      block: newTextBlock,\n      placement: \"after\",\n      select: \"start\"\n    })] : [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"delete\",\n      at: newTextBlockSelection\n    }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n      type: \"insert.block\",\n      block: newTextBlock,\n      placement: \"after\",\n      select: \"start\"\n    })]]\n  })\n], abstractStyleBehaviors = [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"style.add\",\n  guard: ({\n    snapshot\n  }) => ({\n    selectedTextBlocks: (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getSelectedTextBlocks)(snapshot)\n  }),\n  actions: [({\n    event\n  }, {\n    selectedTextBlocks\n  }) => selectedTextBlocks.map((block) => (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"block.set\",\n    at: block.path,\n    props: {\n      style: event.style\n    }\n  }))]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"style.remove\",\n  guard: ({\n    snapshot\n  }) => ({\n    selectedTextBlocks: (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getSelectedTextBlocks)(snapshot)\n  }),\n  actions: [(_, {\n    selectedTextBlocks\n  }) => selectedTextBlocks.map((block) => (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"block.unset\",\n    at: block.path,\n    props: [\"style\"]\n  }))]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"style.toggle\",\n  guard: ({\n    snapshot,\n    event\n  }) => (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.isActiveStyle)(event.style)(snapshot),\n  actions: [({\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"style.remove\",\n    style: event.style\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"style.toggle\",\n  guard: ({\n    snapshot,\n    event\n  }) => !(0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.isActiveStyle)(event.style)(snapshot),\n  actions: [({\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"style.add\",\n    style: event.style\n  })]]\n})], abstractBehaviors = [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"clipboard.copy\",\n  guard: ({\n    snapshot\n  }) => {\n    const focusSpan = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusSpan)(snapshot), selectionCollapsed = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.isSelectionCollapsed)(snapshot);\n    return focusSpan && selectionCollapsed;\n  },\n  actions: []\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"clipboard.copy\",\n  actions: [({\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"serialize\",\n    originEvent: event\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"clipboard.cut\",\n  guard: ({\n    snapshot\n  }) => {\n    const focusSpan = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusSpan)(snapshot), selectionCollapsed = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.isSelectionCollapsed)(snapshot);\n    return focusSpan && selectionCollapsed;\n  },\n  actions: []\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"clipboard.cut\",\n  guard: ({\n    snapshot\n  }) => snapshot.context.selection ? {\n    selection: snapshot.context.selection\n  } : !1,\n  actions: [({\n    event\n  }, {\n    selection\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"serialize\",\n    originEvent: event\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"delete\",\n    at: selection\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"drag.dragstart\",\n  actions: [({\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"serialize\",\n    originEvent: event\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"clipboard.paste\",\n  guard: ({\n    snapshot\n  }) => snapshot.context.selection && (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.isSelectionExpanded)(snapshot) ? {\n    selection: snapshot.context.selection\n  } : !1,\n  actions: [({\n    event\n  }, {\n    selection\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"delete\",\n    at: selection\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"deserialize\",\n    originEvent: event\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"clipboard.paste\",\n  actions: [({\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"deserialize\",\n    originEvent: event\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.defineBehavior)({\n  on: \"input.*\",\n  actions: [({\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_21__.raise)({\n    type: \"deserialize\",\n    originEvent: event\n  })]]\n}), ...abstractAnnotationBehaviors, ...abstractDecoratorBehaviors, ...abstractDeleteBehaviors, ...abstractDeserializeBehaviors, ...abstractInsertBehaviors, ...abstractKeyboardBehaviors, ...abstractListItemBehaviors, ...abstractMoveBehaviors, ...abstractStyleBehaviors, ...abstractSelectBehaviors, ...abstractSerializeBehaviors, ...abstractSplitBehaviors];\nfunction isSyntheticBehaviorEvent(event) {\n  return !isCustomBehaviorEvent(event) && !isNativeBehaviorEvent(event) && !isAbstractBehaviorEvent(event);\n}\nconst abstractBehaviorEventTypes = [\"annotation.set\", \"annotation.toggle\", \"decorator.toggle\", \"delete.backward\", \"delete.block\", \"delete.child\", \"delete.forward\", \"delete.text\", \"deserialize\", \"deserialize.data\", \"deserialization.success\", \"deserialization.failure\", \"insert.blocks\", \"insert.break\", \"insert.inline object\", \"insert.soft break\", \"insert.span\", \"list item.add\", \"list item.remove\", \"list item.toggle\", \"move.block down\", \"move.block up\", \"select.block\", \"select.previous block\", \"select.next block\", \"serialize\", \"serialize.data\", \"serialization.success\", \"serialization.failure\", \"split\", \"style.add\", \"style.remove\", \"style.toggle\"];\nfunction isAbstractBehaviorEvent(event) {\n  return abstractBehaviorEventTypes.includes(event.type);\n}\nconst nativeBehaviorEventTypes = [\"clipboard.copy\", \"clipboard.cut\", \"clipboard.paste\", \"drag.dragstart\", \"drag.drag\", \"drag.dragend\", \"drag.dragenter\", \"drag.dragover\", \"drag.dragleave\", \"drag.drop\", \"input.*\", \"keyboard.keydown\", \"keyboard.keyup\", \"mouse.click\"];\nfunction isNativeBehaviorEvent(event) {\n  return nativeBehaviorEventTypes.includes(event.type);\n}\nfunction isCustomBehaviorEvent(event) {\n  return event.type.startsWith(\"custom.\");\n}\nconst debug$6 = debugWithName(\"behaviors:event\");\nfunction eventCategory(event) {\n  return isNativeBehaviorEvent(event) ? \"native\" : isAbstractBehaviorEvent(event) ? \"synthetic\" : isCustomBehaviorEvent(event) ? \"custom\" : \"synthetic\";\n}\nfunction performEvent({\n  mode,\n  behaviors,\n  remainingEventBehaviors,\n  event,\n  editor,\n  keyGenerator,\n  schema,\n  getSnapshot,\n  nativeEvent,\n  sendBack\n}) {\n  mode === \"send\" && !isNativeBehaviorEvent(event) && createUndoStep(editor), debug$6(`(${mode}:${eventCategory(event)})`, JSON.stringify(event, null, 2));\n  const eventBehaviors = [...remainingEventBehaviors, ...abstractBehaviors].filter((behavior) => {\n    if (behavior.on === \"*\")\n      return !0;\n    const [listenedNamespace] = behavior.on.includes(\"*\") && behavior.on.includes(\".\") ? behavior.on.split(\".\") : [void 0], [eventNamespace] = event.type.includes(\".\") ? event.type.split(\".\") : [void 0];\n    return listenedNamespace !== void 0 && eventNamespace !== void 0 && listenedNamespace === eventNamespace || listenedNamespace !== void 0 && eventNamespace === void 0 && listenedNamespace === event.type ? !0 : behavior.on === event.type;\n  });\n  if (eventBehaviors.length === 0 && isSyntheticBehaviorEvent(event)) {\n    nativeEvent?.preventDefault(), mode === \"send\" && clearUndoStep(editor), withPerformingBehaviorOperation(editor, () => {\n      debug$6(`(execute:${eventCategory(event)})`, JSON.stringify(event, null, 2)), performOperation({\n        context: {\n          keyGenerator,\n          schema\n        },\n        operation: {\n          ...event,\n          editor\n        }\n      });\n    }), editor.onChange();\n    return;\n  }\n  const guardSnapshot = getSnapshot();\n  let nativeEventPrevented = !1, defaultBehaviorOverwritten = !1, eventBehaviorIndex = -1;\n  for (const eventBehavior of eventBehaviors) {\n    eventBehaviorIndex++;\n    let shouldRun = !1;\n    try {\n      shouldRun = eventBehavior.guard === void 0 || eventBehavior.guard({\n        snapshot: guardSnapshot,\n        event,\n        dom: createEditorDom(sendBack, editor)\n      });\n    } catch (error) {\n      console.error(new Error(`Evaluating guard for \"${event.type}\" failed due to: ${error.message}`));\n    }\n    if (!shouldRun)\n      continue;\n    defaultBehaviorOverwritten = !0, eventBehavior.actions.length === 0 && (nativeEventPrevented = !0);\n    let actionSetIndex = -1;\n    for (const actionSet of eventBehavior.actions) {\n      actionSetIndex++;\n      const actionsSnapshot = getSnapshot();\n      let actions = [];\n      try {\n        actions = actionSet({\n          snapshot: actionsSnapshot,\n          event,\n          dom: createEditorDom(sendBack, editor)\n        }, shouldRun);\n      } catch (error) {\n        console.error(new Error(`Evaluating actions for \"${event.type}\" failed due to: ${error.message}`));\n      }\n      if (actions.length === 0)\n        continue;\n      nativeEventPrevented = actions.some((action) => action.type === \"raise\" || action.type === \"execute\") || !actions.some((action) => action.type === \"forward\");\n      let undoStepCreated = !1;\n      actionSetIndex > 0 && (createUndoStep(editor), undoStepCreated = !0), !undoStepCreated && actions.some((action) => action.type === \"execute\") && (createUndoStep(editor), undoStepCreated = !0);\n      const actionTypes = actions.map((action) => action.type), uniqueActionTypes = new Set(actionTypes), raiseGroup = actionTypes.length > 1 && uniqueActionTypes.size === 1 && uniqueActionTypes.has(\"raise\"), executeGroup = actionTypes.length > 1 && uniqueActionTypes.size === 1 && uniqueActionTypes.has(\"execute\");\n      withoutNormalizingConditional(editor, () => raiseGroup || executeGroup, () => {\n        for (const action of actions) {\n          if (action.type === \"effect\") {\n            try {\n              action.effect({\n                send: sendBack\n              });\n            } catch (error) {\n              console.error(new Error(`Executing effect as a result of \"${event.type}\" failed due to: ${error.message}`));\n            }\n            continue;\n          }\n          if (action.type === \"forward\") {\n            const remainingEventBehaviors2 = eventBehaviors.slice(eventBehaviorIndex + 1);\n            performEvent({\n              mode: mode === \"execute\" ? \"execute\" : \"forward\",\n              behaviors,\n              remainingEventBehaviors: remainingEventBehaviors2,\n              event: action.event,\n              editor,\n              keyGenerator,\n              schema,\n              getSnapshot,\n              nativeEvent,\n              sendBack\n            });\n            continue;\n          }\n          if (action.type === \"raise\") {\n            performEvent({\n              mode: mode === \"execute\" ? \"execute\" : \"raise\",\n              behaviors,\n              remainingEventBehaviors: mode === \"execute\" ? remainingEventBehaviors : behaviors,\n              event: action.event,\n              editor,\n              keyGenerator,\n              schema,\n              getSnapshot,\n              nativeEvent,\n              sendBack\n            });\n            continue;\n          }\n          performEvent({\n            mode: \"execute\",\n            behaviors,\n            remainingEventBehaviors: [],\n            event: action.event,\n            editor,\n            keyGenerator,\n            schema,\n            getSnapshot,\n            nativeEvent: void 0,\n            sendBack\n          });\n        }\n      }), undoStepCreated && clearUndoStep(editor);\n    }\n    break;\n  }\n  !defaultBehaviorOverwritten && isSyntheticBehaviorEvent(event) ? (nativeEvent?.preventDefault(), mode === \"send\" && clearUndoStep(editor), withPerformingBehaviorOperation(editor, () => {\n    debug$6(`(execute:${eventCategory(event)})`, JSON.stringify(event, null, 2)), performOperation({\n      context: {\n        keyGenerator,\n        schema\n      },\n      operation: {\n        ...event,\n        editor\n      }\n    });\n  }), editor.onChange()) : nativeEventPrevented && nativeEvent?.preventDefault();\n}\nfunction sortByPriority(items) {\n  if (items.length === 0)\n    return [];\n  const itemsWithPriority = items.filter((item) => item.priority !== void 0), itemsWithoutPriority = items.filter((item) => item.priority === void 0);\n  if (itemsWithPriority.length === 0)\n    return items;\n  const itemsByPriorityId = new Map(itemsWithPriority.map((item) => [item.priority.id, item])), graph = /* @__PURE__ */ new Map(), inDegree = /* @__PURE__ */ new Map();\n  function ensureNode(id) {\n    graph.has(id) || (graph.set(id, /* @__PURE__ */ new Set()), inDegree.set(id, 0));\n  }\n  for (const item of itemsWithPriority) {\n    const id = item.priority.id;\n    ensureNode(id);\n  }\n  function addEdge(fromId, toId) {\n    !graph.has(fromId) || !graph.has(toId) || (graph.get(fromId)?.add(toId), inDegree.set(toId, (inDegree.get(toId) ?? 0) + 1));\n  }\n  for (const item of itemsWithPriority) {\n    const id = item.priority.id, visited = /* @__PURE__ */ new Set();\n    let ref = item.priority.reference;\n    for (; ref; ) {\n      const refId = ref.priority.id;\n      if (ensureNode(refId), visited.has(refId))\n        throw new Error(\"Circular dependency detected in priorities\");\n      visited.add(refId), ref.importance === \"higher\" ? addEdge(id, refId) : addEdge(refId, id), ref = ref.priority.reference;\n    }\n  }\n  const queue = [];\n  for (const [id, degree] of inDegree)\n    degree === 0 && queue.push(id);\n  const result = [];\n  for (; queue.length > 0; ) {\n    const currentId = queue.shift(), currentItem = itemsByPriorityId.get(currentId);\n    currentItem && result.push(currentItem);\n    for (const neighborId of graph.get(currentId) ?? []) {\n      const newDegree = (inDegree.get(neighborId) ?? 0) - 1;\n      inDegree.set(neighborId, newDegree), newDegree === 0 && queue.push(neighborId);\n    }\n  }\n  for (const item of itemsWithPriority)\n    result.includes(item) || result.push(item);\n  return [...result, ...itemsWithoutPriority];\n}\nfunction createEditorSnapshot({\n  converters,\n  editor,\n  keyGenerator,\n  readOnly,\n  schema\n}) {\n  const selection = editor.selection ? slateRangeToSelection({\n    schema,\n    editor,\n    range: editor.selection\n  }) : null, context = {\n    converters,\n    keyGenerator,\n    readOnly,\n    schema,\n    selection,\n    value: editor.value\n  };\n  return {\n    blockIndexMap: editor.blockIndexMap,\n    context,\n    decoratorState: editor.decoratorState\n  };\n}\nconst debug$5 = debugWithName(\"editor machine\");\nfunction rerouteExternalBehaviorEvent({\n  event,\n  slateEditor\n}) {\n  switch (event.type) {\n    case \"blur\":\n      return {\n        type: \"blur\",\n        editor: slateEditor\n      };\n    case \"focus\":\n      return {\n        type: \"focus\",\n        editor: slateEditor\n      };\n    case \"insert.block object\":\n      return {\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"insert.block\",\n          block: {\n            _type: event.blockObject.name,\n            ...event.blockObject.value ?? {}\n          },\n          placement: event.placement\n        },\n        editor: slateEditor\n      };\n    default:\n      return {\n        type: \"behavior event\",\n        behaviorEvent: event,\n        editor: slateEditor\n      };\n  }\n}\nconst editorMachine = (0,xstate__WEBPACK_IMPORTED_MODULE_24__.setup)({\n  types: {\n    context: {},\n    events: {},\n    emitted: {},\n    input: {},\n    tags: {}\n  },\n  actions: {\n    \"add behavior to context\": (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n      behaviors: ({\n        context,\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_24__.assertEvent)(event, \"add behavior\"), /* @__PURE__ */ new Set([...context.behaviors, event.behaviorConfig])),\n      behaviorsSorted: !1\n    }),\n    \"remove behavior from context\": (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n      behaviors: ({\n        context,\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_24__.assertEvent)(event, \"remove behavior\"), context.behaviors.delete(event.behaviorConfig), /* @__PURE__ */ new Set([...context.behaviors]))\n    }),\n    \"emit patch event\": (0,xstate__WEBPACK_IMPORTED_MODULE_36__.a)(({\n      event\n    }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_24__.assertEvent)(event, \"internal.patch\"), event)),\n    \"emit mutation event\": (0,xstate__WEBPACK_IMPORTED_MODULE_36__.a)(({\n      event\n    }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_24__.assertEvent)(event, \"mutation\"), event)),\n    \"emit read only\": (0,xstate__WEBPACK_IMPORTED_MODULE_36__.a)({\n      type: \"read only\"\n    }),\n    \"emit editable\": (0,xstate__WEBPACK_IMPORTED_MODULE_36__.a)({\n      type: \"editable\"\n    }),\n    \"defer event\": (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n      pendingEvents: ({\n        context,\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_24__.assertEvent)(event, [\"internal.patch\", \"mutation\"]), [...context.pendingEvents, event])\n    }),\n    \"emit pending events\": (0,xstate__WEBPACK_IMPORTED_MODULE_36__.e)(({\n      context,\n      enqueue\n    }) => {\n      for (const event of context.pendingEvents)\n        enqueue.emit(event);\n    }),\n    \"emit ready\": (0,xstate__WEBPACK_IMPORTED_MODULE_36__.a)({\n      type: \"ready\"\n    }),\n    \"clear pending events\": (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n      pendingEvents: []\n    }),\n    \"defer incoming patches\": (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n      pendingIncomingPatchesEvents: ({\n        context,\n        event\n      }) => event.type === \"patches\" ? [...context.pendingIncomingPatchesEvents, event] : context.pendingIncomingPatchesEvents\n    }),\n    \"emit pending incoming patches\": (0,xstate__WEBPACK_IMPORTED_MODULE_36__.e)(({\n      context,\n      enqueue\n    }) => {\n      for (const event of context.pendingIncomingPatchesEvents)\n        enqueue.emit(event);\n    }),\n    \"clear pending incoming patches\": (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n      pendingIncomingPatchesEvents: []\n    }),\n    \"handle blur\": ({\n      event\n    }) => {\n      (0,xstate__WEBPACK_IMPORTED_MODULE_24__.assertEvent)(event, \"blur\");\n      try {\n        slate_react__WEBPACK_IMPORTED_MODULE_22__.ReactEditor.blur(event.editor);\n      } catch (error) {\n        console.error(new Error(`Failed to blur editor: ${error.message}`));\n      }\n    },\n    \"handle focus\": ({\n      context\n    }) => {\n      if (!context.slateEditor) {\n        console.error(\"No Slate editor found to focus\");\n        return;\n      }\n      try {\n        const currentSelection = context.slateEditor.selection;\n        slate_react__WEBPACK_IMPORTED_MODULE_22__.ReactEditor.focus(context.slateEditor), currentSelection && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(context.slateEditor, currentSelection);\n      } catch (error) {\n        console.error(new Error(`Failed to focus editor: ${error.message}`));\n      }\n    },\n    \"handle behavior event\": ({\n      context,\n      event,\n      self\n    }) => {\n      (0,xstate__WEBPACK_IMPORTED_MODULE_24__.assertEvent)(event, [\"behavior event\"]);\n      try {\n        const behaviors = [...context.behaviors.values()].map((config) => config.behavior);\n        performEvent({\n          mode: \"send\",\n          behaviors,\n          remainingEventBehaviors: behaviors,\n          event: event.behaviorEvent,\n          editor: event.editor,\n          keyGenerator: context.keyGenerator,\n          schema: context.schema,\n          getSnapshot: () => createEditorSnapshot({\n            converters: [...context.converters],\n            editor: event.editor,\n            keyGenerator: context.keyGenerator,\n            readOnly: self.getSnapshot().matches({\n              \"edit mode\": \"read only\"\n            }),\n            schema: context.schema\n          }),\n          nativeEvent: event.nativeEvent,\n          sendBack: (eventSentBack) => {\n            if (eventSentBack.type === \"set drag ghost\") {\n              self.send(eventSentBack);\n              return;\n            }\n            self.send(rerouteExternalBehaviorEvent({\n              event: eventSentBack,\n              slateEditor: event.editor\n            }));\n          }\n        });\n      } catch (error) {\n        console.error(new Error(`Raising \"${event.behaviorEvent.type}\" failed due to: ${error.message}`));\n      }\n    },\n    \"sort behaviors\": (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n      behaviors: ({\n        context\n      }) => context.behaviorsSorted ? context.behaviors : new Set(sortByPriority([...context.behaviors.values()])),\n      behaviorsSorted: !0\n    })\n  },\n  guards: {\n    \"slate is busy\": ({\n      context\n    }) => context.slateEditor ? context.slateEditor.operations.length > 0 : !1\n  }\n}).createMachine({\n  id: \"editor\",\n  context: ({\n    input\n  }) => ({\n    behaviors: new Set(coreBehaviorsConfig),\n    behaviorsSorted: !1,\n    converters: new Set(input.converters ?? []),\n    getLegacySchema: input.getLegacySchema,\n    keyGenerator: input.keyGenerator,\n    pendingEvents: [],\n    pendingIncomingPatchesEvents: [],\n    schema: input.schema,\n    selection: null,\n    initialReadOnly: input.readOnly ?? !1,\n    maxBlocks: input.maxBlocks,\n    initialValue: input.initialValue\n  }),\n  on: {\n    \"add behavior\": {\n      actions: \"add behavior to context\"\n    },\n    \"remove behavior\": {\n      actions: \"remove behavior from context\"\n    },\n    \"update maxBlocks\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n        maxBlocks: ({\n          event\n        }) => event.maxBlocks\n      })\n    },\n    \"update selection\": {\n      actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n        selection: ({\n          event\n        }) => event.selection\n      }), (0,xstate__WEBPACK_IMPORTED_MODULE_36__.a)(({\n        event\n      }) => ({\n        ...event,\n        type: \"selection\"\n      }))]\n    },\n    \"set drag ghost\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n        dragGhost: ({\n          event\n        }) => event.ghost\n      })\n    }\n  },\n  type: \"parallel\",\n  states: {\n    \"edit mode\": {\n      initial: \"read only\",\n      states: {\n        \"read only\": {\n          initial: \"determine initial edit mode\",\n          on: {\n            \"behavior event\": {\n              actions: [\"sort behaviors\", \"handle behavior event\"],\n              guard: ({\n                event\n              }) => event.behaviorEvent.type === \"clipboard.copy\" || event.behaviorEvent.type === \"mouse.click\" || event.behaviorEvent.type === \"serialize\" || event.behaviorEvent.type === \"serialization.failure\" || event.behaviorEvent.type === \"serialization.success\" || event.behaviorEvent.type === \"select\"\n            }\n          },\n          states: {\n            \"determine initial edit mode\": {\n              entry: [() => {\n                debug$5(\"entry: edit mode->read only->determine initial edit mode\");\n              }],\n              exit: [() => {\n                debug$5(\"exit: edit mode->read only->determine initial edit mode\");\n              }],\n              on: {\n                \"done syncing value\": [{\n                  target: \"#editor.edit mode.read only.read only\",\n                  guard: ({\n                    context\n                  }) => context.initialReadOnly\n                }, {\n                  target: \"#editor.edit mode.editable\"\n                }]\n              }\n            },\n            \"read only\": {\n              entry: [() => {\n                debug$5(\"entry: edit mode->read only->read only\");\n              }],\n              exit: [() => {\n                debug$5(\"exit: edit mode->read only->read only\");\n              }],\n              on: {\n                \"update readOnly\": {\n                  guard: ({\n                    event\n                  }) => !event.readOnly,\n                  target: \"#editor.edit mode.editable\",\n                  actions: [\"emit editable\"]\n                }\n              }\n            }\n          }\n        },\n        editable: {\n          on: {\n            \"update readOnly\": {\n              guard: ({\n                event\n              }) => event.readOnly,\n              target: \"#editor.edit mode.read only.read only\",\n              actions: [\"emit read only\"]\n            },\n            \"behavior event\": {\n              actions: [\"sort behaviors\", \"handle behavior event\"]\n            },\n            blur: {\n              actions: \"handle blur\"\n            },\n            focus: {\n              target: \".focusing\",\n              actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n                slateEditor: ({\n                  event\n                }) => event.editor\n              })]\n            }\n          },\n          initial: \"idle\",\n          states: {\n            idle: {\n              entry: [() => {\n                debug$5(\"entry: edit mode->editable->idle\");\n              }],\n              exit: [() => {\n                debug$5(\"exit: edit mode->editable-idle\");\n              }],\n              on: {\n                dragstart: {\n                  actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n                    internalDrag: ({\n                      event\n                    }) => ({\n                      origin: event.origin\n                    })\n                  })],\n                  target: \"dragging internally\"\n                }\n              }\n            },\n            focusing: {\n              initial: \"checking if busy\",\n              states: {\n                \"checking if busy\": {\n                  entry: [() => {\n                    debug$5(\"entry: edit mode->editable->focusing->checking if busy\");\n                  }],\n                  exit: [() => {\n                    debug$5(\"exit: edit mode->editable->focusing->checking if busy\");\n                  }],\n                  always: [{\n                    guard: \"slate is busy\",\n                    target: \"busy\"\n                  }, {\n                    target: \"#editor.edit mode.editable.idle\",\n                    actions: [\"handle focus\"]\n                  }]\n                },\n                busy: {\n                  entry: [() => {\n                    debug$5(\"entry: edit mode->editable->focusing-busy\");\n                  }],\n                  exit: [() => {\n                    debug$5(\"exit: edit mode->editable->focusing->busy\");\n                  }],\n                  after: {\n                    10: {\n                      target: \"checking if busy\"\n                    }\n                  }\n                }\n              }\n            },\n            \"dragging internally\": {\n              entry: [() => {\n                debug$5(\"entry: edit mode->editable->dragging internally\");\n              }],\n              exit: [() => {\n                debug$5(\"exit: edit mode->editable->dragging internally\");\n              }, ({\n                context\n              }) => {\n                if (context.dragGhost)\n                  try {\n                    context.dragGhost.parentNode?.removeChild(context.dragGhost);\n                  } catch (error) {\n                    console.error(new Error(`Removing the drag ghost failed due to: ${error.message}`));\n                  }\n              }, (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n                dragGhost: void 0\n              }), (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n                internalDrag: void 0\n              })],\n              tags: [\"dragging internally\"],\n              on: {\n                dragend: {\n                  target: \"idle\"\n                },\n                drop: {\n                  target: \"idle\"\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    setup: {\n      initial: \"setting up\",\n      states: {\n        \"setting up\": {\n          entry: [() => {\n            debug$5(\"entry: setup->setting up\");\n          }],\n          exit: [() => {\n            debug$5(\"exit: setup->setting up\");\n          }, \"emit ready\", \"emit pending incoming patches\", \"clear pending incoming patches\"],\n          on: {\n            \"internal.patch\": {\n              actions: \"defer event\"\n            },\n            mutation: {\n              actions: \"defer event\"\n            },\n            \"done syncing value\": {\n              target: \"set up\"\n            },\n            patches: {\n              actions: [\"defer incoming patches\"]\n            }\n          }\n        },\n        \"set up\": {\n          type: \"parallel\",\n          states: {\n            \"value sync\": {\n              initial: \"idle\",\n              states: {\n                idle: {\n                  entry: [() => {\n                    debug$5(\"entry: setup->set up->value sync->idle\");\n                  }],\n                  exit: [() => {\n                    debug$5(\"exit: setup->set up->value sync->idle\");\n                  }],\n                  on: {\n                    patches: {\n                      actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_36__.a)(({\n                        event\n                      }) => event)]\n                    },\n                    \"syncing value\": {\n                      target: \"syncing value\"\n                    }\n                  }\n                },\n                \"syncing value\": {\n                  entry: [() => {\n                    debug$5(\"entry: setup->set up->value sync->syncing value\");\n                  }],\n                  exit: [() => {\n                    debug$5(\"exit: setup->set up->value sync->syncing value\");\n                  }, \"emit pending incoming patches\", \"clear pending incoming patches\"],\n                  on: {\n                    patches: {\n                      actions: [\"defer incoming patches\"]\n                    },\n                    \"done syncing value\": {\n                      target: \"idle\"\n                    }\n                  }\n                }\n              }\n            },\n            writing: {\n              initial: \"pristine\",\n              states: {\n                pristine: {\n                  initial: \"idle\",\n                  states: {\n                    idle: {\n                      entry: [() => {\n                        debug$5(\"entry: setup->set up->writing->pristine->idle\");\n                      }],\n                      exit: [() => {\n                        debug$5(\"exit: setup->set up->writing->pristine->idle\");\n                      }],\n                      on: {\n                        normalizing: {\n                          target: \"normalizing\"\n                        },\n                        \"internal.patch\": {\n                          actions: \"defer event\",\n                          target: \"#editor.setup.set up.writing.dirty\"\n                        },\n                        mutation: {\n                          actions: \"defer event\",\n                          target: \"#editor.setup.set up.writing.dirty\"\n                        }\n                      }\n                    },\n                    normalizing: {\n                      entry: [() => {\n                        debug$5(\"entry: setup->set up->writing->pristine->normalizing\");\n                      }],\n                      exit: [() => {\n                        debug$5(\"exit: setup->set up->writing->pristine->normalizing\");\n                      }],\n                      on: {\n                        \"done normalizing\": {\n                          target: \"idle\"\n                        },\n                        \"internal.patch\": {\n                          actions: \"defer event\"\n                        },\n                        mutation: {\n                          actions: \"defer event\"\n                        }\n                      }\n                    }\n                  }\n                },\n                dirty: {\n                  entry: [() => {\n                    debug$5(\"entry: setup->set up->writing->dirty\");\n                  }, \"emit pending events\", \"clear pending events\"],\n                  exit: [() => {\n                    debug$5(\"exit: setup->set up->writing->dirty\");\n                  }],\n                  on: {\n                    \"internal.patch\": {\n                      actions: \"emit patch event\"\n                    },\n                    mutation: {\n                      actions: \"emit mutation event\"\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}), debug$4 = debugWithName(\"mutation-machine\"), mutationMachine = (0,xstate__WEBPACK_IMPORTED_MODULE_24__.setup)({\n  types: {\n    context: {},\n    events: {},\n    input: {},\n    emitted: {}\n  },\n  actions: {\n    \"assign readOnly\": (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n      readOnly: ({\n        context,\n        event\n      }) => event.type === \"update readOnly\" ? event.readOnly : context.readOnly\n    }),\n    \"emit patch\": (0,xstate__WEBPACK_IMPORTED_MODULE_36__.a)(({\n      event\n    }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_24__.assertEvent)(event, \"patch\"), {\n      type: \"patch\",\n      patch: event.patch\n    })),\n    \"emit has pending mutations\": (0,xstate__WEBPACK_IMPORTED_MODULE_36__.a)({\n      type: \"has pending mutations\"\n    }),\n    \"emit mutations\": (0,xstate__WEBPACK_IMPORTED_MODULE_36__.e)(({\n      context,\n      enqueue\n    }) => {\n      for (const bulk of context.pendingMutations)\n        enqueue.emit({\n          type: \"mutation\",\n          patches: bulk.patches,\n          snapshot: bulk.value\n        });\n    }),\n    \"clear pending mutations\": (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n      pendingMutations: []\n    }),\n    \"defer mutation\": (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n      pendingMutations: ({\n        context,\n        event\n      }) => {\n        if ((0,xstate__WEBPACK_IMPORTED_MODULE_24__.assertEvent)(event, \"patch\"), context.pendingMutations.length === 0)\n          return [{\n            operationId: event.operationId,\n            value: event.value,\n            patches: [event.patch]\n          }];\n        const lastBulk = context.pendingMutations.at(-1);\n        return lastBulk && lastBulk.operationId === event.operationId ? context.pendingMutations.slice(0, -1).concat({\n          value: event.value,\n          operationId: lastBulk.operationId,\n          patches: [...lastBulk.patches, event.patch]\n        }) : context.pendingMutations.concat({\n          value: event.value,\n          operationId: event.operationId,\n          patches: [event.patch]\n        });\n      }\n    }),\n    \"clear pending patch events\": (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n      pendingPatchEvents: []\n    }),\n    \"defer patch\": (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n      pendingPatchEvents: ({\n        context,\n        event\n      }) => event.type === \"patch\" ? [...context.pendingPatchEvents, event] : context.pendingPatchEvents\n    }),\n    \"emit pending patch events\": (0,xstate__WEBPACK_IMPORTED_MODULE_36__.e)(({\n      context,\n      enqueue\n    }) => {\n      for (const event of context.pendingPatchEvents)\n        enqueue.emit(event);\n    })\n  },\n  actors: {\n    \"type listener\": (0,xstate__WEBPACK_IMPORTED_MODULE_26__.fromCallback)(({\n      input,\n      sendBack\n    }) => {\n      const originalApply = input.slateEditor.apply;\n      return input.slateEditor.apply = (op) => {\n        op.type === \"insert_text\" || op.type === \"remove_text\" ? sendBack({\n          type: \"typing\"\n        }) : sendBack({\n          type: \"not typing\"\n        }), originalApply(op);\n      }, () => {\n        input.slateEditor.apply = originalApply;\n      };\n    }),\n    \"mutation interval\": (0,xstate__WEBPACK_IMPORTED_MODULE_26__.fromCallback)(({\n      sendBack\n    }) => {\n      const interval = setInterval(() => {\n        sendBack({\n          type: \"emit changes\"\n        });\n      },  false ? 0 : 1e3);\n      return () => {\n        clearInterval(interval);\n      };\n    })\n  },\n  guards: {\n    \"is read-only\": ({\n      context\n    }) => context.readOnly,\n    \"slate is normalizing\": ({\n      context\n    }) => slate__WEBPACK_IMPORTED_MODULE_14__.Editor.isNormalizing(context.slateEditor)\n  },\n  delays: {\n    \"type debounce\": 250\n  }\n}).createMachine({\n  id: \"mutation\",\n  context: ({\n    input\n  }) => ({\n    pendingMutations: [],\n    pendingPatchEvents: [],\n    readOnly: input.readOnly,\n    schema: input.schema,\n    slateEditor: input.slateEditor\n  }),\n  on: {\n    \"update readOnly\": {\n      actions: [\"assign readOnly\"]\n    }\n  },\n  type: \"parallel\",\n  states: {\n    typing: {\n      initial: \"idle\",\n      invoke: {\n        src: \"type listener\",\n        input: ({\n          context\n        }) => ({\n          slateEditor: context.slateEditor\n        })\n      },\n      states: {\n        idle: {\n          entry: [() => {\n            debug$4(\"entry: typing->idle\");\n          }],\n          exit: [() => {\n            debug$4(\"exit: typing->idle\"), debug$4(\"entry: typing->typing\");\n          }],\n          on: {\n            typing: {\n              target: \"typing\"\n            }\n          }\n        },\n        typing: {\n          after: {\n            \"type debounce\": {\n              target: \"idle\",\n              actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_27__.r)({\n                type: \"emit changes\"\n              }), () => {\n                debug$4(\"exit: typing->typing\");\n              }]\n            }\n          },\n          on: {\n            \"not typing\": {\n              target: \"idle\",\n              actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_27__.r)({\n                type: \"emit changes\"\n              })]\n            },\n            typing: {\n              target: \"typing\",\n              reenter: !0\n            }\n          }\n        }\n      }\n    },\n    mutations: {\n      initial: \"idle\",\n      states: {\n        idle: {\n          entry: [() => {\n            debug$4(\"entry: mutations->idle\");\n          }],\n          exit: [() => {\n            debug$4(\"exit: mutations->idle\");\n          }],\n          on: {\n            patch: [{\n              guard: \"is read-only\",\n              actions: [\"defer patch\", \"defer mutation\"],\n              target: \"has pending mutations\"\n            }, {\n              actions: [\"emit patch\", \"defer mutation\"],\n              target: \"has pending mutations\"\n            }]\n          }\n        },\n        \"has pending mutations\": {\n          entry: [() => {\n            debug$4(\"entry: mutations->has pending mutations\");\n          }, \"emit has pending mutations\"],\n          exit: [() => {\n            debug$4(\"exit: mutations->has pending mutations\");\n          }],\n          invoke: {\n            src: \"mutation interval\"\n          },\n          on: {\n            \"emit changes\": {\n              guard: (0,xstate__WEBPACK_IMPORTED_MODULE_27__.d)([(0,xstate__WEBPACK_IMPORTED_MODULE_27__.n)(\"is read-only\"), \"slate is normalizing\"]),\n              target: \"idle\",\n              actions: [\"emit pending patch events\", \"clear pending patch events\", \"emit mutations\", \"clear pending mutations\"]\n            },\n            patch: [{\n              guard: \"is read-only\",\n              actions: [\"defer patch\", \"defer mutation\"]\n            }, {\n              actions: [\"emit patch\", \"defer mutation\"]\n            }]\n          }\n        }\n      }\n    }\n  }\n}), debug$3 = debugWithName(\"API:editable\");\nfunction createEditableAPI(editor, editorActor) {\n  const types = editorActor.getSnapshot().context.schema;\n  return {\n    focus: () => {\n      editorActor.send({\n        type: \"focus\",\n        editor\n      });\n    },\n    blur: () => {\n      editorActor.send({\n        type: \"blur\",\n        editor\n      });\n    },\n    toggleMark: (mark) => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"decorator.toggle\",\n          decorator: mark\n        },\n        editor\n      });\n    },\n    toggleList: (listItem) => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"list item.toggle\",\n          listItem\n        },\n        editor\n      });\n    },\n    toggleBlockStyle: (style) => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"style.toggle\",\n          style\n        },\n        editor\n      });\n    },\n    isMarkActive: (mark) => {\n      const snapshot = getEditorSnapshot({\n        editorActorSnapshot: editorActor.getSnapshot(),\n        slateEditorInstance: editor\n      });\n      return (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getActiveDecorators)(snapshot).includes(mark);\n    },\n    marks: () => {\n      const snapshot = getEditorSnapshot({\n        editorActorSnapshot: editorActor.getSnapshot(),\n        slateEditorInstance: editor\n      }), activeAnnotations = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getActiveAnnotationsMarks)(snapshot), activeDecorators = (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.getActiveDecorators)(snapshot);\n      return [...activeAnnotations, ...activeDecorators];\n    },\n    undo: () => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"history.undo\"\n        },\n        editor\n      });\n    },\n    redo: () => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"history.redo\"\n        },\n        editor\n      });\n    },\n    select: (selection) => {\n      const slateSelection = toSlateRange({\n        context: {\n          schema: editorActor.getSnapshot().context.schema,\n          value: editor.value,\n          selection\n        },\n        blockIndexMap: editor.blockIndexMap\n      });\n      slateSelection ? slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(editor, slateSelection) : slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.deselect(editor), editor.onChange();\n    },\n    focusBlock: () => {\n      if (editor.selection) {\n        const block = slate__WEBPACK_IMPORTED_MODULE_14__.Node.descendant(editor, editor.selection.focus.path.slice(0, 1));\n        if (block)\n          return fromSlateValue([block], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];\n      }\n    },\n    focusChild: () => {\n      if (editor.selection) {\n        const block = slate__WEBPACK_IMPORTED_MODULE_14__.Node.descendant(editor, editor.selection.focus.path.slice(0, 1));\n        if (block && editor.isTextBlock(block))\n          return fromSlateValue([block], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0].children[editor.selection.focus.path[1]];\n      }\n    },\n    insertChild: (type, value) => {\n      if (type.name !== types.span.name)\n        return editorActor.send({\n          type: \"behavior event\",\n          behaviorEvent: {\n            type: \"insert.inline object\",\n            inlineObject: {\n              name: type.name,\n              value\n            }\n          },\n          editor\n        }), editor.selection ? slateRangeToSelection({\n          schema: editorActor.getSnapshot().context.schema,\n          editor,\n          range: editor.selection\n        })?.focus.path ?? [] : [];\n      if (!editor.selection)\n        throw new Error(\"The editor has no selection\");\n      const [focusBlock] = Array.from(slate__WEBPACK_IMPORTED_MODULE_14__.Editor.nodes(editor, {\n        at: editor.selection.focus.path.slice(0, 1),\n        match: (n) => n._type === types.block.name\n      }))[0] || [void 0];\n      if (!focusBlock)\n        throw new Error(\"No focused text block\");\n      if (type.name !== types.span.name && !types.inlineObjects.some((t) => t.name === type.name))\n        throw new Error(\"This type cannot be inserted as a child to a text block\");\n      const child = toSlateValue([{\n        _key: editorActor.getSnapshot().context.keyGenerator(),\n        _type: types.block.name,\n        children: [{\n          _key: editorActor.getSnapshot().context.keyGenerator(),\n          _type: type.name,\n          ...value || {}\n        }]\n      }], {\n        schemaTypes: editorActor.getSnapshot().context.schema\n      })[0].children[0], focusChildPath = editor.selection.focus.path.slice(0, 2), isSpanNode2 = child._type === types.span.name, focusNode = slate__WEBPACK_IMPORTED_MODULE_14__.Node.get(editor, focusChildPath);\n      return isSpanNode2 && focusNode._type !== types.span.name && (debug$3(\"Inserting span child next to inline object child, moving selection + 1\"), editor.move({\n        distance: 1,\n        unit: \"character\"\n      })), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertNodes(editor, child, {\n        select: !0,\n        at: editor.selection\n      }), editor.onChange(), editor.selection ? slateRangeToSelection({\n        schema: editorActor.getSnapshot().context.schema,\n        editor,\n        range: editor.selection\n      })?.focus.path ?? [] : [];\n    },\n    insertBlock: (type, value) => (editorActor.send({\n      type: \"behavior event\",\n      behaviorEvent: {\n        type: \"insert.block\",\n        block: {\n          _type: type.name,\n          ...value || {}\n        },\n        placement: \"auto\"\n      },\n      editor\n    }), editor.selection ? slateRangeToSelection({\n      schema: editorActor.getSnapshot().context.schema,\n      editor,\n      range: editor.selection\n    })?.focus.path ?? [] : []),\n    hasBlockStyle: (style) => {\n      try {\n        return isStyleActive({\n          editor,\n          style\n        });\n      } catch {\n        return !1;\n      }\n    },\n    hasListStyle: (listItem) => {\n      try {\n        return isListItemActive({\n          editor,\n          listItem\n        });\n      } catch {\n        return !1;\n      }\n    },\n    isVoid: (element) => ![types.block.name, types.span.name].includes(element._type),\n    findByPath: (path) => {\n      const slatePath = toSlateRange({\n        context: {\n          schema: editorActor.getSnapshot().context.schema,\n          value: editor.value,\n          selection: {\n            focus: {\n              path,\n              offset: 0\n            },\n            anchor: {\n              path,\n              offset: 0\n            }\n          }\n        },\n        blockIndexMap: editor.blockIndexMap\n      });\n      if (slatePath) {\n        const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_14__.Editor.node(editor, slatePath.focus.path.slice(0, 1));\n        if (block && blockPath && typeof block._key == \"string\") {\n          if (path.length === 1 && slatePath.focus.path.length === 1)\n            return [fromSlateValue([block], types.block.name)[0], [{\n              _key: block._key\n            }]];\n          const ptBlock = fromSlateValue([block], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];\n          if (editor.isTextBlock(ptBlock)) {\n            const ptChild = ptBlock.children[slatePath.focus.path[1]];\n            if (ptChild)\n              return [ptChild, [{\n                _key: block._key\n              }, \"children\", {\n                _key: ptChild._key\n              }]];\n          }\n        }\n      }\n      return [void 0, void 0];\n    },\n    findDOMNode: (element) => {\n      let node;\n      try {\n        const [item] = Array.from(slate__WEBPACK_IMPORTED_MODULE_14__.Editor.nodes(editor, {\n          at: [],\n          match: (n) => n._key === element._key\n        }) || [])[0] || [void 0];\n        node = slate_react__WEBPACK_IMPORTED_MODULE_22__.ReactEditor.toDOMNode(editor, item);\n      } catch {\n      }\n      return node;\n    },\n    activeAnnotations: () => {\n      if (!editor.selection || editor.selection.focus.path.length < 2)\n        return [];\n      try {\n        const activeAnnotations = [], spans = slate__WEBPACK_IMPORTED_MODULE_14__.Editor.nodes(editor, {\n          at: editor.selection,\n          match: (node) => slate__WEBPACK_IMPORTED_MODULE_14__.Text.isText(node) && node.marks !== void 0 && Array.isArray(node.marks) && node.marks.length > 0\n        });\n        for (const [span, path] of spans) {\n          const [block] = slate__WEBPACK_IMPORTED_MODULE_14__.Editor.node(editor, path, {\n            depth: 1\n          });\n          editor.isTextBlock(block) && block.markDefs?.forEach((def) => {\n            slate__WEBPACK_IMPORTED_MODULE_14__.Text.isText(span) && span.marks && Array.isArray(span.marks) && span.marks.includes(def._key) && activeAnnotations.push(def);\n          });\n        }\n        return activeAnnotations;\n      } catch {\n        return [];\n      }\n    },\n    isAnnotationActive: (annotationType) => {\n      const snapshot = getEditorSnapshot({\n        editorActorSnapshot: editorActor.getSnapshot(),\n        slateEditorInstance: editor\n      });\n      return (0,_chunks_es_selector_is_active_style_js__WEBPACK_IMPORTED_MODULE_19__.isActiveAnnotation)(annotationType)(snapshot);\n    },\n    addAnnotation: (type, value) => {\n      const snapshotBefore = getEditorSnapshot({\n        editorActorSnapshot: editorActor.getSnapshot(),\n        slateEditorInstance: editor\n      }), selectedValueBefore = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getSelectedValue)(snapshotBefore), focusSpanBefore = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusSpan)(snapshotBefore), markDefsBefore = selectedValueBefore.flatMap((block) => (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(snapshotBefore.context, block) ? block.markDefs ?? [] : []);\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"annotation.add\",\n          annotation: {\n            name: type.name,\n            value: value ?? {}\n          }\n        },\n        editor\n      });\n      const snapshotAfter = getEditorSnapshot({\n        editorActorSnapshot: editorActor.getSnapshot(),\n        slateEditorInstance: editor\n      }), selectedValueAfter = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getSelectedValue)(snapshotAfter), focusBlockAfter = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusBlock)(snapshotAfter), focusSpanAfter = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_20__.getFocusSpan)(snapshotAfter), newMarkDefKeysOnFocusSpan = focusSpanAfter?.node.marks?.filter((mark) => !focusSpanBefore?.node.marks?.includes(mark) && !snapshotAfter.context.schema.decorators.map((decorator) => decorator.name).includes(mark)), markDefs = selectedValueAfter.flatMap((block) => (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(snapshotAfter.context, block) ? block.markDefs?.map((markDef2) => ({\n        markDef: markDef2,\n        path: [{\n          _key: block._key\n        }, \"markDefs\", {\n          _key: markDef2._key\n        }]\n      })) ?? [] : []).filter((markDef2) => !markDefsBefore.some((markDefBefore) => markDefBefore._key === markDef2.markDef._key)), spanPath = focusSpanAfter?.path, markDef = markDefs.find((markDef2) => newMarkDefKeysOnFocusSpan?.some((mark) => mark === markDef2.markDef._key));\n      if (focusBlockAfter && spanPath && markDef)\n        return {\n          markDefPath: markDef.path,\n          markDefPaths: markDefs.map((markDef2) => markDef2.path),\n          spanPath\n        };\n    },\n    delete: (selection, options) => {\n      if (selection) {\n        const range = toSlateRange({\n          context: {\n            schema: editorActor.getSnapshot().context.schema,\n            value: editor.value,\n            selection\n          },\n          blockIndexMap: editor.blockIndexMap\n        });\n        if (!(range && range.anchor.path.length > 0 && range.focus.path.length > 0))\n          throw new Error(\"Invalid range\");\n        if (range) {\n          if (!options?.mode || options?.mode === \"selected\") {\n            debug$3(\"Deleting content in selection\"), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.delete(editor, {\n              at: range,\n              hanging: !0,\n              voids: !0\n            }), editor.onChange();\n            return;\n          }\n          if (options?.mode === \"blocks\" && (debug$3(\"Deleting blocks touched by selection\"), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.removeNodes(editor, {\n            at: range,\n            voids: !0,\n            match: (node) => editor.isTextBlock(node) || !editor.isTextBlock(node) && slate__WEBPACK_IMPORTED_MODULE_14__.Element.isElement(node)\n          })), options?.mode === \"children\" && (debug$3(\"Deleting children touched by selection\"), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.removeNodes(editor, {\n            at: range,\n            voids: !0,\n            match: (node) => node._type === types.span.name || // Text children\n            !editor.isTextBlock(node) && slate__WEBPACK_IMPORTED_MODULE_14__.Element.isElement(node)\n          })), editor.children.length === 0) {\n            const placeholderBlock = createPlaceholderBlock(editorActor.getSnapshot().context);\n            editor.children = [placeholderBlock], editor.value = [placeholderBlock], buildIndexMaps({\n              schema: editorActor.getSnapshot().context.schema,\n              value: editor.value\n            }, {\n              blockIndexMap: editor.blockIndexMap,\n              listIndexMap: editor.listIndexMap\n            });\n          }\n          editor.onChange();\n        }\n      }\n    },\n    removeAnnotation: (type) => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"annotation.remove\",\n          annotation: {\n            name: type.name\n          }\n        },\n        editor\n      });\n    },\n    getSelection: () => {\n      let ptRange = null;\n      if (editor.selection) {\n        const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);\n        if (existing)\n          return existing;\n        ptRange = slateRangeToSelection({\n          schema: editorActor.getSnapshot().context.schema,\n          editor,\n          range: editor.selection\n        }), SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange);\n      }\n      return ptRange;\n    },\n    getValue: () => fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)),\n    isCollapsedSelection: () => !!editor.selection && slate__WEBPACK_IMPORTED_MODULE_14__.Range.isCollapsed(editor.selection),\n    isExpandedSelection: () => !!editor.selection && slate__WEBPACK_IMPORTED_MODULE_14__.Range.isExpanded(editor.selection),\n    insertBreak: () => {\n      editor.insertBreak(), editor.onChange();\n    },\n    getFragment: () => fromSlateValue(editor.getFragment(), types.block.name),\n    isSelectionsOverlapping: (selectionA, selectionB) => {\n      const rangeA = toSlateRange({\n        context: {\n          schema: editorActor.getSnapshot().context.schema,\n          value: editor.value,\n          selection: selectionA\n        },\n        blockIndexMap: editor.blockIndexMap\n      }), rangeB = toSlateRange({\n        context: {\n          schema: editorActor.getSnapshot().context.schema,\n          value: editor.value,\n          selection: selectionB\n        },\n        blockIndexMap: editor.blockIndexMap\n      });\n      return slate__WEBPACK_IMPORTED_MODULE_14__.Range.isRange(rangeA) && slate__WEBPACK_IMPORTED_MODULE_14__.Range.isRange(rangeB) && slate__WEBPACK_IMPORTED_MODULE_14__.Range.includes(rangeA, rangeB);\n    }\n  };\n}\nconst relayMachine = (0,xstate__WEBPACK_IMPORTED_MODULE_24__.setup)({\n  types: {\n    context: {},\n    events: {},\n    emitted: {}\n  }\n}).createMachine({\n  id: \"relay\",\n  context: {\n    prevSelection: null,\n    lastEventWasFocused: !1\n  },\n  on: {\n    focused: {\n      actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n        lastEventWasFocused: !0\n      }), (0,xstate__WEBPACK_IMPORTED_MODULE_36__.a)(({\n        event\n      }) => event)]\n    },\n    selection: [{\n      guard: ({\n        context\n      }) => context.lastEventWasFocused,\n      actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n        prevSelection: ({\n          event\n        }) => event.selection\n      }), (0,xstate__WEBPACK_IMPORTED_MODULE_36__.a)(({\n        event\n      }) => event), (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n        lastEventWasFocused: !1\n      })]\n    }, {\n      guard: ({\n        context,\n        event\n      }) => context.prevSelection !== event.selection,\n      actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n        prevSelection: ({\n          event\n        }) => event.selection\n      }), (0,xstate__WEBPACK_IMPORTED_MODULE_36__.a)(({\n        event\n      }) => event), (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n        lastEventWasFocused: !1\n      })]\n    }],\n    \"*\": {\n      actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_36__.a)(({\n        event\n      }) => event), (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n        lastEventWasFocused: !1\n      })]\n    }\n  }\n});\nfunction validateValue(value, types, keyGenerator) {\n  let resolution = null, valid = !0;\n  const validChildTypes = [types.span.name, ...types.inlineObjects.map((t) => t.name)], validBlockTypes = [types.block.name, ...types.blockObjects.map((t) => t.name)];\n  return value === void 0 ? {\n    valid: !0,\n    resolution: null,\n    value\n  } : !Array.isArray(value) || value.length === 0 ? {\n    valid: !1,\n    resolution: {\n      patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([])],\n      description: \"Editor value must be an array of Portable Text blocks, or undefined.\",\n      action: \"Unset the value\",\n      item: value,\n      i18n: {\n        description: \"inputs.portable-text.invalid-value.not-an-array.description\",\n        action: \"inputs.portable-text.invalid-value.not-an-array.action\"\n      }\n    },\n    value\n  } : (value.some((blk, index) => {\n    if (!lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_12__(blk))\n      return resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([index])],\n        description: `Block must be an object, got ${String(blk)}`,\n        action: \"Unset invalid item\",\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.not-an-object.description\",\n          action: \"inputs.portable-text.invalid-value.not-an-object.action\",\n          values: {\n            index\n          }\n        }\n      }, !0;\n    if (!blk._key || typeof blk._key != \"string\")\n      return resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.set)({\n          ...blk,\n          _key: keyGenerator()\n        }, [index])],\n        description: `Block at index ${index} is missing required _key.`,\n        action: \"Set the block with a random _key value\",\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.missing-key.description\",\n          action: \"inputs.portable-text.invalid-value.missing-key.action\",\n          values: {\n            index\n          }\n        }\n      }, !0;\n    if (!blk._type || !validBlockTypes.includes(blk._type)) {\n      if (blk._type === \"block\") {\n        const currentBlockTypeName = types.block.name;\n        return resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.set)({\n            ...blk,\n            _type: currentBlockTypeName\n          }, [{\n            _key: blk._key\n          }])],\n          description: `Block with _key '${blk._key}' has invalid type name '${blk._type}'. According to the schema, the block type name is '${currentBlockTypeName}'`,\n          action: `Use type '${currentBlockTypeName}'`,\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.incorrect-block-type.description\",\n            action: \"inputs.portable-text.invalid-value.incorrect-block-type.action\",\n            values: {\n              key: blk._key,\n              expectedTypeName: currentBlockTypeName\n            }\n          }\n        }, !0;\n      }\n      return !blk._type && (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)({\n        schema: types\n      }, {\n        ...blk,\n        _type: types.block.name\n      }) ? (resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.set)({\n          ...blk,\n          _type: types.block.name\n        }, [{\n          _key: blk._key\n        }])],\n        description: `Block with _key '${blk._key}' is missing a type name. According to the schema, the block type name is '${types.block.name}'`,\n        action: `Use type '${types.block.name}'`,\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.missing-block-type.description\",\n          action: \"inputs.portable-text.invalid-value.missing-block-type.action\",\n          values: {\n            key: blk._key,\n            expectedTypeName: types.block.name\n          }\n        }\n      }, !0) : blk._type ? (resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([{\n          _key: blk._key\n        }])],\n        description: `Block with _key '${blk._key}' has invalid _type '${blk._type}'`,\n        action: \"Remove the block\",\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.disallowed-type.description\",\n          action: \"inputs.portable-text.invalid-value.disallowed-type.action\",\n          values: {\n            key: blk._key,\n            typeName: blk._type\n          }\n        }\n      }, !0) : (resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([{\n          _key: blk._key\n        }])],\n        description: `Block with _key '${blk._key}' is missing an _type property`,\n        action: \"Remove the block\",\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.missing-type.description\",\n          action: \"inputs.portable-text.invalid-value.missing-type.action\",\n          values: {\n            key: blk._key\n          }\n        }\n      }, !0);\n    }\n    if (blk._type === types.block.name) {\n      const textBlock = blk;\n      if (textBlock.children && !Array.isArray(textBlock.children))\n        return resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.set)({\n            children: []\n          }, [{\n            _key: textBlock._key\n          }])],\n          description: `Text block with _key '${textBlock._key}' has a invalid required property 'children'.`,\n          action: \"Reset the children property\",\n          item: textBlock,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.missing-or-invalid-children.description\",\n            action: \"inputs.portable-text.invalid-value.missing-or-invalid-children.action\",\n            values: {\n              key: textBlock._key\n            }\n          }\n        }, !0;\n      if (textBlock.children === void 0 || Array.isArray(textBlock.children) && textBlock.children.length === 0) {\n        const newSpan = {\n          _type: types.span.name,\n          _key: keyGenerator(),\n          text: \"\",\n          marks: []\n        };\n        return resolution = {\n          autoResolve: !0,\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.setIfMissing)([], [{\n            _key: blk._key\n          }, \"children\"]), (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.insert)([newSpan], \"after\", [{\n            _key: blk._key\n          }, \"children\", 0])],\n          description: `Children for text block with _key '${blk._key}' is empty.`,\n          action: \"Insert an empty text\",\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.empty-children.description\",\n            action: \"inputs.portable-text.invalid-value.empty-children.action\",\n            values: {\n              key: blk._key\n            }\n          }\n        }, !0;\n      }\n      const allUsedMarks = lodash_uniq_js__WEBPACK_IMPORTED_MODULE_6__(lodash_flatten_js__WEBPACK_IMPORTED_MODULE_7__(textBlock.children.filter((cld) => cld._type === types.span.name).map((cld) => cld.marks || [])));\n      if (Array.isArray(blk.markDefs) && blk.markDefs.length > 0) {\n        const unusedMarkDefs = lodash_uniq_js__WEBPACK_IMPORTED_MODULE_6__(blk.markDefs.map((def) => def._key).filter((key) => !allUsedMarks.includes(key)));\n        if (unusedMarkDefs.length > 0)\n          return resolution = {\n            autoResolve: !0,\n            patches: unusedMarkDefs.map((markDefKey) => (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([{\n              _key: blk._key\n            }, \"markDefs\", {\n              _key: markDefKey\n            }])),\n            description: `Block contains orphaned data (unused mark definitions): ${unusedMarkDefs.join(\", \")}.`,\n            action: \"Remove unused mark definition item\",\n            item: blk,\n            i18n: {\n              description: \"inputs.portable-text.invalid-value.orphaned-mark-defs.description\",\n              action: \"inputs.portable-text.invalid-value.orphaned-mark-defs.action\",\n              values: {\n                key: blk._key,\n                unusedMarkDefs: unusedMarkDefs.map((m) => m.toString())\n              }\n            }\n          }, !0;\n      }\n      const orphanedMarks = allUsedMarks.filter((mark) => !types.decorators.map((dec) => dec.name).includes(mark)).filter((mark) => textBlock.markDefs === void 0 || !textBlock.markDefs.find((def) => def._key === mark));\n      if (orphanedMarks.length > 0) {\n        const spanChildren = textBlock.children.filter((cld) => cld._type === types.span.name && Array.isArray(cld.marks) && cld.marks.some((mark) => orphanedMarks.includes(mark)));\n        if (spanChildren) {\n          const orphaned = orphanedMarks.join(\", \");\n          return resolution = {\n            autoResolve: !0,\n            patches: spanChildren.map((child) => (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.set)((child.marks || []).filter((cMrk) => !orphanedMarks.includes(cMrk)), [{\n              _key: blk._key\n            }, \"children\", {\n              _key: child._key\n            }, \"marks\"])),\n            description: `Block with _key '${blk._key}' contains marks (${orphaned}) not supported by the current content model.`,\n            action: \"Remove invalid marks\",\n            item: blk,\n            i18n: {\n              description: \"inputs.portable-text.invalid-value.orphaned-marks.description\",\n              action: \"inputs.portable-text.invalid-value.orphaned-marks.action\",\n              values: {\n                key: blk._key,\n                orphanedMarks: orphanedMarks.map((m) => m.toString())\n              }\n            }\n          }, !0;\n        }\n      }\n      textBlock.children.some((child, cIndex) => {\n        if (!lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_12__(child))\n          return resolution = {\n            patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([{\n              _key: blk._key\n            }, \"children\", cIndex])],\n            description: `Child at index '${cIndex}' in block with key '${blk._key}' is not an object.`,\n            action: \"Remove the item\",\n            item: blk,\n            i18n: {\n              description: \"inputs.portable-text.invalid-value.non-object-child.description\",\n              action: \"inputs.portable-text.invalid-value.non-object-child.action\",\n              values: {\n                key: blk._key,\n                index: cIndex\n              }\n            }\n          }, !0;\n        if (!child._key || typeof child._key != \"string\") {\n          const newChild = {\n            ...child,\n            _key: keyGenerator()\n          };\n          return resolution = {\n            autoResolve: !0,\n            patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.set)(newChild, [{\n              _key: blk._key\n            }, \"children\", cIndex])],\n            description: `Child at index ${cIndex} is missing required _key in block with _key ${blk._key}.`,\n            action: \"Set a new random _key on the object\",\n            item: blk,\n            i18n: {\n              description: \"inputs.portable-text.invalid-value.missing-child-key.description\",\n              action: \"inputs.portable-text.invalid-value.missing-child-key.action\",\n              values: {\n                key: blk._key,\n                index: cIndex\n              }\n            }\n          }, !0;\n        }\n        return child._type ? validChildTypes.includes(child._type) ? child._type === types.span.name && typeof child.text != \"string\" ? (resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.set)({\n            ...child,\n            text: \"\"\n          }, [{\n            _key: blk._key\n          }, \"children\", {\n            _key: child._key\n          }])],\n          description: `Child with _key '${child._key}' in block with key '${blk._key}' has missing or invalid text property!`,\n          action: \"Write an empty text property to the object\",\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.invalid-span-text.description\",\n            action: \"inputs.portable-text.invalid-value.invalid-span-text.action\",\n            values: {\n              key: blk._key,\n              childKey: child._key\n            }\n          }\n        }, !0) : !1 : (resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([{\n            _key: blk._key\n          }, \"children\", {\n            _key: child._key\n          }])],\n          description: `Child with _key '${child._key}' in block with key '${blk._key}' has invalid '_type' property (${child._type}).`,\n          action: \"Remove the object\",\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.disallowed-child-type.description\",\n            action: \"inputs.portable-text.invalid-value.disallowed-child-type.action\",\n            values: {\n              key: blk._key,\n              childKey: child._key,\n              childType: child._type\n            }\n          }\n        }, !0) : (resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([{\n            _key: blk._key\n          }, \"children\", {\n            _key: child._key\n          }])],\n          description: `Child with _key '${child._key}' in block with key '${blk._key}' is missing '_type' property.`,\n          action: \"Remove the object\",\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.missing-child-type.description\",\n            action: \"inputs.portable-text.invalid-value.missing-child-type.action\",\n            values: {\n              key: blk._key,\n              childKey: child._key\n            }\n          }\n        }, !0);\n      }) && (valid = !1);\n    }\n    return !1;\n  }) && (valid = !1), {\n    valid,\n    resolution,\n    value\n  });\n}\nconst debug$2 = debugWithName(\"sync machine\"), syncValueCallback = ({\n  sendBack,\n  input\n}) => {\n  updateValue({\n    context: input.context,\n    sendBack,\n    slateEditor: input.slateEditor,\n    value: input.value,\n    streamBlocks: input.streamBlocks\n  });\n}, syncValueLogic = (0,xstate__WEBPACK_IMPORTED_MODULE_26__.fromCallback)(syncValueCallback), syncMachine = (0,xstate__WEBPACK_IMPORTED_MODULE_24__.setup)({\n  types: {\n    context: {},\n    input: {},\n    events: {},\n    emitted: {}\n  },\n  actions: {\n    \"assign initial value synced\": (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n      initialValueSynced: !0\n    }),\n    \"assign readOnly\": (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n      readOnly: ({\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_24__.assertEvent)(event, \"update readOnly\"), event.readOnly)\n    }),\n    \"assign pending value\": (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n      pendingValue: ({\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_24__.assertEvent)(event, \"update value\"), event.value)\n    }),\n    \"clear pending value\": (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n      pendingValue: void 0\n    }),\n    \"assign previous value\": (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n      previousValue: ({\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_24__.assertEvent)(event, \"done syncing\"), event.value)\n    }),\n    \"emit done syncing value\": (0,xstate__WEBPACK_IMPORTED_MODULE_36__.a)({\n      type: \"done syncing value\"\n    }),\n    \"emit syncing value\": (0,xstate__WEBPACK_IMPORTED_MODULE_36__.a)({\n      type: \"syncing value\"\n    })\n  },\n  guards: {\n    \"initial value synced\": ({\n      context\n    }) => context.initialValueSynced,\n    \"is busy\": ({\n      context\n    }) => {\n      const isProcessingLocalChanges = context.isProcessingLocalChanges, isChanging = isChangingRemotely(context.slateEditor) ?? !1, isBusy = isProcessingLocalChanges || isChanging;\n      return debug$2(\"isBusy\", {\n        isBusy,\n        isProcessingLocalChanges,\n        isChanging\n      }), isBusy;\n    },\n    \"is empty value\": ({\n      event\n    }) => event.type === \"update value\" && event.value === void 0,\n    \"is empty array\": ({\n      event\n    }) => event.type === \"update value\" && Array.isArray(event.value) && event.value.length === 0,\n    \"is new value\": ({\n      context,\n      event\n    }) => event.type === \"update value\" && context.previousValue !== event.value,\n    \"value changed while syncing\": ({\n      context,\n      event\n    }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_24__.assertEvent)(event, \"done syncing\"), context.pendingValue !== event.value),\n    \"pending value equals previous value\": ({\n      context\n    }) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__(context.pendingValue, context.previousValue)\n  },\n  actors: {\n    \"sync value\": syncValueLogic\n  }\n}).createMachine({\n  id: \"sync\",\n  context: ({\n    input\n  }) => ({\n    initialValue: input.initialValue,\n    initialValueSynced: !1,\n    isProcessingLocalChanges: !1,\n    keyGenerator: input.keyGenerator,\n    schema: input.schema,\n    readOnly: input.readOnly,\n    slateEditor: input.slateEditor,\n    pendingValue: void 0,\n    previousValue: void 0\n  }),\n  entry: [(0,xstate__WEBPACK_IMPORTED_MODULE_27__.r)(({\n    context\n  }) => ({\n    type: \"update value\",\n    value: context.initialValue\n  }))],\n  on: {\n    \"has pending mutations\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n        isProcessingLocalChanges: !0\n      })\n    },\n    mutation: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_25__.a)({\n        isProcessingLocalChanges: !1\n      })\n    },\n    \"update readOnly\": {\n      actions: [\"assign readOnly\"]\n    }\n  },\n  initial: \"idle\",\n  states: {\n    idle: {\n      entry: [() => {\n        debug$2(\"entry: syncing->idle\");\n      }],\n      exit: [() => {\n        debug$2(\"exit: syncing->idle\");\n      }],\n      on: {\n        \"update value\": [{\n          guard: (0,xstate__WEBPACK_IMPORTED_MODULE_27__.d)([\"is empty value\", (0,xstate__WEBPACK_IMPORTED_MODULE_27__.n)(\"initial value synced\")]),\n          actions: [\"assign initial value synced\", \"emit done syncing value\"]\n        }, {\n          guard: (0,xstate__WEBPACK_IMPORTED_MODULE_27__.d)([\"is empty array\", (0,xstate__WEBPACK_IMPORTED_MODULE_27__.n)(\"initial value synced\")]),\n          actions: [\"assign initial value synced\", (0,xstate__WEBPACK_IMPORTED_MODULE_36__.a)({\n            type: \"value changed\",\n            value: []\n          }), \"emit done syncing value\"]\n        }, {\n          guard: (0,xstate__WEBPACK_IMPORTED_MODULE_27__.d)([\"is busy\", \"is new value\"]),\n          target: \"busy\",\n          actions: [\"assign pending value\"]\n        }, {\n          guard: \"is new value\",\n          target: \"syncing\",\n          actions: [\"assign pending value\"]\n        }, {\n          guard: (0,xstate__WEBPACK_IMPORTED_MODULE_27__.n)(\"initial value synced\"),\n          actions: [() => {\n            debug$2(\"no new value \\u2013 setting initial value as synced\");\n          }, \"assign initial value synced\", \"emit done syncing value\"]\n        }, {\n          actions: [() => {\n            debug$2(\"no new value and initial value already synced\");\n          }]\n        }]\n      }\n    },\n    busy: {\n      entry: [() => {\n        debug$2(\"entry: syncing->busy\");\n      }],\n      exit: [() => {\n        debug$2(\"exit: syncing->busy\");\n      }],\n      after: {\n        1e3: [{\n          guard: \"is busy\",\n          target: \".\",\n          reenter: !0,\n          actions: [() => {\n            debug$2(\"reenter: syncing->busy\");\n          }]\n        }, {\n          target: \"syncing\"\n        }]\n      },\n      on: {\n        \"update value\": [{\n          guard: \"is new value\",\n          actions: [\"assign pending value\"]\n        }]\n      }\n    },\n    syncing: {\n      entry: [() => {\n        debug$2(\"entry: syncing->syncing\");\n      }, \"emit syncing value\"],\n      exit: [() => {\n        debug$2(\"exit: syncing->syncing\");\n      }, \"emit done syncing value\"],\n      invoke: {\n        src: \"sync value\",\n        id: \"sync value\",\n        input: ({\n          context\n        }) => ({\n          context: {\n            keyGenerator: context.keyGenerator,\n            previousValue: context.previousValue,\n            readOnly: context.readOnly,\n            schema: context.schema\n          },\n          slateEditor: context.slateEditor,\n          streamBlocks: !context.initialValueSynced,\n          value: context.pendingValue\n        })\n      },\n      on: {\n        \"update value\": {\n          guard: \"is new value\",\n          actions: [\"assign pending value\"]\n        },\n        patch: {\n          actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_36__.a)(({\n            event\n          }) => event)]\n        },\n        \"invalid value\": {\n          actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_36__.a)(({\n            event\n          }) => event)]\n        },\n        \"value changed\": {\n          actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_36__.a)(({\n            event\n          }) => event)]\n        },\n        \"done syncing\": [{\n          guard: \"value changed while syncing\",\n          actions: [\"assign previous value\", \"assign initial value synced\"],\n          target: \"syncing\",\n          reenter: !0\n        }, {\n          target: \"idle\",\n          actions: [\"clear pending value\", \"assign previous value\", \"assign initial value synced\"]\n        }]\n      }\n    }\n  }\n});\nasync function updateValue({\n  context,\n  sendBack,\n  slateEditor,\n  streamBlocks,\n  value\n}) {\n  let doneSyncing = !1, isChanged = !1, isValid = !0;\n  const hadSelection = !!slateEditor.selection;\n  if ((!value || value.length === 0) && (debug$2(\"Value is empty\"), slate__WEBPACK_IMPORTED_MODULE_14__.Editor.withoutNormalizing(slateEditor, () => {\n    withoutSaving(slateEditor, () => {\n      withRemoteChanges(slateEditor, () => {\n        withoutPatching(slateEditor, () => {\n          if (doneSyncing)\n            return;\n          hadSelection && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.deselect(slateEditor);\n          const childrenLength = slateEditor.children.length;\n          slateEditor.children.forEach((_, index) => {\n            slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.removeNodes(slateEditor, {\n              at: [childrenLength - 1 - index]\n            });\n          }), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertNodes(slateEditor, slateEditor.pteCreateTextBlock({\n            decorators: []\n          }), {\n            at: [0]\n          }), hadSelection && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(slateEditor, [0, 0]);\n        });\n      });\n    });\n  }), isChanged = !0), value && value.length > 0) {\n    const slateValueFromProps = toSlateValue(value, {\n      schemaTypes: context.schema\n    });\n    streamBlocks ? await new Promise((resolve) => {\n      slate__WEBPACK_IMPORTED_MODULE_14__.Editor.withoutNormalizing(slateEditor, () => {\n        withRemoteChanges(slateEditor, () => {\n          withoutPatching(slateEditor, () => {\n            if (doneSyncing) {\n              resolve();\n              return;\n            }\n            isChanged = removeExtraBlocks({\n              slateEditor,\n              slateValueFromProps\n            }), (async () => {\n              for await (const [currentBlock, currentBlockIndex] of getStreamedBlocks({\n                slateValue: slateValueFromProps\n              })) {\n                const {\n                  blockChanged,\n                  blockValid\n                } = syncBlock({\n                  context,\n                  sendBack,\n                  block: currentBlock,\n                  index: currentBlockIndex,\n                  slateEditor,\n                  value\n                });\n                if (isChanged = blockChanged || isChanged, isValid = isValid && blockValid, !isValid)\n                  break;\n              }\n              resolve();\n            })();\n          });\n        });\n      });\n    }) : slate__WEBPACK_IMPORTED_MODULE_14__.Editor.withoutNormalizing(slateEditor, () => {\n      withRemoteChanges(slateEditor, () => {\n        withoutPatching(slateEditor, () => {\n          if (doneSyncing)\n            return;\n          isChanged = removeExtraBlocks({\n            slateEditor,\n            slateValueFromProps\n          });\n          let index = 0;\n          for (const currentBlock of slateValueFromProps) {\n            const {\n              blockChanged,\n              blockValid\n            } = syncBlock({\n              context,\n              sendBack,\n              block: currentBlock,\n              index,\n              slateEditor,\n              value\n            });\n            if (isChanged = blockChanged || isChanged, isValid = isValid && blockValid, !blockValid)\n              break;\n            index++;\n          }\n        });\n      });\n    });\n  }\n  if (!isValid) {\n    debug$2(\"Invalid value, returning\"), doneSyncing = !0, sendBack({\n      type: \"done syncing\",\n      value\n    });\n    return;\n  }\n  if (isChanged) {\n    debug$2(\"Server value changed, syncing editor\");\n    try {\n      slateEditor.onChange();\n    } catch (err) {\n      console.error(err), sendBack({\n        type: \"invalid value\",\n        resolution: null,\n        value\n      }), doneSyncing = !0, sendBack({\n        type: \"done syncing\",\n        value\n      });\n      return;\n    }\n    hadSelection && !slateEditor.selection && (slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(slateEditor, {\n      anchor: {\n        path: [0, 0],\n        offset: 0\n      },\n      focus: {\n        path: [0, 0],\n        offset: 0\n      }\n    }), slateEditor.onChange()), sendBack({\n      type: \"value changed\",\n      value\n    });\n  } else\n    debug$2(\"Server value and editor value is equal, no need to sync.\");\n  doneSyncing = !0, sendBack({\n    type: \"done syncing\",\n    value\n  });\n}\nfunction removeExtraBlocks({\n  slateEditor,\n  slateValueFromProps\n}) {\n  let isChanged = !1;\n  const childrenLength = slateEditor.children.length;\n  if (slateValueFromProps.length < childrenLength) {\n    for (let i = childrenLength - 1; i > slateValueFromProps.length - 1; i--)\n      slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.removeNodes(slateEditor, {\n        at: [i]\n      });\n    isChanged = !0;\n  }\n  return isChanged;\n}\nasync function* getStreamedBlocks({\n  slateValue\n}) {\n  let index = 0;\n  for await (const block of slateValue)\n    index % 10 === 0 && await new Promise((resolve) => setTimeout(resolve, 0)), yield [block, index], index++;\n}\nfunction syncBlock({\n  context,\n  sendBack,\n  block,\n  index,\n  slateEditor,\n  value\n}) {\n  let blockChanged = !1, blockValid = !0;\n  const currentBlock = block, currentBlockIndex = index, oldBlock = slateEditor.children[currentBlockIndex], hasChanges = oldBlock && !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__(currentBlock, oldBlock);\n  return slate__WEBPACK_IMPORTED_MODULE_14__.Editor.withoutNormalizing(slateEditor, () => {\n    withRemoteChanges(slateEditor, () => {\n      withoutPatching(slateEditor, () => {\n        if (hasChanges && blockValid) {\n          const validationValue = [value[currentBlockIndex]], validation = validateValue(validationValue, context.schema, context.keyGenerator);\n          !validation.valid && validation.resolution?.autoResolve && validation.resolution?.patches.length > 0 && !context.readOnly && context.previousValue && context.previousValue !== value && (console.warn(`${validation.resolution.action} for block with _key '${validationValue[0]._key}'. ${validation.resolution?.description}`), validation.resolution.patches.forEach((patch) => {\n            sendBack({\n              type: \"patch\",\n              patch\n            });\n          })), validation.valid || validation.resolution?.autoResolve ? (oldBlock._key === currentBlock._key ? (debug$2.enabled && debug$2(\"Updating block\", oldBlock, currentBlock), _updateBlock(slateEditor, currentBlock, oldBlock, currentBlockIndex)) : (debug$2.enabled && debug$2(\"Replacing block\", oldBlock, currentBlock), _replaceBlock(slateEditor, currentBlock, currentBlockIndex)), blockChanged = !0) : (sendBack({\n            type: \"invalid value\",\n            resolution: validation.resolution,\n            value\n          }), blockValid = !1);\n        }\n        if (!oldBlock && blockValid) {\n          const validationValue = [value[currentBlockIndex]], validation = validateValue(validationValue, context.schema, context.keyGenerator);\n          debug$2.enabled && debug$2(\"Validating and inserting new block in the end of the value\", currentBlock), validation.valid || validation.resolution?.autoResolve ? slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertNodes(slateEditor, currentBlock, {\n            at: [currentBlockIndex]\n          }) : (debug$2(\"Invalid\", validation), sendBack({\n            type: \"invalid value\",\n            resolution: validation.resolution,\n            value\n          }), blockValid = !1);\n        }\n      });\n    });\n  }), {\n    blockChanged,\n    blockValid\n  };\n}\nfunction _replaceBlock(slateEditor, currentBlock, currentBlockIndex) {\n  const currentSelection = slateEditor.selection, selectionFocusOnBlock = currentSelection && currentSelection.focus.path[0] === currentBlockIndex;\n  selectionFocusOnBlock && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.deselect(slateEditor), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.removeNodes(slateEditor, {\n    at: [currentBlockIndex]\n  }), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertNodes(slateEditor, currentBlock, {\n    at: [currentBlockIndex]\n  }), slateEditor.onChange(), selectionFocusOnBlock && slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.select(slateEditor, currentSelection);\n}\nfunction _updateBlock(slateEditor, currentBlock, oldBlock, currentBlockIndex) {\n  if (slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(slateEditor, currentBlock, {\n    at: [currentBlockIndex]\n  }), slateEditor.isTextBlock(currentBlock) && slateEditor.isTextBlock(oldBlock)) {\n    const oldBlockChildrenLength = oldBlock.children.length;\n    currentBlock.children.length < oldBlockChildrenLength && Array.from(Array(oldBlockChildrenLength - currentBlock.children.length)).forEach((_, index) => {\n      const childIndex = oldBlockChildrenLength - 1 - index;\n      childIndex > 0 && (debug$2(\"Removing child\"), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.removeNodes(slateEditor, {\n        at: [currentBlockIndex, childIndex]\n      }));\n    }), currentBlock.children.forEach((currentBlockChild, currentBlockChildIndex) => {\n      const oldBlockChild = oldBlock.children[currentBlockChildIndex], isChildChanged = !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__(currentBlockChild, oldBlockChild), isTextChanged = !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__(currentBlockChild.text, oldBlockChild?.text), path = [currentBlockIndex, currentBlockChildIndex];\n      if (isChildChanged)\n        if (currentBlockChild._key === oldBlockChild?._key) {\n          debug$2(\"Updating changed child\", currentBlockChild, oldBlockChild), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(slateEditor, currentBlockChild, {\n            at: path\n          });\n          const isSpanNode2 = slate__WEBPACK_IMPORTED_MODULE_14__.Text.isText(currentBlockChild) && currentBlockChild._type === \"span\" && slate__WEBPACK_IMPORTED_MODULE_14__.Text.isText(oldBlockChild) && oldBlockChild._type === \"span\";\n          isSpanNode2 && isTextChanged ? (oldBlockChild.text.length > 0 && (0,slate__WEBPACK_IMPORTED_MODULE_14__.deleteText)(slateEditor, {\n            at: {\n              focus: {\n                path,\n                offset: 0\n              },\n              anchor: {\n                path,\n                offset: oldBlockChild.text.length\n              }\n            }\n          }), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertText(slateEditor, currentBlockChild.text, {\n            at: path\n          }), slateEditor.onChange()) : isSpanNode2 || (debug$2(\"Updating changed inline object child\", currentBlockChild), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.setNodes(slateEditor, {\n            _key: VOID_CHILD_KEY\n          }, {\n            at: [...path, 0],\n            voids: !0\n          }));\n        } else oldBlockChild ? (debug$2(\"Replacing child\", currentBlockChild), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.removeNodes(slateEditor, {\n          at: [currentBlockIndex, currentBlockChildIndex]\n        }), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertNodes(slateEditor, currentBlockChild, {\n          at: [currentBlockIndex, currentBlockChildIndex]\n        }), slateEditor.onChange()) : oldBlockChild || (debug$2(\"Inserting new child\", currentBlockChild), slate__WEBPACK_IMPORTED_MODULE_14__.Transforms.insertNodes(slateEditor, currentBlockChild, {\n          at: [currentBlockIndex, currentBlockChildIndex]\n        }), slateEditor.onChange());\n    });\n  }\n}\nconst debug$1 = debugWithName(\"setup\");\nfunction createInternalEditor(config) {\n  debug$1(\"Creating new Editor instance\");\n  const subscriptions = [], editorActor = (0,xstate__WEBPACK_IMPORTED_MODULE_27__.c)(editorMachine, {\n    input: editorConfigToMachineInput(config)\n  }), relayActor = (0,xstate__WEBPACK_IMPORTED_MODULE_27__.c)(relayMachine), slateEditor = createSlateEditor({\n    editorActor,\n    relayActor,\n    subscriptions\n  }), editable = createEditableAPI(slateEditor.instance, editorActor), {\n    mutationActor,\n    syncActor\n  } = createActors({\n    editorActor,\n    relayActor,\n    slateEditor: slateEditor.instance,\n    subscriptions\n  }), editor = {\n    dom: createEditorDom((event) => editorActor.send(event), slateEditor.instance),\n    getSnapshot: () => getEditorSnapshot({\n      editorActorSnapshot: editorActor.getSnapshot(),\n      slateEditorInstance: slateEditor.instance\n    }),\n    registerBehavior: (behaviorConfig) => {\n      const priority = createEditorPriority({\n        name: \"custom\",\n        reference: {\n          priority: corePriority,\n          importance: \"higher\"\n        }\n      }), behaviorConfigWithPriority = {\n        ...behaviorConfig,\n        priority\n      };\n      return editorActor.send({\n        type: \"add behavior\",\n        behaviorConfig: behaviorConfigWithPriority\n      }), () => {\n        editorActor.send({\n          type: \"remove behavior\",\n          behaviorConfig: behaviorConfigWithPriority\n        });\n      };\n    },\n    send: (event) => {\n      switch (event.type) {\n        case \"update value\":\n          syncActor.send(event);\n          break;\n        case \"update readOnly\":\n        case \"patches\":\n        case \"update maxBlocks\":\n          editorActor.send(event);\n          break;\n        default:\n          editorActor.send(rerouteExternalBehaviorEvent({\n            event,\n            slateEditor: slateEditor.instance\n          }));\n      }\n    },\n    on: (event, listener) => relayActor.on(event, (event2) => {\n      switch (event2.type) {\n        case \"blurred\":\n        case \"done loading\":\n        case \"editable\":\n        case \"focused\":\n        case \"invalid value\":\n        case \"loading\":\n        case \"mutation\":\n        case \"patch\":\n        case \"read only\":\n        case \"ready\":\n        case \"selection\":\n        case \"value changed\":\n          listener(event2);\n          break;\n      }\n    }),\n    _internal: {\n      editable,\n      editorActor,\n      slateEditor\n    }\n  };\n  return {\n    actors: {\n      editorActor,\n      mutationActor,\n      relayActor,\n      syncActor\n    },\n    editor,\n    subscriptions\n  };\n}\nfunction editorConfigToMachineInput(config) {\n  const {\n    legacySchema,\n    schema\n  } = compileSchemasFromEditorConfig(config);\n  return {\n    converters: createCoreConverters(legacySchema),\n    getLegacySchema: () => legacySchema,\n    keyGenerator: config.keyGenerator ?? _chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_15__.defaultKeyGenerator,\n    maxBlocks: config.maxBlocks,\n    readOnly: config.readOnly,\n    schema,\n    initialValue: config.initialValue\n  };\n}\nfunction compileSchemasFromEditorConfig(config) {\n  const legacySchema = config.schemaDefinition ? (0,_portabletext_sanity_bridge__WEBPACK_IMPORTED_MODULE_37__.compileSchemaDefinitionToPortableTextMemberSchemaTypes)(config.schemaDefinition) : (0,_portabletext_sanity_bridge__WEBPACK_IMPORTED_MODULE_37__.createPortableTextMemberSchemaTypes)(config.schema.hasOwnProperty(\"jsonType\") ? config.schema : compileType(config.schema)), schema = config.schemaDefinition ? (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_18__.compileSchema)(config.schemaDefinition) : (0,_portabletext_sanity_bridge__WEBPACK_IMPORTED_MODULE_37__.portableTextMemberSchemaTypesToSchema)(legacySchema);\n  return {\n    legacySchema,\n    schema\n  };\n}\nfunction createActors(config) {\n  debug$1(\"Creating new Actors\");\n  const mutationActor = (0,xstate__WEBPACK_IMPORTED_MODULE_27__.c)(mutationMachine, {\n    input: {\n      readOnly: config.editorActor.getSnapshot().matches({\n        \"edit mode\": \"read only\"\n      }),\n      schema: config.editorActor.getSnapshot().context.schema,\n      slateEditor: config.slateEditor\n    }\n  }), syncActor = (0,xstate__WEBPACK_IMPORTED_MODULE_27__.c)(syncMachine, {\n    input: {\n      initialValue: config.editorActor.getSnapshot().context.initialValue,\n      keyGenerator: config.editorActor.getSnapshot().context.keyGenerator,\n      readOnly: config.editorActor.getSnapshot().matches({\n        \"edit mode\": \"read only\"\n      }),\n      schema: config.editorActor.getSnapshot().context.schema,\n      slateEditor: config.slateEditor\n    }\n  });\n  return config.subscriptions.push(() => {\n    const subscription = mutationActor.on(\"*\", (event) => {\n      event.type === \"has pending mutations\" && syncActor.send({\n        type: \"has pending mutations\"\n      }), event.type === \"mutation\" && (syncActor.send({\n        type: \"mutation\"\n      }), config.editorActor.send({\n        type: \"mutation\",\n        patches: event.patches,\n        snapshot: event.snapshot,\n        value: event.snapshot\n      })), event.type === \"patch\" && config.relayActor.send(event);\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }), config.subscriptions.push(() => {\n    const subscription = syncActor.on(\"*\", (event) => {\n      switch (event.type) {\n        case \"invalid value\":\n          config.relayActor.send(event);\n          break;\n        case \"value changed\":\n          config.relayActor.send(event);\n          break;\n        case \"patch\":\n          config.editorActor.send({\n            ...event,\n            type: \"internal.patch\",\n            value: fromSlateValue(config.slateEditor.children, config.editorActor.getSnapshot().context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(config.slateEditor))\n          });\n          break;\n        default:\n          config.editorActor.send(event);\n      }\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }), config.subscriptions.push(() => {\n    const subscription = config.editorActor.subscribe((snapshot) => {\n      snapshot.matches({\n        \"edit mode\": \"read only\"\n      }) ? (mutationActor.send({\n        type: \"update readOnly\",\n        readOnly: !0\n      }), syncActor.send({\n        type: \"update readOnly\",\n        readOnly: !0\n      })) : (mutationActor.send({\n        type: \"update readOnly\",\n        readOnly: !1\n      }), syncActor.send({\n        type: \"update readOnly\",\n        readOnly: !1\n      }));\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }), config.subscriptions.push(() => {\n    const subscription = config.editorActor.on(\"*\", (event) => {\n      switch (event.type) {\n        case \"editable\":\n        case \"mutation\":\n        case \"ready\":\n        case \"read only\":\n        case \"selection\":\n          config.relayActor.send(event);\n          break;\n        case \"internal.patch\":\n          mutationActor.send({\n            ...event,\n            type: \"patch\"\n          });\n          break;\n      }\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }), {\n    mutationActor,\n    syncActor\n  };\n}\nfunction eventToChange(event) {\n  switch (event.type) {\n    case \"blurred\":\n      return {\n        type: \"blur\",\n        event: event.event\n      };\n    case \"patch\":\n      return event;\n    case \"loading\":\n      return {\n        type: \"loading\",\n        isLoading: !0\n      };\n    case \"done loading\":\n      return {\n        type: \"loading\",\n        isLoading: !1\n      };\n    case \"focused\":\n      return {\n        type: \"focus\",\n        event: event.event\n      };\n    case \"value changed\":\n      return {\n        type: \"value\",\n        value: event.value\n      };\n    case \"invalid value\":\n      return {\n        type: \"invalidValue\",\n        resolution: event.resolution,\n        value: event.value\n      };\n    case \"mutation\":\n      return event;\n    case \"ready\":\n      return event;\n    case \"selection\":\n      return event;\n    case \"unset\":\n      return event;\n  }\n}\nconst debug = debugWithName(\"component:PortableTextEditor\");\nclass PortableTextEditor extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n  static displayName = \"PortableTextEditor\";\n  /**\n   * An observable of all the editor changes.\n   */\n  change$ = new rxjs__WEBPACK_IMPORTED_MODULE_38__.Subject();\n  /**\n   * A lookup table for all the relevant schema types for this portable text type.\n   */\n  /**\n   * The editor instance\n   */\n  /*\n   * The editor API (currently implemented with Slate).\n   */\n  subscriptions = [];\n  unsubscribers = [];\n  constructor(props) {\n    if (super(props), props.editor)\n      this.editor = props.editor, this.schemaTypes = this.editor._internal.editorActor.getSnapshot().context.getLegacySchema();\n    else {\n      const {\n        actors,\n        editor,\n        subscriptions\n      } = createInternalEditor({\n        initialValue: props.value,\n        keyGenerator: props.keyGenerator,\n        maxBlocks: props.maxBlocks === void 0 ? void 0 : Number.parseInt(props.maxBlocks.toString(), 10),\n        readOnly: props.readOnly,\n        schema: props.schemaType\n      });\n      this.subscriptions = subscriptions, this.actors = actors, this.editor = editor, this.schemaTypes = actors.editorActor.getSnapshot().context.getLegacySchema();\n    }\n    this.editable = this.editor._internal.editable;\n  }\n  componentDidMount() {\n    if (!this.actors)\n      return;\n    for (const subscription of this.subscriptions)\n      this.unsubscribers.push(subscription());\n    const relayActorSubscription = this.actors.relayActor.on(\"*\", (event) => {\n      const change = eventToChange(event);\n      change && (this.props.editor || this.props.onChange(change), this.change$.next(change));\n    });\n    this.unsubscribers.push(relayActorSubscription.unsubscribe), this.actors.editorActor.start(), this.actors.mutationActor.start(), this.actors.relayActor.start(), this.actors.syncActor.start();\n  }\n  componentDidUpdate(prevProps) {\n    !this.props.editor && !prevProps.editor && this.props.schemaType !== prevProps.schemaType && console.warn(\"Updating schema type is no longer supported\"), !this.props.editor && !prevProps.editor && (this.props.readOnly !== prevProps.readOnly && this.editor._internal.editorActor.send({\n      type: \"update readOnly\",\n      readOnly: this.props.readOnly ?? !1\n    }), this.props.maxBlocks !== prevProps.maxBlocks && this.editor._internal.editorActor.send({\n      type: \"update maxBlocks\",\n      maxBlocks: this.props.maxBlocks === void 0 ? void 0 : Number.parseInt(this.props.maxBlocks.toString(), 10)\n    }), this.props.value !== prevProps.value && this.editor.send({\n      type: \"update value\",\n      value: this.props.value\n    }), this.props.editorRef !== prevProps.editorRef && this.props.editorRef && (this.props.editorRef.current = this));\n  }\n  componentWillUnmount() {\n    for (const unsubscribe of this.unsubscribers)\n      unsubscribe();\n    this.actors && (stopActor(this.actors.editorActor), stopActor(this.actors.mutationActor), stopActor(this.actors.relayActor), stopActor(this.actors.syncActor));\n  }\n  setEditable = (editable) => {\n    this.editor._internal.editable = {\n      ...this.editor._internal.editable,\n      ...editable\n    };\n  };\n  render() {\n    const legacyPatches = this.props.editor ? void 0 : this.props.incomingPatches$ ?? this.props.patches$;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [\n      legacyPatches ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RoutePatchesObservableToEditorActor, { editorActor: this.editor._internal.editorActor, patches$: legacyPatches }) : null,\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(EditorActorContext.Provider, { value: this.editor._internal.editorActor, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RelayActorContext.Provider, { value: this.actors.relayActor, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(slate_react__WEBPACK_IMPORTED_MODULE_22__.Slate, { editor: this.editor._internal.slateEditor.instance, initialValue: this.editor._internal.slateEditor.initialValue, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PortableTextEditorContext.Provider, { value: this, children: this.props.children }) }) }) })\n    ] });\n  }\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isActive = useEditorSelector(editor, selectors.getActiveAnnotations)\n   * ```\n   */\n  static activeAnnotations = (editor) => editor && editor.editable ? editor.editable.activeAnnotations() : [];\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isActive = useEditorSelector(editor, selectors.isActiveAnnotation(...))\n   * ```\n   */\n  static isAnnotationActive = (editor, annotationType) => editor && editor.editable ? editor.editable.isAnnotationActive(annotationType) : !1;\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'annotation.add',\n   *  annotation: {\n   *    name: '...',\n   *    value: {...},\n   *  }\n   * })\n   * ```\n   */\n  static addAnnotation = (editor, type, value) => editor.editable?.addAnnotation(type, value);\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'blur',\n   * })\n   * ```\n   */\n  static blur = (editor) => {\n    debug(\"Host blurred\"), editor.editable?.blur();\n  };\n  static delete = (editor, selection, options) => editor.editable?.delete(selection, options);\n  static findDOMNode = (editor, element) => editor.editable?.findDOMNode(element);\n  static findByPath = (editor, path) => editor.editable?.findByPath(path) || [];\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'focus',\n   * })\n   * ```\n   */\n  static focus = (editor) => {\n    debug(\"Host requesting focus\"), editor.editable?.focus();\n  };\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const focusBlock = useEditorSelector(editor, selectors.getFocusBlock)\n   * ```\n   */\n  static focusBlock = (editor) => editor.editable?.focusBlock();\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const focusChild = useEditorSelector(editor, selectors.getFocusChild)\n   * ```\n   */\n  static focusChild = (editor) => editor.editable?.focusChild();\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const selection = useEditorSelector(editor, selectors.getSelection)\n   * ```\n   */\n  static getSelection = (editor) => editor.editable ? editor.editable.getSelection() : null;\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const value = useEditorSelector(editor, selectors.getValue)\n   * ```\n   */\n  static getValue = (editor) => editor.editable?.getValue();\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isActive = useEditorSelector(editor, selectors.isActiveStyle(...))\n   * ```\n   */\n  static hasBlockStyle = (editor, blockStyle) => editor.editable?.hasBlockStyle(blockStyle);\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isActive = useEditorSelector(editor, selectors.isActiveListItem(...))\n   * ```\n   */\n  static hasListStyle = (editor, listStyle) => editor.editable?.hasListStyle(listStyle);\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isSelectionCollapsed = useEditorSelector(editor, selectors.isSelectionCollapsed)\n   * ```\n   */\n  static isCollapsedSelection = (editor) => editor.editable?.isCollapsedSelection();\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isSelectionExpanded = useEditorSelector(editor, selectors.isSelectionExpanded)\n   * ```\n   */\n  static isExpandedSelection = (editor) => editor.editable?.isExpandedSelection();\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isActive = useEditorSelector(editor, selectors.isActiveDecorator(...))\n   * ```\n   */\n  static isMarkActive = (editor, mark) => editor.editable?.isMarkActive(mark);\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'insert.span',\n   *  text: '...',\n   *  annotations: [{name: '...', value: {...}}],\n   *  decorators: ['...'],\n   * })\n   * editor.send({\n   *  type: 'insert.inline object',\n   *  inlineObject: {\n   *    name: '...',\n   *    value: {...},\n   *  },\n   * })\n   * ```\n   */\n  static insertChild = (editor, type, value) => (debug(\"Host inserting child\"), editor.editable?.insertChild(type, value));\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'insert.block object',\n   *  blockObject: {\n   *    name: '...',\n   *    value: {...},\n   *  },\n   *  placement: 'auto' | 'after' | 'before',\n   * })\n   * ```\n   */\n  static insertBlock = (editor, type, value) => editor.editable?.insertBlock(type, value);\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'insert.break',\n   * })\n   * ```\n   */\n  static insertBreak = (editor) => editor.editable?.insertBreak();\n  static isVoid = (editor, element) => editor.editable?.isVoid(element);\n  static isObjectPath = (_editor, path) => {\n    if (!path || !Array.isArray(path)) return !1;\n    const isChildObjectEditPath = path.length > 3 && path[1] === \"children\";\n    return path.length > 1 && path[1] !== \"children\" || isChildObjectEditPath;\n  };\n  static marks = (editor) => editor.editable?.marks();\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'select',\n   *  selection: {...},\n   * })\n   * ```\n   */\n  static select = (editor, selection) => {\n    debug(\"Host setting selection\", selection), editor.editable?.select(selection);\n  };\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'annotation.remove',\n   *  annotation: {\n   *    name: '...',\n   *  },\n   * })\n   * ```\n   */\n  static removeAnnotation = (editor, type) => editor.editable?.removeAnnotation(type);\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'style.toggle',\n   *  style: '...',\n   * })\n   * ```\n   */\n  static toggleBlockStyle = (editor, blockStyle) => (debug(\"Host is toggling block style\"), editor.editable?.toggleBlockStyle(blockStyle));\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'list item.toggle',\n   *  listItem: '...',\n   * })\n   * ```\n   */\n  static toggleList = (editor, listStyle) => editor.editable?.toggleList(listStyle);\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'decorator.toggle',\n   *  decorator: '...',\n   * })\n   * ```\n   */\n  static toggleMark = (editor, mark) => {\n    debug(\"Host toggling mark\", mark), editor.editable?.toggleMark(mark);\n  };\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const selectedSlice = useEditorSelector(editor, selectors.getSelectedSlice)\n   * ```\n   */\n  static getFragment = (editor) => editor.editable?.getFragment();\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *   type: 'history.undo',\n   * })\n   * ```\n   */\n  static undo = (editor) => {\n    debug(\"Host undoing\"), editor.editable?.undo();\n  };\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *   type: 'history.redo',\n   * })\n   * ```\n   */\n  static redo = (editor) => {\n    debug(\"Host redoing\"), editor.editable?.redo();\n  };\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isOverlapping = useEditorSelector(editor, selectors.isOverlappingSelection(selectionB))\n   * ```\n   */\n  static isSelectionsOverlapping = (editor, selectionA, selectionB) => editor.editable?.isSelectionsOverlapping(selectionA, selectionB);\n}\nfunction RoutePatchesObservableToEditorActor(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(4);\n  let t0, t1;\n  return $[0] !== props.editorActor || $[1] !== props.patches$ ? (t0 = () => {\n    const subscription = props.patches$.subscribe((payload) => {\n      props.editorActor.send({\n        type: \"patches\",\n        ...payload\n      });\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, t1 = [props.editorActor, props.patches$], $[0] = props.editorActor, $[1] = props.patches$, $[2] = t0, $[3] = t1) : (t0 = $[2], t1 = $[3]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(t0, t1), null;\n}\nfunction EditorProvider(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(28);\n  let t0;\n  $[0] !== props.initialConfig ? (t0 = () => {\n    const internalEditor = createInternalEditor(props.initialConfig), portableTextEditor = new PortableTextEditor({\n      editor: internalEditor.editor\n    });\n    return {\n      internalEditor,\n      portableTextEditor\n    };\n  }, $[0] = props.initialConfig, $[1] = t0) : t0 = $[1];\n  const [t1] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(t0), {\n    internalEditor: internalEditor_0,\n    portableTextEditor: portableTextEditor_0\n  } = t1;\n  let t2;\n  $[2] !== internalEditor_0.actors.editorActor || $[3] !== internalEditor_0.actors.mutationActor || $[4] !== internalEditor_0.actors.relayActor || $[5] !== internalEditor_0.actors.syncActor || $[6] !== internalEditor_0.subscriptions || $[7] !== portableTextEditor_0 ? (t2 = () => {\n    const unsubscribers = [];\n    for (const subscription of internalEditor_0.subscriptions)\n      unsubscribers.push(subscription());\n    const relayActorSubscription = internalEditor_0.actors.relayActor.on(\"*\", (event) => {\n      const change = eventToChange(event);\n      change && portableTextEditor_0.change$.next(change);\n    });\n    return unsubscribers.push(relayActorSubscription.unsubscribe), internalEditor_0.actors.editorActor.start(), internalEditor_0.actors.mutationActor.start(), internalEditor_0.actors.relayActor.start(), internalEditor_0.actors.syncActor.start(), () => {\n      for (const unsubscribe of unsubscribers)\n        unsubscribe();\n      stopActor(internalEditor_0.actors.editorActor), stopActor(internalEditor_0.actors.mutationActor), stopActor(internalEditor_0.actors.relayActor), stopActor(internalEditor_0.actors.syncActor);\n    };\n  }, $[2] = internalEditor_0.actors.editorActor, $[3] = internalEditor_0.actors.mutationActor, $[4] = internalEditor_0.actors.relayActor, $[5] = internalEditor_0.actors.syncActor, $[6] = internalEditor_0.subscriptions, $[7] = portableTextEditor_0, $[8] = t2) : t2 = $[8];\n  let t3;\n  $[9] !== internalEditor_0 || $[10] !== portableTextEditor_0 ? (t3 = [internalEditor_0, portableTextEditor_0], $[9] = internalEditor_0, $[10] = portableTextEditor_0, $[11] = t3) : t3 = $[11], (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(t2, t3);\n  let t4;\n  $[12] !== portableTextEditor_0 || $[13] !== props.children ? (t4 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PortableTextEditorContext.Provider, { value: portableTextEditor_0, children: props.children }), $[12] = portableTextEditor_0, $[13] = props.children, $[14] = t4) : t4 = $[14];\n  let t5;\n  $[15] !== internalEditor_0.editor._internal.slateEditor.initialValue || $[16] !== internalEditor_0.editor._internal.slateEditor.instance || $[17] !== t4 ? (t5 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(slate_react__WEBPACK_IMPORTED_MODULE_22__.Slate, { editor: internalEditor_0.editor._internal.slateEditor.instance, initialValue: internalEditor_0.editor._internal.slateEditor.initialValue, children: t4 }), $[15] = internalEditor_0.editor._internal.slateEditor.initialValue, $[16] = internalEditor_0.editor._internal.slateEditor.instance, $[17] = t4, $[18] = t5) : t5 = $[18];\n  let t6;\n  $[19] !== internalEditor_0.actors.relayActor || $[20] !== t5 ? (t6 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RelayActorContext.Provider, { value: internalEditor_0.actors.relayActor, children: t5 }), $[19] = internalEditor_0.actors.relayActor, $[20] = t5, $[21] = t6) : t6 = $[21];\n  let t7;\n  $[22] !== internalEditor_0.actors.editorActor || $[23] !== t6 ? (t7 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(EditorActorContext.Provider, { value: internalEditor_0.actors.editorActor, children: t6 }), $[22] = internalEditor_0.actors.editorActor, $[23] = t6, $[24] = t7) : t7 = $[24];\n  let t8;\n  return $[25] !== internalEditor_0.editor || $[26] !== t7 ? (t8 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_chunks_es_use_editor_js__WEBPACK_IMPORTED_MODULE_13__.EditorContext.Provider, { value: internalEditor_0.editor, children: t7 }), $[25] = internalEditor_0.editor, $[26] = t7, $[27] = t8) : t8 = $[27], t8;\n}\nconst usePortableTextEditorSelection = () => {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(3), editorActor = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(EditorActorContext), [selection, setSelection2] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  let t0, t1;\n  return $[0] !== editorActor ? (t0 = () => {\n    const subscription = editorActor.on(\"selection\", (event) => {\n      (0,react__WEBPACK_IMPORTED_MODULE_1__.startTransition)(() => {\n        setSelection2(event.selection);\n      });\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, t1 = [editorActor], $[0] = editorActor, $[1] = t0, $[2] = t1) : (t0 = $[1], t1 = $[2]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(t0, t1), selection;\n};\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTJDO0FBQzRFO0FBQ2pEO0FBQ2Q7QUFDQztBQUN2QjtBQUNrSDtBQUNyQjtBQUNuRztBQUM0RTtBQUNvQztBQUMwTztBQUM5VTtBQUNrQztBQUN0QjtBQUNxb0I7QUFDMVg7QUFDalA7QUFDNUM7QUFDK0Y7QUFDZ0Q7QUFDeEg7QUFDVjtBQUNQO0FBQ0E7QUFDTjtBQUNxRjtBQUNsQjtBQUNEO0FBQ3BFO0FBQ2dCO0FBQ1Y7QUFDVztBQUNvRTtBQUNqRTtBQUNyQjtBQUMvQjtBQUNBLFlBQVkseURBQUMsY0FBYyxvRUFBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDJHQUEyRyxnREFBUztBQUN2SDtBQUNBO0FBQ0Esa0NBQU87QUFDUDtBQUNBLHVCQUF1QixTQUFTLEVBQUUsS0FBSztBQUN2QyxTQUFTLGtDQUFPLElBQUksMENBQWUsY0FBYyxrQ0FBTyxjQUFjLGtDQUFPO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhDQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLENBQUMsYUFBYTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLDhGQUE4RiwyQ0FBUztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0ws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QUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMENBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FB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QWdFLHdDQUFJO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGdIQUFnSDtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxD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QUFHLGVBQWUsMENBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDRDQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBDQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1REFBSSxDQUFDLHVEQUFRLElBQUk7QUFDNUMsc0NBQXNDLHNEQUFHLHdDQUF3Qyx5RUFBeUU7QUFDMUosc0JBQXNCLHNEQUFHLGdDQUFnQyxvRUFBb0Usc0RBQUcsK0JBQStCLHlEQUF5RCxzREFBRyxDQUFDLCtDQUFLLElBQUksNElBQTRJLHNEQUFHLHVDQUF1Qyw0Q0FBNEMsR0FBRyxHQUFHLEdBQUc7QUFDaGQsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixJQUFJO0FBQ3BCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUIsS0FBSztBQUMvQztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixJQUFJO0FBQ3BCLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsSUFBSTtBQUNwQixPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsSUFBSTtBQUN0QixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBQztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRyw2SUFBNkksZ0RBQVM7QUFDeko7QUFDQTtBQUNBLFlBQVkseURBQUM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxlQUFlLCtDQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaU1BQWlNLGdEQUFTO0FBQzFNO0FBQ0EscUZBQXFGLHNEQUFHLHVDQUF1Qyx1REFBdUQ7QUFDdEw7QUFDQSxtTEFBbUwsc0RBQUcsQ0FBQywrQ0FBSyxJQUFJLHdKQUF3SjtBQUN4VjtBQUNBLHVGQUF1RixzREFBRywrQkFBK0IseURBQXlEO0FBQ2xMO0FBQ0Esd0ZBQXdGLHNEQUFHLGdDQUFnQywwREFBMEQ7QUFDckw7QUFDQSxtRkFBbUYsc0RBQUcsQ0FBQyxvRUFBYSxhQUFhLDhDQUE4QztBQUMvSjtBQUNBO0FBQ0EsWUFBWSx5REFBQyxtQkFBbUIsaURBQVUsbURBQW1ELCtDQUFRO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLE1BQU0sc0RBQWU7QUFDckI7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMEZBQTBGLGdEQUFTO0FBQ3RHO0FBWUU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL0dhbG9jay9DUy9iZWhvbWUtc2l0ZS9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGMgfSBmcm9tIFwicmVhY3QtY29tcGlsZXItcnVudGltZVwiO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgdXNlUmVmLCBmb3J3YXJkUmVmLCBDb21wb25lbnQsIHN0YXJ0VHJhbnNpdGlvbiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlRWRpdG9yLCBFZGl0b3JDb250ZXh0IH0gZnJvbSBcIi4vX2NodW5rcy1lcy91c2UtZWRpdG9yLmpzXCI7XG5pbXBvcnQgeyBqc3gsIGpzeHMsIEZyYWdtZW50IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgeyB1c2VTZWxlY3RvciwgdXNlQWN0b3JSZWYgfSBmcm9tIFwiQHhzdGF0ZS9yZWFjdFwiO1xuaW1wb3J0IG5vb3AgZnJvbSBcImxvZGFzaC9ub29wLmpzXCI7XG5pbXBvcnQgeyBFbGVtZW50IGFzIEVsZW1lbnQkMSwgVGV4dCwgUmFuZ2UsIEVkaXRvciwgTm9kZSwgUG9pbnQsIFBhdGgsIFRyYW5zZm9ybXMsIE9wZXJhdGlvbiwgZGVsZXRlVGV4dCwgc2V0U2VsZWN0aW9uLCBjcmVhdGVFZGl0b3IgfSBmcm9tIFwic2xhdGVcIjtcbmltcG9ydCB7IHVzZVNlbGVjdGVkLCB1c2VTbGF0ZVNlbGVjdG9yLCB1c2VTbGF0ZVN0YXRpYywgUmVhY3RFZGl0b3IsIHVzZVNsYXRlLCBFZGl0YWJsZSwgd2l0aFJlYWN0LCBTbGF0ZSB9IGZyb20gXCJzbGF0ZS1yZWFjdFwiO1xuaW1wb3J0IGRlYnVnJGcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgeyBET01FZGl0b3IsIGlzRE9NTm9kZSwgRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLCBJU19GT0NVU0VELCBJU19SRUFEX09OTFkgfSBmcm9tIFwic2xhdGUtZG9tXCI7XG5pbXBvcnQgeyBnZXRCbG9ja0VuZFBvaW50LCBpc1NlbGVjdGlvbkNvbGxhcHNlZCwgaXNFcXVhbFNlbGVjdGlvblBvaW50cywgaXNFbXB0eVRleHRCbG9jayB9IGZyb20gXCIuL19jaHVua3MtZXMvdXRpbC5pcy1lbXB0eS10ZXh0LWJsb2NrLmpzXCI7XG5pbXBvcnQgeyBnZXRCbG9ja1N0YXJ0UG9pbnQsIGdldEJsb2NrS2V5RnJvbVNlbGVjdGlvblBvaW50LCBnZXRDaGlsZEtleUZyb21TZWxlY3Rpb25Qb2ludCwgYmxvY2tPZmZzZXRUb1NwYW5TZWxlY3Rpb25Qb2ludCwgZGVmYXVsdEtleUdlbmVyYXRvciwgcGFyc2VCbG9ja3MsIHBhcnNlQmxvY2ssIHBhcnNlQW5ub3RhdGlvbiwgcGFyc2VTcGFuLCBwYXJzZUlubGluZU9iamVjdCwgaXNLZXllZFNlZ21lbnQsIGlzTGlzdEJsb2NrLCBpc1R5cGVkT2JqZWN0LCBnZXRTZWxlY3Rpb25TdGFydFBvaW50LCBnZXRTZWxlY3Rpb25FbmRQb2ludCwgZ2V0VGV4dEJsb2NrVGV4dCB9IGZyb20gXCIuL19jaHVua3MtZXMvdXRpbC5nZXQtdGV4dC1ibG9jay10ZXh0LmpzXCI7XG5pbXBvcnQgaXNFcXVhbCBmcm9tIFwibG9kYXNoL2lzRXF1YWwuanNcIjtcbmltcG9ydCB7IGlzVGV4dEJsb2NrLCBpc1NwYW4sIGNvbXBpbGVTY2hlbWEgfSBmcm9tIFwiQHBvcnRhYmxldGV4dC9zY2hlbWFcIjtcbmltcG9ydCB7IGRlZmluZVNjaGVtYSB9IGZyb20gXCJAcG9ydGFibGV0ZXh0L3NjaGVtYVwiO1xuaW1wb3J0IHsgZ2V0Rm9jdXNJbmxpbmVPYmplY3QsIGdldFNlbGVjdGVkQmxvY2tzLCBnZXRTZWxlY3Rpb25TdGFydEJsb2NrIGFzIGdldFNlbGVjdGlvblN0YXJ0QmxvY2skMSwgZ2V0U2VsZWN0aW9uRW5kQmxvY2sgYXMgZ2V0U2VsZWN0aW9uRW5kQmxvY2skMSwgaXNPdmVybGFwcGluZ1NlbGVjdGlvbiwgaXNTZWxlY3RpbmdFbnRpcmVCbG9ja3MsIGdldEFjdGl2ZURlY29yYXRvcnMsIGdldFRyaW1tZWRTZWxlY3Rpb24sIGlzQWN0aXZlQW5ub3RhdGlvbiwgZ2V0Q2FyZXRXb3JkU2VsZWN0aW9uLCBnZXRGb2N1c0Jsb2NrT2JqZWN0LCBnZXRQcmV2aW91c0Jsb2NrLCBnZXROZXh0QmxvY2ssIGdldE1hcmtTdGF0ZSwgZ2V0QWN0aXZlQW5ub3RhdGlvbnNNYXJrcywgaXNBdFRoZUVuZE9mQmxvY2ssIGlzQXRUaGVTdGFydE9mQmxvY2ssIGdldEZpcnN0QmxvY2sgYXMgZ2V0Rmlyc3RCbG9jayQxLCBnZXRMYXN0QmxvY2sgYXMgZ2V0TGFzdEJsb2NrJDEsIGdldEZvY3VzTGlzdEJsb2NrLCBnZXRTZWxlY3Rpb25FbmRQb2ludCBhcyBnZXRTZWxlY3Rpb25FbmRQb2ludCQxLCBpc0FjdGl2ZURlY29yYXRvciwgZ2V0QWN0aXZlQW5ub3RhdGlvbnMsIGdldFNlbGVjdGVkVGV4dEJsb2NrcywgaXNBY3RpdmVMaXN0SXRlbSwgaXNBY3RpdmVTdHlsZSB9IGZyb20gXCIuL19jaHVua3MtZXMvc2VsZWN0b3IuaXMtYWN0aXZlLXN0eWxlLmpzXCI7XG5pbXBvcnQgeyBpc1NlbGVjdGlvbkNvbGxhcHNlZCBhcyBpc1NlbGVjdGlvbkNvbGxhcHNlZCQxLCBnZXRGb2N1c1RleHRCbG9jaywgZ2V0Rm9jdXNTcGFuIGFzIGdldEZvY3VzU3BhbiQxLCBpc1NlbGVjdGlvbkV4cGFuZGVkLCBnZXRGb2N1c0Jsb2NrIGFzIGdldEZvY3VzQmxvY2skMSwgZ2V0U2VsZWN0ZWRWYWx1ZSwgZ2V0U2VsZWN0aW9uU3RhcnRQb2ludCBhcyBnZXRTZWxlY3Rpb25TdGFydFBvaW50JDEsIGdldEZvY3VzQ2hpbGQgYXMgZ2V0Rm9jdXNDaGlsZCQxIH0gZnJvbSBcIi4vX2NodW5rcy1lcy9zZWxlY3Rvci5nZXQtc2VsZWN0aW9uLXRleHQuanNcIjtcbmltcG9ydCB7IGRlZmluZUJlaGF2aW9yLCBmb3J3YXJkLCByYWlzZSwgZWZmZWN0IH0gZnJvbSBcIi4vYmVoYXZpb3JzL2luZGV4LmpzXCI7XG5pbXBvcnQgdW5pcSBmcm9tIFwibG9kYXNoL3VuaXEuanNcIjtcbmltcG9ydCB7IHNldHVwLCBmcm9tQ2FsbGJhY2ssIGFzc2lnbiwgYW5kLCBlbnF1ZXVlQWN0aW9ucywgZW1pdCwgYXNzZXJ0RXZlbnQsIHJhaXNlIGFzIHJhaXNlJDEsIG5vdCwgY3JlYXRlQWN0b3IgfSBmcm9tIFwieHN0YXRlXCI7XG5pbXBvcnQgeyBjb21waWxlU2NoZW1hRGVmaW5pdGlvblRvUG9ydGFibGVUZXh0TWVtYmVyU2NoZW1hVHlwZXMsIGNyZWF0ZVBvcnRhYmxlVGV4dE1lbWJlclNjaGVtYVR5cGVzLCBwb3J0YWJsZVRleHRNZW1iZXJTY2hlbWFUeXBlc1RvU2NoZW1hIH0gZnJvbSBcIkBwb3J0YWJsZXRleHQvc2FuaXR5LWJyaWRnZVwiO1xuaW1wb3J0IHsgaHRtbFRvQmxvY2tzIH0gZnJvbSBcIkBwb3J0YWJsZXRleHQvYmxvY2stdG9vbHNcIjtcbmltcG9ydCB7IHRvSFRNTCB9IGZyb20gXCJAcG9ydGFibGV0ZXh0L3RvLWh0bWxcIjtcbmltcG9ydCB7IFNjaGVtYSB9IGZyb20gXCJAc2FuaXR5L3NjaGVtYVwiO1xuaW1wb3J0IGZsYXR0ZW4gZnJvbSBcImxvZGFzaC9mbGF0dGVuLmpzXCI7XG5pbXBvcnQgb21pdCBmcm9tIFwibG9kYXNoL29taXQuanNcIjtcbmltcG9ydCB7IGFwcGx5QWxsLCB1bnNldCwgaW5zZXJ0LCBzZXQsIHNldElmTWlzc2luZywgZGlmZk1hdGNoUGF0Y2ggYXMgZGlmZk1hdGNoUGF0Y2gkMSB9IGZyb20gXCJAcG9ydGFibGV0ZXh0L3BhdGNoZXNcIjtcbmltcG9ydCB7IGJsb2NrT2Zmc2V0c1RvU2VsZWN0aW9uIH0gZnJvbSBcIi4vX2NodW5rcy1lcy91dGlsLmNoaWxkLXNlbGVjdGlvbi1wb2ludC10by1ibG9jay1vZmZzZXQuanNcIjtcbmltcG9ydCB7IHNlbGVjdGlvblBvaW50VG9CbG9ja09mZnNldCwgc2xpY2VUZXh0QmxvY2sgfSBmcm9tIFwiLi9fY2h1bmtzLWVzL3V0aWwuc2xpY2UtdGV4dC1ibG9jay5qc1wiO1xuaW1wb3J0IGdldCBmcm9tIFwibG9kYXNoL2dldC5qc1wiO1xuaW1wb3J0IGlzVW5kZWZpbmVkIGZyb20gXCJsb2Rhc2gvaXNVbmRlZmluZWQuanNcIjtcbmltcG9ydCBvbWl0QnkgZnJvbSBcImxvZGFzaC9vbWl0QnkuanNcIjtcbmltcG9ydCB7IGNyZWF0ZURyYWZ0LCBmaW5pc2hEcmFmdCB9IGZyb20gXCJpbW1lclwiO1xuaW1wb3J0IHsgY3JlYXRlS2V5Ym9hcmRTaG9ydGN1dCwgY29kZSwgdW5kZXJsaW5lLCBpdGFsaWMsIGJvbGQsIHVuZG8sIHJlZG8gfSBmcm9tIFwiQHBvcnRhYmxldGV4dC9rZXlib2FyZC1zaG9ydGN1dHNcIjtcbmltcG9ydCBpc1BsYWluT2JqZWN0IGZyb20gXCJsb2Rhc2gvaXNQbGFpbk9iamVjdC5qc1wiO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gXCJyeGpzXCI7XG5mdW5jdGlvbiBFZGl0b3JFdmVudExpc3RlbmVyKHByb3BzKSB7XG4gIGNvbnN0ICQgPSBjKDQpLCBlZGl0b3IgPSB1c2VFZGl0b3IoKTtcbiAgbGV0IHQwLCB0MTtcbiAgcmV0dXJuICRbMF0gIT09IGVkaXRvciB8fCAkWzFdICE9PSBwcm9wcy5vbiA/ICh0MCA9ICgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBlZGl0b3Iub24oXCIqXCIsIHByb3BzLm9uKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSwgdDEgPSBbZWRpdG9yLCBwcm9wcy5vbl0sICRbMF0gPSBlZGl0b3IsICRbMV0gPSBwcm9wcy5vbiwgJFsyXSA9IHQwLCAkWzNdID0gdDEpIDogKHQwID0gJFsyXSwgdDEgPSAkWzNdKSwgdXNlRWZmZWN0KHQwLCB0MSksIG51bGw7XG59XG5jb25zdCByb290TmFtZSA9IFwic2FuaXR5LXB0ZTpcIjtcbmRlYnVnJGcocm9vdE5hbWUpO1xuZnVuY3Rpb24gZGVidWdXaXRoTmFtZShuYW1lKSB7XG4gIGNvbnN0IG5hbWVzcGFjZSA9IGAke3Jvb3ROYW1lfSR7bmFtZX1gO1xuICByZXR1cm4gZGVidWckZyAmJiBkZWJ1ZyRnLmVuYWJsZWQobmFtZXNwYWNlKSA/IGRlYnVnJGcobmFtZXNwYWNlKSA6IGRlYnVnJGcocm9vdE5hbWUpO1xufVxuY29uc3QgVk9JRF9DSElMRF9LRVkgPSBcInZvaWQtY2hpbGRcIjtcbmZ1bmN0aW9uIGtlZXBPYmplY3RFcXVhbGl0eShvYmplY3QsIGtleU1hcCkge1xuICBjb25zdCB2YWx1ZSA9IGtleU1hcFtvYmplY3QuX2tleV07XG4gIHJldHVybiB2YWx1ZSAmJiBpc0VxdWFsKG9iamVjdCwgdmFsdWUpID8gdmFsdWUgOiAoa2V5TWFwW29iamVjdC5fa2V5XSA9IG9iamVjdCwgb2JqZWN0KTtcbn1cbmZ1bmN0aW9uIHRvU2xhdGVWYWx1ZSh2YWx1ZSwge1xuICBzY2hlbWFUeXBlc1xufSwga2V5TWFwID0ge30pIHtcbiAgcmV0dXJuIHZhbHVlICYmIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKChibG9jaykgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIF90eXBlLFxuICAgICAgX2tleSxcbiAgICAgIC4uLnJlc3RcbiAgICB9ID0gYmxvY2s7XG4gICAgaWYgKGJsb2NrICYmIGJsb2NrLl90eXBlID09PSBzY2hlbWFUeXBlcy5ibG9jay5uYW1lKSB7XG4gICAgICBjb25zdCB0ZXh0QmxvY2sgPSBibG9jaztcbiAgICAgIGxldCBoYXNJbmxpbmVzID0gITE7XG4gICAgICBjb25zdCBoYXNNaXNzaW5nU3R5bGUgPSB0eXBlb2YgdGV4dEJsb2NrLnN0eWxlID4gXCJ1XCIsIGhhc01pc3NpbmdNYXJrRGVmcyA9IHR5cGVvZiB0ZXh0QmxvY2subWFya0RlZnMgPiBcInVcIiwgaGFzTWlzc2luZ0NoaWxkcmVuID0gdHlwZW9mIHRleHRCbG9jay5jaGlsZHJlbiA+IFwidVwiLCBjaGlsZHJlbiA9ICh0ZXh0QmxvY2suY2hpbGRyZW4gfHwgW10pLm1hcCgoY2hpbGQpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIF90eXBlOiBjVHlwZSxcbiAgICAgICAgICBfa2V5OiBjS2V5LFxuICAgICAgICAgIC4uLmNSZXN0XG4gICAgICAgIH0gPSBjaGlsZDtcbiAgICAgICAgcmV0dXJuIGNUeXBlICE9PSBcInNwYW5cIiA/IChoYXNJbmxpbmVzID0gITAsIGtlZXBPYmplY3RFcXVhbGl0eSh7XG4gICAgICAgICAgX3R5cGU6IGNUeXBlLFxuICAgICAgICAgIF9rZXk6IGNLZXksXG4gICAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgICBfa2V5OiBWT0lEX0NISUxEX0tFWSxcbiAgICAgICAgICAgIF90eXBlOiBcInNwYW5cIixcbiAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICBtYXJrczogW11cbiAgICAgICAgICB9XSxcbiAgICAgICAgICB2YWx1ZTogY1Jlc3QsXG4gICAgICAgICAgX19pbmxpbmU6ICEwXG4gICAgICAgIH0sIGtleU1hcCkpIDogY2hpbGQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAhaGFzTWlzc2luZ1N0eWxlICYmICFoYXNNaXNzaW5nTWFya0RlZnMgJiYgIWhhc01pc3NpbmdDaGlsZHJlbiAmJiAhaGFzSW5saW5lcyAmJiBFbGVtZW50JDEuaXNFbGVtZW50KGJsb2NrKSA/IGJsb2NrIDogKGhhc01pc3NpbmdTdHlsZSAmJiAocmVzdC5zdHlsZSA9IHNjaGVtYVR5cGVzLnN0eWxlc1swXS5uYW1lKSwga2VlcE9iamVjdEVxdWFsaXR5KHtcbiAgICAgICAgX3R5cGUsXG4gICAgICAgIF9rZXksXG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICB9LCBrZXlNYXApKTtcbiAgICB9XG4gICAgcmV0dXJuIGtlZXBPYmplY3RFcXVhbGl0eSh7XG4gICAgICBfdHlwZSxcbiAgICAgIF9rZXksXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgX2tleTogVk9JRF9DSElMRF9LRVksXG4gICAgICAgIF90eXBlOiBcInNwYW5cIixcbiAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgbWFya3M6IFtdXG4gICAgICB9XSxcbiAgICAgIHZhbHVlOiByZXN0XG4gICAgfSwga2V5TWFwKTtcbiAgfSkgOiBbXTtcbn1cbmZ1bmN0aW9uIGZyb21TbGF0ZVZhbHVlKHZhbHVlLCB0ZXh0QmxvY2tUeXBlLCBrZXlNYXAgPSB7fSkge1xuICByZXR1cm4gdmFsdWUubWFwKChibG9jaykgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIF9rZXksXG4gICAgICBfdHlwZVxuICAgIH0gPSBibG9jaztcbiAgICBpZiAoIV9rZXkgfHwgIV90eXBlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGEgdmFsaWQgYmxvY2tcIik7XG4gICAgaWYgKF90eXBlID09PSB0ZXh0QmxvY2tUeXBlICYmIFwiY2hpbGRyZW5cIiBpbiBibG9jayAmJiBBcnJheS5pc0FycmF5KGJsb2NrLmNoaWxkcmVuKSAmJiBfa2V5KSB7XG4gICAgICBsZXQgaGFzSW5saW5lcyA9ICExO1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBibG9jay5jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBfdHlwZTogX2NUeXBlXG4gICAgICAgIH0gPSBjaGlsZDtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBjaGlsZCAmJiBfY1R5cGUgIT09IFwic3BhblwiKSB7XG4gICAgICAgICAgaGFzSW5saW5lcyA9ICEwO1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHZhbHVlOiB2LFxuICAgICAgICAgICAgX2tleTogayxcbiAgICAgICAgICAgIF90eXBlOiB0LFxuICAgICAgICAgICAgX19pbmxpbmU6IF9pLFxuICAgICAgICAgICAgY2hpbGRyZW46IF9jLFxuICAgICAgICAgICAgLi4ucmVzdFxuICAgICAgICAgIH0gPSBjaGlsZDtcbiAgICAgICAgICByZXR1cm4ga2VlcE9iamVjdEVxdWFsaXR5KHtcbiAgICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgICAuLi52LFxuICAgICAgICAgICAgX2tleTogayxcbiAgICAgICAgICAgIF90eXBlOiB0XG4gICAgICAgICAgfSwga2V5TWFwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBoYXNJbmxpbmVzID8ga2VlcE9iamVjdEVxdWFsaXR5KHtcbiAgICAgICAgLi4uYmxvY2ssXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBfa2V5LFxuICAgICAgICBfdHlwZVxuICAgICAgfSwga2V5TWFwKSA6IGJsb2NrO1xuICAgIH1cbiAgICBjb25zdCBibG9ja1ZhbHVlID0gXCJ2YWx1ZVwiIGluIGJsb2NrICYmIGJsb2NrLnZhbHVlO1xuICAgIHJldHVybiBrZWVwT2JqZWN0RXF1YWxpdHkoe1xuICAgICAgX2tleSxcbiAgICAgIF90eXBlLFxuICAgICAgLi4udHlwZW9mIGJsb2NrVmFsdWUgPT0gXCJvYmplY3RcIiA/IGJsb2NrVmFsdWUgOiB7fVxuICAgIH0sIGtleU1hcCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNFcXVhbFRvRW1wdHlFZGl0b3IoY2hpbGRyZW4sIHNjaGVtYVR5cGVzKSB7XG4gIHJldHVybiBjaGlsZHJlbiA9PT0gdm9pZCAwIHx8IGNoaWxkcmVuICYmIEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBjaGlsZHJlbiAmJiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgRWxlbWVudCQxLmlzRWxlbWVudChjaGlsZHJlblswXSkgJiYgY2hpbGRyZW5bMF0uX3R5cGUgPT09IHNjaGVtYVR5cGVzLmJsb2NrLm5hbWUgJiYgXCJzdHlsZVwiIGluIGNoaWxkcmVuWzBdICYmIGNoaWxkcmVuWzBdLnN0eWxlID09PSBzY2hlbWFUeXBlcy5zdHlsZXNbMF0ubmFtZSAmJiAhKFwibGlzdEl0ZW1cIiBpbiBjaGlsZHJlblswXSkgJiYgQXJyYXkuaXNBcnJheShjaGlsZHJlblswXS5jaGlsZHJlbikgJiYgY2hpbGRyZW5bMF0uY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIFRleHQuaXNUZXh0KGNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdKSAmJiBjaGlsZHJlblswXS5jaGlsZHJlblswXS5fdHlwZSA9PT0gXCJzcGFuXCIgJiYgIWNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLm1hcmtzPy5qb2luKFwiXCIpICYmIGNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLnRleHQgPT09IFwiXCI7XG59XG5mdW5jdGlvbiBnZXRGb2N1c0Jsb2NrKHtcbiAgZWRpdG9yXG59KSB7XG4gIGlmICghZWRpdG9yLnNlbGVjdGlvbilcbiAgICByZXR1cm4gW3ZvaWQgMCwgdm9pZCAwXTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gRWRpdG9yLm5vZGUoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGguc2xpY2UoMCwgMSkpID8/IFt2b2lkIDAsIHZvaWQgMF07XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBbdm9pZCAwLCB2b2lkIDBdO1xuICB9XG59XG5mdW5jdGlvbiBnZXRGb2N1c1NwYW4oe1xuICBlZGl0b3Jcbn0pIHtcbiAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uKVxuICAgIHJldHVybiBbdm9pZCAwLCB2b2lkIDBdO1xuICB0cnkge1xuICAgIGNvbnN0IFtmb2N1c0Jsb2NrXSA9IGdldEZvY3VzQmxvY2soe1xuICAgICAgZWRpdG9yXG4gICAgfSk7XG4gICAgaWYgKCFmb2N1c0Jsb2NrKVxuICAgICAgcmV0dXJuIFt2b2lkIDAsIHZvaWQgMF07XG4gICAgaWYgKCFlZGl0b3IuaXNUZXh0QmxvY2soZm9jdXNCbG9jaykpXG4gICAgICByZXR1cm4gW3ZvaWQgMCwgdm9pZCAwXTtcbiAgICBjb25zdCBbbm9kZSwgcGF0aF0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aC5zbGljZSgwLCAyKSk7XG4gICAgaWYgKGVkaXRvci5pc1RleHRTcGFuKG5vZGUpKVxuICAgICAgcmV0dXJuIFtub2RlLCBwYXRoXTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIFt2b2lkIDAsIHZvaWQgMF07XG4gIH1cbiAgcmV0dXJuIFt2b2lkIDAsIHZvaWQgMF07XG59XG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25TdGFydEJsb2NrKHtcbiAgZWRpdG9yXG59KSB7XG4gIGlmICghZWRpdG9yLnNlbGVjdGlvbilcbiAgICByZXR1cm4gW3ZvaWQgMCwgdm9pZCAwXTtcbiAgY29uc3Qgc2VsZWN0aW9uU3RhcnRQb2ludCA9IFJhbmdlLnN0YXJ0KGVkaXRvci5zZWxlY3Rpb24pO1xuICByZXR1cm4gZ2V0UG9pbnRCbG9jayh7XG4gICAgZWRpdG9yLFxuICAgIHBvaW50OiBzZWxlY3Rpb25TdGFydFBvaW50XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uRW5kQmxvY2soe1xuICBlZGl0b3Jcbn0pIHtcbiAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uKVxuICAgIHJldHVybiBbdm9pZCAwLCB2b2lkIDBdO1xuICBjb25zdCBzZWxlY3Rpb25FbmRQb2ludCA9IFJhbmdlLmVuZChlZGl0b3Iuc2VsZWN0aW9uKTtcbiAgcmV0dXJuIGdldFBvaW50QmxvY2soe1xuICAgIGVkaXRvcixcbiAgICBwb2ludDogc2VsZWN0aW9uRW5kUG9pbnRcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRQb2ludEJsb2NrKHtcbiAgZWRpdG9yLFxuICBwb2ludFxufSkge1xuICB0cnkge1xuICAgIGNvbnN0IFtibG9ja10gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBvaW50LnBhdGguc2xpY2UoMCwgMSkpID8/IFt2b2lkIDAsIHZvaWQgMF07XG4gICAgcmV0dXJuIGJsb2NrID8gW2Jsb2NrLCBwb2ludC5wYXRoLnNsaWNlKDAsIDEpXSA6IFt2b2lkIDAsIHZvaWQgMF07XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBbdm9pZCAwLCB2b2lkIDBdO1xuICB9XG59XG5mdW5jdGlvbiBnZXRGb2N1c0NoaWxkKHtcbiAgZWRpdG9yXG59KSB7XG4gIGNvbnN0IFtmb2N1c0Jsb2NrLCBmb2N1c0Jsb2NrUGF0aF0gPSBnZXRGb2N1c0Jsb2NrKHtcbiAgICBlZGl0b3JcbiAgfSksIGNoaWxkSW5kZXggPSBlZGl0b3Iuc2VsZWN0aW9uPy5mb2N1cy5wYXRoLmF0KDEpO1xuICBpZiAoIWZvY3VzQmxvY2sgfHwgIWZvY3VzQmxvY2tQYXRoIHx8IGNoaWxkSW5kZXggPT09IHZvaWQgMClcbiAgICByZXR1cm4gW3ZvaWQgMCwgdm9pZCAwXTtcbiAgdHJ5IHtcbiAgICBjb25zdCBmb2N1c0NoaWxkID0gTm9kZS5jaGlsZChmb2N1c0Jsb2NrLCBjaGlsZEluZGV4KTtcbiAgICByZXR1cm4gZm9jdXNDaGlsZCA/IFtmb2N1c0NoaWxkLCBbLi4uZm9jdXNCbG9ja1BhdGgsIGNoaWxkSW5kZXhdXSA6IFt2b2lkIDAsIHZvaWQgMF07XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBbdm9pZCAwLCB2b2lkIDBdO1xuICB9XG59XG5mdW5jdGlvbiBnZXRQb2ludENoaWxkKHtcbiAgZWRpdG9yLFxuICBwb2ludFxufSkge1xuICBjb25zdCBbYmxvY2ssIGJsb2NrUGF0aF0gPSBnZXRQb2ludEJsb2NrKHtcbiAgICBlZGl0b3IsXG4gICAgcG9pbnRcbiAgfSksIGNoaWxkSW5kZXggPSBwb2ludC5wYXRoLmF0KDEpO1xuICBpZiAoIWJsb2NrIHx8ICFibG9ja1BhdGggfHwgY2hpbGRJbmRleCA9PT0gdm9pZCAwKVxuICAgIHJldHVybiBbdm9pZCAwLCB2b2lkIDBdO1xuICB0cnkge1xuICAgIGNvbnN0IHBvaW50Q2hpbGQgPSBOb2RlLmNoaWxkKGJsb2NrLCBjaGlsZEluZGV4KTtcbiAgICByZXR1cm4gcG9pbnRDaGlsZCA/IFtwb2ludENoaWxkLCBbLi4uYmxvY2tQYXRoLCBjaGlsZEluZGV4XV0gOiBbdm9pZCAwLCB2b2lkIDBdO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gW3ZvaWQgMCwgdm9pZCAwXTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Rmlyc3RCbG9jayh7XG4gIGVkaXRvclxufSkge1xuICBpZiAoZWRpdG9yLmNoaWxkcmVuLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gW3ZvaWQgMCwgdm9pZCAwXTtcbiAgY29uc3QgZmlyc3RCbG9ja1BhdGggPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBbXSkucGF0aC5hdCgwKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZmlyc3RCbG9ja1BhdGggIT09IHZvaWQgMCA/IEVkaXRvci5ub2RlKGVkaXRvciwgW2ZpcnN0QmxvY2tQYXRoXSkgPz8gW3ZvaWQgMCwgdm9pZCAwXSA6IFt2b2lkIDAsIHZvaWQgMF07XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBbdm9pZCAwLCB2b2lkIDBdO1xuICB9XG59XG5mdW5jdGlvbiBnZXRMYXN0QmxvY2soe1xuICBlZGl0b3Jcbn0pIHtcbiAgaWYgKGVkaXRvci5jaGlsZHJlbi5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIFt2b2lkIDAsIHZvaWQgMF07XG4gIGNvbnN0IGxhc3RCbG9ja1BhdGggPSBFZGl0b3IuZW5kKGVkaXRvciwgW10pLnBhdGguYXQoMCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGxhc3RCbG9ja1BhdGggIT09IHZvaWQgMCA/IEVkaXRvci5ub2RlKGVkaXRvciwgW2xhc3RCbG9ja1BhdGhdKSA/PyBbdm9pZCAwLCB2b2lkIDBdIDogW3ZvaWQgMCwgdm9pZCAwXTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIFt2b2lkIDAsIHZvaWQgMF07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldE5vZGVCbG9jayh7XG4gIGVkaXRvcixcbiAgc2NoZW1hLFxuICBub2RlXG59KSB7XG4gIGlmIChFZGl0b3IuaXNFZGl0b3Iobm9kZSkpXG4gICAgcmV0dXJuO1xuICBpZiAoaXNCbG9ja0VsZW1lbnQoe1xuICAgIGVkaXRvcixcbiAgICBzY2hlbWFcbiAgfSwgbm9kZSkpXG4gICAgcmV0dXJuIGVsZW1lbnRUb0Jsb2NrKHtcbiAgICAgIHNjaGVtYSxcbiAgICAgIGVsZW1lbnQ6IG5vZGVcbiAgICB9KTtcbiAgY29uc3QgcGFyZW50ID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgbW9kZTogXCJoaWdoZXN0XCIsXG4gICAgYXQ6IFtdLFxuICAgIG1hdGNoOiAobikgPT4gaXNCbG9ja0VsZW1lbnQoe1xuICAgICAgZWRpdG9yLFxuICAgICAgc2NoZW1hXG4gICAgfSwgbikgJiYgbi5jaGlsZHJlbi5zb21lKChjaGlsZCkgPT4gY2hpbGQuX2tleSA9PT0gbm9kZS5fa2V5KVxuICB9KSkuYXQoMCk/LmF0KDApO1xuICByZXR1cm4gRWxlbWVudCQxLmlzRWxlbWVudChwYXJlbnQpID8gZWxlbWVudFRvQmxvY2soe1xuICAgIHNjaGVtYSxcbiAgICBlbGVtZW50OiBwYXJlbnRcbiAgfSkgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBlbGVtZW50VG9CbG9jayh7XG4gIHNjaGVtYSxcbiAgZWxlbWVudFxufSkge1xuICByZXR1cm4gZnJvbVNsYXRlVmFsdWUoW2VsZW1lbnRdLCBzY2hlbWEuYmxvY2submFtZSk/LmF0KDApO1xufVxuZnVuY3Rpb24gaXNCbG9ja0VsZW1lbnQoe1xuICBlZGl0b3IsXG4gIHNjaGVtYVxufSwgbm9kZSkge1xuICByZXR1cm4gRWxlbWVudCQxLmlzRWxlbWVudChub2RlKSAmJiAhZWRpdG9yLmlzSW5saW5lKG5vZGUpICYmIChzY2hlbWEuYmxvY2submFtZSA9PT0gbm9kZS5fdHlwZSB8fCBzY2hlbWEuYmxvY2tPYmplY3RzLnNvbWUoKGJsb2NrT2JqZWN0KSA9PiBibG9ja09iamVjdC5uYW1lID09PSBub2RlLl90eXBlKSk7XG59XG5mdW5jdGlvbiBpc0xpc3RJdGVtQWN0aXZlKHtcbiAgZWRpdG9yLFxuICBsaXN0SXRlbVxufSkge1xuICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBzZWxlY3RlZEJsb2NrcyA9IFsuLi5FZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgYXQ6IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgbWF0Y2g6IChub2RlKSA9PiBlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSlcbiAgfSldO1xuICByZXR1cm4gc2VsZWN0ZWRCbG9ja3MubGVuZ3RoID4gMCA/IHNlbGVjdGVkQmxvY2tzLmV2ZXJ5KChbbm9kZV0pID0+IGVkaXRvci5pc0xpc3RCbG9jayhub2RlKSAmJiBub2RlLmxpc3RJdGVtID09PSBsaXN0SXRlbSkgOiAhMTtcbn1cbmZ1bmN0aW9uIGlzU3R5bGVBY3RpdmUoe1xuICBlZGl0b3IsXG4gIHN0eWxlXG59KSB7XG4gIGlmICghZWRpdG9yLnNlbGVjdGlvbilcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IHNlbGVjdGVkQmxvY2tzID0gWy4uLkVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICBhdDogZWRpdG9yLnNlbGVjdGlvbixcbiAgICBtYXRjaDogKG5vZGUpID0+IGVkaXRvci5pc1RleHRCbG9jayhub2RlKVxuICB9KV07XG4gIHJldHVybiBzZWxlY3RlZEJsb2Nrcy5sZW5ndGggPiAwID8gc2VsZWN0ZWRCbG9ja3MuZXZlcnkoKFtub2RlXSkgPT4gbm9kZS5zdHlsZSA9PT0gc3R5bGUpIDogITE7XG59XG5mdW5jdGlvbiBzbGF0ZVJhbmdlVG9TZWxlY3Rpb24oe1xuICBzY2hlbWEsXG4gIGVkaXRvcixcbiAgcmFuZ2Vcbn0pIHtcbiAgY29uc3QgW2FuY2hvckJsb2NrXSA9IGdldFBvaW50QmxvY2soe1xuICAgIGVkaXRvcixcbiAgICBwb2ludDogcmFuZ2UuYW5jaG9yXG4gIH0pLCBbZm9jdXNCbG9ja10gPSBnZXRQb2ludEJsb2NrKHtcbiAgICBlZGl0b3IsXG4gICAgcG9pbnQ6IHJhbmdlLmZvY3VzXG4gIH0pO1xuICBpZiAoIWFuY2hvckJsb2NrIHx8ICFmb2N1c0Jsb2NrKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBbYW5jaG9yQ2hpbGRdID0gYW5jaG9yQmxvY2suX3R5cGUgPT09IHNjaGVtYS5ibG9jay5uYW1lID8gZ2V0UG9pbnRDaGlsZCh7XG4gICAgZWRpdG9yLFxuICAgIHBvaW50OiByYW5nZS5hbmNob3JcbiAgfSkgOiBbdm9pZCAwLCB2b2lkIDBdLCBbZm9jdXNDaGlsZF0gPSBmb2N1c0Jsb2NrLl90eXBlID09PSBzY2hlbWEuYmxvY2submFtZSA/IGdldFBvaW50Q2hpbGQoe1xuICAgIGVkaXRvcixcbiAgICBwb2ludDogcmFuZ2UuZm9jdXNcbiAgfSkgOiBbdm9pZCAwLCB2b2lkIDBdLCBzZWxlY3Rpb24gPSB7XG4gICAgYW5jaG9yOiB7XG4gICAgICBwYXRoOiBbe1xuICAgICAgICBfa2V5OiBhbmNob3JCbG9jay5fa2V5XG4gICAgICB9XSxcbiAgICAgIG9mZnNldDogcmFuZ2UuYW5jaG9yLm9mZnNldFxuICAgIH0sXG4gICAgZm9jdXM6IHtcbiAgICAgIHBhdGg6IFt7XG4gICAgICAgIF9rZXk6IGZvY3VzQmxvY2suX2tleVxuICAgICAgfV0sXG4gICAgICBvZmZzZXQ6IHJhbmdlLmZvY3VzLm9mZnNldFxuICAgIH0sXG4gICAgYmFja3dhcmQ6IFJhbmdlLmlzQmFja3dhcmQocmFuZ2UpXG4gIH07XG4gIHJldHVybiBhbmNob3JDaGlsZCAmJiAoc2VsZWN0aW9uLmFuY2hvci5wYXRoLnB1c2goXCJjaGlsZHJlblwiKSwgc2VsZWN0aW9uLmFuY2hvci5wYXRoLnB1c2goe1xuICAgIF9rZXk6IGFuY2hvckNoaWxkLl9rZXlcbiAgfSkpLCBmb2N1c0NoaWxkICYmIChzZWxlY3Rpb24uZm9jdXMucGF0aC5wdXNoKFwiY2hpbGRyZW5cIiksIHNlbGVjdGlvbi5mb2N1cy5wYXRoLnB1c2goe1xuICAgIF9rZXk6IGZvY3VzQ2hpbGQuX2tleVxuICB9KSksIHNlbGVjdGlvbjtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50UG9zaXRpb24oe1xuICBlZGl0b3JBY3RvcixcbiAgc2xhdGVFZGl0b3IsXG4gIGV2ZW50XG59KSB7XG4gIGlmIChlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLm1hdGNoZXMoe1xuICAgIHNldHVwOiBcInNldHRpbmcgdXBcIlxuICB9KSlcbiAgICByZXR1cm47XG4gIGNvbnN0IGV2ZW50Tm9kZSA9IGdldEV2ZW50Tm9kZSh7XG4gICAgc2xhdGVFZGl0b3IsXG4gICAgZXZlbnRcbiAgfSk7XG4gIGlmICghZXZlbnROb2RlKVxuICAgIHJldHVybjtcbiAgY29uc3QgZXZlbnRCbG9jayA9IGdldE5vZGVCbG9jayh7XG4gICAgZWRpdG9yOiBzbGF0ZUVkaXRvcixcbiAgICBzY2hlbWE6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEsXG4gICAgbm9kZTogZXZlbnROb2RlXG4gIH0pLCBldmVudFBvc2l0aW9uQmxvY2sgPSBnZXRFdmVudFBvc2l0aW9uQmxvY2soe1xuICAgIG5vZGU6IGV2ZW50Tm9kZSxcbiAgICBzbGF0ZUVkaXRvcixcbiAgICBldmVudFxuICB9KSwgZXZlbnRTZWxlY3Rpb24gPSBnZXRFdmVudFNlbGVjdGlvbih7XG4gICAgc2NoZW1hOiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLFxuICAgIHNsYXRlRWRpdG9yLFxuICAgIGV2ZW50XG4gIH0pO1xuICBpZiAoZXZlbnRCbG9jayAmJiBldmVudFBvc2l0aW9uQmxvY2sgJiYgIWV2ZW50U2VsZWN0aW9uICYmICFFZGl0b3IuaXNFZGl0b3IoZXZlbnROb2RlKSlcbiAgICByZXR1cm4ge1xuICAgICAgYmxvY2s6IGV2ZW50UG9zaXRpb25CbG9jayxcbiAgICAgIGlzRWRpdG9yOiAhMSxcbiAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICBhbmNob3I6IGdldEJsb2NrU3RhcnRQb2ludCh7XG4gICAgICAgICAgY29udGV4dDogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LFxuICAgICAgICAgIGJsb2NrOiB7XG4gICAgICAgICAgICBub2RlOiBldmVudEJsb2NrLFxuICAgICAgICAgICAgcGF0aDogW3tcbiAgICAgICAgICAgICAgX2tleTogZXZlbnRCbG9jay5fa2V5XG4gICAgICAgICAgICB9XVxuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIGZvY3VzOiBnZXRCbG9ja0VuZFBvaW50KHtcbiAgICAgICAgICBjb250ZXh0OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQsXG4gICAgICAgICAgYmxvY2s6IHtcbiAgICAgICAgICAgIG5vZGU6IGV2ZW50QmxvY2ssXG4gICAgICAgICAgICBwYXRoOiBbe1xuICAgICAgICAgICAgICBfa2V5OiBldmVudEJsb2NrLl9rZXlcbiAgICAgICAgICAgIH1dXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH07XG4gIGlmICghZXZlbnRQb3NpdGlvbkJsb2NrIHx8ICFldmVudFNlbGVjdGlvbilcbiAgICByZXR1cm47XG4gIGNvbnN0IGV2ZW50U2VsZWN0aW9uRm9jdXNCbG9ja0tleSA9IGdldEJsb2NrS2V5RnJvbVNlbGVjdGlvblBvaW50KGV2ZW50U2VsZWN0aW9uLmZvY3VzKTtcbiAgaWYgKGV2ZW50U2VsZWN0aW9uRm9jdXNCbG9ja0tleSAhPT0gdm9pZCAwKVxuICAgIHJldHVybiBpc1NlbGVjdGlvbkNvbGxhcHNlZChldmVudFNlbGVjdGlvbikgJiYgZXZlbnRCbG9jayAmJiBldmVudFNlbGVjdGlvbkZvY3VzQmxvY2tLZXkgIT09IGV2ZW50QmxvY2suX2tleSA/IHtcbiAgICAgIGJsb2NrOiBldmVudFBvc2l0aW9uQmxvY2ssXG4gICAgICBpc0VkaXRvcjogITEsXG4gICAgICBzZWxlY3Rpb246IHtcbiAgICAgICAgYW5jaG9yOiBnZXRCbG9ja1N0YXJ0UG9pbnQoe1xuICAgICAgICAgIGNvbnRleHQ6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dCxcbiAgICAgICAgICBibG9jazoge1xuICAgICAgICAgICAgbm9kZTogZXZlbnRCbG9jayxcbiAgICAgICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgICAgIF9rZXk6IGV2ZW50QmxvY2suX2tleVxuICAgICAgICAgICAgfV1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBmb2N1czogZ2V0QmxvY2tFbmRQb2ludCh7XG4gICAgICAgICAgY29udGV4dDogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LFxuICAgICAgICAgIGJsb2NrOiB7XG4gICAgICAgICAgICBub2RlOiBldmVudEJsb2NrLFxuICAgICAgICAgICAgcGF0aDogW3tcbiAgICAgICAgICAgICAgX2tleTogZXZlbnRCbG9jay5fa2V5XG4gICAgICAgICAgICB9XVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9IDoge1xuICAgICAgYmxvY2s6IGV2ZW50UG9zaXRpb25CbG9jayxcbiAgICAgIGlzRWRpdG9yOiBFZGl0b3IuaXNFZGl0b3IoZXZlbnROb2RlKSxcbiAgICAgIHNlbGVjdGlvbjogZXZlbnRTZWxlY3Rpb25cbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0RXZlbnROb2RlKHtcbiAgc2xhdGVFZGl0b3IsXG4gIGV2ZW50XG59KSB7XG4gIHJldHVybiBET01FZGl0b3IuaGFzVGFyZ2V0KHNsYXRlRWRpdG9yLCBldmVudC50YXJnZXQpID8gRE9NRWRpdG9yLnRvU2xhdGVOb2RlKHNsYXRlRWRpdG9yLCBldmVudC50YXJnZXQpIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRQb3NpdGlvbkJsb2NrKHtcbiAgbm9kZSxcbiAgc2xhdGVFZGl0b3IsXG4gIGV2ZW50XG59KSB7XG4gIGNvbnN0IFtmaXJzdEJsb2NrXSA9IGdldEZpcnN0QmxvY2soe1xuICAgIGVkaXRvcjogc2xhdGVFZGl0b3JcbiAgfSk7XG4gIGlmICghZmlyc3RCbG9jaylcbiAgICByZXR1cm47XG4gIGNvbnN0IGZpcnN0QmxvY2tSZWN0ID0gRE9NRWRpdG9yLnRvRE9NTm9kZShzbGF0ZUVkaXRvciwgZmlyc3RCbG9jaykuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGlmIChldmVudC5wYWdlWSA8IGZpcnN0QmxvY2tSZWN0LnRvcClcbiAgICByZXR1cm4gXCJzdGFydFwiO1xuICBjb25zdCBbbGFzdEJsb2NrXSA9IGdldExhc3RCbG9jayh7XG4gICAgZWRpdG9yOiBzbGF0ZUVkaXRvclxuICB9KTtcbiAgaWYgKCFsYXN0QmxvY2spXG4gICAgcmV0dXJuO1xuICBjb25zdCBsYXN0QmxvY2tSZWYgPSBET01FZGl0b3IudG9ET01Ob2RlKHNsYXRlRWRpdG9yLCBsYXN0QmxvY2spLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBpZiAoZXZlbnQucGFnZVkgPiBsYXN0QmxvY2tSZWYuYm90dG9tKVxuICAgIHJldHVybiBcImVuZFwiO1xuICBjb25zdCBlbGVtZW50UmVjdCA9IERPTUVkaXRvci50b0RPTU5vZGUoc2xhdGVFZGl0b3IsIG5vZGUpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB0b3AgPSBlbGVtZW50UmVjdC50b3AsIGhlaWdodCA9IGVsZW1lbnRSZWN0LmhlaWdodDtcbiAgcmV0dXJuIE1hdGguYWJzKHRvcCAtIGV2ZW50LnBhZ2VZKSA8IGhlaWdodCAvIDIgPyBcInN0YXJ0XCIgOiBcImVuZFwiO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRTZWxlY3Rpb24oe1xuICBzY2hlbWEsXG4gIHNsYXRlRWRpdG9yLFxuICBldmVudFxufSkge1xuICBjb25zdCByYW5nZSA9IGdldFNsYXRlUmFuZ2VGcm9tRXZlbnQoc2xhdGVFZGl0b3IsIGV2ZW50KTtcbiAgcmV0dXJuIHJhbmdlID8gc2xhdGVSYW5nZVRvU2VsZWN0aW9uKHtcbiAgICBzY2hlbWEsXG4gICAgZWRpdG9yOiBzbGF0ZUVkaXRvcixcbiAgICByYW5nZVxuICB9KSA6IG51bGw7XG59XG5mdW5jdGlvbiBnZXRTbGF0ZVJhbmdlRnJvbUV2ZW50KGVkaXRvciwgZXZlbnQpIHtcbiAgaWYgKCFldmVudC50YXJnZXQgfHwgIWlzRE9NTm9kZShldmVudC50YXJnZXQpKVxuICAgIHJldHVybjtcbiAgY29uc3Qgd2luZG93MiA9IERPTUVkaXRvci5nZXRXaW5kb3coZWRpdG9yKTtcbiAgbGV0IGRvbVJhbmdlO1xuICBpZiAod2luZG93Mi5kb2N1bWVudC5jYXJldFBvc2l0aW9uRnJvbVBvaW50ICE9PSB2b2lkIDApIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHdpbmRvdzIuZG9jdW1lbnQuY2FyZXRQb3NpdGlvbkZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICBpZiAocG9zaXRpb24pXG4gICAgICB0cnkge1xuICAgICAgICBkb21SYW5nZSA9IHdpbmRvdzIuZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKSwgZG9tUmFuZ2Uuc2V0U3RhcnQocG9zaXRpb24ub2Zmc2V0Tm9kZSwgcG9zaXRpb24ub2Zmc2V0KSwgZG9tUmFuZ2Uuc2V0RW5kKHBvc2l0aW9uLm9mZnNldE5vZGUsIHBvc2l0aW9uLm9mZnNldCk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgfSBlbHNlIGlmICh3aW5kb3cyLmRvY3VtZW50LmNhcmV0UmFuZ2VGcm9tUG9pbnQgIT09IHZvaWQgMClcbiAgICBkb21SYW5nZSA9IHdpbmRvdzIuZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKSA/PyB2b2lkIDA7XG4gIGVsc2Uge1xuICAgIGNvbnNvbGUud2FybihcIk5laXRoZXIgY2FyZXRQb3NpdGlvbkZyb21Qb2ludCBub3IgY2FyZXRSYW5nZUZyb21Qb2ludCBpcyBzdXBwb3J0ZWRcIik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghZG9tUmFuZ2UpXG4gICAgcmV0dXJuO1xuICBsZXQgcmFuZ2U7XG4gIHRyeSB7XG4gICAgcmFuZ2UgPSBET01FZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgZG9tUmFuZ2UsIHtcbiAgICAgIGV4YWN0TWF0Y2g6ICExLFxuICAgICAgLy8gSXQgY2FuIHN0aWxsIHRocm93IGV2ZW4gd2l0aCB0aGlzIG9wdGlvbiBzZXQgdG8gdHJ1ZVxuICAgICAgc3VwcHJlc3NUaHJvdzogITFcbiAgICB9KTtcbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIHJhbmdlO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUG9pbnQocG9pbnQsIHZhbHVlKSB7XG4gIGlmICghcG9pbnQgfHwgIXZhbHVlKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBuZXdQYXRoID0gW107XG4gIGxldCBuZXdPZmZzZXQgPSBwb2ludC5vZmZzZXQgfHwgMDtcbiAgY29uc3QgYmxvY2tLZXkgPSB0eXBlb2YgcG9pbnQucGF0aFswXSA9PSBcIm9iamVjdFwiICYmIFwiX2tleVwiIGluIHBvaW50LnBhdGhbMF0gJiYgcG9pbnQucGF0aFswXS5fa2V5LCBjaGlsZEtleSA9IHR5cGVvZiBwb2ludC5wYXRoWzJdID09IFwib2JqZWN0XCIgJiYgXCJfa2V5XCIgaW4gcG9pbnQucGF0aFsyXSAmJiBwb2ludC5wYXRoWzJdLl9rZXksIGJsb2NrID0gdmFsdWUuZmluZCgoYmxrKSA9PiBibGsuX2tleSA9PT0gYmxvY2tLZXkpO1xuICBpZiAoYmxvY2spXG4gICAgbmV3UGF0aC5wdXNoKHtcbiAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICB9KTtcbiAgZWxzZVxuICAgIHJldHVybiBudWxsO1xuICBpZiAoYmxvY2sgJiYgcG9pbnQucGF0aFsxXSA9PT0gXCJjaGlsZHJlblwiKSB7XG4gICAgaWYgKCFibG9jay5jaGlsZHJlbiB8fCBBcnJheS5pc0FycmF5KGJsb2NrLmNoaWxkcmVuKSAmJiBibG9jay5jaGlsZHJlbi5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBjaGlsZCA9IEFycmF5LmlzQXJyYXkoYmxvY2suY2hpbGRyZW4pICYmIGJsb2NrLmNoaWxkcmVuLmZpbmQoKGNsZCkgPT4gY2xkLl9rZXkgPT09IGNoaWxkS2V5KTtcbiAgICBpZiAoY2hpbGQpXG4gICAgICBuZXdQYXRoLnB1c2goXCJjaGlsZHJlblwiKSwgbmV3UGF0aC5wdXNoKHtcbiAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgfSksIG5ld09mZnNldCA9IGNoaWxkLnRleHQgJiYgY2hpbGQudGV4dC5sZW5ndGggPj0gcG9pbnQub2Zmc2V0ID8gcG9pbnQub2Zmc2V0IDogY2hpbGQudGV4dCAmJiBjaGlsZC50ZXh0Lmxlbmd0aCB8fCAwO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgcGF0aDogbmV3UGF0aCxcbiAgICBvZmZzZXQ6IG5ld09mZnNldFxuICB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU2VsZWN0aW9uKHNlbGVjdGlvbiwgdmFsdWUpIHtcbiAgaWYgKCFzZWxlY3Rpb24gfHwgIXZhbHVlIHx8IHZhbHVlLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IG5ld0FuY2hvciA9IG51bGwsIG5ld0ZvY3VzID0gbnVsbDtcbiAgY29uc3Qge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9ID0gc2VsZWN0aW9uO1xuICByZXR1cm4gYW5jaG9yICYmIHZhbHVlLmZpbmQoKGJsaykgPT4gaXNFcXVhbCh7XG4gICAgX2tleTogYmxrLl9rZXlcbiAgfSwgYW5jaG9yLnBhdGhbMF0pKSAmJiAobmV3QW5jaG9yID0gbm9ybWFsaXplUG9pbnQoYW5jaG9yLCB2YWx1ZSkpLCBmb2N1cyAmJiB2YWx1ZS5maW5kKChibGspID0+IGlzRXF1YWwoe1xuICAgIF9rZXk6IGJsay5fa2V5XG4gIH0sIGZvY3VzLnBhdGhbMF0pKSAmJiAobmV3Rm9jdXMgPSBub3JtYWxpemVQb2ludChmb2N1cywgdmFsdWUpKSwgbmV3QW5jaG9yICYmIG5ld0ZvY3VzID8ge1xuICAgIGFuY2hvcjogbmV3QW5jaG9yLFxuICAgIGZvY3VzOiBuZXdGb2N1cyxcbiAgICBiYWNrd2FyZDogc2VsZWN0aW9uLmJhY2t3YXJkXG4gIH0gOiBudWxsO1xufVxuZnVuY3Rpb24gdG9TbGF0ZVJhbmdlKHNuYXBzaG90KSB7XG4gIGlmICghc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24pXG4gICAgcmV0dXJuIG51bGw7XG4gIGlmIChpc0VxdWFsU2VsZWN0aW9uUG9pbnRzKHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmFuY2hvciwgc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uZm9jdXMpKSB7XG4gICAgY29uc3QgYW5jaG9yUG9pbnQyID0gdG9TbGF0ZVNlbGVjdGlvblBvaW50KHNuYXBzaG90LCBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5hbmNob3IsIHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmJhY2t3YXJkID8gXCJmb3J3YXJkXCIgOiBcImJhY2t3YXJkXCIpO1xuICAgIHJldHVybiBhbmNob3JQb2ludDIgPyB7XG4gICAgICBhbmNob3I6IGFuY2hvclBvaW50MixcbiAgICAgIGZvY3VzOiBhbmNob3JQb2ludDJcbiAgICB9IDogbnVsbDtcbiAgfVxuICBjb25zdCBhbmNob3JQb2ludCA9IHRvU2xhdGVTZWxlY3Rpb25Qb2ludChzbmFwc2hvdCwgc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uYW5jaG9yLCBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5iYWNrd2FyZCA/IFwiZm9yd2FyZFwiIDogXCJiYWNrd2FyZFwiKSwgZm9jdXNQb2ludCA9IHRvU2xhdGVTZWxlY3Rpb25Qb2ludChzbmFwc2hvdCwgc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uZm9jdXMsIHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmJhY2t3YXJkID8gXCJiYWNrd2FyZFwiIDogXCJmb3J3YXJkXCIpO1xuICByZXR1cm4gIWFuY2hvclBvaW50IHx8ICFmb2N1c1BvaW50ID8gbnVsbCA6IHtcbiAgICBhbmNob3I6IGFuY2hvclBvaW50LFxuICAgIGZvY3VzOiBmb2N1c1BvaW50XG4gIH07XG59XG5mdW5jdGlvbiB0b1NsYXRlU2VsZWN0aW9uUG9pbnQoc25hcHNob3QsIHNlbGVjdGlvblBvaW50LCBkaXJlY3Rpb24pIHtcbiAgY29uc3QgYmxvY2tLZXkgPSBnZXRCbG9ja0tleUZyb21TZWxlY3Rpb25Qb2ludChzZWxlY3Rpb25Qb2ludCk7XG4gIGlmICghYmxvY2tLZXkpXG4gICAgcmV0dXJuO1xuICBjb25zdCBibG9ja0luZGV4ID0gc25hcHNob3QuYmxvY2tJbmRleE1hcC5nZXQoYmxvY2tLZXkpO1xuICBpZiAoYmxvY2tJbmRleCA9PT0gdm9pZCAwKVxuICAgIHJldHVybjtcbiAgY29uc3QgYmxvY2sgPSBzbmFwc2hvdC5jb250ZXh0LnZhbHVlLmF0KGJsb2NrSW5kZXgpO1xuICBpZiAoIWJsb2NrKVxuICAgIHJldHVybjtcbiAgaWYgKCFpc1RleHRCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBibG9jaykpXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IFtibG9ja0luZGV4LCAwXSxcbiAgICAgIG9mZnNldDogMFxuICAgIH07XG4gIGxldCBjaGlsZEtleSA9IGdldENoaWxkS2V5RnJvbVNlbGVjdGlvblBvaW50KHtcbiAgICBwYXRoOiBzZWxlY3Rpb25Qb2ludC5wYXRoXG4gIH0pO1xuICBjb25zdCBzcGFuU2VsZWN0aW9uUG9pbnQgPSBjaGlsZEtleSA/IHZvaWQgMCA6IGJsb2NrT2Zmc2V0VG9TcGFuU2VsZWN0aW9uUG9pbnQoe1xuICAgIGNvbnRleHQ6IHtcbiAgICAgIHNjaGVtYTogc25hcHNob3QuY29udGV4dC5zY2hlbWEsXG4gICAgICB2YWx1ZTogW2Jsb2NrXVxuICAgIH0sXG4gICAgYmxvY2tPZmZzZXQ6IHtcbiAgICAgIHBhdGg6IFt7XG4gICAgICAgIF9rZXk6IGJsb2NrS2V5XG4gICAgICB9XSxcbiAgICAgIG9mZnNldDogc2VsZWN0aW9uUG9pbnQub2Zmc2V0XG4gICAgfSxcbiAgICBkaXJlY3Rpb25cbiAgfSk7XG4gIGlmIChjaGlsZEtleSA9IHNwYW5TZWxlY3Rpb25Qb2ludCA/IGdldENoaWxkS2V5RnJvbVNlbGVjdGlvblBvaW50KHNwYW5TZWxlY3Rpb25Qb2ludCkgOiBjaGlsZEtleSwgIWNoaWxkS2V5KVxuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBbYmxvY2tJbmRleCwgMF0sXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9O1xuICBsZXQgb2Zmc2V0ID0gc3BhblNlbGVjdGlvblBvaW50Py5vZmZzZXQgPz8gc2VsZWN0aW9uUG9pbnQub2Zmc2V0LCBjaGlsZFBhdGggPSBbXSwgY2hpbGRJbmRleCA9IC0xLCBwYXRoQ2hpbGQ7XG4gIGZvciAoY29uc3QgY2hpbGQgb2YgYmxvY2suY2hpbGRyZW4pXG4gICAgaWYgKGNoaWxkSW5kZXgrKywgY2hpbGQuX2tleSA9PT0gY2hpbGRLZXkpIHtcbiAgICAgIHBhdGhDaGlsZCA9IGNoaWxkLCBpc1NwYW4oc25hcHNob3QuY29udGV4dCwgY2hpbGQpID8gY2hpbGRQYXRoID0gW2NoaWxkSW5kZXhdIDogKGNoaWxkUGF0aCA9IFtjaGlsZEluZGV4LCAwXSwgb2Zmc2V0ID0gMCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIHJldHVybiBjaGlsZFBhdGgubGVuZ3RoID09PSAwID8ge1xuICAgIHBhdGg6IFtibG9ja0luZGV4LCAwXSxcbiAgICBvZmZzZXQ6IDBcbiAgfSA6IHtcbiAgICBwYXRoOiBbYmxvY2tJbmRleF0uY29uY2F0KGNoaWxkUGF0aCksXG4gICAgb2Zmc2V0OiBpc1NwYW4oc25hcHNob3QuY29udGV4dCwgcGF0aENoaWxkKSA/IE1hdGgubWluKHBhdGhDaGlsZC50ZXh0Lmxlbmd0aCwgb2Zmc2V0KSA6IG9mZnNldFxuICB9O1xufVxuY29uc3QgRWRpdG9yQWN0b3JDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh7fSk7XG5mdW5jdGlvbiBEcm9wSW5kaWNhdG9yKCkge1xuICBjb25zdCAkID0gYygxKTtcbiAgbGV0IHQwO1xuICByZXR1cm4gJFswXSA9PT0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9fY2FjaGVfc2VudGluZWxcIikgPyAodDAgPSAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHsgY29udGVudEVkaXRhYmxlOiAhMSwgY2xhc3NOYW1lOiBcInB0LWRyb3AtaW5kaWNhdG9yXCIsIHN0eWxlOiB7XG4gICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgaGVpZ2h0OiAxLFxuICAgIGJvcmRlckJvdHRvbTogXCIxcHggc29saWQgY3VycmVudENvbG9yXCIsXG4gICAgekluZGV4OiA1XG4gIH0sIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFwic3BhblwiLCB7fSkgfSksICRbMF0gPSB0MCkgOiB0MCA9ICRbMF0sIHQwO1xufVxuZnVuY3Rpb24gUmVuZGVyRGVmYXVsdEJsb2NrT2JqZWN0KHByb3BzKSB7XG4gIGNvbnN0ICQgPSBjKDQpO1xuICBsZXQgdDA7XG4gICRbMF0gPT09IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vX2NhY2hlX3NlbnRpbmVsXCIpID8gKHQwID0ge1xuICAgIHVzZXJTZWxlY3Q6IFwibm9uZVwiXG4gIH0sICRbMF0gPSB0MCkgOiB0MCA9ICRbMF07XG4gIGxldCB0MTtcbiAgcmV0dXJuICRbMV0gIT09IHByb3BzLmJsb2NrT2JqZWN0Ll9rZXkgfHwgJFsyXSAhPT0gcHJvcHMuYmxvY2tPYmplY3QuX3R5cGUgPyAodDEgPSAvKiBAX19QVVJFX18gKi8ganN4cyhcImRpdlwiLCB7IHN0eWxlOiB0MCwgY2hpbGRyZW46IFtcbiAgICBcIltcIixcbiAgICBwcm9wcy5ibG9ja09iamVjdC5fdHlwZSxcbiAgICBcIjogXCIsXG4gICAgcHJvcHMuYmxvY2tPYmplY3QuX2tleSxcbiAgICBcIl1cIlxuICBdIH0pLCAkWzFdID0gcHJvcHMuYmxvY2tPYmplY3QuX2tleSwgJFsyXSA9IHByb3BzLmJsb2NrT2JqZWN0Ll90eXBlLCAkWzNdID0gdDEpIDogdDEgPSAkWzNdLCB0MTtcbn1cbmZ1bmN0aW9uIFJlbmRlckRlZmF1bHRJbmxpbmVPYmplY3QocHJvcHMpIHtcbiAgY29uc3QgJCA9IGMoNCk7XG4gIGxldCB0MDtcbiAgJFswXSA9PT0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9fY2FjaGVfc2VudGluZWxcIikgPyAodDAgPSB7XG4gICAgdXNlclNlbGVjdDogXCJub25lXCJcbiAgfSwgJFswXSA9IHQwKSA6IHQwID0gJFswXTtcbiAgbGV0IHQxO1xuICByZXR1cm4gJFsxXSAhPT0gcHJvcHMuaW5saW5lT2JqZWN0Ll9rZXkgfHwgJFsyXSAhPT0gcHJvcHMuaW5saW5lT2JqZWN0Ll90eXBlID8gKHQxID0gLyogQF9fUFVSRV9fICovIGpzeHMoXCJzcGFuXCIsIHsgc3R5bGU6IHQwLCBjaGlsZHJlbjogW1xuICAgIFwiW1wiLFxuICAgIHByb3BzLmlubGluZU9iamVjdC5fdHlwZSxcbiAgICBcIjogXCIsXG4gICAgcHJvcHMuaW5saW5lT2JqZWN0Ll9rZXksXG4gICAgXCJdXCJcbiAgXSB9KSwgJFsxXSA9IHByb3BzLmlubGluZU9iamVjdC5fa2V5LCAkWzJdID0gcHJvcHMuaW5saW5lT2JqZWN0Ll90eXBlLCAkWzNdID0gdDEpIDogdDEgPSAkWzNdLCB0MTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVkaXRvclByaW9yaXR5KGNvbmZpZykge1xuICByZXR1cm4ge1xuICAgIGlkOiBkZWZhdWx0S2V5R2VuZXJhdG9yKCksXG4gICAgbmFtZTogY29uZmlnPy5uYW1lLFxuICAgIHJlZmVyZW5jZTogY29uZmlnPy5yZWZlcmVuY2VcbiAgfTtcbn1cbmNvbnN0IGNvcmVQcmlvcml0eSA9IGNyZWF0ZUVkaXRvclByaW9yaXR5KHtcbiAgbmFtZTogXCJjb3JlXCJcbn0pO1xuZnVuY3Rpb24gZ2V0RHJhZ1NlbGVjdGlvbih7XG4gIGV2ZW50U2VsZWN0aW9uLFxuICBzbmFwc2hvdFxufSkge1xuICBsZXQgZHJhZ1NlbGVjdGlvbiA9IGV2ZW50U2VsZWN0aW9uO1xuICBpZiAoZ2V0Rm9jdXNJbmxpbmVPYmplY3Qoe1xuICAgIC4uLnNuYXBzaG90LFxuICAgIGNvbnRleHQ6IHtcbiAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICBzZWxlY3Rpb246IGV2ZW50U2VsZWN0aW9uXG4gICAgfVxuICB9KSlcbiAgICByZXR1cm4gZHJhZ1NlbGVjdGlvbjtcbiAgY29uc3QgZHJhZ2dpbmdDb2xsYXBzZWRTZWxlY3Rpb24gPSBpc1NlbGVjdGlvbkNvbGxhcHNlZCQxKHtcbiAgICBjb250ZXh0OiB7XG4gICAgICAuLi5zbmFwc2hvdC5jb250ZXh0LFxuICAgICAgc2VsZWN0aW9uOiBldmVudFNlbGVjdGlvblxuICAgIH1cbiAgfSksIGRyYWdnZWRUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayh7XG4gICAgLi4uc25hcHNob3QsXG4gICAgY29udGV4dDoge1xuICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgIHNlbGVjdGlvbjogZXZlbnRTZWxlY3Rpb25cbiAgICB9XG4gIH0pLCBkcmFnZ2VkU3BhbiA9IGdldEZvY3VzU3BhbiQxKHtcbiAgICAuLi5zbmFwc2hvdCxcbiAgICBjb250ZXh0OiB7XG4gICAgICAuLi5zbmFwc2hvdC5jb250ZXh0LFxuICAgICAgc2VsZWN0aW9uOiBldmVudFNlbGVjdGlvblxuICAgIH1cbiAgfSk7XG4gIGRyYWdnaW5nQ29sbGFwc2VkU2VsZWN0aW9uICYmIGRyYWdnZWRUZXh0QmxvY2sgJiYgZHJhZ2dlZFNwYW4gJiYgKGRyYWdTZWxlY3Rpb24gPSB7XG4gICAgYW5jaG9yOiBnZXRCbG9ja1N0YXJ0UG9pbnQoe1xuICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgIGJsb2NrOiBkcmFnZ2VkVGV4dEJsb2NrXG4gICAgfSksXG4gICAgZm9jdXM6IGdldEJsb2NrRW5kUG9pbnQoe1xuICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgIGJsb2NrOiBkcmFnZ2VkVGV4dEJsb2NrXG4gICAgfSlcbiAgfSk7XG4gIGNvbnN0IHNlbGVjdGVkQmxvY2tzID0gZ2V0U2VsZWN0ZWRCbG9ja3Moc25hcHNob3QpO1xuICBpZiAoc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24gJiYgaXNTZWxlY3Rpb25FeHBhbmRlZChzbmFwc2hvdCkgJiYgc2VsZWN0ZWRCbG9ja3MubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IHNlbGVjdGlvblN0YXJ0QmxvY2sgPSBnZXRTZWxlY3Rpb25TdGFydEJsb2NrJDEoc25hcHNob3QpLCBzZWxlY3Rpb25FbmRCbG9jayA9IGdldFNlbGVjdGlvbkVuZEJsb2NrJDEoc25hcHNob3QpO1xuICAgIGlmICghc2VsZWN0aW9uU3RhcnRCbG9jayB8fCAhc2VsZWN0aW9uRW5kQmxvY2spXG4gICAgICByZXR1cm4gZHJhZ1NlbGVjdGlvbjtcbiAgICBjb25zdCBzZWxlY3Rpb25TdGFydFBvaW50ID0gZ2V0QmxvY2tTdGFydFBvaW50KHtcbiAgICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgICBibG9jazogc2VsZWN0aW9uU3RhcnRCbG9ja1xuICAgIH0pLCBzZWxlY3Rpb25FbmRQb2ludCA9IGdldEJsb2NrRW5kUG9pbnQoe1xuICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgIGJsb2NrOiBzZWxlY3Rpb25FbmRCbG9ja1xuICAgIH0pO1xuICAgIGlzT3ZlcmxhcHBpbmdTZWxlY3Rpb24oZXZlbnRTZWxlY3Rpb24pKHtcbiAgICAgIC4uLnNuYXBzaG90LFxuICAgICAgY29udGV4dDoge1xuICAgICAgICAuLi5zbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICBzZWxlY3Rpb246IHtcbiAgICAgICAgICBhbmNob3I6IHNlbGVjdGlvblN0YXJ0UG9pbnQsXG4gICAgICAgICAgZm9jdXM6IHNlbGVjdGlvbkVuZFBvaW50XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSAmJiAoZHJhZ1NlbGVjdGlvbiA9IHtcbiAgICAgIGFuY2hvcjogc2VsZWN0aW9uU3RhcnRQb2ludCxcbiAgICAgIGZvY3VzOiBzZWxlY3Rpb25FbmRQb2ludFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBkcmFnU2VsZWN0aW9uO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29yZUJsb2NrRWxlbWVudEJlaGF2aW9yc0NvbmZpZyh7XG4gIGtleSxcbiAgb25TZXREcmFnUG9zaXRpb25CbG9ja1xufSkge1xuICByZXR1cm4gW3tcbiAgICBiZWhhdmlvcjogZGVmaW5lQmVoYXZpb3Ioe1xuICAgICAgb246IFwiZHJhZy5kcmFnb3ZlclwiLFxuICAgICAgZ3VhcmQ6ICh7XG4gICAgICAgIHNuYXBzaG90LFxuICAgICAgICBldmVudFxuICAgICAgfSkgPT4ge1xuICAgICAgICBjb25zdCBkcm9wRm9jdXNCbG9jayA9IGdldEZvY3VzQmxvY2skMSh7XG4gICAgICAgICAgLi4uc25hcHNob3QsXG4gICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogZXZlbnQucG9zaXRpb24uc2VsZWN0aW9uXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFkcm9wRm9jdXNCbG9jayB8fCBkcm9wRm9jdXNCbG9jay5ub2RlLl9rZXkgIT09IGtleSlcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIGNvbnN0IGRyYWdPcmlnaW4gPSBldmVudC5kcmFnT3JpZ2luO1xuICAgICAgICBpZiAoIWRyYWdPcmlnaW4pXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICBjb25zdCBkcmFnU2VsZWN0aW9uID0gZ2V0RHJhZ1NlbGVjdGlvbih7XG4gICAgICAgICAgZXZlbnRTZWxlY3Rpb246IGRyYWdPcmlnaW4uc2VsZWN0aW9uLFxuICAgICAgICAgIHNuYXBzaG90XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZ2V0U2VsZWN0ZWRCbG9ja3Moe1xuICAgICAgICAgIC4uLnNuYXBzaG90LFxuICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgICAgICBzZWxlY3Rpb246IGRyYWdTZWxlY3Rpb25cbiAgICAgICAgICB9XG4gICAgICAgIH0pLnNvbWUoKGRyYWdnZWRCbG9jaykgPT4gZHJhZ2dlZEJsb2NrLm5vZGUuX2tleSA9PT0ga2V5KSA/ICExIDogaXNTZWxlY3RpbmdFbnRpcmVCbG9ja3Moe1xuICAgICAgICAgIC4uLnNuYXBzaG90LFxuICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgICAgICBzZWxlY3Rpb246IGRyYWdTZWxlY3Rpb25cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGFjdGlvbnM6IFsoe1xuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gW3tcbiAgICAgICAgdHlwZTogXCJlZmZlY3RcIixcbiAgICAgICAgZWZmZWN0OiAoKSA9PiB7XG4gICAgICAgICAgb25TZXREcmFnUG9zaXRpb25CbG9jayhldmVudC5wb3NpdGlvbi5ibG9jayk7XG4gICAgICAgIH1cbiAgICAgIH1dXVxuICAgIH0pLFxuICAgIHByaW9yaXR5OiBjcmVhdGVFZGl0b3JQcmlvcml0eSh7XG4gICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgcHJpb3JpdHk6IGNvcmVQcmlvcml0eSxcbiAgICAgICAgaW1wb3J0YW5jZTogXCJsb3dlclwiXG4gICAgICB9XG4gICAgfSlcbiAgfSwge1xuICAgIGJlaGF2aW9yOiBkZWZpbmVCZWhhdmlvcih7XG4gICAgICBvbjogXCJkcmFnLipcIixcbiAgICAgIGd1YXJkOiAoe1xuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gZXZlbnQudHlwZSAhPT0gXCJkcmFnLmRyYWdvdmVyXCIsXG4gICAgICBhY3Rpb25zOiBbKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IFt7XG4gICAgICAgIHR5cGU6IFwiZWZmZWN0XCIsXG4gICAgICAgIGVmZmVjdDogKCkgPT4ge1xuICAgICAgICAgIG9uU2V0RHJhZ1Bvc2l0aW9uQmxvY2sodm9pZCAwKTtcbiAgICAgICAgfVxuICAgICAgfSwgZm9yd2FyZChldmVudCldXVxuICAgIH0pLFxuICAgIHByaW9yaXR5OiBjcmVhdGVFZGl0b3JQcmlvcml0eSh7XG4gICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgcHJpb3JpdHk6IGNvcmVQcmlvcml0eSxcbiAgICAgICAgaW1wb3J0YW5jZTogXCJsb3dlclwiXG4gICAgICB9XG4gICAgfSlcbiAgfV07XG59XG5mdW5jdGlvbiB1c2VDb3JlQmxvY2tFbGVtZW50QmVoYXZpb3JzKHQwKSB7XG4gIGNvbnN0ICQgPSBjKDUpLCB7XG4gICAga2V5LFxuICAgIG9uU2V0RHJhZ1Bvc2l0aW9uQmxvY2tcbiAgfSA9IHQwLCBlZGl0b3JBY3RvciA9IHVzZUNvbnRleHQoRWRpdG9yQWN0b3JDb250ZXh0KTtcbiAgbGV0IHQxLCB0MjtcbiAgJFswXSAhPT0gZWRpdG9yQWN0b3IgfHwgJFsxXSAhPT0ga2V5IHx8ICRbMl0gIT09IG9uU2V0RHJhZ1Bvc2l0aW9uQmxvY2sgPyAodDEgPSAoKSA9PiB7XG4gICAgY29uc3QgYmVoYXZpb3JDb25maWdzID0gY3JlYXRlQ29yZUJsb2NrRWxlbWVudEJlaGF2aW9yc0NvbmZpZyh7XG4gICAgICBrZXksXG4gICAgICBvblNldERyYWdQb3NpdGlvbkJsb2NrXG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBiZWhhdmlvckNvbmZpZyBvZiBiZWhhdmlvckNvbmZpZ3MpXG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJhZGQgYmVoYXZpb3JcIixcbiAgICAgICAgYmVoYXZpb3JDb25maWdcbiAgICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGJlaGF2aW9yQ29uZmlnXzAgb2YgYmVoYXZpb3JDb25maWdzKVxuICAgICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcInJlbW92ZSBiZWhhdmlvclwiLFxuICAgICAgICAgIGJlaGF2aW9yQ29uZmlnOiBiZWhhdmlvckNvbmZpZ18wXG4gICAgICAgIH0pO1xuICAgIH07XG4gIH0sIHQyID0gW2VkaXRvckFjdG9yLCBrZXksIG9uU2V0RHJhZ1Bvc2l0aW9uQmxvY2tdLCAkWzBdID0gZWRpdG9yQWN0b3IsICRbMV0gPSBrZXksICRbMl0gPSBvblNldERyYWdQb3NpdGlvbkJsb2NrLCAkWzNdID0gdDEsICRbNF0gPSB0MikgOiAodDEgPSAkWzNdLCB0MiA9ICRbNF0pLCB1c2VFZmZlY3QodDEsIHQyKTtcbn1cbmZ1bmN0aW9uIFJlbmRlckJsb2NrT2JqZWN0KHByb3BzKSB7XG4gIGNvbnN0ICQgPSBjKDM1KSwgW2RyYWdQb3NpdGlvbkJsb2NrLCBzZXREcmFnUG9zaXRpb25CbG9ja10gPSB1c2VTdGF0ZSgpLCBibG9ja09iamVjdFJlZiA9IHVzZVJlZihudWxsKSwgc2VsZWN0ZWQgPSB1c2VTZWxlY3RlZCgpO1xuICBsZXQgdDA7XG4gICRbMF0gIT09IHNlbGVjdGVkID8gKHQwID0gKGVkaXRvcikgPT4gc2VsZWN0ZWQgJiYgZWRpdG9yLnNlbGVjdGlvbiAhPT0gbnVsbCAmJiBSYW5nZS5pc0NvbGxhcHNlZChlZGl0b3Iuc2VsZWN0aW9uKSwgJFswXSA9IHNlbGVjdGVkLCAkWzFdID0gdDApIDogdDAgPSAkWzFdO1xuICBjb25zdCBmb2N1c2VkID0gdXNlU2xhdGVTZWxlY3Rvcih0MCk7XG4gIGxldCB0MTtcbiAgJFsyXSAhPT0gcHJvcHMuZWxlbWVudC5fa2V5ID8gKHQxID0ge1xuICAgIGtleTogcHJvcHMuZWxlbWVudC5fa2V5LFxuICAgIG9uU2V0RHJhZ1Bvc2l0aW9uQmxvY2s6IHNldERyYWdQb3NpdGlvbkJsb2NrXG4gIH0sICRbMl0gPSBwcm9wcy5lbGVtZW50Ll9rZXksICRbM10gPSB0MSkgOiB0MSA9ICRbM10sIHVzZUNvcmVCbG9ja0VsZW1lbnRCZWhhdmlvcnModDEpO1xuICBsZXQgdDI7XG4gIGlmICgkWzRdICE9PSBwcm9wcy5lbGVtZW50Ll90eXBlIHx8ICRbNV0gIT09IHByb3BzLmxlZ2FjeVNjaGVtYS5ibG9ja09iamVjdHMpIHtcbiAgICBsZXQgdDMyO1xuICAgICRbN10gIT09IHByb3BzLmVsZW1lbnQuX3R5cGUgPyAodDMyID0gKHNjaGVtYVR5cGUpID0+IHNjaGVtYVR5cGUubmFtZSA9PT0gcHJvcHMuZWxlbWVudC5fdHlwZSwgJFs3XSA9IHByb3BzLmVsZW1lbnQuX3R5cGUsICRbOF0gPSB0MzIpIDogdDMyID0gJFs4XSwgdDIgPSBwcm9wcy5sZWdhY3lTY2hlbWEuYmxvY2tPYmplY3RzLmZpbmQodDMyKSwgJFs0XSA9IHByb3BzLmVsZW1lbnQuX3R5cGUsICRbNV0gPSBwcm9wcy5sZWdhY3lTY2hlbWEuYmxvY2tPYmplY3RzLCAkWzZdID0gdDI7XG4gIH0gZWxzZVxuICAgIHQyID0gJFs2XTtcbiAgY29uc3QgbGVnYWN5U2NoZW1hVHlwZSA9IHQyO1xuICBsZWdhY3lTY2hlbWFUeXBlIHx8IGNvbnNvbGUuZXJyb3IoYFVuYWJsZSB0byBmaW5kIEJsb2NrIE9iamVjdCBcIiR7cHJvcHMuZWxlbWVudC5fdHlwZX1cIiBpbiBTY2hlbWFgKTtcbiAgbGV0IHQzO1xuICAkWzldICE9PSBwcm9wcy5ibG9ja09iamVjdCB8fCAkWzEwXSAhPT0gcHJvcHMuZWxlbWVudC5fa2V5IHx8ICRbMTFdICE9PSBwcm9wcy5lbGVtZW50Ll90eXBlID8gKHQzID0gcHJvcHMuYmxvY2tPYmplY3QgPz8ge1xuICAgIF9rZXk6IHByb3BzLmVsZW1lbnQuX2tleSxcbiAgICBfdHlwZTogcHJvcHMuZWxlbWVudC5fdHlwZVxuICB9LCAkWzldID0gcHJvcHMuYmxvY2tPYmplY3QsICRbMTBdID0gcHJvcHMuZWxlbWVudC5fa2V5LCAkWzExXSA9IHByb3BzLmVsZW1lbnQuX3R5cGUsICRbMTJdID0gdDMpIDogdDMgPSAkWzEyXTtcbiAgY29uc3QgYmxvY2tPYmplY3QgPSB0MztcbiAgbGV0IHQ0O1xuICAkWzEzXSAhPT0gZHJhZ1Bvc2l0aW9uQmxvY2sgPyAodDQgPSBkcmFnUG9zaXRpb25CbG9jayA9PT0gXCJzdGFydFwiID8gLyogQF9fUFVSRV9fICovIGpzeChEcm9wSW5kaWNhdG9yLCB7fSkgOiBudWxsLCAkWzEzXSA9IGRyYWdQb3NpdGlvbkJsb2NrLCAkWzE0XSA9IHQ0KSA6IHQ0ID0gJFsxNF07XG4gIGNvbnN0IHQ1ID0gIXByb3BzLnJlYWRPbmx5O1xuICBsZXQgdDY7XG4gICRbMTVdICE9PSBibG9ja09iamVjdCB8fCAkWzE2XSAhPT0gZm9jdXNlZCB8fCAkWzE3XSAhPT0gbGVnYWN5U2NoZW1hVHlwZSB8fCAkWzE4XSAhPT0gcHJvcHMuZWxlbWVudC5fa2V5IHx8ICRbMTldICE9PSBwcm9wcy5yZW5kZXJCbG9jayB8fCAkWzIwXSAhPT0gc2VsZWN0ZWQgPyAodDYgPSBwcm9wcy5yZW5kZXJCbG9jayAmJiBsZWdhY3lTY2hlbWFUeXBlID8gLyogQF9fUFVSRV9fICovIGpzeChSZW5kZXJCbG9jayQxLCB7IHJlbmRlckJsb2NrOiBwcm9wcy5yZW5kZXJCbG9jaywgZWRpdG9yRWxlbWVudFJlZjogYmxvY2tPYmplY3RSZWYsIGZvY3VzZWQsIHBhdGg6IFt7XG4gICAgX2tleTogcHJvcHMuZWxlbWVudC5fa2V5XG4gIH1dLCBzY2hlbWFUeXBlOiBsZWdhY3lTY2hlbWFUeXBlLCBzZWxlY3RlZCwgdHlwZTogbGVnYWN5U2NoZW1hVHlwZSwgdmFsdWU6IGJsb2NrT2JqZWN0LCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChSZW5kZXJEZWZhdWx0QmxvY2tPYmplY3QsIHsgYmxvY2tPYmplY3QgfSkgfSkgOiAvKiBAX19QVVJFX18gKi8ganN4KFJlbmRlckRlZmF1bHRCbG9ja09iamVjdCwgeyBibG9ja09iamVjdCB9KSwgJFsxNV0gPSBibG9ja09iamVjdCwgJFsxNl0gPSBmb2N1c2VkLCAkWzE3XSA9IGxlZ2FjeVNjaGVtYVR5cGUsICRbMThdID0gcHJvcHMuZWxlbWVudC5fa2V5LCAkWzE5XSA9IHByb3BzLnJlbmRlckJsb2NrLCAkWzIwXSA9IHNlbGVjdGVkLCAkWzIxXSA9IHQ2KSA6IHQ2ID0gJFsyMV07XG4gIGxldCB0NztcbiAgJFsyMl0gIT09IHQ1IHx8ICRbMjNdICE9PSB0NiA/ICh0NyA9IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwgeyByZWY6IGJsb2NrT2JqZWN0UmVmLCBjb250ZW50RWRpdGFibGU6ICExLCBkcmFnZ2FibGU6IHQ1LCBjaGlsZHJlbjogdDYgfSksICRbMjJdID0gdDUsICRbMjNdID0gdDYsICRbMjRdID0gdDcpIDogdDcgPSAkWzI0XTtcbiAgbGV0IHQ4O1xuICAkWzI1XSAhPT0gZHJhZ1Bvc2l0aW9uQmxvY2sgPyAodDggPSBkcmFnUG9zaXRpb25CbG9jayA9PT0gXCJlbmRcIiA/IC8qIEBfX1BVUkVfXyAqLyBqc3goRHJvcEluZGljYXRvciwge30pIDogbnVsbCwgJFsyNV0gPSBkcmFnUG9zaXRpb25CbG9jaywgJFsyNl0gPSB0OCkgOiB0OCA9ICRbMjZdO1xuICBsZXQgdDk7XG4gIHJldHVybiAkWzI3XSAhPT0gcHJvcHMuYXR0cmlidXRlcyB8fCAkWzI4XSAhPT0gcHJvcHMuY2hpbGRyZW4gfHwgJFsyOV0gIT09IHByb3BzLmVsZW1lbnQuX2tleSB8fCAkWzMwXSAhPT0gcHJvcHMuZWxlbWVudC5fdHlwZSB8fCAkWzMxXSAhPT0gdDQgfHwgJFszMl0gIT09IHQ3IHx8ICRbMzNdICE9PSB0OCA/ICh0OSA9IC8qIEBfX1BVUkVfXyAqLyBqc3hzKFwiZGl2XCIsIHsgLi4ucHJvcHMuYXR0cmlidXRlcywgY2xhc3NOYW1lOiBcInB0LWJsb2NrIHB0LW9iamVjdC1ibG9ja1wiLCBcImRhdGEtYmxvY2sta2V5XCI6IHByb3BzLmVsZW1lbnQuX2tleSwgXCJkYXRhLWJsb2NrLW5hbWVcIjogcHJvcHMuZWxlbWVudC5fdHlwZSwgXCJkYXRhLWJsb2NrLXR5cGVcIjogXCJvYmplY3RcIiwgY2hpbGRyZW46IFtcbiAgICB0NCxcbiAgICBwcm9wcy5jaGlsZHJlbixcbiAgICB0NyxcbiAgICB0OFxuICBdIH0pLCAkWzI3XSA9IHByb3BzLmF0dHJpYnV0ZXMsICRbMjhdID0gcHJvcHMuY2hpbGRyZW4sICRbMjldID0gcHJvcHMuZWxlbWVudC5fa2V5LCAkWzMwXSA9IHByb3BzLmVsZW1lbnQuX3R5cGUsICRbMzFdID0gdDQsICRbMzJdID0gdDcsICRbMzNdID0gdDgsICRbMzRdID0gdDkpIDogdDkgPSAkWzM0XSwgdDk7XG59XG5mdW5jdGlvbiBSZW5kZXJCbG9jayQxKHtcbiAgcmVuZGVyQmxvY2ssXG4gIGNoaWxkcmVuLFxuICBlZGl0b3JFbGVtZW50UmVmLFxuICBmb2N1c2VkLFxuICBwYXRoLFxuICBzY2hlbWFUeXBlLFxuICBzZWxlY3RlZCxcbiAgdHlwZSxcbiAgdmFsdWVcbn0pIHtcbiAgcmV0dXJuIHJlbmRlckJsb2NrKHtcbiAgICBjaGlsZHJlbixcbiAgICBlZGl0b3JFbGVtZW50UmVmLFxuICAgIGZvY3VzZWQsXG4gICAgcGF0aCxcbiAgICBzY2hlbWFUeXBlLFxuICAgIHNlbGVjdGVkLFxuICAgIHR5cGUsXG4gICAgdmFsdWVcbiAgfSk7XG59XG5mdW5jdGlvbiBSZW5kZXJJbmxpbmVPYmplY3QocHJvcHMpIHtcbiAgY29uc3QgJCA9IGMoMzIpLCBpbmxpbmVPYmplY3RSZWYgPSB1c2VSZWYobnVsbCksIHNsYXRlRWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKSwgc2VsZWN0ZWQgPSB1c2VTZWxlY3RlZCgpO1xuICBsZXQgdDA7XG4gICRbMF0gIT09IHNlbGVjdGVkID8gKHQwID0gKGVkaXRvcikgPT4gc2VsZWN0ZWQgJiYgZWRpdG9yLnNlbGVjdGlvbiAhPT0gbnVsbCAmJiBSYW5nZS5pc0NvbGxhcHNlZChlZGl0b3Iuc2VsZWN0aW9uKSwgJFswXSA9IHNlbGVjdGVkLCAkWzFdID0gdDApIDogdDAgPSAkWzFdO1xuICBjb25zdCBmb2N1c2VkID0gdXNlU2xhdGVTZWxlY3Rvcih0MCk7XG4gIGxldCB0MTtcbiAgaWYgKCRbMl0gIT09IHByb3BzLmVsZW1lbnQuX3R5cGUgfHwgJFszXSAhPT0gcHJvcHMubGVnYWN5U2NoZW1hLmlubGluZU9iamVjdHMpIHtcbiAgICBsZXQgdDIyO1xuICAgICRbNV0gIT09IHByb3BzLmVsZW1lbnQuX3R5cGUgPyAodDIyID0gKGlubGluZU9iamVjdCkgPT4gaW5saW5lT2JqZWN0Lm5hbWUgPT09IHByb3BzLmVsZW1lbnQuX3R5cGUsICRbNV0gPSBwcm9wcy5lbGVtZW50Ll90eXBlLCAkWzZdID0gdDIyKSA6IHQyMiA9ICRbNl0sIHQxID0gcHJvcHMubGVnYWN5U2NoZW1hLmlubGluZU9iamVjdHMuZmluZCh0MjIpLCAkWzJdID0gcHJvcHMuZWxlbWVudC5fdHlwZSwgJFszXSA9IHByb3BzLmxlZ2FjeVNjaGVtYS5pbmxpbmVPYmplY3RzLCAkWzRdID0gdDE7XG4gIH0gZWxzZVxuICAgIHQxID0gJFs0XTtcbiAgY29uc3QgbGVnYWN5U2NoZW1hVHlwZSA9IHQxO1xuICBsZWdhY3lTY2hlbWFUeXBlIHx8IGNvbnNvbGUuZXJyb3IoYFVuYWJsZSB0byBmaW5kIElubGluZSBPYmplY3QgXCIke3Byb3BzLmVsZW1lbnQuX3R5cGV9XCIgaW4gU2NoZW1hYCk7XG4gIGxldCB0MjtcbiAgaWYgKCRbN10gIT09IHByb3BzLmVsZW1lbnQgfHwgJFs4XSAhPT0gc2xhdGVFZGl0b3IpIHtcbiAgICBjb25zdCBwYXRoID0gRE9NRWRpdG9yLmZpbmRQYXRoKHNsYXRlRWRpdG9yLCBwcm9wcy5lbGVtZW50KTtcbiAgICB0MiA9IGdldFBvaW50QmxvY2soe1xuICAgICAgZWRpdG9yOiBzbGF0ZUVkaXRvcixcbiAgICAgIHBvaW50OiB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfVxuICAgIH0pLCAkWzddID0gcHJvcHMuZWxlbWVudCwgJFs4XSA9IHNsYXRlRWRpdG9yLCAkWzldID0gdDI7XG4gIH0gZWxzZVxuICAgIHQyID0gJFs5XTtcbiAgY29uc3QgW2Jsb2NrXSA9IHQyO1xuICBibG9jayB8fCBjb25zb2xlLmVycm9yKGBVbmFibGUgdG8gZmluZCBwYXJlbnQgYmxvY2sgb2YgaW5saW5lIG9iamVjdCAke3Byb3BzLmVsZW1lbnQuX2tleX1gKTtcbiAgbGV0IHQzO1xuICAkWzEwXSAhPT0gcHJvcHMuZWxlbWVudCA/ICh0MyA9IFwidmFsdWVcIiBpbiBwcm9wcy5lbGVtZW50ICYmIHR5cGVvZiBwcm9wcy5lbGVtZW50LnZhbHVlID09IFwib2JqZWN0XCIgPyBwcm9wcy5lbGVtZW50LnZhbHVlIDoge30sICRbMTBdID0gcHJvcHMuZWxlbWVudCwgJFsxMV0gPSB0MykgOiB0MyA9ICRbMTFdO1xuICBsZXQgdDQ7XG4gICRbMTJdICE9PSBwcm9wcy5lbGVtZW50Ll9rZXkgfHwgJFsxM10gIT09IHByb3BzLmVsZW1lbnQuX3R5cGUgfHwgJFsxNF0gIT09IHQzID8gKHQ0ID0ge1xuICAgIF9rZXk6IHByb3BzLmVsZW1lbnQuX2tleSxcbiAgICBfdHlwZTogcHJvcHMuZWxlbWVudC5fdHlwZSxcbiAgICAuLi50M1xuICB9LCAkWzEyXSA9IHByb3BzLmVsZW1lbnQuX2tleSwgJFsxM10gPSBwcm9wcy5lbGVtZW50Ll90eXBlLCAkWzE0XSA9IHQzLCAkWzE1XSA9IHQ0KSA6IHQ0ID0gJFsxNV07XG4gIGNvbnN0IGlubGluZU9iamVjdF8wID0gdDQsIHQ1ID0gIXByb3BzLnJlYWRPbmx5O1xuICBsZXQgdDY7XG4gICRbMTZdID09PSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb19jYWNoZV9zZW50aW5lbFwiKSA/ICh0NiA9IHtcbiAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiXG4gIH0sICRbMTZdID0gdDYpIDogdDYgPSAkWzE2XTtcbiAgbGV0IHQ3O1xuICAkWzE3XSAhPT0gYmxvY2sgfHwgJFsxOF0gIT09IGZvY3VzZWQgfHwgJFsxOV0gIT09IGlubGluZU9iamVjdF8wIHx8ICRbMjBdICE9PSBsZWdhY3lTY2hlbWFUeXBlIHx8ICRbMjFdICE9PSBwcm9wcy5lbGVtZW50Ll9rZXkgfHwgJFsyMl0gIT09IHByb3BzLnJlbmRlckNoaWxkIHx8ICRbMjNdICE9PSBzZWxlY3RlZCA/ICh0NyA9IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzcGFuXCIsIHsgcmVmOiBpbmxpbmVPYmplY3RSZWYsIHN0eWxlOiB0NiwgY2hpbGRyZW46IHByb3BzLnJlbmRlckNoaWxkICYmIGJsb2NrICYmIGxlZ2FjeVNjaGVtYVR5cGUgPyAvKiBAX19QVVJFX18gKi8ganN4KFJlbmRlckNoaWxkJDEsIHsgcmVuZGVyQ2hpbGQ6IHByb3BzLnJlbmRlckNoaWxkLCBhbm5vdGF0aW9uczogW10sIGVkaXRvckVsZW1lbnRSZWY6IGlubGluZU9iamVjdFJlZiwgc2VsZWN0ZWQsIGZvY3VzZWQsIHBhdGg6IFt7XG4gICAgX2tleTogYmxvY2suX2tleVxuICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICBfa2V5OiBwcm9wcy5lbGVtZW50Ll9rZXlcbiAgfV0sIHNjaGVtYVR5cGU6IGxlZ2FjeVNjaGVtYVR5cGUsIHZhbHVlOiBpbmxpbmVPYmplY3RfMCwgdHlwZTogbGVnYWN5U2NoZW1hVHlwZSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goUmVuZGVyRGVmYXVsdElubGluZU9iamVjdCwgeyBpbmxpbmVPYmplY3Q6IGlubGluZU9iamVjdF8wIH0pIH0pIDogLyogQF9fUFVSRV9fICovIGpzeChSZW5kZXJEZWZhdWx0SW5saW5lT2JqZWN0LCB7IGlubGluZU9iamVjdDogaW5saW5lT2JqZWN0XzAgfSkgfSksICRbMTddID0gYmxvY2ssICRbMThdID0gZm9jdXNlZCwgJFsxOV0gPSBpbmxpbmVPYmplY3RfMCwgJFsyMF0gPSBsZWdhY3lTY2hlbWFUeXBlLCAkWzIxXSA9IHByb3BzLmVsZW1lbnQuX2tleSwgJFsyMl0gPSBwcm9wcy5yZW5kZXJDaGlsZCwgJFsyM10gPSBzZWxlY3RlZCwgJFsyNF0gPSB0NykgOiB0NyA9ICRbMjRdO1xuICBsZXQgdDg7XG4gIHJldHVybiAkWzI1XSAhPT0gaW5saW5lT2JqZWN0XzAuX2tleSB8fCAkWzI2XSAhPT0gaW5saW5lT2JqZWN0XzAuX3R5cGUgfHwgJFsyN10gIT09IHByb3BzLmF0dHJpYnV0ZXMgfHwgJFsyOF0gIT09IHByb3BzLmNoaWxkcmVuIHx8ICRbMjldICE9PSB0NSB8fCAkWzMwXSAhPT0gdDcgPyAodDggPSAvKiBAX19QVVJFX18gKi8ganN4cyhcInNwYW5cIiwgeyAuLi5wcm9wcy5hdHRyaWJ1dGVzLCBkcmFnZ2FibGU6IHQ1LCBjbGFzc05hbWU6IFwicHQtaW5saW5lLW9iamVjdFwiLCBcImRhdGEtY2hpbGQta2V5XCI6IGlubGluZU9iamVjdF8wLl9rZXksIFwiZGF0YS1jaGlsZC1uYW1lXCI6IGlubGluZU9iamVjdF8wLl90eXBlLCBcImRhdGEtY2hpbGQtdHlwZVwiOiBcIm9iamVjdFwiLCBjaGlsZHJlbjogW1xuICAgIHByb3BzLmNoaWxkcmVuLFxuICAgIHQ3XG4gIF0gfSksICRbMjVdID0gaW5saW5lT2JqZWN0XzAuX2tleSwgJFsyNl0gPSBpbmxpbmVPYmplY3RfMC5fdHlwZSwgJFsyN10gPSBwcm9wcy5hdHRyaWJ1dGVzLCAkWzI4XSA9IHByb3BzLmNoaWxkcmVuLCAkWzI5XSA9IHQ1LCAkWzMwXSA9IHQ3LCAkWzMxXSA9IHQ4KSA6IHQ4ID0gJFszMV0sIHQ4O1xufVxuZnVuY3Rpb24gUmVuZGVyQ2hpbGQkMSh7XG4gIHJlbmRlckNoaWxkLFxuICBhbm5vdGF0aW9ucyxcbiAgY2hpbGRyZW4sXG4gIGVkaXRvckVsZW1lbnRSZWYsXG4gIGZvY3VzZWQsXG4gIHBhdGgsXG4gIHNjaGVtYVR5cGUsXG4gIHNlbGVjdGVkLFxuICB2YWx1ZSxcbiAgdHlwZVxufSkge1xuICByZXR1cm4gcmVuZGVyQ2hpbGQoe1xuICAgIGFubm90YXRpb25zLFxuICAgIGNoaWxkcmVuLFxuICAgIGVkaXRvckVsZW1lbnRSZWYsXG4gICAgZm9jdXNlZCxcbiAgICBwYXRoLFxuICAgIHNjaGVtYVR5cGUsXG4gICAgc2VsZWN0ZWQsXG4gICAgdmFsdWUsXG4gICAgdHlwZVxuICB9KTtcbn1cbmZ1bmN0aW9uIFJlbmRlclRleHRCbG9jayhwcm9wcykge1xuICBjb25zdCAkID0gYyg3NyksIFtkcmFnUG9zaXRpb25CbG9jaywgc2V0RHJhZ1Bvc2l0aW9uQmxvY2tdID0gdXNlU3RhdGUoKSwgYmxvY2tSZWYgPSB1c2VSZWYobnVsbCksIHNlbGVjdGVkID0gdXNlU2VsZWN0ZWQoKTtcbiAgbGV0IHQwO1xuICAkWzBdICE9PSBzZWxlY3RlZCA/ICh0MCA9IChlZGl0b3IpID0+IHNlbGVjdGVkICYmIGVkaXRvci5zZWxlY3Rpb24gIT09IG51bGwgJiYgUmFuZ2UuaXNDb2xsYXBzZWQoZWRpdG9yLnNlbGVjdGlvbiksICRbMF0gPSBzZWxlY3RlZCwgJFsxXSA9IHQwKSA6IHQwID0gJFsxXTtcbiAgY29uc3QgZm9jdXNlZCA9IHVzZVNsYXRlU2VsZWN0b3IodDApO1xuICBsZXQgdDE7XG4gICRbMl0gIT09IHByb3BzLmVsZW1lbnQuX2tleSA/ICh0MSA9IHtcbiAgICBrZXk6IHByb3BzLmVsZW1lbnQuX2tleSxcbiAgICBvblNldERyYWdQb3NpdGlvbkJsb2NrOiBzZXREcmFnUG9zaXRpb25CbG9ja1xuICB9LCAkWzJdID0gcHJvcHMuZWxlbWVudC5fa2V5LCAkWzNdID0gdDEpIDogdDEgPSAkWzNdLCB1c2VDb3JlQmxvY2tFbGVtZW50QmVoYXZpb3JzKHQxKTtcbiAgbGV0IHQyO1xuICAkWzRdICE9PSBwcm9wcy50ZXh0QmxvY2suX2tleSA/ICh0MiA9IChlZGl0b3JfMCkgPT4gZWRpdG9yXzAubGlzdEluZGV4TWFwLmdldChwcm9wcy50ZXh0QmxvY2suX2tleSksICRbNF0gPSBwcm9wcy50ZXh0QmxvY2suX2tleSwgJFs1XSA9IHQyKSA6IHQyID0gJFs1XTtcbiAgY29uc3QgbGlzdEluZGV4ID0gdXNlU2xhdGVTZWxlY3Rvcih0Mik7XG4gIGxldCBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICBpZiAocHJvcHMucmVuZGVyU3R5bGUgJiYgcHJvcHMudGV4dEJsb2NrLnN0eWxlKSB7XG4gICAgbGV0IHQzMjtcbiAgICAkWzZdICE9PSBwcm9wcy5sZWdhY3lTY2hlbWEgfHwgJFs3XSAhPT0gcHJvcHMudGV4dEJsb2NrLnN0eWxlID8gKHQzMiA9IHByb3BzLnRleHRCbG9jay5zdHlsZSAhPT0gdm9pZCAwID8gcHJvcHMubGVnYWN5U2NoZW1hLnN0eWxlcy5maW5kKChzdHlsZSkgPT4gc3R5bGUudmFsdWUgPT09IHByb3BzLnRleHRCbG9jay5zdHlsZSkgOiB2b2lkIDAsICRbNl0gPSBwcm9wcy5sZWdhY3lTY2hlbWEsICRbN10gPSBwcm9wcy50ZXh0QmxvY2suc3R5bGUsICRbOF0gPSB0MzIpIDogdDMyID0gJFs4XTtcbiAgICBjb25zdCBsZWdhY3lTdHlsZVNjaGVtYVR5cGUgPSB0MzI7XG4gICAgaWYgKGxlZ2FjeVN0eWxlU2NoZW1hVHlwZSkge1xuICAgICAgbGV0IHQ0MjtcbiAgICAgICRbOV0gIT09IHByb3BzLnRleHRCbG9jay5fa2V5ID8gKHQ0MiA9IFt7XG4gICAgICAgIF9rZXk6IHByb3BzLnRleHRCbG9jay5fa2V5XG4gICAgICB9XSwgJFs5XSA9IHByb3BzLnRleHRCbG9jay5fa2V5LCAkWzEwXSA9IHQ0MikgOiB0NDIgPSAkWzEwXTtcbiAgICAgIGxldCB0NTI7XG4gICAgICAkWzExXSAhPT0gY2hpbGRyZW4gfHwgJFsxMl0gIT09IGZvY3VzZWQgfHwgJFsxM10gIT09IGxlZ2FjeVN0eWxlU2NoZW1hVHlwZSB8fCAkWzE0XSAhPT0gcHJvcHMucmVuZGVyU3R5bGUgfHwgJFsxNV0gIT09IHByb3BzLnRleHRCbG9jayB8fCAkWzE2XSAhPT0gc2VsZWN0ZWQgfHwgJFsxN10gIT09IHQ0MiA/ICh0NTIgPSAvKiBAX19QVVJFX18gKi8ganN4KFJlbmRlclN0eWxlLCB7IHJlbmRlclN0eWxlOiBwcm9wcy5yZW5kZXJTdHlsZSwgYmxvY2s6IHByb3BzLnRleHRCbG9jaywgZWRpdG9yRWxlbWVudFJlZjogYmxvY2tSZWYsIGZvY3VzZWQsIHBhdGg6IHQ0Miwgc2NoZW1hVHlwZTogbGVnYWN5U3R5bGVTY2hlbWFUeXBlLCBzZWxlY3RlZCwgdmFsdWU6IHByb3BzLnRleHRCbG9jay5zdHlsZSwgY2hpbGRyZW4gfSksICRbMTFdID0gY2hpbGRyZW4sICRbMTJdID0gZm9jdXNlZCwgJFsxM10gPSBsZWdhY3lTdHlsZVNjaGVtYVR5cGUsICRbMTRdID0gcHJvcHMucmVuZGVyU3R5bGUsICRbMTVdID0gcHJvcHMudGV4dEJsb2NrLCAkWzE2XSA9IHNlbGVjdGVkLCAkWzE3XSA9IHQ0MiwgJFsxOF0gPSB0NTIpIDogdDUyID0gJFsxOF0sIGNoaWxkcmVuID0gdDUyO1xuICAgIH0gZWxzZVxuICAgICAgY29uc29sZS5lcnJvcihgVW5hYmxlIHRvIGZpbmQgU2NoZW1hIHR5cGUgZm9yIHRleHQgYmxvY2sgc3R5bGUgJHtwcm9wcy50ZXh0QmxvY2suc3R5bGV9YCk7XG4gIH1cbiAgaWYgKHByb3BzLnJlbmRlckxpc3RJdGVtICYmIHByb3BzLnRleHRCbG9jay5saXN0SXRlbSkge1xuICAgIGxldCB0MzI7XG4gICAgaWYgKCRbMTldICE9PSBwcm9wcy5sZWdhY3lTY2hlbWEubGlzdHMgfHwgJFsyMF0gIT09IHByb3BzLnRleHRCbG9jay5saXN0SXRlbSkge1xuICAgICAgbGV0IHQ0MjtcbiAgICAgICRbMjJdICE9PSBwcm9wcy50ZXh0QmxvY2subGlzdEl0ZW0gPyAodDQyID0gKGxpc3QpID0+IGxpc3QudmFsdWUgPT09IHByb3BzLnRleHRCbG9jay5saXN0SXRlbSwgJFsyMl0gPSBwcm9wcy50ZXh0QmxvY2subGlzdEl0ZW0sICRbMjNdID0gdDQyKSA6IHQ0MiA9ICRbMjNdLCB0MzIgPSBwcm9wcy5sZWdhY3lTY2hlbWEubGlzdHMuZmluZCh0NDIpLCAkWzE5XSA9IHByb3BzLmxlZ2FjeVNjaGVtYS5saXN0cywgJFsyMF0gPSBwcm9wcy50ZXh0QmxvY2subGlzdEl0ZW0sICRbMjFdID0gdDMyO1xuICAgIH0gZWxzZVxuICAgICAgdDMyID0gJFsyMV07XG4gICAgY29uc3QgbGVnYWN5TGlzdEl0ZW1TY2hlbWFUeXBlID0gdDMyO1xuICAgIGlmIChsZWdhY3lMaXN0SXRlbVNjaGVtYVR5cGUpIHtcbiAgICAgIGNvbnN0IHQ0MiA9IHByb3BzLnRleHRCbG9jay5sZXZlbCA/PyAxO1xuICAgICAgbGV0IHQ1MjtcbiAgICAgICRbMjRdICE9PSBwcm9wcy50ZXh0QmxvY2suX2tleSA/ICh0NTIgPSBbe1xuICAgICAgICBfa2V5OiBwcm9wcy50ZXh0QmxvY2suX2tleVxuICAgICAgfV0sICRbMjRdID0gcHJvcHMudGV4dEJsb2NrLl9rZXksICRbMjVdID0gdDUyKSA6IHQ1MiA9ICRbMjVdO1xuICAgICAgbGV0IHQ2MjtcbiAgICAgICRbMjZdICE9PSBjaGlsZHJlbiB8fCAkWzI3XSAhPT0gZm9jdXNlZCB8fCAkWzI4XSAhPT0gbGVnYWN5TGlzdEl0ZW1TY2hlbWFUeXBlIHx8ICRbMjldICE9PSBwcm9wcy5yZW5kZXJMaXN0SXRlbSB8fCAkWzMwXSAhPT0gcHJvcHMudGV4dEJsb2NrIHx8ICRbMzFdICE9PSBzZWxlY3RlZCB8fCAkWzMyXSAhPT0gdDQyIHx8ICRbMzNdICE9PSB0NTIgPyAodDYyID0gLyogQF9fUFVSRV9fICovIGpzeChSZW5kZXJMaXN0SXRlbSwgeyByZW5kZXJMaXN0SXRlbTogcHJvcHMucmVuZGVyTGlzdEl0ZW0sIGJsb2NrOiBwcm9wcy50ZXh0QmxvY2ssIGVkaXRvckVsZW1lbnRSZWY6IGJsb2NrUmVmLCBmb2N1c2VkLCBsZXZlbDogdDQyLCBwYXRoOiB0NTIsIHNlbGVjdGVkLCB2YWx1ZTogcHJvcHMudGV4dEJsb2NrLmxpc3RJdGVtLCBzY2hlbWFUeXBlOiBsZWdhY3lMaXN0SXRlbVNjaGVtYVR5cGUsIGNoaWxkcmVuIH0pLCAkWzI2XSA9IGNoaWxkcmVuLCAkWzI3XSA9IGZvY3VzZWQsICRbMjhdID0gbGVnYWN5TGlzdEl0ZW1TY2hlbWFUeXBlLCAkWzI5XSA9IHByb3BzLnJlbmRlckxpc3RJdGVtLCAkWzMwXSA9IHByb3BzLnRleHRCbG9jaywgJFszMV0gPSBzZWxlY3RlZCwgJFszMl0gPSB0NDIsICRbMzNdID0gdDUyLCAkWzM0XSA9IHQ2MikgOiB0NjIgPSAkWzM0XSwgY2hpbGRyZW4gPSB0NjI7XG4gICAgfSBlbHNlXG4gICAgICBjb25zb2xlLmVycm9yKGBVbmFibGUgdG8gZmluZCBTY2hlbWEgdHlwZSBmb3IgdGV4dCBibG9jayBsaXN0IGl0ZW0gJHtwcm9wcy50ZXh0QmxvY2subGlzdEl0ZW19YCk7XG4gIH1cbiAgY29uc3QgdDMgPSBwcm9wcy5hdHRyaWJ1dGVzO1xuICBsZXQgdDQ7XG4gICRbMzVdICE9PSBwcm9wcy50ZXh0QmxvY2suc3R5bGUgPyAodDQgPSBwcm9wcy50ZXh0QmxvY2suc3R5bGUgPyBbYHB0LXRleHQtYmxvY2stc3R5bGUtJHtwcm9wcy50ZXh0QmxvY2suc3R5bGV9YF0gOiBbXSwgJFszNV0gPSBwcm9wcy50ZXh0QmxvY2suc3R5bGUsICRbMzZdID0gdDQpIDogdDQgPSAkWzM2XTtcbiAgbGV0IHQ1O1xuICAkWzM3XSAhPT0gcHJvcHMudGV4dEJsb2NrLmxldmVsIHx8ICRbMzhdICE9PSBwcm9wcy50ZXh0QmxvY2subGlzdEl0ZW0gPyAodDUgPSBwcm9wcy50ZXh0QmxvY2subGlzdEl0ZW0gPyBbXCJwdC1saXN0LWl0ZW1cIiwgYHB0LWxpc3QtaXRlbS0ke3Byb3BzLnRleHRCbG9jay5saXN0SXRlbX1gLCBgcHQtbGlzdC1pdGVtLWxldmVsLSR7cHJvcHMudGV4dEJsb2NrLmxldmVsID8/IDF9YF0gOiBbXSwgJFszN10gPSBwcm9wcy50ZXh0QmxvY2subGV2ZWwsICRbMzhdID0gcHJvcHMudGV4dEJsb2NrLmxpc3RJdGVtLCAkWzM5XSA9IHQ1KSA6IHQ1ID0gJFszOV07XG4gIGxldCB0NjtcbiAgJFs0MF0gIT09IHQ0IHx8ICRbNDFdICE9PSB0NSA/ICh0NiA9IFtcInB0LWJsb2NrXCIsIFwicHQtdGV4dC1ibG9ja1wiLCAuLi50NCwgLi4udDVdLCAkWzQwXSA9IHQ0LCAkWzQxXSA9IHQ1LCAkWzQyXSA9IHQ2KSA6IHQ2ID0gJFs0Ml07XG4gIGNvbnN0IHQ3ID0gdDYuam9pbihcIiBcIik7XG4gIGxldCB0ODtcbiAgJFs0M10gIT09IHByb3BzLnRleHRCbG9jay5saXN0SXRlbSA/ICh0OCA9IHByb3BzLnRleHRCbG9jay5saXN0SXRlbSAhPT0gdm9pZCAwID8ge1xuICAgIFwiZGF0YS1saXN0LWl0ZW1cIjogcHJvcHMudGV4dEJsb2NrLmxpc3RJdGVtXG4gIH0gOiB7fSwgJFs0M10gPSBwcm9wcy50ZXh0QmxvY2subGlzdEl0ZW0sICRbNDRdID0gdDgpIDogdDggPSAkWzQ0XTtcbiAgbGV0IHQ5O1xuICAkWzQ1XSAhPT0gcHJvcHMudGV4dEJsb2NrLmxldmVsID8gKHQ5ID0gcHJvcHMudGV4dEJsb2NrLmxldmVsICE9PSB2b2lkIDAgPyB7XG4gICAgXCJkYXRhLWxldmVsXCI6IHByb3BzLnRleHRCbG9jay5sZXZlbFxuICB9IDoge30sICRbNDVdID0gcHJvcHMudGV4dEJsb2NrLmxldmVsLCAkWzQ2XSA9IHQ5KSA6IHQ5ID0gJFs0Nl07XG4gIGxldCB0MTA7XG4gICRbNDddICE9PSBwcm9wcy50ZXh0QmxvY2suc3R5bGUgPyAodDEwID0gcHJvcHMudGV4dEJsb2NrLnN0eWxlICE9PSB2b2lkIDAgPyB7XG4gICAgXCJkYXRhLXN0eWxlXCI6IHByb3BzLnRleHRCbG9jay5zdHlsZVxuICB9IDoge30sICRbNDddID0gcHJvcHMudGV4dEJsb2NrLnN0eWxlLCAkWzQ4XSA9IHQxMCkgOiB0MTAgPSAkWzQ4XTtcbiAgbGV0IHQxMTtcbiAgJFs0OV0gIT09IGxpc3RJbmRleCA/ICh0MTEgPSBsaXN0SW5kZXggIT09IHZvaWQgMCA/IHtcbiAgICBcImRhdGEtbGlzdC1pbmRleFwiOiBsaXN0SW5kZXhcbiAgfSA6IHt9LCAkWzQ5XSA9IGxpc3RJbmRleCwgJFs1MF0gPSB0MTEpIDogdDExID0gJFs1MF07XG4gIGxldCB0MTI7XG4gICRbNTFdICE9PSBkcmFnUG9zaXRpb25CbG9jayA/ICh0MTIgPSBkcmFnUG9zaXRpb25CbG9jayA9PT0gXCJzdGFydFwiID8gLyogQF9fUFVSRV9fICovIGpzeChEcm9wSW5kaWNhdG9yLCB7fSkgOiBudWxsLCAkWzUxXSA9IGRyYWdQb3NpdGlvbkJsb2NrLCAkWzUyXSA9IHQxMikgOiB0MTIgPSAkWzUyXTtcbiAgbGV0IHQxMztcbiAgJFs1M10gIT09IGNoaWxkcmVuIHx8ICRbNTRdICE9PSBmb2N1c2VkIHx8ICRbNTVdICE9PSBwcm9wcy5sZWdhY3lTY2hlbWEgfHwgJFs1Nl0gIT09IHByb3BzLnJlbmRlckJsb2NrIHx8ICRbNTddICE9PSBwcm9wcy50ZXh0QmxvY2sgfHwgJFs1OF0gIT09IHNlbGVjdGVkID8gKHQxMyA9IHByb3BzLnJlbmRlckJsb2NrID8gLyogQF9fUFVSRV9fICovIGpzeChSZW5kZXJCbG9jaywgeyByZW5kZXJCbG9jazogcHJvcHMucmVuZGVyQmxvY2ssIGVkaXRvckVsZW1lbnRSZWY6IGJsb2NrUmVmLCBmb2N1c2VkLCBsZXZlbDogcHJvcHMudGV4dEJsb2NrLmxldmVsLCBsaXN0SXRlbTogcHJvcHMudGV4dEJsb2NrLmxpc3RJdGVtLCBwYXRoOiBbe1xuICAgIF9rZXk6IHByb3BzLnRleHRCbG9jay5fa2V5XG4gIH1dLCBzZWxlY3RlZCwgc2NoZW1hVHlwZTogcHJvcHMubGVnYWN5U2NoZW1hLmJsb2NrLCBzdHlsZTogcHJvcHMudGV4dEJsb2NrLnN0eWxlLCB0eXBlOiBwcm9wcy5sZWdhY3lTY2hlbWEuYmxvY2ssIHZhbHVlOiBwcm9wcy50ZXh0QmxvY2ssIGNoaWxkcmVuIH0pIDogY2hpbGRyZW4sICRbNTNdID0gY2hpbGRyZW4sICRbNTRdID0gZm9jdXNlZCwgJFs1NV0gPSBwcm9wcy5sZWdhY3lTY2hlbWEsICRbNTZdID0gcHJvcHMucmVuZGVyQmxvY2ssICRbNTddID0gcHJvcHMudGV4dEJsb2NrLCAkWzU4XSA9IHNlbGVjdGVkLCAkWzU5XSA9IHQxMykgOiB0MTMgPSAkWzU5XTtcbiAgbGV0IHQxNDtcbiAgJFs2MF0gIT09IHQxMyA/ICh0MTQgPSAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHsgcmVmOiBibG9ja1JlZiwgY2hpbGRyZW46IHQxMyB9KSwgJFs2MF0gPSB0MTMsICRbNjFdID0gdDE0KSA6IHQxNCA9ICRbNjFdO1xuICBsZXQgdDE1O1xuICAkWzYyXSAhPT0gZHJhZ1Bvc2l0aW9uQmxvY2sgPyAodDE1ID0gZHJhZ1Bvc2l0aW9uQmxvY2sgPT09IFwiZW5kXCIgPyAvKiBAX19QVVJFX18gKi8ganN4KERyb3BJbmRpY2F0b3IsIHt9KSA6IG51bGwsICRbNjJdID0gZHJhZ1Bvc2l0aW9uQmxvY2ssICRbNjNdID0gdDE1KSA6IHQxNSA9ICRbNjNdO1xuICBsZXQgdDE2O1xuICByZXR1cm4gJFs2NF0gIT09IHByb3BzLmF0dHJpYnV0ZXMgfHwgJFs2NV0gIT09IHByb3BzLnNwZWxsQ2hlY2sgfHwgJFs2Nl0gIT09IHByb3BzLnRleHRCbG9jay5fa2V5IHx8ICRbNjddICE9PSBwcm9wcy50ZXh0QmxvY2suX3R5cGUgfHwgJFs2OF0gIT09IHQxMCB8fCAkWzY5XSAhPT0gdDExIHx8ICRbNzBdICE9PSB0MTIgfHwgJFs3MV0gIT09IHQxNCB8fCAkWzcyXSAhPT0gdDE1IHx8ICRbNzNdICE9PSB0NyB8fCAkWzc0XSAhPT0gdDggfHwgJFs3NV0gIT09IHQ5ID8gKHQxNiA9IC8qIEBfX1BVUkVfXyAqLyBqc3hzKFwiZGl2XCIsIHsgLi4udDMsIGNsYXNzTmFtZTogdDcsIHNwZWxsQ2hlY2s6IHByb3BzLnNwZWxsQ2hlY2ssIFwiZGF0YS1ibG9jay1rZXlcIjogcHJvcHMudGV4dEJsb2NrLl9rZXksIFwiZGF0YS1ibG9jay1uYW1lXCI6IHByb3BzLnRleHRCbG9jay5fdHlwZSwgXCJkYXRhLWJsb2NrLXR5cGVcIjogXCJ0ZXh0XCIsIC4uLnQ4LCAuLi50OSwgLi4udDEwLCAuLi50MTEsIGNoaWxkcmVuOiBbXG4gICAgdDEyLFxuICAgIHQxNCxcbiAgICB0MTVcbiAgXSB9KSwgJFs2NF0gPSBwcm9wcy5hdHRyaWJ1dGVzLCAkWzY1XSA9IHByb3BzLnNwZWxsQ2hlY2ssICRbNjZdID0gcHJvcHMudGV4dEJsb2NrLl9rZXksICRbNjddID0gcHJvcHMudGV4dEJsb2NrLl90eXBlLCAkWzY4XSA9IHQxMCwgJFs2OV0gPSB0MTEsICRbNzBdID0gdDEyLCAkWzcxXSA9IHQxNCwgJFs3Ml0gPSB0MTUsICRbNzNdID0gdDcsICRbNzRdID0gdDgsICRbNzVdID0gdDksICRbNzZdID0gdDE2KSA6IHQxNiA9ICRbNzZdLCB0MTY7XG59XG5mdW5jdGlvbiBSZW5kZXJCbG9jayh7XG4gIHJlbmRlckJsb2NrLFxuICBjaGlsZHJlbixcbiAgZWRpdG9yRWxlbWVudFJlZixcbiAgZm9jdXNlZCxcbiAgbGV2ZWwsXG4gIGxpc3RJdGVtLFxuICBwYXRoLFxuICBzZWxlY3RlZCxcbiAgc3R5bGUsXG4gIHNjaGVtYVR5cGUsXG4gIHR5cGUsXG4gIHZhbHVlXG59KSB7XG4gIHJldHVybiByZW5kZXJCbG9jayh7XG4gICAgY2hpbGRyZW4sXG4gICAgZWRpdG9yRWxlbWVudFJlZixcbiAgICBmb2N1c2VkLFxuICAgIGxldmVsLFxuICAgIGxpc3RJdGVtLFxuICAgIHBhdGgsXG4gICAgc2VsZWN0ZWQsXG4gICAgc3R5bGUsXG4gICAgc2NoZW1hVHlwZSxcbiAgICB0eXBlLFxuICAgIHZhbHVlXG4gIH0pO1xufVxuZnVuY3Rpb24gUmVuZGVyTGlzdEl0ZW0oe1xuICByZW5kZXJMaXN0SXRlbSxcbiAgYmxvY2ssXG4gIGNoaWxkcmVuLFxuICBlZGl0b3JFbGVtZW50UmVmLFxuICBmb2N1c2VkLFxuICBsZXZlbCxcbiAgcGF0aCxcbiAgc2NoZW1hVHlwZSxcbiAgc2VsZWN0ZWQsXG4gIHZhbHVlXG59KSB7XG4gIHJldHVybiByZW5kZXJMaXN0SXRlbSh7XG4gICAgYmxvY2ssXG4gICAgY2hpbGRyZW4sXG4gICAgZWRpdG9yRWxlbWVudFJlZixcbiAgICBmb2N1c2VkLFxuICAgIGxldmVsLFxuICAgIHBhdGgsXG4gICAgc2NoZW1hVHlwZSxcbiAgICBzZWxlY3RlZCxcbiAgICB2YWx1ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIFJlbmRlclN0eWxlKHtcbiAgcmVuZGVyU3R5bGUsXG4gIGJsb2NrLFxuICBjaGlsZHJlbixcbiAgZWRpdG9yRWxlbWVudFJlZixcbiAgZm9jdXNlZCxcbiAgcGF0aCxcbiAgc2NoZW1hVHlwZSxcbiAgc2VsZWN0ZWQsXG4gIHZhbHVlXG59KSB7XG4gIHJldHVybiByZW5kZXJTdHlsZSh7XG4gICAgYmxvY2ssXG4gICAgY2hpbGRyZW4sXG4gICAgZWRpdG9yRWxlbWVudFJlZixcbiAgICBmb2N1c2VkLFxuICAgIHBhdGgsXG4gICAgc2NoZW1hVHlwZSxcbiAgICBzZWxlY3RlZCxcbiAgICB2YWx1ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIFJlbmRlckVsZW1lbnQocHJvcHMpIHtcbiAgY29uc3QgJCA9IGMoMzQpLCBlZGl0b3JBY3RvciA9IHVzZUNvbnRleHQoRWRpdG9yQWN0b3JDb250ZXh0KSwgc2NoZW1hID0gdXNlU2VsZWN0b3IoZWRpdG9yQWN0b3IsIF90ZW1wJDMpLCBsZWdhY3lTY2hlbWEgPSB1c2VTZWxlY3RvcihlZGl0b3JBY3RvciwgX3RlbXAyJDIpLCBzbGF0ZVN0YXRpYyA9IHVzZVNsYXRlU3RhdGljKCk7XG4gIGlmIChcIl9faW5saW5lXCIgaW4gcHJvcHMuZWxlbWVudCAmJiBwcm9wcy5lbGVtZW50Ll9faW5saW5lID09PSAhMCkge1xuICAgIGxldCB0MDI7XG4gICAgcmV0dXJuICRbMF0gIT09IGxlZ2FjeVNjaGVtYSB8fCAkWzFdICE9PSBwcm9wcy5hdHRyaWJ1dGVzIHx8ICRbMl0gIT09IHByb3BzLmNoaWxkcmVuIHx8ICRbM10gIT09IHByb3BzLmVsZW1lbnQgfHwgJFs0XSAhPT0gcHJvcHMucmVhZE9ubHkgfHwgJFs1XSAhPT0gcHJvcHMucmVuZGVyQ2hpbGQgfHwgJFs2XSAhPT0gc2NoZW1hID8gKHQwMiA9IC8qIEBfX1BVUkVfXyAqLyBqc3goUmVuZGVySW5saW5lT2JqZWN0LCB7IGF0dHJpYnV0ZXM6IHByb3BzLmF0dHJpYnV0ZXMsIGVsZW1lbnQ6IHByb3BzLmVsZW1lbnQsIGxlZ2FjeVNjaGVtYSwgcmVhZE9ubHk6IHByb3BzLnJlYWRPbmx5LCByZW5kZXJDaGlsZDogcHJvcHMucmVuZGVyQ2hpbGQsIHNjaGVtYSwgY2hpbGRyZW46IHByb3BzLmNoaWxkcmVuIH0pLCAkWzBdID0gbGVnYWN5U2NoZW1hLCAkWzFdID0gcHJvcHMuYXR0cmlidXRlcywgJFsyXSA9IHByb3BzLmNoaWxkcmVuLCAkWzNdID0gcHJvcHMuZWxlbWVudCwgJFs0XSA9IHByb3BzLnJlYWRPbmx5LCAkWzVdID0gcHJvcHMucmVuZGVyQ2hpbGQsICRbNl0gPSBzY2hlbWEsICRbN10gPSB0MDIpIDogdDAyID0gJFs3XSwgdDAyO1xuICB9XG4gIGxldCBibG9jaywgdDA7XG4gIGlmICgkWzhdICE9PSBwcm9wcy5lbGVtZW50Ll9rZXkgfHwgJFs5XSAhPT0gc2NoZW1hIHx8ICRbMTBdICE9PSBzbGF0ZVN0YXRpYy5ibG9ja0luZGV4TWFwIHx8ICRbMTFdICE9PSBzbGF0ZVN0YXRpYy52YWx1ZSkge1xuICAgIGNvbnN0IGJsb2NrSW5kZXggPSBzbGF0ZVN0YXRpYy5ibG9ja0luZGV4TWFwLmdldChwcm9wcy5lbGVtZW50Ll9rZXkpO1xuICAgIGJsb2NrID0gYmxvY2tJbmRleCAhPT0gdm9pZCAwID8gc2xhdGVTdGF0aWMudmFsdWUuYXQoYmxvY2tJbmRleCkgOiB2b2lkIDAsIHQwID0gaXNUZXh0QmxvY2soe1xuICAgICAgc2NoZW1hXG4gICAgfSwgYmxvY2spLCAkWzhdID0gcHJvcHMuZWxlbWVudC5fa2V5LCAkWzldID0gc2NoZW1hLCAkWzEwXSA9IHNsYXRlU3RhdGljLmJsb2NrSW5kZXhNYXAsICRbMTFdID0gc2xhdGVTdGF0aWMudmFsdWUsICRbMTJdID0gYmxvY2ssICRbMTNdID0gdDA7XG4gIH0gZWxzZVxuICAgIGJsb2NrID0gJFsxMl0sIHQwID0gJFsxM107XG4gIGlmICh0MCkge1xuICAgIGxldCB0MTI7XG4gICAgcmV0dXJuICRbMTRdICE9PSBibG9jayB8fCAkWzE1XSAhPT0gbGVnYWN5U2NoZW1hIHx8ICRbMTZdICE9PSBwcm9wcy5hdHRyaWJ1dGVzIHx8ICRbMTddICE9PSBwcm9wcy5jaGlsZHJlbiB8fCAkWzE4XSAhPT0gcHJvcHMuZWxlbWVudCB8fCAkWzE5XSAhPT0gcHJvcHMucmVhZE9ubHkgfHwgJFsyMF0gIT09IHByb3BzLnJlbmRlckJsb2NrIHx8ICRbMjFdICE9PSBwcm9wcy5yZW5kZXJMaXN0SXRlbSB8fCAkWzIyXSAhPT0gcHJvcHMucmVuZGVyU3R5bGUgfHwgJFsyM10gIT09IHByb3BzLnNwZWxsQ2hlY2sgPyAodDEyID0gLyogQF9fUFVSRV9fICovIGpzeChSZW5kZXJUZXh0QmxvY2ssIHsgYXR0cmlidXRlczogcHJvcHMuYXR0cmlidXRlcywgZWxlbWVudDogcHJvcHMuZWxlbWVudCwgbGVnYWN5U2NoZW1hLCByZWFkT25seTogcHJvcHMucmVhZE9ubHksIHJlbmRlckJsb2NrOiBwcm9wcy5yZW5kZXJCbG9jaywgcmVuZGVyTGlzdEl0ZW06IHByb3BzLnJlbmRlckxpc3RJdGVtLCByZW5kZXJTdHlsZTogcHJvcHMucmVuZGVyU3R5bGUsIHNwZWxsQ2hlY2s6IHByb3BzLnNwZWxsQ2hlY2ssIHRleHRCbG9jazogYmxvY2ssIGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbiB9KSwgJFsxNF0gPSBibG9jaywgJFsxNV0gPSBsZWdhY3lTY2hlbWEsICRbMTZdID0gcHJvcHMuYXR0cmlidXRlcywgJFsxN10gPSBwcm9wcy5jaGlsZHJlbiwgJFsxOF0gPSBwcm9wcy5lbGVtZW50LCAkWzE5XSA9IHByb3BzLnJlYWRPbmx5LCAkWzIwXSA9IHByb3BzLnJlbmRlckJsb2NrLCAkWzIxXSA9IHByb3BzLnJlbmRlckxpc3RJdGVtLCAkWzIyXSA9IHByb3BzLnJlbmRlclN0eWxlLCAkWzIzXSA9IHByb3BzLnNwZWxsQ2hlY2ssICRbMjRdID0gdDEyKSA6IHQxMiA9ICRbMjRdLCB0MTI7XG4gIH1cbiAgbGV0IHQxO1xuICByZXR1cm4gJFsyNV0gIT09IGJsb2NrIHx8ICRbMjZdICE9PSBsZWdhY3lTY2hlbWEgfHwgJFsyN10gIT09IHByb3BzLmF0dHJpYnV0ZXMgfHwgJFsyOF0gIT09IHByb3BzLmNoaWxkcmVuIHx8ICRbMjldICE9PSBwcm9wcy5lbGVtZW50IHx8ICRbMzBdICE9PSBwcm9wcy5yZWFkT25seSB8fCAkWzMxXSAhPT0gcHJvcHMucmVuZGVyQmxvY2sgfHwgJFszMl0gIT09IHNjaGVtYSA/ICh0MSA9IC8qIEBfX1BVUkVfXyAqLyBqc3goUmVuZGVyQmxvY2tPYmplY3QsIHsgYXR0cmlidXRlczogcHJvcHMuYXR0cmlidXRlcywgYmxvY2tPYmplY3Q6IGJsb2NrLCBlbGVtZW50OiBwcm9wcy5lbGVtZW50LCBsZWdhY3lTY2hlbWEsIHJlYWRPbmx5OiBwcm9wcy5yZWFkT25seSwgcmVuZGVyQmxvY2s6IHByb3BzLnJlbmRlckJsb2NrLCBzY2hlbWEsIGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbiB9KSwgJFsyNV0gPSBibG9jaywgJFsyNl0gPSBsZWdhY3lTY2hlbWEsICRbMjddID0gcHJvcHMuYXR0cmlidXRlcywgJFsyOF0gPSBwcm9wcy5jaGlsZHJlbiwgJFsyOV0gPSBwcm9wcy5lbGVtZW50LCAkWzMwXSA9IHByb3BzLnJlYWRPbmx5LCAkWzMxXSA9IHByb3BzLnJlbmRlckJsb2NrLCAkWzMyXSA9IHNjaGVtYSwgJFszM10gPSB0MSkgOiB0MSA9ICRbMzNdLCB0MTtcbn1cbmZ1bmN0aW9uIF90ZW1wMiQyKHNfMCkge1xuICByZXR1cm4gc18wLmNvbnRleHQuZ2V0TGVnYWN5U2NoZW1hKCk7XG59XG5mdW5jdGlvbiBfdGVtcCQzKHMpIHtcbiAgcmV0dXJuIHMuY29udGV4dC5zY2hlbWE7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufVxuZnVuY3Rpb24gdXNlRWRpdG9yU2VsZWN0b3IoZWRpdG9yLCBzZWxlY3RvciwgdDApIHtcbiAgY29uc3QgJCA9IGMoMyksIGNvbXBhcmUgPSB0MCA9PT0gdm9pZCAwID8gZGVmYXVsdENvbXBhcmUgOiB0MDtcbiAgbGV0IHQxO1xuICByZXR1cm4gJFswXSAhPT0gZWRpdG9yIHx8ICRbMV0gIT09IHNlbGVjdG9yID8gKHQxID0gKGVkaXRvckFjdG9yU25hcHNob3QpID0+IHtcbiAgICBjb25zdCBzbmFwc2hvdCA9IGdldEVkaXRvclNuYXBzaG90KHtcbiAgICAgIGVkaXRvckFjdG9yU25hcHNob3QsXG4gICAgICBzbGF0ZUVkaXRvckluc3RhbmNlOiBlZGl0b3IuX2ludGVybmFsLnNsYXRlRWRpdG9yLmluc3RhbmNlXG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbGVjdG9yKHNuYXBzaG90KTtcbiAgfSwgJFswXSA9IGVkaXRvciwgJFsxXSA9IHNlbGVjdG9yLCAkWzJdID0gdDEpIDogdDEgPSAkWzJdLCB1c2VTZWxlY3RvcihlZGl0b3IuX2ludGVybmFsLmVkaXRvckFjdG9yLCB0MSwgY29tcGFyZSk7XG59XG5mdW5jdGlvbiBnZXRFZGl0b3JTbmFwc2hvdCh7XG4gIGVkaXRvckFjdG9yU25hcHNob3QsXG4gIHNsYXRlRWRpdG9ySW5zdGFuY2Vcbn0pIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gc2xhdGVFZGl0b3JJbnN0YW5jZS5zZWxlY3Rpb24gPyBzbGF0ZVJhbmdlVG9TZWxlY3Rpb24oe1xuICAgIHNjaGVtYTogZWRpdG9yQWN0b3JTbmFwc2hvdC5jb250ZXh0LnNjaGVtYSxcbiAgICBlZGl0b3I6IHNsYXRlRWRpdG9ySW5zdGFuY2UsXG4gICAgcmFuZ2U6IHNsYXRlRWRpdG9ySW5zdGFuY2Uuc2VsZWN0aW9uXG4gIH0pIDogbnVsbDtcbiAgcmV0dXJuIHtcbiAgICBibG9ja0luZGV4TWFwOiBzbGF0ZUVkaXRvckluc3RhbmNlLmJsb2NrSW5kZXhNYXAsXG4gICAgY29udGV4dDoge1xuICAgICAgY29udmVydGVyczogWy4uLmVkaXRvckFjdG9yU25hcHNob3QuY29udGV4dC5jb252ZXJ0ZXJzXSxcbiAgICAgIGtleUdlbmVyYXRvcjogZWRpdG9yQWN0b3JTbmFwc2hvdC5jb250ZXh0LmtleUdlbmVyYXRvcixcbiAgICAgIHJlYWRPbmx5OiBlZGl0b3JBY3RvclNuYXBzaG90Lm1hdGNoZXMoe1xuICAgICAgICBcImVkaXQgbW9kZVwiOiBcInJlYWQgb25seVwiXG4gICAgICB9KSxcbiAgICAgIHNjaGVtYTogZWRpdG9yQWN0b3JTbmFwc2hvdC5jb250ZXh0LnNjaGVtYSxcbiAgICAgIHNlbGVjdGlvbixcbiAgICAgIHZhbHVlOiBzbGF0ZUVkaXRvckluc3RhbmNlLnZhbHVlXG4gICAgfSxcbiAgICBkZWNvcmF0b3JTdGF0ZTogc2xhdGVFZGl0b3JJbnN0YW5jZS5kZWNvcmF0b3JTdGF0ZVxuICB9O1xufVxuZnVuY3Rpb24gUmVuZGVyU3Bhbihwcm9wcykge1xuICBjb25zdCAkID0gYyg0MCksIHNsYXRlRWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKSwgZWRpdG9yQWN0b3IgPSB1c2VDb250ZXh0KEVkaXRvckFjdG9yQ29udGV4dCksIGxlZ2FjeVNjaGVtYSA9IHVzZVNlbGVjdG9yKGVkaXRvckFjdG9yLCBfdGVtcCQyKSwgc3BhblJlZiA9IHVzZVJlZihudWxsKTtcbiAgbGV0IHQwO1xuICAkWzBdICE9PSBwcm9wcy5sZWFmLl9rZXkgfHwgJFsxXSAhPT0gc2xhdGVFZGl0b3IgPyAodDAgPSAoZWRpdG9yQWN0b3JTbmFwc2hvdCkgPT4ge1xuICAgIGNvbnN0IHNuYXBzaG90ID0gZ2V0RWRpdG9yU25hcHNob3Qoe1xuICAgICAgZWRpdG9yQWN0b3JTbmFwc2hvdCxcbiAgICAgIHNsYXRlRWRpdG9ySW5zdGFuY2U6IHNsYXRlRWRpdG9yXG4gICAgfSk7XG4gICAgaWYgKCFzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbiB8fCAhaXNTZWxlY3Rpb25Db2xsYXBzZWQkMShzbmFwc2hvdCkpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgZm9jdXNlZFNwYW4gPSBnZXRGb2N1c1NwYW4kMShzbmFwc2hvdCk7XG4gICAgcmV0dXJuIGZvY3VzZWRTcGFuID8gZm9jdXNlZFNwYW4ubm9kZS5fa2V5ID09PSBwcm9wcy5sZWFmLl9rZXkgOiAhMTtcbiAgfSwgJFswXSA9IHByb3BzLmxlYWYuX2tleSwgJFsxXSA9IHNsYXRlRWRpdG9yLCAkWzJdID0gdDApIDogdDAgPSAkWzJdO1xuICBjb25zdCBmb2N1c2VkID0gdXNlU2VsZWN0b3IoZWRpdG9yQWN0b3IsIHQwKTtcbiAgbGV0IHQxO1xuICAkWzNdICE9PSBwcm9wcy5jaGlsZHJlbi5wcm9wcy5wYXJlbnQgfHwgJFs0XSAhPT0gcHJvcHMubGVhZi5fa2V5IHx8ICRbNV0gIT09IHByb3BzLmxlYWYudGV4dCB8fCAkWzZdICE9PSBzbGF0ZUVkaXRvciA/ICh0MSA9IChlZGl0b3JBY3RvclNuYXBzaG90XzApID0+IHtcbiAgICBjb25zdCBzbmFwc2hvdF8wID0gZ2V0RWRpdG9yU25hcHNob3Qoe1xuICAgICAgZWRpdG9yQWN0b3JTbmFwc2hvdDogZWRpdG9yQWN0b3JTbmFwc2hvdF8wLFxuICAgICAgc2xhdGVFZGl0b3JJbnN0YW5jZTogc2xhdGVFZGl0b3JcbiAgICB9KTtcbiAgICBpZiAoIXNuYXBzaG90XzAuY29udGV4dC5zZWxlY3Rpb24pXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgcGFyZW50ID0gcHJvcHMuY2hpbGRyZW4ucHJvcHMucGFyZW50LCBibG9jayA9IHBhcmVudCAmJiBpc1RleHRCbG9jayhzbmFwc2hvdF8wLmNvbnRleHQsIHBhcmVudCkgPyBwYXJlbnQgOiB2b2lkIDAsIHNwYW5TZWxlY3Rpb24gPSBibG9jayA/IHtcbiAgICAgIGFuY2hvcjoge1xuICAgICAgICBwYXRoOiBbe1xuICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgX2tleTogcHJvcHMubGVhZi5fa2V5XG4gICAgICAgIH1dLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0sXG4gICAgICBmb2N1czoge1xuICAgICAgICBwYXRoOiBbe1xuICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgX2tleTogcHJvcHMubGVhZi5fa2V5XG4gICAgICAgIH1dLFxuICAgICAgICBvZmZzZXQ6IHByb3BzLmxlYWYudGV4dC5sZW5ndGhcbiAgICAgIH1cbiAgICB9IDogbnVsbDtcbiAgICByZXR1cm4gaXNPdmVybGFwcGluZ1NlbGVjdGlvbihzcGFuU2VsZWN0aW9uKShzbmFwc2hvdF8wKTtcbiAgfSwgJFszXSA9IHByb3BzLmNoaWxkcmVuLnByb3BzLnBhcmVudCwgJFs0XSA9IHByb3BzLmxlYWYuX2tleSwgJFs1XSA9IHByb3BzLmxlYWYudGV4dCwgJFs2XSA9IHNsYXRlRWRpdG9yLCAkWzddID0gdDEpIDogdDEgPSAkWzddO1xuICBjb25zdCBzZWxlY3RlZCA9IHVzZVNlbGVjdG9yKGVkaXRvckFjdG9yLCB0MSksIHBhcmVudF8wID0gcHJvcHMuY2hpbGRyZW4ucHJvcHMucGFyZW50LCBibG9ja18wID0gcGFyZW50XzAgJiYgc2xhdGVFZGl0b3IuaXNUZXh0QmxvY2socGFyZW50XzApID8gcGFyZW50XzAgOiB2b2lkIDA7XG4gIGxldCB0MjtcbiAgJFs4XSAhPT0gYmxvY2tfMCB8fCAkWzldICE9PSBwcm9wcy5sZWFmLl9rZXkgPyAodDIgPSBibG9ja18wID8gW3tcbiAgICBfa2V5OiBibG9ja18wLl9rZXlcbiAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgX2tleTogcHJvcHMubGVhZi5fa2V5XG4gIH1dIDogdm9pZCAwLCAkWzhdID0gYmxvY2tfMCwgJFs5XSA9IHByb3BzLmxlYWYuX2tleSwgJFsxMF0gPSB0MikgOiB0MiA9ICRbMTBdO1xuICBjb25zdCBwYXRoID0gdDI7XG4gIGxldCBhbm5vdGF0aW9uTWFya0RlZnMsIGNoaWxkcmVuO1xuICBpZiAoJFsxMV0gIT09IGJsb2NrXzAgfHwgJFsxMl0gIT09IGVkaXRvckFjdG9yIHx8ICRbMTNdICE9PSBmb2N1c2VkIHx8ICRbMTRdICE9PSBsZWdhY3lTY2hlbWEgfHwgJFsxNV0gIT09IHBhdGggfHwgJFsxNl0gIT09IHByb3BzLmNoaWxkcmVuIHx8ICRbMTddICE9PSBwcm9wcy5sZWFmLm1hcmtzIHx8ICRbMThdICE9PSBwcm9wcy5yZW5kZXJBbm5vdGF0aW9uIHx8ICRbMTldICE9PSBwcm9wcy5yZW5kZXJEZWNvcmF0b3IgfHwgJFsyMF0gIT09IHNlbGVjdGVkKSB7XG4gICAgY29uc3QgZGVjb3JhdG9yU2NoZW1hVHlwZXMgPSBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLmRlY29yYXRvcnMubWFwKF90ZW1wMiQxKSwgZGVjb3JhdG9ycyA9IHVuaXEoKHByb3BzLmxlYWYubWFya3MgPz8gW10pLmZpbHRlcigobWFyaykgPT4gZGVjb3JhdG9yU2NoZW1hVHlwZXMuaW5jbHVkZXMobWFyaykpKTtcbiAgICBhbm5vdGF0aW9uTWFya0RlZnMgPSAocHJvcHMubGVhZi5tYXJrcyA/PyBbXSkuZmxhdE1hcCgobWFya18wKSA9PiB7XG4gICAgICBpZiAoZGVjb3JhdG9yU2NoZW1hVHlwZXMuaW5jbHVkZXMobWFya18wKSlcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgY29uc3QgbWFya0RlZl8wID0gYmxvY2tfMD8ubWFya0RlZnM/LmZpbmQoKG1hcmtEZWYpID0+IG1hcmtEZWYuX2tleSA9PT0gbWFya18wKTtcbiAgICAgIHJldHVybiBtYXJrRGVmXzAgPyBbbWFya0RlZl8wXSA6IFtdO1xuICAgIH0pLCBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICAgIGZvciAoY29uc3QgbWFya18xIG9mIGRlY29yYXRvcnMpIHtcbiAgICAgIGNvbnN0IGxlZ2FjeURlY29yYXRvclNjaGVtYVR5cGUgPSBsZWdhY3lTY2hlbWEuZGVjb3JhdG9ycy5maW5kKChkZWMpID0+IGRlYy52YWx1ZSA9PT0gbWFya18xKTtcbiAgICAgIHBhdGggJiYgbGVnYWN5RGVjb3JhdG9yU2NoZW1hVHlwZSAmJiBwcm9wcy5yZW5kZXJEZWNvcmF0b3IgJiYgKGNoaWxkcmVuID0gLyogQF9fUFVSRV9fICovIGpzeChSZW5kZXJEZWNvcmF0b3IsIHsgcmVuZGVyRGVjb3JhdG9yOiBwcm9wcy5yZW5kZXJEZWNvcmF0b3IsIGVkaXRvckVsZW1lbnRSZWY6IHNwYW5SZWYsIGZvY3VzZWQsIHBhdGgsIHNlbGVjdGVkLCBzY2hlbWFUeXBlOiBsZWdhY3lEZWNvcmF0b3JTY2hlbWFUeXBlLCB2YWx1ZTogbWFya18xLCB0eXBlOiBsZWdhY3lEZWNvcmF0b3JTY2hlbWFUeXBlLCBjaGlsZHJlbiB9KSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgYW5ub3RhdGlvbk1hcmtEZWYgb2YgYW5ub3RhdGlvbk1hcmtEZWZzKSB7XG4gICAgICBjb25zdCBsZWdhY3lBbm5vdGF0aW9uU2NoZW1hVHlwZSA9IGxlZ2FjeVNjaGVtYS5hbm5vdGF0aW9ucy5maW5kKCh0KSA9PiB0Lm5hbWUgPT09IGFubm90YXRpb25NYXJrRGVmLl90eXBlKTtcbiAgICAgIGxlZ2FjeUFubm90YXRpb25TY2hlbWFUeXBlICYmIChibG9ja18wICYmIHBhdGggJiYgcHJvcHMucmVuZGVyQW5ub3RhdGlvbiA/IGNoaWxkcmVuID0gLyogQF9fUFVSRV9fICovIGpzeChcInNwYW5cIiwgeyByZWY6IHNwYW5SZWYsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFJlbmRlckFubm90YXRpb24sIHsgcmVuZGVyQW5ub3RhdGlvbjogcHJvcHMucmVuZGVyQW5ub3RhdGlvbiwgYmxvY2s6IGJsb2NrXzAsIGVkaXRvckVsZW1lbnRSZWY6IHNwYW5SZWYsIGZvY3VzZWQsIHBhdGgsIHNlbGVjdGVkLCBzY2hlbWFUeXBlOiBsZWdhY3lBbm5vdGF0aW9uU2NoZW1hVHlwZSwgdmFsdWU6IGFubm90YXRpb25NYXJrRGVmLCB0eXBlOiBsZWdhY3lBbm5vdGF0aW9uU2NoZW1hVHlwZSwgY2hpbGRyZW4gfSkgfSkgOiBjaGlsZHJlbiA9IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzcGFuXCIsIHsgcmVmOiBzcGFuUmVmLCBjaGlsZHJlbiB9KSk7XG4gICAgfVxuICAgICRbMTFdID0gYmxvY2tfMCwgJFsxMl0gPSBlZGl0b3JBY3RvciwgJFsxM10gPSBmb2N1c2VkLCAkWzE0XSA9IGxlZ2FjeVNjaGVtYSwgJFsxNV0gPSBwYXRoLCAkWzE2XSA9IHByb3BzLmNoaWxkcmVuLCAkWzE3XSA9IHByb3BzLmxlYWYubWFya3MsICRbMThdID0gcHJvcHMucmVuZGVyQW5ub3RhdGlvbiwgJFsxOV0gPSBwcm9wcy5yZW5kZXJEZWNvcmF0b3IsICRbMjBdID0gc2VsZWN0ZWQsICRbMjFdID0gYW5ub3RhdGlvbk1hcmtEZWZzLCAkWzIyXSA9IGNoaWxkcmVuO1xuICB9IGVsc2VcbiAgICBhbm5vdGF0aW9uTWFya0RlZnMgPSAkWzIxXSwgY2hpbGRyZW4gPSAkWzIyXTtcbiAgaWYgKGJsb2NrXzAgJiYgcGF0aCAmJiBwcm9wcy5yZW5kZXJDaGlsZCkge1xuICAgIGxldCB0MzI7XG4gICAgaWYgKCRbMjNdICE9PSBibG9ja18wLmNoaWxkcmVuIHx8ICRbMjRdICE9PSBwcm9wcy5sZWFmKSB7XG4gICAgICBsZXQgdDQ7XG4gICAgICAkWzI2XSAhPT0gcHJvcHMubGVhZiA/ICh0NCA9IChfY2hpbGQpID0+IF9jaGlsZC5fa2V5ID09PSBwcm9wcy5sZWFmLl9rZXksICRbMjZdID0gcHJvcHMubGVhZiwgJFsyN10gPSB0NCkgOiB0NCA9ICRbMjddLCB0MzIgPSBibG9ja18wLmNoaWxkcmVuLmZpbmQodDQpLCAkWzIzXSA9IGJsb2NrXzAuY2hpbGRyZW4sICRbMjRdID0gcHJvcHMubGVhZiwgJFsyNV0gPSB0MzI7XG4gICAgfSBlbHNlXG4gICAgICB0MzIgPSAkWzI1XTtcbiAgICBjb25zdCBjaGlsZCA9IHQzMjtcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIGxldCB0NDtcbiAgICAgICRbMjhdICE9PSBhbm5vdGF0aW9uTWFya0RlZnMgfHwgJFsyOV0gIT09IGNoaWxkIHx8ICRbMzBdICE9PSBjaGlsZHJlbiB8fCAkWzMxXSAhPT0gZm9jdXNlZCB8fCAkWzMyXSAhPT0gbGVnYWN5U2NoZW1hLnNwYW4gfHwgJFszM10gIT09IHBhdGggfHwgJFszNF0gIT09IHByb3BzLnJlbmRlckNoaWxkIHx8ICRbMzVdICE9PSBzZWxlY3RlZCA/ICh0NCA9IC8qIEBfX1BVUkVfXyAqLyBqc3goUmVuZGVyQ2hpbGQsIHsgcmVuZGVyQ2hpbGQ6IHByb3BzLnJlbmRlckNoaWxkLCBhbm5vdGF0aW9uczogYW5ub3RhdGlvbk1hcmtEZWZzLCBlZGl0b3JFbGVtZW50UmVmOiBzcGFuUmVmLCBmb2N1c2VkLCBwYXRoLCBzY2hlbWFUeXBlOiBsZWdhY3lTY2hlbWEuc3Bhbiwgc2VsZWN0ZWQsIHZhbHVlOiBjaGlsZCwgdHlwZTogbGVnYWN5U2NoZW1hLnNwYW4sIGNoaWxkcmVuIH0pLCAkWzI4XSA9IGFubm90YXRpb25NYXJrRGVmcywgJFsyOV0gPSBjaGlsZCwgJFszMF0gPSBjaGlsZHJlbiwgJFszMV0gPSBmb2N1c2VkLCAkWzMyXSA9IGxlZ2FjeVNjaGVtYS5zcGFuLCAkWzMzXSA9IHBhdGgsICRbMzRdID0gcHJvcHMucmVuZGVyQ2hpbGQsICRbMzVdID0gc2VsZWN0ZWQsICRbMzZdID0gdDQpIDogdDQgPSAkWzM2XSwgY2hpbGRyZW4gPSB0NDtcbiAgICB9XG4gIH1cbiAgbGV0IHQzO1xuICByZXR1cm4gJFszN10gIT09IGNoaWxkcmVuIHx8ICRbMzhdICE9PSBwcm9wcy5hdHRyaWJ1dGVzID8gKHQzID0gLyogQF9fUFVSRV9fICovIGpzeChcInNwYW5cIiwgeyAuLi5wcm9wcy5hdHRyaWJ1dGVzLCByZWY6IHNwYW5SZWYsIGNoaWxkcmVuIH0pLCAkWzM3XSA9IGNoaWxkcmVuLCAkWzM4XSA9IHByb3BzLmF0dHJpYnV0ZXMsICRbMzldID0gdDMpIDogdDMgPSAkWzM5XSwgdDM7XG59XG5mdW5jdGlvbiBfdGVtcDIkMShkZWNvcmF0b3IpIHtcbiAgcmV0dXJuIGRlY29yYXRvci5uYW1lO1xufVxuZnVuY3Rpb24gX3RlbXAkMihzKSB7XG4gIHJldHVybiBzLmNvbnRleHQuZ2V0TGVnYWN5U2NoZW1hKCk7XG59XG5mdW5jdGlvbiBSZW5kZXJBbm5vdGF0aW9uKHtcbiAgcmVuZGVyQW5ub3RhdGlvbixcbiAgYmxvY2ssXG4gIGNoaWxkcmVuLFxuICBlZGl0b3JFbGVtZW50UmVmLFxuICBmb2N1c2VkLFxuICBwYXRoLFxuICBzY2hlbWFUeXBlLFxuICBzZWxlY3RlZCxcbiAgdmFsdWUsXG4gIHR5cGVcbn0pIHtcbiAgcmV0dXJuIHJlbmRlckFubm90YXRpb24oe1xuICAgIGJsb2NrLFxuICAgIGNoaWxkcmVuLFxuICAgIGVkaXRvckVsZW1lbnRSZWYsXG4gICAgZm9jdXNlZCxcbiAgICBwYXRoLFxuICAgIHNjaGVtYVR5cGUsXG4gICAgc2VsZWN0ZWQsXG4gICAgdmFsdWUsXG4gICAgdHlwZVxuICB9KTtcbn1cbmZ1bmN0aW9uIFJlbmRlckRlY29yYXRvcih7XG4gIHJlbmRlckRlY29yYXRvcixcbiAgY2hpbGRyZW4sXG4gIGVkaXRvckVsZW1lbnRSZWYsXG4gIGZvY3VzZWQsXG4gIHBhdGgsXG4gIHNjaGVtYVR5cGUsXG4gIHNlbGVjdGVkLFxuICB2YWx1ZSxcbiAgdHlwZVxufSkge1xuICByZXR1cm4gcmVuZGVyRGVjb3JhdG9yKHtcbiAgICBjaGlsZHJlbixcbiAgICBlZGl0b3JFbGVtZW50UmVmLFxuICAgIGZvY3VzZWQsXG4gICAgcGF0aCxcbiAgICBzY2hlbWFUeXBlLFxuICAgIHNlbGVjdGVkLFxuICAgIHZhbHVlLFxuICAgIHR5cGVcbiAgfSk7XG59XG5mdW5jdGlvbiBSZW5kZXJDaGlsZCh7XG4gIHJlbmRlckNoaWxkLFxuICBhbm5vdGF0aW9ucyxcbiAgY2hpbGRyZW4sXG4gIGVkaXRvckVsZW1lbnRSZWYsXG4gIGZvY3VzZWQsXG4gIHBhdGgsXG4gIHNjaGVtYVR5cGUsXG4gIHNlbGVjdGVkLFxuICB2YWx1ZSxcbiAgdHlwZVxufSkge1xuICByZXR1cm4gcmVuZGVyQ2hpbGQoe1xuICAgIGFubm90YXRpb25zLFxuICAgIGNoaWxkcmVuLFxuICAgIGVkaXRvckVsZW1lbnRSZWYsXG4gICAgZm9jdXNlZCxcbiAgICBwYXRoLFxuICAgIHNjaGVtYVR5cGUsXG4gICAgc2VsZWN0ZWQsXG4gICAgdmFsdWUsXG4gICAgdHlwZVxuICB9KTtcbn1cbmNvbnN0IFBMQUNFSE9MREVSX1NUWUxFID0ge1xuICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICB1c2VyU2VsZWN0OiBcIm5vbmVcIixcbiAgcG9pbnRlckV2ZW50czogXCJub25lXCIsXG4gIGxlZnQ6IDAsXG4gIHJpZ2h0OiAwXG59O1xuZnVuY3Rpb24gUmVuZGVyTGVhZihwcm9wcykge1xuICBjb25zdCAkID0gYygxMiksIGVkaXRvckFjdG9yID0gdXNlQ29udGV4dChFZGl0b3JBY3RvckNvbnRleHQpLCBzY2hlbWEgPSB1c2VTZWxlY3RvcihlZGl0b3JBY3RvciwgX3RlbXAkMSk7XG4gIGlmIChwcm9wcy5sZWFmLl90eXBlICE9PSBzY2hlbWEuc3Bhbi5uYW1lKVxuICAgIHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbiAgbGV0IHQwO1xuICAkWzBdICE9PSBwcm9wcyA/ICh0MCA9IC8qIEBfX1BVUkVfXyAqLyBqc3goUmVuZGVyU3BhbiwgeyAuLi5wcm9wcyB9KSwgJFswXSA9IHByb3BzLCAkWzFdID0gdDApIDogdDAgPSAkWzFdO1xuICBsZXQgcmVuZGVyZWRTcGFuID0gdDA7XG4gIGlmIChwcm9wcy5yZW5kZXJQbGFjZWhvbGRlciAmJiBwcm9wcy5sZWFmLnBsYWNlaG9sZGVyICYmIHByb3BzLnRleHQudGV4dCA9PT0gXCJcIikge1xuICAgIGxldCB0MTtcbiAgICAkWzJdICE9PSBwcm9wcy5yZW5kZXJQbGFjZWhvbGRlciA/ICh0MSA9IHByb3BzLnJlbmRlclBsYWNlaG9sZGVyKCksICRbMl0gPSBwcm9wcy5yZW5kZXJQbGFjZWhvbGRlciwgJFszXSA9IHQxKSA6IHQxID0gJFszXTtcbiAgICBsZXQgdDI7XG4gICAgJFs0XSAhPT0gdDEgPyAodDIgPSAvKiBAX19QVVJFX18gKi8ganN4KFwic3BhblwiLCB7IHN0eWxlOiBQTEFDRUhPTERFUl9TVFlMRSwgY29udGVudEVkaXRhYmxlOiAhMSwgY2hpbGRyZW46IHQxIH0pLCAkWzRdID0gdDEsICRbNV0gPSB0MikgOiB0MiA9ICRbNV07XG4gICAgbGV0IHQzO1xuICAgIHJldHVybiAkWzZdICE9PSByZW5kZXJlZFNwYW4gfHwgJFs3XSAhPT0gdDIgPyAodDMgPSAvKiBAX19QVVJFX18gKi8ganN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW1xuICAgICAgdDIsXG4gICAgICByZW5kZXJlZFNwYW5cbiAgICBdIH0pLCAkWzZdID0gcmVuZGVyZWRTcGFuLCAkWzddID0gdDIsICRbOF0gPSB0MykgOiB0MyA9ICRbOF0sIHQzO1xuICB9XG4gIGNvbnN0IHJhbmdlRGVjb3JhdGlvbiA9IHByb3BzLmxlYWYucmFuZ2VEZWNvcmF0aW9uO1xuICBpZiAocmFuZ2VEZWNvcmF0aW9uKSB7XG4gICAgbGV0IHQxO1xuICAgICRbOV0gIT09IHJhbmdlRGVjb3JhdGlvbiB8fCAkWzEwXSAhPT0gcmVuZGVyZWRTcGFuID8gKHQxID0gcmFuZ2VEZWNvcmF0aW9uLmNvbXBvbmVudCh7XG4gICAgICBjaGlsZHJlbjogcmVuZGVyZWRTcGFuXG4gICAgfSksICRbOV0gPSByYW5nZURlY29yYXRpb24sICRbMTBdID0gcmVuZGVyZWRTcGFuLCAkWzExXSA9IHQxKSA6IHQxID0gJFsxMV0sIHJlbmRlcmVkU3BhbiA9IHQxO1xuICB9XG4gIHJldHVybiByZW5kZXJlZFNwYW47XG59XG5mdW5jdGlvbiBfdGVtcCQxKHMpIHtcbiAgcmV0dXJuIHMuY29udGV4dC5zY2hlbWE7XG59XG5mdW5jdGlvbiBSZW5kZXJUZXh0KHByb3BzKSB7XG4gIGNvbnN0ICQgPSBjKDUpO1xuICBsZXQgdDA7XG4gIHJldHVybiAkWzBdICE9PSBwcm9wcy5hdHRyaWJ1dGVzIHx8ICRbMV0gIT09IHByb3BzLmNoaWxkcmVuIHx8ICRbMl0gIT09IHByb3BzLnRleHQuX2tleSB8fCAkWzNdICE9PSBwcm9wcy50ZXh0Ll90eXBlID8gKHQwID0gLyogQF9fUFVSRV9fICovIGpzeChcInNwYW5cIiwgeyAuLi5wcm9wcy5hdHRyaWJ1dGVzLCBcImRhdGEtY2hpbGQta2V5XCI6IHByb3BzLnRleHQuX2tleSwgXCJkYXRhLWNoaWxkLW5hbWVcIjogcHJvcHMudGV4dC5fdHlwZSwgXCJkYXRhLWNoaWxkLXR5cGVcIjogXCJzcGFuXCIsIGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbiB9KSwgJFswXSA9IHByb3BzLmF0dHJpYnV0ZXMsICRbMV0gPSBwcm9wcy5jaGlsZHJlbiwgJFsyXSA9IHByb3BzLnRleHQuX2tleSwgJFszXSA9IHByb3BzLnRleHQuX3R5cGUsICRbNF0gPSB0MCkgOiB0MCA9ICRbNF0sIHQwO1xufVxuY29uc3QgUG9ydGFibGVUZXh0RWRpdG9yQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCksIHVzZVBvcnRhYmxlVGV4dEVkaXRvciA9ICgpID0+IHtcbiAgY29uc3QgZWRpdG9yID0gdXNlQ29udGV4dChQb3J0YWJsZVRleHRFZGl0b3JDb250ZXh0KTtcbiAgaWYgKCFlZGl0b3IpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGB1c2VQb3J0YWJsZVRleHRFZGl0b3JgIGhvb2sgbXVzdCBiZSB1c2VkIGluc2lkZSB0aGUgPFBvcnRhYmxlVGV4dEVkaXRvcj4gY29tcG9uZW50J3MgY29udGV4dC5cIik7XG4gIHJldHVybiBlZGl0b3I7XG59LCBJU19NQUMgPSB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgL01hY3xpUG9kfGlQaG9uZXxpUGFkLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSwgbW9kaWZpZXJzID0ge1xuICBhbHQ6IFwiYWx0S2V5XCIsXG4gIGNvbnRyb2w6IFwiY3RybEtleVwiLFxuICBtZXRhOiBcIm1ldGFLZXlcIixcbiAgc2hpZnQ6IFwic2hpZnRLZXlcIlxufSwgYWxpYXNlcyA9IHtcbiAgYWRkOiBcIitcIixcbiAgYnJlYWs6IFwicGF1c2VcIixcbiAgY21kOiBcIm1ldGFcIixcbiAgY29tbWFuZDogXCJtZXRhXCIsXG4gIGN0bDogXCJjb250cm9sXCIsXG4gIGN0cmw6IFwiY29udHJvbFwiLFxuICBkZWw6IFwiZGVsZXRlXCIsXG4gIGRvd246IFwiYXJyb3dkb3duXCIsXG4gIGVzYzogXCJlc2NhcGVcIixcbiAgaW5zOiBcImluc2VydFwiLFxuICBsZWZ0OiBcImFycm93bGVmdFwiLFxuICBtb2Q6IElTX01BQyA/IFwibWV0YVwiIDogXCJjb250cm9sXCIsXG4gIG9wdDogXCJhbHRcIixcbiAgb3B0aW9uOiBcImFsdFwiLFxuICByZXR1cm46IFwiZW50ZXJcIixcbiAgcmlnaHQ6IFwiYXJyb3dyaWdodFwiLFxuICBzcGFjZTogXCIgXCIsXG4gIHNwYWNlYmFyOiBcIiBcIixcbiAgdXA6IFwiYXJyb3d1cFwiLFxuICB3aW46IFwibWV0YVwiLFxuICB3aW5kb3dzOiBcIm1ldGFcIlxufSwga2V5Q29kZXMgPSB7XG4gIGJhY2tzcGFjZTogOCxcbiAgdGFiOiA5LFxuICBlbnRlcjogMTMsXG4gIHNoaWZ0OiAxNixcbiAgY29udHJvbDogMTcsXG4gIGFsdDogMTgsXG4gIHBhdXNlOiAxOSxcbiAgY2Fwc2xvY2s6IDIwLFxuICBlc2NhcGU6IDI3LFxuICBcIiBcIjogMzIsXG4gIHBhZ2V1cDogMzMsXG4gIHBhZ2Vkb3duOiAzNCxcbiAgZW5kOiAzNSxcbiAgaG9tZTogMzYsXG4gIGFycm93bGVmdDogMzcsXG4gIGFycm93dXA6IDM4LFxuICBhcnJvd3JpZ2h0OiAzOSxcbiAgYXJyb3dkb3duOiA0MCxcbiAgaW5zZXJ0OiA0NSxcbiAgZGVsZXRlOiA0NixcbiAgbWV0YTogOTEsXG4gIG51bWxvY2s6IDE0NCxcbiAgc2Nyb2xsbG9jazogMTQ1LFxuICBcIjtcIjogMTg2LFxuICBcIj1cIjogMTg3LFxuICBcIixcIjogMTg4LFxuICBcIi1cIjogMTg5LFxuICBcIi5cIjogMTkwLFxuICBcIi9cIjogMTkxLFxuICBcImBcIjogMTkyLFxuICBcIltcIjogMjE5LFxuICBcIlxcXFxcIjogMjIwLFxuICBcIl1cIjogMjIxLFxuICBcIidcIjogMjIyLFxuICBmMTogMTEyLFxuICBmMjogMTEzLFxuICBmMzogMTE0LFxuICBmNDogMTE1LFxuICBmNTogMTE2LFxuICBmNjogMTE3LFxuICBmNzogMTE4LFxuICBmODogMTE5LFxuICBmOTogMTIwLFxuICBmMTA6IDEyMSxcbiAgZjExOiAxMjIsXG4gIGYxMjogMTIzLFxuICBmMTM6IDEyNCxcbiAgZjE0OiAxMjUsXG4gIGYxNTogMTI2LFxuICBmMTY6IDEyNyxcbiAgZjE3OiAxMjgsXG4gIGYxODogMTI5LFxuICBmMTk6IDEzMCxcbiAgZjIwOiAxMzFcbn07XG5mdW5jdGlvbiBpc0hvdGtleShob3RrZXksIGV2ZW50KSB7XG4gIHJldHVybiBjb21wYXJlSG90a2V5KHBhcnNlSG90a2V5KGhvdGtleSksIGV2ZW50KTtcbn1cbmZ1bmN0aW9uIHBhcnNlSG90a2V5KGhvdGtleSkge1xuICBjb25zdCBwYXJzZWRIb3RrZXkgPSB7XG4gICAgYWx0S2V5OiAhMSxcbiAgICBjdHJsS2V5OiAhMSxcbiAgICBtZXRhS2V5OiAhMSxcbiAgICBzaGlmdEtleTogITFcbiAgfSwgaG90a2V5U2VnbWVudHMgPSBob3RrZXkucmVwbGFjZShcIisrXCIsIFwiK2FkZFwiKS5zcGxpdChcIitcIik7XG4gIGZvciAoY29uc3QgcmF3SG90a2V5U2VnbWVudCBvZiBob3RrZXlTZWdtZW50cykge1xuICAgIGNvbnN0IG9wdGlvbmFsID0gcmF3SG90a2V5U2VnbWVudC5lbmRzV2l0aChcIj9cIikgJiYgcmF3SG90a2V5U2VnbWVudC5sZW5ndGggPiAxLCBob3RrZXlTZWdtZW50ID0gb3B0aW9uYWwgPyByYXdIb3RrZXlTZWdtZW50LnNsaWNlKDAsIC0xKSA6IHJhd0hvdGtleVNlZ21lbnQsIGtleU5hbWUgPSB0b0tleU5hbWUoaG90a2V5U2VnbWVudCksIG1vZGlmaWVyID0gbW9kaWZpZXJzW2tleU5hbWVdLCBhbGlhcyA9IGFsaWFzZXNbaG90a2V5U2VnbWVudF0sIGNvZGUyID0ga2V5Q29kZXNba2V5TmFtZV07XG4gICAgaWYgKGhvdGtleVNlZ21lbnQubGVuZ3RoID4gMSAmJiBtb2RpZmllciA9PT0gdm9pZCAwICYmIGFsaWFzID09PSB2b2lkIDAgJiYgY29kZTIgPT09IHZvaWQgMClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVua25vd24gbW9kaWZpZXI6IFwiJHtob3RrZXlTZWdtZW50fVwiYCk7XG4gICAgKGhvdGtleVNlZ21lbnRzLmxlbmd0aCA9PT0gMSB8fCBtb2RpZmllciA9PT0gdm9pZCAwKSAmJiAocGFyc2VkSG90a2V5LmtleSA9IGtleU5hbWUsIHBhcnNlZEhvdGtleS5rZXlDb2RlID0gdG9LZXlDb2RlKGhvdGtleVNlZ21lbnQpKSwgbW9kaWZpZXIgIT09IHZvaWQgMCAmJiAocGFyc2VkSG90a2V5W21vZGlmaWVyXSA9IG9wdGlvbmFsID8gbnVsbCA6ICEwKTtcbiAgfVxuICByZXR1cm4gcGFyc2VkSG90a2V5O1xufVxuZnVuY3Rpb24gY29tcGFyZUhvdGtleShwYXJzZWRIb3RrZXksIGV2ZW50KSB7XG4gIHJldHVybiAocGFyc2VkSG90a2V5LmFsdEtleSA9PSBudWxsIHx8IHBhcnNlZEhvdGtleS5hbHRLZXkgPT09IGV2ZW50LmFsdEtleSkgJiYgKHBhcnNlZEhvdGtleS5jdHJsS2V5ID09IG51bGwgfHwgcGFyc2VkSG90a2V5LmN0cmxLZXkgPT09IGV2ZW50LmN0cmxLZXkpICYmIChwYXJzZWRIb3RrZXkubWV0YUtleSA9PSBudWxsIHx8IHBhcnNlZEhvdGtleS5tZXRhS2V5ID09PSBldmVudC5tZXRhS2V5KSAmJiAocGFyc2VkSG90a2V5LnNoaWZ0S2V5ID09IG51bGwgfHwgcGFyc2VkSG90a2V5LnNoaWZ0S2V5ID09PSBldmVudC5zaGlmdEtleSkgPyBwYXJzZWRIb3RrZXkua2V5Q29kZSAhPT0gdm9pZCAwICYmIGV2ZW50LmtleUNvZGUgIT09IHZvaWQgMCA/IHBhcnNlZEhvdGtleS5rZXlDb2RlID09PSA5MSAmJiBldmVudC5rZXlDb2RlID09PSA5MyA/ICEwIDogcGFyc2VkSG90a2V5LmtleUNvZGUgPT09IGV2ZW50LmtleUNvZGUgOiBwYXJzZWRIb3RrZXkua2V5Q29kZSA9PT0gZXZlbnQua2V5Q29kZSB8fCBwYXJzZWRIb3RrZXkua2V5ID09PSBldmVudC5rZXkudG9Mb3dlckNhc2UoKSA6ICExO1xufVxuZnVuY3Rpb24gdG9LZXlDb2RlKG5hbWUpIHtcbiAgY29uc3Qga2V5TmFtZSA9IHRvS2V5TmFtZShuYW1lKTtcbiAgcmV0dXJuIGtleUNvZGVzW2tleU5hbWVdID8/IGtleU5hbWUudG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KDApO1xufVxuZnVuY3Rpb24gdG9LZXlOYW1lKG5hbWUpIHtcbiAgY29uc3Qga2V5TmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIGFsaWFzZXNba2V5TmFtZV0gPz8ga2V5TmFtZTtcbn1cbmNvbnN0IGRlYnVnJGYgPSBkZWJ1Z1dpdGhOYW1lKFwicGx1Z2luOndpdGhIb3RLZXlzXCIpO1xuZnVuY3Rpb24gY3JlYXRlV2l0aEhvdGtleXMoZWRpdG9yQWN0b3IsIHBvcnRhYmxlVGV4dEVkaXRvciwgaG90a2V5c0Zyb21PcHRpb25zKSB7XG4gIGNvbnN0IHJlc2VydmVkSG90a2V5cyA9IFtcImVudGVyXCIsIFwidGFiXCIsIFwic2hpZnRcIiwgXCJkZWxldGVcIiwgXCJlbmRcIl0sIGFjdGl2ZUhvdGtleXMgPSBob3RrZXlzRnJvbU9wdGlvbnMgPz8ge307XG4gIHJldHVybiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLnB0ZVdpdGhIb3RLZXlzID0gKGV2ZW50KSA9PiB7XG4gICAgICBPYmplY3Qua2V5cyhhY3RpdmVIb3RrZXlzKS5mb3JFYWNoKChjYXQpID0+IHtcbiAgICAgICAgaWYgKGNhdCA9PT0gXCJtYXJrc1wiKVxuICAgICAgICAgIGZvciAoY29uc3QgaG90a2V5IGluIGFjdGl2ZUhvdGtleXNbY2F0XSkge1xuICAgICAgICAgICAgaWYgKHJlc2VydmVkSG90a2V5cy5pbmNsdWRlcyhob3RrZXkpKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBob3RrZXkgJHtob3RrZXl9IGlzIHJlc2VydmVkIWApO1xuICAgICAgICAgICAgaWYgKGlzSG90a2V5KGhvdGtleSwgZXZlbnQubmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlTWFyayA9IGFjdGl2ZUhvdGtleXNbY2F0XTtcbiAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlTWFyaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmsgPSBwb3NzaWJsZU1hcmtbaG90a2V5XTtcbiAgICAgICAgICAgICAgICBkZWJ1ZyRmKGBIb3RLZXkgJHtob3RrZXl9IHRvIHRvZ2dsZSAke21hcmt9YCksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICAgICAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImRlY29yYXRvci50b2dnbGVcIixcbiAgICAgICAgICAgICAgICAgICAgZGVjb3JhdG9yOiBtYXJrXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgZWRpdG9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGlmIChjYXQgPT09IFwiY3VzdG9tXCIpXG4gICAgICAgICAgZm9yIChjb25zdCBob3RrZXkgaW4gYWN0aXZlSG90a2V5c1tjYXRdKSB7XG4gICAgICAgICAgICBpZiAocmVzZXJ2ZWRIb3RrZXlzLmluY2x1ZGVzKGhvdGtleSkpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGhvdGtleSAke2hvdGtleX0gaXMgcmVzZXJ2ZWQhYCk7XG4gICAgICAgICAgICBpZiAoaXNIb3RrZXkoaG90a2V5LCBldmVudC5uYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgICAgY29uc3QgcG9zc2libGVDb21tYW5kID0gYWN0aXZlSG90a2V5c1tjYXRdO1xuICAgICAgICAgICAgICBpZiAocG9zc2libGVDb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWFuZCA9IHBvc3NpYmxlQ29tbWFuZFtob3RrZXldO1xuICAgICAgICAgICAgICAgIGNvbW1hbmQoZXZlbnQsIHBvcnRhYmxlVGV4dEVkaXRvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5mdW5jdGlvbiBtb3ZlUmFuZ2VCeU9wZXJhdGlvbihyYW5nZSwgb3BlcmF0aW9uKSB7XG4gIGNvbnN0IGFuY2hvciA9IFBvaW50LnRyYW5zZm9ybShyYW5nZS5hbmNob3IsIG9wZXJhdGlvbiksIGZvY3VzID0gUG9pbnQudHJhbnNmb3JtKHJhbmdlLmZvY3VzLCBvcGVyYXRpb24pO1xuICByZXR1cm4gYW5jaG9yID09PSBudWxsIHx8IGZvY3VzID09PSBudWxsID8gbnVsbCA6IFBvaW50LmVxdWFscyhhbmNob3IsIHJhbmdlLmFuY2hvcikgJiYgUG9pbnQuZXF1YWxzKGZvY3VzLCByYW5nZS5mb2N1cykgPyByYW5nZSA6IHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXNcbiAgfTtcbn1cbmNvbnN0IHNsYXRlT3BlcmF0aW9uQ2FsbGJhY2sgPSAoe1xuICBpbnB1dCxcbiAgc2VuZEJhY2tcbn0pID0+IHtcbiAgY29uc3Qgb3JpZ2luYWxBcHBseSA9IGlucHV0LnNsYXRlRWRpdG9yLmFwcGx5O1xuICByZXR1cm4gaW5wdXQuc2xhdGVFZGl0b3IuYXBwbHkgPSAob3ApID0+IHtcbiAgICBvcC50eXBlICE9PSBcInNldF9zZWxlY3Rpb25cIiAmJiBzZW5kQmFjayh7XG4gICAgICB0eXBlOiBcInNsYXRlIG9wZXJhdGlvblwiLFxuICAgICAgb3BlcmF0aW9uOiBvcFxuICAgIH0pLCBvcmlnaW5hbEFwcGx5KG9wKTtcbiAgfSwgKCkgPT4ge1xuICAgIGlucHV0LnNsYXRlRWRpdG9yLmFwcGx5ID0gb3JpZ2luYWxBcHBseTtcbiAgfTtcbn0sIHJhbmdlRGVjb3JhdGlvbnNNYWNoaW5lID0gc2V0dXAoe1xuICB0eXBlczoge1xuICAgIGNvbnRleHQ6IHt9LFxuICAgIGlucHV0OiB7fSxcbiAgICBldmVudHM6IHt9XG4gIH0sXG4gIGFjdGlvbnM6IHtcbiAgICBcInVwZGF0ZSBwZW5kaW5nIHJhbmdlIGRlY29yYXRpb25zXCI6IGFzc2lnbih7XG4gICAgICBwZW5kaW5nUmFuZ2VEZWNvcmF0aW9uczogKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IGV2ZW50LnR5cGUgIT09IFwicmFuZ2UgZGVjb3JhdGlvbnMgdXBkYXRlZFwiID8gY29udGV4dC5wZW5kaW5nUmFuZ2VEZWNvcmF0aW9ucyA6IGV2ZW50LnJhbmdlRGVjb3JhdGlvbnNcbiAgICB9KSxcbiAgICBcInNldCB1cCBpbml0aWFsIHJhbmdlIGRlY29yYXRpb25zXCI6ICh7XG4gICAgICBjb250ZXh0XG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgcmFuZ2VEZWNvcmF0aW9uU3RhdGUgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgcmFuZ2VEZWNvcmF0aW9uIG9mIGNvbnRleHQucGVuZGluZ1JhbmdlRGVjb3JhdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc2xhdGVSYW5nZSA9IHRvU2xhdGVSYW5nZSh7XG4gICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgc2NoZW1hOiBjb250ZXh0LnNjaGVtYSxcbiAgICAgICAgICAgIHZhbHVlOiBjb250ZXh0LnNsYXRlRWRpdG9yLnZhbHVlLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiByYW5nZURlY29yYXRpb24uc2VsZWN0aW9uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBibG9ja0luZGV4TWFwOiBjb250ZXh0LnNsYXRlRWRpdG9yLmJsb2NrSW5kZXhNYXBcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghUmFuZ2UuaXNSYW5nZShzbGF0ZVJhbmdlKSkge1xuICAgICAgICAgIHJhbmdlRGVjb3JhdGlvbi5vbk1vdmVkPy4oe1xuICAgICAgICAgICAgbmV3U2VsZWN0aW9uOiBudWxsLFxuICAgICAgICAgICAgcmFuZ2VEZWNvcmF0aW9uLFxuICAgICAgICAgICAgb3JpZ2luOiBcImxvY2FsXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByYW5nZURlY29yYXRpb25TdGF0ZS5wdXNoKHtcbiAgICAgICAgICByYW5nZURlY29yYXRpb24sXG4gICAgICAgICAgLi4uc2xhdGVSYW5nZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuc2xhdGVFZGl0b3IuZGVjb3JhdGVkUmFuZ2VzID0gcmFuZ2VEZWNvcmF0aW9uU3RhdGU7XG4gICAgfSxcbiAgICBcInVwZGF0ZSByYW5nZSBkZWNvcmF0aW9uc1wiOiAoe1xuICAgICAgY29udGV4dCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4ge1xuICAgICAgaWYgKGV2ZW50LnR5cGUgIT09IFwicmFuZ2UgZGVjb3JhdGlvbnMgdXBkYXRlZFwiKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCByYW5nZURlY29yYXRpb25TdGF0ZSA9IFtdO1xuICAgICAgZm9yIChjb25zdCByYW5nZURlY29yYXRpb24gb2YgZXZlbnQucmFuZ2VEZWNvcmF0aW9ucykge1xuICAgICAgICBjb25zdCBzbGF0ZVJhbmdlID0gdG9TbGF0ZVJhbmdlKHtcbiAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICBzY2hlbWE6IGNvbnRleHQuc2NoZW1hLFxuICAgICAgICAgICAgdmFsdWU6IGNvbnRleHQuc2xhdGVFZGl0b3IudmFsdWUsXG4gICAgICAgICAgICBzZWxlY3Rpb246IHJhbmdlRGVjb3JhdGlvbi5zZWxlY3Rpb25cbiAgICAgICAgICB9LFxuICAgICAgICAgIGJsb2NrSW5kZXhNYXA6IGNvbnRleHQuc2xhdGVFZGl0b3IuYmxvY2tJbmRleE1hcFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFSYW5nZS5pc1JhbmdlKHNsYXRlUmFuZ2UpKSB7XG4gICAgICAgICAgcmFuZ2VEZWNvcmF0aW9uLm9uTW92ZWQ/Lih7XG4gICAgICAgICAgICBuZXdTZWxlY3Rpb246IG51bGwsXG4gICAgICAgICAgICByYW5nZURlY29yYXRpb24sXG4gICAgICAgICAgICBvcmlnaW46IFwibG9jYWxcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJhbmdlRGVjb3JhdGlvblN0YXRlLnB1c2goe1xuICAgICAgICAgIHJhbmdlRGVjb3JhdGlvbixcbiAgICAgICAgICAuLi5zbGF0ZVJhbmdlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29udGV4dC5zbGF0ZUVkaXRvci5kZWNvcmF0ZWRSYW5nZXMgPSByYW5nZURlY29yYXRpb25TdGF0ZTtcbiAgICB9LFxuICAgIFwibW92ZSByYW5nZSBkZWNvcmF0aW9uc1wiOiAoe1xuICAgICAgY29udGV4dCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4ge1xuICAgICAgaWYgKGV2ZW50LnR5cGUgIT09IFwic2xhdGUgb3BlcmF0aW9uXCIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHJhbmdlRGVjb3JhdGlvblN0YXRlID0gW107XG4gICAgICBmb3IgKGNvbnN0IGRlY29yYXRlZFJhbmdlIG9mIGNvbnRleHQuc2xhdGVFZGl0b3IuZGVjb3JhdGVkUmFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IHNsYXRlUmFuZ2UgPSB0b1NsYXRlUmFuZ2Uoe1xuICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgIHNjaGVtYTogY29udGV4dC5zY2hlbWEsXG4gICAgICAgICAgICB2YWx1ZTogY29udGV4dC5zbGF0ZUVkaXRvci52YWx1ZSxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogZGVjb3JhdGVkUmFuZ2UucmFuZ2VEZWNvcmF0aW9uLnNlbGVjdGlvblxuICAgICAgICAgIH0sXG4gICAgICAgICAgYmxvY2tJbmRleE1hcDogY29udGV4dC5zbGF0ZUVkaXRvci5ibG9ja0luZGV4TWFwXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIVJhbmdlLmlzUmFuZ2Uoc2xhdGVSYW5nZSkpIHtcbiAgICAgICAgICBkZWNvcmF0ZWRSYW5nZS5yYW5nZURlY29yYXRpb24ub25Nb3ZlZD8uKHtcbiAgICAgICAgICAgIG5ld1NlbGVjdGlvbjogbnVsbCxcbiAgICAgICAgICAgIHJhbmdlRGVjb3JhdGlvbjogZGVjb3JhdGVkUmFuZ2UucmFuZ2VEZWNvcmF0aW9uLFxuICAgICAgICAgICAgb3JpZ2luOiBcImxvY2FsXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3UmFuZ2U7XG4gICAgICAgIGlmIChuZXdSYW5nZSA9IG1vdmVSYW5nZUJ5T3BlcmF0aW9uKHNsYXRlUmFuZ2UsIGV2ZW50Lm9wZXJhdGlvbiksIG5ld1JhbmdlICYmIG5ld1JhbmdlICE9PSBzbGF0ZVJhbmdlIHx8IG5ld1JhbmdlID09PSBudWxsICYmIHNsYXRlUmFuZ2UpIHtcbiAgICAgICAgICBjb25zdCBuZXdSYW5nZVNlbGVjdGlvbiA9IG5ld1JhbmdlID8gc2xhdGVSYW5nZVRvU2VsZWN0aW9uKHtcbiAgICAgICAgICAgIHNjaGVtYTogY29udGV4dC5zY2hlbWEsXG4gICAgICAgICAgICBlZGl0b3I6IGNvbnRleHQuc2xhdGVFZGl0b3IsXG4gICAgICAgICAgICByYW5nZTogbmV3UmFuZ2VcbiAgICAgICAgICB9KSA6IG51bGw7XG4gICAgICAgICAgZGVjb3JhdGVkUmFuZ2UucmFuZ2VEZWNvcmF0aW9uLm9uTW92ZWQ/Lih7XG4gICAgICAgICAgICBuZXdTZWxlY3Rpb246IG5ld1JhbmdlU2VsZWN0aW9uLFxuICAgICAgICAgICAgcmFuZ2VEZWNvcmF0aW9uOiBkZWNvcmF0ZWRSYW5nZS5yYW5nZURlY29yYXRpb24sXG4gICAgICAgICAgICBvcmlnaW46IFwibG9jYWxcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIG5ld1JhbmdlICE9PSBudWxsICYmIHJhbmdlRGVjb3JhdGlvblN0YXRlLnB1c2goe1xuICAgICAgICAgIC4uLm5ld1JhbmdlIHx8IHNsYXRlUmFuZ2UsXG4gICAgICAgICAgcmFuZ2VEZWNvcmF0aW9uOiB7XG4gICAgICAgICAgICAuLi5kZWNvcmF0ZWRSYW5nZS5yYW5nZURlY29yYXRpb24sXG4gICAgICAgICAgICBzZWxlY3Rpb246IHNsYXRlUmFuZ2VUb1NlbGVjdGlvbih7XG4gICAgICAgICAgICAgIHNjaGVtYTogY29udGV4dC5zY2hlbWEsXG4gICAgICAgICAgICAgIGVkaXRvcjogY29udGV4dC5zbGF0ZUVkaXRvcixcbiAgICAgICAgICAgICAgcmFuZ2U6IG5ld1JhbmdlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LnNsYXRlRWRpdG9yLmRlY29yYXRlZFJhbmdlcyA9IHJhbmdlRGVjb3JhdGlvblN0YXRlO1xuICAgIH0sXG4gICAgXCJhc3NpZ24gcmVhZE9ubHlcIjogYXNzaWduKHtcbiAgICAgIHJlYWRPbmx5OiAoe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gZXZlbnQudHlwZSAhPT0gXCJ1cGRhdGUgcmVhZCBvbmx5XCIgPyBjb250ZXh0LnJlYWRPbmx5IDogZXZlbnQucmVhZE9ubHlcbiAgICB9KSxcbiAgICBcInVwZGF0ZSBkZWNvcmF0ZVwiOiBhc3NpZ24oe1xuICAgICAgZGVjb3JhdGU6ICh7XG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pID0+ICh7XG4gICAgICAgIGZuOiBjcmVhdGVEZWNvcmF0ZShjb250ZXh0LnNjaGVtYSwgY29udGV4dC5zbGF0ZUVkaXRvcilcbiAgICAgIH0pXG4gICAgfSlcbiAgfSxcbiAgYWN0b3JzOiB7XG4gICAgXCJzbGF0ZSBvcGVyYXRpb24gbGlzdGVuZXJcIjogZnJvbUNhbGxiYWNrKHNsYXRlT3BlcmF0aW9uQ2FsbGJhY2spXG4gIH0sXG4gIGd1YXJkczoge1xuICAgIFwiaGFzIHBlbmRpbmcgcmFuZ2UgZGVjb3JhdGlvbnNcIjogKHtcbiAgICAgIGNvbnRleHRcbiAgICB9KSA9PiBjb250ZXh0LnBlbmRpbmdSYW5nZURlY29yYXRpb25zLmxlbmd0aCA+IDAsXG4gICAgXCJoYXMgcmFuZ2UgZGVjb3JhdGlvbnNcIjogKHtcbiAgICAgIGNvbnRleHRcbiAgICB9KSA9PiBjb250ZXh0LnNsYXRlRWRpdG9yLmRlY29yYXRlZFJhbmdlcy5sZW5ndGggPiAwLFxuICAgIFwiaGFzIGRpZmZlcmVudCBkZWNvcmF0aW9uc1wiOiAoe1xuICAgICAgY29udGV4dCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4ge1xuICAgICAgaWYgKGV2ZW50LnR5cGUgIT09IFwicmFuZ2UgZGVjb3JhdGlvbnMgdXBkYXRlZFwiKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBleGlzdGluZ1JhbmdlRGVjb3JhdGlvbnMgPSBjb250ZXh0LnNsYXRlRWRpdG9yLmRlY29yYXRlZFJhbmdlcy5tYXAoKGRlY29yYXRlZFJhbmdlKSA9PiAoe1xuICAgICAgICBhbmNob3I6IGRlY29yYXRlZFJhbmdlLnJhbmdlRGVjb3JhdGlvbi5zZWxlY3Rpb24/LmFuY2hvcixcbiAgICAgICAgZm9jdXM6IGRlY29yYXRlZFJhbmdlLnJhbmdlRGVjb3JhdGlvbi5zZWxlY3Rpb24/LmZvY3VzLFxuICAgICAgICBwYXlsb2FkOiBkZWNvcmF0ZWRSYW5nZS5yYW5nZURlY29yYXRpb24ucGF5bG9hZFxuICAgICAgfSkpLCBuZXdSYW5nZURlY29yYXRpb25zID0gZXZlbnQucmFuZ2VEZWNvcmF0aW9ucy5tYXAoKHJhbmdlRGVjb3JhdGlvbikgPT4gKHtcbiAgICAgICAgYW5jaG9yOiByYW5nZURlY29yYXRpb24uc2VsZWN0aW9uPy5hbmNob3IsXG4gICAgICAgIGZvY3VzOiByYW5nZURlY29yYXRpb24uc2VsZWN0aW9uPy5mb2N1cyxcbiAgICAgICAgcGF5bG9hZDogcmFuZ2VEZWNvcmF0aW9uLnBheWxvYWRcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiAhaXNFcXVhbChleGlzdGluZ1JhbmdlRGVjb3JhdGlvbnMsIG5ld1JhbmdlRGVjb3JhdGlvbnMpO1xuICAgIH0sXG4gICAgXCJub3QgcmVhZCBvbmx5XCI6ICh7XG4gICAgICBjb250ZXh0XG4gICAgfSkgPT4gIWNvbnRleHQucmVhZE9ubHksXG4gICAgXCJzaG91bGQgc2tpcCBzZXR1cFwiOiAoe1xuICAgICAgY29udGV4dFxuICAgIH0pID0+IGNvbnRleHQuc2tpcFNldHVwXG4gIH1cbn0pLmNyZWF0ZU1hY2hpbmUoe1xuICBpZDogXCJyYW5nZSBkZWNvcmF0aW9uc1wiLFxuICBjb250ZXh0OiAoe1xuICAgIGlucHV0XG4gIH0pID0+ICh7XG4gICAgcmVhZE9ubHk6IGlucHV0LnJlYWRPbmx5LFxuICAgIHBlbmRpbmdSYW5nZURlY29yYXRpb25zOiBpbnB1dC5yYW5nZURlY29yYXRpb25zLFxuICAgIGRlY29yYXRlZFJhbmdlczogW10sXG4gICAgc2tpcFNldHVwOiBpbnB1dC5za2lwU2V0dXAsXG4gICAgc2NoZW1hOiBpbnB1dC5zY2hlbWEsXG4gICAgc2xhdGVFZGl0b3I6IGlucHV0LnNsYXRlRWRpdG9yLFxuICAgIGRlY29yYXRlOiB7XG4gICAgICBmbjogY3JlYXRlRGVjb3JhdGUoaW5wdXQuc2NoZW1hLCBpbnB1dC5zbGF0ZUVkaXRvcilcbiAgICB9XG4gIH0pLFxuICBpbnZva2U6IHtcbiAgICBzcmM6IFwic2xhdGUgb3BlcmF0aW9uIGxpc3RlbmVyXCIsXG4gICAgaW5wdXQ6ICh7XG4gICAgICBjb250ZXh0XG4gICAgfSkgPT4gKHtcbiAgICAgIHNsYXRlRWRpdG9yOiBjb250ZXh0LnNsYXRlRWRpdG9yXG4gICAgfSlcbiAgfSxcbiAgb246IHtcbiAgICBcInVwZGF0ZSByZWFkIG9ubHlcIjoge1xuICAgICAgYWN0aW9uczogW1wiYXNzaWduIHJlYWRPbmx5XCJdXG4gICAgfVxuICB9LFxuICBpbml0aWFsOiBcInNldHRpbmcgdXBcIixcbiAgc3RhdGVzOiB7XG4gICAgXCJzZXR0aW5nIHVwXCI6IHtcbiAgICAgIGFsd2F5czogW3tcbiAgICAgICAgZ3VhcmQ6IGFuZChbXCJzaG91bGQgc2tpcCBzZXR1cFwiLCBcImhhcyBwZW5kaW5nIHJhbmdlIGRlY29yYXRpb25zXCJdKSxcbiAgICAgICAgdGFyZ2V0OiBcInJlYWR5XCIsXG4gICAgICAgIGFjdGlvbnM6IFtcInNldCB1cCBpbml0aWFsIHJhbmdlIGRlY29yYXRpb25zXCIsIFwidXBkYXRlIGRlY29yYXRlXCJdXG4gICAgICB9LCB7XG4gICAgICAgIGd1YXJkOiBcInNob3VsZCBza2lwIHNldHVwXCIsXG4gICAgICAgIHRhcmdldDogXCJyZWFkeVwiXG4gICAgICB9XSxcbiAgICAgIG9uOiB7XG4gICAgICAgIFwicmFuZ2UgZGVjb3JhdGlvbnMgdXBkYXRlZFwiOiB7XG4gICAgICAgICAgYWN0aW9uczogW1widXBkYXRlIHBlbmRpbmcgcmFuZ2UgZGVjb3JhdGlvbnNcIl1cbiAgICAgICAgfSxcbiAgICAgICAgcmVhZHk6IFt7XG4gICAgICAgICAgdGFyZ2V0OiBcInJlYWR5XCIsXG4gICAgICAgICAgZ3VhcmQ6IFwiaGFzIHBlbmRpbmcgcmFuZ2UgZGVjb3JhdGlvbnNcIixcbiAgICAgICAgICBhY3Rpb25zOiBbXCJzZXQgdXAgaW5pdGlhbCByYW5nZSBkZWNvcmF0aW9uc1wiLCBcInVwZGF0ZSBkZWNvcmF0ZVwiXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgdGFyZ2V0OiBcInJlYWR5XCJcbiAgICAgICAgfV1cbiAgICAgIH1cbiAgICB9LFxuICAgIHJlYWR5OiB7XG4gICAgICBpbml0aWFsOiBcImlkbGVcIixcbiAgICAgIG9uOiB7XG4gICAgICAgIFwicmFuZ2UgZGVjb3JhdGlvbnMgdXBkYXRlZFwiOiB7XG4gICAgICAgICAgdGFyZ2V0OiBcIi5pZGxlXCIsXG4gICAgICAgICAgZ3VhcmQ6IFwiaGFzIGRpZmZlcmVudCBkZWNvcmF0aW9uc1wiLFxuICAgICAgICAgIGFjdGlvbnM6IFtcInVwZGF0ZSByYW5nZSBkZWNvcmF0aW9uc1wiLCBcInVwZGF0ZSBkZWNvcmF0ZVwiXVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3RhdGVzOiB7XG4gICAgICAgIGlkbGU6IHtcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgXCJzbGF0ZSBvcGVyYXRpb25cIjoge1xuICAgICAgICAgICAgICB0YXJnZXQ6IFwibW92aW5nIHJhbmdlIGRlY29yYXRpb25zXCIsXG4gICAgICAgICAgICAgIGd1YXJkOiBhbmQoW1wiaGFzIHJhbmdlIGRlY29yYXRpb25zXCIsIFwibm90IHJlYWQgb25seVwiXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwibW92aW5nIHJhbmdlIGRlY29yYXRpb25zXCI6IHtcbiAgICAgICAgICBlbnRyeTogW1wibW92ZSByYW5nZSBkZWNvcmF0aW9uc1wiXSxcbiAgICAgICAgICBhbHdheXM6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJpZGxlXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuZnVuY3Rpb24gY3JlYXRlRGVjb3JhdGUoc2NoZW1hLCBzbGF0ZUVkaXRvcikge1xuICByZXR1cm4gZnVuY3Rpb24oW25vZGUsIHBhdGhdKSB7XG4gICAgaWYgKGlzRXF1YWxUb0VtcHR5RWRpdG9yKHNsYXRlRWRpdG9yLmNoaWxkcmVuLCBzY2hlbWEpKVxuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgIHBhdGg6IFswLCAwXSxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICBwYXRoOiBbMCwgMF0sXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIHBsYWNlaG9sZGVyOiAhMFxuICAgICAgfV07XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGlmICghRWxlbWVudCQxLmlzRWxlbWVudChub2RlKSB8fCBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCBibG9ja0luZGV4ID0gcGF0aC5hdCgwKTtcbiAgICByZXR1cm4gYmxvY2tJbmRleCA9PT0gdm9pZCAwID8gW10gOiBzbGF0ZUVkaXRvci5kZWNvcmF0ZWRSYW5nZXMuZmlsdGVyKChkZWNvcmF0ZWRSYW5nZSkgPT4gUmFuZ2UuaXNDb2xsYXBzZWQoZGVjb3JhdGVkUmFuZ2UpID8gbm9kZS5jaGlsZHJlbi5zb21lKChfLCBjaGlsZEluZGV4KSA9PiBQYXRoLmVxdWFscyhkZWNvcmF0ZWRSYW5nZS5hbmNob3IucGF0aCwgW2Jsb2NrSW5kZXgsIGNoaWxkSW5kZXhdKSAmJiBQYXRoLmVxdWFscyhkZWNvcmF0ZWRSYW5nZS5mb2N1cy5wYXRoLCBbYmxvY2tJbmRleCwgY2hpbGRJbmRleF0pKSA6IFJhbmdlLmludGVyc2VjdGlvbihkZWNvcmF0ZWRSYW5nZSwge1xuICAgICAgYW5jaG9yOiB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIGZvY3VzOiB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfVxuICAgIH0pIHx8IFJhbmdlLmluY2x1ZGVzKGRlY29yYXRlZFJhbmdlLCBwYXRoKSk7XG4gIH07XG59XG5jb25zdCBSZWxheUFjdG9yQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe30pLCBkZWJ1ZyRlID0gZGVidWdXaXRoTmFtZShcInZhbGlkYXRlIHNlbGVjdGlvbiBtYWNoaW5lXCIpLCB2YWxpZGF0ZVNlbGVjdGlvblNldHVwID0gc2V0dXAoe1xuICB0eXBlczoge1xuICAgIGNvbnRleHQ6IHt9LFxuICAgIGlucHV0OiB7fSxcbiAgICBldmVudHM6IHt9XG4gIH0sXG4gIGd1YXJkczoge1xuICAgIFwicGVuZGluZyBvcGVyYXRpb25zXCI6ICh7XG4gICAgICBjb250ZXh0XG4gICAgfSkgPT4gY29udGV4dC5zbGF0ZUVkaXRvci5vcGVyYXRpb25zLmxlbmd0aCA+IDBcbiAgfVxufSksIHZhbGlkYXRlU2VsZWN0aW9uQWN0aW9uID0gdmFsaWRhdGVTZWxlY3Rpb25TZXR1cC5jcmVhdGVBY3Rpb24oKHtcbiAgY29udGV4dCxcbiAgZXZlbnRcbn0pID0+IHtcbiAgdmFsaWRhdGVTZWxlY3Rpb24oY29udGV4dC5zbGF0ZUVkaXRvciwgZXZlbnQuZWRpdG9yRWxlbWVudCk7XG59KSwgdmFsaWRhdGVTZWxlY3Rpb25NYWNoaW5lID0gdmFsaWRhdGVTZWxlY3Rpb25TZXR1cC5jcmVhdGVNYWNoaW5lKHtcbiAgaWQ6IFwidmFsaWRhdGUgc2VsZWN0aW9uXCIsXG4gIGNvbnRleHQ6ICh7XG4gICAgaW5wdXRcbiAgfSkgPT4gKHtcbiAgICBzbGF0ZUVkaXRvcjogaW5wdXQuc2xhdGVFZGl0b3JcbiAgfSksXG4gIGluaXRpYWw6IFwiaWRsZVwiLFxuICBzdGF0ZXM6IHtcbiAgICBpZGxlOiB7XG4gICAgICBvbjoge1xuICAgICAgICBcInZhbGlkYXRlIHNlbGVjdGlvblwiOiBbe1xuICAgICAgICAgIGd1YXJkOiBcInBlbmRpbmcgb3BlcmF0aW9uc1wiLFxuICAgICAgICAgIHRhcmdldDogXCJ3YWl0aW5nXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGFjdGlvbnM6IFt2YWxpZGF0ZVNlbGVjdGlvbkFjdGlvbl0sXG4gICAgICAgICAgdGFyZ2V0OiBcImlkbGVcIlxuICAgICAgICB9XVxuICAgICAgfVxuICAgIH0sXG4gICAgd2FpdGluZzoge1xuICAgICAgYWZ0ZXI6IHtcbiAgICAgICAgMDogW3tcbiAgICAgICAgICBndWFyZDogXCJwZW5kaW5nIG9wZXJhdGlvbnNcIixcbiAgICAgICAgICB0YXJnZXQ6IFwiLlwiLFxuICAgICAgICAgIHJlZW50ZXI6ICEwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0YXJnZXQ6IFwiaWRsZVwiLFxuICAgICAgICAgIGFjdGlvbnM6IFt2YWxpZGF0ZVNlbGVjdGlvbkFjdGlvbl1cbiAgICAgICAgfV1cbiAgICAgIH0sXG4gICAgICBvbjoge1xuICAgICAgICBcInZhbGlkYXRlIHNlbGVjdGlvblwiOiB7XG4gICAgICAgICAgdGFyZ2V0OiBcIi5cIixcbiAgICAgICAgICByZWVudGVyOiAhMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbmZ1bmN0aW9uIHZhbGlkYXRlU2VsZWN0aW9uKHNsYXRlRWRpdG9yLCBlZGl0b3JFbGVtZW50KSB7XG4gIGlmICghc2xhdGVFZGl0b3Iuc2VsZWN0aW9uKVxuICAgIHJldHVybjtcbiAgbGV0IHJvb3Q7XG4gIHRyeSB7XG4gICAgcm9vdCA9IFJlYWN0RWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChzbGF0ZUVkaXRvcik7XG4gIH0gY2F0Y2gge1xuICB9XG4gIGlmICghcm9vdCB8fCBlZGl0b3JFbGVtZW50ICE9PSByb290LmFjdGl2ZUVsZW1lbnQpXG4gICAgcmV0dXJuO1xuICBjb25zdCBkb21TZWxlY3Rpb24gPSBSZWFjdEVkaXRvci5nZXRXaW5kb3coc2xhdGVFZGl0b3IpLmdldFNlbGVjdGlvbigpO1xuICBpZiAoIWRvbVNlbGVjdGlvbiB8fCBkb21TZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMClcbiAgICByZXR1cm47XG4gIGNvbnN0IGV4aXN0aW5nRE9NUmFuZ2UgPSBkb21TZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBuZXdET01SYW5nZSA9IFJlYWN0RWRpdG9yLnRvRE9NUmFuZ2Uoc2xhdGVFZGl0b3IsIHNsYXRlRWRpdG9yLnNlbGVjdGlvbik7XG4gICAgKG5ld0RPTVJhbmdlLnN0YXJ0T2Zmc2V0ICE9PSBleGlzdGluZ0RPTVJhbmdlLnN0YXJ0T2Zmc2V0IHx8IG5ld0RPTVJhbmdlLmVuZE9mZnNldCAhPT0gZXhpc3RpbmdET01SYW5nZS5lbmRPZmZzZXQpICYmIChkZWJ1ZyRlKFwiRE9NIHJhbmdlIG91dCBvZiBzeW5jLCB2YWxpZGF0aW5nIHNlbGVjdGlvblwiKSwgZG9tU2VsZWN0aW9uPy5yZW1vdmVBbGxSYW5nZXMoKSwgZG9tU2VsZWN0aW9uLmFkZFJhbmdlKG5ld0RPTVJhbmdlKSk7XG4gIH0gY2F0Y2gge1xuICAgIGRlYnVnJGUoXCJDb3VsZCBub3QgcmVzb2x2ZSBzZWxlY3Rpb24sIHNlbGVjdGluZyB0b3AgZG9jdW1lbnRcIiksIFRyYW5zZm9ybXMuZGVzZWxlY3Qoc2xhdGVFZGl0b3IpLCBzbGF0ZUVkaXRvci5jaGlsZHJlbi5sZW5ndGggPiAwICYmIFRyYW5zZm9ybXMuc2VsZWN0KHNsYXRlRWRpdG9yLCBFZGl0b3Iuc3RhcnQoc2xhdGVFZGl0b3IsIFtdKSksIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCk7XG4gIH1cbn1cbmNvbnN0IElTX1BST0NFU1NJTkdfUkVNT1RFX0NIQU5HRVMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgS0VZX1RPX1NMQVRFX0VMRU1FTlQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgU0xBVEVfVE9fUE9SVEFCTEVfVEVYVF9SQU5HRSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBkZWJ1ZyRkID0gZGVidWdXaXRoTmFtZShcImNvbXBvbmVudDpFZGl0YWJsZVwiKSwgUG9ydGFibGVUZXh0RWRpdGFibGUgPSBmb3J3YXJkUmVmKGZ1bmN0aW9uKHByb3BzLCBmb3J3YXJkZWRSZWYpIHtcbiAgY29uc3QgJCA9IGMoMTc0KTtcbiAgbGV0IGhvdGtleXMsIG9uQmVmb3JlSW5wdXQsIG9uQmx1ciwgb25DbGljaywgb25Db3B5LCBvbkN1dCwgb25EcmFnLCBvbkRyYWdFbmQsIG9uRHJhZ0VudGVyLCBvbkRyYWdMZWF2ZSwgb25EcmFnT3Zlciwgb25EcmFnU3RhcnQsIG9uRHJvcCwgb25Gb2N1cywgb25QYXN0ZSwgcHJvcHNTZWxlY3Rpb24sIHJhbmdlRGVjb3JhdGlvbnMsIHJlbmRlckFubm90YXRpb24sIHJlbmRlckJsb2NrLCByZW5kZXJDaGlsZCwgcmVuZGVyRGVjb3JhdG9yLCByZW5kZXJMaXN0SXRlbSwgcmVuZGVyUGxhY2Vob2xkZXIsIHJlbmRlclN0eWxlLCByZXN0UHJvcHMsIHNjcm9sbFNlbGVjdGlvbkludG9WaWV3LCBzcGVsbENoZWNrO1xuICAkWzBdICE9PSBwcm9wcyA/ICh7XG4gICAgaG90a2V5cyxcbiAgICBvbkJsdXIsXG4gICAgb25Gb2N1cyxcbiAgICBvbkJlZm9yZUlucHV0LFxuICAgIG9uUGFzdGUsXG4gICAgb25Db3B5LFxuICAgIG9uQ3V0LFxuICAgIG9uQ2xpY2ssXG4gICAgb25EcmFnU3RhcnQsXG4gICAgb25EcmFnLFxuICAgIG9uRHJhZ0VuZCxcbiAgICBvbkRyYWdFbnRlcixcbiAgICBvbkRyYWdPdmVyLFxuICAgIG9uRHJvcCxcbiAgICBvbkRyYWdMZWF2ZSxcbiAgICByYW5nZURlY29yYXRpb25zLFxuICAgIHJlbmRlckFubm90YXRpb24sXG4gICAgcmVuZGVyQmxvY2ssXG4gICAgcmVuZGVyQ2hpbGQsXG4gICAgcmVuZGVyRGVjb3JhdG9yLFxuICAgIHJlbmRlckxpc3RJdGVtLFxuICAgIHJlbmRlclBsYWNlaG9sZGVyLFxuICAgIHJlbmRlclN0eWxlLFxuICAgIHNlbGVjdGlvbjogcHJvcHNTZWxlY3Rpb24sXG4gICAgc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcsXG4gICAgc3BlbGxDaGVjayxcbiAgICAuLi5yZXN0UHJvcHNcbiAgfSA9IHByb3BzLCAkWzBdID0gcHJvcHMsICRbMV0gPSBob3RrZXlzLCAkWzJdID0gb25CZWZvcmVJbnB1dCwgJFszXSA9IG9uQmx1ciwgJFs0XSA9IG9uQ2xpY2ssICRbNV0gPSBvbkNvcHksICRbNl0gPSBvbkN1dCwgJFs3XSA9IG9uRHJhZywgJFs4XSA9IG9uRHJhZ0VuZCwgJFs5XSA9IG9uRHJhZ0VudGVyLCAkWzEwXSA9IG9uRHJhZ0xlYXZlLCAkWzExXSA9IG9uRHJhZ092ZXIsICRbMTJdID0gb25EcmFnU3RhcnQsICRbMTNdID0gb25Ecm9wLCAkWzE0XSA9IG9uRm9jdXMsICRbMTVdID0gb25QYXN0ZSwgJFsxNl0gPSBwcm9wc1NlbGVjdGlvbiwgJFsxN10gPSByYW5nZURlY29yYXRpb25zLCAkWzE4XSA9IHJlbmRlckFubm90YXRpb24sICRbMTldID0gcmVuZGVyQmxvY2ssICRbMjBdID0gcmVuZGVyQ2hpbGQsICRbMjFdID0gcmVuZGVyRGVjb3JhdG9yLCAkWzIyXSA9IHJlbmRlckxpc3RJdGVtLCAkWzIzXSA9IHJlbmRlclBsYWNlaG9sZGVyLCAkWzI0XSA9IHJlbmRlclN0eWxlLCAkWzI1XSA9IHJlc3RQcm9wcywgJFsyNl0gPSBzY3JvbGxTZWxlY3Rpb25JbnRvVmlldywgJFsyN10gPSBzcGVsbENoZWNrKSA6IChob3RrZXlzID0gJFsxXSwgb25CZWZvcmVJbnB1dCA9ICRbMl0sIG9uQmx1ciA9ICRbM10sIG9uQ2xpY2sgPSAkWzRdLCBvbkNvcHkgPSAkWzVdLCBvbkN1dCA9ICRbNl0sIG9uRHJhZyA9ICRbN10sIG9uRHJhZ0VuZCA9ICRbOF0sIG9uRHJhZ0VudGVyID0gJFs5XSwgb25EcmFnTGVhdmUgPSAkWzEwXSwgb25EcmFnT3ZlciA9ICRbMTFdLCBvbkRyYWdTdGFydCA9ICRbMTJdLCBvbkRyb3AgPSAkWzEzXSwgb25Gb2N1cyA9ICRbMTRdLCBvblBhc3RlID0gJFsxNV0sIHByb3BzU2VsZWN0aW9uID0gJFsxNl0sIHJhbmdlRGVjb3JhdGlvbnMgPSAkWzE3XSwgcmVuZGVyQW5ub3RhdGlvbiA9ICRbMThdLCByZW5kZXJCbG9jayA9ICRbMTldLCByZW5kZXJDaGlsZCA9ICRbMjBdLCByZW5kZXJEZWNvcmF0b3IgPSAkWzIxXSwgcmVuZGVyTGlzdEl0ZW0gPSAkWzIyXSwgcmVuZGVyUGxhY2Vob2xkZXIgPSAkWzIzXSwgcmVuZGVyU3R5bGUgPSAkWzI0XSwgcmVzdFByb3BzID0gJFsyNV0sIHNjcm9sbFNlbGVjdGlvbkludG9WaWV3ID0gJFsyNl0sIHNwZWxsQ2hlY2sgPSAkWzI3XSk7XG4gIGNvbnN0IHBvcnRhYmxlVGV4dEVkaXRvciA9IHVzZVBvcnRhYmxlVGV4dEVkaXRvcigpLCBbaGFzSW52YWxpZFZhbHVlLCBzZXRIYXNJbnZhbGlkVmFsdWVdID0gdXNlU3RhdGUoITEpLCBlZGl0b3JBY3RvciA9IHVzZUNvbnRleHQoRWRpdG9yQWN0b3JDb250ZXh0KSwgcmVsYXlBY3RvciA9IHVzZUNvbnRleHQoUmVsYXlBY3RvckNvbnRleHQpLCByZWFkT25seSA9IHVzZVNlbGVjdG9yKGVkaXRvckFjdG9yLCBfdGVtcCksIHNsYXRlRWRpdG9yID0gdXNlU2xhdGUoKTtcbiAgbGV0IHQwO1xuICAkWzI4XSAhPT0gc2xhdGVFZGl0b3IgPyAodDAgPSB7XG4gICAgaW5wdXQ6IHtcbiAgICAgIHNsYXRlRWRpdG9yXG4gICAgfVxuICB9LCAkWzI4XSA9IHNsYXRlRWRpdG9yLCAkWzI5XSA9IHQwKSA6IHQwID0gJFsyOV07XG4gIGNvbnN0IHZhbGlkYXRlU2VsZWN0aW9uQWN0b3IgPSB1c2VBY3RvclJlZih2YWxpZGF0ZVNlbGVjdGlvbk1hY2hpbmUsIHQwKTtcbiAgbGV0IHQxO1xuICAkWzMwXSAhPT0gcmFuZ2VEZWNvcmF0aW9ucyA/ICh0MSA9IHJhbmdlRGVjb3JhdGlvbnMgPz8gW10sICRbMzBdID0gcmFuZ2VEZWNvcmF0aW9ucywgJFszMV0gPSB0MSkgOiB0MSA9ICRbMzFdO1xuICBsZXQgdDI7XG4gICRbMzJdICE9PSBlZGl0b3JBY3RvciA/ICh0MiA9IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCksICRbMzJdID0gZWRpdG9yQWN0b3IsICRbMzNdID0gdDIpIDogdDIgPSAkWzMzXTtcbiAgY29uc3QgdDMgPSAhZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5tYXRjaGVzKHtcbiAgICBzZXR1cDogXCJzZXR0aW5nIHVwXCJcbiAgfSk7XG4gIGxldCB0NDtcbiAgJFszNF0gIT09IHJlYWRPbmx5IHx8ICRbMzVdICE9PSBzbGF0ZUVkaXRvciB8fCAkWzM2XSAhPT0gdDEgfHwgJFszN10gIT09IHQyLmNvbnRleHQuc2NoZW1hIHx8ICRbMzhdICE9PSB0MyA/ICh0NCA9IHtcbiAgICBpbnB1dDoge1xuICAgICAgcmFuZ2VEZWNvcmF0aW9uczogdDEsXG4gICAgICByZWFkT25seSxcbiAgICAgIHNjaGVtYTogdDIuY29udGV4dC5zY2hlbWEsXG4gICAgICBzbGF0ZUVkaXRvcixcbiAgICAgIHNraXBTZXR1cDogdDNcbiAgICB9XG4gIH0sICRbMzRdID0gcmVhZE9ubHksICRbMzVdID0gc2xhdGVFZGl0b3IsICRbMzZdID0gdDEsICRbMzddID0gdDIuY29udGV4dC5zY2hlbWEsICRbMzhdID0gdDMsICRbMzldID0gdDQpIDogdDQgPSAkWzM5XTtcbiAgY29uc3QgcmFuZ2VEZWNvcmF0aW9uc0FjdG9yID0gdXNlQWN0b3JSZWYocmFuZ2VEZWNvcmF0aW9uc01hY2hpbmUsIHQ0KSwgZGVjb3JhdGUgPSB1c2VTZWxlY3RvcihyYW5nZURlY29yYXRpb25zQWN0b3IsIF90ZW1wMik7XG4gIGxldCB0NSwgdDY7XG4gICRbNDBdICE9PSByYW5nZURlY29yYXRpb25zQWN0b3IgfHwgJFs0MV0gIT09IHJlYWRPbmx5ID8gKHQ1ID0gKCkgPT4ge1xuICAgIHJhbmdlRGVjb3JhdGlvbnNBY3Rvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwidXBkYXRlIHJlYWQgb25seVwiLFxuICAgICAgcmVhZE9ubHlcbiAgICB9KTtcbiAgfSwgdDYgPSBbcmFuZ2VEZWNvcmF0aW9uc0FjdG9yLCByZWFkT25seV0sICRbNDBdID0gcmFuZ2VEZWNvcmF0aW9uc0FjdG9yLCAkWzQxXSA9IHJlYWRPbmx5LCAkWzQyXSA9IHQ1LCAkWzQzXSA9IHQ2KSA6ICh0NSA9ICRbNDJdLCB0NiA9ICRbNDNdKSwgdXNlRWZmZWN0KHQ1LCB0Nik7XG4gIGxldCB0NywgdDg7XG4gICRbNDRdICE9PSByYW5nZURlY29yYXRpb25zIHx8ICRbNDVdICE9PSByYW5nZURlY29yYXRpb25zQWN0b3IgPyAodDcgPSAoKSA9PiB7XG4gICAgcmFuZ2VEZWNvcmF0aW9uc0FjdG9yLnNlbmQoe1xuICAgICAgdHlwZTogXCJyYW5nZSBkZWNvcmF0aW9ucyB1cGRhdGVkXCIsXG4gICAgICByYW5nZURlY29yYXRpb25zOiByYW5nZURlY29yYXRpb25zID8/IFtdXG4gICAgfSk7XG4gIH0sIHQ4ID0gW3JhbmdlRGVjb3JhdGlvbnNBY3RvciwgcmFuZ2VEZWNvcmF0aW9uc10sICRbNDRdID0gcmFuZ2VEZWNvcmF0aW9ucywgJFs0NV0gPSByYW5nZURlY29yYXRpb25zQWN0b3IsICRbNDZdID0gdDcsICRbNDddID0gdDgpIDogKHQ3ID0gJFs0Nl0sIHQ4ID0gJFs0N10pLCB1c2VFZmZlY3QodDcsIHQ4KTtcbiAgYmIwOiB7XG4gICAgaWYgKHJlYWRPbmx5KVxuICAgICAgYnJlYWsgYmIwO1xuICAgIGNyZWF0ZVdpdGhIb3RrZXlzKGVkaXRvckFjdG9yLCBwb3J0YWJsZVRleHRFZGl0b3IsIGhvdGtleXMpKHNsYXRlRWRpdG9yKTtcbiAgfVxuICBsZXQgdDEwO1xuICAkWzQ4XSAhPT0gcmVhZE9ubHkgfHwgJFs0OV0gIT09IHJlbmRlckJsb2NrIHx8ICRbNTBdICE9PSByZW5kZXJDaGlsZCB8fCAkWzUxXSAhPT0gcmVuZGVyTGlzdEl0ZW0gfHwgJFs1Ml0gIT09IHJlbmRlclN0eWxlIHx8ICRbNTNdICE9PSBzcGVsbENoZWNrID8gKHQxMCA9IChlUHJvcHMpID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goUmVuZGVyRWxlbWVudCwgeyAuLi5lUHJvcHMsIHJlYWRPbmx5LCByZW5kZXJCbG9jaywgcmVuZGVyQ2hpbGQsIHJlbmRlckxpc3RJdGVtLCByZW5kZXJTdHlsZSwgc3BlbGxDaGVjayB9KSwgJFs0OF0gPSByZWFkT25seSwgJFs0OV0gPSByZW5kZXJCbG9jaywgJFs1MF0gPSByZW5kZXJDaGlsZCwgJFs1MV0gPSByZW5kZXJMaXN0SXRlbSwgJFs1Ml0gPSByZW5kZXJTdHlsZSwgJFs1M10gPSBzcGVsbENoZWNrLCAkWzU0XSA9IHQxMCkgOiB0MTAgPSAkWzU0XTtcbiAgY29uc3QgcmVuZGVyRWxlbWVudCA9IHQxMDtcbiAgbGV0IHQxMTtcbiAgJFs1NV0gIT09IHJlYWRPbmx5IHx8ICRbNTZdICE9PSByZW5kZXJBbm5vdGF0aW9uIHx8ICRbNTddICE9PSByZW5kZXJDaGlsZCB8fCAkWzU4XSAhPT0gcmVuZGVyRGVjb3JhdG9yIHx8ICRbNTldICE9PSByZW5kZXJQbGFjZWhvbGRlciA/ICh0MTEgPSAobGVhZlByb3BzKSA9PiAvKiBAX19QVVJFX18gKi8ganN4KFJlbmRlckxlYWYsIHsgLi4ubGVhZlByb3BzLCByZWFkT25seSwgcmVuZGVyQW5ub3RhdGlvbiwgcmVuZGVyQ2hpbGQsIHJlbmRlckRlY29yYXRvciwgcmVuZGVyUGxhY2Vob2xkZXIgfSksICRbNTVdID0gcmVhZE9ubHksICRbNTZdID0gcmVuZGVyQW5ub3RhdGlvbiwgJFs1N10gPSByZW5kZXJDaGlsZCwgJFs1OF0gPSByZW5kZXJEZWNvcmF0b3IsICRbNTldID0gcmVuZGVyUGxhY2Vob2xkZXIsICRbNjBdID0gdDExKSA6IHQxMSA9ICRbNjBdO1xuICBjb25zdCByZW5kZXJMZWFmID0gdDExLCByZW5kZXJUZXh0ID0gX3RlbXAzO1xuICBsZXQgdDEyO1xuICAkWzYxXSAhPT0gZWRpdG9yQWN0b3IgfHwgJFs2Ml0gIT09IHByb3BzU2VsZWN0aW9uIHx8ICRbNjNdICE9PSBzbGF0ZUVkaXRvciA/ICh0MTIgPSAoKSA9PiB7XG4gICAgaWYgKHByb3BzU2VsZWN0aW9uKSB7XG4gICAgICBkZWJ1ZyRkKGBTZWxlY3Rpb24gZnJvbSBwcm9wcyAke0pTT04uc3RyaW5naWZ5KHByb3BzU2VsZWN0aW9uKX1gKTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRTZWxlY3Rpb24gPSBub3JtYWxpemVTZWxlY3Rpb24ocHJvcHNTZWxlY3Rpb24sIGZyb21TbGF0ZVZhbHVlKHNsYXRlRWRpdG9yLmNoaWxkcmVuLCBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWUpKTtcbiAgICAgIGlmIChub3JtYWxpemVkU2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgIGRlYnVnJGQoYE5vcm1hbGl6ZWQgc2VsZWN0aW9uIGZyb20gcHJvcHMgJHtKU09OLnN0cmluZ2lmeShub3JtYWxpemVkU2VsZWN0aW9uKX1gKTtcbiAgICAgICAgY29uc3Qgc2xhdGVSYW5nZSA9IHRvU2xhdGVSYW5nZSh7XG4gICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgc2NoZW1hOiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLFxuICAgICAgICAgICAgdmFsdWU6IHNsYXRlRWRpdG9yLnZhbHVlLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiBub3JtYWxpemVkU2VsZWN0aW9uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBibG9ja0luZGV4TWFwOiBzbGF0ZUVkaXRvci5ibG9ja0luZGV4TWFwXG4gICAgICAgIH0pO1xuICAgICAgICBzbGF0ZVJhbmdlICYmIChUcmFuc2Zvcm1zLnNlbGVjdChzbGF0ZUVkaXRvciwgc2xhdGVSYW5nZSksIHNsYXRlRWRpdG9yLm9wZXJhdGlvbnMuc29tZShfdGVtcDQpIHx8IGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwidXBkYXRlIHNlbGVjdGlvblwiLFxuICAgICAgICAgIHNlbGVjdGlvbjogbm9ybWFsaXplZFNlbGVjdGlvblxuICAgICAgICB9KSwgc2xhdGVFZGl0b3Iub25DaGFuZ2UoKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCAkWzYxXSA9IGVkaXRvckFjdG9yLCAkWzYyXSA9IHByb3BzU2VsZWN0aW9uLCAkWzYzXSA9IHNsYXRlRWRpdG9yLCAkWzY0XSA9IHQxMikgOiB0MTIgPSAkWzY0XTtcbiAgY29uc3QgcmVzdG9yZVNlbGVjdGlvbkZyb21Qcm9wcyA9IHQxMjtcbiAgbGV0IHQxMywgdDE0O1xuICAkWzY1XSAhPT0gZWRpdG9yQWN0b3IgfHwgJFs2Nl0gIT09IHJhbmdlRGVjb3JhdGlvbnNBY3RvciB8fCAkWzY3XSAhPT0gcmVzdG9yZVNlbGVjdGlvbkZyb21Qcm9wcyA/ICh0MTMgPSAoKSA9PiB7XG4gICAgY29uc3Qgb25SZWFkeSA9IGVkaXRvckFjdG9yLm9uKFwicmVhZHlcIiwgKCkgPT4ge1xuICAgICAgcmFuZ2VEZWNvcmF0aW9uc0FjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcInJlYWR5XCJcbiAgICAgIH0pLCByZXN0b3JlU2VsZWN0aW9uRnJvbVByb3BzKCk7XG4gICAgfSksIG9uSW52YWxpZFZhbHVlID0gZWRpdG9yQWN0b3Iub24oXCJpbnZhbGlkIHZhbHVlXCIsICgpID0+IHtcbiAgICAgIHNldEhhc0ludmFsaWRWYWx1ZSghMCk7XG4gICAgfSksIG9uVmFsdWVDaGFuZ2VkID0gZWRpdG9yQWN0b3Iub24oXCJ2YWx1ZSBjaGFuZ2VkXCIsICgpID0+IHtcbiAgICAgIHNldEhhc0ludmFsaWRWYWx1ZSghMSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG9uUmVhZHkudW5zdWJzY3JpYmUoKSwgb25JbnZhbGlkVmFsdWUudW5zdWJzY3JpYmUoKSwgb25WYWx1ZUNoYW5nZWQudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCB0MTQgPSBbcmFuZ2VEZWNvcmF0aW9uc0FjdG9yLCBlZGl0b3JBY3RvciwgcmVzdG9yZVNlbGVjdGlvbkZyb21Qcm9wc10sICRbNjVdID0gZWRpdG9yQWN0b3IsICRbNjZdID0gcmFuZ2VEZWNvcmF0aW9uc0FjdG9yLCAkWzY3XSA9IHJlc3RvcmVTZWxlY3Rpb25Gcm9tUHJvcHMsICRbNjhdID0gdDEzLCAkWzY5XSA9IHQxNCkgOiAodDEzID0gJFs2OF0sIHQxNCA9ICRbNjldKSwgdXNlRWZmZWN0KHQxMywgdDE0KTtcbiAgbGV0IHQxNSwgdDE2O1xuICAkWzcwXSAhPT0gaGFzSW52YWxpZFZhbHVlIHx8ICRbNzFdICE9PSBwcm9wc1NlbGVjdGlvbiB8fCAkWzcyXSAhPT0gcmVzdG9yZVNlbGVjdGlvbkZyb21Qcm9wcyA/ICh0MTUgPSAoKSA9PiB7XG4gICAgcHJvcHNTZWxlY3Rpb24gJiYgIWhhc0ludmFsaWRWYWx1ZSAmJiByZXN0b3JlU2VsZWN0aW9uRnJvbVByb3BzKCk7XG4gIH0sIHQxNiA9IFtoYXNJbnZhbGlkVmFsdWUsIHByb3BzU2VsZWN0aW9uLCByZXN0b3JlU2VsZWN0aW9uRnJvbVByb3BzXSwgJFs3MF0gPSBoYXNJbnZhbGlkVmFsdWUsICRbNzFdID0gcHJvcHNTZWxlY3Rpb24sICRbNzJdID0gcmVzdG9yZVNlbGVjdGlvbkZyb21Qcm9wcywgJFs3M10gPSB0MTUsICRbNzRdID0gdDE2KSA6ICh0MTUgPSAkWzczXSwgdDE2ID0gJFs3NF0pLCB1c2VFZmZlY3QodDE1LCB0MTYpO1xuICBsZXQgdDE3O1xuICAkWzc1XSAhPT0gZWRpdG9yQWN0b3IgfHwgJFs3Nl0gIT09IG9uQ29weSB8fCAkWzc3XSAhPT0gc2xhdGVFZGl0b3IgPyAodDE3ID0gKGV2ZW50KSA9PiB7XG4gICAgaWYgKG9uQ29weSlcbiAgICAgIG9uQ29weShldmVudCkgIT09IHZvaWQgMCAmJiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGVsc2UgaWYgKGV2ZW50Lm5hdGl2ZUV2ZW50LmNsaXBib2FyZERhdGEpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpLCBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gc2xhdGVFZGl0b3Iuc2VsZWN0aW9uID8gc2xhdGVSYW5nZVRvU2VsZWN0aW9uKHtcbiAgICAgICAgc2NoZW1hOiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLFxuICAgICAgICBlZGl0b3I6IHNsYXRlRWRpdG9yLFxuICAgICAgICByYW5nZTogc2xhdGVFZGl0b3Iuc2VsZWN0aW9uXG4gICAgICB9KSA6IHZvaWQgMCwgcG9zaXRpb24gPSBzZWxlY3Rpb24gPyB7XG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfSA6IHZvaWQgMDtcbiAgICAgIGlmICghcG9zaXRpb24pIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGZpbmQgcG9zaXRpb24gZm9yIGNvcHkgZXZlbnRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImNsaXBib2FyZC5jb3B5XCIsXG4gICAgICAgICAgb3JpZ2luRXZlbnQ6IHtcbiAgICAgICAgICAgIGRhdGFUcmFuc2ZlcjogZXZlbnQubmF0aXZlRXZlbnQuY2xpcGJvYXJkRGF0YVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcG9zaXRpb25cbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yOiBzbGF0ZUVkaXRvcixcbiAgICAgICAgbmF0aXZlRXZlbnQ6IGV2ZW50XG4gICAgICB9KTtcbiAgICB9XG4gIH0sICRbNzVdID0gZWRpdG9yQWN0b3IsICRbNzZdID0gb25Db3B5LCAkWzc3XSA9IHNsYXRlRWRpdG9yLCAkWzc4XSA9IHQxNykgOiB0MTcgPSAkWzc4XTtcbiAgY29uc3QgaGFuZGxlQ29weSA9IHQxNztcbiAgbGV0IHQxODtcbiAgJFs3OV0gIT09IGVkaXRvckFjdG9yIHx8ICRbODBdICE9PSBvbkN1dCB8fCAkWzgxXSAhPT0gc2xhdGVFZGl0b3IgPyAodDE4ID0gKGV2ZW50XzApID0+IHtcbiAgICBpZiAob25DdXQpXG4gICAgICBvbkN1dChldmVudF8wKSAhPT0gdm9pZCAwICYmIGV2ZW50XzAucHJldmVudERlZmF1bHQoKTtcbiAgICBlbHNlIGlmIChldmVudF8wLm5hdGl2ZUV2ZW50LmNsaXBib2FyZERhdGEpIHtcbiAgICAgIGV2ZW50XzAuc3RvcFByb3BhZ2F0aW9uKCksIGV2ZW50XzAucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbl8wID0gZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNlbGVjdGlvbiwgcG9zaXRpb25fMCA9IHNlbGVjdGlvbl8wID8ge1xuICAgICAgICBzZWxlY3Rpb246IHNlbGVjdGlvbl8wXG4gICAgICB9IDogdm9pZCAwO1xuICAgICAgaWYgKCFwb3NpdGlvbl8wKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBmaW5kIHBvc2l0aW9uIGZvciBjdXQgZXZlbnRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImNsaXBib2FyZC5jdXRcIixcbiAgICAgICAgICBvcmlnaW5FdmVudDoge1xuICAgICAgICAgICAgZGF0YVRyYW5zZmVyOiBldmVudF8wLm5hdGl2ZUV2ZW50LmNsaXBib2FyZERhdGFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbl8wXG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvcjogc2xhdGVFZGl0b3IsXG4gICAgICAgIG5hdGl2ZUV2ZW50OiBldmVudF8wXG4gICAgICB9KTtcbiAgICB9XG4gIH0sICRbNzldID0gZWRpdG9yQWN0b3IsICRbODBdID0gb25DdXQsICRbODFdID0gc2xhdGVFZGl0b3IsICRbODJdID0gdDE4KSA6IHQxOCA9ICRbODJdO1xuICBjb25zdCBoYW5kbGVDdXQgPSB0MTg7XG4gIGxldCB0MTk7XG4gICRbODNdICE9PSBlZGl0b3JBY3RvciB8fCAkWzg0XSAhPT0gb25QYXN0ZSB8fCAkWzg1XSAhPT0gcG9ydGFibGVUZXh0RWRpdG9yIHx8ICRbODZdICE9PSByZWxheUFjdG9yIHx8ICRbODddICE9PSBzbGF0ZUVkaXRvciA/ICh0MTkgPSAoZXZlbnRfMSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gZnJvbVNsYXRlVmFsdWUoc2xhdGVFZGl0b3IuY2hpbGRyZW4sIGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEuYmxvY2submFtZSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuZ2V0KHNsYXRlRWRpdG9yKSksIHBhdGggPSAoc2xhdGVFZGl0b3Iuc2VsZWN0aW9uID8gc2xhdGVSYW5nZVRvU2VsZWN0aW9uKHtcbiAgICAgIHNjaGVtYTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYSxcbiAgICAgIGVkaXRvcjogc2xhdGVFZGl0b3IsXG4gICAgICByYW5nZTogc2xhdGVFZGl0b3Iuc2VsZWN0aW9uXG4gICAgfSkgOiBudWxsKT8uZm9jdXMucGF0aCB8fCBbXSwgb25QYXN0ZVJlc3VsdCA9IG9uUGFzdGU/Lih7XG4gICAgICBldmVudDogZXZlbnRfMSxcbiAgICAgIHZhbHVlLFxuICAgICAgcGF0aCxcbiAgICAgIHNjaGVtYVR5cGVzOiBwb3J0YWJsZVRleHRFZGl0b3Iuc2NoZW1hVHlwZXNcbiAgICB9KTtcbiAgICBpZiAob25QYXN0ZVJlc3VsdCB8fCAhc2xhdGVFZGl0b3Iuc2VsZWN0aW9uKVxuICAgICAgZXZlbnRfMS5wcmV2ZW50RGVmYXVsdCgpLCByZWxheUFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImxvYWRpbmdcIlxuICAgICAgfSksIFByb21pc2UucmVzb2x2ZShvblBhc3RlUmVzdWx0KS50aGVuKChyZXN1bHRfMSkgPT4ge1xuICAgICAgICBpZiAoZGVidWckZChcIkN1c3RvbSBwYXN0ZSBmdW5jdGlvbiBmcm9tIGNsaWVudCByZXNvbHZlZFwiLCByZXN1bHRfMSksICFyZXN1bHRfMSB8fCAhcmVzdWx0XzEuaW5zZXJ0KSB7XG4gICAgICAgICAgZGVidWckZChcIk5vIHJlc3VsdCBmcm9tIGN1c3RvbSBwYXN0ZSBoYW5kbGVyLCBwYXN0aW5nIG5vcm1hbGx5XCIpO1xuICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbl8xID0gZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNlbGVjdGlvbiwgcG9zaXRpb25fMSA9IHNlbGVjdGlvbl8xID8ge1xuICAgICAgICAgICAgc2VsZWN0aW9uOiBzZWxlY3Rpb25fMVxuICAgICAgICAgIH0gOiB2b2lkIDA7XG4gICAgICAgICAgaWYgKCFwb3NpdGlvbl8xKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgZmluZCBwb3NpdGlvbiBmb3IgcGFzdGUgZXZlbnRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgICAgICB0eXBlOiBcImNsaXBib2FyZC5wYXN0ZVwiLFxuICAgICAgICAgICAgICBvcmlnaW5FdmVudDoge1xuICAgICAgICAgICAgICAgIGRhdGFUcmFuc2ZlcjogZXZlbnRfMS5jbGlwYm9hcmREYXRhXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbl8xXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZWRpdG9yOiBzbGF0ZUVkaXRvcixcbiAgICAgICAgICAgIG5hdGl2ZUV2ZW50OiBldmVudF8xXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHJlc3VsdF8xLmluc2VydCA/IGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgICAgICB0eXBlOiBcImluc2VydC5ibG9ja3NcIixcbiAgICAgICAgICAgICAgYmxvY2tzOiBwYXJzZUJsb2Nrcyh7XG4gICAgICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgICAga2V5R2VuZXJhdG9yOiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgc2NoZW1hOiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBibG9ja3M6IHJlc3VsdF8xLmluc2VydCxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICByZW1vdmVVbnVzZWRNYXJrRGVmczogITAsXG4gICAgICAgICAgICAgICAgICB2YWxpZGF0ZUZpZWxkczogITFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBwbGFjZW1lbnQ6IFwiYXV0b1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZWRpdG9yOiBzbGF0ZUVkaXRvclxuICAgICAgICAgIH0pIDogY29uc29sZS53YXJuKFwiWW91ciBvblBhc3RlIGZ1bmN0aW9uIHJldHVybmVkIHNvbWV0aGluZyB1bmV4cGVjdGVkOlwiLCByZXN1bHRfMSk7XG4gICAgICB9KS5jYXRjaChfdGVtcDUpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICByZWxheUFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwiZG9uZSBsb2FkaW5nXCJcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICBlbHNlIGlmIChldmVudF8xLm5hdGl2ZUV2ZW50LmNsaXBib2FyZERhdGEpIHtcbiAgICAgIGV2ZW50XzEucHJldmVudERlZmF1bHQoKSwgZXZlbnRfMS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbl8yID0gZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNlbGVjdGlvbiwgcG9zaXRpb25fMiA9IHNlbGVjdGlvbl8yID8ge1xuICAgICAgICBzZWxlY3Rpb246IHNlbGVjdGlvbl8yXG4gICAgICB9IDogdm9pZCAwO1xuICAgICAgaWYgKCFwb3NpdGlvbl8yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBmaW5kIHBvc2l0aW9uIGZvciBwYXN0ZSBldmVudFwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwiY2xpcGJvYXJkLnBhc3RlXCIsXG4gICAgICAgICAgb3JpZ2luRXZlbnQ6IHtcbiAgICAgICAgICAgIGRhdGFUcmFuc2ZlcjogZXZlbnRfMS5uYXRpdmVFdmVudC5jbGlwYm9hcmREYXRhXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25fMlxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3I6IHNsYXRlRWRpdG9yLFxuICAgICAgICBuYXRpdmVFdmVudDogZXZlbnRfMVxuICAgICAgfSk7XG4gICAgfVxuICAgIGRlYnVnJGQoXCJObyByZXN1bHQgZnJvbSBjdXN0b20gcGFzdGUgaGFuZGxlciwgcGFzdGluZyBub3JtYWxseVwiKTtcbiAgfSwgJFs4M10gPSBlZGl0b3JBY3RvciwgJFs4NF0gPSBvblBhc3RlLCAkWzg1XSA9IHBvcnRhYmxlVGV4dEVkaXRvciwgJFs4Nl0gPSByZWxheUFjdG9yLCAkWzg3XSA9IHNsYXRlRWRpdG9yLCAkWzg4XSA9IHQxOSkgOiB0MTkgPSAkWzg4XTtcbiAgY29uc3QgaGFuZGxlUGFzdGUgPSB0MTk7XG4gIGxldCB0MjA7XG4gICRbODldICE9PSBlZGl0b3JBY3RvciB8fCAkWzkwXSAhPT0gb25Gb2N1cyB8fCAkWzkxXSAhPT0gcmVsYXlBY3RvciB8fCAkWzkyXSAhPT0gc2xhdGVFZGl0b3IgPyAodDIwID0gKGV2ZW50XzIpID0+IHtcbiAgICBvbkZvY3VzICYmIG9uRm9jdXMoZXZlbnRfMiksIGV2ZW50XzIuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgKHJlbGF5QWN0b3Iuc2VuZCh7XG4gICAgICB0eXBlOiBcImZvY3VzZWRcIixcbiAgICAgIGV2ZW50OiBldmVudF8yXG4gICAgfSksICFzbGF0ZUVkaXRvci5zZWxlY3Rpb24gJiYgaXNFcXVhbFRvRW1wdHlFZGl0b3Ioc2xhdGVFZGl0b3IuY2hpbGRyZW4sIGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEpICYmIChUcmFuc2Zvcm1zLnNlbGVjdChzbGF0ZUVkaXRvciwgRWRpdG9yLnN0YXJ0KHNsYXRlRWRpdG9yLCBbXSkpLCBzbGF0ZUVkaXRvci5vbkNoYW5nZSgpKSk7XG4gIH0sICRbODldID0gZWRpdG9yQWN0b3IsICRbOTBdID0gb25Gb2N1cywgJFs5MV0gPSByZWxheUFjdG9yLCAkWzkyXSA9IHNsYXRlRWRpdG9yLCAkWzkzXSA9IHQyMCkgOiB0MjAgPSAkWzkzXTtcbiAgY29uc3QgaGFuZGxlT25Gb2N1cyA9IHQyMDtcbiAgbGV0IHQyMTtcbiAgJFs5NF0gIT09IGVkaXRvckFjdG9yIHx8ICRbOTVdICE9PSBvbkNsaWNrIHx8ICRbOTZdICE9PSBzbGF0ZUVkaXRvciA/ICh0MjEgPSAoZXZlbnRfMykgPT4ge1xuICAgIGlmIChvbkNsaWNrICYmIG9uQ2xpY2soZXZlbnRfMyksIGV2ZW50XzMuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgZXZlbnRfMy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHBvc2l0aW9uXzMgPSBnZXRFdmVudFBvc2l0aW9uKHtcbiAgICAgIGVkaXRvckFjdG9yLFxuICAgICAgc2xhdGVFZGl0b3IsXG4gICAgICBldmVudDogZXZlbnRfMy5uYXRpdmVFdmVudFxuICAgIH0pO1xuICAgIHBvc2l0aW9uXzMgJiYgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgIHR5cGU6IFwibW91c2UuY2xpY2tcIixcbiAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXzNcbiAgICAgIH0sXG4gICAgICBlZGl0b3I6IHNsYXRlRWRpdG9yLFxuICAgICAgbmF0aXZlRXZlbnQ6IGV2ZW50XzNcbiAgICB9KTtcbiAgfSwgJFs5NF0gPSBlZGl0b3JBY3RvciwgJFs5NV0gPSBvbkNsaWNrLCAkWzk2XSA9IHNsYXRlRWRpdG9yLCAkWzk3XSA9IHQyMSkgOiB0MjEgPSAkWzk3XTtcbiAgY29uc3QgaGFuZGxlQ2xpY2sgPSB0MjE7XG4gIGxldCB0MjI7XG4gICRbOThdICE9PSBvbkJsdXIgfHwgJFs5OV0gIT09IHJlbGF5QWN0b3IgPyAodDIyID0gKGV2ZW50XzQpID0+IHtcbiAgICBvbkJsdXIgJiYgb25CbHVyKGV2ZW50XzQpLCBldmVudF80LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgfHwgcmVsYXlBY3Rvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwiYmx1cnJlZFwiLFxuICAgICAgZXZlbnQ6IGV2ZW50XzRcbiAgICB9KTtcbiAgfSwgJFs5OF0gPSBvbkJsdXIsICRbOTldID0gcmVsYXlBY3RvciwgJFsxMDBdID0gdDIyKSA6IHQyMiA9ICRbMTAwXTtcbiAgY29uc3QgaGFuZGxlT25CbHVyID0gdDIyO1xuICBsZXQgdDIzO1xuICAkWzEwMV0gIT09IG9uQmVmb3JlSW5wdXQgPyAodDIzID0gKGV2ZW50XzUpID0+IHtcbiAgICBvbkJlZm9yZUlucHV0ICYmIG9uQmVmb3JlSW5wdXQoZXZlbnRfNSk7XG4gIH0sICRbMTAxXSA9IG9uQmVmb3JlSW5wdXQsICRbMTAyXSA9IHQyMykgOiB0MjMgPSAkWzEwMl07XG4gIGNvbnN0IGhhbmRsZU9uQmVmb3JlSW5wdXQgPSB0MjM7XG4gIGxldCB0MjQ7XG4gICRbMTAzXSAhPT0gZWRpdG9yQWN0b3IgfHwgJFsxMDRdICE9PSBwcm9wcyB8fCAkWzEwNV0gIT09IHNsYXRlRWRpdG9yID8gKHQyNCA9IChldmVudF82KSA9PiB7XG4gICAgcHJvcHMub25LZXlEb3duICYmIHByb3BzLm9uS2V5RG93bihldmVudF82KSwgZXZlbnRfNi5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBzbGF0ZUVkaXRvci5wdGVXaXRoSG90S2V5cyhldmVudF82KSwgZXZlbnRfNi5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgdHlwZTogXCJrZXlib2FyZC5rZXlkb3duXCIsXG4gICAgICAgIG9yaWdpbkV2ZW50OiB7XG4gICAgICAgICAga2V5OiBldmVudF82LmtleSxcbiAgICAgICAgICBjb2RlOiBldmVudF82LmNvZGUsXG4gICAgICAgICAgYWx0S2V5OiBldmVudF82LmFsdEtleSxcbiAgICAgICAgICBjdHJsS2V5OiBldmVudF82LmN0cmxLZXksXG4gICAgICAgICAgbWV0YUtleTogZXZlbnRfNi5tZXRhS2V5LFxuICAgICAgICAgIHNoaWZ0S2V5OiBldmVudF82LnNoaWZ0S2V5XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlZGl0b3I6IHNsYXRlRWRpdG9yLFxuICAgICAgbmF0aXZlRXZlbnQ6IGV2ZW50XzZcbiAgICB9KTtcbiAgfSwgJFsxMDNdID0gZWRpdG9yQWN0b3IsICRbMTA0XSA9IHByb3BzLCAkWzEwNV0gPSBzbGF0ZUVkaXRvciwgJFsxMDZdID0gdDI0KSA6IHQyNCA9ICRbMTA2XTtcbiAgY29uc3QgaGFuZGxlS2V5RG93biA9IHQyNDtcbiAgbGV0IHQyNTtcbiAgJFsxMDddICE9PSBlZGl0b3JBY3RvciB8fCAkWzEwOF0gIT09IHByb3BzIHx8ICRbMTA5XSAhPT0gc2xhdGVFZGl0b3IgPyAodDI1ID0gKGV2ZW50XzcpID0+IHtcbiAgICBwcm9wcy5vbktleVVwICYmIHByb3BzLm9uS2V5VXAoZXZlbnRfNyksIGV2ZW50XzcuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgIHR5cGU6IFwia2V5Ym9hcmQua2V5dXBcIixcbiAgICAgICAgb3JpZ2luRXZlbnQ6IHtcbiAgICAgICAgICBrZXk6IGV2ZW50Xzcua2V5LFxuICAgICAgICAgIGNvZGU6IGV2ZW50XzcuY29kZSxcbiAgICAgICAgICBhbHRLZXk6IGV2ZW50XzcuYWx0S2V5LFxuICAgICAgICAgIGN0cmxLZXk6IGV2ZW50XzcuY3RybEtleSxcbiAgICAgICAgICBtZXRhS2V5OiBldmVudF83Lm1ldGFLZXksXG4gICAgICAgICAgc2hpZnRLZXk6IGV2ZW50Xzcuc2hpZnRLZXlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGVkaXRvcjogc2xhdGVFZGl0b3IsXG4gICAgICBuYXRpdmVFdmVudDogZXZlbnRfN1xuICAgIH0pO1xuICB9LCAkWzEwN10gPSBlZGl0b3JBY3RvciwgJFsxMDhdID0gcHJvcHMsICRbMTA5XSA9IHNsYXRlRWRpdG9yLCAkWzExMF0gPSB0MjUpIDogdDI1ID0gJFsxMTBdO1xuICBjb25zdCBoYW5kbGVLZXlVcCA9IHQyNTtcbiAgbGV0IHQyNjtcbiAgYmIxOiB7XG4gICAgaWYgKHNjcm9sbFNlbGVjdGlvbkludG9WaWV3ID09PSB2b2lkIDApIHtcbiAgICAgIHQyNiA9IHZvaWQgMDtcbiAgICAgIGJyZWFrIGJiMTtcbiAgICB9XG4gICAgaWYgKHNjcm9sbFNlbGVjdGlvbkludG9WaWV3ID09PSBudWxsKSB7XG4gICAgICB0MjYgPSBub29wO1xuICAgICAgYnJlYWsgYmIxO1xuICAgIH1cbiAgICBsZXQgdDI3MjtcbiAgICAkWzExMV0gIT09IHBvcnRhYmxlVGV4dEVkaXRvciB8fCAkWzExMl0gIT09IHNjcm9sbFNlbGVjdGlvbkludG9WaWV3ID8gKHQyNzIgPSAoX2VkaXRvciwgZG9tUmFuZ2UpID0+IHtcbiAgICAgIHNjcm9sbFNlbGVjdGlvbkludG9WaWV3KHBvcnRhYmxlVGV4dEVkaXRvciwgZG9tUmFuZ2UpO1xuICAgIH0sICRbMTExXSA9IHBvcnRhYmxlVGV4dEVkaXRvciwgJFsxMTJdID0gc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcsICRbMTEzXSA9IHQyNzIpIDogdDI3MiA9ICRbMTEzXSwgdDI2ID0gdDI3MjtcbiAgfVxuICBjb25zdCBzY3JvbGxTZWxlY3Rpb25JbnRvVmlld1RvU2xhdGUgPSB0MjY7XG4gIGxldCB0MjcsIHQyODtcbiAgJFsxMTRdICE9PSBlZGl0b3JBY3RvciB8fCAkWzExNV0gIT09IHNsYXRlRWRpdG9yID8gKHQyNyA9ICgpID0+IHtcbiAgICBjb25zdCB3aW5kb3cyID0gUmVhY3RFZGl0b3IuZ2V0V2luZG93KHNsYXRlRWRpdG9yKSwgb25EcmFnRW5kXzAgPSAoKSA9PiB7XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJkcmFnZW5kXCJcbiAgICAgIH0pO1xuICAgIH0sIG9uRHJvcF8wID0gKCkgPT4ge1xuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiZHJvcFwiXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiB3aW5kb3cyLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnZW5kXCIsIG9uRHJhZ0VuZF8wKSwgd2luZG93Mi5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLCBvbkRyb3BfMCksICgpID0+IHtcbiAgICAgIHdpbmRvdzIuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRyYWdlbmRcIiwgb25EcmFnRW5kXzApLCB3aW5kb3cyLmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsIG9uRHJvcF8wKTtcbiAgICB9O1xuICB9LCB0MjggPSBbc2xhdGVFZGl0b3IsIGVkaXRvckFjdG9yXSwgJFsxMTRdID0gZWRpdG9yQWN0b3IsICRbMTE1XSA9IHNsYXRlRWRpdG9yLCAkWzExNl0gPSB0MjcsICRbMTE3XSA9IHQyOCkgOiAodDI3ID0gJFsxMTZdLCB0MjggPSAkWzExN10pLCB1c2VFZmZlY3QodDI3LCB0MjgpO1xuICBsZXQgdDI5O1xuICAkWzExOF0gIT09IGVkaXRvckFjdG9yIHx8ICRbMTE5XSAhPT0gb25EcmFnU3RhcnQgfHwgJFsxMjBdICE9PSBzbGF0ZUVkaXRvciA/ICh0MjkgPSAoZXZlbnRfOCkgPT4ge1xuICAgIGlmIChvbkRyYWdTdGFydD8uKGV2ZW50XzgpLCBldmVudF84LmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8IGV2ZW50XzguaXNQcm9wYWdhdGlvblN0b3BwZWQoKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBwb3NpdGlvbl80ID0gZ2V0RXZlbnRQb3NpdGlvbih7XG4gICAgICBlZGl0b3JBY3RvcixcbiAgICAgIHNsYXRlRWRpdG9yLFxuICAgICAgZXZlbnQ6IGV2ZW50XzgubmF0aXZlRXZlbnRcbiAgICB9KTtcbiAgICBpZiAoIXBvc2l0aW9uXzQpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBmaW5kIHBvc2l0aW9uIGZvciBkcmFnc3RhcnQgZXZlbnRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwiZHJhZ3N0YXJ0XCIsXG4gICAgICBvcmlnaW46IHBvc2l0aW9uXzRcbiAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgIHR5cGU6IFwiZHJhZy5kcmFnc3RhcnRcIixcbiAgICAgICAgb3JpZ2luRXZlbnQ6IHtcbiAgICAgICAgICBjbGllbnRYOiBldmVudF84LmNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WTogZXZlbnRfOC5jbGllbnRZLFxuICAgICAgICAgIGRhdGFUcmFuc2ZlcjogZXZlbnRfOC5kYXRhVHJhbnNmZXJcbiAgICAgICAgfSxcbiAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXzRcbiAgICAgIH0sXG4gICAgICBlZGl0b3I6IHNsYXRlRWRpdG9yXG4gICAgfSksICEwO1xuICB9LCAkWzExOF0gPSBlZGl0b3JBY3RvciwgJFsxMTldID0gb25EcmFnU3RhcnQsICRbMTIwXSA9IHNsYXRlRWRpdG9yLCAkWzEyMV0gPSB0MjkpIDogdDI5ID0gJFsxMjFdO1xuICBjb25zdCBoYW5kbGVEcmFnU3RhcnQgPSB0Mjk7XG4gIGxldCB0MzA7XG4gICRbMTIyXSAhPT0gZWRpdG9yQWN0b3IgfHwgJFsxMjNdICE9PSBvbkRyYWcgfHwgJFsxMjRdICE9PSBzbGF0ZUVkaXRvciA/ICh0MzAgPSAoZXZlbnRfOSkgPT4ge1xuICAgIGlmIChvbkRyYWc/LihldmVudF85KSwgIShldmVudF85LmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8IGV2ZW50XzkuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSB8fCAhZ2V0RXZlbnRQb3NpdGlvbih7XG4gICAgICBlZGl0b3JBY3RvcixcbiAgICAgIHNsYXRlRWRpdG9yLFxuICAgICAgZXZlbnQ6IGV2ZW50XzkubmF0aXZlRXZlbnRcbiAgICB9KSkpXG4gICAgICByZXR1cm4gZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwiZHJhZy5kcmFnXCIsXG4gICAgICAgICAgb3JpZ2luRXZlbnQ6IHtcbiAgICAgICAgICAgIGRhdGFUcmFuc2ZlcjogZXZlbnRfOS5kYXRhVHJhbnNmZXJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvcjogc2xhdGVFZGl0b3JcbiAgICAgIH0pLCAhMDtcbiAgfSwgJFsxMjJdID0gZWRpdG9yQWN0b3IsICRbMTIzXSA9IG9uRHJhZywgJFsxMjRdID0gc2xhdGVFZGl0b3IsICRbMTI1XSA9IHQzMCkgOiB0MzAgPSAkWzEyNV07XG4gIGNvbnN0IGhhbmRsZURyYWcgPSB0MzA7XG4gIGxldCB0MzE7XG4gICRbMTI2XSAhPT0gZWRpdG9yQWN0b3IgfHwgJFsxMjddICE9PSBvbkRyYWdFbmQgfHwgJFsxMjhdICE9PSBzbGF0ZUVkaXRvciA/ICh0MzEgPSAoZXZlbnRfMTApID0+IHtcbiAgICBpZiAob25EcmFnRW5kPy4oZXZlbnRfMTApLCAhKGV2ZW50XzEwLmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8IGV2ZW50XzEwLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpKVxuICAgICAgcmV0dXJuIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImRyYWcuZHJhZ2VuZFwiLFxuICAgICAgICAgIG9yaWdpbkV2ZW50OiB7XG4gICAgICAgICAgICBkYXRhVHJhbnNmZXI6IGV2ZW50XzEwLmRhdGFUcmFuc2ZlclxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yOiBzbGF0ZUVkaXRvclxuICAgICAgfSksICEwO1xuICB9LCAkWzEyNl0gPSBlZGl0b3JBY3RvciwgJFsxMjddID0gb25EcmFnRW5kLCAkWzEyOF0gPSBzbGF0ZUVkaXRvciwgJFsxMjldID0gdDMxKSA6IHQzMSA9ICRbMTI5XTtcbiAgY29uc3QgaGFuZGxlRHJhZ0VuZCA9IHQzMTtcbiAgbGV0IHQzMjtcbiAgJFsxMzBdICE9PSBlZGl0b3JBY3RvciB8fCAkWzEzMV0gIT09IG9uRHJhZ0VudGVyIHx8ICRbMTMyXSAhPT0gc2xhdGVFZGl0b3IgPyAodDMyID0gKGV2ZW50XzExKSA9PiB7XG4gICAgaWYgKG9uRHJhZ0VudGVyPy4oZXZlbnRfMTEpLCBldmVudF8xMS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBldmVudF8xMS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHBvc2l0aW9uXzYgPSBnZXRFdmVudFBvc2l0aW9uKHtcbiAgICAgIGVkaXRvckFjdG9yLFxuICAgICAgc2xhdGVFZGl0b3IsXG4gICAgICBldmVudDogZXZlbnRfMTEubmF0aXZlRXZlbnRcbiAgICB9KTtcbiAgICBpZiAocG9zaXRpb25fNilcbiAgICAgIHJldHVybiBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJkcmFnLmRyYWdlbnRlclwiLFxuICAgICAgICAgIG9yaWdpbkV2ZW50OiB7XG4gICAgICAgICAgICBkYXRhVHJhbnNmZXI6IGV2ZW50XzExLmRhdGFUcmFuc2ZlclxuICAgICAgICAgIH0sXG4gICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXzZcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yOiBzbGF0ZUVkaXRvclxuICAgICAgfSksICEwO1xuICB9LCAkWzEzMF0gPSBlZGl0b3JBY3RvciwgJFsxMzFdID0gb25EcmFnRW50ZXIsICRbMTMyXSA9IHNsYXRlRWRpdG9yLCAkWzEzM10gPSB0MzIpIDogdDMyID0gJFsxMzNdO1xuICBjb25zdCBoYW5kbGVEcmFnRW50ZXIgPSB0MzI7XG4gIGxldCB0MzM7XG4gICRbMTM0XSAhPT0gZWRpdG9yQWN0b3IgfHwgJFsxMzVdICE9PSBvbkRyYWdPdmVyIHx8ICRbMTM2XSAhPT0gc2xhdGVFZGl0b3IgPyAodDMzID0gKGV2ZW50XzEyKSA9PiB7XG4gICAgaWYgKG9uRHJhZ092ZXI/LihldmVudF8xMiksIGV2ZW50XzEyLmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8IGV2ZW50XzEyLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcG9zaXRpb25fNyA9IGdldEV2ZW50UG9zaXRpb24oe1xuICAgICAgZWRpdG9yQWN0b3IsXG4gICAgICBzbGF0ZUVkaXRvcixcbiAgICAgIGV2ZW50OiBldmVudF8xMi5uYXRpdmVFdmVudFxuICAgIH0pO1xuICAgIGlmIChwb3NpdGlvbl83KVxuICAgICAgcmV0dXJuIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImRyYWcuZHJhZ292ZXJcIixcbiAgICAgICAgICBvcmlnaW5FdmVudDoge1xuICAgICAgICAgICAgZGF0YVRyYW5zZmVyOiBldmVudF8xMi5kYXRhVHJhbnNmZXJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRyYWdPcmlnaW46IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5pbnRlcm5hbERyYWc/Lm9yaWdpbixcbiAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25fN1xuICAgICAgICB9LFxuICAgICAgICBlZGl0b3I6IHNsYXRlRWRpdG9yLFxuICAgICAgICBuYXRpdmVFdmVudDogZXZlbnRfMTJcbiAgICAgIH0pLCAhMDtcbiAgfSwgJFsxMzRdID0gZWRpdG9yQWN0b3IsICRbMTM1XSA9IG9uRHJhZ092ZXIsICRbMTM2XSA9IHNsYXRlRWRpdG9yLCAkWzEzN10gPSB0MzMpIDogdDMzID0gJFsxMzddO1xuICBjb25zdCBoYW5kbGVEcmFnT3ZlciA9IHQzMztcbiAgbGV0IHQzNDtcbiAgJFsxMzhdICE9PSBlZGl0b3JBY3RvciB8fCAkWzEzOV0gIT09IG9uRHJvcCB8fCAkWzE0MF0gIT09IHNsYXRlRWRpdG9yID8gKHQzNCA9IChldmVudF8xMykgPT4ge1xuICAgIGlmIChvbkRyb3A/LihldmVudF8xMyksIGV2ZW50XzEzLmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8IGV2ZW50XzEzLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcG9zaXRpb25fOCA9IGdldEV2ZW50UG9zaXRpb24oe1xuICAgICAgZWRpdG9yQWN0b3IsXG4gICAgICBzbGF0ZUVkaXRvcixcbiAgICAgIGV2ZW50OiBldmVudF8xMy5uYXRpdmVFdmVudFxuICAgIH0pO1xuICAgIGlmICghcG9zaXRpb25fOCkge1xuICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGZpbmQgcG9zaXRpb24gZm9yIGRyb3AgZXZlbnRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgdHlwZTogXCJkcmFnLmRyb3BcIixcbiAgICAgICAgb3JpZ2luRXZlbnQ6IHtcbiAgICAgICAgICBkYXRhVHJhbnNmZXI6IGV2ZW50XzEzLmRhdGFUcmFuc2ZlclxuICAgICAgICB9LFxuICAgICAgICBkcmFnT3JpZ2luOiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuaW50ZXJuYWxEcmFnPy5vcmlnaW4sXG4gICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbl84XG4gICAgICB9LFxuICAgICAgZWRpdG9yOiBzbGF0ZUVkaXRvcixcbiAgICAgIG5hdGl2ZUV2ZW50OiBldmVudF8xM1xuICAgIH0pLCAhMDtcbiAgfSwgJFsxMzhdID0gZWRpdG9yQWN0b3IsICRbMTM5XSA9IG9uRHJvcCwgJFsxNDBdID0gc2xhdGVFZGl0b3IsICRbMTQxXSA9IHQzNCkgOiB0MzQgPSAkWzE0MV07XG4gIGNvbnN0IGhhbmRsZURyb3AgPSB0MzQ7XG4gIGxldCB0MzU7XG4gICRbMTQyXSAhPT0gZWRpdG9yQWN0b3IgfHwgJFsxNDNdICE9PSBvbkRyYWdMZWF2ZSB8fCAkWzE0NF0gIT09IHNsYXRlRWRpdG9yID8gKHQzNSA9IChldmVudF8xNCkgPT4ge1xuICAgIGlmIChvbkRyYWdMZWF2ZT8uKGV2ZW50XzE0KSwgIShldmVudF8xNC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBldmVudF8xNC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpIHx8ICFnZXRFdmVudFBvc2l0aW9uKHtcbiAgICAgIGVkaXRvckFjdG9yLFxuICAgICAgc2xhdGVFZGl0b3IsXG4gICAgICBldmVudDogZXZlbnRfMTQubmF0aXZlRXZlbnRcbiAgICB9KSkpXG4gICAgICByZXR1cm4gZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwiZHJhZy5kcmFnbGVhdmVcIixcbiAgICAgICAgICBvcmlnaW5FdmVudDoge1xuICAgICAgICAgICAgZGF0YVRyYW5zZmVyOiBldmVudF8xNC5kYXRhVHJhbnNmZXJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvcjogc2xhdGVFZGl0b3JcbiAgICAgIH0pLCAhMDtcbiAgfSwgJFsxNDJdID0gZWRpdG9yQWN0b3IsICRbMTQzXSA9IG9uRHJhZ0xlYXZlLCAkWzE0NF0gPSBzbGF0ZUVkaXRvciwgJFsxNDVdID0gdDM1KSA6IHQzNSA9ICRbMTQ1XTtcbiAgY29uc3QgaGFuZGxlRHJhZ0xlYXZlID0gdDM1O1xuICBsZXQgdDM2O1xuICAkWzE0Nl0gIT09IGZvcndhcmRlZFJlZiB8fCAkWzE0N10gIT09IHZhbGlkYXRlU2VsZWN0aW9uQWN0b3IgPyAodDM2ID0gKGVkaXRvckVsZW1lbnQpID0+IHtcbiAgICBpZiAodHlwZW9mIGZvcndhcmRlZFJlZiA9PSBcImZ1bmN0aW9uXCIgPyBmb3J3YXJkZWRSZWYoZWRpdG9yRWxlbWVudCkgOiBmb3J3YXJkZWRSZWYgJiYgKGZvcndhcmRlZFJlZi5jdXJyZW50ID0gZWRpdG9yRWxlbWVudCksIGVkaXRvckVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IG11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XG4gICAgICAgIHZhbGlkYXRlU2VsZWN0aW9uQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJ2YWxpZGF0ZSBzZWxlY3Rpb25cIixcbiAgICAgICAgICBlZGl0b3JFbGVtZW50XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKGVkaXRvckVsZW1lbnQsIHtcbiAgICAgICAgYXR0cmlidXRlT2xkVmFsdWU6ICExLFxuICAgICAgICBhdHRyaWJ1dGVzOiAhMSxcbiAgICAgICAgY2hhcmFjdGVyRGF0YTogITEsXG4gICAgICAgIGNoaWxkTGlzdDogITAsXG4gICAgICAgIHN1YnRyZWU6ICEwXG4gICAgICB9KSwgKCkgPT4ge1xuICAgICAgICBtdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCAkWzE0Nl0gPSBmb3J3YXJkZWRSZWYsICRbMTQ3XSA9IHZhbGlkYXRlU2VsZWN0aW9uQWN0b3IsICRbMTQ4XSA9IHQzNikgOiB0MzYgPSAkWzE0OF07XG4gIGNvbnN0IGNhbGxiYWNrUmVmID0gdDM2O1xuICBpZiAoIXBvcnRhYmxlVGV4dEVkaXRvcilcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IHQzNztcbiAgcmV0dXJuICRbMTQ5XSAhPT0gY2FsbGJhY2tSZWYgfHwgJFsxNTBdICE9PSBkZWNvcmF0ZSB8fCAkWzE1MV0gIT09IGhhbmRsZUNsaWNrIHx8ICRbMTUyXSAhPT0gaGFuZGxlQ29weSB8fCAkWzE1M10gIT09IGhhbmRsZUN1dCB8fCAkWzE1NF0gIT09IGhhbmRsZURyYWcgfHwgJFsxNTVdICE9PSBoYW5kbGVEcmFnRW5kIHx8ICRbMTU2XSAhPT0gaGFuZGxlRHJhZ0VudGVyIHx8ICRbMTU3XSAhPT0gaGFuZGxlRHJhZ0xlYXZlIHx8ICRbMTU4XSAhPT0gaGFuZGxlRHJhZ092ZXIgfHwgJFsxNTldICE9PSBoYW5kbGVEcmFnU3RhcnQgfHwgJFsxNjBdICE9PSBoYW5kbGVEcm9wIHx8ICRbMTYxXSAhPT0gaGFuZGxlS2V5RG93biB8fCAkWzE2Ml0gIT09IGhhbmRsZUtleVVwIHx8ICRbMTYzXSAhPT0gaGFuZGxlT25CZWZvcmVJbnB1dCB8fCAkWzE2NF0gIT09IGhhbmRsZU9uQmx1ciB8fCAkWzE2NV0gIT09IGhhbmRsZU9uRm9jdXMgfHwgJFsxNjZdICE9PSBoYW5kbGVQYXN0ZSB8fCAkWzE2N10gIT09IGhhc0ludmFsaWRWYWx1ZSB8fCAkWzE2OF0gIT09IHJlYWRPbmx5IHx8ICRbMTY5XSAhPT0gcmVuZGVyRWxlbWVudCB8fCAkWzE3MF0gIT09IHJlbmRlckxlYWYgfHwgJFsxNzFdICE9PSByZXN0UHJvcHMgfHwgJFsxNzJdICE9PSBzY3JvbGxTZWxlY3Rpb25JbnRvVmlld1RvU2xhdGUgPyAodDM3ID0gaGFzSW52YWxpZFZhbHVlID8gbnVsbCA6IC8qIEBfX1BVUkVfXyAqLyBqc3goRWRpdGFibGUsIHsgLi4ucmVzdFByb3BzLCByZWY6IGNhbGxiYWNrUmVmLCBcImRhdGEtcmVhZC1vbmx5XCI6IHJlYWRPbmx5LCBhdXRvRm9jdXM6ICExLCBjbGFzc05hbWU6IHJlc3RQcm9wcy5jbGFzc05hbWUgfHwgXCJwdC1lZGl0YWJsZVwiLCBkZWNvcmF0ZSwgb25CbHVyOiBoYW5kbGVPbkJsdXIsIG9uQ29weTogaGFuZGxlQ29weSwgb25DdXQ6IGhhbmRsZUN1dCwgb25DbGljazogaGFuZGxlQ2xpY2ssIG9uRE9NQmVmb3JlSW5wdXQ6IGhhbmRsZU9uQmVmb3JlSW5wdXQsIG9uRHJhZ1N0YXJ0OiBoYW5kbGVEcmFnU3RhcnQsIG9uRHJhZzogaGFuZGxlRHJhZywgb25EcmFnRW5kOiBoYW5kbGVEcmFnRW5kLCBvbkRyYWdFbnRlcjogaGFuZGxlRHJhZ0VudGVyLCBvbkRyYWdPdmVyOiBoYW5kbGVEcmFnT3Zlciwgb25Ecm9wOiBoYW5kbGVEcm9wLCBvbkRyYWdMZWF2ZTogaGFuZGxlRHJhZ0xlYXZlLCBvbkZvY3VzOiBoYW5kbGVPbkZvY3VzLCBvbktleURvd246IGhhbmRsZUtleURvd24sIG9uS2V5VXA6IGhhbmRsZUtleVVwLCBvblBhc3RlOiBoYW5kbGVQYXN0ZSwgcmVhZE9ubHksIHJlbmRlclBsYWNlaG9sZGVyOiB2b2lkIDAsIHJlbmRlckVsZW1lbnQsIHJlbmRlckxlYWYsIHJlbmRlclRleHQsIHNjcm9sbFNlbGVjdGlvbkludG9WaWV3OiBzY3JvbGxTZWxlY3Rpb25JbnRvVmlld1RvU2xhdGUgfSksICRbMTQ5XSA9IGNhbGxiYWNrUmVmLCAkWzE1MF0gPSBkZWNvcmF0ZSwgJFsxNTFdID0gaGFuZGxlQ2xpY2ssICRbMTUyXSA9IGhhbmRsZUNvcHksICRbMTUzXSA9IGhhbmRsZUN1dCwgJFsxNTRdID0gaGFuZGxlRHJhZywgJFsxNTVdID0gaGFuZGxlRHJhZ0VuZCwgJFsxNTZdID0gaGFuZGxlRHJhZ0VudGVyLCAkWzE1N10gPSBoYW5kbGVEcmFnTGVhdmUsICRbMTU4XSA9IGhhbmRsZURyYWdPdmVyLCAkWzE1OV0gPSBoYW5kbGVEcmFnU3RhcnQsICRbMTYwXSA9IGhhbmRsZURyb3AsICRbMTYxXSA9IGhhbmRsZUtleURvd24sICRbMTYyXSA9IGhhbmRsZUtleVVwLCAkWzE2M10gPSBoYW5kbGVPbkJlZm9yZUlucHV0LCAkWzE2NF0gPSBoYW5kbGVPbkJsdXIsICRbMTY1XSA9IGhhbmRsZU9uRm9jdXMsICRbMTY2XSA9IGhhbmRsZVBhc3RlLCAkWzE2N10gPSBoYXNJbnZhbGlkVmFsdWUsICRbMTY4XSA9IHJlYWRPbmx5LCAkWzE2OV0gPSByZW5kZXJFbGVtZW50LCAkWzE3MF0gPSByZW5kZXJMZWFmLCAkWzE3MV0gPSByZXN0UHJvcHMsICRbMTcyXSA9IHNjcm9sbFNlbGVjdGlvbkludG9WaWV3VG9TbGF0ZSwgJFsxNzNdID0gdDM3KSA6IHQzNyA9ICRbMTczXSwgdDM3O1xufSk7XG5Qb3J0YWJsZVRleHRFZGl0YWJsZS5kaXNwbGF5TmFtZSA9IFwiRm9yd2FyZFJlZihQb3J0YWJsZVRleHRFZGl0YWJsZSlcIjtcbmZ1bmN0aW9uIF90ZW1wKHMpIHtcbiAgcmV0dXJuIHMubWF0Y2hlcyh7XG4gICAgXCJlZGl0IG1vZGVcIjogXCJyZWFkIG9ubHlcIlxuICB9KTtcbn1cbmZ1bmN0aW9uIF90ZW1wMihzXzApIHtcbiAgcmV0dXJuIHNfMC5jb250ZXh0LmRlY29yYXRlPy5mbjtcbn1cbmZ1bmN0aW9uIF90ZW1wMyhwcm9wc18wKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFJlbmRlclRleHQsIHsgLi4ucHJvcHNfMCB9KTtcbn1cbmZ1bmN0aW9uIF90ZW1wNChvKSB7XG4gIHJldHVybiBvLnR5cGUgPT09IFwic2V0X3NlbGVjdGlvblwiO1xufVxuZnVuY3Rpb24gX3RlbXA1KGVycm9yKSB7XG4gIHJldHVybiBjb25zb2xlLndhcm4oZXJyb3IpLCBlcnJvcjtcbn1cbmNvbnN0IGZvckVhY2hBY3RvciA9IChhY3RvclJlZiwgY2FsbGJhY2spID0+IHtcbiAgY2FsbGJhY2soYWN0b3JSZWYpO1xuICBjb25zdCBjaGlsZHJlbiA9IGFjdG9yUmVmLmdldFNuYXBzaG90KCkuY2hpbGRyZW47XG4gIGNoaWxkcmVuICYmIE9iamVjdC52YWx1ZXMoY2hpbGRyZW4pLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgZm9yRWFjaEFjdG9yKGNoaWxkLCBjYWxsYmFjayk7XG4gIH0pO1xufTtcbmZ1bmN0aW9uIHN0b3BBY3RvcihhY3RvclJlZikge1xuICBjb25zdCBwZXJzaXN0ZWRTbmFwc2hvdHMgPSBbXTtcbiAgZm9yRWFjaEFjdG9yKGFjdG9yUmVmLCAocmVmKSA9PiB7XG4gICAgcGVyc2lzdGVkU25hcHNob3RzLnB1c2goW3JlZiwgcmVmLmdldFNuYXBzaG90KCldKSwgcmVmLm9ic2VydmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIH0pO1xuICBjb25zdCBzeXN0ZW1TbmFwc2hvdCA9IGFjdG9yUmVmLnN5c3RlbS5nZXRTbmFwc2hvdD8uKCk7XG4gIGFjdG9yUmVmLnN0b3AoKSwgYWN0b3JSZWYuc3lzdGVtLl9zbmFwc2hvdCA9IHN5c3RlbVNuYXBzaG90LCBwZXJzaXN0ZWRTbmFwc2hvdHMuZm9yRWFjaCgoW3JlZiwgc25hcHNob3RdKSA9PiB7XG4gICAgcmVmLl9wcm9jZXNzaW5nU3RhdHVzID0gMCwgcmVmLl9zbmFwc2hvdCA9IHNuYXBzaG90O1xuICB9KTtcbn1cbmNvbnN0IGNvbnZlcnRlckpzb24gPSB7XG4gIG1pbWVUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgc2VyaWFsaXplOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IHtcbiAgICBjb25zdCBwb3J0YWJsZVRleHRDb252ZXJ0ZXIgPSBzbmFwc2hvdC5jb250ZXh0LmNvbnZlcnRlcnMuZmluZCgoY29udmVydGVyKSA9PiBjb252ZXJ0ZXIubWltZVR5cGUgPT09IFwiYXBwbGljYXRpb24veC1wb3J0YWJsZS10ZXh0XCIpO1xuICAgIHJldHVybiBwb3J0YWJsZVRleHRDb252ZXJ0ZXIgPyB7XG4gICAgICAuLi5wb3J0YWJsZVRleHRDb252ZXJ0ZXIuc2VyaWFsaXplKHtcbiAgICAgICAgc25hcHNob3QsXG4gICAgICAgIGV2ZW50XG4gICAgICB9KSxcbiAgICAgIG1pbWVUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIG9yaWdpbkV2ZW50OiBldmVudC5vcmlnaW5FdmVudFxuICAgIH0gOiB7XG4gICAgICB0eXBlOiBcInNlcmlhbGl6YXRpb24uZmFpbHVyZVwiLFxuICAgICAgbWltZVR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgb3JpZ2luRXZlbnQ6IGV2ZW50Lm9yaWdpbkV2ZW50LFxuICAgICAgcmVhc29uOiBcIk5vIGFwcGxpY2F0aW9uL3gtcG9ydGFibGUtdGV4dCBDb252ZXJ0ZXIgZm91bmRcIlxuICAgIH07XG4gIH0sXG4gIGRlc2VyaWFsaXplOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IHtcbiAgICBjb25zdCBwb3J0YWJsZVRleHRDb252ZXJ0ZXIgPSBzbmFwc2hvdC5jb250ZXh0LmNvbnZlcnRlcnMuZmluZCgoY29udmVydGVyKSA9PiBjb252ZXJ0ZXIubWltZVR5cGUgPT09IFwiYXBwbGljYXRpb24veC1wb3J0YWJsZS10ZXh0XCIpO1xuICAgIHJldHVybiBwb3J0YWJsZVRleHRDb252ZXJ0ZXIgPyB7XG4gICAgICAuLi5wb3J0YWJsZVRleHRDb252ZXJ0ZXIuZGVzZXJpYWxpemUoe1xuICAgICAgICBzbmFwc2hvdCxcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pLFxuICAgICAgbWltZVR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgfSA6IHtcbiAgICAgIHR5cGU6IFwiZGVzZXJpYWxpemF0aW9uLmZhaWx1cmVcIixcbiAgICAgIG1pbWVUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIHJlYXNvbjogXCJObyBhcHBsaWNhdGlvbi94LXBvcnRhYmxlLXRleHQgQ29udmVydGVyIGZvdW5kXCJcbiAgICB9O1xuICB9XG59LCBjb252ZXJ0ZXJQb3J0YWJsZVRleHQgPSB7XG4gIG1pbWVUeXBlOiBcImFwcGxpY2F0aW9uL3gtcG9ydGFibGUtdGV4dFwiLFxuICBzZXJpYWxpemU6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4ge1xuICAgIGlmICghc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24pXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInNlcmlhbGl6YXRpb24uZmFpbHVyZVwiLFxuICAgICAgICBtaW1lVHlwZTogXCJhcHBsaWNhdGlvbi94LXBvcnRhYmxlLXRleHRcIixcbiAgICAgICAgb3JpZ2luRXZlbnQ6IGV2ZW50Lm9yaWdpbkV2ZW50LFxuICAgICAgICByZWFzb246IFwiTm8gc2VsZWN0aW9uXCJcbiAgICAgIH07XG4gICAgY29uc3QgYmxvY2tzID0gZ2V0U2VsZWN0ZWRWYWx1ZShzbmFwc2hvdCk7XG4gICAgcmV0dXJuIGJsb2Nrcy5sZW5ndGggPT09IDAgPyB7XG4gICAgICB0eXBlOiBcInNlcmlhbGl6YXRpb24uZmFpbHVyZVwiLFxuICAgICAgbWltZVR5cGU6IFwiYXBwbGljYXRpb24veC1wb3J0YWJsZS10ZXh0XCIsXG4gICAgICByZWFzb246IFwiTm8gYmxvY2tzIHNlcmlhbGl6ZWRcIixcbiAgICAgIG9yaWdpbkV2ZW50OiBldmVudC5vcmlnaW5FdmVudFxuICAgIH0gOiB7XG4gICAgICB0eXBlOiBcInNlcmlhbGl6YXRpb24uc3VjY2Vzc1wiLFxuICAgICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoYmxvY2tzKSxcbiAgICAgIG1pbWVUeXBlOiBcImFwcGxpY2F0aW9uL3gtcG9ydGFibGUtdGV4dFwiLFxuICAgICAgb3JpZ2luRXZlbnQ6IGV2ZW50Lm9yaWdpbkV2ZW50XG4gICAgfTtcbiAgfSxcbiAgZGVzZXJpYWxpemU6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGJsb2NrcyA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGJsb2NrcykpXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImRlc2VyaWFsaXphdGlvbi5mYWlsdXJlXCIsXG4gICAgICAgIG1pbWVUeXBlOiBcImFwcGxpY2F0aW9uL3gtcG9ydGFibGUtdGV4dFwiLFxuICAgICAgICByZWFzb246IFwiRGF0YSBpcyBub3QgYW4gYXJyYXlcIlxuICAgICAgfTtcbiAgICBjb25zdCBwYXJzZWRCbG9ja3MgPSBibG9ja3MuZmxhdE1hcCgoYmxvY2spID0+IHtcbiAgICAgIGNvbnN0IHBhcnNlZEJsb2NrID0gcGFyc2VCbG9jayh7XG4gICAgICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgIGJsb2NrLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgcmVtb3ZlVW51c2VkTWFya0RlZnM6ICEwLFxuICAgICAgICAgIHZhbGlkYXRlRmllbGRzOiAhMVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwYXJzZWRCbG9jayA/IFtwYXJzZWRCbG9ja10gOiBbXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcGFyc2VkQmxvY2tzLmxlbmd0aCA9PT0gMCAmJiBibG9ja3MubGVuZ3RoID4gMCA/IHtcbiAgICAgIHR5cGU6IFwiZGVzZXJpYWxpemF0aW9uLmZhaWx1cmVcIixcbiAgICAgIG1pbWVUeXBlOiBcImFwcGxpY2F0aW9uL3gtcG9ydGFibGUtdGV4dFwiLFxuICAgICAgcmVhc29uOiBcIk5vIGJsb2NrcyB3ZXJlIHBhcnNlZFwiXG4gICAgfSA6IHtcbiAgICAgIHR5cGU6IFwiZGVzZXJpYWxpemF0aW9uLnN1Y2Nlc3NcIixcbiAgICAgIGRhdGE6IHBhcnNlZEJsb2NrcyxcbiAgICAgIG1pbWVUeXBlOiBcImFwcGxpY2F0aW9uL3gtcG9ydGFibGUtdGV4dFwiXG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUNvbnZlcnRlclRleHRIdG1sKGxlZ2FjeVNjaGVtYSkge1xuICByZXR1cm4ge1xuICAgIG1pbWVUeXBlOiBcInRleHQvaHRtbFwiLFxuICAgIHNlcmlhbGl6ZTogKHtcbiAgICAgIHNuYXBzaG90LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiB7XG4gICAgICBpZiAoIXNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwic2VyaWFsaXphdGlvbi5mYWlsdXJlXCIsXG4gICAgICAgICAgbWltZVR5cGU6IFwidGV4dC9odG1sXCIsXG4gICAgICAgICAgb3JpZ2luRXZlbnQ6IGV2ZW50Lm9yaWdpbkV2ZW50LFxuICAgICAgICAgIHJlYXNvbjogXCJObyBzZWxlY3Rpb25cIlxuICAgICAgICB9O1xuICAgICAgY29uc3QgYmxvY2tzID0gZ2V0U2VsZWN0ZWRWYWx1ZShzbmFwc2hvdCksIGh0bWwgPSB0b0hUTUwoYmxvY2tzLCB7XG4gICAgICAgIG9uTWlzc2luZ0NvbXBvbmVudDogITEsXG4gICAgICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgICB1bmtub3duVHlwZTogKHtcbiAgICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgICAgfSkgPT4gY2hpbGRyZW4gIT09IHZvaWQgMCA/IGAke2NoaWxkcmVufWAgOiBcIlwiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGh0bWwgPT09IFwiXCIgPyB7XG4gICAgICAgIHR5cGU6IFwic2VyaWFsaXphdGlvbi5mYWlsdXJlXCIsXG4gICAgICAgIG1pbWVUeXBlOiBcInRleHQvaHRtbFwiLFxuICAgICAgICBvcmlnaW5FdmVudDogZXZlbnQub3JpZ2luRXZlbnQsXG4gICAgICAgIHJlYXNvbjogXCJTZXJpYWxpemVkIEhUTUwgaXMgZW1wdHlcIlxuICAgICAgfSA6IHtcbiAgICAgICAgdHlwZTogXCJzZXJpYWxpemF0aW9uLnN1Y2Nlc3NcIixcbiAgICAgICAgZGF0YTogaHRtbCxcbiAgICAgICAgbWltZVR5cGU6IFwidGV4dC9odG1sXCIsXG4gICAgICAgIG9yaWdpbkV2ZW50OiBldmVudC5vcmlnaW5FdmVudFxuICAgICAgfTtcbiAgICB9LFxuICAgIGRlc2VyaWFsaXplOiAoe1xuICAgICAgc25hcHNob3QsXG4gICAgICBldmVudFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IHBhcnNlZEJsb2NrcyA9IGh0bWxUb0Jsb2NrcyhldmVudC5kYXRhLCBsZWdhY3lTY2hlbWEucG9ydGFibGVUZXh0LCB7XG4gICAgICAgIGtleUdlbmVyYXRvcjogc25hcHNob3QuY29udGV4dC5rZXlHZW5lcmF0b3IsXG4gICAgICAgIHVuc3RhYmxlX3doaXRlc3BhY2VPblBhc3RlTW9kZTogbGVnYWN5U2NoZW1hLmJsb2NrLm9wdGlvbnMudW5zdGFibGVfd2hpdGVzcGFjZU9uUGFzdGVNb2RlXG4gICAgICB9KS5mbGF0TWFwKChibG9jaykgPT4ge1xuICAgICAgICBjb25zdCBwYXJzZWRCbG9jayA9IHBhcnNlQmxvY2soe1xuICAgICAgICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgICAgYmxvY2ssXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgcmVtb3ZlVW51c2VkTWFya0RlZnM6ICEwLFxuICAgICAgICAgICAgdmFsaWRhdGVGaWVsZHM6ICExXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcnNlZEJsb2NrID8gW3BhcnNlZEJsb2NrXSA6IFtdO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGFyc2VkQmxvY2tzLmxlbmd0aCA9PT0gMCA/IHtcbiAgICAgICAgdHlwZTogXCJkZXNlcmlhbGl6YXRpb24uZmFpbHVyZVwiLFxuICAgICAgICBtaW1lVHlwZTogXCJ0ZXh0L2h0bWxcIixcbiAgICAgICAgcmVhc29uOiBcIk5vIGJsb2NrcyBkZXNlcmlhbGl6ZWRcIlxuICAgICAgfSA6IHtcbiAgICAgICAgdHlwZTogXCJkZXNlcmlhbGl6YXRpb24uc3VjY2Vzc1wiLFxuICAgICAgICBkYXRhOiBwYXJzZWRCbG9ja3MsXG4gICAgICAgIG1pbWVUeXBlOiBcInRleHQvaHRtbFwiXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbnZlcnRlclRleHRQbGFpbihsZWdhY3lTY2hlbWEpIHtcbiAgcmV0dXJuIHtcbiAgICBtaW1lVHlwZTogXCJ0ZXh0L3BsYWluXCIsXG4gICAgc2VyaWFsaXplOiAoe1xuICAgICAgc25hcHNob3QsXG4gICAgICBldmVudFxuICAgIH0pID0+IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uID8ge1xuICAgICAgdHlwZTogXCJzZXJpYWxpemF0aW9uLnN1Y2Nlc3NcIixcbiAgICAgIGRhdGE6IGdldFNlbGVjdGVkVmFsdWUoc25hcHNob3QpLm1hcCgoYmxvY2spID0+IGlzVGV4dEJsb2NrKHNuYXBzaG90LmNvbnRleHQsIGJsb2NrKSA/IGJsb2NrLmNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IGNoaWxkLl90eXBlID09PSBzbmFwc2hvdC5jb250ZXh0LnNjaGVtYS5zcGFuLm5hbWUgPyBjaGlsZC50ZXh0IDogZXZlbnQub3JpZ2luRXZlbnQgPT09IFwiZHJhZy5kcmFnc3RhcnRcIiA/IGBbJHtzbmFwc2hvdC5jb250ZXh0LnNjaGVtYS5pbmxpbmVPYmplY3RzLmZpbmQoKGlubGluZU9iamVjdFR5cGUpID0+IGlubGluZU9iamVjdFR5cGUubmFtZSA9PT0gY2hpbGQuX3R5cGUpPy50aXRsZSA/PyBcIk9iamVjdFwifV1gIDogXCJcIikuam9pbihcIlwiKSA6IGV2ZW50Lm9yaWdpbkV2ZW50ID09PSBcImRyYWcuZHJhZ3N0YXJ0XCIgPyBgWyR7c25hcHNob3QuY29udGV4dC5zY2hlbWEuYmxvY2tPYmplY3RzLmZpbmQoKGJsb2NrT2JqZWN0VHlwZSkgPT4gYmxvY2tPYmplY3RUeXBlLm5hbWUgPT09IGJsb2NrLl90eXBlKT8udGl0bGUgPz8gXCJPYmplY3RcIn1dYCA6IFwiXCIpLmZpbHRlcigoYmxvY2spID0+IGJsb2NrICE9PSBcIlwiKS5qb2luKGBcblxuYCksXG4gICAgICBtaW1lVHlwZTogXCJ0ZXh0L3BsYWluXCIsXG4gICAgICBvcmlnaW5FdmVudDogZXZlbnQub3JpZ2luRXZlbnRcbiAgICB9IDoge1xuICAgICAgdHlwZTogXCJzZXJpYWxpemF0aW9uLmZhaWx1cmVcIixcbiAgICAgIG1pbWVUeXBlOiBcInRleHQvcGxhaW5cIixcbiAgICAgIG9yaWdpbkV2ZW50OiBldmVudC5vcmlnaW5FdmVudCxcbiAgICAgIHJlYXNvbjogXCJObyBzZWxlY3Rpb25cIlxuICAgIH0sXG4gICAgZGVzZXJpYWxpemU6ICh7XG4gICAgICBzbmFwc2hvdCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgdGV4dFRvSHRtbCA9IGA8aHRtbD48Ym9keT4ke2VzY2FwZUh0bWwoZXZlbnQuZGF0YSkuc3BsaXQoL1xcbnsyLH0vKS5tYXAoKGxpbmUpID0+IGxpbmUgPyBgPHA+JHtsaW5lLnJlcGxhY2UoLyg/OlxcclxcbnxcXHJ8XFxuKS9nLCBcIjxici8+XCIpfTwvcD5gIDogXCI8cD48L3A+XCIpLmpvaW4oXCJcIil9PC9ib2R5PjwvaHRtbD5gLCBwYXJzZWRCbG9ja3MgPSBodG1sVG9CbG9ja3ModGV4dFRvSHRtbCwgbGVnYWN5U2NoZW1hLnBvcnRhYmxlVGV4dCwge1xuICAgICAgICBrZXlHZW5lcmF0b3I6IHNuYXBzaG90LmNvbnRleHQua2V5R2VuZXJhdG9yXG4gICAgICB9KS5mbGF0TWFwKChibG9jaykgPT4ge1xuICAgICAgICBjb25zdCBwYXJzZWRCbG9jayA9IHBhcnNlQmxvY2soe1xuICAgICAgICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgICAgYmxvY2ssXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgcmVtb3ZlVW51c2VkTWFya0RlZnM6ICEwLFxuICAgICAgICAgICAgdmFsaWRhdGVGaWVsZHM6ICExXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcnNlZEJsb2NrID8gW3BhcnNlZEJsb2NrXSA6IFtdO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGFyc2VkQmxvY2tzLmxlbmd0aCA9PT0gMCA/IHtcbiAgICAgICAgdHlwZTogXCJkZXNlcmlhbGl6YXRpb24uZmFpbHVyZVwiLFxuICAgICAgICBtaW1lVHlwZTogXCJ0ZXh0L3BsYWluXCIsXG4gICAgICAgIHJlYXNvbjogXCJObyBibG9ja3MgZGVzZXJpYWxpemVkXCJcbiAgICAgIH0gOiB7XG4gICAgICAgIHR5cGU6IFwiZGVzZXJpYWxpemF0aW9uLnN1Y2Nlc3NcIixcbiAgICAgICAgZGF0YTogcGFyc2VkQmxvY2tzLFxuICAgICAgICBtaW1lVHlwZTogXCJ0ZXh0L3BsYWluXCJcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuY29uc3QgZW50aXR5TWFwID0ge1xuICBcIiZcIjogXCImYW1wO1wiLFxuICBcIjxcIjogXCImbHQ7XCIsXG4gIFwiPlwiOiBcIiZndDtcIixcbiAgJ1wiJzogXCImcXVvdDtcIixcbiAgXCInXCI6IFwiJiMzOTtcIixcbiAgXCIvXCI6IFwiJiN4MkY7XCIsXG4gIFwiYFwiOiBcIiYjeDYwO1wiLFxuICBcIj1cIjogXCImI3gzRDtcIlxufTtcbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKC9bJjw+XCInYD0vXS9nLCAocykgPT4gZW50aXR5TWFwW3NdKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvcmVDb252ZXJ0ZXJzKGxlZ2FjeVNjaGVtYSkge1xuICByZXR1cm4gW2NvbnZlcnRlckpzb24sIGNvbnZlcnRlclBvcnRhYmxlVGV4dCwgY3JlYXRlQ29udmVydGVyVGV4dEh0bWwobGVnYWN5U2NoZW1hKSwgY3JlYXRlQ29udmVydGVyVGV4dFBsYWluKGxlZ2FjeVNjaGVtYSldO1xufVxuZnVuY3Rpb24gY29tcGlsZVR5cGUocmF3VHlwZSkge1xuICByZXR1cm4gU2NoZW1hLmNvbXBpbGUoe1xuICAgIG5hbWU6IFwiYmxvY2tUeXBlU2NoZW1hXCIsXG4gICAgdHlwZXM6IFtyYXdUeXBlXVxuICB9KS5nZXQocmF3VHlwZS5uYW1lKTtcbn1cbmNvbnN0IGxldmVsSW5kZXhNYXBzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGJ1aWxkSW5kZXhNYXBzKGNvbnRleHQsIHtcbiAgYmxvY2tJbmRleE1hcCxcbiAgbGlzdEluZGV4TWFwXG59KSB7XG4gIGJsb2NrSW5kZXhNYXAuY2xlYXIoKSwgbGlzdEluZGV4TWFwLmNsZWFyKCksIGxldmVsSW5kZXhNYXBzLmNsZWFyKCk7XG4gIGxldCBwcmV2aW91c0xpc3RJdGVtO1xuICBmb3IgKGxldCBibG9ja0luZGV4ID0gMDsgYmxvY2tJbmRleCA8IGNvbnRleHQudmFsdWUubGVuZ3RoOyBibG9ja0luZGV4KyspIHtcbiAgICBjb25zdCBibG9jayA9IGNvbnRleHQudmFsdWUuYXQoYmxvY2tJbmRleCk7XG4gICAgaWYgKGJsb2NrID09PSB2b2lkIDApXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAoYmxvY2tJbmRleE1hcC5zZXQoYmxvY2suX2tleSwgYmxvY2tJbmRleCksICFpc1RleHRCbG9jayhjb250ZXh0LCBibG9jaykpIHtcbiAgICAgIGxldmVsSW5kZXhNYXBzLmNsZWFyKCksIHByZXZpb3VzTGlzdEl0ZW0gPSB2b2lkIDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGJsb2NrLmxpc3RJdGVtID09PSB2b2lkIDAgfHwgYmxvY2subGV2ZWwgPT09IHZvaWQgMCkge1xuICAgICAgbGV2ZWxJbmRleE1hcHMuY2xlYXIoKSwgcHJldmlvdXNMaXN0SXRlbSA9IHZvaWQgMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoIXByZXZpb3VzTGlzdEl0ZW0pIHtcbiAgICAgIGNvbnN0IGxldmVsSW5kZXhNYXAyID0gbGV2ZWxJbmRleE1hcHMuZ2V0KGJsb2NrLmxpc3RJdGVtKSA/PyAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgbGV2ZWxJbmRleE1hcDIuc2V0KGJsb2NrLmxldmVsLCAxKSwgbGV2ZWxJbmRleE1hcHMuc2V0KGJsb2NrLmxpc3RJdGVtLCBsZXZlbEluZGV4TWFwMiksIGxpc3RJbmRleE1hcC5zZXQoYmxvY2suX2tleSwgMSksIHByZXZpb3VzTGlzdEl0ZW0gPSB7XG4gICAgICAgIGxpc3RJdGVtOiBibG9jay5saXN0SXRlbSxcbiAgICAgICAgbGV2ZWw6IGJsb2NrLmxldmVsXG4gICAgICB9O1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcmV2aW91c0xpc3RJdGVtLmxpc3RJdGVtID09PSBibG9jay5saXN0SXRlbSAmJiBwcmV2aW91c0xpc3RJdGVtLmxldmVsIDwgYmxvY2subGV2ZWwpIHtcbiAgICAgIGNvbnN0IGxldmVsSW5kZXhNYXAyID0gbGV2ZWxJbmRleE1hcHMuZ2V0KGJsb2NrLmxpc3RJdGVtKSA/PyAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgbGV2ZWxJbmRleE1hcDIuc2V0KGJsb2NrLmxldmVsLCAxKSwgbGV2ZWxJbmRleE1hcHMuc2V0KGJsb2NrLmxpc3RJdGVtLCBsZXZlbEluZGV4TWFwMiksIGxpc3RJbmRleE1hcC5zZXQoYmxvY2suX2tleSwgMSksIHByZXZpb3VzTGlzdEl0ZW0gPSB7XG4gICAgICAgIGxpc3RJdGVtOiBibG9jay5saXN0SXRlbSxcbiAgICAgICAgbGV2ZWw6IGJsb2NrLmxldmVsXG4gICAgICB9O1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGxldmVsSW5kZXhNYXBzLmZvckVhY2goKGxldmVsSW5kZXhNYXAyLCBsaXN0SXRlbSkgPT4ge1xuICAgICAgaWYgKGxpc3RJdGVtID09PSBibG9jay5saXN0SXRlbSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgbGV2ZWxzVG9EZWxldGUgPSBbXTtcbiAgICAgIGxldmVsSW5kZXhNYXAyLmZvckVhY2goKF8sIGxldmVsKSA9PiB7XG4gICAgICAgIGxldmVsID49IGJsb2NrLmxldmVsICYmIGxldmVsc1RvRGVsZXRlLnB1c2gobGV2ZWwpO1xuICAgICAgfSksIGxldmVsc1RvRGVsZXRlLmZvckVhY2goKGxldmVsKSA9PiB7XG4gICAgICAgIGxldmVsSW5kZXhNYXAyLmRlbGV0ZShsZXZlbCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjb25zdCBsZXZlbEluZGV4TWFwID0gbGV2ZWxJbmRleE1hcHMuZ2V0KGJsb2NrLmxpc3RJdGVtKSA/PyAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBsZXZlbENvdW50ZXIgPSBsZXZlbEluZGV4TWFwLmdldChibG9jay5sZXZlbCkgPz8gMDtcbiAgICBsZXZlbEluZGV4TWFwLnNldChibG9jay5sZXZlbCwgbGV2ZWxDb3VudGVyICsgMSksIGxldmVsSW5kZXhNYXBzLnNldChibG9jay5saXN0SXRlbSwgbGV2ZWxJbmRleE1hcCksIGxpc3RJbmRleE1hcC5zZXQoYmxvY2suX2tleSwgbGV2ZWxDb3VudGVyICsgMSksIHByZXZpb3VzTGlzdEl0ZW0gPSB7XG4gICAgICBsaXN0SXRlbTogYmxvY2subGlzdEl0ZW0sXG4gICAgICBsZXZlbDogYmxvY2subGV2ZWxcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQbGFjZWhvbGRlckJsb2NrKGNvbnRleHQpIHtcbiAgcmV0dXJuIHtcbiAgICBfdHlwZTogY29udGV4dC5zY2hlbWEuYmxvY2submFtZSxcbiAgICBfa2V5OiBjb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgIHN0eWxlOiBjb250ZXh0LnNjaGVtYS5zdHlsZXNbMF0ubmFtZSA/PyBcIm5vcm1hbFwiLFxuICAgIG1hcmtEZWZzOiBbXSxcbiAgICBjaGlsZHJlbjogW3tcbiAgICAgIF90eXBlOiBjb250ZXh0LnNjaGVtYS5zcGFuLm5hbWUsXG4gICAgICBfa2V5OiBjb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgdGV4dDogXCJcIixcbiAgICAgIG1hcmtzOiBbXVxuICAgIH1dXG4gIH07XG59XG5mdW5jdGlvbiBnZXRQcmV2aW91c1NwYW4oe1xuICBlZGl0b3IsXG4gIGJsb2NrUGF0aCxcbiAgc3BhblBhdGhcbn0pIHtcbiAgbGV0IHByZXZpb3VzU3BhbjtcbiAgZm9yIChjb25zdCBbY2hpbGQsIGNoaWxkUGF0aF0gb2YgTm9kZS5jaGlsZHJlbihlZGl0b3IsIGJsb2NrUGF0aCwge1xuICAgIHJldmVyc2U6ICEwXG4gIH0pKVxuICAgIGlmIChlZGl0b3IuaXNUZXh0U3BhbihjaGlsZCkgJiYgUGF0aC5pc0JlZm9yZShjaGlsZFBhdGgsIHNwYW5QYXRoKSkge1xuICAgICAgcHJldmlvdXNTcGFuID0gY2hpbGQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIHJldHVybiBwcmV2aW91c1NwYW47XG59XG5mdW5jdGlvbiBnZXROZXh0U3Bhbih7XG4gIGVkaXRvcixcbiAgYmxvY2tQYXRoLFxuICBzcGFuUGF0aFxufSkge1xuICBsZXQgbmV4dFNwYW47XG4gIGZvciAoY29uc3QgW2NoaWxkLCBjaGlsZFBhdGhdIG9mIE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBibG9ja1BhdGgpKVxuICAgIGlmIChlZGl0b3IuaXNUZXh0U3BhbihjaGlsZCkgJiYgUGF0aC5pc0FmdGVyKGNoaWxkUGF0aCwgc3BhblBhdGgpKSB7XG4gICAgICBuZXh0U3BhbiA9IGNoaWxkO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gbmV4dFNwYW47XG59XG5mdW5jdGlvbiB3aXRoUmVtb3RlQ2hhbmdlcyhlZGl0b3IsIGZuKSB7XG4gIGNvbnN0IHByZXYgPSBpc0NoYW5naW5nUmVtb3RlbHkoZWRpdG9yKSB8fCAhMTtcbiAgSVNfUFJPQ0VTU0lOR19SRU1PVEVfQ0hBTkdFUy5zZXQoZWRpdG9yLCAhMCksIGZuKCksIElTX1BST0NFU1NJTkdfUkVNT1RFX0NIQU5HRVMuc2V0KGVkaXRvciwgcHJldik7XG59XG5mdW5jdGlvbiBpc0NoYW5naW5nUmVtb3RlbHkoZWRpdG9yKSB7XG4gIHJldHVybiBJU19QUk9DRVNTSU5HX1JFTU9URV9DSEFOR0VTLmdldChlZGl0b3IpO1xufVxuY29uc3QgSVNfVURPSU5HID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIElTX1JFRE9JTkcgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHdpdGhVbmRvaW5nKGVkaXRvciwgZm4pIHtcbiAgY29uc3QgcHJldiA9IGlzVW5kb2luZyhlZGl0b3IpO1xuICBJU19VRE9JTkcuc2V0KGVkaXRvciwgITApLCBmbigpLCBJU19VRE9JTkcuc2V0KGVkaXRvciwgcHJldik7XG59XG5mdW5jdGlvbiBpc1VuZG9pbmcoZWRpdG9yKSB7XG4gIHJldHVybiBJU19VRE9JTkcuZ2V0KGVkaXRvcikgPz8gITE7XG59XG5mdW5jdGlvbiBzZXRJc1VuZG9pbmcoZWRpdG9yLCBpc1VuZG9pbmcyKSB7XG4gIElTX1VET0lORy5zZXQoZWRpdG9yLCBpc1VuZG9pbmcyKTtcbn1cbmZ1bmN0aW9uIHdpdGhSZWRvaW5nKGVkaXRvciwgZm4pIHtcbiAgY29uc3QgcHJldiA9IGlzUmVkb2luZyhlZGl0b3IpO1xuICBJU19SRURPSU5HLnNldChlZGl0b3IsICEwKSwgZm4oKSwgSVNfUkVET0lORy5zZXQoZWRpdG9yLCBwcmV2KTtcbn1cbmZ1bmN0aW9uIGlzUmVkb2luZyhlZGl0b3IpIHtcbiAgcmV0dXJuIElTX1JFRE9JTkcuZ2V0KGVkaXRvcikgPz8gITE7XG59XG5mdW5jdGlvbiBzZXRJc1JlZG9pbmcoZWRpdG9yLCBpc1JlZG9pbmcyKSB7XG4gIElTX1JFRE9JTkcuc2V0KGVkaXRvciwgaXNSZWRvaW5nMik7XG59XG5jb25zdCBkZWJ1ZyRjID0gZGVidWdXaXRoTmFtZShcInBsdWdpbjp3aXRoUG9ydGFibGVUZXh0TWFya01vZGVsXCIpO1xuZnVuY3Rpb24gY3JlYXRlV2l0aFBvcnRhYmxlVGV4dE1hcmtNb2RlbChlZGl0b3JBY3Rvcikge1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgYXBwbHk6IGFwcGx5MixcbiAgICAgIG5vcm1hbGl6ZU5vZGVcbiAgICB9ID0gZWRpdG9yLCBkZWNvcmF0b3JzID0gZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYS5kZWNvcmF0b3JzLm1hcCgodCkgPT4gdC5uYW1lKTtcbiAgICByZXR1cm4gZWRpdG9yLm5vcm1hbGl6ZU5vZGUgPSAobm9kZUVudHJ5KSA9PiB7XG4gICAgICBjb25zdCBbbm9kZSwgcGF0aF0gPSBub2RlRW50cnk7XG4gICAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gTm9kZS5jaGlsZHJlbihlZGl0b3IsIHBhdGgpO1xuICAgICAgICBmb3IgKGNvbnN0IFtjaGlsZCwgY2hpbGRQYXRoXSBvZiBjaGlsZHJlbikge1xuICAgICAgICAgIGNvbnN0IG5leHROb2RlID0gbm9kZS5jaGlsZHJlbltjaGlsZFBhdGhbMV0gKyAxXTtcbiAgICAgICAgICBpZiAoZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpICYmIGVkaXRvci5pc1RleHRTcGFuKG5leHROb2RlKSAmJiBjaGlsZC5tYXJrcz8uZXZlcnkoKG1hcmspID0+IG5leHROb2RlLm1hcmtzPy5pbmNsdWRlcyhtYXJrKSkgJiYgbmV4dE5vZGUubWFya3M/LmV2ZXJ5KChtYXJrKSA9PiBjaGlsZC5tYXJrcz8uaW5jbHVkZXMobWFyaykpKSB7XG4gICAgICAgICAgICBkZWJ1ZyRjKFwiTWVyZ2luZyBzcGFuc1wiLCBKU09OLnN0cmluZ2lmeShjaGlsZCwgbnVsbCwgMiksIEpTT04uc3RyaW5naWZ5KG5leHROb2RlLCBudWxsLCAyKSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICB0eXBlOiBcIm5vcm1hbGl6aW5nXCJcbiAgICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLm1lcmdlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGF0OiBbY2hpbGRQYXRoWzBdLCBjaGlsZFBhdGhbMV0gKyAxXSxcbiAgICAgICAgICAgICAgdm9pZHM6ICEwXG4gICAgICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSkgJiYgIUFycmF5LmlzQXJyYXkobm9kZS5tYXJrRGVmcykpIHtcbiAgICAgICAgZGVidWckYyhcIkFkZGluZyAubWFya0RlZnMgdG8gYmxvY2sgbm9kZVwiKSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIG1hcmtEZWZzOiBbXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZWRpdG9yLmlzVGV4dFNwYW4obm9kZSkgJiYgIUFycmF5LmlzQXJyYXkobm9kZS5tYXJrcykpIHtcbiAgICAgICAgZGVidWckYyhcIkFkZGluZyAubWFya3MgdG8gc3BhbiBub2RlXCIpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcIm5vcm1hbGl6aW5nXCJcbiAgICAgICAgfSksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgbWFya3M6IFtdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBhdDogcGF0aFxuICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJkb25lIG5vcm1hbGl6aW5nXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlZGl0b3IuaXNUZXh0U3Bhbihub2RlKSkge1xuICAgICAgICBjb25zdCBibG9ja1BhdGggPSBQYXRoLnBhcmVudChwYXRoKSwgW2Jsb2NrXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgYmxvY2tQYXRoKSwgZGVjb3JhdG9yczIgPSBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLmRlY29yYXRvcnMubWFwKChkZWNvcmF0b3IpID0+IGRlY29yYXRvci5uYW1lKSwgYW5ub3RhdGlvbnMgPSBub2RlLm1hcmtzPy5maWx0ZXIoKG1hcmspID0+ICFkZWNvcmF0b3JzMi5pbmNsdWRlcyhtYXJrKSk7XG4gICAgICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIG5vZGUudGV4dCA9PT0gXCJcIiAmJiBhbm5vdGF0aW9ucyAmJiBhbm5vdGF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZGVidWckYyhcIlJlbW92aW5nIGFubm90YXRpb25zIGZyb20gZW1wdHkgc3BhbiBub2RlXCIpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgbWFya3M6IG5vZGUubWFya3M/LmZpbHRlcigobWFyaykgPT4gZGVjb3JhdG9yczIuaW5jbHVkZXMobWFyaykpXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhub2RlKSkge1xuICAgICAgICBjb25zdCBkZWNvcmF0b3JzMiA9IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEuZGVjb3JhdG9ycy5tYXAoKGRlY29yYXRvcikgPT4gZGVjb3JhdG9yLm5hbWUpO1xuICAgICAgICBmb3IgKGNvbnN0IFtjaGlsZCwgY2hpbGRQYXRoXSBvZiBOb2RlLmNoaWxkcmVuKGVkaXRvciwgcGF0aCkpXG4gICAgICAgICAgaWYgKGVkaXRvci5pc1RleHRTcGFuKGNoaWxkKSkge1xuICAgICAgICAgICAgY29uc3QgbWFya3MgPSBjaGlsZC5tYXJrcyA/PyBbXSwgb3JwaGFuZWRBbm5vdGF0aW9ucyA9IG1hcmtzLmZpbHRlcigobWFyaykgPT4gIWRlY29yYXRvcnMyLmluY2x1ZGVzKG1hcmspICYmICFub2RlLm1hcmtEZWZzPy5maW5kKChkZWYpID0+IGRlZi5fa2V5ID09PSBtYXJrKSk7XG4gICAgICAgICAgICBpZiAob3JwaGFuZWRBbm5vdGF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGRlYnVnJGMoXCJSZW1vdmluZyBvcnBoYW5lZCBhbm5vdGF0aW9ucyBmcm9tIHNwYW4gbm9kZVwiKSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIG1hcmtzOiBtYXJrcy5maWx0ZXIoKG1hcmspID0+ICFvcnBoYW5lZEFubm90YXRpb25zLmluY2x1ZGVzKG1hcmspKVxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgYXQ6IGNoaWxkUGF0aFxuICAgICAgICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJkb25lIG5vcm1hbGl6aW5nXCJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZWRpdG9yLmlzVGV4dFNwYW4obm9kZSkpIHtcbiAgICAgICAgY29uc3QgYmxvY2tQYXRoID0gUGF0aC5wYXJlbnQocGF0aCksIFtibG9ja10gPSBFZGl0b3Iubm9kZShlZGl0b3IsIGJsb2NrUGF0aCk7XG4gICAgICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spKSB7XG4gICAgICAgICAgY29uc3QgZGVjb3JhdG9yczIgPSBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLmRlY29yYXRvcnMubWFwKChkZWNvcmF0b3IpID0+IGRlY29yYXRvci5uYW1lKSwgbWFya3MgPSBub2RlLm1hcmtzID8/IFtdLCBvcnBoYW5lZEFubm90YXRpb25zID0gbWFya3MuZmlsdGVyKChtYXJrKSA9PiAhZGVjb3JhdG9yczIuaW5jbHVkZXMobWFyaykgJiYgIWJsb2NrLm1hcmtEZWZzPy5maW5kKChkZWYpID0+IGRlZi5fa2V5ID09PSBtYXJrKSk7XG4gICAgICAgICAgaWYgKG9ycGhhbmVkQW5ub3RhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZGVidWckYyhcIlJlbW92aW5nIG9ycGhhbmVkIGFubm90YXRpb25zIGZyb20gc3BhbiBub2RlXCIpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgbWFya3M6IG1hcmtzLmZpbHRlcigobWFyaykgPT4gIW9ycGhhbmVkQW5ub3RhdGlvbnMuaW5jbHVkZXMobWFyaykpXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSkpIHtcbiAgICAgICAgY29uc3QgbWFya0RlZnMgPSBub2RlLm1hcmtEZWZzID8/IFtdLCBtYXJrRGVmS2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIG5ld01hcmtEZWZzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbWFya0RlZiBvZiBtYXJrRGVmcylcbiAgICAgICAgICBtYXJrRGVmS2V5cy5oYXMobWFya0RlZi5fa2V5KSB8fCAobWFya0RlZktleXMuYWRkKG1hcmtEZWYuX2tleSksIG5ld01hcmtEZWZzLnB1c2gobWFya0RlZikpO1xuICAgICAgICBpZiAobWFya0RlZnMubGVuZ3RoICE9PSBuZXdNYXJrRGVmcy5sZW5ndGgpIHtcbiAgICAgICAgICBkZWJ1ZyRjKFwiUmVtb3ZpbmcgZHVwbGljYXRlIG1hcmtEZWZzXCIpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgbWFya0RlZnM6IG5ld01hcmtEZWZzXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhub2RlKSAmJiAhZWRpdG9yLm9wZXJhdGlvbnMuc29tZSgob3ApID0+IG9wLnR5cGUgPT09IFwibWVyZ2Vfbm9kZVwiICYmIFwibWFya0RlZnNcIiBpbiBvcC5wcm9wZXJ0aWVzICYmIG9wLnBhdGgubGVuZ3RoID09PSAxKSkge1xuICAgICAgICBjb25zdCBuZXdNYXJrRGVmcyA9IChub2RlLm1hcmtEZWZzIHx8IFtdKS5maWx0ZXIoKGRlZikgPT4gbm9kZS5jaGlsZHJlbi5maW5kKChjaGlsZCkgPT4gVGV4dC5pc1RleHQoY2hpbGQpICYmIEFycmF5LmlzQXJyYXkoY2hpbGQubWFya3MpICYmIGNoaWxkLm1hcmtzLmluY2x1ZGVzKGRlZi5fa2V5KSkpO1xuICAgICAgICBpZiAobm9kZS5tYXJrRGVmcyAmJiAhaXNFcXVhbChuZXdNYXJrRGVmcywgbm9kZS5tYXJrRGVmcykpIHtcbiAgICAgICAgICBkZWJ1ZyRjKFwiUmVtb3ZpbmcgbWFya0RlZiBub3QgaW4gdXNlXCIpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgbWFya0RlZnM6IG5ld01hcmtEZWZzXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9ybWFsaXplTm9kZShub2RlRW50cnkpO1xuICAgIH0sIGVkaXRvci5hcHBseSA9IChvcCkgPT4ge1xuICAgICAgaWYgKGlzQ2hhbmdpbmdSZW1vdGVseShlZGl0b3IpKSB7XG4gICAgICAgIGFwcGx5MihvcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1VuZG9pbmcoZWRpdG9yKSB8fCBpc1JlZG9pbmcoZWRpdG9yKSkge1xuICAgICAgICBhcHBseTIob3ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAob3AudHlwZSA9PT0gXCJzZXRfc2VsZWN0aW9uXCIgJiYgb3AucHJvcGVydGllcyAmJiBvcC5uZXdQcm9wZXJ0aWVzICYmIG9wLnByb3BlcnRpZXMuYW5jaG9yICYmIG9wLnByb3BlcnRpZXMuZm9jdXMgJiYgb3AubmV3UHJvcGVydGllcy5hbmNob3IgJiYgb3AubmV3UHJvcGVydGllcy5mb2N1cykge1xuICAgICAgICBjb25zdCBwcmV2aW91c1NlbGVjdGlvbklzQ29sbGFwc2VkID0gUmFuZ2UuaXNDb2xsYXBzZWQoe1xuICAgICAgICAgIGFuY2hvcjogb3AucHJvcGVydGllcy5hbmNob3IsXG4gICAgICAgICAgZm9jdXM6IG9wLnByb3BlcnRpZXMuZm9jdXNcbiAgICAgICAgfSksIG5ld1NlbGVjdGlvbklzQ29sbGFwc2VkID0gUmFuZ2UuaXNDb2xsYXBzZWQoe1xuICAgICAgICAgIGFuY2hvcjogb3AubmV3UHJvcGVydGllcy5hbmNob3IsXG4gICAgICAgICAgZm9jdXM6IG9wLm5ld1Byb3BlcnRpZXMuZm9jdXNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcmV2aW91c1NlbGVjdGlvbklzQ29sbGFwc2VkICYmIG5ld1NlbGVjdGlvbklzQ29sbGFwc2VkKSB7XG4gICAgICAgICAgY29uc3QgZm9jdXNTcGFuID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBtb2RlOiBcImxvd2VzdFwiLFxuICAgICAgICAgICAgYXQ6IG9wLnByb3BlcnRpZXMuZm9jdXMsXG4gICAgICAgICAgICBtYXRjaDogKG4pID0+IGVkaXRvci5pc1RleHRTcGFuKG4pLFxuICAgICAgICAgICAgdm9pZHM6ICExXG4gICAgICAgICAgfSkpWzBdPy5bMF0sIG5ld0ZvY3VzU3BhbiA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgbW9kZTogXCJsb3dlc3RcIixcbiAgICAgICAgICAgIGF0OiBvcC5uZXdQcm9wZXJ0aWVzLmZvY3VzLFxuICAgICAgICAgICAgbWF0Y2g6IChuKSA9PiBlZGl0b3IuaXNUZXh0U3BhbihuKSxcbiAgICAgICAgICAgIHZvaWRzOiAhMVxuICAgICAgICAgIH0pKVswXT8uWzBdLCBtb3ZlZFRvTmV4dFNwYW4gPSBmb2N1c1NwYW4gJiYgbmV3Rm9jdXNTcGFuICYmIG9wLm5ld1Byb3BlcnRpZXMuZm9jdXMucGF0aFswXSA9PT0gb3AucHJvcGVydGllcy5mb2N1cy5wYXRoWzBdICYmIG9wLm5ld1Byb3BlcnRpZXMuZm9jdXMucGF0aFsxXSA9PT0gb3AucHJvcGVydGllcy5mb2N1cy5wYXRoWzFdICsgMSAmJiBmb2N1c1NwYW4udGV4dC5sZW5ndGggPT09IG9wLnByb3BlcnRpZXMuZm9jdXMub2Zmc2V0ICYmIG9wLm5ld1Byb3BlcnRpZXMuZm9jdXMub2Zmc2V0ID09PSAwLCBtb3ZlZFRvUHJldmlvdXNTcGFuID0gZm9jdXNTcGFuICYmIG5ld0ZvY3VzU3BhbiAmJiBvcC5uZXdQcm9wZXJ0aWVzLmZvY3VzLnBhdGhbMF0gPT09IG9wLnByb3BlcnRpZXMuZm9jdXMucGF0aFswXSAmJiBvcC5uZXdQcm9wZXJ0aWVzLmZvY3VzLnBhdGhbMV0gPT09IG9wLnByb3BlcnRpZXMuZm9jdXMucGF0aFsxXSAtIDEgJiYgb3AucHJvcGVydGllcy5mb2N1cy5vZmZzZXQgPT09IDAgJiYgbmV3Rm9jdXNTcGFuLnRleHQubGVuZ3RoID09PSBvcC5uZXdQcm9wZXJ0aWVzLmZvY3VzLm9mZnNldDtcbiAgICAgICAgICAhbW92ZWRUb05leHRTcGFuICYmICFtb3ZlZFRvUHJldmlvdXNTcGFuICYmIChlZGl0b3IuZGVjb3JhdG9yU3RhdGUgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcC50eXBlID09PSBcInJlbW92ZV90ZXh0XCIpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNlbGVjdGlvblxuICAgICAgICB9ID0gZWRpdG9yO1xuICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgIGNvbnN0IFtibG9jaywgYmxvY2tQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgc2VsZWN0aW9uLCB7XG4gICAgICAgICAgICBkZXB0aDogMVxuICAgICAgICAgIH0pLCBbc3Bhbiwgc3BhblBhdGhdID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBtb2RlOiBcImxvd2VzdFwiLFxuICAgICAgICAgICAgYXQ6IHtcbiAgICAgICAgICAgICAgcGF0aDogb3AucGF0aCxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBvcC5vZmZzZXRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXRjaDogKG4pID0+IGVkaXRvci5pc1RleHRTcGFuKG4pLFxuICAgICAgICAgICAgdm9pZHM6ICExXG4gICAgICAgICAgfSkpWzBdID8/IFt2b2lkIDAsIHZvaWQgMF07XG4gICAgICAgICAgaWYgKHNwYW4gJiYgYmxvY2sgJiYgaXNUZXh0QmxvY2soZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LCBibG9jaykpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcmtEZWZzID0gYmxvY2subWFya0RlZnMgPz8gW10sIG1hcmtzID0gc3Bhbi5tYXJrcyA/PyBbXSwgc3Bhbkhhc0Fubm90YXRpb25zID0gbWFya3Muc29tZSgobWFyaykgPT4gbWFya0RlZnMuZmluZCgobWFya0RlZikgPT4gbWFya0RlZi5fa2V5ID09PSBtYXJrKSksIGRlbGV0aW5nRnJvbVRoZUVuZCA9IG9wLm9mZnNldCArIG9wLnRleHQubGVuZ3RoID09PSBzcGFuLnRleHQubGVuZ3RoLCBkZWxldGluZ0FsbFRleHQgPSBvcC5vZmZzZXQgPT09IDAgJiYgZGVsZXRpbmdGcm9tVGhlRW5kLCBwcmV2aW91c1NwYW4gPSBnZXRQcmV2aW91c1NwYW4oe1xuICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgIGJsb2NrUGF0aCxcbiAgICAgICAgICAgICAgc3BhblBhdGhcbiAgICAgICAgICAgIH0pLCBuZXh0U3BhbiA9IGdldE5leHRTcGFuKHtcbiAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICBibG9ja1BhdGgsXG4gICAgICAgICAgICAgIHNwYW5QYXRoXG4gICAgICAgICAgICB9KSwgcHJldmlvdXNTcGFuSGFzU2FtZUFubm90YXRpb24gPSBwcmV2aW91c1NwYW4gPyBwcmV2aW91c1NwYW4ubWFya3M/LnNvbWUoKG1hcmspID0+ICFkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspICYmIG1hcmtzLmluY2x1ZGVzKG1hcmspKSA6ICExLCBuZXh0U3Bhbkhhc1NhbWVBbm5vdGF0aW9uID0gbmV4dFNwYW4gPyBuZXh0U3Bhbi5tYXJrcz8uc29tZSgobWFyaykgPT4gIWRlY29yYXRvcnMuaW5jbHVkZXMobWFyaykgJiYgbWFya3MuaW5jbHVkZXMobWFyaykpIDogITE7XG4gICAgICAgICAgICBpZiAoc3Bhbkhhc0Fubm90YXRpb25zICYmIGRlbGV0aW5nQWxsVGV4dCAmJiAhcHJldmlvdXNTcGFuSGFzU2FtZUFubm90YXRpb24gJiYgIW5leHRTcGFuSGFzU2FtZUFubm90YXRpb24pIHtcbiAgICAgICAgICAgICAgY29uc3Qgc25hcHNob3QgPSBnZXRFZGl0b3JTbmFwc2hvdCh7XG4gICAgICAgICAgICAgICAgZWRpdG9yQWN0b3JTbmFwc2hvdDogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKSxcbiAgICAgICAgICAgICAgICBzbGF0ZUVkaXRvckluc3RhbmNlOiBlZGl0b3JcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYXBwbHkyKG9wKSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICAgIG1hcmtzOiBnZXRBY3RpdmVEZWNvcmF0b3JzKHNuYXBzaG90KVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgIGF0OiBvcC5wYXRoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wLnR5cGUgPT09IFwibWVyZ2Vfbm9kZVwiICYmIG9wLnBhdGgubGVuZ3RoID09PSAxICYmIFwibWFya0RlZnNcIiBpbiBvcC5wcm9wZXJ0aWVzICYmIG9wLnByb3BlcnRpZXMuX3R5cGUgPT09IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEuYmxvY2submFtZSAmJiBBcnJheS5pc0FycmF5KG9wLnByb3BlcnRpZXMubWFya0RlZnMpICYmIG9wLnByb3BlcnRpZXMubWFya0RlZnMubGVuZ3RoID4gMCAmJiBvcC5wYXRoWzBdIC0gMSA+PSAwKSB7XG4gICAgICAgIGNvbnN0IFt0YXJnZXRCbG9jaywgdGFyZ2V0UGF0aF0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIFtvcC5wYXRoWzBdIC0gMV0pO1xuICAgICAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKHRhcmdldEJsb2NrKSkge1xuICAgICAgICAgIGNvbnN0IG9sZERlZnMgPSBBcnJheS5pc0FycmF5KHRhcmdldEJsb2NrLm1hcmtEZWZzKSAmJiB0YXJnZXRCbG9jay5tYXJrRGVmcyB8fCBbXSwgbmV3TWFya0RlZnMgPSB1bmlxKFsuLi5vbGREZWZzLCAuLi5vcC5wcm9wZXJ0aWVzLm1hcmtEZWZzXSk7XG4gICAgICAgICAgZGVidWckYyhcIkNvcHlpbmcgbWFya0RlZnMgb3ZlciB0byBtZXJnZWQgYmxvY2tcIiwgb3ApLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgbWFya0RlZnM6IG5ld01hcmtEZWZzXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFBhdGgsXG4gICAgICAgICAgICB2b2lkczogITFcbiAgICAgICAgICB9KSwgYXBwbHkyKG9wKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFwcGx5MihvcCk7XG4gICAgfSwgZWRpdG9yO1xuICB9O1xufVxuY29uc3QgcmVtb3ZlRGVjb3JhdG9yT3BlcmF0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBvcGVyYXRpb25cbn0pID0+IHtcbiAgY29uc3QgZWRpdG9yID0gb3BlcmF0aW9uLmVkaXRvciwgbWFyayA9IG9wZXJhdGlvbi5kZWNvcmF0b3IsIHtcbiAgICBzZWxlY3Rpb25cbiAgfSA9IGVkaXRvcjtcbiAgaWYgKHNlbGVjdGlvbikge1xuICAgIGlmIChSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpXG4gICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge30sIHtcbiAgICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0LFxuICAgICAgICBzcGxpdDogITAsXG4gICAgICAgIGhhbmdpbmc6ICEwXG4gICAgICB9KSwgZWRpdG9yLnNlbGVjdGlvbiAmJiBbLi4uRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0XG4gICAgICB9KV0uZm9yRWFjaCgoW25vZGUsIHBhdGhdKSA9PiB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gZWRpdG9yLmNoaWxkcmVuW3BhdGhbMF1dO1xuICAgICAgICBFbGVtZW50JDEuaXNFbGVtZW50KGJsb2NrKSAmJiBibG9jay5jaGlsZHJlbi5pbmNsdWRlcyhub2RlKSAmJiBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIG1hcmtzOiAoQXJyYXkuaXNBcnJheShub2RlLm1hcmtzKSA/IG5vZGUubWFya3MgOiBbXSkuZmlsdGVyKChlTWFyaykgPT4gZU1hcmsgIT09IG1hcmspLFxuICAgICAgICAgIF90eXBlOiBcInNwYW5cIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IFtibG9jaywgYmxvY2tQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgc2VsZWN0aW9uLCB7XG4gICAgICAgIGRlcHRoOiAxXG4gICAgICB9KSwgbG9uZWx5RW1wdHlTcGFuID0gZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSAmJiBibG9jay5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgZWRpdG9yLmlzVGV4dFNwYW4oYmxvY2suY2hpbGRyZW5bMF0pICYmIGJsb2NrLmNoaWxkcmVuWzBdLnRleHQgPT09IFwiXCIgPyBibG9jay5jaGlsZHJlblswXSA6IHZvaWQgMDtcbiAgICAgIGlmIChsb25lbHlFbXB0eVNwYW4pIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdNYXJrc1dpdGhvdXREZWNvcmF0b3IgPSAobG9uZWx5RW1wdHlTcGFuLm1hcmtzID8/IFtdKS5maWx0ZXIoKGV4aXN0aW5nTWFyaykgPT4gZXhpc3RpbmdNYXJrICE9PSBtYXJrKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBtYXJrczogZXhpc3RpbmdNYXJrc1dpdGhvdXREZWNvcmF0b3JcbiAgICAgICAgfSwge1xuICAgICAgICAgIGF0OiBibG9ja1BhdGgsXG4gICAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBlZGl0b3IuaXNUZXh0U3Bhbihub2RlKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBlZGl0b3IuZGVjb3JhdG9yU3RhdGVbbWFya10gPSAhMTtcbiAgICB9XG4gICAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbjIgPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbiA9IHtcbiAgICAgICAgLi4uc2VsZWN0aW9uMlxuICAgICAgfTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBjbG9uZURpZmYoZGlmZjIpIHtcbiAgY29uc3QgW3R5cGUsIHBhdGNoXSA9IGRpZmYyO1xuICByZXR1cm4gW3R5cGUsIHBhdGNoXTtcbn1cbmZ1bmN0aW9uIGdldENvbW1vbk92ZXJsYXAodGV4dEEsIHRleHRCKSB7XG4gIGxldCB0ZXh0MSA9IHRleHRBLCB0ZXh0MiA9IHRleHRCO1xuICBjb25zdCB0ZXh0MUxlbmd0aCA9IHRleHQxLmxlbmd0aCwgdGV4dDJMZW5ndGggPSB0ZXh0Mi5sZW5ndGg7XG4gIGlmICh0ZXh0MUxlbmd0aCA9PT0gMCB8fCB0ZXh0Mkxlbmd0aCA9PT0gMCkgcmV0dXJuIDA7XG4gIHRleHQxTGVuZ3RoID4gdGV4dDJMZW5ndGggPyB0ZXh0MSA9IHRleHQxLnN1YnN0cmluZyh0ZXh0MUxlbmd0aCAtIHRleHQyTGVuZ3RoKSA6IHRleHQxTGVuZ3RoIDwgdGV4dDJMZW5ndGggJiYgKHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKDAsIHRleHQxTGVuZ3RoKSk7XG4gIGNvbnN0IHRleHRMZW5ndGggPSBNYXRoLm1pbih0ZXh0MUxlbmd0aCwgdGV4dDJMZW5ndGgpO1xuICBpZiAodGV4dDEgPT09IHRleHQyKSByZXR1cm4gdGV4dExlbmd0aDtcbiAgbGV0IGJlc3QgPSAwLCBsZW5ndGggPSAxO1xuICBmb3IgKGxldCBmb3VuZCA9IDA7IGZvdW5kICE9PSAtMTsgKSB7XG4gICAgY29uc3QgcGF0dGVybiA9IHRleHQxLnN1YnN0cmluZyh0ZXh0TGVuZ3RoIC0gbGVuZ3RoKTtcbiAgICBpZiAoZm91bmQgPSB0ZXh0Mi5pbmRleE9mKHBhdHRlcm4pLCBmb3VuZCA9PT0gLTEpIHJldHVybiBiZXN0O1xuICAgIGxlbmd0aCArPSBmb3VuZCwgKGZvdW5kID09PSAwIHx8IHRleHQxLnN1YnN0cmluZyh0ZXh0TGVuZ3RoIC0gbGVuZ3RoKSA9PT0gdGV4dDIuc3Vic3RyaW5nKDAsIGxlbmd0aCkpICYmIChiZXN0ID0gbGVuZ3RoLCBsZW5ndGgrKyk7XG4gIH1cbiAgcmV0dXJuIGJlc3Q7XG59XG5mdW5jdGlvbiBnZXRDb21tb25QcmVmaXgodGV4dDEsIHRleHQyKSB7XG4gIGlmICghdGV4dDEgfHwgIXRleHQyIHx8IHRleHQxWzBdICE9PSB0ZXh0MlswXSkgcmV0dXJuIDA7XG4gIGxldCBwb2ludGVyTWluID0gMCwgcG9pbnRlck1heCA9IE1hdGgubWluKHRleHQxLmxlbmd0aCwgdGV4dDIubGVuZ3RoKSwgcG9pbnRlck1pZCA9IHBvaW50ZXJNYXgsIHBvaW50ZXJTdGFydCA9IDA7XG4gIGZvciAoOyBwb2ludGVyTWluIDwgcG9pbnRlck1pZDsgKSB0ZXh0MS5zdWJzdHJpbmcocG9pbnRlclN0YXJ0LCBwb2ludGVyTWlkKSA9PT0gdGV4dDIuc3Vic3RyaW5nKHBvaW50ZXJTdGFydCwgcG9pbnRlck1pZCkgPyAocG9pbnRlck1pbiA9IHBvaW50ZXJNaWQsIHBvaW50ZXJTdGFydCA9IHBvaW50ZXJNaW4pIDogcG9pbnRlck1heCA9IHBvaW50ZXJNaWQsIHBvaW50ZXJNaWQgPSBNYXRoLmZsb29yKChwb2ludGVyTWF4IC0gcG9pbnRlck1pbikgLyAyICsgcG9pbnRlck1pbik7XG4gIHJldHVybiBwb2ludGVyTWlkO1xufVxuZnVuY3Rpb24gZ2V0Q29tbW9uU3VmZml4KHRleHQxLCB0ZXh0Mikge1xuICBpZiAoIXRleHQxIHx8ICF0ZXh0MiB8fCB0ZXh0MVt0ZXh0MS5sZW5ndGggLSAxXSAhPT0gdGV4dDJbdGV4dDIubGVuZ3RoIC0gMV0pIHJldHVybiAwO1xuICBsZXQgcG9pbnRlck1pbiA9IDAsIHBvaW50ZXJNYXggPSBNYXRoLm1pbih0ZXh0MS5sZW5ndGgsIHRleHQyLmxlbmd0aCksIHBvaW50ZXJNaWQgPSBwb2ludGVyTWF4LCBwb2ludGVyRW5kID0gMDtcbiAgZm9yICg7IHBvaW50ZXJNaW4gPCBwb2ludGVyTWlkOyApIHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSBwb2ludGVyTWlkLCB0ZXh0MS5sZW5ndGggLSBwb2ludGVyRW5kKSA9PT0gdGV4dDIuc3Vic3RyaW5nKHRleHQyLmxlbmd0aCAtIHBvaW50ZXJNaWQsIHRleHQyLmxlbmd0aCAtIHBvaW50ZXJFbmQpID8gKHBvaW50ZXJNaW4gPSBwb2ludGVyTWlkLCBwb2ludGVyRW5kID0gcG9pbnRlck1pbikgOiBwb2ludGVyTWF4ID0gcG9pbnRlck1pZCwgcG9pbnRlck1pZCA9IE1hdGguZmxvb3IoKHBvaW50ZXJNYXggLSBwb2ludGVyTWluKSAvIDIgKyBwb2ludGVyTWluKTtcbiAgcmV0dXJuIHBvaW50ZXJNaWQ7XG59XG5mdW5jdGlvbiBpc0hpZ2hTdXJyb2dhdGUoY2hhcikge1xuICBjb25zdCBjaGFyQ29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGNoYXJDb2RlID49IDU1Mjk2ICYmIGNoYXJDb2RlIDw9IDU2MzE5O1xufVxuZnVuY3Rpb24gaXNMb3dTdXJyb2dhdGUoY2hhcikge1xuICBjb25zdCBjaGFyQ29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGNoYXJDb2RlID49IDU2MzIwICYmIGNoYXJDb2RlIDw9IDU3MzQzO1xufVxuZnVuY3Rpb24gYmlzZWN0KHRleHQxLCB0ZXh0MiwgZGVhZGxpbmUpIHtcbiAgY29uc3QgdGV4dDFMZW5ndGggPSB0ZXh0MS5sZW5ndGgsIHRleHQyTGVuZ3RoID0gdGV4dDIubGVuZ3RoLCBtYXhEID0gTWF0aC5jZWlsKCh0ZXh0MUxlbmd0aCArIHRleHQyTGVuZ3RoKSAvIDIpLCB2T2Zmc2V0ID0gbWF4RCwgdkxlbmd0aCA9IDIgKiBtYXhELCB2MSA9IG5ldyBBcnJheSh2TGVuZ3RoKSwgdjIgPSBuZXcgQXJyYXkodkxlbmd0aCk7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgdkxlbmd0aDsgeCsrKSB2MVt4XSA9IC0xLCB2Mlt4XSA9IC0xO1xuICB2MVt2T2Zmc2V0ICsgMV0gPSAwLCB2Mlt2T2Zmc2V0ICsgMV0gPSAwO1xuICBjb25zdCBkZWx0YSA9IHRleHQxTGVuZ3RoIC0gdGV4dDJMZW5ndGgsIGZyb250ID0gZGVsdGEgJSAyICE9PSAwO1xuICBsZXQgazFzdGFydCA9IDAsIGsxZW5kID0gMCwgazJzdGFydCA9IDAsIGsyZW5kID0gMDtcbiAgZm9yIChsZXQgZCA9IDA7IGQgPCBtYXhEICYmICEoRGF0ZS5ub3coKSA+IGRlYWRsaW5lKTsgZCsrKSB7XG4gICAgZm9yIChsZXQgazEgPSAtZCArIGsxc3RhcnQ7IGsxIDw9IGQgLSBrMWVuZDsgazEgKz0gMikge1xuICAgICAgY29uc3QgazFPZmZzZXQgPSB2T2Zmc2V0ICsgazE7XG4gICAgICBsZXQgeDE7XG4gICAgICBrMSA9PT0gLWQgfHwgazEgIT09IGQgJiYgdjFbazFPZmZzZXQgLSAxXSA8IHYxW2sxT2Zmc2V0ICsgMV0gPyB4MSA9IHYxW2sxT2Zmc2V0ICsgMV0gOiB4MSA9IHYxW2sxT2Zmc2V0IC0gMV0gKyAxO1xuICAgICAgbGV0IHkxID0geDEgLSBrMTtcbiAgICAgIGZvciAoOyB4MSA8IHRleHQxTGVuZ3RoICYmIHkxIDwgdGV4dDJMZW5ndGggJiYgdGV4dDEuY2hhckF0KHgxKSA9PT0gdGV4dDIuY2hhckF0KHkxKTsgKSB4MSsrLCB5MSsrO1xuICAgICAgaWYgKHYxW2sxT2Zmc2V0XSA9IHgxLCB4MSA+IHRleHQxTGVuZ3RoKSBrMWVuZCArPSAyO1xuICAgICAgZWxzZSBpZiAoeTEgPiB0ZXh0Mkxlbmd0aCkgazFzdGFydCArPSAyO1xuICAgICAgZWxzZSBpZiAoZnJvbnQpIHtcbiAgICAgICAgY29uc3QgazJPZmZzZXQgPSB2T2Zmc2V0ICsgZGVsdGEgLSBrMTtcbiAgICAgICAgaWYgKGsyT2Zmc2V0ID49IDAgJiYgazJPZmZzZXQgPCB2TGVuZ3RoICYmIHYyW2syT2Zmc2V0XSAhPT0gLTEpIHtcbiAgICAgICAgICBjb25zdCB4MiA9IHRleHQxTGVuZ3RoIC0gdjJbazJPZmZzZXRdO1xuICAgICAgICAgIGlmICh4MSA+PSB4MikgcmV0dXJuIGJpc2VjdFNwbGl0KHRleHQxLCB0ZXh0MiwgeDEsIHkxLCBkZWFkbGluZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgazIgPSAtZCArIGsyc3RhcnQ7IGsyIDw9IGQgLSBrMmVuZDsgazIgKz0gMikge1xuICAgICAgY29uc3QgazJPZmZzZXQgPSB2T2Zmc2V0ICsgazI7XG4gICAgICBsZXQgeDI7XG4gICAgICBrMiA9PT0gLWQgfHwgazIgIT09IGQgJiYgdjJbazJPZmZzZXQgLSAxXSA8IHYyW2syT2Zmc2V0ICsgMV0gPyB4MiA9IHYyW2syT2Zmc2V0ICsgMV0gOiB4MiA9IHYyW2syT2Zmc2V0IC0gMV0gKyAxO1xuICAgICAgbGV0IHkyID0geDIgLSBrMjtcbiAgICAgIGZvciAoOyB4MiA8IHRleHQxTGVuZ3RoICYmIHkyIDwgdGV4dDJMZW5ndGggJiYgdGV4dDEuY2hhckF0KHRleHQxTGVuZ3RoIC0geDIgLSAxKSA9PT0gdGV4dDIuY2hhckF0KHRleHQyTGVuZ3RoIC0geTIgLSAxKTsgKSB4MisrLCB5MisrO1xuICAgICAgaWYgKHYyW2syT2Zmc2V0XSA9IHgyLCB4MiA+IHRleHQxTGVuZ3RoKSBrMmVuZCArPSAyO1xuICAgICAgZWxzZSBpZiAoeTIgPiB0ZXh0Mkxlbmd0aCkgazJzdGFydCArPSAyO1xuICAgICAgZWxzZSBpZiAoIWZyb250KSB7XG4gICAgICAgIGNvbnN0IGsxT2Zmc2V0ID0gdk9mZnNldCArIGRlbHRhIC0gazI7XG4gICAgICAgIGlmIChrMU9mZnNldCA+PSAwICYmIGsxT2Zmc2V0IDwgdkxlbmd0aCAmJiB2MVtrMU9mZnNldF0gIT09IC0xKSB7XG4gICAgICAgICAgY29uc3QgeDEgPSB2MVtrMU9mZnNldF0sIHkxID0gdk9mZnNldCArIHgxIC0gazFPZmZzZXQ7XG4gICAgICAgICAgaWYgKHgyID0gdGV4dDFMZW5ndGggLSB4MiwgeDEgPj0geDIpIHJldHVybiBiaXNlY3RTcGxpdCh0ZXh0MSwgdGV4dDIsIHgxLCB5MSwgZGVhZGxpbmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbW0RJRkZfREVMRVRFLCB0ZXh0MV0sIFtESUZGX0lOU0VSVCwgdGV4dDJdXTtcbn1cbmZ1bmN0aW9uIGJpc2VjdFNwbGl0KHRleHQxLCB0ZXh0MiwgeCwgeSwgZGVhZGxpbmUpIHtcbiAgY29uc3QgdGV4dDFhID0gdGV4dDEuc3Vic3RyaW5nKDAsIHgpLCB0ZXh0MmEgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgeSksIHRleHQxYiA9IHRleHQxLnN1YnN0cmluZyh4KSwgdGV4dDJiID0gdGV4dDIuc3Vic3RyaW5nKHkpLCBkaWZmcyA9IGRvRGlmZih0ZXh0MWEsIHRleHQyYSwge1xuICAgIGNoZWNrTGluZXM6ICExLFxuICAgIGRlYWRsaW5lXG4gIH0pLCBkaWZmc2IgPSBkb0RpZmYodGV4dDFiLCB0ZXh0MmIsIHtcbiAgICBjaGVja0xpbmVzOiAhMSxcbiAgICBkZWFkbGluZVxuICB9KTtcbiAgcmV0dXJuIGRpZmZzLmNvbmNhdChkaWZmc2IpO1xufVxuZnVuY3Rpb24gZmluZEhhbGZNYXRjaCh0ZXh0MSwgdGV4dDIsIHRpbWVvdXQgPSAxKSB7XG4gIGlmICh0aW1lb3V0IDw9IDApIHJldHVybiBudWxsO1xuICBjb25zdCBsb25nVGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQxIDogdGV4dDIsIHNob3J0VGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQyIDogdGV4dDE7XG4gIGlmIChsb25nVGV4dC5sZW5ndGggPCA0IHx8IHNob3J0VGV4dC5sZW5ndGggKiAyIDwgbG9uZ1RleHQubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgaGFsZk1hdGNoMSA9IGhhbGZNYXRjaEkobG9uZ1RleHQsIHNob3J0VGV4dCwgTWF0aC5jZWlsKGxvbmdUZXh0Lmxlbmd0aCAvIDQpKSwgaGFsZk1hdGNoMiA9IGhhbGZNYXRjaEkobG9uZ1RleHQsIHNob3J0VGV4dCwgTWF0aC5jZWlsKGxvbmdUZXh0Lmxlbmd0aCAvIDIpKTtcbiAgbGV0IGhhbGZNYXRjaDtcbiAgaWYgKGhhbGZNYXRjaDEgJiYgaGFsZk1hdGNoMikgaGFsZk1hdGNoID0gaGFsZk1hdGNoMVs0XS5sZW5ndGggPiBoYWxmTWF0Y2gyWzRdLmxlbmd0aCA/IGhhbGZNYXRjaDEgOiBoYWxmTWF0Y2gyO1xuICBlbHNlIHtcbiAgICBpZiAoIWhhbGZNYXRjaDEgJiYgIWhhbGZNYXRjaDIpIHJldHVybiBudWxsO1xuICAgIGhhbGZNYXRjaDIgPyBoYWxmTWF0Y2gxIHx8IChoYWxmTWF0Y2ggPSBoYWxmTWF0Y2gyKSA6IGhhbGZNYXRjaCA9IGhhbGZNYXRjaDE7XG4gIH1cbiAgaWYgKCFoYWxmTWF0Y2gpIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIGEgaGFsZiBtYXRjaC5cIik7XG4gIGxldCB0ZXh0MUEsIHRleHQxQiwgdGV4dDJBLCB0ZXh0MkI7XG4gIHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/ICh0ZXh0MUEgPSBoYWxmTWF0Y2hbMF0sIHRleHQxQiA9IGhhbGZNYXRjaFsxXSwgdGV4dDJBID0gaGFsZk1hdGNoWzJdLCB0ZXh0MkIgPSBoYWxmTWF0Y2hbM10pIDogKHRleHQyQSA9IGhhbGZNYXRjaFswXSwgdGV4dDJCID0gaGFsZk1hdGNoWzFdLCB0ZXh0MUEgPSBoYWxmTWF0Y2hbMl0sIHRleHQxQiA9IGhhbGZNYXRjaFszXSk7XG4gIGNvbnN0IG1pZENvbW1vbiA9IGhhbGZNYXRjaFs0XTtcbiAgcmV0dXJuIFt0ZXh0MUEsIHRleHQxQiwgdGV4dDJBLCB0ZXh0MkIsIG1pZENvbW1vbl07XG59XG5mdW5jdGlvbiBoYWxmTWF0Y2hJKGxvbmdUZXh0LCBzaG9ydFRleHQsIGkpIHtcbiAgY29uc3Qgc2VlZCA9IGxvbmdUZXh0LnNsaWNlKGksIGkgKyBNYXRoLmZsb29yKGxvbmdUZXh0Lmxlbmd0aCAvIDQpKTtcbiAgbGV0IGogPSAtMSwgYmVzdENvbW1vbiA9IFwiXCIsIGJlc3RMb25nVGV4dEEsIGJlc3RMb25nVGV4dEIsIGJlc3RTaG9ydFRleHRBLCBiZXN0U2hvcnRUZXh0QjtcbiAgZm9yICg7IChqID0gc2hvcnRUZXh0LmluZGV4T2Yoc2VlZCwgaiArIDEpKSAhPT0gLTE7ICkge1xuICAgIGNvbnN0IHByZWZpeExlbmd0aCA9IGdldENvbW1vblByZWZpeChsb25nVGV4dC5zbGljZShpKSwgc2hvcnRUZXh0LnNsaWNlKGopKSwgc3VmZml4TGVuZ3RoID0gZ2V0Q29tbW9uU3VmZml4KGxvbmdUZXh0LnNsaWNlKDAsIGkpLCBzaG9ydFRleHQuc2xpY2UoMCwgaikpO1xuICAgIGJlc3RDb21tb24ubGVuZ3RoIDwgc3VmZml4TGVuZ3RoICsgcHJlZml4TGVuZ3RoICYmIChiZXN0Q29tbW9uID0gc2hvcnRUZXh0LnNsaWNlKGogLSBzdWZmaXhMZW5ndGgsIGopICsgc2hvcnRUZXh0LnNsaWNlKGosIGogKyBwcmVmaXhMZW5ndGgpLCBiZXN0TG9uZ1RleHRBID0gbG9uZ1RleHQuc2xpY2UoMCwgaSAtIHN1ZmZpeExlbmd0aCksIGJlc3RMb25nVGV4dEIgPSBsb25nVGV4dC5zbGljZShpICsgcHJlZml4TGVuZ3RoKSwgYmVzdFNob3J0VGV4dEEgPSBzaG9ydFRleHQuc2xpY2UoMCwgaiAtIHN1ZmZpeExlbmd0aCksIGJlc3RTaG9ydFRleHRCID0gc2hvcnRUZXh0LnNsaWNlKGogKyBwcmVmaXhMZW5ndGgpKTtcbiAgfVxuICByZXR1cm4gYmVzdENvbW1vbi5sZW5ndGggKiAyID49IGxvbmdUZXh0Lmxlbmd0aCA/IFtiZXN0TG9uZ1RleHRBIHx8IFwiXCIsIGJlc3RMb25nVGV4dEIgfHwgXCJcIiwgYmVzdFNob3J0VGV4dEEgfHwgXCJcIiwgYmVzdFNob3J0VGV4dEIgfHwgXCJcIiwgYmVzdENvbW1vbiB8fCBcIlwiXSA6IG51bGw7XG59XG5mdW5jdGlvbiBjaGFyc1RvTGluZXMoZGlmZnMsIGxpbmVBcnJheSkge1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgY29uc3QgY2hhcnMgPSBkaWZmc1t4XVsxXSwgdGV4dCA9IFtdO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgY2hhcnMubGVuZ3RoOyB5KyspIHRleHRbeV0gPSBsaW5lQXJyYXlbY2hhcnMuY2hhckNvZGVBdCh5KV07XG4gICAgZGlmZnNbeF1bMV0gPSB0ZXh0LmpvaW4oXCJcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGxpbmVzVG9DaGFycyh0ZXh0QSwgdGV4dEIpIHtcbiAgY29uc3QgbGluZUFycmF5ID0gW10sIGxpbmVIYXNoID0ge307XG4gIGxpbmVBcnJheVswXSA9IFwiXCI7XG4gIGZ1bmN0aW9uIGRpZmZMaW5lc1RvTXVuZ2UodGV4dCkge1xuICAgIGxldCBjaGFycyA9IFwiXCIsIGxpbmVTdGFydCA9IDAsIGxpbmVFbmQgPSAtMSwgbGluZUFycmF5TGVuZ3RoID0gbGluZUFycmF5Lmxlbmd0aDtcbiAgICBmb3IgKDsgbGluZUVuZCA8IHRleHQubGVuZ3RoIC0gMTsgKSB7XG4gICAgICBsaW5lRW5kID0gdGV4dC5pbmRleE9mKGBcbmAsIGxpbmVTdGFydCksIGxpbmVFbmQgPT09IC0xICYmIChsaW5lRW5kID0gdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIGxldCBsaW5lID0gdGV4dC5zbGljZShsaW5lU3RhcnQsIGxpbmVFbmQgKyAxKTtcbiAgICAgIChsaW5lSGFzaC5oYXNPd25Qcm9wZXJ0eSA/IGxpbmVIYXNoLmhhc093blByb3BlcnR5KGxpbmUpIDogbGluZUhhc2hbbGluZV0gIT09IHZvaWQgMCkgPyBjaGFycyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxpbmVIYXNoW2xpbmVdKSA6IChsaW5lQXJyYXlMZW5ndGggPT09IG1heExpbmVzICYmIChsaW5lID0gdGV4dC5zbGljZShsaW5lU3RhcnQpLCBsaW5lRW5kID0gdGV4dC5sZW5ndGgpLCBjaGFycyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxpbmVBcnJheUxlbmd0aCksIGxpbmVIYXNoW2xpbmVdID0gbGluZUFycmF5TGVuZ3RoLCBsaW5lQXJyYXlbbGluZUFycmF5TGVuZ3RoKytdID0gbGluZSksIGxpbmVTdGFydCA9IGxpbmVFbmQgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH1cbiAgbGV0IG1heExpbmVzID0gNGU0O1xuICBjb25zdCBjaGFyczEgPSBkaWZmTGluZXNUb011bmdlKHRleHRBKTtcbiAgbWF4TGluZXMgPSA2NTUzNTtcbiAgY29uc3QgY2hhcnMyID0gZGlmZkxpbmVzVG9NdW5nZSh0ZXh0Qik7XG4gIHJldHVybiB7XG4gICAgY2hhcnMxLFxuICAgIGNoYXJzMixcbiAgICBsaW5lQXJyYXlcbiAgfTtcbn1cbmZ1bmN0aW9uIGRvTGluZU1vZGVEaWZmKHRleHRBLCB0ZXh0Qiwgb3B0cykge1xuICBsZXQgdGV4dDEgPSB0ZXh0QSwgdGV4dDIgPSB0ZXh0QjtcbiAgY29uc3QgYSA9IGxpbmVzVG9DaGFycyh0ZXh0MSwgdGV4dDIpO1xuICB0ZXh0MSA9IGEuY2hhcnMxLCB0ZXh0MiA9IGEuY2hhcnMyO1xuICBjb25zdCBsaW5lYXJyYXkgPSBhLmxpbmVBcnJheTtcbiAgbGV0IGRpZmZzID0gZG9EaWZmKHRleHQxLCB0ZXh0Miwge1xuICAgIGNoZWNrTGluZXM6ICExLFxuICAgIGRlYWRsaW5lOiBvcHRzLmRlYWRsaW5lXG4gIH0pO1xuICBjaGFyc1RvTGluZXMoZGlmZnMsIGxpbmVhcnJheSksIGRpZmZzID0gY2xlYW51cFNlbWFudGljKGRpZmZzKSwgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgXCJcIl0pO1xuICBsZXQgcG9pbnRlciA9IDAsIGNvdW50RGVsZXRlID0gMCwgY291bnRJbnNlcnQgPSAwLCB0ZXh0RGVsZXRlID0gXCJcIiwgdGV4dEluc2VydCA9IFwiXCI7XG4gIGZvciAoOyBwb2ludGVyIDwgZGlmZnMubGVuZ3RoOyApIHtcbiAgICBzd2l0Y2ggKGRpZmZzW3BvaW50ZXJdWzBdKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBjb3VudEluc2VydCsrLCB0ZXh0SW5zZXJ0ICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIGNvdW50RGVsZXRlKyssIHRleHREZWxldGUgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICBpZiAoY291bnREZWxldGUgPj0gMSAmJiBjb3VudEluc2VydCA+PSAxKSB7XG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSBjb3VudERlbGV0ZSAtIGNvdW50SW5zZXJ0LCBjb3VudERlbGV0ZSArIGNvdW50SW5zZXJ0KSwgcG9pbnRlciA9IHBvaW50ZXIgLSBjb3VudERlbGV0ZSAtIGNvdW50SW5zZXJ0O1xuICAgICAgICAgIGNvbnN0IGFhID0gZG9EaWZmKHRleHREZWxldGUsIHRleHRJbnNlcnQsIHtcbiAgICAgICAgICAgIGNoZWNrTGluZXM6ICExLFxuICAgICAgICAgICAgZGVhZGxpbmU6IG9wdHMuZGVhZGxpbmVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gYWEubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBhYVtqXSk7XG4gICAgICAgICAgcG9pbnRlciArPSBhYS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY291bnRJbnNlcnQgPSAwLCBjb3VudERlbGV0ZSA9IDAsIHRleHREZWxldGUgPSBcIlwiLCB0ZXh0SW5zZXJ0ID0gXCJcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRpZmYgb3BlcmF0aW9uLlwiKTtcbiAgICB9XG4gICAgcG9pbnRlcisrO1xuICB9XG4gIHJldHVybiBkaWZmcy5wb3AoKSwgZGlmZnM7XG59XG5mdW5jdGlvbiBjb21wdXRlRGlmZih0ZXh0MSwgdGV4dDIsIG9wdHMpIHtcbiAgbGV0IGRpZmZzO1xuICBpZiAoIXRleHQxKSByZXR1cm4gW1tESUZGX0lOU0VSVCwgdGV4dDJdXTtcbiAgaWYgKCF0ZXh0MikgcmV0dXJuIFtbRElGRl9ERUxFVEUsIHRleHQxXV07XG4gIGNvbnN0IGxvbmd0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDEgOiB0ZXh0Miwgc2hvcnR0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDIgOiB0ZXh0MSwgaSA9IGxvbmd0ZXh0LmluZGV4T2Yoc2hvcnR0ZXh0KTtcbiAgaWYgKGkgIT09IC0xKSByZXR1cm4gZGlmZnMgPSBbW0RJRkZfSU5TRVJULCBsb25ndGV4dC5zdWJzdHJpbmcoMCwgaSldLCBbRElGRl9FUVVBTCwgc2hvcnR0ZXh0XSwgW0RJRkZfSU5TRVJULCBsb25ndGV4dC5zdWJzdHJpbmcoaSArIHNob3J0dGV4dC5sZW5ndGgpXV0sIHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCAmJiAoZGlmZnNbMF1bMF0gPSBESUZGX0RFTEVURSwgZGlmZnNbMl1bMF0gPSBESUZGX0RFTEVURSksIGRpZmZzO1xuICBpZiAoc2hvcnR0ZXh0Lmxlbmd0aCA9PT0gMSkgcmV0dXJuIFtbRElGRl9ERUxFVEUsIHRleHQxXSwgW0RJRkZfSU5TRVJULCB0ZXh0Ml1dO1xuICBjb25zdCBoYWxmTWF0Y2ggPSBmaW5kSGFsZk1hdGNoKHRleHQxLCB0ZXh0Mik7XG4gIGlmIChoYWxmTWF0Y2gpIHtcbiAgICBjb25zdCB0ZXh0MUEgPSBoYWxmTWF0Y2hbMF0sIHRleHQxQiA9IGhhbGZNYXRjaFsxXSwgdGV4dDJBID0gaGFsZk1hdGNoWzJdLCB0ZXh0MkIgPSBoYWxmTWF0Y2hbM10sIG1pZENvbW1vbiA9IGhhbGZNYXRjaFs0XSwgZGlmZnNBID0gZG9EaWZmKHRleHQxQSwgdGV4dDJBLCBvcHRzKSwgZGlmZnNCID0gZG9EaWZmKHRleHQxQiwgdGV4dDJCLCBvcHRzKTtcbiAgICByZXR1cm4gZGlmZnNBLmNvbmNhdChbW0RJRkZfRVFVQUwsIG1pZENvbW1vbl1dLCBkaWZmc0IpO1xuICB9XG4gIHJldHVybiBvcHRzLmNoZWNrTGluZXMgJiYgdGV4dDEubGVuZ3RoID4gMTAwICYmIHRleHQyLmxlbmd0aCA+IDEwMCA/IGRvTGluZU1vZGVEaWZmKHRleHQxLCB0ZXh0Miwgb3B0cykgOiBiaXNlY3QodGV4dDEsIHRleHQyLCBvcHRzLmRlYWRsaW5lKTtcbn1cbnZhciBfX2RlZlByb3AkMiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgX19nZXRPd25Qcm9wU3ltYm9scyQyID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgX19oYXNPd25Qcm9wJDIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBfX3Byb3BJc0VudW0kMiA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUsIF9fZGVmTm9ybWFsUHJvcCQyID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQyKG9iaiwga2V5LCB7XG4gIGVudW1lcmFibGU6ICEwLFxuICBjb25maWd1cmFibGU6ICEwLFxuICB3cml0YWJsZTogITAsXG4gIHZhbHVlXG59KSA6IG9ialtrZXldID0gdmFsdWUsIF9fc3ByZWFkVmFsdWVzJDIgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpIF9faGFzT3duUHJvcCQyLmNhbGwoYiwgcHJvcCkgJiYgX19kZWZOb3JtYWxQcm9wJDIoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzJDIpIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyQyKGIpKSBfX3Byb3BJc0VudW0kMi5jYWxsKGIsIHByb3ApICYmIF9fZGVmTm9ybWFsUHJvcCQyKGEsIHByb3AsIGJbcHJvcF0pO1xuICByZXR1cm4gYTtcbn07XG5jb25zdCBESUZGX0RFTEVURSA9IC0xLCBESUZGX0lOU0VSVCA9IDEsIERJRkZfRVFVQUwgPSAwO1xuZnVuY3Rpb24gZGlmZih0ZXh0QSwgdGV4dEIsIG9wdHMpIHtcbiAgaWYgKHRleHRBID09PSBudWxsIHx8IHRleHRCID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJOdWxsIGlucHV0LiAoZGlmZilcIik7XG4gIGNvbnN0IGRpZmZzID0gZG9EaWZmKHRleHRBLCB0ZXh0QiwgY3JlYXRlSW50ZXJuYWxPcHRzKG9wdHMgfHwge30pKTtcbiAgcmV0dXJuIGFkanVzdERpZmZGb3JTdXJyb2dhdGVQYWlycyhkaWZmcyksIGRpZmZzO1xufVxuZnVuY3Rpb24gZG9EaWZmKHRleHRBLCB0ZXh0Qiwgb3B0aW9ucykge1xuICBsZXQgdGV4dDEgPSB0ZXh0QSwgdGV4dDIgPSB0ZXh0QjtcbiAgaWYgKHRleHQxID09PSB0ZXh0MikgcmV0dXJuIHRleHQxID8gW1tESUZGX0VRVUFMLCB0ZXh0MV1dIDogW107XG4gIGxldCBjb21tb25sZW5ndGggPSBnZXRDb21tb25QcmVmaXgodGV4dDEsIHRleHQyKTtcbiAgY29uc3QgY29tbW9ucHJlZml4ID0gdGV4dDEuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCk7XG4gIHRleHQxID0gdGV4dDEuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCksIHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCksIGNvbW1vbmxlbmd0aCA9IGdldENvbW1vblN1ZmZpeCh0ZXh0MSwgdGV4dDIpO1xuICBjb25zdCBjb21tb25zdWZmaXggPSB0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcoMCwgdGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKSwgdGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgdGV4dDIubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgbGV0IGRpZmZzID0gY29tcHV0ZURpZmYodGV4dDEsIHRleHQyLCBvcHRpb25zKTtcbiAgcmV0dXJuIGNvbW1vbnByZWZpeCAmJiBkaWZmcy51bnNoaWZ0KFtESUZGX0VRVUFMLCBjb21tb25wcmVmaXhdKSwgY29tbW9uc3VmZml4ICYmIGRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIGNvbW1vbnN1ZmZpeF0pLCBkaWZmcyA9IGNsZWFudXBNZXJnZShkaWZmcyksIGRpZmZzO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVhZExpbmUodGltZW91dCkge1xuICBsZXQgdCA9IDE7XG4gIHJldHVybiB0eXBlb2YgdGltZW91dCA8IFwidVwiICYmICh0ID0gdGltZW91dCA8PSAwID8gTnVtYmVyLk1BWF9WQUxVRSA6IHRpbWVvdXQpLCBEYXRlLm5vdygpICsgdCAqIDFlMztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUludGVybmFsT3B0cyhvcHRzKSB7XG4gIHJldHVybiBfX3NwcmVhZFZhbHVlcyQyKHtcbiAgICBjaGVja0xpbmVzOiAhMCxcbiAgICBkZWFkbGluZTogY3JlYXRlRGVhZExpbmUob3B0cy50aW1lb3V0IHx8IDEpXG4gIH0sIG9wdHMpO1xufVxuZnVuY3Rpb24gY29tYmluZUNoYXIoZGF0YSwgY2hhciwgZGlyKSB7XG4gIHJldHVybiBkaXIgPT09IDEgPyBkYXRhICsgY2hhciA6IGNoYXIgKyBkYXRhO1xufVxuZnVuY3Rpb24gc3BsaXRDaGFyKGRhdGEsIGRpcikge1xuICByZXR1cm4gZGlyID09PSAxID8gW2RhdGEuc3Vic3RyaW5nKDAsIGRhdGEubGVuZ3RoIC0gMSksIGRhdGFbZGF0YS5sZW5ndGggLSAxXV0gOiBbZGF0YS5zdWJzdHJpbmcoMSksIGRhdGFbMF1dO1xufVxuZnVuY3Rpb24gaGFzU2hhcmVkQ2hhcihkaWZmcywgaSwgaiwgZGlyKSB7XG4gIHJldHVybiBkaXIgPT09IDEgPyBkaWZmc1tpXVsxXVtkaWZmc1tpXVsxXS5sZW5ndGggLSAxXSA9PT0gZGlmZnNbal1bMV1bZGlmZnNbal1bMV0ubGVuZ3RoIC0gMV0gOiBkaWZmc1tpXVsxXVswXSA9PT0gZGlmZnNbal1bMV1bMF07XG59XG5mdW5jdGlvbiBkZWlzb2xhdGVDaGFyKGRpZmZzLCBpLCBkaXIpIHtcbiAgY29uc3QgaW52ID0gZGlyID09PSAxID8gLTEgOiAxO1xuICBsZXQgaW5zZXJ0SWR4ID0gbnVsbCwgZGVsZXRlSWR4ID0gbnVsbCwgaiA9IGkgKyBkaXI7XG4gIGZvciAoOyBqID49IDAgJiYgaiA8IGRpZmZzLmxlbmd0aCAmJiAoaW5zZXJ0SWR4ID09PSBudWxsIHx8IGRlbGV0ZUlkeCA9PT0gbnVsbCk7IGogKz0gZGlyKSB7XG4gICAgY29uc3QgW29wLCB0ZXh0Ml0gPSBkaWZmc1tqXTtcbiAgICBpZiAodGV4dDIubGVuZ3RoICE9PSAwKSB7XG4gICAgICBpZiAob3AgPT09IERJRkZfSU5TRVJUKSB7XG4gICAgICAgIGluc2VydElkeCA9PT0gbnVsbCAmJiAoaW5zZXJ0SWR4ID0gaik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChvcCA9PT0gRElGRl9ERUxFVEUpIHtcbiAgICAgICAgZGVsZXRlSWR4ID09PSBudWxsICYmIChkZWxldGVJZHggPSBqKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKG9wID09PSBESUZGX0VRVUFMKSB7XG4gICAgICAgIGlmIChpbnNlcnRJZHggPT09IG51bGwgJiYgZGVsZXRlSWR4ID09PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgW3Jlc3QsIGNoYXIyXSA9IHNwbGl0Q2hhcihkaWZmc1tpXVsxXSwgZGlyKTtcbiAgICAgICAgICBkaWZmc1tpXVsxXSA9IHJlc3QsIGRpZmZzW2pdWzFdID0gY29tYmluZUNoYXIoZGlmZnNbal1bMV0sIGNoYXIyLCBpbnYpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGluc2VydElkeCAhPT0gbnVsbCAmJiBkZWxldGVJZHggIT09IG51bGwgJiYgaGFzU2hhcmVkQ2hhcihkaWZmcywgaW5zZXJ0SWR4LCBkZWxldGVJZHgsIGRpcikpIHtcbiAgICBjb25zdCBbaW5zZXJ0VGV4dCwgaW5zZXJ0Q2hhcl0gPSBzcGxpdENoYXIoZGlmZnNbaW5zZXJ0SWR4XVsxXSwgaW52KSwgW2RlbGV0ZVRleHQyXSA9IHNwbGl0Q2hhcihkaWZmc1tkZWxldGVJZHhdWzFdLCBpbnYpO1xuICAgIGRpZmZzW2luc2VydElkeF1bMV0gPSBpbnNlcnRUZXh0LCBkaWZmc1tkZWxldGVJZHhdWzFdID0gZGVsZXRlVGV4dDIsIGRpZmZzW2ldWzFdID0gY29tYmluZUNoYXIoZGlmZnNbaV1bMV0sIGluc2VydENoYXIsIGRpcik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IFt0ZXh0LCBjaGFyXSA9IHNwbGl0Q2hhcihkaWZmc1tpXVsxXSwgZGlyKTtcbiAgZGlmZnNbaV1bMV0gPSB0ZXh0LCBpbnNlcnRJZHggPT09IG51bGwgPyAoZGlmZnMuc3BsaWNlKGosIDAsIFtESUZGX0lOU0VSVCwgY2hhcl0pLCBkZWxldGVJZHggIT09IG51bGwgJiYgZGVsZXRlSWR4ID49IGogJiYgZGVsZXRlSWR4KyspIDogZGlmZnNbaW5zZXJ0SWR4XVsxXSA9IGNvbWJpbmVDaGFyKGRpZmZzW2luc2VydElkeF1bMV0sIGNoYXIsIGludiksIGRlbGV0ZUlkeCA9PT0gbnVsbCA/IGRpZmZzLnNwbGljZShqLCAwLCBbRElGRl9ERUxFVEUsIGNoYXJdKSA6IGRpZmZzW2RlbGV0ZUlkeF1bMV0gPSBjb21iaW5lQ2hhcihkaWZmc1tkZWxldGVJZHhdWzFdLCBjaGFyLCBpbnYpO1xufVxuZnVuY3Rpb24gYWRqdXN0RGlmZkZvclN1cnJvZ2F0ZVBhaXJzKGRpZmZzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBbZGlmZlR5cGUsIGRpZmZUZXh0XSA9IGRpZmZzW2ldO1xuICAgIGlmIChkaWZmVGV4dC5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuICAgIGNvbnN0IGZpcnN0Q2hhciA9IGRpZmZUZXh0WzBdLCBsYXN0Q2hhciA9IGRpZmZUZXh0W2RpZmZUZXh0Lmxlbmd0aCAtIDFdO1xuICAgIGlzSGlnaFN1cnJvZ2F0ZShsYXN0Q2hhcikgJiYgZGlmZlR5cGUgPT09IERJRkZfRVFVQUwgJiYgZGVpc29sYXRlQ2hhcihkaWZmcywgaSwgMSksIGlzTG93U3Vycm9nYXRlKGZpcnN0Q2hhcikgJiYgZGlmZlR5cGUgPT09IERJRkZfRVFVQUwgJiYgZGVpc29sYXRlQ2hhcihkaWZmcywgaSwgLTEpO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZnMubGVuZ3RoOyBpKyspIGRpZmZzW2ldWzFdLmxlbmd0aCA9PT0gMCAmJiBkaWZmcy5zcGxpY2UoaSwgMSk7XG59XG5mdW5jdGlvbiBjbGVhbnVwU2VtYW50aWMocmF3RGlmZnMpIHtcbiAgbGV0IGRpZmZzID0gcmF3RGlmZnMubWFwKChkaWZmMikgPT4gY2xvbmVEaWZmKGRpZmYyKSksIGhhc0NoYW5nZXMgPSAhMTtcbiAgY29uc3QgZXF1YWxpdGllcyA9IFtdO1xuICBsZXQgZXF1YWxpdGllc0xlbmd0aCA9IDAsIGxhc3RFcXVhbGl0eSA9IG51bGwsIHBvaW50ZXIgPSAwLCBsZW5ndGhJbnNlcnRpb25zMSA9IDAsIGxlbmd0aERlbGV0aW9uczEgPSAwLCBsZW5ndGhJbnNlcnRpb25zMiA9IDAsIGxlbmd0aERlbGV0aW9uczIgPSAwO1xuICBmb3IgKDsgcG9pbnRlciA8IGRpZmZzLmxlbmd0aDsgKSBkaWZmc1twb2ludGVyXVswXSA9PT0gRElGRl9FUVVBTCA/IChlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGgrK10gPSBwb2ludGVyLCBsZW5ndGhJbnNlcnRpb25zMSA9IGxlbmd0aEluc2VydGlvbnMyLCBsZW5ndGhEZWxldGlvbnMxID0gbGVuZ3RoRGVsZXRpb25zMiwgbGVuZ3RoSW5zZXJ0aW9uczIgPSAwLCBsZW5ndGhEZWxldGlvbnMyID0gMCwgbGFzdEVxdWFsaXR5ID0gZGlmZnNbcG9pbnRlcl1bMV0pIDogKGRpZmZzW3BvaW50ZXJdWzBdID09PSBESUZGX0lOU0VSVCA/IGxlbmd0aEluc2VydGlvbnMyICs9IGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCA6IGxlbmd0aERlbGV0aW9uczIgKz0gZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoLCBsYXN0RXF1YWxpdHkgJiYgbGFzdEVxdWFsaXR5Lmxlbmd0aCA8PSBNYXRoLm1heChsZW5ndGhJbnNlcnRpb25zMSwgbGVuZ3RoRGVsZXRpb25zMSkgJiYgbGFzdEVxdWFsaXR5Lmxlbmd0aCA8PSBNYXRoLm1heChsZW5ndGhJbnNlcnRpb25zMiwgbGVuZ3RoRGVsZXRpb25zMikgJiYgKGRpZmZzLnNwbGljZShlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSwgMCwgW0RJRkZfREVMRVRFLCBsYXN0RXF1YWxpdHldKSwgZGlmZnNbZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gKyAxXVswXSA9IERJRkZfSU5TRVJULCBlcXVhbGl0aWVzTGVuZ3RoLS0sIGVxdWFsaXRpZXNMZW5ndGgtLSwgcG9pbnRlciA9IGVxdWFsaXRpZXNMZW5ndGggPiAwID8gZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gOiAtMSwgbGVuZ3RoSW5zZXJ0aW9uczEgPSAwLCBsZW5ndGhEZWxldGlvbnMxID0gMCwgbGVuZ3RoSW5zZXJ0aW9uczIgPSAwLCBsZW5ndGhEZWxldGlvbnMyID0gMCwgbGFzdEVxdWFsaXR5ID0gbnVsbCwgaGFzQ2hhbmdlcyA9ICEwKSksIHBvaW50ZXIrKztcbiAgZm9yIChoYXNDaGFuZ2VzICYmIChkaWZmcyA9IGNsZWFudXBNZXJnZShkaWZmcykpLCBkaWZmcyA9IGNsZWFudXBTZW1hbnRpY0xvc3NsZXNzKGRpZmZzKSwgcG9pbnRlciA9IDE7IHBvaW50ZXIgPCBkaWZmcy5sZW5ndGg7ICkge1xuICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMF0gPT09IERJRkZfREVMRVRFICYmIGRpZmZzW3BvaW50ZXJdWzBdID09PSBESUZGX0lOU0VSVCkge1xuICAgICAgY29uc3QgZGVsZXRpb24gPSBkaWZmc1twb2ludGVyIC0gMV1bMV0sIGluc2VydGlvbiA9IGRpZmZzW3BvaW50ZXJdWzFdLCBvdmVybGFwTGVuZ3RoMSA9IGdldENvbW1vbk92ZXJsYXAoZGVsZXRpb24sIGluc2VydGlvbiksIG92ZXJsYXBMZW5ndGgyID0gZ2V0Q29tbW9uT3ZlcmxhcChpbnNlcnRpb24sIGRlbGV0aW9uKTtcbiAgICAgIG92ZXJsYXBMZW5ndGgxID49IG92ZXJsYXBMZW5ndGgyID8gKG92ZXJsYXBMZW5ndGgxID49IGRlbGV0aW9uLmxlbmd0aCAvIDIgfHwgb3ZlcmxhcExlbmd0aDEgPj0gaW5zZXJ0aW9uLmxlbmd0aCAvIDIpICYmIChkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgW0RJRkZfRVFVQUwsIGluc2VydGlvbi5zdWJzdHJpbmcoMCwgb3ZlcmxhcExlbmd0aDEpXSksIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSA9IGRlbGV0aW9uLnN1YnN0cmluZygwLCBkZWxldGlvbi5sZW5ndGggLSBvdmVybGFwTGVuZ3RoMSksIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGluc2VydGlvbi5zdWJzdHJpbmcob3ZlcmxhcExlbmd0aDEpLCBwb2ludGVyKyspIDogKG92ZXJsYXBMZW5ndGgyID49IGRlbGV0aW9uLmxlbmd0aCAvIDIgfHwgb3ZlcmxhcExlbmd0aDIgPj0gaW5zZXJ0aW9uLmxlbmd0aCAvIDIpICYmIChkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgW0RJRkZfRVFVQUwsIGRlbGV0aW9uLnN1YnN0cmluZygwLCBvdmVybGFwTGVuZ3RoMildKSwgZGlmZnNbcG9pbnRlciAtIDFdWzBdID0gRElGRl9JTlNFUlQsIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSA9IGluc2VydGlvbi5zdWJzdHJpbmcoMCwgaW5zZXJ0aW9uLmxlbmd0aCAtIG92ZXJsYXBMZW5ndGgyKSwgZGlmZnNbcG9pbnRlciArIDFdWzBdID0gRElGRl9ERUxFVEUsIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGRlbGV0aW9uLnN1YnN0cmluZyhvdmVybGFwTGVuZ3RoMiksIHBvaW50ZXIrKyksIHBvaW50ZXIrKztcbiAgICB9XG4gICAgcG9pbnRlcisrO1xuICB9XG4gIHJldHVybiBkaWZmcztcbn1cbmNvbnN0IG5vbkFscGhhTnVtZXJpY1JlZ2V4ID0gL1teYS16QS1aMC05XS8sIHdoaXRlc3BhY2VSZWdleCA9IC9cXHMvLCBsaW5lYnJlYWtSZWdleCA9IC9bXFxyXFxuXS8sIGJsYW5rbGluZUVuZFJlZ2V4ID0gL1xcblxccj9cXG4kLywgYmxhbmtsaW5lU3RhcnRSZWdleCA9IC9eXFxyP1xcblxccj9cXG4vO1xuZnVuY3Rpb24gY2xlYW51cFNlbWFudGljTG9zc2xlc3MocmF3RGlmZnMpIHtcbiAgY29uc3QgZGlmZnMgPSByYXdEaWZmcy5tYXAoKGRpZmYyKSA9PiBjbG9uZURpZmYoZGlmZjIpKTtcbiAgZnVuY3Rpb24gZGlmZkNsZWFudXBTZW1hbnRpY1Njb3JlKG9uZSwgdHdvKSB7XG4gICAgaWYgKCFvbmUgfHwgIXR3bykgcmV0dXJuIDY7XG4gICAgY29uc3QgY2hhcjEgPSBvbmUuY2hhckF0KG9uZS5sZW5ndGggLSAxKSwgY2hhcjIgPSB0d28uY2hhckF0KDApLCBub25BbHBoYU51bWVyaWMxID0gY2hhcjEubWF0Y2gobm9uQWxwaGFOdW1lcmljUmVnZXgpLCBub25BbHBoYU51bWVyaWMyID0gY2hhcjIubWF0Y2gobm9uQWxwaGFOdW1lcmljUmVnZXgpLCB3aGl0ZXNwYWNlMSA9IG5vbkFscGhhTnVtZXJpYzEgJiYgY2hhcjEubWF0Y2god2hpdGVzcGFjZVJlZ2V4KSwgd2hpdGVzcGFjZTIgPSBub25BbHBoYU51bWVyaWMyICYmIGNoYXIyLm1hdGNoKHdoaXRlc3BhY2VSZWdleCksIGxpbmVCcmVhazEgPSB3aGl0ZXNwYWNlMSAmJiBjaGFyMS5tYXRjaChsaW5lYnJlYWtSZWdleCksIGxpbmVCcmVhazIgPSB3aGl0ZXNwYWNlMiAmJiBjaGFyMi5tYXRjaChsaW5lYnJlYWtSZWdleCksIGJsYW5rTGluZTEgPSBsaW5lQnJlYWsxICYmIG9uZS5tYXRjaChibGFua2xpbmVFbmRSZWdleCksIGJsYW5rTGluZTIgPSBsaW5lQnJlYWsyICYmIHR3by5tYXRjaChibGFua2xpbmVTdGFydFJlZ2V4KTtcbiAgICByZXR1cm4gYmxhbmtMaW5lMSB8fCBibGFua0xpbmUyID8gNSA6IGxpbmVCcmVhazEgfHwgbGluZUJyZWFrMiA/IDQgOiBub25BbHBoYU51bWVyaWMxICYmICF3aGl0ZXNwYWNlMSAmJiB3aGl0ZXNwYWNlMiA/IDMgOiB3aGl0ZXNwYWNlMSB8fCB3aGl0ZXNwYWNlMiA/IDIgOiBub25BbHBoYU51bWVyaWMxIHx8IG5vbkFscGhhTnVtZXJpYzIgPyAxIDogMDtcbiAgfVxuICBsZXQgcG9pbnRlciA9IDE7XG4gIGZvciAoOyBwb2ludGVyIDwgZGlmZnMubGVuZ3RoIC0gMTsgKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PT0gRElGRl9FUVVBTCAmJiBkaWZmc1twb2ludGVyICsgMV1bMF0gPT09IERJRkZfRVFVQUwpIHtcbiAgICAgIGxldCBlcXVhbGl0eTEgPSBkaWZmc1twb2ludGVyIC0gMV1bMV0sIGVkaXQgPSBkaWZmc1twb2ludGVyXVsxXSwgZXF1YWxpdHkyID0gZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuICAgICAgY29uc3QgY29tbW9uT2Zmc2V0ID0gZ2V0Q29tbW9uU3VmZml4KGVxdWFsaXR5MSwgZWRpdCk7XG4gICAgICBpZiAoY29tbW9uT2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IGNvbW1vblN0cmluZyA9IGVkaXQuc3Vic3RyaW5nKGVkaXQubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KTtcbiAgICAgICAgZXF1YWxpdHkxID0gZXF1YWxpdHkxLnN1YnN0cmluZygwLCBlcXVhbGl0eTEubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KSwgZWRpdCA9IGNvbW1vblN0cmluZyArIGVkaXQuc3Vic3RyaW5nKDAsIGVkaXQubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KSwgZXF1YWxpdHkyID0gY29tbW9uU3RyaW5nICsgZXF1YWxpdHkyO1xuICAgICAgfVxuICAgICAgbGV0IGJlc3RFcXVhbGl0eTEgPSBlcXVhbGl0eTEsIGJlc3RFZGl0ID0gZWRpdCwgYmVzdEVxdWFsaXR5MiA9IGVxdWFsaXR5MiwgYmVzdFNjb3JlID0gZGlmZkNsZWFudXBTZW1hbnRpY1Njb3JlKGVxdWFsaXR5MSwgZWRpdCkgKyBkaWZmQ2xlYW51cFNlbWFudGljU2NvcmUoZWRpdCwgZXF1YWxpdHkyKTtcbiAgICAgIGZvciAoOyBlZGl0LmNoYXJBdCgwKSA9PT0gZXF1YWxpdHkyLmNoYXJBdCgwKTsgKSB7XG4gICAgICAgIGVxdWFsaXR5MSArPSBlZGl0LmNoYXJBdCgwKSwgZWRpdCA9IGVkaXQuc3Vic3RyaW5nKDEpICsgZXF1YWxpdHkyLmNoYXJBdCgwKSwgZXF1YWxpdHkyID0gZXF1YWxpdHkyLnN1YnN0cmluZygxKTtcbiAgICAgICAgY29uc3Qgc2NvcmUgPSBkaWZmQ2xlYW51cFNlbWFudGljU2NvcmUoZXF1YWxpdHkxLCBlZGl0KSArIGRpZmZDbGVhbnVwU2VtYW50aWNTY29yZShlZGl0LCBlcXVhbGl0eTIpO1xuICAgICAgICBzY29yZSA+PSBiZXN0U2NvcmUgJiYgKGJlc3RTY29yZSA9IHNjb3JlLCBiZXN0RXF1YWxpdHkxID0gZXF1YWxpdHkxLCBiZXN0RWRpdCA9IGVkaXQsIGJlc3RFcXVhbGl0eTIgPSBlcXVhbGl0eTIpO1xuICAgICAgfVxuICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdICE9PSBiZXN0RXF1YWxpdHkxICYmIChiZXN0RXF1YWxpdHkxID8gZGlmZnNbcG9pbnRlciAtIDFdWzFdID0gYmVzdEVxdWFsaXR5MSA6IChkaWZmcy5zcGxpY2UocG9pbnRlciAtIDEsIDEpLCBwb2ludGVyLS0pLCBkaWZmc1twb2ludGVyXVsxXSA9IGJlc3RFZGl0LCBiZXN0RXF1YWxpdHkyID8gZGlmZnNbcG9pbnRlciArIDFdWzFdID0gYmVzdEVxdWFsaXR5MiA6IChkaWZmcy5zcGxpY2UocG9pbnRlciArIDEsIDEpLCBwb2ludGVyLS0pKTtcbiAgICB9XG4gICAgcG9pbnRlcisrO1xuICB9XG4gIHJldHVybiBkaWZmcztcbn1cbmZ1bmN0aW9uIGNsZWFudXBNZXJnZShyYXdEaWZmcykge1xuICBsZXQgZGlmZnMgPSByYXdEaWZmcy5tYXAoKGRpZmYyKSA9PiBjbG9uZURpZmYoZGlmZjIpKTtcbiAgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgXCJcIl0pO1xuICBsZXQgcG9pbnRlciA9IDAsIGNvdW50RGVsZXRlID0gMCwgY291bnRJbnNlcnQgPSAwLCB0ZXh0RGVsZXRlID0gXCJcIiwgdGV4dEluc2VydCA9IFwiXCIsIGNvbW1vbmxlbmd0aDtcbiAgZm9yICg7IHBvaW50ZXIgPCBkaWZmcy5sZW5ndGg7ICkgc3dpdGNoIChkaWZmc1twb2ludGVyXVswXSkge1xuICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICBjb3VudEluc2VydCsrLCB0ZXh0SW5zZXJ0ICs9IGRpZmZzW3BvaW50ZXJdWzFdLCBwb2ludGVyKys7XG4gICAgICBicmVhaztcbiAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgY291bnREZWxldGUrKywgdGV4dERlbGV0ZSArPSBkaWZmc1twb2ludGVyXVsxXSwgcG9pbnRlcisrO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgY291bnREZWxldGUgKyBjb3VudEluc2VydCA+IDEgPyAoY291bnREZWxldGUgIT09IDAgJiYgY291bnRJbnNlcnQgIT09IDAgJiYgKGNvbW1vbmxlbmd0aCA9IGdldENvbW1vblByZWZpeCh0ZXh0SW5zZXJ0LCB0ZXh0RGVsZXRlKSwgY29tbW9ubGVuZ3RoICE9PSAwICYmIChwb2ludGVyIC0gY291bnREZWxldGUgLSBjb3VudEluc2VydCA+IDAgJiYgZGlmZnNbcG9pbnRlciAtIGNvdW50RGVsZXRlIC0gY291bnRJbnNlcnQgLSAxXVswXSA9PT0gRElGRl9FUVVBTCA/IGRpZmZzW3BvaW50ZXIgLSBjb3VudERlbGV0ZSAtIGNvdW50SW5zZXJ0IC0gMV1bMV0gKz0gdGV4dEluc2VydC5zdWJzdHJpbmcoMCwgY29tbW9ubGVuZ3RoKSA6IChkaWZmcy5zcGxpY2UoMCwgMCwgW0RJRkZfRVFVQUwsIHRleHRJbnNlcnQuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCldKSwgcG9pbnRlcisrKSwgdGV4dEluc2VydCA9IHRleHRJbnNlcnQuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCksIHRleHREZWxldGUgPSB0ZXh0RGVsZXRlLnN1YnN0cmluZyhjb21tb25sZW5ndGgpKSwgY29tbW9ubGVuZ3RoID0gZ2V0Q29tbW9uU3VmZml4KHRleHRJbnNlcnQsIHRleHREZWxldGUpLCBjb21tb25sZW5ndGggIT09IDAgJiYgKGRpZmZzW3BvaW50ZXJdWzFdID0gdGV4dEluc2VydC5zdWJzdHJpbmcodGV4dEluc2VydC5sZW5ndGggLSBjb21tb25sZW5ndGgpICsgZGlmZnNbcG9pbnRlcl1bMV0sIHRleHRJbnNlcnQgPSB0ZXh0SW5zZXJ0LnN1YnN0cmluZygwLCB0ZXh0SW5zZXJ0Lmxlbmd0aCAtIGNvbW1vbmxlbmd0aCksIHRleHREZWxldGUgPSB0ZXh0RGVsZXRlLnN1YnN0cmluZygwLCB0ZXh0RGVsZXRlLmxlbmd0aCAtIGNvbW1vbmxlbmd0aCkpKSwgcG9pbnRlciAtPSBjb3VudERlbGV0ZSArIGNvdW50SW5zZXJ0LCBkaWZmcy5zcGxpY2UocG9pbnRlciwgY291bnREZWxldGUgKyBjb3VudEluc2VydCksIHRleHREZWxldGUubGVuZ3RoICYmIChkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgW0RJRkZfREVMRVRFLCB0ZXh0RGVsZXRlXSksIHBvaW50ZXIrKyksIHRleHRJbnNlcnQubGVuZ3RoICYmIChkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgW0RJRkZfSU5TRVJULCB0ZXh0SW5zZXJ0XSksIHBvaW50ZXIrKyksIHBvaW50ZXIrKykgOiBwb2ludGVyICE9PSAwICYmIGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PT0gRElGRl9FUVVBTCA/IChkaWZmc1twb2ludGVyIC0gMV1bMV0gKz0gZGlmZnNbcG9pbnRlcl1bMV0sIGRpZmZzLnNwbGljZShwb2ludGVyLCAxKSkgOiBwb2ludGVyKyssIGNvdW50SW5zZXJ0ID0gMCwgY291bnREZWxldGUgPSAwLCB0ZXh0RGVsZXRlID0gXCJcIiwgdGV4dEluc2VydCA9IFwiXCI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkaWZmIG9wZXJhdGlvblwiKTtcbiAgfVxuICBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXSA9PT0gXCJcIiAmJiBkaWZmcy5wb3AoKTtcbiAgbGV0IGhhc0NoYW5nZXMgPSAhMTtcbiAgZm9yIChwb2ludGVyID0gMTsgcG9pbnRlciA8IGRpZmZzLmxlbmd0aCAtIDE7ICkgZGlmZnNbcG9pbnRlciAtIDFdWzBdID09PSBESUZGX0VRVUFMICYmIGRpZmZzW3BvaW50ZXIgKyAxXVswXSA9PT0gRElGRl9FUVVBTCAmJiAoZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCAtIGRpZmZzW3BvaW50ZXIgLSAxXVsxXS5sZW5ndGgpID09PSBkaWZmc1twb2ludGVyIC0gMV1bMV0gPyAoZGlmZnNbcG9pbnRlcl1bMV0gPSBkaWZmc1twb2ludGVyIC0gMV1bMV0gKyBkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoMCwgZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIC0gZGlmZnNbcG9pbnRlciAtIDFdWzFdLmxlbmd0aCksIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSwgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSAxLCAxKSwgaGFzQ2hhbmdlcyA9ICEwKSA6IGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZygwLCBkaWZmc1twb2ludGVyICsgMV1bMV0ubGVuZ3RoKSA9PT0gZGlmZnNbcG9pbnRlciArIDFdWzFdICYmIChkaWZmc1twb2ludGVyIC0gMV1bMV0gKz0gZGlmZnNbcG9pbnRlciArIDFdWzFdLCBkaWZmc1twb2ludGVyXVsxXSA9IGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZyhkaWZmc1twb2ludGVyICsgMV1bMV0ubGVuZ3RoKSArIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSwgZGlmZnMuc3BsaWNlKHBvaW50ZXIgKyAxLCAxKSwgaGFzQ2hhbmdlcyA9ICEwKSksIHBvaW50ZXIrKztcbiAgcmV0dXJuIGhhc0NoYW5nZXMgJiYgKGRpZmZzID0gY2xlYW51cE1lcmdlKGRpZmZzKSksIGRpZmZzO1xufVxuZnVuY3Rpb24gdHJ1ZUNvdW50KC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGFyZ3MucmVkdWNlKChuLCBib29sKSA9PiBuICsgKGJvb2wgPyAxIDogMCksIDApO1xufVxuZnVuY3Rpb24gY2xlYW51cEVmZmljaWVuY3kocmF3RGlmZnMsIGVkaXRDb3N0ID0gNCkge1xuICBsZXQgZGlmZnMgPSByYXdEaWZmcy5tYXAoKGRpZmYyKSA9PiBjbG9uZURpZmYoZGlmZjIpKSwgaGFzQ2hhbmdlcyA9ICExO1xuICBjb25zdCBlcXVhbGl0aWVzID0gW107XG4gIGxldCBlcXVhbGl0aWVzTGVuZ3RoID0gMCwgbGFzdEVxdWFsaXR5ID0gbnVsbCwgcG9pbnRlciA9IDAsIHByZUlucyA9ICExLCBwcmVEZWwgPSAhMSwgcG9zdElucyA9ICExLCBwb3N0RGVsID0gITE7XG4gIGZvciAoOyBwb2ludGVyIDwgZGlmZnMubGVuZ3RoOyApIGRpZmZzW3BvaW50ZXJdWzBdID09PSBESUZGX0VRVUFMID8gKGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCA8IGVkaXRDb3N0ICYmIChwb3N0SW5zIHx8IHBvc3REZWwpID8gKGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCsrXSA9IHBvaW50ZXIsIHByZUlucyA9IHBvc3RJbnMsIHByZURlbCA9IHBvc3REZWwsIGxhc3RFcXVhbGl0eSA9IGRpZmZzW3BvaW50ZXJdWzFdKSA6IChlcXVhbGl0aWVzTGVuZ3RoID0gMCwgbGFzdEVxdWFsaXR5ID0gbnVsbCksIHBvc3RJbnMgPSAhMSwgcG9zdERlbCA9ICExKSA6IChkaWZmc1twb2ludGVyXVswXSA9PT0gRElGRl9ERUxFVEUgPyBwb3N0RGVsID0gITAgOiBwb3N0SW5zID0gITAsIGxhc3RFcXVhbGl0eSAmJiAocHJlSW5zICYmIHByZURlbCAmJiBwb3N0SW5zICYmIHBvc3REZWwgfHwgbGFzdEVxdWFsaXR5Lmxlbmd0aCA8IGVkaXRDb3N0IC8gMiAmJiB0cnVlQ291bnQocHJlSW5zLCBwcmVEZWwsIHBvc3RJbnMsIHBvc3REZWwpID09PSAzKSAmJiAoZGlmZnMuc3BsaWNlKGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdLCAwLCBbRElGRl9ERUxFVEUsIGxhc3RFcXVhbGl0eV0pLCBkaWZmc1tlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSArIDFdWzBdID0gRElGRl9JTlNFUlQsIGVxdWFsaXRpZXNMZW5ndGgtLSwgbGFzdEVxdWFsaXR5ID0gbnVsbCwgcHJlSW5zICYmIHByZURlbCA/IChwb3N0SW5zID0gITAsIHBvc3REZWwgPSAhMCwgZXF1YWxpdGllc0xlbmd0aCA9IDApIDogKGVxdWFsaXRpZXNMZW5ndGgtLSwgcG9pbnRlciA9IGVxdWFsaXRpZXNMZW5ndGggPiAwID8gZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gOiAtMSwgcG9zdElucyA9ICExLCBwb3N0RGVsID0gITEpLCBoYXNDaGFuZ2VzID0gITApKSwgcG9pbnRlcisrO1xuICByZXR1cm4gaGFzQ2hhbmdlcyAmJiAoZGlmZnMgPSBjbGVhbnVwTWVyZ2UoZGlmZnMpKSwgZGlmZnM7XG59XG52YXIgX19kZWZQcm9wJDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIF9fZ2V0T3duUHJvcFN5bWJvbHMkMSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIF9faGFzT3duUHJvcCQxID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgX19wcm9wSXNFbnVtJDEgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLCBfX2RlZk5vcm1hbFByb3AkMSA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMShvYmosIGtleSwge1xuICBlbnVtZXJhYmxlOiAhMCxcbiAgY29uZmlndXJhYmxlOiAhMCxcbiAgd3JpdGFibGU6ICEwLFxuICB2YWx1ZVxufSkgOiBvYmpba2V5XSA9IHZhbHVlLCBfX3NwcmVhZFZhbHVlcyQxID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKSBfX2hhc093blByb3AkMS5jYWxsKGIsIHByb3ApICYmIF9fZGVmTm9ybWFsUHJvcCQxKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scyQxKSBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMkMShiKSkgX19wcm9wSXNFbnVtJDEuY2FsbChiLCBwcm9wKSAmJiBfX2RlZk5vcm1hbFByb3AkMShhLCBwcm9wLCBiW3Byb3BdKTtcbiAgcmV0dXJuIGE7XG59O1xuY29uc3QgREVGQVVMVF9PUFRJT05TID0ge1xuICAvKipcbiAgICogQXQgd2hhdCBwb2ludCBpcyBubyBtYXRjaCBkZWNsYXJlZCAoMC4wID0gcGVyZmVjdGlvbiwgMS4wID0gdmVyeSBsb29zZSkuXG4gICAqL1xuICB0aHJlc2hvbGQ6IDAuNSxcbiAgLyoqXG4gICAqIEhvdyBmYXIgdG8gc2VhcmNoIGZvciBhIG1hdGNoICgwID0gZXhhY3QgbG9jYXRpb24sIDEwMDArID0gYnJvYWQgbWF0Y2gpLlxuICAgKiBBIG1hdGNoIHRoaXMgbWFueSBjaGFyYWN0ZXJzIGF3YXkgZnJvbSB0aGUgZXhwZWN0ZWQgbG9jYXRpb24gd2lsbCBhZGRcbiAgICogMS4wIHRvIHRoZSBzY29yZSAoMC4wIGlzIGEgcGVyZmVjdCBtYXRjaCkuXG4gICAqL1xuICBkaXN0YW5jZTogMWUzXG59O1xuZnVuY3Rpb24gYXBwbHlEZWZhdWx0cyhvcHRpb25zKSB7XG4gIHJldHVybiBfX3NwcmVhZFZhbHVlcyQxKF9fc3ByZWFkVmFsdWVzJDEoe30sIERFRkFVTFRfT1BUSU9OUyksIG9wdGlvbnMpO1xufVxuY29uc3QgTUFYX0JJVFMkMSA9IDMyO1xuZnVuY3Rpb24gYml0YXAodGV4dCwgcGF0dGVybiwgbG9jLCBvcHRzID0ge30pIHtcbiAgaWYgKHBhdHRlcm4ubGVuZ3RoID4gTUFYX0JJVFMkMSkgdGhyb3cgbmV3IEVycm9yKFwiUGF0dGVybiB0b28gbG9uZyBmb3IgdGhpcyBicm93c2VyLlwiKTtcbiAgY29uc3Qgb3B0aW9ucyA9IGFwcGx5RGVmYXVsdHMob3B0cyksIHMgPSBnZXRBbHBoYWJldEZyb21QYXR0ZXJuKHBhdHRlcm4pO1xuICBmdW5jdGlvbiBnZXRCaXRhcFNjb3JlKGUsIHgpIHtcbiAgICBjb25zdCBhY2N1cmFjeSA9IGUgLyBwYXR0ZXJuLmxlbmd0aCwgcHJveGltaXR5ID0gTWF0aC5hYnMobG9jIC0geCk7XG4gICAgcmV0dXJuIG9wdGlvbnMuZGlzdGFuY2UgPyBhY2N1cmFjeSArIHByb3hpbWl0eSAvIG9wdGlvbnMuZGlzdGFuY2UgOiBwcm94aW1pdHkgPyAxIDogYWNjdXJhY3k7XG4gIH1cbiAgbGV0IHNjb3JlVGhyZXNob2xkID0gb3B0aW9ucy50aHJlc2hvbGQsIGJlc3RMb2MgPSB0ZXh0LmluZGV4T2YocGF0dGVybiwgbG9jKTtcbiAgYmVzdExvYyAhPT0gLTEgJiYgKHNjb3JlVGhyZXNob2xkID0gTWF0aC5taW4oZ2V0Qml0YXBTY29yZSgwLCBiZXN0TG9jKSwgc2NvcmVUaHJlc2hvbGQpLCBiZXN0TG9jID0gdGV4dC5sYXN0SW5kZXhPZihwYXR0ZXJuLCBsb2MgKyBwYXR0ZXJuLmxlbmd0aCksIGJlc3RMb2MgIT09IC0xICYmIChzY29yZVRocmVzaG9sZCA9IE1hdGgubWluKGdldEJpdGFwU2NvcmUoMCwgYmVzdExvYyksIHNjb3JlVGhyZXNob2xkKSkpO1xuICBjb25zdCBtYXRjaG1hc2sgPSAxIDw8IHBhdHRlcm4ubGVuZ3RoIC0gMTtcbiAgYmVzdExvYyA9IC0xO1xuICBsZXQgYmluTWluLCBiaW5NaWQsIGJpbk1heCA9IHBhdHRlcm4ubGVuZ3RoICsgdGV4dC5sZW5ndGgsIGxhc3RSZCA9IFtdO1xuICBmb3IgKGxldCBkID0gMDsgZCA8IHBhdHRlcm4ubGVuZ3RoOyBkKyspIHtcbiAgICBmb3IgKGJpbk1pbiA9IDAsIGJpbk1pZCA9IGJpbk1heDsgYmluTWluIDwgYmluTWlkOyApIGdldEJpdGFwU2NvcmUoZCwgbG9jICsgYmluTWlkKSA8PSBzY29yZVRocmVzaG9sZCA/IGJpbk1pbiA9IGJpbk1pZCA6IGJpbk1heCA9IGJpbk1pZCwgYmluTWlkID0gTWF0aC5mbG9vcigoYmluTWF4IC0gYmluTWluKSAvIDIgKyBiaW5NaW4pO1xuICAgIGJpbk1heCA9IGJpbk1pZDtcbiAgICBsZXQgc3RhcnQgPSBNYXRoLm1heCgxLCBsb2MgLSBiaW5NaWQgKyAxKTtcbiAgICBjb25zdCBmaW5pc2ggPSBNYXRoLm1pbihsb2MgKyBiaW5NaWQsIHRleHQubGVuZ3RoKSArIHBhdHRlcm4ubGVuZ3RoLCByZCA9IG5ldyBBcnJheShmaW5pc2ggKyAyKTtcbiAgICByZFtmaW5pc2ggKyAxXSA9ICgxIDw8IGQpIC0gMTtcbiAgICBmb3IgKGxldCBqID0gZmluaXNoOyBqID49IHN0YXJ0OyBqLS0pIHtcbiAgICAgIGNvbnN0IGNoYXJNYXRjaCA9IHNbdGV4dC5jaGFyQXQoaiAtIDEpXTtcbiAgICAgIGlmIChkID09PSAwID8gcmRbal0gPSAocmRbaiArIDFdIDw8IDEgfCAxKSAmIGNoYXJNYXRjaCA6IHJkW2pdID0gKHJkW2ogKyAxXSA8PCAxIHwgMSkgJiBjaGFyTWF0Y2ggfCAoKGxhc3RSZFtqICsgMV0gfCBsYXN0UmRbal0pIDw8IDEgfCAxKSB8IGxhc3RSZFtqICsgMV0sIHJkW2pdICYgbWF0Y2htYXNrKSB7XG4gICAgICAgIGNvbnN0IHNjb3JlID0gZ2V0Qml0YXBTY29yZShkLCBqIC0gMSk7XG4gICAgICAgIGlmIChzY29yZSA8PSBzY29yZVRocmVzaG9sZCkgaWYgKHNjb3JlVGhyZXNob2xkID0gc2NvcmUsIGJlc3RMb2MgPSBqIC0gMSwgYmVzdExvYyA+IGxvYykgc3RhcnQgPSBNYXRoLm1heCgxLCAyICogbG9jIC0gYmVzdExvYyk7XG4gICAgICAgIGVsc2UgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChnZXRCaXRhcFNjb3JlKGQgKyAxLCBsb2MpID4gc2NvcmVUaHJlc2hvbGQpIGJyZWFrO1xuICAgIGxhc3RSZCA9IHJkO1xuICB9XG4gIHJldHVybiBiZXN0TG9jO1xufVxuZnVuY3Rpb24gZ2V0QWxwaGFiZXRGcm9tUGF0dGVybihwYXR0ZXJuKSB7XG4gIGNvbnN0IHMgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKSBzW3BhdHRlcm4uY2hhckF0KGkpXSA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkrKykgc1twYXR0ZXJuLmNoYXJBdChpKV0gfD0gMSA8PCBwYXR0ZXJuLmxlbmd0aCAtIGkgLSAxO1xuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIG1hdGNoKHRleHQsIHBhdHRlcm4sIHNlYXJjaExvY2F0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKHRleHQgPT09IG51bGwgfHwgcGF0dGVybiA9PT0gbnVsbCB8fCBzZWFyY2hMb2NhdGlvbiA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiTnVsbCBpbnB1dC4gKG1hdGNoKCkpXCIpO1xuICBjb25zdCBsb2MgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzZWFyY2hMb2NhdGlvbiwgdGV4dC5sZW5ndGgpKTtcbiAgaWYgKHRleHQgPT09IHBhdHRlcm4pIHJldHVybiAwO1xuICBpZiAodGV4dC5sZW5ndGgpIHtcbiAgICBpZiAodGV4dC5zdWJzdHJpbmcobG9jLCBsb2MgKyBwYXR0ZXJuLmxlbmd0aCkgPT09IHBhdHRlcm4pIHJldHVybiBsb2M7XG4gIH0gZWxzZSByZXR1cm4gLTE7XG4gIHJldHVybiBiaXRhcCh0ZXh0LCBwYXR0ZXJuLCBsb2MsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZGlmZlRleHQxKGRpZmZzKSB7XG4gIGNvbnN0IHRleHQgPSBbXTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykgZGlmZnNbeF1bMF0gIT09IERJRkZfSU5TRVJUICYmICh0ZXh0W3hdID0gZGlmZnNbeF1bMV0pO1xuICByZXR1cm4gdGV4dC5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gZGlmZlRleHQyKGRpZmZzKSB7XG4gIGNvbnN0IHRleHQgPSBbXTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykgZGlmZnNbeF1bMF0gIT09IERJRkZfREVMRVRFICYmICh0ZXh0W3hdID0gZGlmZnNbeF1bMV0pO1xuICByZXR1cm4gdGV4dC5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gbGV2ZW5zaHRlaW4oZGlmZnMpIHtcbiAgbGV0IGxldmVuID0gMCwgaW5zZXJ0aW9ucyA9IDAsIGRlbGV0aW9ucyA9IDA7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICBjb25zdCBvcCA9IGRpZmZzW3hdWzBdLCBkYXRhID0gZGlmZnNbeF1bMV07XG4gICAgc3dpdGNoIChvcCkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgaW5zZXJ0aW9ucyArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBkZWxldGlvbnMgKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICBsZXZlbiArPSBNYXRoLm1heChpbnNlcnRpb25zLCBkZWxldGlvbnMpLCBpbnNlcnRpb25zID0gMCwgZGVsZXRpb25zID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRpZmYgb3BlcmF0aW9uLlwiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxldmVuICs9IE1hdGgubWF4KGluc2VydGlvbnMsIGRlbGV0aW9ucyksIGxldmVuO1xufVxuZnVuY3Rpb24geEluZGV4KGRpZmZzLCBsb2NhdGlvbikge1xuICBsZXQgY2hhcnMxID0gMCwgY2hhcnMyID0gMCwgbGFzdENoYXJzMSA9IDAsIGxhc3RDaGFyczIgPSAwLCB4O1xuICBmb3IgKHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoICYmIChkaWZmc1t4XVswXSAhPT0gRElGRl9JTlNFUlQgJiYgKGNoYXJzMSArPSBkaWZmc1t4XVsxXS5sZW5ndGgpLCBkaWZmc1t4XVswXSAhPT0gRElGRl9ERUxFVEUgJiYgKGNoYXJzMiArPSBkaWZmc1t4XVsxXS5sZW5ndGgpLCAhKGNoYXJzMSA+IGxvY2F0aW9uKSk7IHgrKykgbGFzdENoYXJzMSA9IGNoYXJzMSwgbGFzdENoYXJzMiA9IGNoYXJzMjtcbiAgcmV0dXJuIGRpZmZzLmxlbmd0aCAhPT0geCAmJiBkaWZmc1t4XVswXSA9PT0gRElGRl9ERUxFVEUgPyBsYXN0Q2hhcnMyIDogbGFzdENoYXJzMiArIChsb2NhdGlvbiAtIGxhc3RDaGFyczEpO1xufVxuZnVuY3Rpb24gY291bnRVdGY4Qnl0ZXMoc3RyKSB7XG4gIGxldCBieXRlcyA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZVBvaW50ID0gc3RyLmNvZGVQb2ludEF0KGkpO1xuICAgIGlmICh0eXBlb2YgY29kZVBvaW50ID4gXCJ1XCIpIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZXQgY29kZXBvaW50XCIpO1xuICAgIGJ5dGVzICs9IHV0ZjhsZW4oY29kZVBvaW50KTtcbiAgfVxuICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBhZGp1c3RJbmRpY2llc1RvVWNzMihwYXRjaGVzLCBiYXNlLCBvcHRpb25zID0ge30pIHtcbiAgbGV0IGJ5dGVPZmZzZXQgPSAwLCBpZHggPSAwO1xuICBmdW5jdGlvbiBhZHZhbmNlVG8odGFyZ2V0KSB7XG4gICAgZm9yICg7IGJ5dGVPZmZzZXQgPCB0YXJnZXQ7ICkge1xuICAgICAgY29uc3QgY29kZVBvaW50ID0gYmFzZS5jb2RlUG9pbnRBdChpZHgpO1xuICAgICAgaWYgKHR5cGVvZiBjb2RlUG9pbnQgPiBcInVcIikgcmV0dXJuIGlkeDtcbiAgICAgIGJ5dGVPZmZzZXQgKz0gdXRmOGxlbihjb2RlUG9pbnQpLCBjb2RlUG9pbnQgPiA2NTUzNSA/IGlkeCArPSAyIDogaWR4ICs9IDE7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5hbGxvd0V4Y2VlZGluZ0luZGljZXMgJiYgYnl0ZU9mZnNldCAhPT0gdGFyZ2V0KSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZGV0ZXJtaW5lIGJ5dGUgb2Zmc2V0XCIpO1xuICAgIHJldHVybiBpZHg7XG4gIH1cbiAgY29uc3QgYWRqdXN0ZWQgPSBbXTtcbiAgZm9yIChjb25zdCBwYXRjaCBvZiBwYXRjaGVzKSBhZGp1c3RlZC5wdXNoKHtcbiAgICBkaWZmczogcGF0Y2guZGlmZnMubWFwKChkaWZmMikgPT4gY2xvbmVEaWZmKGRpZmYyKSksXG4gICAgc3RhcnQxOiBhZHZhbmNlVG8ocGF0Y2guc3RhcnQxKSxcbiAgICBzdGFydDI6IGFkdmFuY2VUbyhwYXRjaC5zdGFydDIpLFxuICAgIHV0ZjhTdGFydDE6IHBhdGNoLnV0ZjhTdGFydDEsXG4gICAgdXRmOFN0YXJ0MjogcGF0Y2gudXRmOFN0YXJ0MixcbiAgICBsZW5ndGgxOiBwYXRjaC5sZW5ndGgxLFxuICAgIGxlbmd0aDI6IHBhdGNoLmxlbmd0aDIsXG4gICAgdXRmOExlbmd0aDE6IHBhdGNoLnV0ZjhMZW5ndGgxLFxuICAgIHV0ZjhMZW5ndGgyOiBwYXRjaC51dGY4TGVuZ3RoMlxuICB9KTtcbiAgcmV0dXJuIGFkanVzdGVkO1xufVxuZnVuY3Rpb24gdXRmOGxlbihjb2RlUG9pbnQpIHtcbiAgcmV0dXJuIGNvZGVQb2ludCA8PSAxMjcgPyAxIDogY29kZVBvaW50IDw9IDIwNDcgPyAyIDogY29kZVBvaW50IDw9IDY1NTM1ID8gMyA6IDQ7XG59XG5jb25zdCBNQVhfQklUUyA9IDMyLCBERUZBVUxUX01BUkdJTiA9IDQ7XG5mdW5jdGlvbiBhZGRQYWRkaW5nKHBhdGNoZXMsIG1hcmdpbiA9IERFRkFVTFRfTUFSR0lOKSB7XG4gIGNvbnN0IHBhZGRpbmdMZW5ndGggPSBtYXJnaW47XG4gIGxldCBudWxsUGFkZGluZyA9IFwiXCI7XG4gIGZvciAobGV0IHggPSAxOyB4IDw9IHBhZGRpbmdMZW5ndGg7IHgrKykgbnVsbFBhZGRpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh4KTtcbiAgZm9yIChjb25zdCBwIG9mIHBhdGNoZXMpIHAuc3RhcnQxICs9IHBhZGRpbmdMZW5ndGgsIHAuc3RhcnQyICs9IHBhZGRpbmdMZW5ndGgsIHAudXRmOFN0YXJ0MSArPSBwYWRkaW5nTGVuZ3RoLCBwLnV0ZjhTdGFydDIgKz0gcGFkZGluZ0xlbmd0aDtcbiAgbGV0IHBhdGNoID0gcGF0Y2hlc1swXSwgZGlmZnMgPSBwYXRjaC5kaWZmcztcbiAgaWYgKGRpZmZzLmxlbmd0aCA9PT0gMCB8fCBkaWZmc1swXVswXSAhPT0gRElGRl9FUVVBTCkgZGlmZnMudW5zaGlmdChbRElGRl9FUVVBTCwgbnVsbFBhZGRpbmddKSwgcGF0Y2guc3RhcnQxIC09IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnN0YXJ0MiAtPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC51dGY4U3RhcnQxIC09IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnV0ZjhTdGFydDIgLT0gcGFkZGluZ0xlbmd0aCwgcGF0Y2gubGVuZ3RoMSArPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC5sZW5ndGgyICs9IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgyICs9IHBhZGRpbmdMZW5ndGg7XG4gIGVsc2UgaWYgKHBhZGRpbmdMZW5ndGggPiBkaWZmc1swXVsxXS5sZW5ndGgpIHtcbiAgICBjb25zdCBmaXJzdERpZmZMZW5ndGggPSBkaWZmc1swXVsxXS5sZW5ndGgsIGV4dHJhTGVuZ3RoID0gcGFkZGluZ0xlbmd0aCAtIGZpcnN0RGlmZkxlbmd0aDtcbiAgICBkaWZmc1swXVsxXSA9IG51bGxQYWRkaW5nLnN1YnN0cmluZyhmaXJzdERpZmZMZW5ndGgpICsgZGlmZnNbMF1bMV0sIHBhdGNoLnN0YXJ0MSAtPSBleHRyYUxlbmd0aCwgcGF0Y2guc3RhcnQyIC09IGV4dHJhTGVuZ3RoLCBwYXRjaC51dGY4U3RhcnQxIC09IGV4dHJhTGVuZ3RoLCBwYXRjaC51dGY4U3RhcnQyIC09IGV4dHJhTGVuZ3RoLCBwYXRjaC5sZW5ndGgxICs9IGV4dHJhTGVuZ3RoLCBwYXRjaC5sZW5ndGgyICs9IGV4dHJhTGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSArPSBleHRyYUxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gZXh0cmFMZW5ndGg7XG4gIH1cbiAgaWYgKHBhdGNoID0gcGF0Y2hlc1twYXRjaGVzLmxlbmd0aCAtIDFdLCBkaWZmcyA9IHBhdGNoLmRpZmZzLCBkaWZmcy5sZW5ndGggPT09IDAgfHwgZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMF0gIT09IERJRkZfRVFVQUwpIGRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIG51bGxQYWRkaW5nXSksIHBhdGNoLmxlbmd0aDEgKz0gcGFkZGluZ0xlbmd0aCwgcGF0Y2gubGVuZ3RoMiArPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSArPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMiArPSBwYWRkaW5nTGVuZ3RoO1xuICBlbHNlIGlmIChwYWRkaW5nTGVuZ3RoID4gZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0ubGVuZ3RoKSB7XG4gICAgY29uc3QgZXh0cmFMZW5ndGggPSBwYWRkaW5nTGVuZ3RoIC0gZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0ubGVuZ3RoO1xuICAgIGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdICs9IG51bGxQYWRkaW5nLnN1YnN0cmluZygwLCBleHRyYUxlbmd0aCksIHBhdGNoLmxlbmd0aDEgKz0gZXh0cmFMZW5ndGgsIHBhdGNoLmxlbmd0aDIgKz0gZXh0cmFMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IGV4dHJhTGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMiArPSBleHRyYUxlbmd0aDtcbiAgfVxuICByZXR1cm4gbnVsbFBhZGRpbmc7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXRjaE9iamVjdChzdGFydDEsIHN0YXJ0Mikge1xuICByZXR1cm4ge1xuICAgIGRpZmZzOiBbXSxcbiAgICBzdGFydDEsXG4gICAgc3RhcnQyLFxuICAgIHV0ZjhTdGFydDE6IHN0YXJ0MSxcbiAgICB1dGY4U3RhcnQyOiBzdGFydDIsXG4gICAgbGVuZ3RoMTogMCxcbiAgICBsZW5ndGgyOiAwLFxuICAgIHV0ZjhMZW5ndGgxOiAwLFxuICAgIHV0ZjhMZW5ndGgyOiAwXG4gIH07XG59XG5mdW5jdGlvbiBzcGxpdE1heChwYXRjaGVzLCBtYXJnaW4gPSBERUZBVUxUX01BUkdJTikge1xuICBjb25zdCBwYXRjaFNpemUgPSBNQVhfQklUUztcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgaWYgKHBhdGNoZXNbeF0ubGVuZ3RoMSA8PSBwYXRjaFNpemUpIGNvbnRpbnVlO1xuICAgIGNvbnN0IGJpZ3BhdGNoID0gcGF0Y2hlc1t4XTtcbiAgICBwYXRjaGVzLnNwbGljZSh4LS0sIDEpO1xuICAgIGxldCBzdGFydDEgPSBiaWdwYXRjaC5zdGFydDEsIHN0YXJ0MiA9IGJpZ3BhdGNoLnN0YXJ0MiwgcHJlQ29udGV4dCA9IFwiXCI7XG4gICAgZm9yICg7IGJpZ3BhdGNoLmRpZmZzLmxlbmd0aCAhPT0gMDsgKSB7XG4gICAgICBjb25zdCBwYXRjaCA9IGNyZWF0ZVBhdGNoT2JqZWN0KHN0YXJ0MSAtIHByZUNvbnRleHQubGVuZ3RoLCBzdGFydDIgLSBwcmVDb250ZXh0Lmxlbmd0aCk7XG4gICAgICBsZXQgZW1wdHkgPSAhMDtcbiAgICAgIGlmIChwcmVDb250ZXh0ICE9PSBcIlwiKSB7XG4gICAgICAgIGNvbnN0IHByZWNvbnRleHRCeXRlQ291bnQgPSBjb3VudFV0ZjhCeXRlcyhwcmVDb250ZXh0KTtcbiAgICAgICAgcGF0Y2gubGVuZ3RoMSA9IHByZUNvbnRleHQubGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSA9IHByZWNvbnRleHRCeXRlQ291bnQsIHBhdGNoLmxlbmd0aDIgPSBwcmVDb250ZXh0Lmxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgPSBwcmVjb250ZXh0Qnl0ZUNvdW50LCBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBwcmVDb250ZXh0XSk7XG4gICAgICB9XG4gICAgICBmb3IgKDsgYmlncGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmIHBhdGNoLmxlbmd0aDEgPCBwYXRjaFNpemUgLSBtYXJnaW47ICkge1xuICAgICAgICBjb25zdCBkaWZmVHlwZSA9IGJpZ3BhdGNoLmRpZmZzWzBdWzBdO1xuICAgICAgICBsZXQgZGlmZlRleHQgPSBiaWdwYXRjaC5kaWZmc1swXVsxXSwgZGlmZlRleHRCeXRlQ291bnQgPSBjb3VudFV0ZjhCeXRlcyhkaWZmVGV4dCk7XG4gICAgICAgIGlmIChkaWZmVHlwZSA9PT0gRElGRl9JTlNFUlQpIHtcbiAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZUZXh0Lmxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gZGlmZlRleHRCeXRlQ291bnQsIHN0YXJ0MiArPSBkaWZmVGV4dC5sZW5ndGg7XG4gICAgICAgICAgY29uc3QgZGlmZjIgPSBiaWdwYXRjaC5kaWZmcy5zaGlmdCgpO1xuICAgICAgICAgIGRpZmYyICYmIHBhdGNoLmRpZmZzLnB1c2goZGlmZjIpLCBlbXB0eSA9ICExO1xuICAgICAgICB9IGVsc2UgZGlmZlR5cGUgPT09IERJRkZfREVMRVRFICYmIHBhdGNoLmRpZmZzLmxlbmd0aCA9PT0gMSAmJiBwYXRjaC5kaWZmc1swXVswXSA9PT0gRElGRl9FUVVBTCAmJiBkaWZmVGV4dC5sZW5ndGggPiAyICogcGF0Y2hTaXplID8gKHBhdGNoLmxlbmd0aDEgKz0gZGlmZlRleHQubGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSArPSBkaWZmVGV4dEJ5dGVDb3VudCwgc3RhcnQxICs9IGRpZmZUZXh0Lmxlbmd0aCwgZW1wdHkgPSAhMSwgcGF0Y2guZGlmZnMucHVzaChbZGlmZlR5cGUsIGRpZmZUZXh0XSksIGJpZ3BhdGNoLmRpZmZzLnNoaWZ0KCkpIDogKGRpZmZUZXh0ID0gZGlmZlRleHQuc3Vic3RyaW5nKDAsIHBhdGNoU2l6ZSAtIHBhdGNoLmxlbmd0aDEgLSBtYXJnaW4pLCBkaWZmVGV4dEJ5dGVDb3VudCA9IGNvdW50VXRmOEJ5dGVzKGRpZmZUZXh0KSwgcGF0Y2gubGVuZ3RoMSArPSBkaWZmVGV4dC5sZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IGRpZmZUZXh0Qnl0ZUNvdW50LCBzdGFydDEgKz0gZGlmZlRleHQubGVuZ3RoLCBkaWZmVHlwZSA9PT0gRElGRl9FUVVBTCA/IChwYXRjaC5sZW5ndGgyICs9IGRpZmZUZXh0Lmxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gZGlmZlRleHRCeXRlQ291bnQsIHN0YXJ0MiArPSBkaWZmVGV4dC5sZW5ndGgpIDogZW1wdHkgPSAhMSwgcGF0Y2guZGlmZnMucHVzaChbZGlmZlR5cGUsIGRpZmZUZXh0XSksIGRpZmZUZXh0ID09PSBiaWdwYXRjaC5kaWZmc1swXVsxXSA/IGJpZ3BhdGNoLmRpZmZzLnNoaWZ0KCkgOiBiaWdwYXRjaC5kaWZmc1swXVsxXSA9IGJpZ3BhdGNoLmRpZmZzWzBdWzFdLnN1YnN0cmluZyhkaWZmVGV4dC5sZW5ndGgpKTtcbiAgICAgIH1cbiAgICAgIHByZUNvbnRleHQgPSBkaWZmVGV4dDIocGF0Y2guZGlmZnMpLCBwcmVDb250ZXh0ID0gcHJlQ29udGV4dC5zdWJzdHJpbmcocHJlQ29udGV4dC5sZW5ndGggLSBtYXJnaW4pO1xuICAgICAgY29uc3QgcG9zdENvbnRleHQgPSBkaWZmVGV4dDEoYmlncGF0Y2guZGlmZnMpLnN1YnN0cmluZygwLCBtYXJnaW4pLCBwb3N0Q29udGV4dEJ5dGVDb3VudCA9IGNvdW50VXRmOEJ5dGVzKHBvc3RDb250ZXh0KTtcbiAgICAgIHBvc3RDb250ZXh0ICE9PSBcIlwiICYmIChwYXRjaC5sZW5ndGgxICs9IHBvc3RDb250ZXh0Lmxlbmd0aCwgcGF0Y2gubGVuZ3RoMiArPSBwb3N0Q29udGV4dC5sZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IHBvc3RDb250ZXh0Qnl0ZUNvdW50LCBwYXRjaC51dGY4TGVuZ3RoMiArPSBwb3N0Q29udGV4dEJ5dGVDb3VudCwgcGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmIHBhdGNoLmRpZmZzW3BhdGNoLmRpZmZzLmxlbmd0aCAtIDFdWzBdID09PSBESUZGX0VRVUFMID8gcGF0Y2guZGlmZnNbcGF0Y2guZGlmZnMubGVuZ3RoIC0gMV1bMV0gKz0gcG9zdENvbnRleHQgOiBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBwb3N0Q29udGV4dF0pKSwgZW1wdHkgfHwgcGF0Y2hlcy5zcGxpY2UoKyt4LCAwLCBwYXRjaCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhcHBseShwYXRjaGVzLCBvcmlnaW5hbFRleHQsIG9wdHMgPSB7fSkge1xuICBpZiAodHlwZW9mIHBhdGNoZXMgPT0gXCJzdHJpbmdcIikgdGhyb3cgbmV3IEVycm9yKFwiUGF0Y2hlcyBtdXN0IGJlIGFuIGFycmF5IC0gcGFzcyB0aGUgcGF0Y2ggdG8gYHBhcnNlUGF0Y2goKWAgZmlyc3RcIik7XG4gIGxldCB0ZXh0ID0gb3JpZ2luYWxUZXh0O1xuICBpZiAocGF0Y2hlcy5sZW5ndGggPT09IDApIHJldHVybiBbdGV4dCwgW11dO1xuICBjb25zdCBwYXJzZWQgPSBhZGp1c3RJbmRpY2llc1RvVWNzMihwYXRjaGVzLCB0ZXh0LCB7XG4gICAgYWxsb3dFeGNlZWRpbmdJbmRpY2VzOiBvcHRzLmFsbG93RXhjZWVkaW5nSW5kaWNlc1xuICB9KSwgbWFyZ2luID0gb3B0cy5tYXJnaW4gfHwgREVGQVVMVF9NQVJHSU4sIGRlbGV0ZVRocmVzaG9sZCA9IG9wdHMuZGVsZXRlVGhyZXNob2xkIHx8IDAuNCwgbnVsbFBhZGRpbmcgPSBhZGRQYWRkaW5nKHBhcnNlZCwgbWFyZ2luKTtcbiAgdGV4dCA9IG51bGxQYWRkaW5nICsgdGV4dCArIG51bGxQYWRkaW5nLCBzcGxpdE1heChwYXJzZWQsIG1hcmdpbik7XG4gIGxldCBkZWx0YSA9IDA7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBwYXJzZWQubGVuZ3RoOyB4KyspIHtcbiAgICBjb25zdCBleHBlY3RlZExvYyA9IHBhcnNlZFt4XS5zdGFydDIgKyBkZWx0YSwgdGV4dDEgPSBkaWZmVGV4dDEocGFyc2VkW3hdLmRpZmZzKTtcbiAgICBsZXQgc3RhcnRMb2MsIGVuZExvYyA9IC0xO1xuICAgIGlmICh0ZXh0MS5sZW5ndGggPiBNQVhfQklUUyA/IChzdGFydExvYyA9IG1hdGNoKHRleHQsIHRleHQxLnN1YnN0cmluZygwLCBNQVhfQklUUyksIGV4cGVjdGVkTG9jKSwgc3RhcnRMb2MgIT09IC0xICYmIChlbmRMb2MgPSBtYXRjaCh0ZXh0LCB0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gTUFYX0JJVFMpLCBleHBlY3RlZExvYyArIHRleHQxLmxlbmd0aCAtIE1BWF9CSVRTKSwgKGVuZExvYyA9PT0gLTEgfHwgc3RhcnRMb2MgPj0gZW5kTG9jKSAmJiAoc3RhcnRMb2MgPSAtMSkpKSA6IHN0YXJ0TG9jID0gbWF0Y2godGV4dCwgdGV4dDEsIGV4cGVjdGVkTG9jKSwgc3RhcnRMb2MgPT09IC0xKSByZXN1bHRzW3hdID0gITEsIGRlbHRhIC09IHBhcnNlZFt4XS5sZW5ndGgyIC0gcGFyc2VkW3hdLmxlbmd0aDE7XG4gICAgZWxzZSB7XG4gICAgICByZXN1bHRzW3hdID0gITAsIGRlbHRhID0gc3RhcnRMb2MgLSBleHBlY3RlZExvYztcbiAgICAgIGxldCB0ZXh0MjtcbiAgICAgIGlmIChlbmRMb2MgPT09IC0xID8gdGV4dDIgPSB0ZXh0LnN1YnN0cmluZyhzdGFydExvYywgc3RhcnRMb2MgKyB0ZXh0MS5sZW5ndGgpIDogdGV4dDIgPSB0ZXh0LnN1YnN0cmluZyhzdGFydExvYywgZW5kTG9jICsgTUFYX0JJVFMpLCB0ZXh0MSA9PT0gdGV4dDIpIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydExvYykgKyBkaWZmVGV4dDIocGFyc2VkW3hdLmRpZmZzKSArIHRleHQuc3Vic3RyaW5nKHN0YXJ0TG9jICsgdGV4dDEubGVuZ3RoKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBsZXQgZGlmZnMgPSBkaWZmKHRleHQxLCB0ZXh0Miwge1xuICAgICAgICAgIGNoZWNrTGluZXM6ICExXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGV4dDEubGVuZ3RoID4gTUFYX0JJVFMgJiYgbGV2ZW5zaHRlaW4oZGlmZnMpIC8gdGV4dDEubGVuZ3RoID4gZGVsZXRlVGhyZXNob2xkKSByZXN1bHRzW3hdID0gITE7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRpZmZzID0gY2xlYW51cFNlbWFudGljTG9zc2xlc3MoZGlmZnMpO1xuICAgICAgICAgIGxldCBpbmRleDEgPSAwLCBpbmRleDIgPSAwO1xuICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgcGFyc2VkW3hdLmRpZmZzLmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgICBjb25zdCBtb2QgPSBwYXJzZWRbeF0uZGlmZnNbeV07XG4gICAgICAgICAgICBtb2RbMF0gIT09IERJRkZfRVFVQUwgJiYgKGluZGV4MiA9IHhJbmRleChkaWZmcywgaW5kZXgxKSksIG1vZFswXSA9PT0gRElGRl9JTlNFUlQgPyB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgc3RhcnRMb2MgKyBpbmRleDIpICsgbW9kWzFdICsgdGV4dC5zdWJzdHJpbmcoc3RhcnRMb2MgKyBpbmRleDIpIDogbW9kWzBdID09PSBESUZGX0RFTEVURSAmJiAodGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0TG9jICsgaW5kZXgyKSArIHRleHQuc3Vic3RyaW5nKHN0YXJ0TG9jICsgeEluZGV4KGRpZmZzLCBpbmRleDEgKyBtb2RbMV0ubGVuZ3RoKSkpLCBtb2RbMF0gIT09IERJRkZfREVMRVRFICYmIChpbmRleDEgKz0gbW9kWzFdLmxlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcobnVsbFBhZGRpbmcubGVuZ3RoLCB0ZXh0Lmxlbmd0aCAtIG51bGxQYWRkaW5nLmxlbmd0aCksIFt0ZXh0LCByZXN1bHRzXTtcbn1cbmNvbnN0IHBhdGNoSGVhZGVyID0gL15AQCAtKFxcZCspLD8oXFxkKikgXFwrKFxcZCspLD8oXFxkKikgQEAkLztcbmZ1bmN0aW9uIHBhcnNlKHRleHRsaW5lKSB7XG4gIGlmICghdGV4dGxpbmUpIHJldHVybiBbXTtcbiAgY29uc3QgcGF0Y2hlcyA9IFtdLCBsaW5lcyA9IHRleHRsaW5lLnNwbGl0KGBcbmApO1xuICBsZXQgdGV4dFBvaW50ZXIgPSAwO1xuICBmb3IgKDsgdGV4dFBvaW50ZXIgPCBsaW5lcy5sZW5ndGg7ICkge1xuICAgIGNvbnN0IG0gPSBsaW5lc1t0ZXh0UG9pbnRlcl0ubWF0Y2gocGF0Y2hIZWFkZXIpO1xuICAgIGlmICghbSkgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhdGNoIHN0cmluZzogJHtsaW5lc1t0ZXh0UG9pbnRlcl19YCk7XG4gICAgY29uc3QgcGF0Y2ggPSBjcmVhdGVQYXRjaE9iamVjdCh0b0ludChtWzFdKSwgdG9JbnQobVszXSkpO1xuICAgIGZvciAocGF0Y2hlcy5wdXNoKHBhdGNoKSwgbVsyXSA9PT0gXCJcIiA/IChwYXRjaC5zdGFydDEtLSwgcGF0Y2gudXRmOFN0YXJ0MS0tLCBwYXRjaC5sZW5ndGgxID0gMSwgcGF0Y2gudXRmOExlbmd0aDEgPSAxKSA6IG1bMl0gPT09IFwiMFwiID8gKHBhdGNoLmxlbmd0aDEgPSAwLCBwYXRjaC51dGY4TGVuZ3RoMSA9IDApIDogKHBhdGNoLnN0YXJ0MS0tLCBwYXRjaC51dGY4U3RhcnQxLS0sIHBhdGNoLnV0ZjhMZW5ndGgxID0gdG9JbnQobVsyXSksIHBhdGNoLmxlbmd0aDEgPSBwYXRjaC51dGY4TGVuZ3RoMSksIG1bNF0gPT09IFwiXCIgPyAocGF0Y2guc3RhcnQyLS0sIHBhdGNoLnV0ZjhTdGFydDItLSwgcGF0Y2gubGVuZ3RoMiA9IDEsIHBhdGNoLnV0ZjhMZW5ndGgyID0gMSkgOiBtWzRdID09PSBcIjBcIiA/IChwYXRjaC5sZW5ndGgyID0gMCwgcGF0Y2gudXRmOExlbmd0aDIgPSAwKSA6IChwYXRjaC5zdGFydDItLSwgcGF0Y2gudXRmOFN0YXJ0Mi0tLCBwYXRjaC51dGY4TGVuZ3RoMiA9IHRvSW50KG1bNF0pLCBwYXRjaC5sZW5ndGgyID0gcGF0Y2gudXRmOExlbmd0aDIpLCB0ZXh0UG9pbnRlcisrOyB0ZXh0UG9pbnRlciA8IGxpbmVzLmxlbmd0aDsgKSB7XG4gICAgICBjb25zdCBjdXJyZW50TGluZSA9IGxpbmVzW3RleHRQb2ludGVyXSwgc2lnbiA9IGN1cnJlbnRMaW5lLmNoYXJBdCgwKTtcbiAgICAgIGlmIChzaWduID09PSBcIkBcIikgYnJlYWs7XG4gICAgICBpZiAoc2lnbiA9PT0gXCJcIikge1xuICAgICAgICB0ZXh0UG9pbnRlcisrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBsaW5lO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGluZSA9IGRlY29kZVVSSShjdXJyZW50TGluZS5zbGljZSgxKSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbGxlZ2FsIGVzY2FwZSBpbiBwYXJzZTogJHtjdXJyZW50TGluZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHV0ZjhEaWZmID0gY291bnRVdGY4Qnl0ZXMobGluZSkgLSBsaW5lLmxlbmd0aDtcbiAgICAgIGlmIChzaWduID09PSBcIi1cIikgcGF0Y2guZGlmZnMucHVzaChbRElGRl9ERUxFVEUsIGxpbmVdKSwgcGF0Y2gubGVuZ3RoMSAtPSB1dGY4RGlmZjtcbiAgICAgIGVsc2UgaWYgKHNpZ24gPT09IFwiK1wiKSBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0lOU0VSVCwgbGluZV0pLCBwYXRjaC5sZW5ndGgyIC09IHV0ZjhEaWZmO1xuICAgICAgZWxzZSBpZiAoc2lnbiA9PT0gXCIgXCIpIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIGxpbmVdKSwgcGF0Y2gubGVuZ3RoMSAtPSB1dGY4RGlmZiwgcGF0Y2gubGVuZ3RoMiAtPSB1dGY4RGlmZjtcbiAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhdGNoIG1vZGUgXCIke3NpZ259XCIgaW46ICR7bGluZX1gKTtcbiAgICAgIHRleHRQb2ludGVyKys7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXRjaGVzO1xufVxuZnVuY3Rpb24gdG9JbnQobnVtKSB7XG4gIHJldHVybiBwYXJzZUludChudW0sIDEwKTtcbn1cbmNvbnN0IENVUlJFTlRfVU5ET19TVEVQID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBnZXRDdXJyZW50VW5kb1N0ZXBJZChlZGl0b3IpIHtcbiAgcmV0dXJuIENVUlJFTlRfVU5ET19TVEVQLmdldChlZGl0b3IpPy51bmRvU3RlcElkO1xufVxuZnVuY3Rpb24gY3JlYXRlVW5kb1N0ZXAoZWRpdG9yKSB7XG4gIENVUlJFTlRfVU5ET19TVEVQLnNldChlZGl0b3IsIHtcbiAgICB1bmRvU3RlcElkOiBkZWZhdWx0S2V5R2VuZXJhdG9yKClcbiAgfSk7XG59XG5mdW5jdGlvbiBjbGVhclVuZG9TdGVwKGVkaXRvcikge1xuICBDVVJSRU5UX1VORE9fU1RFUC5zZXQoZWRpdG9yLCB2b2lkIDApO1xufVxuY29uc3QgZGVidWckYiA9IGRlYnVnV2l0aE5hbWUoXCJwbHVnaW46d2l0aFVuZG9SZWRvXCIpLCBTQVZJTkcgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgUkVNT1RFX1BBVENIRVMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgVU5ET19TVEVQX0xJTUlUID0gMWUzLCBpc1NhdmluZyA9IChlZGl0b3IpID0+IHtcbiAgY29uc3Qgc3RhdGUgPSBTQVZJTkcuZ2V0KGVkaXRvcik7XG4gIHJldHVybiBzdGF0ZSA9PT0gdm9pZCAwID8gITAgOiBzdGF0ZTtcbn0sIGdldFJlbW90ZVBhdGNoZXMgPSAoZWRpdG9yKSA9PiAoUkVNT1RFX1BBVENIRVMuZ2V0KGVkaXRvcikgfHwgUkVNT1RFX1BBVENIRVMuc2V0KGVkaXRvciwgW10pLCBSRU1PVEVfUEFUQ0hFUy5nZXQoZWRpdG9yKSB8fCBbXSk7XG5mdW5jdGlvbiBjcmVhdGVXaXRoVW5kb1JlZG8ob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgZWRpdG9yQWN0b3JcbiAgfSA9IG9wdGlvbnM7XG4gIHJldHVybiAoZWRpdG9yKSA9PiB7XG4gICAgbGV0IHByZXZpb3VzU25hcHNob3QgPSBmcm9tU2xhdGVWYWx1ZShlZGl0b3IuY2hpbGRyZW4sIGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEuYmxvY2submFtZSk7XG4gICAgY29uc3QgcmVtb3RlUGF0Y2hlcyA9IGdldFJlbW90ZVBhdGNoZXMoZWRpdG9yKTtcbiAgICBsZXQgcHJldmlvdXNVbmRvU3RlcElkID0gZ2V0Q3VycmVudFVuZG9TdGVwSWQoZWRpdG9yKTtcbiAgICBvcHRpb25zLnN1YnNjcmlwdGlvbnMucHVzaCgoKSA9PiB7XG4gICAgICBkZWJ1ZyRiKFwiU3Vic2NyaWJpbmcgdG8gcGF0Y2hlc1wiKTtcbiAgICAgIGNvbnN0IHN1YiA9IGVkaXRvckFjdG9yLm9uKFwicGF0Y2hlc1wiLCAoe1xuICAgICAgICBwYXRjaGVzLFxuICAgICAgICBzbmFwc2hvdFxuICAgICAgfSkgPT4ge1xuICAgICAgICBsZXQgcmVzZXQgPSAhMTtcbiAgICAgICAgcGF0Y2hlcy5mb3JFYWNoKChwYXRjaCkgPT4ge1xuICAgICAgICAgIGlmICghcmVzZXQgJiYgcGF0Y2gub3JpZ2luICE9PSBcImxvY2FsXCIgJiYgcmVtb3RlUGF0Y2hlcykge1xuICAgICAgICAgICAgaWYgKHBhdGNoLnR5cGUgPT09IFwidW5zZXRcIiAmJiBwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBkZWJ1ZyRiKFwiU29tZW9uZSBlbHNlIGNsZWFyZWQgdGhlIGNvbnRlbnQsIHJlc2V0dGluZyB1bmRvL3JlZG8gaGlzdG9yeVwiKSwgZWRpdG9yLmhpc3RvcnkgPSB7XG4gICAgICAgICAgICAgICAgdW5kb3M6IFtdLFxuICAgICAgICAgICAgICAgIHJlZG9zOiBbXVxuICAgICAgICAgICAgICB9LCByZW1vdGVQYXRjaGVzLnNwbGljZSgwLCByZW1vdGVQYXRjaGVzLmxlbmd0aCksIFNBVklORy5zZXQoZWRpdG9yLCAhMCksIHJlc2V0ID0gITA7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbW90ZVBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgIHBhdGNoLFxuICAgICAgICAgICAgICB0aW1lOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgc25hcHNob3QsXG4gICAgICAgICAgICAgIHByZXZpb3VzU25hcHNob3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksIHByZXZpb3VzU25hcHNob3QgPSBzbmFwc2hvdDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZGVidWckYihcIlVuc3Vic2NyaWJpbmcgdG8gcGF0Y2hlc1wiKSwgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9O1xuICAgIH0pLCBlZGl0b3IuaGlzdG9yeSA9IHtcbiAgICAgIHVuZG9zOiBbXSxcbiAgICAgIHJlZG9zOiBbXVxuICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgYXBwbHk6IGFwcGx5MlxuICAgIH0gPSBlZGl0b3I7XG4gICAgcmV0dXJuIGVkaXRvci5hcHBseSA9IChvcCkgPT4ge1xuICAgICAgaWYgKGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkubWF0Y2hlcyh7XG4gICAgICAgIFwiZWRpdCBtb2RlXCI6IFwicmVhZCBvbmx5XCJcbiAgICAgIH0pKSB7XG4gICAgICAgIGFwcGx5MihvcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc0NoYW5naW5nUmVtb3RlbHkoZWRpdG9yKSkge1xuICAgICAgICBhcHBseTIob3ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNVbmRvaW5nKGVkaXRvcikgfHwgaXNSZWRvaW5nKGVkaXRvcikpIHtcbiAgICAgICAgYXBwbHkyKG9wKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBvcGVyYXRpb25zLFxuICAgICAgICBoaXN0b3J5XG4gICAgICB9ID0gZWRpdG9yLCB7XG4gICAgICAgIHVuZG9zXG4gICAgICB9ID0gaGlzdG9yeSwgc3RlcCA9IHVuZG9zW3VuZG9zLmxlbmd0aCAtIDFdLCBsYXN0T3AgPSBzdGVwICYmIHN0ZXAub3BlcmF0aW9ucyAmJiBzdGVwLm9wZXJhdGlvbnNbc3RlcC5vcGVyYXRpb25zLmxlbmd0aCAtIDFdLCBvdmVyd3JpdGUgPSBzaG91bGRPdmVyd3JpdGUob3AsIGxhc3RPcCksIHNhdmUgPSBpc1NhdmluZyhlZGl0b3IpLCBjdXJyZW50VW5kb1N0ZXBJZCA9IGdldEN1cnJlbnRVbmRvU3RlcElkKGVkaXRvcik7XG4gICAgICBsZXQgbWVyZ2UgPSBjdXJyZW50VW5kb1N0ZXBJZCA9PT0gcHJldmlvdXNVbmRvU3RlcElkO1xuICAgICAgaWYgKHNhdmUpIHtcbiAgICAgICAgaWYgKHN0ZXAgPyBvcGVyYXRpb25zLmxlbmd0aCA9PT0gMCAmJiAobWVyZ2UgPSBjdXJyZW50VW5kb1N0ZXBJZCA9PT0gdm9pZCAwICYmIHByZXZpb3VzVW5kb1N0ZXBJZCA9PT0gdm9pZCAwID8gc2hvdWxkTWVyZ2Uob3AsIGxhc3RPcCkgfHwgb3ZlcndyaXRlIDogbWVyZ2UpIDogbWVyZ2UgPSAhMSwgc3RlcCAmJiBtZXJnZSlcbiAgICAgICAgICBzdGVwLm9wZXJhdGlvbnMucHVzaChvcCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG5ld1N0ZXAgPSB7XG4gICAgICAgICAgICBvcGVyYXRpb25zOiBbLi4uZWRpdG9yLnNlbGVjdGlvbiA9PT0gbnVsbCA/IFtdIDogW2NyZWF0ZVNlbGVjdE9wZXJhdGlvbihlZGl0b3IpXSwgb3BdLFxuICAgICAgICAgICAgdGltZXN0YW1wOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxuICAgICAgICAgIH07XG4gICAgICAgICAgdW5kb3MucHVzaChuZXdTdGVwKSwgZGVidWckYihcIkNyZWF0ZWQgbmV3IHVuZG8gc3RlcFwiLCBzdGVwKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgdW5kb3MubGVuZ3RoID4gVU5ET19TVEVQX0xJTUlUOyApXG4gICAgICAgICAgdW5kb3Muc2hpZnQoKTtcbiAgICAgICAgc2hvdWxkQ2xlYXIob3ApICYmIChoaXN0b3J5LnJlZG9zID0gW10pO1xuICAgICAgfVxuICAgICAgcHJldmlvdXNVbmRvU3RlcElkID0gY3VycmVudFVuZG9TdGVwSWQsIGFwcGx5MihvcCk7XG4gICAgfSwgZWRpdG9yO1xuICB9O1xufVxuY29uc3QgaGlzdG9yeVVuZG9PcGVyYXRpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIG9wZXJhdGlvblxufSkgPT4ge1xuICBjb25zdCBlZGl0b3IgPSBvcGVyYXRpb24uZWRpdG9yLCB7XG4gICAgdW5kb3NcbiAgfSA9IGVkaXRvci5oaXN0b3J5LCByZW1vdGVQYXRjaGVzID0gZ2V0UmVtb3RlUGF0Y2hlcyhlZGl0b3IpO1xuICBpZiAodW5kb3MubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHN0ZXAgPSB1bmRvc1t1bmRvcy5sZW5ndGggLSAxXTtcbiAgICBpZiAoZGVidWckYihcIlVuZG9pbmdcIiwgc3RlcCksIHN0ZXAub3BlcmF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBvdGhlclBhdGNoZXMgPSByZW1vdGVQYXRjaGVzLmZpbHRlcigoaXRlbSkgPT4gaXRlbS50aW1lID49IHN0ZXAudGltZXN0YW1wKTtcbiAgICAgIGxldCB0cmFuc2Zvcm1lZE9wZXJhdGlvbnMgPSBzdGVwLm9wZXJhdGlvbnM7XG4gICAgICBvdGhlclBhdGNoZXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICB0cmFuc2Zvcm1lZE9wZXJhdGlvbnMgPSBmbGF0dGVuKHRyYW5zZm9ybWVkT3BlcmF0aW9ucy5tYXAoKG9wKSA9PiB0cmFuc2Zvcm1PcGVyYXRpb24oZWRpdG9yLCBpdGVtLnBhdGNoLCBvcCwgaXRlbS5zbmFwc2hvdCwgaXRlbS5wcmV2aW91c1NuYXBzaG90KSkpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCByZXZlcnNlZE9wZXJhdGlvbnMgPSB0cmFuc2Zvcm1lZE9wZXJhdGlvbnMubWFwKE9wZXJhdGlvbi5pbnZlcnNlKS5yZXZlcnNlKCk7XG4gICAgICB0cnkge1xuICAgICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgIHdpdGhVbmRvaW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgd2l0aG91dFNhdmluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgcmV2ZXJzZWRPcGVyYXRpb25zLmZvckVhY2goKG9wKSA9PiB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLmFwcGx5KG9wKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZGVidWckYihcIkNvdWxkIG5vdCBwZXJmb3JtIHVuZG8gc3RlcFwiLCBlcnIpLCByZW1vdGVQYXRjaGVzLnNwbGljZSgwLCByZW1vdGVQYXRjaGVzLmxlbmd0aCksIFRyYW5zZm9ybXMuZGVzZWxlY3QoZWRpdG9yKSwgZWRpdG9yLmhpc3RvcnkgPSB7XG4gICAgICAgICAgdW5kb3M6IFtdLFxuICAgICAgICAgIHJlZG9zOiBbXVxuICAgICAgICB9LCBTQVZJTkcuc2V0KGVkaXRvciwgITApLCBzZXRJc1VuZG9pbmcoZWRpdG9yLCAhMSksIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlZGl0b3IuaGlzdG9yeS5yZWRvcy5wdXNoKHN0ZXApLCBlZGl0b3IuaGlzdG9yeS51bmRvcy5wb3AoKTtcbiAgICB9XG4gIH1cbn0sIGhpc3RvcnlSZWRvT3BlcmF0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBvcGVyYXRpb25cbn0pID0+IHtcbiAgY29uc3QgZWRpdG9yID0gb3BlcmF0aW9uLmVkaXRvciwge1xuICAgIHJlZG9zXG4gIH0gPSBlZGl0b3IuaGlzdG9yeSwgcmVtb3RlUGF0Y2hlcyA9IGdldFJlbW90ZVBhdGNoZXMoZWRpdG9yKTtcbiAgaWYgKHJlZG9zLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBzdGVwID0gcmVkb3NbcmVkb3MubGVuZ3RoIC0gMV07XG4gICAgaWYgKGRlYnVnJGIoXCJSZWRvaW5nXCIsIHN0ZXApLCBzdGVwLm9wZXJhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgb3RoZXJQYXRjaGVzID0gcmVtb3RlUGF0Y2hlcy5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0udGltZSA+PSBzdGVwLnRpbWVzdGFtcCk7XG4gICAgICBsZXQgdHJhbnNmb3JtZWRPcGVyYXRpb25zID0gc3RlcC5vcGVyYXRpb25zO1xuICAgICAgb3RoZXJQYXRjaGVzLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgdHJhbnNmb3JtZWRPcGVyYXRpb25zID0gZmxhdHRlbih0cmFuc2Zvcm1lZE9wZXJhdGlvbnMubWFwKChvcCkgPT4gdHJhbnNmb3JtT3BlcmF0aW9uKGVkaXRvciwgaXRlbS5wYXRjaCwgb3AsIGl0ZW0uc25hcHNob3QsIGl0ZW0ucHJldmlvdXNTbmFwc2hvdCkpKTtcbiAgICAgIH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICB3aXRoUmVkb2luZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgIHdpdGhvdXRTYXZpbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybWVkT3BlcmF0aW9ucy5mb3JFYWNoKChvcCkgPT4ge1xuICAgICAgICAgICAgICAgIGVkaXRvci5hcHBseShvcCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGRlYnVnJGIoXCJDb3VsZCBub3QgcGVyZm9ybSByZWRvIHN0ZXBcIiwgZXJyKSwgcmVtb3RlUGF0Y2hlcy5zcGxpY2UoMCwgcmVtb3RlUGF0Y2hlcy5sZW5ndGgpLCBUcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvciksIGVkaXRvci5oaXN0b3J5ID0ge1xuICAgICAgICAgIHVuZG9zOiBbXSxcbiAgICAgICAgICByZWRvczogW11cbiAgICAgICAgfSwgU0FWSU5HLnNldChlZGl0b3IsICEwKSwgc2V0SXNSZWRvaW5nKGVkaXRvciwgITEpLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWRpdG9yLmhpc3RvcnkudW5kb3MucHVzaChzdGVwKSwgZWRpdG9yLmhpc3RvcnkucmVkb3MucG9wKCk7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gdHJhbnNmb3JtT3BlcmF0aW9uKGVkaXRvciwgcGF0Y2gsIG9wZXJhdGlvbiwgc25hcHNob3QsIHByZXZpb3VzU25hcHNob3QpIHtcbiAgY29uc3QgdHJhbnNmb3JtZWRPcGVyYXRpb24gPSB7XG4gICAgLi4ub3BlcmF0aW9uXG4gIH07XG4gIGlmIChwYXRjaC50eXBlID09PSBcImluc2VydFwiICYmIHBhdGNoLnBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgaW5zZXJ0QmxvY2tJbmRleCA9IChzbmFwc2hvdCB8fCBbXSkuZmluZEluZGV4KChibGspID0+IGlzRXF1YWwoe1xuICAgICAgX2tleTogYmxrLl9rZXlcbiAgICB9LCBwYXRjaC5wYXRoWzBdKSk7XG4gICAgcmV0dXJuIGRlYnVnJGIoYEFkanVzdGluZyBibG9jayBwYXRoICgrJHtwYXRjaC5pdGVtcy5sZW5ndGh9KSBmb3IgJyR7dHJhbnNmb3JtZWRPcGVyYXRpb24udHlwZX0nIG9wZXJhdGlvbiBhbmQgcGF0Y2ggJyR7cGF0Y2gudHlwZX0nYCksIFthZGp1c3RCbG9ja1BhdGgodHJhbnNmb3JtZWRPcGVyYXRpb24sIHBhdGNoLml0ZW1zLmxlbmd0aCwgaW5zZXJ0QmxvY2tJbmRleCldO1xuICB9XG4gIGlmIChwYXRjaC50eXBlID09PSBcInVuc2V0XCIgJiYgcGF0Y2gucGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCB1bnNldEJsb2NrSW5kZXggPSAocHJldmlvdXNTbmFwc2hvdCB8fCBbXSkuZmluZEluZGV4KChibGspID0+IGlzRXF1YWwoe1xuICAgICAgX2tleTogYmxrLl9rZXlcbiAgICB9LCBwYXRjaC5wYXRoWzBdKSk7XG4gICAgcmV0dXJuIFwicGF0aFwiIGluIHRyYW5zZm9ybWVkT3BlcmF0aW9uICYmIEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRPcGVyYXRpb24ucGF0aCkgJiYgdHJhbnNmb3JtZWRPcGVyYXRpb24ucGF0aFswXSA9PT0gdW5zZXRCbG9ja0luZGV4ID8gKGRlYnVnJGIoXCJTa2lwcGluZyB0cmFuc2Zvcm1hdGlvbiB0aGF0IHRhcmdldGVkIHJlbW92ZWQgYmxvY2tcIiksIFtdKSA6IFthZGp1c3RCbG9ja1BhdGgodHJhbnNmb3JtZWRPcGVyYXRpb24sIC0xLCB1bnNldEJsb2NrSW5kZXgpXTtcbiAgfVxuICBpZiAocGF0Y2gudHlwZSA9PT0gXCJ1bnNldFwiICYmIHBhdGNoLnBhdGgubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBkZWJ1ZyRiKGBBZGp1c3Rpbmcgc2VsZWN0aW9uIGZvciB1bnNldCBldmVyeXRoaW5nIHBhdGNoIGFuZCAke29wZXJhdGlvbi50eXBlfSBvcGVyYXRpb25gKSwgW107XG4gIGlmIChwYXRjaC50eXBlID09PSBcImRpZmZNYXRjaFBhdGNoXCIpIHtcbiAgICBjb25zdCBvcGVyYXRpb25UYXJnZXRCbG9jayA9IGZpbmRPcGVyYXRpb25UYXJnZXRCbG9jayhlZGl0b3IsIHRyYW5zZm9ybWVkT3BlcmF0aW9uKTtcbiAgICByZXR1cm4gIW9wZXJhdGlvblRhcmdldEJsb2NrIHx8ICFpc0VxdWFsKHtcbiAgICAgIF9rZXk6IG9wZXJhdGlvblRhcmdldEJsb2NrLl9rZXlcbiAgICB9LCBwYXRjaC5wYXRoWzBdKSA/IFt0cmFuc2Zvcm1lZE9wZXJhdGlvbl0gOiAocGFyc2UocGF0Y2gudmFsdWUpLmZvckVhY2goKGRpZmZQYXRjaCkgPT4ge1xuICAgICAgbGV0IGFkanVzdE9mZnNldEJ5ID0gMCwgY2hhbmdlZE9mZnNldCA9IGRpZmZQYXRjaC51dGY4U3RhcnQxO1xuICAgICAgY29uc3Qge1xuICAgICAgICBkaWZmc1xuICAgICAgfSA9IGRpZmZQYXRjaDtcbiAgICAgIGlmIChkaWZmcy5mb3JFYWNoKChkaWZmMiwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgW2RpZmZUeXBlLCB0ZXh0XSA9IGRpZmYyO1xuICAgICAgICBkaWZmVHlwZSA9PT0gRElGRl9JTlNFUlQgPyAoYWRqdXN0T2Zmc2V0QnkgKz0gdGV4dC5sZW5ndGgsIGNoYW5nZWRPZmZzZXQgKz0gdGV4dC5sZW5ndGgpIDogZGlmZlR5cGUgPT09IERJRkZfREVMRVRFID8gKGFkanVzdE9mZnNldEJ5IC09IHRleHQubGVuZ3RoLCBjaGFuZ2VkT2Zmc2V0IC09IHRleHQubGVuZ3RoKSA6IGRpZmZUeXBlID09PSBESUZGX0VRVUFMICYmIChkaWZmcy5zbGljZShpbmRleCkuZXZlcnkoKFtkVHlwZV0pID0+IGRUeXBlID09PSBESUZGX0VRVUFMKSB8fCAoY2hhbmdlZE9mZnNldCArPSB0ZXh0Lmxlbmd0aCkpO1xuICAgICAgfSksIHRyYW5zZm9ybWVkT3BlcmF0aW9uLnR5cGUgPT09IFwiaW5zZXJ0X3RleHRcIiAmJiBjaGFuZ2VkT2Zmc2V0IDwgdHJhbnNmb3JtZWRPcGVyYXRpb24ub2Zmc2V0ICYmICh0cmFuc2Zvcm1lZE9wZXJhdGlvbi5vZmZzZXQgKz0gYWRqdXN0T2Zmc2V0QnkpLCB0cmFuc2Zvcm1lZE9wZXJhdGlvbi50eXBlID09PSBcInJlbW92ZV90ZXh0XCIgJiYgY2hhbmdlZE9mZnNldCA8PSB0cmFuc2Zvcm1lZE9wZXJhdGlvbi5vZmZzZXQgLSB0cmFuc2Zvcm1lZE9wZXJhdGlvbi50ZXh0Lmxlbmd0aCAmJiAodHJhbnNmb3JtZWRPcGVyYXRpb24ub2Zmc2V0ICs9IGFkanVzdE9mZnNldEJ5KSwgdHJhbnNmb3JtZWRPcGVyYXRpb24udHlwZSA9PT0gXCJzZXRfc2VsZWN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgY3VycmVudEZvY3VzID0gdHJhbnNmb3JtZWRPcGVyYXRpb24ucHJvcGVydGllcz8uZm9jdXMgPyB7XG4gICAgICAgICAgLi4udHJhbnNmb3JtZWRPcGVyYXRpb24ucHJvcGVydGllcy5mb2N1c1xuICAgICAgICB9IDogdm9pZCAwLCBjdXJyZW50QW5jaG9yID0gdHJhbnNmb3JtZWRPcGVyYXRpb24/LnByb3BlcnRpZXM/LmFuY2hvciA/IHtcbiAgICAgICAgICAuLi50cmFuc2Zvcm1lZE9wZXJhdGlvbi5wcm9wZXJ0aWVzLmFuY2hvclxuICAgICAgICB9IDogdm9pZCAwLCBuZXdGb2N1cyA9IHRyYW5zZm9ybWVkT3BlcmF0aW9uPy5uZXdQcm9wZXJ0aWVzPy5mb2N1cyA/IHtcbiAgICAgICAgICAuLi50cmFuc2Zvcm1lZE9wZXJhdGlvbi5uZXdQcm9wZXJ0aWVzLmZvY3VzXG4gICAgICAgIH0gOiB2b2lkIDAsIG5ld0FuY2hvciA9IHRyYW5zZm9ybWVkT3BlcmF0aW9uPy5uZXdQcm9wZXJ0aWVzPy5hbmNob3IgPyB7XG4gICAgICAgICAgLi4udHJhbnNmb3JtZWRPcGVyYXRpb24ubmV3UHJvcGVydGllcy5hbmNob3JcbiAgICAgICAgfSA6IHZvaWQgMDtcbiAgICAgICAgKGN1cnJlbnRGb2N1cyAmJiBjdXJyZW50QW5jaG9yIHx8IG5ld0ZvY3VzICYmIG5ld0FuY2hvcikgJiYgKFtjdXJyZW50Rm9jdXMsIGN1cnJlbnRBbmNob3IsIG5ld0ZvY3VzLCBuZXdBbmNob3JdLmZvckVhY2goKHBvaW50KSA9PiB7XG4gICAgICAgICAgcG9pbnQgJiYgY2hhbmdlZE9mZnNldCA8IHBvaW50Lm9mZnNldCAmJiAocG9pbnQub2Zmc2V0ICs9IGFkanVzdE9mZnNldEJ5KTtcbiAgICAgICAgfSksIGN1cnJlbnRGb2N1cyAmJiBjdXJyZW50QW5jaG9yICYmICh0cmFuc2Zvcm1lZE9wZXJhdGlvbi5wcm9wZXJ0aWVzID0ge1xuICAgICAgICAgIGZvY3VzOiBjdXJyZW50Rm9jdXMsXG4gICAgICAgICAgYW5jaG9yOiBjdXJyZW50QW5jaG9yXG4gICAgICAgIH0pLCBuZXdGb2N1cyAmJiBuZXdBbmNob3IgJiYgKHRyYW5zZm9ybWVkT3BlcmF0aW9uLm5ld1Byb3BlcnRpZXMgPSB7XG4gICAgICAgICAgZm9jdXM6IG5ld0ZvY3VzLFxuICAgICAgICAgIGFuY2hvcjogbmV3QW5jaG9yXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9KSwgW3RyYW5zZm9ybWVkT3BlcmF0aW9uXSk7XG4gIH1cbiAgcmV0dXJuIFt0cmFuc2Zvcm1lZE9wZXJhdGlvbl07XG59XG5mdW5jdGlvbiBhZGp1c3RCbG9ja1BhdGgob3BlcmF0aW9uLCBsZXZlbCwgYmxvY2tJbmRleCkge1xuICBjb25zdCB0cmFuc2Zvcm1lZE9wZXJhdGlvbiA9IHtcbiAgICAuLi5vcGVyYXRpb25cbiAgfTtcbiAgaWYgKGJsb2NrSW5kZXggPj0gMCAmJiB0cmFuc2Zvcm1lZE9wZXJhdGlvbi50eXBlICE9PSBcInNldF9zZWxlY3Rpb25cIiAmJiBBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkT3BlcmF0aW9uLnBhdGgpICYmIHRyYW5zZm9ybWVkT3BlcmF0aW9uLnBhdGhbMF0gPj0gYmxvY2tJbmRleCArIGxldmVsICYmIHRyYW5zZm9ybWVkT3BlcmF0aW9uLnBhdGhbMF0gKyBsZXZlbCA+IC0xKSB7XG4gICAgY29uc3QgbmV3UGF0aCA9IFt0cmFuc2Zvcm1lZE9wZXJhdGlvbi5wYXRoWzBdICsgbGV2ZWwsIC4uLnRyYW5zZm9ybWVkT3BlcmF0aW9uLnBhdGguc2xpY2UoMSldO1xuICAgIHRyYW5zZm9ybWVkT3BlcmF0aW9uLnBhdGggPSBuZXdQYXRoO1xuICB9XG4gIGlmICh0cmFuc2Zvcm1lZE9wZXJhdGlvbi50eXBlID09PSBcInNldF9zZWxlY3Rpb25cIikge1xuICAgIGNvbnN0IGN1cnJlbnRGb2N1cyA9IHRyYW5zZm9ybWVkT3BlcmF0aW9uLnByb3BlcnRpZXM/LmZvY3VzID8ge1xuICAgICAgLi4udHJhbnNmb3JtZWRPcGVyYXRpb24ucHJvcGVydGllcy5mb2N1c1xuICAgIH0gOiB2b2lkIDAsIGN1cnJlbnRBbmNob3IgPSB0cmFuc2Zvcm1lZE9wZXJhdGlvbj8ucHJvcGVydGllcz8uYW5jaG9yID8ge1xuICAgICAgLi4udHJhbnNmb3JtZWRPcGVyYXRpb24ucHJvcGVydGllcy5hbmNob3JcbiAgICB9IDogdm9pZCAwLCBuZXdGb2N1cyA9IHRyYW5zZm9ybWVkT3BlcmF0aW9uPy5uZXdQcm9wZXJ0aWVzPy5mb2N1cyA/IHtcbiAgICAgIC4uLnRyYW5zZm9ybWVkT3BlcmF0aW9uLm5ld1Byb3BlcnRpZXMuZm9jdXNcbiAgICB9IDogdm9pZCAwLCBuZXdBbmNob3IgPSB0cmFuc2Zvcm1lZE9wZXJhdGlvbj8ubmV3UHJvcGVydGllcz8uYW5jaG9yID8ge1xuICAgICAgLi4udHJhbnNmb3JtZWRPcGVyYXRpb24ubmV3UHJvcGVydGllcy5hbmNob3JcbiAgICB9IDogdm9pZCAwO1xuICAgIChjdXJyZW50Rm9jdXMgJiYgY3VycmVudEFuY2hvciB8fCBuZXdGb2N1cyAmJiBuZXdBbmNob3IpICYmIChbY3VycmVudEZvY3VzLCBjdXJyZW50QW5jaG9yLCBuZXdGb2N1cywgbmV3QW5jaG9yXS5mb3JFYWNoKChwb2ludCkgPT4ge1xuICAgICAgcG9pbnQgJiYgcG9pbnQucGF0aFswXSA+PSBibG9ja0luZGV4ICsgbGV2ZWwgJiYgcG9pbnQucGF0aFswXSArIGxldmVsID4gLTEgJiYgKHBvaW50LnBhdGggPSBbcG9pbnQucGF0aFswXSArIGxldmVsLCAuLi5wb2ludC5wYXRoLnNsaWNlKDEpXSk7XG4gICAgfSksIGN1cnJlbnRGb2N1cyAmJiBjdXJyZW50QW5jaG9yICYmICh0cmFuc2Zvcm1lZE9wZXJhdGlvbi5wcm9wZXJ0aWVzID0ge1xuICAgICAgZm9jdXM6IGN1cnJlbnRGb2N1cyxcbiAgICAgIGFuY2hvcjogY3VycmVudEFuY2hvclxuICAgIH0pLCBuZXdGb2N1cyAmJiBuZXdBbmNob3IgJiYgKHRyYW5zZm9ybWVkT3BlcmF0aW9uLm5ld1Byb3BlcnRpZXMgPSB7XG4gICAgICBmb2N1czogbmV3Rm9jdXMsXG4gICAgICBhbmNob3I6IG5ld0FuY2hvclxuICAgIH0pKTtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtZWRPcGVyYXRpb247XG59XG5jb25zdCBzaG91bGRNZXJnZSA9IChvcCwgcHJldikgPT4gISEob3AudHlwZSA9PT0gXCJzZXRfc2VsZWN0aW9uXCIgfHwgcHJldiAmJiBvcC50eXBlID09PSBcImluc2VydF90ZXh0XCIgJiYgcHJldi50eXBlID09PSBcImluc2VydF90ZXh0XCIgJiYgb3Aub2Zmc2V0ID09PSBwcmV2Lm9mZnNldCArIHByZXYudGV4dC5sZW5ndGggJiYgUGF0aC5lcXVhbHMob3AucGF0aCwgcHJldi5wYXRoKSAmJiBvcC50ZXh0ICE9PSBcIiBcIiB8fCBwcmV2ICYmIG9wLnR5cGUgPT09IFwicmVtb3ZlX3RleHRcIiAmJiBwcmV2LnR5cGUgPT09IFwicmVtb3ZlX3RleHRcIiAmJiBvcC5vZmZzZXQgKyBvcC50ZXh0Lmxlbmd0aCA9PT0gcHJldi5vZmZzZXQgJiYgUGF0aC5lcXVhbHMob3AucGF0aCwgcHJldi5wYXRoKSksIHNob3VsZE92ZXJ3cml0ZSA9IChvcCwgcHJldikgPT4gISEocHJldiAmJiBvcC50eXBlID09PSBcInNldF9zZWxlY3Rpb25cIiAmJiBwcmV2LnR5cGUgPT09IFwic2V0X3NlbGVjdGlvblwiKSwgc2hvdWxkQ2xlYXIgPSAob3ApID0+IG9wLnR5cGUgIT09IFwic2V0X3NlbGVjdGlvblwiO1xuZnVuY3Rpb24gd2l0aG91dFNhdmluZyhlZGl0b3IsIGZuKSB7XG4gIGNvbnN0IHByZXYgPSBpc1NhdmluZyhlZGl0b3IpO1xuICBTQVZJTkcuc2V0KGVkaXRvciwgITEpLCBmbigpLCBTQVZJTkcuc2V0KGVkaXRvciwgcHJldik7XG59XG5mdW5jdGlvbiBjcmVhdGVTZWxlY3RPcGVyYXRpb24oZWRpdG9yKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzZXRfc2VsZWN0aW9uXCIsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgLi4uZWRpdG9yLnNlbGVjdGlvblxuICAgIH0sXG4gICAgbmV3UHJvcGVydGllczoge1xuICAgICAgLi4uZWRpdG9yLnNlbGVjdGlvblxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbmRPcGVyYXRpb25UYXJnZXRCbG9jayhlZGl0b3IsIG9wZXJhdGlvbikge1xuICBsZXQgYmxvY2s7XG4gIHJldHVybiBvcGVyYXRpb24udHlwZSA9PT0gXCJzZXRfc2VsZWN0aW9uXCIgJiYgZWRpdG9yLnNlbGVjdGlvbiA/IGJsb2NrID0gZWRpdG9yLmNoaWxkcmVuW2VkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aFswXV0gOiBcInBhdGhcIiBpbiBvcGVyYXRpb24gJiYgKGJsb2NrID0gZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXSksIGJsb2NrO1xufVxuY29uc3QgYWRkQW5ub3RhdGlvbk9wZXJhdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgY29udGV4dCxcbiAgb3BlcmF0aW9uXG59KSA9PiB7XG4gIGNvbnN0IHBhcnNlZEFubm90YXRpb24gPSBwYXJzZUFubm90YXRpb24oe1xuICAgIGFubm90YXRpb246IHtcbiAgICAgIF90eXBlOiBvcGVyYXRpb24uYW5ub3RhdGlvbi5uYW1lLFxuICAgICAgLi4ub3BlcmF0aW9uLmFubm90YXRpb24udmFsdWVcbiAgICB9LFxuICAgIGNvbnRleHQsXG4gICAgb3B0aW9uczoge1xuICAgICAgdmFsaWRhdGVGaWVsZHM6ICEwXG4gICAgfVxuICB9KTtcbiAgaWYgKCFwYXJzZWRBbm5vdGF0aW9uKVxuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIGFubm90YXRpb24gJHtKU09OLnN0cmluZ2lmeShvcGVyYXRpb24uYW5ub3RhdGlvbil9YCk7XG4gIGNvbnN0IGVkaXRvciA9IG9wZXJhdGlvbi5lZGl0b3I7XG4gIGlmICghZWRpdG9yLnNlbGVjdGlvbiB8fCBSYW5nZS5pc0NvbGxhcHNlZChlZGl0b3Iuc2VsZWN0aW9uKSlcbiAgICByZXR1cm47XG4gIGNvbnN0IHNlbGVjdGVkQmxvY2tzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgIG1hdGNoOiAobm9kZSkgPT4gZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpLFxuICAgIHJldmVyc2U6IFJhbmdlLmlzQmFja3dhcmQoZWRpdG9yLnNlbGVjdGlvbilcbiAgfSk7XG4gIGxldCBibG9ja0luZGV4ID0gMDtcbiAgZm9yIChjb25zdCBbYmxvY2ssIGJsb2NrUGF0aF0gb2Ygc2VsZWN0ZWRCbG9ja3MpIHtcbiAgICBpZiAoYmxvY2suY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IGJsb2NrLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBibG9jay5jaGlsZHJlblswXS50ZXh0ID09PSBcIlwiKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgYW5ub3RhdGlvbktleSA9IGJsb2NrSW5kZXggPT09IDAgPyBwYXJzZWRBbm5vdGF0aW9uLl9rZXkgOiBjb250ZXh0LmtleUdlbmVyYXRvcigpLCBtYXJrRGVmcyA9IGJsb2NrLm1hcmtEZWZzID8/IFtdO1xuICAgIG1hcmtEZWZzLmZpbmQoKG1hcmtEZWYpID0+IG1hcmtEZWYuX3R5cGUgPT09IHBhcnNlZEFubm90YXRpb24uX3R5cGUgJiYgbWFya0RlZi5fa2V5ID09PSBhbm5vdGF0aW9uS2V5KSA9PT0gdm9pZCAwICYmIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICBtYXJrRGVmczogWy4uLm1hcmtEZWZzLCB7XG4gICAgICAgIC4uLnBhcnNlZEFubm90YXRpb24sXG4gICAgICAgIF9rZXk6IGFubm90YXRpb25LZXlcbiAgICAgIH1dXG4gICAgfSwge1xuICAgICAgYXQ6IGJsb2NrUGF0aFxuICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge30sIHtcbiAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICAgIHNwbGl0OiAhMFxuICAgIH0pO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gTm9kZS5jaGlsZHJlbihlZGl0b3IsIGJsb2NrUGF0aCk7XG4gICAgZm9yIChjb25zdCBbc3BhbiwgcGF0aF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgIGlmICghZWRpdG9yLmlzVGV4dFNwYW4oc3BhbikgfHwgIVJhbmdlLmluY2x1ZGVzKGVkaXRvci5zZWxlY3Rpb24sIHBhdGgpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IG1hcmtzID0gc3Bhbi5tYXJrcyA/PyBbXTtcbiAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIG1hcmtzOiBbLi4ubWFya3MsIGFubm90YXRpb25LZXldXG4gICAgICB9LCB7XG4gICAgICAgIGF0OiBwYXRoXG4gICAgICB9KTtcbiAgICB9XG4gICAgYmxvY2tJbmRleCsrO1xuICB9XG59LCByZW1vdmVBbm5vdGF0aW9uT3BlcmF0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBvcGVyYXRpb25cbn0pID0+IHtcbiAgY29uc3QgZWRpdG9yID0gb3BlcmF0aW9uLmVkaXRvcjtcbiAgaWYgKGVkaXRvci5zZWxlY3Rpb24pXG4gICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBbYmxvY2ssIGJsb2NrUGF0aF0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24sIHtcbiAgICAgICAgZGVwdGg6IDFcbiAgICAgIH0pO1xuICAgICAgaWYgKCFlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBwb3RlbnRpYWxBbm5vdGF0aW9ucyA9IChibG9jay5tYXJrRGVmcyA/PyBbXSkuZmlsdGVyKChtYXJrRGVmKSA9PiBtYXJrRGVmLl90eXBlID09PSBvcGVyYXRpb24uYW5ub3RhdGlvbi5uYW1lKSwgW3NlbGVjdGVkQ2hpbGQsIHNlbGVjdGVkQ2hpbGRQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbiwge1xuICAgICAgICBkZXB0aDogMlxuICAgICAgfSk7XG4gICAgICBpZiAoIWVkaXRvci5pc1RleHRTcGFuKHNlbGVjdGVkQ2hpbGQpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBhbm5vdGF0aW9uVG9SZW1vdmUgPSBzZWxlY3RlZENoaWxkLm1hcmtzPy5maW5kKChtYXJrKSA9PiBwb3RlbnRpYWxBbm5vdGF0aW9ucy5zb21lKChtYXJrRGVmKSA9PiBtYXJrRGVmLl9rZXkgPT09IG1hcmspKTtcbiAgICAgIGlmICghYW5ub3RhdGlvblRvUmVtb3ZlKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBwcmV2aW91c1NwYW5zV2l0aFNhbWVBbm5vdGF0aW9uID0gW107XG4gICAgICBmb3IgKGNvbnN0IFtjaGlsZCwgY2hpbGRQYXRoXSBvZiBOb2RlLmNoaWxkcmVuKGVkaXRvciwgYmxvY2tQYXRoLCB7XG4gICAgICAgIHJldmVyc2U6ICEwXG4gICAgICB9KSlcbiAgICAgICAgaWYgKGVkaXRvci5pc1RleHRTcGFuKGNoaWxkKSAmJiBQYXRoLmlzQmVmb3JlKGNoaWxkUGF0aCwgc2VsZWN0ZWRDaGlsZFBhdGgpKVxuICAgICAgICAgIGlmIChjaGlsZC5tYXJrcz8uaW5jbHVkZXMoYW5ub3RhdGlvblRvUmVtb3ZlKSlcbiAgICAgICAgICAgIHByZXZpb3VzU3BhbnNXaXRoU2FtZUFubm90YXRpb24ucHVzaChbY2hpbGQsIGNoaWxkUGF0aF0pO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgY29uc3QgbmV4dFNwYW5zV2l0aFNhbWVBbm5vdGF0aW9uID0gW107XG4gICAgICBmb3IgKGNvbnN0IFtjaGlsZCwgY2hpbGRQYXRoXSBvZiBOb2RlLmNoaWxkcmVuKGVkaXRvciwgYmxvY2tQYXRoKSlcbiAgICAgICAgaWYgKGVkaXRvci5pc1RleHRTcGFuKGNoaWxkKSAmJiBQYXRoLmlzQWZ0ZXIoY2hpbGRQYXRoLCBzZWxlY3RlZENoaWxkUGF0aCkpXG4gICAgICAgICAgaWYgKGNoaWxkLm1hcmtzPy5pbmNsdWRlcyhhbm5vdGF0aW9uVG9SZW1vdmUpKVxuICAgICAgICAgICAgbmV4dFNwYW5zV2l0aFNhbWVBbm5vdGF0aW9uLnB1c2goW2NoaWxkLCBjaGlsZFBhdGhdKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICAgIGZvciAoY29uc3QgW2NoaWxkLCBjaGlsZFBhdGhdIG9mIFsuLi5wcmV2aW91c1NwYW5zV2l0aFNhbWVBbm5vdGF0aW9uLCBbc2VsZWN0ZWRDaGlsZCwgc2VsZWN0ZWRDaGlsZFBhdGhdLCAuLi5uZXh0U3BhbnNXaXRoU2FtZUFubm90YXRpb25dKVxuICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIG1hcmtzOiBjaGlsZC5tYXJrcz8uZmlsdGVyKChtYXJrKSA9PiBtYXJrICE9PSBhbm5vdGF0aW9uVG9SZW1vdmUpXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBhdDogY2hpbGRQYXRoXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge30sIHtcbiAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBlZGl0b3IuaXNUZXh0U3Bhbihub2RlKSxcbiAgICAgICAgc3BsaXQ6ICEwLFxuICAgICAgICBoYW5naW5nOiAhMFxuICAgICAgfSk7XG4gICAgICBjb25zdCBibG9ja3MgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICBtYXRjaDogKG5vZGUpID0+IGVkaXRvci5pc1RleHRCbG9jayhub2RlKVxuICAgICAgfSk7XG4gICAgICBmb3IgKGNvbnN0IFtibG9jaywgYmxvY2tQYXRoXSBvZiBibG9ja3MpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBOb2RlLmNoaWxkcmVuKGVkaXRvciwgYmxvY2tQYXRoKTtcbiAgICAgICAgZm9yIChjb25zdCBbY2hpbGQsIGNoaWxkUGF0aF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoIWVkaXRvci5pc1RleHRTcGFuKGNoaWxkKSB8fCAhUmFuZ2UuaW5jbHVkZXMoZWRpdG9yLnNlbGVjdGlvbiwgY2hpbGRQYXRoKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IG1hcmtEZWZzID0gYmxvY2subWFya0RlZnMgPz8gW10sIG1hcmtzID0gY2hpbGQubWFya3MgPz8gW10sIG1hcmtzV2l0aG91dEFubm90YXRpb24gPSBtYXJrcy5maWx0ZXIoKG1hcmspID0+IG1hcmtEZWZzLmZpbmQoKG1hcmtEZWYyKSA9PiBtYXJrRGVmMi5fa2V5ID09PSBtYXJrKT8uX3R5cGUgIT09IG9wZXJhdGlvbi5hbm5vdGF0aW9uLm5hbWUpO1xuICAgICAgICAgIG1hcmtzV2l0aG91dEFubm90YXRpb24ubGVuZ3RoICE9PSBtYXJrcy5sZW5ndGggJiYgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIG1hcmtzOiBtYXJrc1dpdGhvdXRBbm5vdGF0aW9uXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IGNoaWxkUGF0aFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxufSwgYmxvY2tTZXRPcGVyYXRpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIG9wZXJhdGlvblxufSkgPT4ge1xuICBjb25zdCBibG9ja0luZGV4ID0gb3BlcmF0aW9uLmVkaXRvci5ibG9ja0luZGV4TWFwLmdldChvcGVyYXRpb24uYXRbMF0uX2tleSk7XG4gIGlmIChibG9ja0luZGV4ID09PSB2b2lkIDApXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBibG9jayBpbmRleCBmb3IgYmxvY2sgYXQgJHtKU09OLnN0cmluZ2lmeShvcGVyYXRpb24uYXQpfWApO1xuICBjb25zdCBibG9jayA9IG9wZXJhdGlvbi5lZGl0b3IudmFsdWUuYXQoYmxvY2tJbmRleCk7XG4gIGlmICghYmxvY2spXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBibG9jayBhdCAke0pTT04uc3RyaW5naWZ5KG9wZXJhdGlvbi5hdCl9YCk7XG4gIGNvbnN0IHtcbiAgICBfdHlwZSxcbiAgICAuLi5maWx0ZXJlZFByb3BzXG4gIH0gPSBvcGVyYXRpb24ucHJvcHMsIHVwZGF0ZWRCbG9jayA9IHtcbiAgICAuLi5ibG9jayxcbiAgICAuLi5maWx0ZXJlZFByb3BzXG4gIH0sIHBhcnNlZEJsb2NrID0gcGFyc2VCbG9jayh7XG4gICAgY29udGV4dCxcbiAgICBibG9jazogdXBkYXRlZEJsb2NrLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHJlbW92ZVVudXNlZE1hcmtEZWZzOiAhMSxcbiAgICAgIHZhbGlkYXRlRmllbGRzOiAhMFxuICAgIH1cbiAgfSk7XG4gIGlmICghcGFyc2VkQmxvY2spXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gdXBkYXRlIGJsb2NrIGF0ICR7SlNPTi5zdHJpbmdpZnkob3BlcmF0aW9uLmF0KX1gKTtcbiAgY29uc3Qgc2xhdGVCbG9jayA9IHRvU2xhdGVWYWx1ZShbcGFyc2VkQmxvY2tdLCB7XG4gICAgc2NoZW1hVHlwZXM6IGNvbnRleHQuc2NoZW1hXG4gIH0pPy5hdCgwKTtcbiAgaWYgKCFzbGF0ZUJsb2NrKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBjb252ZXJ0IGJsb2NrIHRvIFNsYXRlIHZhbHVlXCIpO1xuICBUcmFuc2Zvcm1zLnNldE5vZGVzKG9wZXJhdGlvbi5lZGl0b3IsIHNsYXRlQmxvY2ssIHtcbiAgICBhdDogW2Jsb2NrSW5kZXhdXG4gIH0pO1xufSwgYmxvY2tVbnNldE9wZXJhdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgY29udGV4dCxcbiAgb3BlcmF0aW9uXG59KSA9PiB7XG4gIGNvbnN0IGxvY2F0aW9uID0gdG9TbGF0ZVJhbmdlKHtcbiAgICBjb250ZXh0OiB7XG4gICAgICBzY2hlbWE6IGNvbnRleHQuc2NoZW1hLFxuICAgICAgdmFsdWU6IG9wZXJhdGlvbi5lZGl0b3IudmFsdWUsXG4gICAgICBzZWxlY3Rpb246IHtcbiAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgcGF0aDogb3BlcmF0aW9uLmF0LFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9LFxuICAgICAgICBmb2N1czoge1xuICAgICAgICAgIHBhdGg6IG9wZXJhdGlvbi5hdCxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgYmxvY2tJbmRleE1hcDogb3BlcmF0aW9uLmVkaXRvci5ibG9ja0luZGV4TWFwXG4gIH0pO1xuICBpZiAoIWxvY2F0aW9uKVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGNvbnZlcnQgJHtKU09OLnN0cmluZ2lmeShvcGVyYXRpb24uYXQpfSBpbnRvIGEgU2xhdGUgUmFuZ2VgKTtcbiAgY29uc3QgYmxvY2sgPSBFZGl0b3Iubm9kZShvcGVyYXRpb24uZWRpdG9yLCBsb2NhdGlvbiwge1xuICAgIGRlcHRoOiAxXG4gIH0pPy5bMF07XG4gIGlmICghYmxvY2spXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBibG9jayBhdCAke0pTT04uc3RyaW5naWZ5KG9wZXJhdGlvbi5hdCl9YCk7XG4gIGNvbnN0IHBhcnNlZEJsb2NrID0gZnJvbVNsYXRlVmFsdWUoW2Jsb2NrXSwgY29udGV4dC5zY2hlbWEuYmxvY2submFtZSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuZ2V0KG9wZXJhdGlvbi5lZGl0b3IpKS5hdCgwKTtcbiAgaWYgKCFwYXJzZWRCbG9jaylcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBwYXJzZSBibG9jayBhdCAke0pTT04uc3RyaW5naWZ5KG9wZXJhdGlvbi5hdCl9YCk7XG4gIGlmIChpc1RleHRCbG9jayhjb250ZXh0LCBwYXJzZWRCbG9jaykpIHtcbiAgICBjb25zdCBwcm9wc1RvUmVtb3ZlID0gb3BlcmF0aW9uLnByb3BzLmZpbHRlcigocHJvcCkgPT4gcHJvcCAhPT0gXCJfdHlwZVwiKSwgdXBkYXRlZFRleHRCbG9jayA9IHBhcnNlQmxvY2soe1xuICAgICAgY29udGV4dCxcbiAgICAgIGJsb2NrOiBvbWl0KHBhcnNlZEJsb2NrLCBwcm9wc1RvUmVtb3ZlKSxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcmVtb3ZlVW51c2VkTWFya0RlZnM6ICEwLFxuICAgICAgICB2YWxpZGF0ZUZpZWxkczogITBcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXVwZGF0ZWRUZXh0QmxvY2spXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byB1cGRhdGUgYmxvY2sgYXQgJHtKU09OLnN0cmluZ2lmeShvcGVyYXRpb24uYXQpfWApO1xuICAgIGNvbnN0IHByb3BzVG9TZXQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcHNUb1JlbW92ZSlcbiAgICAgIHByb3AgaW4gdXBkYXRlZFRleHRCbG9jayA/IHByb3BzVG9TZXRbcHJvcF0gPSB1cGRhdGVkVGV4dEJsb2NrW3Byb3BdIDogcHJvcHNUb1NldFtwcm9wXSA9IHZvaWQgMDtcbiAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKG9wZXJhdGlvbi5lZGl0b3IsIHByb3BzVG9TZXQsIHtcbiAgICAgIGF0OiBsb2NhdGlvblxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB1cGRhdGVkQmxvY2tPYmplY3QgPSBwYXJzZUJsb2NrKHtcbiAgICBjb250ZXh0LFxuICAgIGJsb2NrOiBvbWl0KHBhcnNlZEJsb2NrLCBvcGVyYXRpb24ucHJvcHMuZmlsdGVyKChwcm9wKSA9PiBwcm9wICE9PSBcIl90eXBlXCIpKSxcbiAgICBvcHRpb25zOiB7XG4gICAgICByZW1vdmVVbnVzZWRNYXJrRGVmczogITAsXG4gICAgICB2YWxpZGF0ZUZpZWxkczogITBcbiAgICB9XG4gIH0pO1xuICBpZiAoIXVwZGF0ZWRCbG9ja09iamVjdClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byB1cGRhdGUgYmxvY2sgYXQgJHtKU09OLnN0cmluZ2lmeShvcGVyYXRpb24uYXQpfWApO1xuICBjb25zdCB7XG4gICAgX3R5cGUsXG4gICAgX2tleSxcbiAgICAuLi5wcm9wc1xuICB9ID0gdXBkYXRlZEJsb2NrT2JqZWN0O1xuICBUcmFuc2Zvcm1zLnNldE5vZGVzKG9wZXJhdGlvbi5lZGl0b3IsIHtcbiAgICBfdHlwZSxcbiAgICBfa2V5LFxuICAgIHZhbHVlOiBwcm9wc1xuICB9LCB7XG4gICAgYXQ6IGxvY2F0aW9uXG4gIH0pO1xufSwgY2hpbGRTZXRPcGVyYXRpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIG9wZXJhdGlvblxufSkgPT4ge1xuICBjb25zdCBsb2NhdGlvbiA9IHRvU2xhdGVSYW5nZSh7XG4gICAgY29udGV4dDoge1xuICAgICAgc2NoZW1hOiBjb250ZXh0LnNjaGVtYSxcbiAgICAgIHZhbHVlOiBvcGVyYXRpb24uZWRpdG9yLnZhbHVlLFxuICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgIHBhdGg6IG9wZXJhdGlvbi5hdCxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICBwYXRoOiBvcGVyYXRpb24uYXQsXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGJsb2NrSW5kZXhNYXA6IG9wZXJhdGlvbi5lZGl0b3IuYmxvY2tJbmRleE1hcFxuICB9KTtcbiAgaWYgKCFsb2NhdGlvbilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBjb252ZXJ0ICR7SlNPTi5zdHJpbmdpZnkob3BlcmF0aW9uLmF0KX0gaW50byBhIFNsYXRlIFJhbmdlYCk7XG4gIGNvbnN0IGNoaWxkRW50cnkgPSBFZGl0b3Iubm9kZShvcGVyYXRpb24uZWRpdG9yLCBsb2NhdGlvbiwge1xuICAgIGRlcHRoOiAyXG4gIH0pLCBjaGlsZCA9IGNoaWxkRW50cnk/LlswXSwgY2hpbGRQYXRoID0gY2hpbGRFbnRyeT8uWzFdO1xuICBpZiAoIWNoaWxkIHx8ICFjaGlsZFBhdGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBjaGlsZCBhdCAke0pTT04uc3RyaW5naWZ5KG9wZXJhdGlvbi5hdCl9YCk7XG4gIGlmIChvcGVyYXRpb24uZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpKSB7XG4gICAgY29uc3Qge1xuICAgICAgX3R5cGUsXG4gICAgICB0ZXh0LFxuICAgICAgLi4ucmVzdFxuICAgIH0gPSBvcGVyYXRpb24ucHJvcHM7XG4gICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhvcGVyYXRpb24uZWRpdG9yLCB7XG4gICAgICAuLi5jaGlsZCxcbiAgICAgIC4uLnJlc3RcbiAgICB9LCB7XG4gICAgICBhdDogY2hpbGRQYXRoXG4gICAgfSksIHR5cGVvZiB0ZXh0ID09IFwic3RyaW5nXCIgJiYgY2hpbGQudGV4dCAhPT0gdGV4dCAmJiAob3BlcmF0aW9uLmVkaXRvci5hcHBseSh7XG4gICAgICB0eXBlOiBcInJlbW92ZV90ZXh0XCIsXG4gICAgICBwYXRoOiBjaGlsZFBhdGgsXG4gICAgICBvZmZzZXQ6IDAsXG4gICAgICB0ZXh0OiBjaGlsZC50ZXh0XG4gICAgfSksIG9wZXJhdGlvbi5lZGl0b3IuYXBwbHkoe1xuICAgICAgdHlwZTogXCJpbnNlcnRfdGV4dFwiLFxuICAgICAgcGF0aDogY2hpbGRQYXRoLFxuICAgICAgb2Zmc2V0OiAwLFxuICAgICAgdGV4dFxuICAgIH0pKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKEVsZW1lbnQkMS5pc0VsZW1lbnQoY2hpbGQpKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IGNvbnRleHQuc2NoZW1hLmlubGluZU9iamVjdHMuZmluZCgoZGVmaW5pdGlvbjIpID0+IGRlZmluaXRpb24yLm5hbWUgPT09IGNoaWxkLl90eXBlKTtcbiAgICBpZiAoIWRlZmluaXRpb24pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIHNjaGVtYSBkZWZpbml0aW9uIGZvciBJbmxpbmUgT2JqZWN0IHR5cGUgJHtjaGlsZC5fdHlwZX1gKTtcbiAgICBjb25zdCB2YWx1ZSA9IFwidmFsdWVcIiBpbiBjaGlsZCAmJiB0eXBlb2YgY2hpbGQudmFsdWUgPT0gXCJvYmplY3RcIiA/IGNoaWxkLnZhbHVlIDoge30sIHtcbiAgICAgIF90eXBlLFxuICAgICAgX2tleSxcbiAgICAgIC4uLnJlc3RcbiAgICB9ID0gb3BlcmF0aW9uLnByb3BzO1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiByZXN0KVxuICAgICAgZGVmaW5pdGlvbi5maWVsZHMuc29tZSgoZmllbGQpID0+IGZpZWxkLm5hbWUgPT09IHByb3ApIHx8IGRlbGV0ZSByZXN0W3Byb3BdO1xuICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMob3BlcmF0aW9uLmVkaXRvciwge1xuICAgICAgLi4uY2hpbGQsXG4gICAgICBfa2V5OiB0eXBlb2YgX2tleSA9PSBcInN0cmluZ1wiID8gX2tleSA6IGNoaWxkLl9rZXksXG4gICAgICB2YWx1ZToge1xuICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgLi4ucmVzdFxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGF0OiBjaGlsZFBhdGhcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGNoaWxkIGF0ICR7SlNPTi5zdHJpbmdpZnkob3BlcmF0aW9uLmF0KX1gKTtcbn0sIGNoaWxkVW5zZXRPcGVyYXRpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIG9wZXJhdGlvblxufSkgPT4ge1xuICBjb25zdCBsb2NhdGlvbiA9IHRvU2xhdGVSYW5nZSh7XG4gICAgY29udGV4dDoge1xuICAgICAgc2NoZW1hOiBjb250ZXh0LnNjaGVtYSxcbiAgICAgIHZhbHVlOiBvcGVyYXRpb24uZWRpdG9yLnZhbHVlLFxuICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgIHBhdGg6IG9wZXJhdGlvbi5hdCxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICBwYXRoOiBvcGVyYXRpb24uYXQsXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGJsb2NrSW5kZXhNYXA6IG9wZXJhdGlvbi5lZGl0b3IuYmxvY2tJbmRleE1hcFxuICB9KTtcbiAgaWYgKCFsb2NhdGlvbilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBjb252ZXJ0ICR7SlNPTi5zdHJpbmdpZnkob3BlcmF0aW9uLmF0KX0gaW50byBhIFNsYXRlIFJhbmdlYCk7XG4gIGNvbnN0IGNoaWxkRW50cnkgPSBFZGl0b3Iubm9kZShvcGVyYXRpb24uZWRpdG9yLCBsb2NhdGlvbiwge1xuICAgIGRlcHRoOiAyXG4gIH0pLCBjaGlsZCA9IGNoaWxkRW50cnk/LlswXSwgY2hpbGRQYXRoID0gY2hpbGRFbnRyeT8uWzFdO1xuICBpZiAoIWNoaWxkIHx8ICFjaGlsZFBhdGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBjaGlsZCBhdCAke0pTT04uc3RyaW5naWZ5KG9wZXJhdGlvbi5hdCl9YCk7XG4gIGlmIChvcGVyYXRpb24uZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpKSB7XG4gICAgb3BlcmF0aW9uLnByb3BzLmluY2x1ZGVzKFwidGV4dFwiKSAmJiBvcGVyYXRpb24uZWRpdG9yLmFwcGx5KHtcbiAgICAgIHR5cGU6IFwicmVtb3ZlX3RleHRcIixcbiAgICAgIHBhdGg6IGNoaWxkUGF0aCxcbiAgICAgIG9mZnNldDogMCxcbiAgICAgIHRleHQ6IGNoaWxkLnRleHRcbiAgICB9KTtcbiAgICBjb25zdCBuZXdOb2RlID0ge307XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIG9wZXJhdGlvbi5wcm9wcylcbiAgICAgIGlmIChwcm9wICE9PSBcIl90eXBlXCIpIHtcbiAgICAgICAgaWYgKHByb3AgPT09IFwiX2tleVwiKSB7XG4gICAgICAgICAgbmV3Tm9kZS5fa2V5ID0gY29udGV4dC5rZXlHZW5lcmF0b3IoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBuZXdOb2RlW3Byb3BdID0gbnVsbDtcbiAgICAgIH1cbiAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKG9wZXJhdGlvbi5lZGl0b3IsIG5ld05vZGUsIHtcbiAgICAgIGF0OiBjaGlsZFBhdGhcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKEVsZW1lbnQkMS5pc0VsZW1lbnQoY2hpbGQpKSB7XG4gICAgY29uc3QgdmFsdWUgPSBcInZhbHVlXCIgaW4gY2hpbGQgJiYgdHlwZW9mIGNoaWxkLnZhbHVlID09IFwib2JqZWN0XCIgPyBjaGlsZC52YWx1ZSA6IHt9LCBwYXRjaGVzID0gb3BlcmF0aW9uLnByb3BzLm1hcCgocHJvcCkgPT4gKHtcbiAgICAgIHR5cGU6IFwidW5zZXRcIixcbiAgICAgIHBhdGg6IFtwcm9wXVxuICAgIH0pKSwgbmV3VmFsdWUgPSBhcHBseUFsbCh2YWx1ZSwgcGF0Y2hlcyk7XG4gICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhvcGVyYXRpb24uZWRpdG9yLCB7XG4gICAgICAuLi5jaGlsZCxcbiAgICAgIF9rZXk6IG9wZXJhdGlvbi5wcm9wcy5pbmNsdWRlcyhcIl9rZXlcIikgPyBjb250ZXh0LmtleUdlbmVyYXRvcigpIDogY2hpbGQuX2tleSxcbiAgICAgIHZhbHVlOiBuZXdWYWx1ZVxuICAgIH0sIHtcbiAgICAgIGF0OiBjaGlsZFBhdGhcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGNoaWxkIGF0ICR7SlNPTi5zdHJpbmdpZnkob3BlcmF0aW9uLmF0KX1gKTtcbn0sIGRlY29yYXRvckFkZE9wZXJhdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgY29udGV4dCxcbiAgb3BlcmF0aW9uXG59KSA9PiB7XG4gIGNvbnN0IGVkaXRvciA9IG9wZXJhdGlvbi5lZGl0b3IsIG1hcmsgPSBvcGVyYXRpb24uZGVjb3JhdG9yLCB2YWx1ZSA9IGZyb21TbGF0ZVZhbHVlKGVkaXRvci5jaGlsZHJlbiwgY29udGV4dC5zY2hlbWEuYmxvY2submFtZSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuZ2V0KGVkaXRvcikpLCBtYW51YWxBbmNob3IgPSBvcGVyYXRpb24uYXQ/LmFuY2hvciA/IGJsb2NrT2Zmc2V0VG9TcGFuU2VsZWN0aW9uUG9pbnQoe1xuICAgIGNvbnRleHQ6IHtcbiAgICAgIC4uLmNvbnRleHQsXG4gICAgICB2YWx1ZVxuICAgIH0sXG4gICAgYmxvY2tPZmZzZXQ6IG9wZXJhdGlvbi5hdC5hbmNob3IsXG4gICAgZGlyZWN0aW9uOiBcImJhY2t3YXJkXCJcbiAgfSkgOiB2b2lkIDAsIG1hbnVhbEZvY3VzID0gb3BlcmF0aW9uLmF0Py5mb2N1cyA/IGJsb2NrT2Zmc2V0VG9TcGFuU2VsZWN0aW9uUG9pbnQoe1xuICAgIGNvbnRleHQ6IHtcbiAgICAgIC4uLmNvbnRleHQsXG4gICAgICB2YWx1ZVxuICAgIH0sXG4gICAgYmxvY2tPZmZzZXQ6IG9wZXJhdGlvbi5hdC5mb2N1cyxcbiAgICBkaXJlY3Rpb246IFwiZm9yd2FyZFwiXG4gIH0pIDogdm9pZCAwLCBtYW51YWxTZWxlY3Rpb24gPSBtYW51YWxBbmNob3IgJiYgbWFudWFsRm9jdXMgPyB7XG4gICAgYW5jaG9yOiBtYW51YWxBbmNob3IsXG4gICAgZm9jdXM6IG1hbnVhbEZvY3VzXG4gIH0gOiB2b2lkIDAsIHNlbGVjdGlvbiA9IG1hbnVhbFNlbGVjdGlvbiA/IHRvU2xhdGVSYW5nZSh7XG4gICAgY29udGV4dDoge1xuICAgICAgc2NoZW1hOiBjb250ZXh0LnNjaGVtYSxcbiAgICAgIHZhbHVlOiBvcGVyYXRpb24uZWRpdG9yLnZhbHVlLFxuICAgICAgc2VsZWN0aW9uOiBtYW51YWxTZWxlY3Rpb25cbiAgICB9LFxuICAgIGJsb2NrSW5kZXhNYXA6IG9wZXJhdGlvbi5lZGl0b3IuYmxvY2tJbmRleE1hcFxuICB9KSA/PyBlZGl0b3Iuc2VsZWN0aW9uIDogZWRpdG9yLnNlbGVjdGlvbjtcbiAgaWYgKCFzZWxlY3Rpb24pXG4gICAgcmV0dXJuO1xuICBjb25zdCBlZGl0b3JTZWxlY3Rpb24gPSBzbGF0ZVJhbmdlVG9TZWxlY3Rpb24oe1xuICAgIHNjaGVtYTogY29udGV4dC5zY2hlbWEsXG4gICAgZWRpdG9yLFxuICAgIHJhbmdlOiBzZWxlY3Rpb25cbiAgfSksIGFuY2hvck9mZnNldCA9IGVkaXRvclNlbGVjdGlvbiA/IHNlbGVjdGlvblBvaW50VG9CbG9ja09mZnNldCh7XG4gICAgY29udGV4dDoge1xuICAgICAgLi4uY29udGV4dCxcbiAgICAgIHZhbHVlXG4gICAgfSxcbiAgICBzZWxlY3Rpb25Qb2ludDogZWRpdG9yU2VsZWN0aW9uLmFuY2hvclxuICB9KSA6IHZvaWQgMCwgZm9jdXNPZmZzZXQgPSBlZGl0b3JTZWxlY3Rpb24gPyBzZWxlY3Rpb25Qb2ludFRvQmxvY2tPZmZzZXQoe1xuICAgIGNvbnRleHQ6IHtcbiAgICAgIC4uLmNvbnRleHQsXG4gICAgICB2YWx1ZVxuICAgIH0sXG4gICAgc2VsZWN0aW9uUG9pbnQ6IGVkaXRvclNlbGVjdGlvbi5mb2N1c1xuICB9KSA6IHZvaWQgMDtcbiAgaWYgKCFhbmNob3JPZmZzZXQgfHwgIWZvY3VzT2Zmc2V0KVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIGFuY2hvciBvciBmb2N1cyBvZmZzZXRcIik7XG4gIGlmIChSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge30sIHtcbiAgICAgIGF0OiBzZWxlY3Rpb24sXG4gICAgICBtYXRjaDogVGV4dC5pc1RleHQsXG4gICAgICBzcGxpdDogITAsXG4gICAgICBoYW5naW5nOiAhMFxuICAgIH0pO1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gZnJvbVNsYXRlVmFsdWUoZWRpdG9yLmNoaWxkcmVuLCBjb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZWRpdG9yKSksIG5ld1NlbGVjdGlvbiA9IGJsb2NrT2Zmc2V0c1RvU2VsZWN0aW9uKHtcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgLi4uY29udGV4dCxcbiAgICAgICAgdmFsdWU6IG5ld1ZhbHVlXG4gICAgICB9LFxuICAgICAgb2Zmc2V0czoge1xuICAgICAgICBhbmNob3I6IGFuY2hvck9mZnNldCxcbiAgICAgICAgZm9jdXM6IGZvY3VzT2Zmc2V0XG4gICAgICB9LFxuICAgICAgYmFja3dhcmQ6IGVkaXRvclNlbGVjdGlvbj8uYmFja3dhcmRcbiAgICB9KSwgdHJpbW1lZFNlbGVjdGlvbiA9IGdldFRyaW1tZWRTZWxlY3Rpb24oe1xuICAgICAgYmxvY2tJbmRleE1hcDogZWRpdG9yLmJsb2NrSW5kZXhNYXAsXG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIGNvbnZlcnRlcnM6IFtdLFxuICAgICAgICBrZXlHZW5lcmF0b3I6IGNvbnRleHQua2V5R2VuZXJhdG9yLFxuICAgICAgICByZWFkT25seTogITEsXG4gICAgICAgIHNjaGVtYTogY29udGV4dC5zY2hlbWEsXG4gICAgICAgIHNlbGVjdGlvbjogbmV3U2VsZWN0aW9uLFxuICAgICAgICB2YWx1ZTogbmV3VmFsdWVcbiAgICAgIH0sXG4gICAgICBkZWNvcmF0b3JTdGF0ZTogZWRpdG9yLmRlY29yYXRvclN0YXRlXG4gICAgfSk7XG4gICAgaWYgKCF0cmltbWVkU2VsZWN0aW9uKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgdHJpbW1lZCBzZWxlY3Rpb25cIik7XG4gICAgY29uc3QgbmV3UmFuZ2UgPSB0b1NsYXRlUmFuZ2Uoe1xuICAgICAgY29udGV4dDoge1xuICAgICAgICBzY2hlbWE6IGNvbnRleHQuc2NoZW1hLFxuICAgICAgICB2YWx1ZTogb3BlcmF0aW9uLmVkaXRvci52YWx1ZSxcbiAgICAgICAgc2VsZWN0aW9uOiB0cmltbWVkU2VsZWN0aW9uXG4gICAgICB9LFxuICAgICAgYmxvY2tJbmRleE1hcDogb3BlcmF0aW9uLmVkaXRvci5ibG9ja0luZGV4TWFwXG4gICAgfSk7XG4gICAgaWYgKCFuZXdSYW5nZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIG5ldyBzZWxlY3Rpb25cIik7XG4gICAgY29uc3Qgc3BsaXRUZXh0Tm9kZXMgPSBSYW5nZS5pc1JhbmdlKG5ld1JhbmdlKSA/IFsuLi5FZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogbmV3UmFuZ2UsXG4gICAgICBtYXRjaDogKG5vZGUpID0+IFRleHQuaXNUZXh0KG5vZGUpXG4gICAgfSldIDogW107XG4gICAgZm9yIChjb25zdCBbbm9kZSwgcGF0aF0gb2Ygc3BsaXRUZXh0Tm9kZXMpIHtcbiAgICAgIGNvbnN0IG1hcmtzID0gWy4uLihBcnJheS5pc0FycmF5KG5vZGUubWFya3MpID8gbm9kZS5tYXJrcyA6IFtdKS5maWx0ZXIoKGVNYXJrKSA9PiBlTWFyayAhPT0gbWFyayksIG1hcmtdO1xuICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgbWFya3NcbiAgICAgIH0sIHtcbiAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICAgICAgc3BsaXQ6ICEwLFxuICAgICAgICBoYW5naW5nOiAhMFxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogc2VsZWN0aW9uLFxuICAgICAgbWF0Y2g6IChub2RlKSA9PiBlZGl0b3IuaXNUZXh0U3Bhbihub2RlKVxuICAgIH0pKT8uYXQoMCkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgW2Jsb2NrLCBibG9ja1BhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBzZWxlY3Rpb24sIHtcbiAgICAgIGRlcHRoOiAxXG4gICAgfSksIGxvbmVseUVtcHR5U3BhbiA9IGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgYmxvY2suY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGVkaXRvci5pc1RleHRTcGFuKGJsb2NrLmNoaWxkcmVuWzBdKSAmJiBibG9jay5jaGlsZHJlblswXS50ZXh0ID09PSBcIlwiID8gYmxvY2suY2hpbGRyZW5bMF0gOiB2b2lkIDA7XG4gICAgaWYgKGxvbmVseUVtcHR5U3Bhbikge1xuICAgICAgY29uc3QgZXhpc3RpbmdNYXJrcyA9IGxvbmVseUVtcHR5U3Bhbi5tYXJrcyA/PyBbXSwgZXhpc3RpbmdNYXJrc1dpdGhvdXREZWNvcmF0b3IgPSBleGlzdGluZ01hcmtzLmZpbHRlcigoZXhpc3RpbmdNYXJrKSA9PiBleGlzdGluZ01hcmsgIT09IG1hcmspO1xuICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgbWFya3M6IGV4aXN0aW5nTWFya3MubGVuZ3RoID09PSBleGlzdGluZ01hcmtzV2l0aG91dERlY29yYXRvci5sZW5ndGggPyBbLi4uZXhpc3RpbmdNYXJrcywgbWFya10gOiBleGlzdGluZ01hcmtzV2l0aG91dERlY29yYXRvclxuICAgICAgfSwge1xuICAgICAgICBhdDogYmxvY2tQYXRoLFxuICAgICAgICBtYXRjaDogKG5vZGUpID0+IGVkaXRvci5pc1RleHRTcGFuKG5vZGUpXG4gICAgICB9KTtcbiAgICB9IGVsc2VcbiAgICAgIGVkaXRvci5kZWNvcmF0b3JTdGF0ZVttYXJrXSA9ICEwO1xuICB9XG4gIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uMiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgZWRpdG9yLnNlbGVjdGlvbiA9IHtcbiAgICAgIC4uLnNlbGVjdGlvbjJcbiAgICB9O1xuICB9XG59LCBkZWxldGVPcGVyYXRpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIG9wZXJhdGlvblxufSkgPT4ge1xuICBjb25zdCBhbmNob3JCbG9ja0tleSA9IGdldEJsb2NrS2V5RnJvbVNlbGVjdGlvblBvaW50KG9wZXJhdGlvbi5hdC5hbmNob3IpLCBmb2N1c0Jsb2NrS2V5ID0gZ2V0QmxvY2tLZXlGcm9tU2VsZWN0aW9uUG9pbnQob3BlcmF0aW9uLmF0LmZvY3VzKSwgc3RhcnRCbG9ja0tleSA9IG9wZXJhdGlvbi5hdC5iYWNrd2FyZCA/IGZvY3VzQmxvY2tLZXkgOiBhbmNob3JCbG9ja0tleSwgZW5kQmxvY2tLZXkgPSBvcGVyYXRpb24uYXQuYmFja3dhcmQgPyBhbmNob3JCbG9ja0tleSA6IGZvY3VzQmxvY2tLZXksIGVuZE9mZnNldCA9IG9wZXJhdGlvbi5hdC5iYWNrd2FyZCA/IG9wZXJhdGlvbi5hdC5mb2N1cy5vZmZzZXQgOiBvcGVyYXRpb24uYXQuYW5jaG9yLm9mZnNldDtcbiAgaWYgKCFzdGFydEJsb2NrS2V5KVxuICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZXQgc3RhcnQgYmxvY2sga2V5XCIpO1xuICBpZiAoIWVuZEJsb2NrS2V5KVxuICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZXQgZW5kIGJsb2NrIGtleVwiKTtcbiAgY29uc3Qgc3RhcnRCbG9ja0luZGV4ID0gb3BlcmF0aW9uLmVkaXRvci5ibG9ja0luZGV4TWFwLmdldChzdGFydEJsb2NrS2V5KTtcbiAgaWYgKHN0YXJ0QmxvY2tJbmRleCA9PT0gdm9pZCAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZXQgc3RhcnQgYmxvY2sgaW5kZXhcIik7XG4gIGNvbnN0IHN0YXJ0QmxvY2sgPSBvcGVyYXRpb24uZWRpdG9yLnZhbHVlLmF0KHN0YXJ0QmxvY2tJbmRleCk7XG4gIGlmICghc3RhcnRCbG9jaylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZ2V0IHN0YXJ0IGJsb2NrXCIpO1xuICBjb25zdCBlbmRCbG9ja0luZGV4ID0gb3BlcmF0aW9uLmVkaXRvci5ibG9ja0luZGV4TWFwLmdldChlbmRCbG9ja0tleSk7XG4gIGlmIChlbmRCbG9ja0luZGV4ID09PSB2b2lkIDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGdldCBlbmQgYmxvY2sgaW5kZXhcIik7XG4gIGNvbnN0IGVuZEJsb2NrID0gb3BlcmF0aW9uLmVkaXRvci52YWx1ZS5hdChlbmRCbG9ja0luZGV4KTtcbiAgaWYgKCFlbmRCbG9jaylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZ2V0IGVuZCBibG9ja1wiKTtcbiAgaWYgKG9wZXJhdGlvbi51bml0ID09PSBcImJsb2NrXCIpIHtcbiAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKG9wZXJhdGlvbi5lZGl0b3IsIHtcbiAgICAgIGF0OiB7XG4gICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgIHBhdGg6IFtzdGFydEJsb2NrSW5kZXhdLFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9LFxuICAgICAgICBmb2N1czoge1xuICAgICAgICAgIHBhdGg6IFtlbmRCbG9ja0luZGV4XSxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1vZGU6IFwiaGlnaGVzdFwiXG4gICAgfSksIG9wZXJhdGlvbi5lZGl0b3IuY2hpbGRyZW4ubGVuZ3RoID09PSAwICYmIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMob3BlcmF0aW9uLmVkaXRvciwgY3JlYXRlUGxhY2Vob2xkZXJCbG9jayhjb250ZXh0KSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJhbmdlID0gdG9TbGF0ZVJhbmdlKHtcbiAgICBjb250ZXh0OiB7XG4gICAgICBzY2hlbWE6IGNvbnRleHQuc2NoZW1hLFxuICAgICAgdmFsdWU6IG9wZXJhdGlvbi5lZGl0b3IudmFsdWUsXG4gICAgICBzZWxlY3Rpb246IG9wZXJhdGlvbi5hdFxuICAgIH0sXG4gICAgYmxvY2tJbmRleE1hcDogb3BlcmF0aW9uLmVkaXRvci5ibG9ja0luZGV4TWFwXG4gIH0pO1xuICBpZiAoIXJhbmdlKVxuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCBTbGF0ZSBSYW5nZSBmb3Igc2VsZWN0aW9uICR7SlNPTi5zdHJpbmdpZnkob3BlcmF0aW9uLmF0KX1gKTtcbiAgaWYgKG9wZXJhdGlvbi5kaXJlY3Rpb24gPT09IFwiYmFja3dhcmRcIiAmJiBvcGVyYXRpb24udW5pdCA9PT0gXCJsaW5lXCIpIHtcbiAgICBjb25zdCBwYXJlbnRCbG9ja0VudHJ5ID0gRWRpdG9yLmFib3ZlKG9wZXJhdGlvbi5lZGl0b3IsIHtcbiAgICAgIG1hdGNoOiAobikgPT4gRWxlbWVudCQxLmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhvcGVyYXRpb24uZWRpdG9yLCBuKSxcbiAgICAgIGF0OiByYW5nZVxuICAgIH0pO1xuICAgIGlmIChwYXJlbnRCbG9ja0VudHJ5KSB7XG4gICAgICBjb25zdCBbLCBwYXJlbnRCbG9ja1BhdGhdID0gcGFyZW50QmxvY2tFbnRyeSwgcGFyZW50RWxlbWVudFJhbmdlID0gRWRpdG9yLnJhbmdlKG9wZXJhdGlvbi5lZGl0b3IsIHBhcmVudEJsb2NrUGF0aCwgcmFuZ2UuYW5jaG9yKSwgY3VycmVudExpbmVSYW5nZSA9IGZpbmRDdXJyZW50TGluZVJhbmdlKG9wZXJhdGlvbi5lZGl0b3IsIHBhcmVudEVsZW1lbnRSYW5nZSk7XG4gICAgICBpZiAoIVJhbmdlLmlzQ29sbGFwc2VkKGN1cnJlbnRMaW5lUmFuZ2UpKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKG9wZXJhdGlvbi5lZGl0b3IsIHtcbiAgICAgICAgICBhdDogY3VycmVudExpbmVSYW5nZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBoYW5naW5nID0gaXNUZXh0QmxvY2soY29udGV4dCwgZW5kQmxvY2spICYmIGVuZE9mZnNldCA9PT0gMDtcbiAgZGVsZXRlVGV4dChvcGVyYXRpb24uZWRpdG9yLCB7XG4gICAgYXQ6IHJhbmdlLFxuICAgIHJldmVyc2U6IG9wZXJhdGlvbi5kaXJlY3Rpb24gPT09IFwiYmFja3dhcmRcIixcbiAgICB1bml0OiBvcGVyYXRpb24udW5pdCxcbiAgICBoYW5naW5nXG4gIH0pLCBvcGVyYXRpb24uZWRpdG9yLnNlbGVjdGlvbiAmJiBpc1RleHRCbG9jayhjb250ZXh0LCBzdGFydEJsb2NrKSAmJiBpc1RleHRCbG9jayhjb250ZXh0LCBlbmRCbG9jaykgJiYgc2V0U2VsZWN0aW9uKG9wZXJhdGlvbi5lZGl0b3IsIHtcbiAgICBhbmNob3I6IG9wZXJhdGlvbi5lZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLFxuICAgIGZvY3VzOiBvcGVyYXRpb24uZWRpdG9yLnNlbGVjdGlvbi5mb2N1c1xuICB9KTtcbn07XG5mdW5jdGlvbiBmaW5kQ3VycmVudExpbmVSYW5nZShlZGl0b3IsIHBhcmVudFJhbmdlKSB7XG4gIGNvbnN0IHBhcmVudFJhbmdlQm91bmRhcnkgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBSYW5nZS5lbmQocGFyZW50UmFuZ2UpKSwgcG9zaXRpb25zID0gQXJyYXkuZnJvbShFZGl0b3IucG9zaXRpb25zKGVkaXRvciwge1xuICAgIGF0OiBwYXJlbnRSYW5nZVxuICB9KSk7XG4gIGxldCBsZWZ0ID0gMCwgcmlnaHQgPSBwb3NpdGlvbnMubGVuZ3RoLCBtaWRkbGUgPSBNYXRoLmZsb29yKHJpZ2h0IC8gMik7XG4gIGlmIChyYW5nZXNBcmVPblNhbWVMaW5lKGVkaXRvciwgRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9zaXRpb25zW2xlZnRdKSwgcGFyZW50UmFuZ2VCb3VuZGFyeSkpXG4gICAgcmV0dXJuIEVkaXRvci5yYW5nZShlZGl0b3IsIHBvc2l0aW9uc1tsZWZ0XSwgcGFyZW50UmFuZ2VCb3VuZGFyeSk7XG4gIGlmIChwb3NpdGlvbnMubGVuZ3RoIDwgMilcbiAgICByZXR1cm4gRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9zaXRpb25zW3Bvc2l0aW9ucy5sZW5ndGggLSAxXSwgcGFyZW50UmFuZ2VCb3VuZGFyeSk7XG4gIGZvciAoOyBtaWRkbGUgIT09IHBvc2l0aW9ucy5sZW5ndGggJiYgbWlkZGxlICE9PSBsZWZ0OyApXG4gICAgcmFuZ2VzQXJlT25TYW1lTGluZShlZGl0b3IsIEVkaXRvci5yYW5nZShlZGl0b3IsIHBvc2l0aW9uc1ttaWRkbGVdKSwgcGFyZW50UmFuZ2VCb3VuZGFyeSkgPyByaWdodCA9IG1pZGRsZSA6IGxlZnQgPSBtaWRkbGUsIG1pZGRsZSA9IE1hdGguZmxvb3IoKGxlZnQgKyByaWdodCkgLyAyKTtcbiAgcmV0dXJuIEVkaXRvci5yYW5nZShlZGl0b3IsIHBvc2l0aW9uc1tsZWZ0XSwgcGFyZW50UmFuZ2VCb3VuZGFyeSk7XG59XG5mdW5jdGlvbiByYW5nZXNBcmVPblNhbWVMaW5lKGVkaXRvciwgcmFuZ2UxLCByYW5nZTIpIHtcbiAgY29uc3QgcmVjdDEgPSBET01FZGl0b3IudG9ET01SYW5nZShlZGl0b3IsIHJhbmdlMSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHJlY3QyID0gRE9NRWRpdG9yLnRvRE9NUmFuZ2UoZWRpdG9yLCByYW5nZTIpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4gZG9tUmVjdHNJbnRlcnNlY3QocmVjdDEsIHJlY3QyKSAmJiBkb21SZWN0c0ludGVyc2VjdChyZWN0MiwgcmVjdDEpO1xufVxuZnVuY3Rpb24gZG9tUmVjdHNJbnRlcnNlY3QocmVjdCwgY29tcGFyZVJlY3QpIHtcbiAgY29uc3QgbWlkZGxlID0gKGNvbXBhcmVSZWN0LnRvcCArIGNvbXBhcmVSZWN0LmJvdHRvbSkgLyAyO1xuICByZXR1cm4gcmVjdC50b3AgPD0gbWlkZGxlICYmIHJlY3QuYm90dG9tID49IG1pZGRsZTtcbn1cbmNvbnN0IGluc2VydEJsb2NrT3BlcmF0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBjb250ZXh0LFxuICBvcGVyYXRpb25cbn0pID0+IHtcbiAgY29uc3QgcGFyc2VkQmxvY2sgPSBwYXJzZUJsb2NrKHtcbiAgICBibG9jazogb3BlcmF0aW9uLmJsb2NrLFxuICAgIGNvbnRleHQsXG4gICAgb3B0aW9uczoge1xuICAgICAgcmVtb3ZlVW51c2VkTWFya0RlZnM6ICEwLFxuICAgICAgdmFsaWRhdGVGaWVsZHM6ICEwXG4gICAgfVxuICB9KTtcbiAgaWYgKCFwYXJzZWRCbG9jaylcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBibG9jayAke0pTT04uc3RyaW5naWZ5KG9wZXJhdGlvbi5ibG9jayl9YCk7XG4gIGNvbnN0IGZyYWdtZW50ID0gdG9TbGF0ZVZhbHVlKFtwYXJzZWRCbG9ja10sIHtcbiAgICBzY2hlbWFUeXBlczogY29udGV4dC5zY2hlbWFcbiAgfSlbMF07XG4gIGlmICghZnJhZ21lbnQpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY29udmVydCBibG9jayB0byBTbGF0ZSBmcmFnbWVudCAke0pTT04uc3RyaW5naWZ5KHBhcnNlZEJsb2NrKX1gKTtcbiAgaW5zZXJ0QmxvY2soe1xuICAgIGNvbnRleHQsXG4gICAgYmxvY2s6IGZyYWdtZW50LFxuICAgIHBsYWNlbWVudDogb3BlcmF0aW9uLnBsYWNlbWVudCxcbiAgICBzZWxlY3Q6IG9wZXJhdGlvbi5zZWxlY3QgPz8gXCJzdGFydFwiLFxuICAgIGVkaXRvcjogb3BlcmF0aW9uLmVkaXRvclxuICB9KTtcbn07XG5mdW5jdGlvbiBpbnNlcnRCbG9jayh7XG4gIGNvbnRleHQsXG4gIGJsb2NrLFxuICBwbGFjZW1lbnQsXG4gIHNlbGVjdCxcbiAgZWRpdG9yXG59KSB7XG4gIGNvbnN0IFtzdGFydEJsb2NrLCBzdGFydEJsb2NrUGF0aF0gPSBnZXRTZWxlY3Rpb25TdGFydEJsb2NrKHtcbiAgICBlZGl0b3JcbiAgfSksIFtlbmRCbG9jaywgZW5kQmxvY2tQYXRoXSA9IGdldFNlbGVjdGlvbkVuZEJsb2NrKHtcbiAgICBlZGl0b3JcbiAgfSk7XG4gIGlmICghZWRpdG9yLnNlbGVjdGlvbiB8fCAhc3RhcnRCbG9jayB8fCAhc3RhcnRCbG9ja1BhdGggfHwgIWVuZEJsb2NrIHx8ICFlbmRCbG9ja1BhdGgpIHtcbiAgICBzZWxlY3QgIT09IFwibm9uZVwiICYmIERPTUVkaXRvci5mb2N1cyhlZGl0b3IpO1xuICAgIGNvbnN0IFtsYXN0QmxvY2ssIGxhc3RCbG9ja1BhdGhdID0gZ2V0TGFzdEJsb2NrKHtcbiAgICAgIGVkaXRvclxuICAgIH0pO1xuICAgIGlmIChwbGFjZW1lbnQgPT09IFwiYmVmb3JlXCIpXG4gICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgW2Jsb2NrXSwge1xuICAgICAgICBhdDogWzBdXG4gICAgICB9KSwgc2VsZWN0ID09PSBcInN0YXJ0XCIgPyBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIEVkaXRvci5zdGFydChlZGl0b3IsIFswXSkpIDogc2VsZWN0ID09PSBcImVuZFwiICYmIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgRWRpdG9yLmVuZChlZGl0b3IsIFswXSkpO1xuICAgIGVsc2UgaWYgKHBsYWNlbWVudCA9PT0gXCJhZnRlclwiKSB7XG4gICAgICBjb25zdCBuZXh0UGF0aCA9IGxhc3RCbG9ja1BhdGggPyBbbGFzdEJsb2NrUGF0aFswXSArIDFdIDogWzBdO1xuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIFtibG9ja10sIHtcbiAgICAgICAgYXQ6IG5leHRQYXRoXG4gICAgICB9KSwgc2VsZWN0ID09PSBcInN0YXJ0XCIgPyBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIEVkaXRvci5zdGFydChlZGl0b3IsIG5leHRQYXRoKSkgOiBzZWxlY3QgPT09IFwiZW5kXCIgJiYgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBFZGl0b3IuZW5kKGVkaXRvciwgbmV4dFBhdGgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxhc3RCbG9jayAmJiBpc0VxdWFsVG9FbXB0eUVkaXRvcihbbGFzdEJsb2NrXSwgY29udGV4dC5zY2hlbWEpKSB7XG4gICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGxhc3RCbG9ja1BhdGhcbiAgICAgICAgfSksIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBbYmxvY2tdLCB7XG4gICAgICAgICAgYXQ6IGxhc3RCbG9ja1BhdGgsXG4gICAgICAgICAgc2VsZWN0OiAhMVxuICAgICAgICB9KSwgVHJhbnNmb3Jtcy5kZXNlbGVjdChlZGl0b3IpLCBzZWxlY3QgPT09IFwic3RhcnRcIiA/IFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgRWRpdG9yLnN0YXJ0KGVkaXRvciwgbGFzdEJsb2NrUGF0aCkpIDogc2VsZWN0ID09PSBcImVuZFwiICYmIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgRWRpdG9yLmVuZChlZGl0b3IsIGxhc3RCbG9ja1BhdGgpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgbGFzdEJsb2NrICYmIGVkaXRvci5pc1RleHRCbG9jayhsYXN0QmxvY2spKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbkJlZm9yZSA9IEVkaXRvci5lbmQoZWRpdG9yLCBsYXN0QmxvY2tQYXRoKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnRGcmFnbWVudChlZGl0b3IsIFtibG9ja10sIHtcbiAgICAgICAgICBhdDogRWRpdG9yLmVuZChlZGl0b3IsIGxhc3RCbG9ja1BhdGgpXG4gICAgICAgIH0pLCBzZWxlY3QgPT09IFwic3RhcnRcIiA/IFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc2VsZWN0aW9uQmVmb3JlKSA6IHNlbGVjdCA9PT0gXCJub25lXCIgJiYgVHJhbnNmb3Jtcy5kZXNlbGVjdChlZGl0b3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0UGF0aCA9IGxhc3RCbG9ja1BhdGggPyBbbGFzdEJsb2NrUGF0aFswXSArIDFdIDogWzBdO1xuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIFtibG9ja10sIHtcbiAgICAgICAgYXQ6IG5leHRQYXRoLFxuICAgICAgICBzZWxlY3Q6ICExXG4gICAgICB9KSwgc2VsZWN0ID09PSBcInN0YXJ0XCIgPyBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIEVkaXRvci5zdGFydChlZGl0b3IsIG5leHRQYXRoKSkgOiBzZWxlY3QgPT09IFwiZW5kXCIgJiYgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBFZGl0b3IuZW5kKGVkaXRvciwgbmV4dFBhdGgpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocGxhY2VtZW50ID09PSBcImJlZm9yZVwiKSB7XG4gICAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb24sIHNlbGVjdGlvblN0YXJ0UG9pbnQgPSBSYW5nZS5zdGFydChjdXJyZW50U2VsZWN0aW9uKTtcbiAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgW2Jsb2NrXSwge1xuICAgICAgYXQ6IFtzZWxlY3Rpb25TdGFydFBvaW50LnBhdGhbMF1dLFxuICAgICAgc2VsZWN0OiAhMVxuICAgIH0pLCBzZWxlY3QgPT09IFwic3RhcnRcIiA/IFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgRWRpdG9yLnN0YXJ0KGVkaXRvciwgW3NlbGVjdGlvblN0YXJ0UG9pbnQucGF0aFswXV0pKSA6IHNlbGVjdCA9PT0gXCJlbmRcIiAmJiBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIEVkaXRvci5lbmQoZWRpdG9yLCBbc2VsZWN0aW9uU3RhcnRQb2ludC5wYXRoWzBdXSkpO1xuICB9IGVsc2UgaWYgKHBsYWNlbWVudCA9PT0gXCJhZnRlclwiKSB7XG4gICAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb24sIG5leHRQYXRoID0gW1JhbmdlLmVuZChjdXJyZW50U2VsZWN0aW9uKS5wYXRoWzBdICsgMV07XG4gICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIFtibG9ja10sIHtcbiAgICAgIGF0OiBuZXh0UGF0aCxcbiAgICAgIHNlbGVjdDogITFcbiAgICB9KSwgc2VsZWN0ID09PSBcInN0YXJ0XCIgPyBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIEVkaXRvci5zdGFydChlZGl0b3IsIG5leHRQYXRoKSkgOiBzZWxlY3QgPT09IFwiZW5kXCIgJiYgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBFZGl0b3IuZW5kKGVkaXRvciwgbmV4dFBhdGgpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjdXJyZW50U2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbiwgZW5kQmxvY2tFbmRQb2ludCA9IEVkaXRvci5zdGFydChlZGl0b3IsIGVuZEJsb2NrUGF0aCk7XG4gICAgaWYgKFJhbmdlLmlzRXhwYW5kZWQoY3VycmVudFNlbGVjdGlvbikgJiYgIWVkaXRvci5pc1RleHRCbG9jayhibG9jaykpIHtcbiAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICBhdDogY3VycmVudFNlbGVjdGlvblxuICAgICAgfSk7XG4gICAgICBjb25zdCBuZXdTZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uLCBbZm9jdXNCbG9jaywgZm9jdXNCbG9ja1BhdGhdID0gZ2V0Rm9jdXNCbG9jayh7XG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgW2Jsb2NrXSwge1xuICAgICAgICB2b2lkczogITBcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYWRqdXN0ZWRTZWxlY3Rpb24gPSBuZXdTZWxlY3Rpb24uYW5jaG9yLm9mZnNldCA9PT0gMCA/IFJhbmdlLnRyYW5zZm9ybShuZXdTZWxlY3Rpb24sIHtcbiAgICAgICAgdHlwZTogXCJpbnNlcnRfbm9kZVwiLFxuICAgICAgICBub2RlOiBibG9jayxcbiAgICAgICAgcGF0aDogW25ld1NlbGVjdGlvbi5hbmNob3IucGF0aFswXV1cbiAgICAgIH0pIDogbmV3U2VsZWN0aW9uO1xuICAgICAgc2VsZWN0ID09PSBcIm5vbmVcIiAmJiBhZGp1c3RlZFNlbGVjdGlvbiAmJiBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIGFkanVzdGVkU2VsZWN0aW9uKSwgZm9jdXNCbG9jayAmJiBpc0VxdWFsVG9FbXB0eUVkaXRvcihbZm9jdXNCbG9ja10sIGNvbnRleHQuc2NoZW1hKSAmJiBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogZm9jdXNCbG9ja1BhdGhcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKGVuZEJsb2NrKSAmJiBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spKSB7XG4gICAgICBjb25zdCBzZWxlY3Rpb25TdGFydFBvaW50ID0gUmFuZ2Uuc3RhcnQoY3VycmVudFNlbGVjdGlvbik7XG4gICAgICBpZiAoaXNFcXVhbFRvRW1wdHlFZGl0b3IoW2VuZEJsb2NrXSwgY29udGV4dC5zY2hlbWEpKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTZWxlY3Rpb24yID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIFtibG9ja10sIHtcbiAgICAgICAgICBhdDogZW5kQmxvY2tQYXRoLFxuICAgICAgICAgIHNlbGVjdDogITFcbiAgICAgICAgfSksIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IFBhdGgubmV4dChlbmRCbG9ja1BhdGgpXG4gICAgICAgIH0pLCBzZWxlY3QgPT09IFwic3RhcnRcIiA/IFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc2VsZWN0aW9uU3RhcnRQb2ludCkgOiBzZWxlY3QgPT09IFwiZW5kXCIgPyBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIEVkaXRvci5lbmQoZWRpdG9yLCBlbmRCbG9ja1BhdGgpKSA6IFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgY3VycmVudFNlbGVjdGlvbjIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBlbmRCbG9ja0NoaWxkS2V5cyA9IGVuZEJsb2NrLmNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IGNoaWxkLl9rZXkpLCBlbmRCbG9ja01hcmtEZWZzS2V5cyA9IGVuZEJsb2NrLm1hcmtEZWZzPy5tYXAoKG1hcmtEZWYpID0+IG1hcmtEZWYuX2tleSkgPz8gW10sIG1hcmtEZWZLZXlNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBhZGp1c3RlZE1hcmtEZWZzID0gYmxvY2subWFya0RlZnM/Lm1hcCgobWFya0RlZikgPT4ge1xuICAgICAgICBpZiAoZW5kQmxvY2tNYXJrRGVmc0tleXMuaW5jbHVkZXMobWFya0RlZi5fa2V5KSkge1xuICAgICAgICAgIGNvbnN0IG5ld0tleSA9IGNvbnRleHQua2V5R2VuZXJhdG9yKCk7XG4gICAgICAgICAgcmV0dXJuIG1hcmtEZWZLZXlNYXAuc2V0KG1hcmtEZWYuX2tleSwgbmV3S2V5KSwge1xuICAgICAgICAgICAgLi4ubWFya0RlZixcbiAgICAgICAgICAgIF9rZXk6IG5ld0tleVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcmtEZWY7XG4gICAgICB9KSwgYWRqdXN0ZWRDaGlsZHJlbiA9IGJsb2NrLmNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IHtcbiAgICAgICAgaWYgKGlzU3Bhbihjb250ZXh0LCBjaGlsZCkpIHtcbiAgICAgICAgICBjb25zdCBtYXJrcyA9IGNoaWxkLm1hcmtzPy5tYXAoKG1hcmspID0+IG1hcmtEZWZLZXlNYXAuZ2V0KG1hcmspIHx8IG1hcmspID8/IFtdO1xuICAgICAgICAgIGlmICghaXNFcXVhbChjaGlsZC5tYXJrcywgbWFya3MpKVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uY2hpbGQsXG4gICAgICAgICAgICAgIF9rZXk6IGVuZEJsb2NrQ2hpbGRLZXlzLmluY2x1ZGVzKGNoaWxkLl9rZXkpID8gY29udGV4dC5rZXlHZW5lcmF0b3IoKSA6IGNoaWxkLl9rZXksXG4gICAgICAgICAgICAgIG1hcmtzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmRCbG9ja0NoaWxkS2V5cy5pbmNsdWRlcyhjaGlsZC5fa2V5KSA/IHtcbiAgICAgICAgICAuLi5jaGlsZCxcbiAgICAgICAgICBfa2V5OiBjb250ZXh0LmtleUdlbmVyYXRvcigpXG4gICAgICAgIH0gOiBjaGlsZDtcbiAgICAgIH0pO1xuICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgbWFya0RlZnM6IFsuLi5lbmRCbG9jay5tYXJrRGVmcyA/PyBbXSwgLi4uYWRqdXN0ZWRNYXJrRGVmcyA/PyBbXV1cbiAgICAgIH0sIHtcbiAgICAgICAgYXQ6IGVuZEJsb2NrUGF0aFxuICAgICAgfSk7XG4gICAgICBjb25zdCBhZGp1c3RlZEJsb2NrID0gaXNFcXVhbChibG9jay5jaGlsZHJlbiwgYWRqdXN0ZWRDaGlsZHJlbikgPyBibG9jayA6IHtcbiAgICAgICAgLi4uYmxvY2ssXG4gICAgICAgIGNoaWxkcmVuOiBhZGp1c3RlZENoaWxkcmVuXG4gICAgICB9O1xuICAgICAgaWYgKHNlbGVjdCA9PT0gXCJlbmRcIikge1xuICAgICAgICBUcmFuc2Zvcm1zLmluc2VydEZyYWdtZW50KGVkaXRvciwgW2FkanVzdGVkQmxvY2tdLCB7XG4gICAgICAgICAgdm9pZHM6ICEwXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydEZyYWdtZW50KGVkaXRvciwgW2FkanVzdGVkQmxvY2tdLCB7XG4gICAgICAgIGF0OiBjdXJyZW50U2VsZWN0aW9uLFxuICAgICAgICB2b2lkczogITBcbiAgICAgIH0pLCBzZWxlY3QgPT09IFwic3RhcnRcIiA/IFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc2VsZWN0aW9uU3RhcnRQb2ludCkgOiBQb2ludC5lcXVhbHMoc2VsZWN0aW9uU3RhcnRQb2ludCwgZW5kQmxvY2tFbmRQb2ludCkgfHwgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzZWxlY3Rpb25TdGFydFBvaW50KTtcbiAgICB9IGVsc2UgaWYgKGVkaXRvci5pc1RleHRCbG9jayhlbmRCbG9jaykpIHtcbiAgICAgIGNvbnN0IGVuZEJsb2NrU3RhcnRQb2ludCA9IEVkaXRvci5zdGFydChlZGl0b3IsIGVuZEJsb2NrUGF0aCksIGVuZEJsb2NrRW5kUG9pbnQyID0gRWRpdG9yLmVuZChlZGl0b3IsIGVuZEJsb2NrUGF0aCksIHNlbGVjdGlvblN0YXJ0UG9pbnQgPSBSYW5nZS5zdGFydChjdXJyZW50U2VsZWN0aW9uKSwgc2VsZWN0aW9uRW5kUG9pbnQgPSBSYW5nZS5lbmQoY3VycmVudFNlbGVjdGlvbik7XG4gICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoY3VycmVudFNlbGVjdGlvbikgJiYgUG9pbnQuZXF1YWxzKHNlbGVjdGlvblN0YXJ0UG9pbnQsIGVuZEJsb2NrU3RhcnRQb2ludCkpXG4gICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBbYmxvY2tdLCB7XG4gICAgICAgICAgYXQ6IGVuZEJsb2NrUGF0aCxcbiAgICAgICAgICBzZWxlY3Q6ICExXG4gICAgICAgIH0pLCAoc2VsZWN0ID09PSBcInN0YXJ0XCIgfHwgc2VsZWN0ID09PSBcImVuZFwiKSAmJiBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIEVkaXRvci5zdGFydChlZGl0b3IsIGVuZEJsb2NrUGF0aCkpLCBpc0VtcHR5VGV4dEJsb2NrKGNvbnRleHQsIGVuZEJsb2NrKSAmJiBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBQYXRoLm5leHQoZW5kQmxvY2tQYXRoKVxuICAgICAgICB9KTtcbiAgICAgIGVsc2UgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGN1cnJlbnRTZWxlY3Rpb24pICYmIFBvaW50LmVxdWFscyhzZWxlY3Rpb25FbmRQb2ludCwgZW5kQmxvY2tFbmRQb2ludDIpKSB7XG4gICAgICAgIGNvbnN0IG5leHRQYXRoID0gW2VuZEJsb2NrUGF0aFswXSArIDFdO1xuICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgW2Jsb2NrXSwge1xuICAgICAgICAgIGF0OiBuZXh0UGF0aCxcbiAgICAgICAgICBzZWxlY3Q6ICExXG4gICAgICAgIH0pLCAoc2VsZWN0ID09PSBcInN0YXJ0XCIgfHwgc2VsZWN0ID09PSBcImVuZFwiKSAmJiBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIEVkaXRvci5zdGFydChlZGl0b3IsIG5leHRQYXRoKSk7XG4gICAgICB9IGVsc2UgaWYgKFJhbmdlLmlzRXhwYW5kZWQoY3VycmVudFNlbGVjdGlvbikgJiYgUG9pbnQuZXF1YWxzKHNlbGVjdGlvblN0YXJ0UG9pbnQsIGVuZEJsb2NrU3RhcnRQb2ludCkgJiYgUG9pbnQuZXF1YWxzKHNlbGVjdGlvbkVuZFBvaW50LCBlbmRCbG9ja0VuZFBvaW50MikpXG4gICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0RnJhZ21lbnQoZWRpdG9yLCBbYmxvY2tdLCB7XG4gICAgICAgICAgYXQ6IGN1cnJlbnRTZWxlY3Rpb25cbiAgICAgICAgfSksIHNlbGVjdCA9PT0gXCJzdGFydFwiID8gVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBlbmRCbG9ja1BhdGgpKSA6IHNlbGVjdCA9PT0gXCJlbmRcIiAmJiBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIEVkaXRvci5lbmQoZWRpdG9yLCBlbmRCbG9ja1BhdGgpKTtcbiAgICAgIGVsc2UgaWYgKFJhbmdlLmlzRXhwYW5kZWQoY3VycmVudFNlbGVjdGlvbikgJiYgUG9pbnQuZXF1YWxzKHNlbGVjdGlvblN0YXJ0UG9pbnQsIGVuZEJsb2NrU3RhcnRQb2ludCkpXG4gICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0RnJhZ21lbnQoZWRpdG9yLCBbYmxvY2tdLCB7XG4gICAgICAgICAgYXQ6IGN1cnJlbnRTZWxlY3Rpb25cbiAgICAgICAgfSksIHNlbGVjdCA9PT0gXCJzdGFydFwiID8gVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBlbmRCbG9ja1BhdGgpKSA6IHNlbGVjdCA9PT0gXCJlbmRcIiAmJiBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIEVkaXRvci5lbmQoZWRpdG9yLCBlbmRCbG9ja1BhdGgpKTtcbiAgICAgIGVsc2UgaWYgKFJhbmdlLmlzRXhwYW5kZWQoY3VycmVudFNlbGVjdGlvbikgJiYgUG9pbnQuZXF1YWxzKHNlbGVjdGlvbkVuZFBvaW50LCBlbmRCbG9ja0VuZFBvaW50MikpXG4gICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0RnJhZ21lbnQoZWRpdG9yLCBbYmxvY2tdLCB7XG4gICAgICAgICAgYXQ6IGN1cnJlbnRTZWxlY3Rpb25cbiAgICAgICAgfSksIHNlbGVjdCA9PT0gXCJzdGFydFwiID8gVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBQYXRoLm5leHQoZW5kQmxvY2tQYXRoKSkpIDogc2VsZWN0ID09PSBcImVuZFwiICYmIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgRWRpdG9yLmVuZChlZGl0b3IsIFBhdGgubmV4dChlbmRCbG9ja1BhdGgpKSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgY3VycmVudFNlbGVjdGlvbjIgPSBlZGl0b3Iuc2VsZWN0aW9uLCBbZm9jdXNDaGlsZF0gPSBnZXRGb2N1c0NoaWxkKHtcbiAgICAgICAgICBlZGl0b3JcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChmb2N1c0NoaWxkICYmIGVkaXRvci5pc1RleHRTcGFuKGZvY3VzQ2hpbGQpKVxuICAgICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBjdXJyZW50U2VsZWN0aW9uMlxuICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLmluc2VydEZyYWdtZW50KGVkaXRvciwgW2Jsb2NrXSwge1xuICAgICAgICAgICAgYXQ6IGN1cnJlbnRTZWxlY3Rpb24yXG4gICAgICAgICAgfSksIHNlbGVjdCA9PT0gXCJzdGFydFwiIHx8IHNlbGVjdCA9PT0gXCJlbmRcIiA/IFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgW2VuZEJsb2NrUGF0aFswXSArIDFdKSA6IFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgY3VycmVudFNlbGVjdGlvbjIpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb25zdCBuZXh0UGF0aCA9IFtlbmRCbG9ja1BhdGhbMF0gKyAxXTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgW2Jsb2NrXSwge1xuICAgICAgICAgICAgYXQ6IG5leHRQYXRoLFxuICAgICAgICAgICAgc2VsZWN0OiAhMVxuICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIGN1cnJlbnRTZWxlY3Rpb24yKSwgc2VsZWN0ID09PSBcInN0YXJ0XCIgPyBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIEVkaXRvci5zdGFydChlZGl0b3IsIG5leHRQYXRoKSkgOiBzZWxlY3QgPT09IFwiZW5kXCIgJiYgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBFZGl0b3IuZW5kKGVkaXRvciwgbmV4dFBhdGgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgW2Jsb2NrXSwge1xuICAgICAgICBzZWxlY3Q6ICExXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG5leHRQYXRoID0gW2VuZEJsb2NrUGF0aFswXSArIDFdO1xuICAgICAgc2VsZWN0ID09PSBcInN0YXJ0XCIgPyBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIEVkaXRvci5zdGFydChlZGl0b3IsIG5leHRQYXRoKSkgOiBzZWxlY3QgPT09IFwiZW5kXCIgJiYgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBFZGl0b3IuZW5kKGVkaXRvciwgbmV4dFBhdGgpKTtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IGluc2VydENoaWxkT3BlcmF0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBjb250ZXh0LFxuICBvcGVyYXRpb25cbn0pID0+IHtcbiAgY29uc3QgZm9jdXMgPSBvcGVyYXRpb24uZWRpdG9yLnNlbGVjdGlvbj8uZm9jdXMsIGZvY3VzQmxvY2tJbmRleCA9IGZvY3VzPy5wYXRoLmF0KDApLCBmb2N1c0NoaWxkSW5kZXggPSBmb2N1cz8ucGF0aC5hdCgxKTtcbiAgaWYgKGZvY3VzQmxvY2tJbmRleCA9PT0gdm9pZCAwIHx8IGZvY3VzQ2hpbGRJbmRleCA9PT0gdm9pZCAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBpbnNlcnQgY2hpbGQgd2l0aG91dCBhIGZvY3VzXCIpO1xuICBjb25zdCBbZm9jdXNCbG9jaywgZm9jdXNCbG9ja1BhdGhdID0gZ2V0Rm9jdXNCbG9jayh7XG4gICAgZWRpdG9yOiBvcGVyYXRpb24uZWRpdG9yXG4gIH0pO1xuICBpZiAoIWZvY3VzIHx8ICFmb2N1c0Jsb2NrIHx8ICFmb2N1c0Jsb2NrUGF0aClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gaW5zZXJ0IGNoaWxkIHdpdGhvdXQgYSBmb2N1cyBibG9ja1wiKTtcbiAgaWYgKCFpc1RleHRCbG9jayhjb250ZXh0LCBmb2N1c0Jsb2NrKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gaW5zZXJ0IGNoaWxkIGludG8gYSBub24tdGV4dCBibG9ja1wiKTtcbiAgY29uc3QgbWFya0RlZnMgPSBmb2N1c0Jsb2NrLm1hcmtEZWZzID8/IFtdLCBtYXJrRGVmS2V5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZm9yIChjb25zdCBtYXJrRGVmIG9mIG1hcmtEZWZzKVxuICAgIG1hcmtEZWZLZXlNYXAuc2V0KG1hcmtEZWYuX2tleSwgbWFya0RlZi5fa2V5KTtcbiAgY29uc3Qgc3BhbiA9IHBhcnNlU3Bhbih7XG4gICAgc3Bhbjogb3BlcmF0aW9uLmNoaWxkLFxuICAgIGNvbnRleHQsXG4gICAgbWFya0RlZktleU1hcCxcbiAgICBvcHRpb25zOiB7XG4gICAgICB2YWxpZGF0ZUZpZWxkczogITBcbiAgICB9XG4gIH0pO1xuICBpZiAoc3Bhbikge1xuICAgIGNvbnN0IFtmb2N1c1NwYW5dID0gZ2V0Rm9jdXNTcGFuKHtcbiAgICAgIGVkaXRvcjogb3BlcmF0aW9uLmVkaXRvclxuICAgIH0pO1xuICAgIGZvY3VzU3BhbiA/IFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMob3BlcmF0aW9uLmVkaXRvciwgc3Bhbiwge1xuICAgICAgYXQ6IGZvY3VzLFxuICAgICAgc2VsZWN0OiAhMFxuICAgIH0pIDogVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhvcGVyYXRpb24uZWRpdG9yLCBzcGFuLCB7XG4gICAgICBhdDogW2ZvY3VzQmxvY2tJbmRleCwgZm9jdXNDaGlsZEluZGV4ICsgMV0sXG4gICAgICBzZWxlY3Q6ICEwXG4gICAgfSksIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTi5zZXQob3BlcmF0aW9uLmVkaXRvciwgb3BlcmF0aW9uLmVkaXRvci5zZWxlY3Rpb24pO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBpbmxpbmVPYmplY3QgPSBwYXJzZUlubGluZU9iamVjdCh7XG4gICAgaW5saW5lT2JqZWN0OiBvcGVyYXRpb24uY2hpbGQsXG4gICAgY29udGV4dCxcbiAgICBvcHRpb25zOiB7XG4gICAgICB2YWxpZGF0ZUZpZWxkczogITBcbiAgICB9XG4gIH0pO1xuICBpZiAoaW5saW5lT2JqZWN0KSB7XG4gICAgY29uc3Qge1xuICAgICAgX2tleSxcbiAgICAgIF90eXBlLFxuICAgICAgLi4ucmVzdFxuICAgIH0gPSBpbmxpbmVPYmplY3Q7XG4gICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhvcGVyYXRpb24uZWRpdG9yLCB7XG4gICAgICBfa2V5LFxuICAgICAgX3R5cGUsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgX2tleTogVk9JRF9DSElMRF9LRVksXG4gICAgICAgIF90eXBlOiBcInNwYW5cIixcbiAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgbWFya3M6IFtdXG4gICAgICB9XSxcbiAgICAgIHZhbHVlOiByZXN0LFxuICAgICAgX19pbmxpbmU6ICEwXG4gICAgfSwge1xuICAgICAgYXQ6IFtmb2N1c0Jsb2NrSW5kZXgsIGZvY3VzQ2hpbGRJbmRleCArIDFdLFxuICAgICAgc2VsZWN0OiAhMFxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcGFyc2UgY2hpbGRcIik7XG59LCBpbnNlcnRUZXh0T3BlcmF0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBvcGVyYXRpb25cbn0pID0+IHtcbiAgVHJhbnNmb3Jtcy5pbnNlcnRUZXh0KG9wZXJhdGlvbi5lZGl0b3IsIG9wZXJhdGlvbi50ZXh0KTtcbn0sIG1vdmVCYWNrd2FyZE9wZXJhdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgb3BlcmF0aW9uXG59KSA9PiB7XG4gIFRyYW5zZm9ybXMubW92ZShvcGVyYXRpb24uZWRpdG9yLCB7XG4gICAgdW5pdDogXCJjaGFyYWN0ZXJcIixcbiAgICBkaXN0YW5jZTogb3BlcmF0aW9uLmRpc3RhbmNlLFxuICAgIHJldmVyc2U6ICEwXG4gIH0pO1xufSwgbW92ZUJsb2NrT3BlcmF0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBvcGVyYXRpb25cbn0pID0+IHtcbiAgY29uc3Qgb3JpZ2luS2V5ID0gZ2V0QmxvY2tLZXlGcm9tU2VsZWN0aW9uUG9pbnQoe1xuICAgIHBhdGg6IG9wZXJhdGlvbi5hdFxuICB9KTtcbiAgaWYgKCFvcmlnaW5LZXkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGdldCBibG9jayBrZXkgZnJvbSBzZWxlY3Rpb24gcG9pbnRcIik7XG4gIGNvbnN0IG9yaWdpbkJsb2NrSW5kZXggPSBvcGVyYXRpb24uZWRpdG9yLmJsb2NrSW5kZXhNYXAuZ2V0KG9yaWdpbktleSk7XG4gIGlmIChvcmlnaW5CbG9ja0luZGV4ID09PSB2b2lkIDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGdldCBibG9jayBpbmRleCBmcm9tIGJsb2NrIGtleVwiKTtcbiAgY29uc3QgZGVzdGluYXRpb25LZXkgPSBnZXRCbG9ja0tleUZyb21TZWxlY3Rpb25Qb2ludCh7XG4gICAgcGF0aDogb3BlcmF0aW9uLnRvXG4gIH0pO1xuICBpZiAoIWRlc3RpbmF0aW9uS2V5KVxuICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZXQgYmxvY2sga2V5IGZyb20gc2VsZWN0aW9uIHBvaW50XCIpO1xuICBjb25zdCBkZXN0aW5hdGlvbkJsb2NrSW5kZXggPSBvcGVyYXRpb24uZWRpdG9yLmJsb2NrSW5kZXhNYXAuZ2V0KGRlc3RpbmF0aW9uS2V5KTtcbiAgaWYgKGRlc3RpbmF0aW9uQmxvY2tJbmRleCA9PT0gdm9pZCAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZXQgYmxvY2sgaW5kZXggZnJvbSBibG9jayBrZXlcIik7XG4gIFRyYW5zZm9ybXMubW92ZU5vZGVzKG9wZXJhdGlvbi5lZGl0b3IsIHtcbiAgICBhdDogW29yaWdpbkJsb2NrSW5kZXhdLFxuICAgIHRvOiBbZGVzdGluYXRpb25CbG9ja0luZGV4XSxcbiAgICBtb2RlOiBcImhpZ2hlc3RcIlxuICB9KTtcbn0sIG1vdmVGb3J3YXJkT3BlcmF0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBvcGVyYXRpb25cbn0pID0+IHtcbiAgVHJhbnNmb3Jtcy5tb3ZlKG9wZXJhdGlvbi5lZGl0b3IsIHtcbiAgICB1bml0OiBcImNoYXJhY3RlclwiLFxuICAgIGRpc3RhbmNlOiBvcGVyYXRpb24uZGlzdGFuY2VcbiAgfSk7XG59LCBzZWxlY3RPcGVyYXRpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIG9wZXJhdGlvblxufSkgPT4ge1xuICBjb25zdCBuZXdTZWxlY3Rpb24gPSB0b1NsYXRlUmFuZ2Uoe1xuICAgIGNvbnRleHQ6IHtcbiAgICAgIHNjaGVtYTogY29udGV4dC5zY2hlbWEsXG4gICAgICB2YWx1ZTogb3BlcmF0aW9uLmVkaXRvci52YWx1ZSxcbiAgICAgIHNlbGVjdGlvbjogb3BlcmF0aW9uLmF0XG4gICAgfSxcbiAgICBibG9ja0luZGV4TWFwOiBvcGVyYXRpb24uZWRpdG9yLmJsb2NrSW5kZXhNYXBcbiAgfSk7XG4gIG5ld1NlbGVjdGlvbiA/IFRyYW5zZm9ybXMuc2VsZWN0KG9wZXJhdGlvbi5lZGl0b3IsIG5ld1NlbGVjdGlvbikgOiBUcmFuc2Zvcm1zLmRlc2VsZWN0KG9wZXJhdGlvbi5lZGl0b3IpLCBJU19GT0NVU0VELmdldChvcGVyYXRpb24uZWRpdG9yKSAmJiBJU19SRUFEX09OTFkuZ2V0KG9wZXJhdGlvbi5lZGl0b3IpICYmIElTX0ZPQ1VTRUQuc2V0KG9wZXJhdGlvbi5lZGl0b3IsICExKTtcbn0sIGJlaGF2aW9yT3BlcmF0aW9uSW1wbGVtZW50YXRpb25zID0ge1xuICBcImFubm90YXRpb24uYWRkXCI6IGFkZEFubm90YXRpb25PcGVyYXRpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJhbm5vdGF0aW9uLnJlbW92ZVwiOiByZW1vdmVBbm5vdGF0aW9uT3BlcmF0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwiYmxvY2suc2V0XCI6IGJsb2NrU2V0T3BlcmF0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwiYmxvY2sudW5zZXRcIjogYmxvY2tVbnNldE9wZXJhdGlvbkltcGxlbWVudGF0aW9uLFxuICBcImNoaWxkLnNldFwiOiBjaGlsZFNldE9wZXJhdGlvbkltcGxlbWVudGF0aW9uLFxuICBcImNoaWxkLnVuc2V0XCI6IGNoaWxkVW5zZXRPcGVyYXRpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJkZWNvcmF0b3IuYWRkXCI6IGRlY29yYXRvckFkZE9wZXJhdGlvbkltcGxlbWVudGF0aW9uLFxuICBcImRlY29yYXRvci5yZW1vdmVcIjogcmVtb3ZlRGVjb3JhdG9yT3BlcmF0aW9uSW1wbGVtZW50YXRpb24sXG4gIGRlbGV0ZTogZGVsZXRlT3BlcmF0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwiaGlzdG9yeS5yZWRvXCI6IGhpc3RvcnlSZWRvT3BlcmF0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwiaGlzdG9yeS51bmRvXCI6IGhpc3RvcnlVbmRvT3BlcmF0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwiaW5zZXJ0LmJsb2NrXCI6IGluc2VydEJsb2NrT3BlcmF0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwiaW5zZXJ0LmNoaWxkXCI6IGluc2VydENoaWxkT3BlcmF0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwiaW5zZXJ0LnRleHRcIjogaW5zZXJ0VGV4dE9wZXJhdGlvbkltcGxlbWVudGF0aW9uLFxuICBcIm1vdmUuYmFja3dhcmRcIjogbW92ZUJhY2t3YXJkT3BlcmF0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwibW92ZS5ibG9ja1wiOiBtb3ZlQmxvY2tPcGVyYXRpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJtb3ZlLmZvcndhcmRcIjogbW92ZUZvcndhcmRPcGVyYXRpb25JbXBsZW1lbnRhdGlvbixcbiAgc2VsZWN0OiBzZWxlY3RPcGVyYXRpb25JbXBsZW1lbnRhdGlvblxufTtcbmZ1bmN0aW9uIHBlcmZvcm1PcGVyYXRpb24oe1xuICBjb250ZXh0LFxuICBvcGVyYXRpb25cbn0pIHtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhvcGVyYXRpb24uZWRpdG9yLCAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHN3aXRjaCAob3BlcmF0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImFubm90YXRpb24uYWRkXCI6IHtcbiAgICAgICAgICBiZWhhdmlvck9wZXJhdGlvbkltcGxlbWVudGF0aW9uc1tcImFubm90YXRpb24uYWRkXCJdKHtcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBvcGVyYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiYW5ub3RhdGlvbi5yZW1vdmVcIjoge1xuICAgICAgICAgIGJlaGF2aW9yT3BlcmF0aW9uSW1wbGVtZW50YXRpb25zW1wiYW5ub3RhdGlvbi5yZW1vdmVcIl0oe1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJibG9jay5zZXRcIjoge1xuICAgICAgICAgIGJlaGF2aW9yT3BlcmF0aW9uSW1wbGVtZW50YXRpb25zW1wiYmxvY2suc2V0XCJdKHtcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBvcGVyYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiYmxvY2sudW5zZXRcIjoge1xuICAgICAgICAgIGJlaGF2aW9yT3BlcmF0aW9uSW1wbGVtZW50YXRpb25zW1wiYmxvY2sudW5zZXRcIl0oe1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJjaGlsZC5zZXRcIjoge1xuICAgICAgICAgIGJlaGF2aW9yT3BlcmF0aW9uSW1wbGVtZW50YXRpb25zW1wiY2hpbGQuc2V0XCJdKHtcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBvcGVyYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiY2hpbGQudW5zZXRcIjoge1xuICAgICAgICAgIGJlaGF2aW9yT3BlcmF0aW9uSW1wbGVtZW50YXRpb25zW1wiY2hpbGQudW5zZXRcIl0oe1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJkZWNvcmF0b3IuYWRkXCI6IHtcbiAgICAgICAgICBiZWhhdmlvck9wZXJhdGlvbkltcGxlbWVudGF0aW9uc1tcImRlY29yYXRvci5hZGRcIl0oe1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJkZWNvcmF0b3IucmVtb3ZlXCI6IHtcbiAgICAgICAgICBiZWhhdmlvck9wZXJhdGlvbkltcGxlbWVudGF0aW9uc1tcImRlY29yYXRvci5yZW1vdmVcIl0oe1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJkZWxldGVcIjoge1xuICAgICAgICAgIGJlaGF2aW9yT3BlcmF0aW9uSW1wbGVtZW50YXRpb25zLmRlbGV0ZSh7XG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgb3BlcmF0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImhpc3RvcnkucmVkb1wiOiB7XG4gICAgICAgICAgYmVoYXZpb3JPcGVyYXRpb25JbXBsZW1lbnRhdGlvbnNbXCJoaXN0b3J5LnJlZG9cIl0oe1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJoaXN0b3J5LnVuZG9cIjoge1xuICAgICAgICAgIGJlaGF2aW9yT3BlcmF0aW9uSW1wbGVtZW50YXRpb25zW1wiaGlzdG9yeS51bmRvXCJdKHtcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBvcGVyYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiaW5zZXJ0LmJsb2NrXCI6IHtcbiAgICAgICAgICBiZWhhdmlvck9wZXJhdGlvbkltcGxlbWVudGF0aW9uc1tcImluc2VydC5ibG9ja1wiXSh7XG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgb3BlcmF0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImluc2VydC5jaGlsZFwiOiB7XG4gICAgICAgICAgYmVoYXZpb3JPcGVyYXRpb25JbXBsZW1lbnRhdGlvbnNbXCJpbnNlcnQuY2hpbGRcIl0oe1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJpbnNlcnQudGV4dFwiOiB7XG4gICAgICAgICAgYmVoYXZpb3JPcGVyYXRpb25JbXBsZW1lbnRhdGlvbnNbXCJpbnNlcnQudGV4dFwiXSh7XG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgb3BlcmF0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIm1vdmUuYmFja3dhcmRcIjoge1xuICAgICAgICAgIGJlaGF2aW9yT3BlcmF0aW9uSW1wbGVtZW50YXRpb25zW1wibW92ZS5iYWNrd2FyZFwiXSh7XG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgb3BlcmF0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIm1vdmUuYmxvY2tcIjoge1xuICAgICAgICAgIGJlaGF2aW9yT3BlcmF0aW9uSW1wbGVtZW50YXRpb25zW1wibW92ZS5ibG9ja1wiXSh7XG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgb3BlcmF0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIm1vdmUuZm9yd2FyZFwiOiB7XG4gICAgICAgICAgYmVoYXZpb3JPcGVyYXRpb25JbXBsZW1lbnRhdGlvbnNbXCJtb3ZlLmZvcndhcmRcIl0oe1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBiZWhhdmlvck9wZXJhdGlvbkltcGxlbWVudGF0aW9ucy5zZWxlY3Qoe1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobmV3IEVycm9yKGBFeGVjdXRpbmcgXCIke29wZXJhdGlvbi50eXBlfVwiIGZhaWxlZCBkdWUgdG86ICR7ZXJyb3IubWVzc2FnZX1gKSk7XG4gICAgfVxuICB9KTtcbn1cbmNvbnN0IElTX1BFUkZPUk1JTkdfT1BFUkFUSU9OID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiB3aXRoUGVyZm9ybWluZ0JlaGF2aW9yT3BlcmF0aW9uKGVkaXRvciwgZm4pIHtcbiAgY29uc3QgcHJldiA9IElTX1BFUkZPUk1JTkdfT1BFUkFUSU9OLmdldChlZGl0b3IpO1xuICBJU19QRVJGT1JNSU5HX09QRVJBVElPTi5zZXQoZWRpdG9yLCAhMCksIGZuKCksIElTX1BFUkZPUk1JTkdfT1BFUkFUSU9OLnNldChlZGl0b3IsIHByZXYpO1xufVxuZnVuY3Rpb24gaXNQZXJmb3JtaW5nQmVoYXZpb3JPcGVyYXRpb24oZWRpdG9yKSB7XG4gIHJldHVybiBJU19QRVJGT1JNSU5HX09QRVJBVElPTi5nZXQoZWRpdG9yKSA/PyAhMTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVdpdGhFdmVudExpc3RlbmVycyhlZGl0b3JBY3Rvcikge1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5tYXhCbG9ja3MgIT09IHZvaWQgMClcbiAgICAgIHJldHVybiBlZGl0b3I7XG4gICAgY29uc3Qge1xuICAgICAgZGVsZXRlOiBlZGl0b3JEZWxldGUsXG4gICAgICBzZWxlY3RcbiAgICB9ID0gZWRpdG9yO1xuICAgIHJldHVybiBlZGl0b3IuZGVsZXRlID0gKG9wdGlvbnMpID0+IHtcbiAgICAgIGlmIChpc1BlcmZvcm1pbmdCZWhhdmlvck9wZXJhdGlvbihlZGl0b3IpKSB7XG4gICAgICAgIGVkaXRvckRlbGV0ZShvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYXQgPSBvcHRpb25zPy5hdCA/PyBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgaWYgKCFhdCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiVW5leHBlY3RlZCBjYWxsIHRvIC5kZWxldGUoLi4uKSB3aXRob3V0IGBhdGAgb3B0aW9uXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KSwgc2VsZWN0aW9uID0gc2xhdGVSYW5nZVRvU2VsZWN0aW9uKHtcbiAgICAgICAgc2NoZW1hOiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLFxuICAgICAgICBlZGl0b3IsXG4gICAgICAgIHJhbmdlXG4gICAgICB9KTtcbiAgICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmV4cGVjdGVkIGNhbGwgdG8gLmRlbGV0ZSguLi4pIHdpdGggaW52YWxpZCBgYXRgIG9wdGlvblwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwiZGVsZXRlXCIsXG4gICAgICAgICAgYXQ6IHNlbGVjdGlvbixcbiAgICAgICAgICBkaXJlY3Rpb246IG9wdGlvbnM/LnJldmVyc2UgPyBcImJhY2t3YXJkXCIgOiBcImZvcndhcmRcIixcbiAgICAgICAgICB1bml0OiBvcHRpb25zPy51bml0XG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSwgZWRpdG9yLmRlbGV0ZUJhY2t3YXJkID0gKHVuaXQpID0+IHtcbiAgICAgIGlmIChpc1BlcmZvcm1pbmdCZWhhdmlvck9wZXJhdGlvbihlZGl0b3IpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmV4cGVjdGVkIGNhbGwgdG8gLmRlbGV0ZUJhY2t3YXJkKC4uLilcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImRlbGV0ZS5iYWNrd2FyZFwiLFxuICAgICAgICAgIHVuaXRcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9KTtcbiAgICB9LCBlZGl0b3IuZGVsZXRlRm9yd2FyZCA9ICh1bml0KSA9PiB7XG4gICAgICBpZiAoaXNQZXJmb3JtaW5nQmVoYXZpb3JPcGVyYXRpb24oZWRpdG9yKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiVW5leHBlY3RlZCBjYWxsIHRvIC5kZWxldGVGb3J3YXJkKC4uLilcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImRlbGV0ZS5mb3J3YXJkXCIsXG4gICAgICAgICAgdW5pdFxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3JcbiAgICAgIH0pO1xuICAgIH0sIGVkaXRvci5pbnNlcnRCcmVhayA9ICgpID0+IHtcbiAgICAgIGlmIChpc1BlcmZvcm1pbmdCZWhhdmlvck9wZXJhdGlvbihlZGl0b3IpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmV4cGVjdGVkIGNhbGwgdG8gLmluc2VydEJyZWFrKC4uLilcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImluc2VydC5icmVha1wiXG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSwgZWRpdG9yLmluc2VydERhdGEgPSAoZGF0YVRyYW5zZmVyKSA9PiB7XG4gICAgICBpZiAoaXNQZXJmb3JtaW5nQmVoYXZpb3JPcGVyYXRpb24oZWRpdG9yKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiVW5leHBlY3RlZCBjYWxsIHRvIC5pbnNlcnREYXRhKC4uLilcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImlucHV0LipcIixcbiAgICAgICAgICBvcmlnaW5FdmVudDoge1xuICAgICAgICAgICAgZGF0YVRyYW5zZmVyXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3JcbiAgICAgIH0pO1xuICAgIH0sIGVkaXRvci5pbnNlcnRTb2Z0QnJlYWsgPSAoKSA9PiB7XG4gICAgICBpZiAoaXNQZXJmb3JtaW5nQmVoYXZpb3JPcGVyYXRpb24oZWRpdG9yKSkge1xuICAgICAgICBwZXJmb3JtT3BlcmF0aW9uKHtcbiAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICBrZXlHZW5lcmF0b3I6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IsXG4gICAgICAgICAgICBzY2hlbWE6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWFcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9wZXJhdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogXCJpbnNlcnQudGV4dFwiLFxuICAgICAgICAgICAgdGV4dDogYFxuYCxcbiAgICAgICAgICAgIGVkaXRvclxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImluc2VydC5zb2Z0IGJyZWFrXCJcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9KTtcbiAgICB9LCBlZGl0b3IuaW5zZXJ0VGV4dCA9ICh0ZXh0KSA9PiB7XG4gICAgICBpZiAoaXNQZXJmb3JtaW5nQmVoYXZpb3JPcGVyYXRpb24oZWRpdG9yKSkge1xuICAgICAgICBwZXJmb3JtT3BlcmF0aW9uKHtcbiAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICBrZXlHZW5lcmF0b3I6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IsXG4gICAgICAgICAgICBzY2hlbWE6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWFcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9wZXJhdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogXCJpbnNlcnQudGV4dFwiLFxuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIGVkaXRvclxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImluc2VydC50ZXh0XCIsXG4gICAgICAgICAgdGV4dFxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3JcbiAgICAgIH0pO1xuICAgIH0sIGVkaXRvci5yZWRvID0gKCkgPT4ge1xuICAgICAgaWYgKGlzUGVyZm9ybWluZ0JlaGF2aW9yT3BlcmF0aW9uKGVkaXRvcikpIHtcbiAgICAgICAgcGVyZm9ybU9wZXJhdGlvbih7XG4gICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAga2V5R2VuZXJhdG9yOiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yLFxuICAgICAgICAgICAgc2NoZW1hOiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgICAgIHR5cGU6IFwiaGlzdG9yeS5yZWRvXCIsXG4gICAgICAgICAgICBlZGl0b3JcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJoaXN0b3J5LnJlZG9cIlxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3JcbiAgICAgIH0pO1xuICAgIH0sIGVkaXRvci5zZWxlY3QgPSAobG9jYXRpb24pID0+IHtcbiAgICAgIGlmIChpc1BlcmZvcm1pbmdCZWhhdmlvck9wZXJhdGlvbihlZGl0b3IpKSB7XG4gICAgICAgIHNlbGVjdChsb2NhdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgbG9jYXRpb24pO1xuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwic2VsZWN0XCIsXG4gICAgICAgICAgYXQ6IHNsYXRlUmFuZ2VUb1NlbGVjdGlvbih7XG4gICAgICAgICAgICBzY2hlbWE6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEsXG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICByYW5nZVxuICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSwgZWRpdG9yLnNldEZyYWdtZW50RGF0YSA9ICgpID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmV4cGVjdGVkIGNhbGwgdG8gLnNldEZyYWdtZW50RGF0YSguLi4pXCIpO1xuICAgIH0sIGVkaXRvci51bmRvID0gKCkgPT4ge1xuICAgICAgaWYgKGlzUGVyZm9ybWluZ0JlaGF2aW9yT3BlcmF0aW9uKGVkaXRvcikpIHtcbiAgICAgICAgcGVyZm9ybU9wZXJhdGlvbih7XG4gICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAga2V5R2VuZXJhdG9yOiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yLFxuICAgICAgICAgICAgc2NoZW1hOiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgICAgIHR5cGU6IFwiaGlzdG9yeS51bmRvXCIsXG4gICAgICAgICAgICBlZGl0b3JcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJoaXN0b3J5LnVuZG9cIlxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3JcbiAgICAgIH0pO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVdpdGhNYXhCbG9ja3MoZWRpdG9yQWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGFwcGx5OiBhcHBseTJcbiAgICB9ID0gZWRpdG9yO1xuICAgIHJldHVybiBlZGl0b3IuYXBwbHkgPSAob3BlcmF0aW9uKSA9PiB7XG4gICAgICBpZiAoZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5tYXRjaGVzKHtcbiAgICAgICAgXCJlZGl0IG1vZGVcIjogXCJyZWFkIG9ubHlcIlxuICAgICAgfSkpIHtcbiAgICAgICAgYXBwbHkyKG9wZXJhdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc0NoYW5naW5nUmVtb3RlbHkoZWRpdG9yKSkge1xuICAgICAgICBhcHBseTIob3BlcmF0aW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzVW5kb2luZyhlZGl0b3IpIHx8IGlzUmVkb2luZyhlZGl0b3IpKSB7XG4gICAgICAgIGFwcGx5MihvcGVyYXRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByb3dzID0gZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0Lm1heEJsb2NrcyA/PyAtMTtcbiAgICAgIHJvd3MgPiAwICYmIGVkaXRvci5jaGlsZHJlbi5sZW5ndGggPj0gcm93cyAmJiAob3BlcmF0aW9uLnR5cGUgPT09IFwiaW5zZXJ0X25vZGVcIiB8fCBvcGVyYXRpb24udHlwZSA9PT0gXCJzcGxpdF9ub2RlXCIpICYmIG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMSB8fCBhcHBseTIob3BlcmF0aW9uKTtcbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVXaXRoT2JqZWN0S2V5cyhlZGl0b3JBY3Rvcikge1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgYXBwbHk6IGFwcGx5MixcbiAgICAgIG5vcm1hbGl6ZU5vZGVcbiAgICB9ID0gZWRpdG9yO1xuICAgIHJldHVybiBlZGl0b3IuYXBwbHkgPSAob3BlcmF0aW9uKSA9PiB7XG4gICAgICBpZiAoaXNDaGFuZ2luZ1JlbW90ZWx5KGVkaXRvcikpIHtcbiAgICAgICAgYXBwbHkyKG9wZXJhdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1VuZG9pbmcoZWRpdG9yKSB8fCBpc1JlZG9pbmcoZWRpdG9yKSkge1xuICAgICAgICBhcHBseTIob3BlcmF0aW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9wZXJhdGlvbi50eXBlID09PSBcInNwbGl0X25vZGVcIikge1xuICAgICAgICBjb25zdCBleGlzdGluZ0tleXMgPSBbLi4uTm9kZS5kZXNjZW5kYW50cyhlZGl0b3IpXS5tYXAoKFtub2RlXSkgPT4gbm9kZS5fa2V5KTtcbiAgICAgICAgYXBwbHkyKHtcbiAgICAgICAgICAuLi5vcGVyYXRpb24sXG4gICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgLi4ub3BlcmF0aW9uLnByb3BlcnRpZXMsXG4gICAgICAgICAgICBfa2V5OiBvcGVyYXRpb24ucHJvcGVydGllcy5fa2V5ID09PSB2b2lkIDAgfHwgZXhpc3RpbmdLZXlzLmluY2x1ZGVzKG9wZXJhdGlvbi5wcm9wZXJ0aWVzLl9rZXkpID8gZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpIDogb3BlcmF0aW9uLnByb3BlcnRpZXMuX2tleVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChvcGVyYXRpb24udHlwZSA9PT0gXCJpbnNlcnRfbm9kZVwiICYmICFFZGl0b3IuaXNFZGl0b3Iob3BlcmF0aW9uLm5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nS2V5cyA9IFsuLi5Ob2RlLmRlc2NlbmRhbnRzKGVkaXRvcildLm1hcCgoW25vZGVdKSA9PiBub2RlLl9rZXkpO1xuICAgICAgICBhcHBseTIoe1xuICAgICAgICAgIC4uLm9wZXJhdGlvbixcbiAgICAgICAgICBub2RlOiB7XG4gICAgICAgICAgICAuLi5vcGVyYXRpb24ubm9kZSxcbiAgICAgICAgICAgIF9rZXk6IG9wZXJhdGlvbi5ub2RlLl9rZXkgPT09IHZvaWQgMCB8fCBleGlzdGluZ0tleXMuaW5jbHVkZXMob3BlcmF0aW9uLm5vZGUuX2tleSkgPyBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKCkgOiBvcGVyYXRpb24ubm9kZS5fa2V5XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9wZXJhdGlvbi50eXBlID09PSBcIm1lcmdlX25vZGVcIikge1xuICAgICAgICBjb25zdCBpbmRleCA9IG9wZXJhdGlvbi5wYXRoW29wZXJhdGlvbi5wYXRoLmxlbmd0aCAtIDFdLCBwcmV2UGF0aCA9IFBhdGgucHJldmlvdXMob3BlcmF0aW9uLnBhdGgpLCBwcmV2SW5kZXggPSBwcmV2UGF0aFtwcmV2UGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKG9wZXJhdGlvbi5wYXRoLmxlbmd0aCAhPT0gMSB8fCBwcmV2UGF0aC5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICBhcHBseTIob3BlcmF0aW9uKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvY2sgPSBlZGl0b3IudmFsdWUuYXQoaW5kZXgpLCBwcmV2aW91c0Jsb2NrID0gZWRpdG9yLnZhbHVlLmF0KHByZXZJbmRleCk7XG4gICAgICAgIGlmICghYmxvY2sgfHwgIXByZXZpb3VzQmxvY2spIHtcbiAgICAgICAgICBhcHBseTIob3BlcmF0aW9uKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1RleHRCbG9jayhlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQsIGJsb2NrKSB8fCAhaXNUZXh0QmxvY2soZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LCBwcmV2aW91c0Jsb2NrKSkge1xuICAgICAgICAgIGFwcGx5MihvcGVyYXRpb24pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2aW91c0Jsb2NrQ2hpbGRLZXlzID0gcHJldmlvdXNCbG9jay5jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiBjaGlsZC5fa2V5KSwgcHJldmlvdXNCbG9ja01hcmtEZWZLZXlzID0gcHJldmlvdXNCbG9jay5tYXJrRGVmcz8ubWFwKChtYXJrRGVmKSA9PiBtYXJrRGVmLl9rZXkpID8/IFtdLCBtYXJrRGVmS2V5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgYWRqdXN0ZWRNYXJrRGVmcyA9IGJsb2NrLm1hcmtEZWZzPy5tYXAoKG1hcmtEZWYpID0+IHtcbiAgICAgICAgICBpZiAocHJldmlvdXNCbG9ja01hcmtEZWZLZXlzLmluY2x1ZGVzKG1hcmtEZWYuX2tleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0tleSA9IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKTtcbiAgICAgICAgICAgIHJldHVybiBtYXJrRGVmS2V5TWFwLnNldChtYXJrRGVmLl9rZXksIG5ld0tleSksIHtcbiAgICAgICAgICAgICAgLi4ubWFya0RlZixcbiAgICAgICAgICAgICAgX2tleTogbmV3S2V5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWFya0RlZjtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBjaGlsZEluZGV4ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBibG9jay5jaGlsZHJlbikge1xuICAgICAgICAgIGlmIChpc1NwYW4oZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LCBjaGlsZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcmtzID0gY2hpbGQubWFya3M/Lm1hcCgobWFyaykgPT4gbWFya0RlZktleU1hcC5nZXQobWFyaykgfHwgbWFyaykgPz8gW107XG4gICAgICAgICAgICBpc0VxdWFsKGNoaWxkLm1hcmtzLCBtYXJrcykgfHwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgbWFya3NcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgYXQ6IFtpbmRleCwgY2hpbGRJbmRleF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcmV2aW91c0Jsb2NrQ2hpbGRLZXlzLmluY2x1ZGVzKGNoaWxkLl9rZXkpICYmIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBfa2V5OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKClcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBhdDogW2luZGV4LCBjaGlsZEluZGV4XVxuICAgICAgICAgIH0pLCBjaGlsZEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgYXBwbHkyKHtcbiAgICAgICAgICAuLi5vcGVyYXRpb24sXG4gICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgLi4ub3BlcmF0aW9uLnByb3BlcnRpZXMsXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGFkanVzdGVkIG1hcmtEZWZzIGFyZSBjYXJyaWVkIGFsb25nIGZvciB0aGUgbWVyZ2VcbiAgICAgICAgICAgIC8vIG9wZXJhdGlvblxuICAgICAgICAgICAgbWFya0RlZnM6IGFkanVzdGVkTWFya0RlZnNcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhcHBseTIob3BlcmF0aW9uKTtcbiAgICB9LCBlZGl0b3Iubm9ybWFsaXplTm9kZSA9IChlbnRyeSkgPT4ge1xuICAgICAgY29uc3QgW25vZGUsIHBhdGhdID0gZW50cnk7XG4gICAgICBpZiAoRWxlbWVudCQxLmlzRWxlbWVudChub2RlKSAmJiBub2RlLl90eXBlID09PSBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWUpIHtcbiAgICAgICAgaWYgKCFub2RlLl9rZXkpIHtcbiAgICAgICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtjaGlsZCwgY2hpbGRQYXRoXSBvZiBOb2RlLmNoaWxkcmVuKGVkaXRvciwgcGF0aCkpXG4gICAgICAgICAgaWYgKCFjaGlsZC5fa2V5KSB7XG4gICAgICAgICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGF0OiBjaGlsZFBhdGhcbiAgICAgICAgICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJkb25lIG5vcm1hbGl6aW5nXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vcm1hbGl6ZU5vZGUoZW50cnkpO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFwcGx5UGF0Y2goc2NoZW1hKSB7XG4gIHJldHVybiAoZWRpdG9yLCBwYXRjaCkgPT4ge1xuICAgIGxldCBjaGFuZ2VkID0gITE7XG4gICAgdHJ5IHtcbiAgICAgIHN3aXRjaCAocGF0Y2gudHlwZSkge1xuICAgICAgICBjYXNlIFwiaW5zZXJ0XCI6XG4gICAgICAgICAgY2hhbmdlZCA9IGluc2VydFBhdGNoKGVkaXRvciwgcGF0Y2gsIHNjaGVtYSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ1bnNldFwiOlxuICAgICAgICAgIGNoYW5nZWQgPSB1bnNldFBhdGNoKGVkaXRvciwgcGF0Y2gpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2V0XCI6XG4gICAgICAgICAgY2hhbmdlZCA9IHNldFBhdGNoKGVkaXRvciwgcGF0Y2gpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGlmZk1hdGNoUGF0Y2hcIjpcbiAgICAgICAgICBjaGFuZ2VkID0gZGlmZk1hdGNoUGF0Y2goZWRpdG9yLCBwYXRjaCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9O1xufVxuZnVuY3Rpb24gZGlmZk1hdGNoUGF0Y2goZWRpdG9yLCBwYXRjaCkge1xuICBjb25zdCBibG9jayA9IGZpbmRCbG9jayhlZGl0b3IuY2hpbGRyZW4sIHBhdGNoLnBhdGgpO1xuICBpZiAoIWJsb2NrKVxuICAgIHJldHVybiAhMTtcbiAgY29uc3QgY2hpbGQgPSBmaW5kQmxvY2tDaGlsZChibG9jaywgcGF0Y2gucGF0aCk7XG4gIGlmICghY2hpbGQgfHwgIShibG9jayAmJiBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2subm9kZSkgJiYgcGF0Y2gucGF0aC5sZW5ndGggPT09IDQgJiYgcGF0Y2gucGF0aFsxXSA9PT0gXCJjaGlsZHJlblwiICYmIHBhdGNoLnBhdGhbM10gPT09IFwidGV4dFwiKSB8fCAhVGV4dC5pc1RleHQoY2hpbGQubm9kZSkpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBwYXRjaGVzID0gcGFyc2UocGF0Y2gudmFsdWUpLCBbbmV3VmFsdWVdID0gYXBwbHkocGF0Y2hlcywgY2hpbGQubm9kZS50ZXh0LCB7XG4gICAgYWxsb3dFeGNlZWRpbmdJbmRpY2VzOiAhMFxuICB9KSwgZGlmZiQxID0gY2xlYW51cEVmZmljaWVuY3koZGlmZihjaGlsZC5ub2RlLnRleHQsIG5ld1ZhbHVlKSwgNSk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBmb3IgKGNvbnN0IFtvcCwgdGV4dF0gb2YgZGlmZiQxKVxuICAgIG9wID09PSBESUZGX0lOU0VSVCA/IChlZGl0b3IuYXBwbHkoe1xuICAgICAgdHlwZTogXCJpbnNlcnRfdGV4dFwiLFxuICAgICAgcGF0aDogW2Jsb2NrLmluZGV4LCBjaGlsZC5pbmRleF0sXG4gICAgICBvZmZzZXQsXG4gICAgICB0ZXh0XG4gICAgfSksIG9mZnNldCArPSB0ZXh0Lmxlbmd0aCkgOiBvcCA9PT0gRElGRl9ERUxFVEUgPyBlZGl0b3IuYXBwbHkoe1xuICAgICAgdHlwZTogXCJyZW1vdmVfdGV4dFwiLFxuICAgICAgcGF0aDogW2Jsb2NrLmluZGV4LCBjaGlsZC5pbmRleF0sXG4gICAgICBvZmZzZXQsXG4gICAgICB0ZXh0XG4gICAgfSkgOiBvcCA9PT0gRElGRl9FUVVBTCAmJiAob2Zmc2V0ICs9IHRleHQubGVuZ3RoKTtcbiAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24gaW5zZXJ0UGF0Y2goZWRpdG9yLCBwYXRjaCwgc2NoZW1hKSB7XG4gIGNvbnN0IGJsb2NrID0gZmluZEJsb2NrKGVkaXRvci5jaGlsZHJlbiwgcGF0Y2gucGF0aCk7XG4gIGlmICghYmxvY2sgfHwgcGF0Y2gucGF0aC5sZW5ndGggPiAxICYmIHBhdGNoLnBhdGhbMV0gIT09IFwiY2hpbGRyZW5cIilcbiAgICByZXR1cm4gITE7XG4gIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGl0ZW1zOiBpdGVtczIsXG4gICAgICBwb3NpdGlvbjogcG9zaXRpb24yXG4gICAgfSA9IHBhdGNoLCBibG9ja3NUb0luc2VydCA9IHRvU2xhdGVWYWx1ZShpdGVtczIsIHtcbiAgICAgIHNjaGVtYVR5cGVzOiBzY2hlbWFcbiAgICB9LCBLRVlfVE9fU0xBVEVfRUxFTUVOVC5nZXQoZWRpdG9yKSksIHRhcmdldEJsb2NrSW5kZXggPSBibG9jay5pbmRleCwgbm9ybWFsaXplZElkeDIgPSBwb3NpdGlvbjIgPT09IFwiYWZ0ZXJcIiA/IHRhcmdldEJsb2NrSW5kZXggKyAxIDogdGFyZ2V0QmxvY2tJbmRleCwgZWRpdG9yV2FzRW1wdHlCZWZvcmUgPSBpc0VxdWFsVG9FbXB0eUVkaXRvcihlZGl0b3IuY2hpbGRyZW4sIHNjaGVtYSk7XG4gICAgcmV0dXJuIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBibG9ja3NUb0luc2VydCwge1xuICAgICAgYXQ6IFtub3JtYWxpemVkSWR4Ml1cbiAgICB9KSwgZWRpdG9yV2FzRW1wdHlCZWZvcmUgJiYgdHlwZW9mIHBhdGNoLnBhdGhbMF0gPT0gXCJudW1iZXJcIiAmJiBwYXRjaC5wYXRoWzBdID09PSAwICYmIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogW3Bvc2l0aW9uMiA9PT0gXCJiZWZvcmVcIiA/IHRhcmdldEJsb2NrSW5kZXggKyAxIDogdGFyZ2V0QmxvY2tJbmRleF1cbiAgICB9KSwgITA7XG4gIH1cbiAgY29uc3Qge1xuICAgIGl0ZW1zLFxuICAgIHBvc2l0aW9uXG4gIH0gPSBwYXRjaCwgdGFyZ2V0Q2hpbGQgPSBmaW5kQmxvY2tDaGlsZChibG9jaywgcGF0Y2gucGF0aCk7XG4gIGlmICghdGFyZ2V0Q2hpbGQpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBjaGlsZHJlblRvSW5zZXJ0ID0gdG9TbGF0ZVZhbHVlKFt7XG4gICAgLi4uYmxvY2subm9kZSxcbiAgICBjaGlsZHJlbjogaXRlbXNcbiAgfV0sIHtcbiAgICBzY2hlbWFUeXBlczogc2NoZW1hXG4gIH0sIEtFWV9UT19TTEFURV9FTEVNRU5ULmdldChlZGl0b3IpKSwgbm9ybWFsaXplZElkeCA9IHBvc2l0aW9uID09PSBcImFmdGVyXCIgPyB0YXJnZXRDaGlsZC5pbmRleCArIDEgOiB0YXJnZXRDaGlsZC5pbmRleCwgY2hpbGRJbnNlcnRQYXRoID0gW2Jsb2NrLmluZGV4LCBub3JtYWxpemVkSWR4XTtcbiAgcmV0dXJuIGNoaWxkcmVuVG9JbnNlcnQgJiYgRWxlbWVudCQxLmlzRWxlbWVudChjaGlsZHJlblRvSW5zZXJ0WzBdKSAmJiBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgY2hpbGRyZW5Ub0luc2VydFswXS5jaGlsZHJlbiwge1xuICAgIGF0OiBjaGlsZEluc2VydFBhdGhcbiAgfSksICEwO1xufVxuZnVuY3Rpb24gc2V0UGF0Y2goZWRpdG9yLCBwYXRjaCkge1xuICBsZXQgdmFsdWUgPSBwYXRjaC52YWx1ZTtcbiAgdHlwZW9mIHBhdGNoLnBhdGhbM10gPT0gXCJzdHJpbmdcIiAmJiAodmFsdWUgPSB7fSwgdmFsdWVbcGF0Y2gucGF0aFszXV0gPSBwYXRjaC52YWx1ZSk7XG4gIGNvbnN0IGJsb2NrID0gZmluZEJsb2NrKGVkaXRvci5jaGlsZHJlbiwgcGF0Y2gucGF0aCk7XG4gIGlmICghYmxvY2spXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBpc1RleHRCbG9jazIgPSBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2subm9kZSk7XG4gIGlmIChpc1RleHRCbG9jazIgJiYgcGF0Y2gucGF0aC5sZW5ndGggPiAxICYmIHBhdGNoLnBhdGhbMV0gIT09IFwiY2hpbGRyZW5cIilcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IGNoaWxkID0gZmluZEJsb2NrQ2hpbGQoYmxvY2ssIHBhdGNoLnBhdGgpO1xuICBpZiAoaXNUZXh0QmxvY2syICYmIGNoaWxkKSB7XG4gICAgaWYgKFRleHQuaXNUZXh0KGNoaWxkLm5vZGUpKVxuICAgICAgaWYgKFRleHQuaXNUZXh0KHZhbHVlKSkge1xuICAgICAgICBjb25zdCBvbGRUZXh0ID0gY2hpbGQubm9kZS50ZXh0LCBuZXdUZXh0ID0gdmFsdWUudGV4dDtcbiAgICAgICAgb2xkVGV4dCAhPT0gbmV3VGV4dCAmJiAoZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICB0eXBlOiBcInJlbW92ZV90ZXh0XCIsXG4gICAgICAgICAgcGF0aDogW2Jsb2NrLmluZGV4LCBjaGlsZC5pbmRleF0sXG4gICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAgIHRleHQ6IG9sZFRleHRcbiAgICAgICAgfSksIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgdHlwZTogXCJpbnNlcnRfdGV4dFwiLFxuICAgICAgICAgIHBhdGg6IFtibG9jay5pbmRleCwgY2hpbGQuaW5kZXhdLFxuICAgICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgICB0ZXh0OiBuZXdUZXh0XG4gICAgICAgIH0pLCBlZGl0b3Iub25DaGFuZ2UoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwcm9wUGF0aCA9IHBhdGNoLnBhdGguc2xpY2UoMyksIHByb3BFbnRyeSA9IHByb3BQYXRoLmF0KDApO1xuICAgICAgICBpZiAocHJvcEVudHJ5ID09PSB2b2lkIDAgfHwgdHlwZW9mIHByb3BFbnRyeSA9PSBcInN0cmluZ1wiICYmIFtcIl9rZXlcIiwgXCJfdHlwZVwiLCBcInRleHRcIl0uaW5jbHVkZXMocHJvcEVudHJ5KSlcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIGNvbnN0IG5ld05vZGUgPSBhcHBseUFsbChjaGlsZC5ub2RlLCBbe1xuICAgICAgICAgIC4uLnBhdGNoLFxuICAgICAgICAgIHBhdGg6IHByb3BQYXRoXG4gICAgICAgIH1dKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIG5ld05vZGUsIHtcbiAgICAgICAgICBhdDogW2Jsb2NrLmluZGV4LCBjaGlsZC5pbmRleF1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBwcm9wUGF0aCA9IHBhdGNoLnBhdGguc2xpY2UoMyksIHJlc2VydmVkUHJvcHMgPSBbXCJfa2V5XCIsIFwiX3R5cGVcIiwgXCJjaGlsZHJlblwiLCBcIl9faW5saW5lXCJdLCBwcm9wRW50cnkgPSBwcm9wUGF0aC5hdCgwKTtcbiAgICAgIGlmIChwcm9wRW50cnkgPT09IHZvaWQgMCB8fCB0eXBlb2YgcHJvcEVudHJ5ID09IFwic3RyaW5nXCIgJiYgcmVzZXJ2ZWRQcm9wcy5pbmNsdWRlcyhwcm9wRW50cnkpKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCB2YWx1ZTIgPSBcInZhbHVlXCIgaW4gY2hpbGQubm9kZSAmJiB0eXBlb2YgY2hpbGQubm9kZS52YWx1ZSA9PSBcIm9iamVjdFwiID8gY2hpbGQubm9kZS52YWx1ZSA6IHt9LCBuZXdWYWx1ZSA9IGFwcGx5QWxsKHZhbHVlMiwgW3tcbiAgICAgICAgLi4ucGF0Y2gsXG4gICAgICAgIHBhdGg6IHBhdGNoLnBhdGguc2xpY2UoMylcbiAgICAgIH1dKTtcbiAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIC4uLmNoaWxkLm5vZGUsXG4gICAgICAgIHZhbHVlOiBuZXdWYWx1ZVxuICAgICAgfSwge1xuICAgICAgICBhdDogW2Jsb2NrLmluZGV4LCBjaGlsZC5pbmRleF1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gITA7XG4gIH0gZWxzZSBpZiAoRWxlbWVudCQxLmlzRWxlbWVudChibG9jay5ub2RlKSAmJiBwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgLi4ubmV4dFJlc3RcbiAgICB9ID0gdmFsdWUsIHtcbiAgICAgIGNoaWxkcmVuOiBfcHJldkNoaWxkcmVuLFxuICAgICAgLi4ucHJldlJlc3RcbiAgICB9ID0gYmxvY2subm9kZSB8fCB7XG4gICAgICBjaGlsZHJlbjogdm9pZCAwXG4gICAgfTtcbiAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgdHlwZTogXCJzZXRfbm9kZVwiLFxuICAgICAgcGF0aDogW2Jsb2NrLmluZGV4XSxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLi4ucHJldlJlc3RcbiAgICAgIH0sXG4gICAgICBuZXdQcm9wZXJ0aWVzOiBuZXh0UmVzdFxuICAgIH0pO1xuICAgIGNvbnN0IGJsb2NrTm9kZSA9IGJsb2NrLm5vZGU7XG4gICAgYmxvY2tOb2RlLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkMiwgY2hpbGRJbmRleCkgPT4ge1xuICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgdHlwZTogXCJyZW1vdmVfbm9kZVwiLFxuICAgICAgICBwYXRoOiBbYmxvY2suaW5kZXgsIGJsb2NrTm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxIC0gY2hpbGRJbmRleF0sXG4gICAgICAgIG5vZGU6IGNoaWxkMlxuICAgICAgfSk7XG4gICAgfSksIEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkMiwgY2hpbGRJbmRleCkgPT4ge1xuICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgdHlwZTogXCJpbnNlcnRfbm9kZVwiLFxuICAgICAgICBwYXRoOiBbYmxvY2suaW5kZXgsIGNoaWxkSW5kZXhdLFxuICAgICAgICBub2RlOiBjaGlsZDJcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGJsb2NrICYmIFwidmFsdWVcIiBpbiBibG9jay5ub2RlKVxuICAgIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA+IDEgJiYgcGF0Y2gucGF0aFsxXSAhPT0gXCJjaGlsZHJlblwiKSB7XG4gICAgICBjb25zdCBuZXdWYWwgPSBhcHBseUFsbChibG9jay5ub2RlLnZhbHVlLCBbe1xuICAgICAgICAuLi5wYXRjaCxcbiAgICAgICAgcGF0aDogcGF0Y2gucGF0aC5zbGljZSgxKVxuICAgICAgfV0pO1xuICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgLi4uYmxvY2subm9kZSxcbiAgICAgICAgdmFsdWU6IG5ld1ZhbFxuICAgICAgfSwge1xuICAgICAgICBhdDogW2Jsb2NrLmluZGV4XVxuICAgICAgfSk7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gITE7XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIHVuc2V0UGF0Y2goZWRpdG9yLCBwYXRjaCkge1xuICBpZiAocGF0Y2gucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICBjb25zdCBwcmV2aW91c1NlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgVHJhbnNmb3Jtcy5kZXNlbGVjdChlZGl0b3IpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gTm9kZS5jaGlsZHJlbihlZGl0b3IsIFtdLCB7XG4gICAgICByZXZlcnNlOiAhMFxuICAgIH0pO1xuICAgIGZvciAoY29uc3QgW18sIHBhdGhdIG9mIGNoaWxkcmVuKVxuICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhdGhcbiAgICAgIH0pO1xuICAgIHJldHVybiBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgZWRpdG9yLnB0ZUNyZWF0ZVRleHRCbG9jayh7XG4gICAgICBkZWNvcmF0b3JzOiBbXVxuICAgIH0pKSwgcHJldmlvdXNTZWxlY3Rpb24gJiYgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCB7XG4gICAgICBhbmNob3I6IHtcbiAgICAgICAgcGF0aDogWzAsIDBdLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0sXG4gICAgICBmb2N1czoge1xuICAgICAgICBwYXRoOiBbMCwgMF0sXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfVxuICAgIH0pLCBlZGl0b3Iub25DaGFuZ2UoKSwgITA7XG4gIH1cbiAgY29uc3QgYmxvY2sgPSBmaW5kQmxvY2soZWRpdG9yLmNoaWxkcmVuLCBwYXRjaC5wYXRoKTtcbiAgaWYgKCFibG9jaylcbiAgICByZXR1cm4gITE7XG4gIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChlZGl0b3IuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBwcmV2aW91c1NlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgICByZXR1cm4gVHJhbnNmb3Jtcy5kZXNlbGVjdChlZGl0b3IpLCBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogW2Jsb2NrLmluZGV4XVxuICAgICAgfSksIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBlZGl0b3IucHRlQ3JlYXRlVGV4dEJsb2NrKHtcbiAgICAgICAgZGVjb3JhdG9yczogW11cbiAgICAgIH0pKSwgcHJldmlvdXNTZWxlY3Rpb24gJiYgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCB7XG4gICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgIHBhdGg6IFswLCAwXSxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICBwYXRoOiBbMCwgMF0sXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH1cbiAgICAgIH0pLCBlZGl0b3Iub25DaGFuZ2UoKSwgITA7XG4gICAgfVxuICAgIHJldHVybiBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IFtibG9jay5pbmRleF1cbiAgICB9KSwgITA7XG4gIH1cbiAgY29uc3QgY2hpbGQgPSBmaW5kQmxvY2tDaGlsZChibG9jaywgcGF0Y2gucGF0aCk7XG4gIGlmIChlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2subm9kZSkgJiYgY2hpbGQgJiYgcGF0Y2gucGF0aFsxXSA9PT0gXCJjaGlsZHJlblwiICYmIHBhdGNoLnBhdGgubGVuZ3RoID09PSAzKVxuICAgIHJldHVybiBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IFtibG9jay5pbmRleCwgY2hpbGQuaW5kZXhdXG4gICAgfSksICEwO1xuICBpZiAoY2hpbGQgJiYgIVRleHQuaXNUZXh0KGNoaWxkLm5vZGUpKSB7XG4gICAgY29uc3QgcHJvcEVudHJ5ID0gcGF0Y2gucGF0aC5zbGljZSgzKS5hdCgwKTtcbiAgICBpZiAocHJvcEVudHJ5ID09PSB2b2lkIDAgfHwgdHlwZW9mIHByb3BFbnRyeSA9PSBcInN0cmluZ1wiICYmIFtcIl9rZXlcIiwgXCJfdHlwZVwiLCBcImNoaWxkcmVuXCIsIFwiX19pbmxpbmVcIl0uaW5jbHVkZXMocHJvcEVudHJ5KSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCB2YWx1ZSA9IFwidmFsdWVcIiBpbiBjaGlsZC5ub2RlICYmIHR5cGVvZiBjaGlsZC5ub2RlLnZhbHVlID09IFwib2JqZWN0XCIgPyBjaGlsZC5ub2RlLnZhbHVlIDoge30sIG5ld1ZhbHVlID0gYXBwbHlBbGwodmFsdWUsIFt7XG4gICAgICAuLi5wYXRjaCxcbiAgICAgIHBhdGg6IHBhdGNoLnBhdGguc2xpY2UoMylcbiAgICB9XSk7XG4gICAgcmV0dXJuIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAuLi5jaGlsZC5ub2RlLFxuICAgICAgdmFsdWU6IG5ld1ZhbHVlXG4gICAgfSwge1xuICAgICAgYXQ6IFtibG9jay5pbmRleCwgY2hpbGQuaW5kZXhdXG4gICAgfSksICEwO1xuICB9XG4gIGlmIChjaGlsZCAmJiBUZXh0LmlzVGV4dChjaGlsZC5ub2RlKSkge1xuICAgIGNvbnN0IHByb3BQYXRoID0gcGF0Y2gucGF0aC5zbGljZSgzKSwgcHJvcEVudHJ5ID0gcHJvcFBhdGguYXQoMCk7XG4gICAgaWYgKHByb3BFbnRyeSA9PT0gdm9pZCAwIHx8IHR5cGVvZiBwcm9wRW50cnkgPT0gXCJzdHJpbmdcIiAmJiBbXCJfa2V5XCIsIFwiX3R5cGVcIl0uaW5jbHVkZXMocHJvcEVudHJ5KSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBpZiAodHlwZW9mIHByb3BFbnRyeSA9PSBcInN0cmluZ1wiICYmIHByb3BFbnRyeSA9PT0gXCJ0ZXh0XCIpXG4gICAgICByZXR1cm4gZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgdHlwZTogXCJyZW1vdmVfdGV4dFwiLFxuICAgICAgICBwYXRoOiBbYmxvY2suaW5kZXgsIGNoaWxkLmluZGV4XSxcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICB0ZXh0OiBjaGlsZC5ub2RlLnRleHRcbiAgICAgIH0pLCAhMDtcbiAgICBjb25zdCBuZXdOb2RlID0gYXBwbHlBbGwoY2hpbGQubm9kZSwgW3tcbiAgICAgIC4uLnBhdGNoLFxuICAgICAgcGF0aDogcHJvcFBhdGhcbiAgICB9XSksIG5ld0tleXMgPSBPYmplY3Qua2V5cyhuZXdOb2RlKSwgcmVtb3ZlZFByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhjaGlsZC5ub2RlKS5maWx0ZXIoKHByb3BlcnR5KSA9PiAhbmV3S2V5cy5pbmNsdWRlcyhwcm9wZXJ0eSkpO1xuICAgIHJldHVybiBUcmFuc2Zvcm1zLnVuc2V0Tm9kZXMoZWRpdG9yLCByZW1vdmVkUHJvcGVydGllcywge1xuICAgICAgYXQ6IFtibG9jay5pbmRleCwgY2hpbGQuaW5kZXhdXG4gICAgfSksICEwO1xuICB9XG4gIGlmICghY2hpbGQpIHtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGJsb2NrLm5vZGUpIHtcbiAgICAgIGNvbnN0IG5ld1ZhbCA9IGFwcGx5QWxsKGJsb2NrLm5vZGUudmFsdWUsIFt7XG4gICAgICAgIC4uLnBhdGNoLFxuICAgICAgICBwYXRoOiBwYXRjaC5wYXRoLnNsaWNlKDEpXG4gICAgICB9XSk7XG4gICAgICByZXR1cm4gVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgLi4uYmxvY2subm9kZSxcbiAgICAgICAgdmFsdWU6IG5ld1ZhbFxuICAgICAgfSwge1xuICAgICAgICBhdDogW2Jsb2NrLmluZGV4XVxuICAgICAgfSksICEwO1xuICAgIH1cbiAgICByZXR1cm4gITE7XG4gIH1cbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gZmluZEJsb2NrKGNoaWxkcmVuLCBwYXRoKSB7XG4gIGxldCBibG9ja0luZGV4ID0gLTE7XG4gIGNvbnN0IGJsb2NrID0gY2hpbGRyZW4uZmluZCgobm9kZSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBpc01hdGNoID0gaXNLZXllZFNlZ21lbnQocGF0aFswXSkgPyBub2RlLl9rZXkgPT09IHBhdGhbMF0uX2tleSA6IGluZGV4ID09PSBwYXRoWzBdO1xuICAgIHJldHVybiBpc01hdGNoICYmIChibG9ja0luZGV4ID0gaW5kZXgpLCBpc01hdGNoO1xuICB9KTtcbiAgaWYgKGJsb2NrKVxuICAgIHJldHVybiB7XG4gICAgICBub2RlOiBibG9jayxcbiAgICAgIGluZGV4OiBibG9ja0luZGV4XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZpbmRCbG9ja0NoaWxkKGJsb2NrLCBwYXRoKSB7XG4gIGNvbnN0IGJsb2NrTm9kZSA9IGJsb2NrLm5vZGU7XG4gIGlmICghRWxlbWVudCQxLmlzRWxlbWVudChibG9ja05vZGUpIHx8IHBhdGhbMV0gIT09IFwiY2hpbGRyZW5cIilcbiAgICByZXR1cm47XG4gIGxldCBjaGlsZEluZGV4ID0gLTE7XG4gIGNvbnN0IGNoaWxkID0gYmxvY2tOb2RlLmNoaWxkcmVuLmZpbmQoKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgaXNNYXRjaCA9IGlzS2V5ZWRTZWdtZW50KHBhdGhbMl0pID8gbm9kZS5fa2V5ID09PSBwYXRoWzJdLl9rZXkgOiBpbmRleCA9PT0gcGF0aFsyXTtcbiAgICByZXR1cm4gaXNNYXRjaCAmJiAoY2hpbGRJbmRleCA9IGluZGV4KSwgaXNNYXRjaDtcbiAgfSk7XG4gIGlmIChjaGlsZClcbiAgICByZXR1cm4ge1xuICAgICAgbm9kZTogY2hpbGQsXG4gICAgICBpbmRleDogY2hpbGRJbmRleFxuICAgIH07XG59XG5mdW5jdGlvbiBpbnNlcnRUZXh0UGF0Y2goc2NoZW1hLCBjaGlsZHJlbiwgb3BlcmF0aW9uLCBiZWZvcmVWYWx1ZSkge1xuICBjb25zdCBibG9jayA9IGlzVGV4dEJsb2NrKHtcbiAgICBzY2hlbWFcbiAgfSwgY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dKSAmJiBjaGlsZHJlbltvcGVyYXRpb24ucGF0aFswXV07XG4gIGlmICghYmxvY2spXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgYmxvY2tcIik7XG4gIGNvbnN0IHRleHRDaGlsZCA9IGlzVGV4dEJsb2NrKHtcbiAgICBzY2hlbWFcbiAgfSwgYmxvY2spICYmIGlzU3Bhbih7XG4gICAgc2NoZW1hXG4gIH0sIGJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXSkgJiYgYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dO1xuICBpZiAoIXRleHRDaGlsZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBjaGlsZFwiKTtcbiAgY29uc3QgcGF0aCA9IFt7XG4gICAgX2tleTogYmxvY2suX2tleVxuICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICBfa2V5OiB0ZXh0Q2hpbGQuX2tleVxuICB9LCBcInRleHRcIl0sIHByZXZCbG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5wYXRoWzBdXSwgcHJldkNoaWxkID0gaXNUZXh0QmxvY2soe1xuICAgIHNjaGVtYVxuICB9LCBwcmV2QmxvY2spICYmIHByZXZCbG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV0sIHByZXZUZXh0ID0gaXNTcGFuKHtcbiAgICBzY2hlbWFcbiAgfSwgcHJldkNoaWxkKSA/IHByZXZDaGlsZC50ZXh0IDogXCJcIiwgcGF0Y2ggPSBkaWZmTWF0Y2hQYXRjaCQxKHByZXZUZXh0LCB0ZXh0Q2hpbGQudGV4dCwgcGF0aCk7XG4gIHJldHVybiBwYXRjaC52YWx1ZS5sZW5ndGggPyBbcGF0Y2hdIDogW107XG59XG5mdW5jdGlvbiByZW1vdmVUZXh0UGF0Y2goc2NoZW1hLCBjaGlsZHJlbiwgb3BlcmF0aW9uLCBiZWZvcmVWYWx1ZSkge1xuICBjb25zdCBibG9jayA9IGNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXTtcbiAgaWYgKCFibG9jaylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBibG9ja1wiKTtcbiAgY29uc3QgY2hpbGQgPSBpc1RleHRCbG9jayh7XG4gICAgc2NoZW1hXG4gIH0sIGJsb2NrKSAmJiBibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV0gfHwgdm9pZCAwLCB0ZXh0Q2hpbGQgPSBpc1NwYW4oe1xuICAgIHNjaGVtYVxuICB9LCBjaGlsZCkgPyBjaGlsZCA6IHZvaWQgMDtcbiAgaWYgKGNoaWxkICYmICF0ZXh0Q2hpbGQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgc3BhblwiKTtcbiAgaWYgKCF0ZXh0Q2hpbGQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgY2hpbGRcIik7XG4gIGNvbnN0IHBhdGggPSBbe1xuICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgX2tleTogdGV4dENoaWxkLl9rZXlcbiAgfSwgXCJ0ZXh0XCJdLCBiZWZvcmVCbG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5wYXRoWzBdXSwgcHJldlRleHRDaGlsZCA9IGlzVGV4dEJsb2NrKHtcbiAgICBzY2hlbWFcbiAgfSwgYmVmb3JlQmxvY2spICYmIGJlZm9yZUJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXSwgcHJldlRleHQgPSBpc1NwYW4oe1xuICAgIHNjaGVtYVxuICB9LCBwcmV2VGV4dENoaWxkKSAmJiBwcmV2VGV4dENoaWxkLnRleHQsIHBhdGNoID0gZGlmZk1hdGNoUGF0Y2gkMShwcmV2VGV4dCB8fCBcIlwiLCB0ZXh0Q2hpbGQudGV4dCwgcGF0aCk7XG4gIHJldHVybiBwYXRjaC52YWx1ZSA/IFtwYXRjaF0gOiBbXTtcbn1cbmZ1bmN0aW9uIHNldE5vZGVQYXRjaChzY2hlbWEsIGNoaWxkcmVuLCBvcGVyYXRpb24pIHtcbiAgaWYgKG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IGJsb2NrID0gY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dO1xuICAgIGlmICh0eXBlb2YgYmxvY2suX2tleSAhPSBcInN0cmluZ1wiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgYmxvY2sgdG8gaGF2ZSBhIF9rZXlcIik7XG4gICAgY29uc3Qgc2V0Tm9kZSA9IG9taXRCeSh7XG4gICAgICAuLi5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFswXV0sXG4gICAgICAuLi5vcGVyYXRpb24ubmV3UHJvcGVydGllc1xuICAgIH0sIGlzVW5kZWZpbmVkKTtcbiAgICByZXR1cm4gW3NldChmcm9tU2xhdGVWYWx1ZShbc2V0Tm9kZV0sIHNjaGVtYS5ibG9jay5uYW1lKVswXSwgW3tcbiAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICB9XSldO1xuICB9IGVsc2UgaWYgKG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMikge1xuICAgIGNvbnN0IGJsb2NrID0gY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dO1xuICAgIGlmIChpc1RleHRCbG9jayh7XG4gICAgICBzY2hlbWFcbiAgICB9LCBibG9jaykpIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dO1xuICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrS2V5ID0gYmxvY2suX2tleSwgY2hpbGRLZXkgPSBjaGlsZC5fa2V5LCBwYXRjaGVzID0gW10sIGtleXMgPSBPYmplY3Qua2V5cyhvcGVyYXRpb24ubmV3UHJvcGVydGllcyk7XG4gICAgICAgIHJldHVybiBrZXlzLmZvckVhY2goKGtleU5hbWUpID0+IHtcbiAgICAgICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDEgJiYga2V5TmFtZSA9PT0gXCJfa2V5XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IGdldChvcGVyYXRpb24ubmV3UHJvcGVydGllcywga2V5TmFtZSk7XG4gICAgICAgICAgICBwYXRjaGVzLnB1c2goc2V0KHZhbCwgW3tcbiAgICAgICAgICAgICAgX2tleTogYmxvY2tLZXlcbiAgICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwgYmxvY2suY2hpbGRyZW4uaW5kZXhPZihjaGlsZCksIGtleU5hbWVdKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IGdldChvcGVyYXRpb24ubmV3UHJvcGVydGllcywga2V5TmFtZSk7XG4gICAgICAgICAgICBwYXRjaGVzLnB1c2goc2V0KHZhbCwgW3tcbiAgICAgICAgICAgICAgX2tleTogYmxvY2tLZXlcbiAgICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgICBfa2V5OiBjaGlsZEtleVxuICAgICAgICAgICAgfSwga2V5TmFtZV0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCBwYXRjaGVzO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgYSB2YWxpZCBjaGlsZFwiKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgYSB2YWxpZCBibG9ja1wiKTtcbiAgfSBlbHNlXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHBhdGggZW5jb3VudGVyZWQ6ICR7SlNPTi5zdHJpbmdpZnkob3BlcmF0aW9uLnBhdGgpfWApO1xufVxuZnVuY3Rpb24gaW5zZXJ0Tm9kZVBhdGNoKHNjaGVtYSwgY2hpbGRyZW4sIG9wZXJhdGlvbiwgYmVmb3JlVmFsdWUpIHtcbiAgY29uc3QgYmxvY2sgPSBiZWZvcmVWYWx1ZVtvcGVyYXRpb24ucGF0aFswXV07XG4gIGlmIChvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IG9wZXJhdGlvbi5wYXRoWzBdID09PSAwID8gXCJiZWZvcmVcIiA6IFwiYWZ0ZXJcIiwgYmVmb3JlQmxvY2sgPSBiZWZvcmVWYWx1ZVtvcGVyYXRpb24ucGF0aFswXSAtIDFdLCB0YXJnZXRLZXkgPSBvcGVyYXRpb24ucGF0aFswXSA9PT0gMCA/IGJsb2NrPy5fa2V5IDogYmVmb3JlQmxvY2s/Ll9rZXk7XG4gICAgcmV0dXJuIHRhcmdldEtleSA/IFtpbnNlcnQoW2Zyb21TbGF0ZVZhbHVlKFtvcGVyYXRpb24ubm9kZV0sIHNjaGVtYS5ibG9jay5uYW1lKVswXV0sIHBvc2l0aW9uLCBbe1xuICAgICAgX2tleTogdGFyZ2V0S2V5XG4gICAgfV0pXSA6IFtzZXRJZk1pc3NpbmcoYmVmb3JlVmFsdWUsIFtdKSwgaW5zZXJ0KFtmcm9tU2xhdGVWYWx1ZShbb3BlcmF0aW9uLm5vZGVdLCBzY2hlbWEuYmxvY2submFtZSlbMF1dLCBcImJlZm9yZVwiLCBbb3BlcmF0aW9uLnBhdGhbMF1dKV07XG4gIH0gZWxzZSBpZiAoaXNUZXh0QmxvY2soe1xuICAgIHNjaGVtYVxuICB9LCBibG9jaykgJiYgb3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAyICYmIGNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXSkge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gYmxvY2suY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8ICFibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXSAtIDFdID8gXCJiZWZvcmVcIiA6IFwiYWZ0ZXJcIiwgbm9kZSA9IHtcbiAgICAgIC4uLm9wZXJhdGlvbi5ub2RlXG4gICAgfTtcbiAgICAhbm9kZS5fdHlwZSAmJiBUZXh0LmlzVGV4dChub2RlKSAmJiAobm9kZS5fdHlwZSA9IFwic3BhblwiLCBub2RlLm1hcmtzID0gW10pO1xuICAgIGNvbnN0IGNoaWxkID0gZnJvbVNsYXRlVmFsdWUoW3tcbiAgICAgIF9rZXk6IFwiYm9ndXNcIixcbiAgICAgIF90eXBlOiBzY2hlbWEuYmxvY2submFtZSxcbiAgICAgIGNoaWxkcmVuOiBbbm9kZV1cbiAgICB9XSwgc2NoZW1hLmJsb2NrLm5hbWUpWzBdLmNoaWxkcmVuWzBdO1xuICAgIHJldHVybiBbaW5zZXJ0KFtjaGlsZF0sIHBvc2l0aW9uLCBbe1xuICAgICAgX2tleTogYmxvY2suX2tleVxuICAgIH0sIFwiY2hpbGRyZW5cIiwgYmxvY2suY2hpbGRyZW4ubGVuZ3RoIDw9IDEgfHwgIWJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdIC0gMV0gPyAwIDoge1xuICAgICAgX2tleTogYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV0gLSAxXS5fa2V5XG4gICAgfV0pXTtcbiAgfVxuICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBzcGxpdE5vZGVQYXRjaChzY2hlbWEsIGNoaWxkcmVuLCBvcGVyYXRpb24sIGJlZm9yZVZhbHVlKSB7XG4gIGNvbnN0IHBhdGNoZXMgPSBbXSwgc3BsaXRCbG9jayA9IGNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXTtcbiAgaWYgKCFpc1RleHRCbG9jayh7XG4gICAgc2NoZW1hXG4gIH0sIHNwbGl0QmxvY2spKVxuICAgIHRocm93IG5ldyBFcnJvcihgQmxvY2sgd2l0aCBwYXRoICR7SlNPTi5zdHJpbmdpZnkob3BlcmF0aW9uLnBhdGhbMF0pfSBpcyBub3QgYSB0ZXh0IGJsb2NrIGFuZCBjYW4ndCBiZSBzcGxpdGApO1xuICBpZiAob3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3Qgb2xkQmxvY2sgPSBiZWZvcmVWYWx1ZVtvcGVyYXRpb24ucGF0aFswXV07XG4gICAgaWYgKGlzVGV4dEJsb2NrKHtcbiAgICAgIHNjaGVtYVxuICAgIH0sIG9sZEJsb2NrKSkge1xuICAgICAgY29uc3QgdGFyZ2V0VmFsdWUgPSBmcm9tU2xhdGVWYWx1ZShbY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF0gKyAxXV0sIHNjaGVtYS5ibG9jay5uYW1lKVswXTtcbiAgICAgIHRhcmdldFZhbHVlICYmIChwYXRjaGVzLnB1c2goaW5zZXJ0KFt0YXJnZXRWYWx1ZV0sIFwiYWZ0ZXJcIiwgW3tcbiAgICAgICAgX2tleTogc3BsaXRCbG9jay5fa2V5XG4gICAgICB9XSkpLCBvbGRCbG9jay5jaGlsZHJlbi5zbGljZShvcGVyYXRpb24ucG9zaXRpb24pLmZvckVhY2goKHNwYW4pID0+IHtcbiAgICAgICAgY29uc3QgcGF0aCA9IFt7XG4gICAgICAgICAgX2tleTogb2xkQmxvY2suX2tleVxuICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICBfa2V5OiBzcGFuLl9rZXlcbiAgICAgICAgfV07XG4gICAgICAgIHBhdGNoZXMucHVzaCh1bnNldChwYXRoKSk7XG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRjaGVzO1xuICB9XG4gIGlmIChvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDIpIHtcbiAgICBjb25zdCBzcGxpdFNwYW4gPSBzcGxpdEJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXTtcbiAgICBpZiAoaXNTcGFuKHtcbiAgICAgIHNjaGVtYVxuICAgIH0sIHNwbGl0U3BhbikpIHtcbiAgICAgIGNvbnN0IHRhcmdldFNwYW5zID0gZnJvbVNsYXRlVmFsdWUoW3tcbiAgICAgICAgLi4uc3BsaXRCbG9jayxcbiAgICAgICAgY2hpbGRyZW46IHNwbGl0QmxvY2suY2hpbGRyZW4uc2xpY2Uob3BlcmF0aW9uLnBhdGhbMV0gKyAxLCBvcGVyYXRpb24ucGF0aFsxXSArIDIpXG4gICAgICB9XSwgc2NoZW1hLmJsb2NrLm5hbWUpWzBdLmNoaWxkcmVuO1xuICAgICAgcGF0Y2hlcy5wdXNoKGluc2VydCh0YXJnZXRTcGFucywgXCJhZnRlclwiLCBbe1xuICAgICAgICBfa2V5OiBzcGxpdEJsb2NrLl9rZXlcbiAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICBfa2V5OiBzcGxpdFNwYW4uX2tleVxuICAgICAgfV0pKSwgcGF0Y2hlcy5wdXNoKHNldChzcGxpdFNwYW4udGV4dCwgW3tcbiAgICAgICAgX2tleTogc3BsaXRCbG9jay5fa2V5XG4gICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgX2tleTogc3BsaXRTcGFuLl9rZXlcbiAgICAgIH0sIFwidGV4dFwiXSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0Y2hlcztcbiAgfVxuICByZXR1cm4gcGF0Y2hlcztcbn1cbmZ1bmN0aW9uIHJlbW92ZU5vZGVQYXRjaChzY2hlbWEsIGJlZm9yZVZhbHVlLCBvcGVyYXRpb24pIHtcbiAgY29uc3QgYmxvY2sgPSBiZWZvcmVWYWx1ZVtvcGVyYXRpb24ucGF0aFswXV07XG4gIGlmIChvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoYmxvY2sgJiYgYmxvY2suX2tleSlcbiAgICAgIHJldHVybiBbdW5zZXQoW3tcbiAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgfV0pXTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCbG9jayBub3QgZm91bmRcIik7XG4gIH0gZWxzZSBpZiAoaXNUZXh0QmxvY2soe1xuICAgIHNjaGVtYVxuICB9LCBibG9jaykgJiYgb3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAyKSB7XG4gICAgY29uc3Qgc3BhblRvUmVtb3ZlID0gYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dO1xuICAgIHJldHVybiBzcGFuVG9SZW1vdmUgPyBibG9jay5jaGlsZHJlbi5maWx0ZXIoKHNwYW4pID0+IHNwYW4uX2tleSA9PT0gb3BlcmF0aW9uLm5vZGUuX2tleSkubGVuZ3RoID4gMSA/IChjb25zb2xlLndhcm4oYE11bHRpcGxlIHNwYW5zIGhhdmUgXFxgX2tleVxcYCAke29wZXJhdGlvbi5ub2RlLl9rZXl9LiBJdCdzIGFtYmlndW91cyB3aGljaCBvbmUgdG8gcmVtb3ZlLmAsIEpTT04uc3RyaW5naWZ5KGJsb2NrLCBudWxsLCAyKSksIFtdKSA6IFt1bnNldChbe1xuICAgICAgX2tleTogYmxvY2suX2tleVxuICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgX2tleTogc3BhblRvUmVtb3ZlLl9rZXlcbiAgICB9XSldIDogW107XG4gIH0gZWxzZVxuICAgIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIG1lcmdlTm9kZVBhdGNoKHNjaGVtYSwgY2hpbGRyZW4sIG9wZXJhdGlvbiwgYmVmb3JlVmFsdWUpIHtcbiAgY29uc3QgcGF0Y2hlcyA9IFtdLCBibG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5wYXRoWzBdXSwgdXBkYXRlZEJsb2NrID0gY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dO1xuICBpZiAob3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAxKVxuICAgIGlmIChibG9jaz8uX2tleSkge1xuICAgICAgY29uc3QgbmV3QmxvY2sgPSBmcm9tU2xhdGVWYWx1ZShbY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF0gLSAxXV0sIHNjaGVtYS5ibG9jay5uYW1lKVswXTtcbiAgICAgIHBhdGNoZXMucHVzaChzZXQobmV3QmxvY2ssIFt7XG4gICAgICAgIF9rZXk6IG5ld0Jsb2NrLl9rZXlcbiAgICAgIH1dKSksIHBhdGNoZXMucHVzaCh1bnNldChbe1xuICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICB9XSkpO1xuICAgIH0gZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGFyZ2V0IGtleSBub3QgZm91bmQhXCIpO1xuICBlbHNlIGlmIChpc1RleHRCbG9jayh7XG4gICAgc2NoZW1hXG4gIH0sIGJsb2NrKSAmJiBpc1RleHRCbG9jayh7XG4gICAgc2NoZW1hXG4gIH0sIHVwZGF0ZWRCbG9jaykgJiYgb3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAyKSB7XG4gICAgY29uc3QgdXBkYXRlZFNwYW4gPSB1cGRhdGVkQmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV0gLSAxXSAmJiBpc1NwYW4oe1xuICAgICAgc2NoZW1hXG4gICAgfSwgdXBkYXRlZEJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdIC0gMV0pID8gdXBkYXRlZEJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdIC0gMV0gOiB2b2lkIDAsIHJlbW92ZWRTcGFuID0gYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dICYmIGlzU3Bhbih7XG4gICAgICBzY2hlbWFcbiAgICB9LCBibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV0pID8gYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dIDogdm9pZCAwO1xuICAgIHVwZGF0ZWRTcGFuICYmIChibG9jay5jaGlsZHJlbi5maWx0ZXIoKHNwYW4pID0+IHNwYW4uX2tleSA9PT0gdXBkYXRlZFNwYW4uX2tleSkubGVuZ3RoID09PSAxID8gcGF0Y2hlcy5wdXNoKHNldCh1cGRhdGVkU3Bhbi50ZXh0LCBbe1xuICAgICAgX2tleTogYmxvY2suX2tleVxuICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgX2tleTogdXBkYXRlZFNwYW4uX2tleVxuICAgIH0sIFwidGV4dFwiXSkpIDogY29uc29sZS53YXJuKGBNdWx0aXBsZSBzcGFucyBoYXZlIFxcYF9rZXlcXGAgJHt1cGRhdGVkU3Bhbi5fa2V5fS4gSXQncyBhbWJpZ3VvdXMgd2hpY2ggb25lIHRvIHVwZGF0ZS5gLCBKU09OLnN0cmluZ2lmeShibG9jaywgbnVsbCwgMikpKSwgcmVtb3ZlZFNwYW4gJiYgKGJsb2NrLmNoaWxkcmVuLmZpbHRlcigoc3BhbikgPT4gc3Bhbi5fa2V5ID09PSByZW1vdmVkU3Bhbi5fa2V5KS5sZW5ndGggPT09IDEgPyBwYXRjaGVzLnB1c2godW5zZXQoW3tcbiAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgIF9rZXk6IHJlbW92ZWRTcGFuLl9rZXlcbiAgICB9XSkpIDogY29uc29sZS53YXJuKGBNdWx0aXBsZSBzcGFucyBoYXZlIFxcYF9rZXlcXGAgJHtyZW1vdmVkU3Bhbi5fa2V5fS4gSXQncyBhbWJpZ3VvdXMgd2hpY2ggb25lIHRvIHJlbW92ZS5gLCBKU09OLnN0cmluZ2lmeShibG9jaywgbnVsbCwgMikpKTtcbiAgfVxuICByZXR1cm4gcGF0Y2hlcztcbn1cbmZ1bmN0aW9uIG1vdmVOb2RlUGF0Y2goc2NoZW1hLCBiZWZvcmVWYWx1ZSwgb3BlcmF0aW9uKSB7XG4gIGNvbnN0IHBhdGNoZXMgPSBbXSwgYmxvY2sgPSBiZWZvcmVWYWx1ZVtvcGVyYXRpb24ucGF0aFswXV0sIHRhcmdldEJsb2NrID0gYmVmb3JlVmFsdWVbb3BlcmF0aW9uLm5ld1BhdGhbMF1dO1xuICBpZiAoIXRhcmdldEJsb2NrKVxuICAgIHJldHVybiBwYXRjaGVzO1xuICBpZiAob3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSBvcGVyYXRpb24ucGF0aFswXSA+IG9wZXJhdGlvbi5uZXdQYXRoWzBdID8gXCJiZWZvcmVcIiA6IFwiYWZ0ZXJcIjtcbiAgICBwYXRjaGVzLnB1c2godW5zZXQoW3tcbiAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICB9XSkpLCBwYXRjaGVzLnB1c2goaW5zZXJ0KFtmcm9tU2xhdGVWYWx1ZShbYmxvY2tdLCBzY2hlbWEuYmxvY2submFtZSlbMF1dLCBwb3NpdGlvbiwgW3tcbiAgICAgIF9rZXk6IHRhcmdldEJsb2NrLl9rZXlcbiAgICB9XSkpO1xuICB9IGVsc2UgaWYgKG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMiAmJiBpc1RleHRCbG9jayh7XG4gICAgc2NoZW1hXG4gIH0sIGJsb2NrKSAmJiBpc1RleHRCbG9jayh7XG4gICAgc2NoZW1hXG4gIH0sIHRhcmdldEJsb2NrKSkge1xuICAgIGNvbnN0IGNoaWxkID0gYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dLCB0YXJnZXRDaGlsZCA9IHRhcmdldEJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5uZXdQYXRoWzFdXSwgcG9zaXRpb24gPSBvcGVyYXRpb24ubmV3UGF0aFsxXSA9PT0gdGFyZ2V0QmxvY2suY2hpbGRyZW4ubGVuZ3RoID8gXCJhZnRlclwiIDogXCJiZWZvcmVcIiwgY2hpbGRUb0luc2VydCA9IGZyb21TbGF0ZVZhbHVlKFtibG9ja10sIHNjaGVtYS5ibG9jay5uYW1lKVswXS5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV07XG4gICAgcGF0Y2hlcy5wdXNoKHVuc2V0KFt7XG4gICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgfV0pKSwgcGF0Y2hlcy5wdXNoKGluc2VydChbY2hpbGRUb0luc2VydF0sIHBvc2l0aW9uLCBbe1xuICAgICAgX2tleTogdGFyZ2V0QmxvY2suX2tleVxuICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgX2tleTogdGFyZ2V0Q2hpbGQuX2tleVxuICAgIH1dKSk7XG4gIH1cbiAgcmV0dXJuIHBhdGNoZXM7XG59XG5jb25zdCBQQVRDSElORyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gd2l0aG91dFBhdGNoaW5nKGVkaXRvciwgZm4pIHtcbiAgY29uc3QgcHJldiA9IGlzUGF0Y2hpbmcoZWRpdG9yKTtcbiAgUEFUQ0hJTkcuc2V0KGVkaXRvciwgITEpLCBmbigpLCBQQVRDSElORy5zZXQoZWRpdG9yLCBwcmV2KTtcbn1cbmZ1bmN0aW9uIGlzUGF0Y2hpbmcoZWRpdG9yKSB7XG4gIHJldHVybiBQQVRDSElORy5nZXQoZWRpdG9yKTtcbn1cbmNvbnN0IGRlYnVnJGEgPSBkZWJ1Z1dpdGhOYW1lKFwicGx1Z2luOndpdGhQYXRjaGVzXCIpO1xuZnVuY3Rpb24gY3JlYXRlV2l0aFBhdGNoZXMoe1xuICBlZGl0b3JBY3RvcixcbiAgcmVsYXlBY3RvcixcbiAgc3Vic2NyaXB0aW9uc1xufSkge1xuICBsZXQgcHJldmlvdXNDaGlsZHJlbjtcbiAgY29uc3QgYXBwbHlQYXRjaCA9IGNyZWF0ZUFwcGx5UGF0Y2goZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYSk7XG4gIHJldHVybiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICBJU19QUk9DRVNTSU5HX1JFTU9URV9DSEFOR0VTLnNldChlZGl0b3IsICExKSwgUEFUQ0hJTkcuc2V0KGVkaXRvciwgITApLCBwcmV2aW91c0NoaWxkcmVuID0gWy4uLmVkaXRvci5jaGlsZHJlbl07XG4gICAgY29uc3Qge1xuICAgICAgYXBwbHk6IGFwcGx5MlxuICAgIH0gPSBlZGl0b3I7XG4gICAgbGV0IGJ1ZmZlcmVkUGF0Y2hlcyA9IFtdO1xuICAgIGNvbnN0IGhhbmRsZUJ1ZmZlcmVkUmVtb3RlUGF0Y2hlcyA9ICgpID0+IHtcbiAgICAgIGlmIChidWZmZXJlZFBhdGNoZXMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBwYXRjaGVzID0gYnVmZmVyZWRQYXRjaGVzO1xuICAgICAgYnVmZmVyZWRQYXRjaGVzID0gW107XG4gICAgICBsZXQgY2hhbmdlZCA9ICExO1xuICAgICAgd2l0aFJlbW90ZUNoYW5nZXMoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgd2l0aG91dFBhdGNoaW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgd2l0aG91dFNhdmluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBwYXRjaCBvZiBwYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgZGVidWckYS5lbmFibGVkICYmIGRlYnVnJGEoYEhhbmRsaW5nIHJlbW90ZSBwYXRjaCAke0pTT04uc3RyaW5naWZ5KHBhdGNoKX1gKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IGFwcGx5UGF0Y2goZWRpdG9yLCBwYXRjaCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEFwcGx5aW5nIHBhdGNoICR7SlNPTi5zdHJpbmdpZnkocGF0Y2gpfSBmYWlsZWQgZHVlIHRvOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSksIGNoYW5nZWQgJiYgKGVkaXRvci5ub3JtYWxpemUoKSwgZWRpdG9yLm9uQ2hhbmdlKCkpO1xuICAgICAgfSk7XG4gICAgfSwgaGFuZGxlUGF0Y2hlcyA9ICh7XG4gICAgICBwYXRjaGVzXG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgcmVtb3RlUGF0Y2hlcyA9IHBhdGNoZXMuZmlsdGVyKChwKSA9PiBwLm9yaWdpbiAhPT0gXCJsb2NhbFwiKTtcbiAgICAgIHJlbW90ZVBhdGNoZXMubGVuZ3RoICE9PSAwICYmIChidWZmZXJlZFBhdGNoZXMgPSBidWZmZXJlZFBhdGNoZXMuY29uY2F0KHJlbW90ZVBhdGNoZXMpLCBoYW5kbGVCdWZmZXJlZFJlbW90ZVBhdGNoZXMoKSk7XG4gICAgfTtcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9ucy5wdXNoKCgpID0+IHtcbiAgICAgIGRlYnVnJGEoXCJTdWJzY3JpYmluZyB0byByZW1vdGUgcGF0Y2hlc1wiKTtcbiAgICAgIGNvbnN0IHN1YiA9IGVkaXRvckFjdG9yLm9uKFwicGF0Y2hlc1wiLCBoYW5kbGVQYXRjaGVzKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRlYnVnJGEoXCJVbnN1YnNjcmliaW5nIHRvIHJlbW90ZSBwYXRjaGVzXCIpLCBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgIH07XG4gICAgfSksIGVkaXRvci5hcHBseSA9IChvcGVyYXRpb24pID0+IHtcbiAgICAgIGxldCBwYXRjaGVzID0gW107XG4gICAgICBwcmV2aW91c0NoaWxkcmVuID0gZWRpdG9yLmNoaWxkcmVuO1xuICAgICAgY29uc3QgZWRpdG9yV2FzRW1wdHkgPSBpc0VxdWFsVG9FbXB0eUVkaXRvcihwcmV2aW91c0NoaWxkcmVuLCBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hKTtcbiAgICAgIGFwcGx5MihvcGVyYXRpb24pO1xuICAgICAgY29uc3QgZWRpdG9ySXNFbXB0eSA9IGlzRXF1YWxUb0VtcHR5RWRpdG9yKGVkaXRvci5jaGlsZHJlbiwgZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYSk7XG4gICAgICBpZiAoIWlzUGF0Y2hpbmcoZWRpdG9yKSlcbiAgICAgICAgcmV0dXJuIGVkaXRvcjtcbiAgICAgIHN3aXRjaCAoZWRpdG9yV2FzRW1wdHkgJiYgIWVkaXRvcklzRW1wdHkgJiYgb3BlcmF0aW9uLnR5cGUgIT09IFwic2V0X3NlbGVjdGlvblwiICYmIHBhdGNoZXMucHVzaChpbnNlcnQocHJldmlvdXNDaGlsZHJlbiwgXCJiZWZvcmVcIiwgWzBdKSksIG9wZXJhdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJpbnNlcnRfdGV4dFwiOlxuICAgICAgICAgIHBhdGNoZXMgPSBbLi4ucGF0Y2hlcywgLi4uaW5zZXJ0VGV4dFBhdGNoKGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEsIGVkaXRvci5jaGlsZHJlbiwgb3BlcmF0aW9uLCBwcmV2aW91c0NoaWxkcmVuKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZW1vdmVfdGV4dFwiOlxuICAgICAgICAgIHBhdGNoZXMgPSBbLi4ucGF0Y2hlcywgLi4ucmVtb3ZlVGV4dFBhdGNoKGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEsIGVkaXRvci5jaGlsZHJlbiwgb3BlcmF0aW9uLCBwcmV2aW91c0NoaWxkcmVuKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZW1vdmVfbm9kZVwiOlxuICAgICAgICAgIHBhdGNoZXMgPSBbLi4ucGF0Y2hlcywgLi4ucmVtb3ZlTm9kZVBhdGNoKGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEsIHByZXZpb3VzQ2hpbGRyZW4sIG9wZXJhdGlvbildO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3BsaXRfbm9kZVwiOlxuICAgICAgICAgIHBhdGNoZXMgPSBbLi4ucGF0Y2hlcywgLi4uc3BsaXROb2RlUGF0Y2goZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYSwgZWRpdG9yLmNoaWxkcmVuLCBvcGVyYXRpb24sIHByZXZpb3VzQ2hpbGRyZW4pXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImluc2VydF9ub2RlXCI6XG4gICAgICAgICAgcGF0Y2hlcyA9IFsuLi5wYXRjaGVzLCAuLi5pbnNlcnROb2RlUGF0Y2goZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYSwgZWRpdG9yLmNoaWxkcmVuLCBvcGVyYXRpb24sIHByZXZpb3VzQ2hpbGRyZW4pXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNldF9ub2RlXCI6XG4gICAgICAgICAgcGF0Y2hlcyA9IFsuLi5wYXRjaGVzLCAuLi5zZXROb2RlUGF0Y2goZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYSwgZWRpdG9yLmNoaWxkcmVuLCBvcGVyYXRpb24pXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1lcmdlX25vZGVcIjpcbiAgICAgICAgICBwYXRjaGVzID0gWy4uLnBhdGNoZXMsIC4uLm1lcmdlTm9kZVBhdGNoKGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEsIGVkaXRvci5jaGlsZHJlbiwgb3BlcmF0aW9uLCBwcmV2aW91c0NoaWxkcmVuKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtb3ZlX25vZGVcIjpcbiAgICAgICAgICBwYXRjaGVzID0gWy4uLnBhdGNoZXMsIC4uLm1vdmVOb2RlUGF0Y2goZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYSwgcHJldmlvdXNDaGlsZHJlbiwgb3BlcmF0aW9uKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoIWVkaXRvcldhc0VtcHR5ICYmIGVkaXRvcklzRW1wdHkgJiYgW1wibWVyZ2Vfbm9kZVwiLCBcInNldF9ub2RlXCIsIFwicmVtb3ZlX3RleHRcIiwgXCJyZW1vdmVfbm9kZVwiXS5pbmNsdWRlcyhvcGVyYXRpb24udHlwZSkgJiYgKHBhdGNoZXMgPSBbLi4ucGF0Y2hlcywgdW5zZXQoW10pXSwgcmVsYXlBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJ1bnNldFwiLFxuICAgICAgICBwcmV2aW91c1ZhbHVlOiBmcm9tU2xhdGVWYWx1ZShwcmV2aW91c0NoaWxkcmVuLCBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKVxuICAgICAgfSkpLCBlZGl0b3JXYXNFbXB0eSAmJiBwYXRjaGVzLmxlbmd0aCA+IDAgJiYgKHBhdGNoZXMgPSBbc2V0SWZNaXNzaW5nKFtdLCBbXSksIC4uLnBhdGNoZXNdKSwgcGF0Y2hlcy5sZW5ndGggPiAwKVxuICAgICAgICBmb3IgKGNvbnN0IHBhdGNoIG9mIHBhdGNoZXMpXG4gICAgICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICB0eXBlOiBcImludGVybmFsLnBhdGNoXCIsXG4gICAgICAgICAgICBwYXRjaDoge1xuICAgICAgICAgICAgICAuLi5wYXRjaCxcbiAgICAgICAgICAgICAgb3JpZ2luOiBcImxvY2FsXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcGVyYXRpb25JZDogZ2V0Q3VycmVudFVuZG9TdGVwSWQoZWRpdG9yKSxcbiAgICAgICAgICAgIHZhbHVlOiBlZGl0b3IudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgIHJldHVybiBlZGl0b3I7XG4gICAgfSwgZWRpdG9yO1xuICB9O1xufVxuY29uc3QgZGVidWckOSA9IGRlYnVnV2l0aE5hbWUoXCJwbHVnaW46d2l0aFBsYWNlaG9sZGVyQmxvY2tcIik7XG5mdW5jdGlvbiBjcmVhdGVXaXRoUGxhY2Vob2xkZXJCbG9jayhlZGl0b3JBY3Rvcikge1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgYXBwbHk6IGFwcGx5MlxuICAgIH0gPSBlZGl0b3I7XG4gICAgcmV0dXJuIGVkaXRvci5hcHBseSA9IChvcCkgPT4ge1xuICAgICAgaWYgKGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkubWF0Y2hlcyh7XG4gICAgICAgIFwiZWRpdCBtb2RlXCI6IFwicmVhZCBvbmx5XCJcbiAgICAgIH0pKSB7XG4gICAgICAgIGFwcGx5MihvcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc0NoYW5naW5nUmVtb3RlbHkoZWRpdG9yKSkge1xuICAgICAgICBhcHBseTIob3ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNVbmRvaW5nKGVkaXRvcikgfHwgaXNSZWRvaW5nKGVkaXRvcikpIHtcbiAgICAgICAgYXBwbHkyKG9wKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9wLnR5cGUgPT09IFwicmVtb3ZlX25vZGVcIikge1xuICAgICAgICBjb25zdCBibG9ja0luZGV4ID0gb3AucGF0aC5hdCgwKSwgaXNMb25lbHlCbG9jayA9IG9wLnBhdGgubGVuZ3RoID09PSAxICYmIGJsb2NrSW5kZXggPT09IDAgJiYgZWRpdG9yLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSwgaXNCbG9ja09iamVjdCA9IG9wLm5vZGUuX3R5cGUgIT09IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEuYmxvY2submFtZTtcbiAgICAgICAgaXNMb25lbHlCbG9jayAmJiBpc0Jsb2NrT2JqZWN0ICYmIChkZWJ1ZyQ5KFwiQWRkaW5nIHBsYWNlaG9sZGVyIGJsb2NrXCIpLCBFZGl0b3IuaW5zZXJ0Tm9kZShlZGl0b3IsIGVkaXRvci5wdGVDcmVhdGVUZXh0QmxvY2soe1xuICAgICAgICAgIGRlY29yYXRvcnM6IFtdXG4gICAgICAgIH0pKSk7XG4gICAgICB9XG4gICAgICBhcHBseTIob3ApO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmNvbnN0IGRlYnVnJDggPSBkZWJ1Z1dpdGhOYW1lKFwicGx1Z2luOndpdGhTY2hlbWFUeXBlc1wiKTtcbmZ1bmN0aW9uIGNyZWF0ZVdpdGhTY2hlbWFUeXBlcyh7XG4gIGVkaXRvckFjdG9yXG59KSB7XG4gIHJldHVybiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICBlZGl0b3IuaXNUZXh0QmxvY2sgPSAodmFsdWUpID0+IEVkaXRvci5pc0VkaXRvcih2YWx1ZSkgPyAhMSA6IGlzVGV4dEJsb2NrKGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dCwgdmFsdWUpLCBlZGl0b3IuaXNUZXh0U3BhbiA9ICh2YWx1ZSkgPT4gRWRpdG9yLmlzRWRpdG9yKHZhbHVlKSA/ICExIDogaXNTcGFuKGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dCwgdmFsdWUpLCBlZGl0b3IuaXNMaXN0QmxvY2sgPSAodmFsdWUpID0+IEVkaXRvci5pc0VkaXRvcih2YWx1ZSkgPyAhMSA6IGlzTGlzdEJsb2NrKGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dCwgdmFsdWUpLCBlZGl0b3IuaXNWb2lkID0gKGVsZW1lbnQpID0+IEVkaXRvci5pc0VkaXRvcihlbGVtZW50KSA/ICExIDogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lICE9PSBlbGVtZW50Ll90eXBlICYmIChlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLmJsb2NrT2JqZWN0cy5tYXAoKG9iaikgPT4gb2JqLm5hbWUpLmluY2x1ZGVzKGVsZW1lbnQuX3R5cGUpIHx8IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEuaW5saW5lT2JqZWN0cy5tYXAoKG9iaikgPT4gb2JqLm5hbWUpLmluY2x1ZGVzKGVsZW1lbnQuX3R5cGUpKSwgZWRpdG9yLmlzSW5saW5lID0gKGVsZW1lbnQpID0+IEVkaXRvci5pc0VkaXRvcihlbGVtZW50KSA/ICExIDogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYS5pbmxpbmVPYmplY3RzLm1hcCgob2JqKSA9PiBvYmoubmFtZSkuaW5jbHVkZXMoZWxlbWVudC5fdHlwZSkgJiYgXCJfX2lubGluZVwiIGluIGVsZW1lbnQgJiYgZWxlbWVudC5fX2lubGluZSA9PT0gITA7XG4gICAgY29uc3Qge1xuICAgICAgbm9ybWFsaXplTm9kZVxuICAgIH0gPSBlZGl0b3I7XG4gICAgcmV0dXJuIGVkaXRvci5ub3JtYWxpemVOb2RlID0gKGVudHJ5KSA9PiB7XG4gICAgICBjb25zdCBbbm9kZSwgcGF0aF0gPSBlbnRyeTtcbiAgICAgIGlmIChub2RlLl90eXBlID09PSB2b2lkIDAgJiYgcGF0aC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgZGVidWckOChcIlNldHRpbmcgc3BhbiB0eXBlIG9uIHRleHQgbm9kZSB3aXRob3V0IGEgdHlwZVwiKTtcbiAgICAgICAgY29uc3Qgc3BhbiA9IG5vZGUsIGtleSA9IHNwYW4uX2tleSB8fCBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKCk7XG4gICAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAuLi5zcGFuLFxuICAgICAgICAgIF90eXBlOiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLnNwYW4ubmFtZSxcbiAgICAgICAgICBfa2V5OiBrZXlcbiAgICAgICAgfSwge1xuICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuX2tleSA9PT0gdm9pZCAwICYmIChwYXRoLmxlbmd0aCA9PT0gMSB8fCBwYXRoLmxlbmd0aCA9PT0gMikpIHtcbiAgICAgICAgZGVidWckOChcIlNldHRpbmcgbWlzc2luZyBrZXkgb24gY2hpbGQgbm9kZSB3aXRob3V0IGEga2V5XCIpO1xuICAgICAgICBjb25zdCBrZXkgPSBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKCk7XG4gICAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBfa2V5OiBrZXlcbiAgICAgICAgfSwge1xuICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbm9ybWFsaXplTm9kZShlbnRyeSk7XG4gICAgfSwgZWRpdG9yO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlV2l0aFV0aWxzKHtcbiAgZWRpdG9yQWN0b3Jcbn0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IucHRlQ3JlYXRlVGV4dEJsb2NrID0gKG9wdGlvbnMpID0+IHRvU2xhdGVWYWx1ZShbe1xuICAgICAgX3R5cGU6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEuYmxvY2submFtZSxcbiAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgIHN0eWxlOiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLnN0eWxlc1swXS5uYW1lIHx8IFwibm9ybWFsXCIsXG4gICAgICAuLi5vcHRpb25zLmxpc3RJdGVtID8ge1xuICAgICAgICBsaXN0SXRlbTogb3B0aW9ucy5saXN0SXRlbVxuICAgICAgfSA6IHt9LFxuICAgICAgLi4ub3B0aW9ucy5sZXZlbCA/IHtcbiAgICAgICAgbGV2ZWw6IG9wdGlvbnMubGV2ZWxcbiAgICAgIH0gOiB7fSxcbiAgICAgIG1hcmtEZWZzOiBbXSxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICBfdHlwZTogXCJzcGFuXCIsXG4gICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgbWFya3M6IG9wdGlvbnMuZGVjb3JhdG9ycy5maWx0ZXIoKGRlY29yYXRvcikgPT4gZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYS5kZWNvcmF0b3JzLmZpbmQoKHtcbiAgICAgICAgICBuYW1lXG4gICAgICAgIH0pID0+IG5hbWUgPT09IGRlY29yYXRvcikpXG4gICAgICB9XVxuICAgIH1dLCB7XG4gICAgICBzY2hlbWFUeXBlczogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYVxuICAgIH0pWzBdLCBlZGl0b3I7XG4gIH07XG59XG5mdW5jdGlvbiBwbHVnaW5VcGRhdGVTZWxlY3Rpb24oe1xuICBlZGl0b3IsXG4gIGVkaXRvckFjdG9yXG59KSB7XG4gIGNvbnN0IHVwZGF0ZVNlbGVjdGlvbiA9ICgpID0+IHtcbiAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgY29uc3QgZXhpc3RpbmdTZWxlY3Rpb24gPSBTTEFURV9UT19QT1JUQUJMRV9URVhUX1JBTkdFLmdldChlZGl0b3Iuc2VsZWN0aW9uKTtcbiAgICAgIGlmIChleGlzdGluZ1NlbGVjdGlvbilcbiAgICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJ1cGRhdGUgc2VsZWN0aW9uXCIsXG4gICAgICAgICAgc2VsZWN0aW9uOiBleGlzdGluZ1NlbGVjdGlvblxuICAgICAgICB9KTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBzbGF0ZVJhbmdlVG9TZWxlY3Rpb24oe1xuICAgICAgICAgIHNjaGVtYTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYSxcbiAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgcmFuZ2U6IGVkaXRvci5zZWxlY3Rpb25cbiAgICAgICAgfSk7XG4gICAgICAgIFNMQVRFX1RPX1BPUlRBQkxFX1RFWFRfUkFOR0Uuc2V0KGVkaXRvci5zZWxlY3Rpb24sIHNlbGVjdGlvbiksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwidXBkYXRlIHNlbGVjdGlvblwiLFxuICAgICAgICAgIHNlbGVjdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2VcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcInVwZGF0ZSBzZWxlY3Rpb25cIixcbiAgICAgICAgc2VsZWN0aW9uOiBudWxsXG4gICAgICB9KTtcbiAgfSwge1xuICAgIG9uQ2hhbmdlXG4gIH0gPSBlZGl0b3I7XG4gIHJldHVybiBlZGl0b3Iub25DaGFuZ2UgPSAoKSA9PiB7XG4gICAgb25DaGFuZ2UoKSwgZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5tYXRjaGVzKHtcbiAgICAgIHNldHVwOiBcInNldHRpbmcgdXBcIlxuICAgIH0pIHx8IHVwZGF0ZVNlbGVjdGlvbigpO1xuICB9LCBlZGl0b3I7XG59XG5mdW5jdGlvbiBpc0VkaXRvck5vZGUobm9kZSkge1xuICByZXR1cm4gdHlwZW9mIG5vZGUgPT0gXCJvYmplY3RcIiAmJiBub2RlICE9PSBudWxsID8gIShcIl90eXBlXCIgaW4gbm9kZSkgJiYgXCJjaGlsZHJlblwiIGluIG5vZGUgJiYgQXJyYXkuaXNBcnJheShub2RlLmNoaWxkcmVuKSA6ICExO1xufVxuZnVuY3Rpb24gaXNUZXh0QmxvY2tOb2RlKGNvbnRleHQsIG5vZGUpIHtcbiAgcmV0dXJuIGlzVHlwZWRPYmplY3Qobm9kZSkgJiYgbm9kZS5fdHlwZSA9PT0gY29udGV4dC5zY2hlbWEuYmxvY2submFtZTtcbn1cbmZ1bmN0aW9uIGlzU3Bhbk5vZGUoY29udGV4dCwgbm9kZSkge1xuICByZXR1cm4gdHlwZW9mIG5vZGUgIT0gXCJvYmplY3RcIiB8fCBub2RlID09PSBudWxsIHx8IFwiY2hpbGRyZW5cIiBpbiBub2RlID8gITEgOiBcIl90eXBlXCIgaW4gbm9kZSA/IG5vZGUuX3R5cGUgPT09IGNvbnRleHQuc2NoZW1hLnNwYW4ubmFtZSA6IFwidGV4dFwiIGluIG5vZGU7XG59XG5mdW5jdGlvbiBpc1BhcnRpYWxTcGFuTm9kZShub2RlKSB7XG4gIHJldHVybiB0eXBlb2Ygbm9kZSA9PSBcIm9iamVjdFwiICYmIG5vZGUgIT09IG51bGwgJiYgXCJ0ZXh0XCIgaW4gbm9kZSAmJiB0eXBlb2Ygbm9kZS50ZXh0ID09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc09iamVjdE5vZGUoY29udGV4dCwgbm9kZSkge1xuICByZXR1cm4gIWlzRWRpdG9yTm9kZShub2RlKSAmJiAhaXNUZXh0QmxvY2tOb2RlKGNvbnRleHQsIG5vZGUpICYmICFpc1NwYW5Ob2RlKGNvbnRleHQsIG5vZGUpICYmICFpc1BhcnRpYWxTcGFuTm9kZShub2RlKTtcbn1cbmZ1bmN0aW9uIGdldEJsb2NrKHJvb3QsIHBhdGgpIHtcbiAgY29uc3QgaW5kZXggPSBwYXRoLmF0KDApO1xuICBpZiAoIShpbmRleCA9PT0gdm9pZCAwIHx8IHBhdGgubGVuZ3RoICE9PSAxKSlcbiAgICByZXR1cm4gcm9vdC5jaGlsZHJlbi5hdChpbmRleCk7XG59XG5mdW5jdGlvbiBnZXROb2RlKGNvbnRleHQsIHJvb3QsIHBhdGgpIHtcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiByb290O1xuICBpZiAocGF0aC5sZW5ndGggPT09IDEpXG4gICAgcmV0dXJuIGdldEJsb2NrKHJvb3QsIHBhdGgpO1xuICBpZiAocGF0aC5sZW5ndGggPT09IDIpIHtcbiAgICBjb25zdCBibG9jayA9IGdldEJsb2NrKHJvb3QsIHBhdGguc2xpY2UoMCwgMSkpO1xuICAgIHJldHVybiAhYmxvY2sgfHwgIWlzVGV4dEJsb2NrTm9kZShjb250ZXh0LCBibG9jaykgPyB2b2lkIDAgOiBibG9jay5jaGlsZHJlbi5hdChwYXRoWzFdKSB8fCB2b2lkIDA7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFNwYW4oY29udGV4dCwgcm9vdCwgcGF0aCkge1xuICBjb25zdCBub2RlID0gZ2V0Tm9kZShjb250ZXh0LCByb290LCBwYXRoKTtcbiAgaWYgKG5vZGUgJiYgaXNTcGFuTm9kZShjb250ZXh0LCBub2RlKSlcbiAgICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGdldFBhcmVudChjb250ZXh0LCByb290LCBwYXRoKSB7XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm47XG4gIGNvbnN0IHBhcmVudFBhdGggPSBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgaWYgKHBhcmVudFBhdGgubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiByb290O1xuICBjb25zdCBibG9ja0luZGV4ID0gcGFyZW50UGF0aC5hdCgwKTtcbiAgaWYgKGJsb2NrSW5kZXggPT09IHZvaWQgMCB8fCBwYXJlbnRQYXRoLmxlbmd0aCAhPT0gMSlcbiAgICByZXR1cm47XG4gIGNvbnN0IGJsb2NrID0gcm9vdC5jaGlsZHJlbi5hdChibG9ja0luZGV4KTtcbiAgaWYgKGJsb2NrICYmIGlzVGV4dEJsb2NrTm9kZShjb250ZXh0LCBibG9jaykpXG4gICAgcmV0dXJuIGJsb2NrO1xufVxuZnVuY3Rpb24gYXBwbHlPcGVyYXRpb25Ub1BvcnRhYmxlVGV4dChjb250ZXh0LCB2YWx1ZSwgb3BlcmF0aW9uKSB7XG4gIGNvbnN0IGRyYWZ0ID0gY3JlYXRlRHJhZnQoe1xuICAgIGNoaWxkcmVuOiB2YWx1ZVxuICB9KTtcbiAgdHJ5IHtcbiAgICBhcHBseU9wZXJhdGlvblRvUG9ydGFibGVUZXh0RHJhZnQoY29udGV4dCwgZHJhZnQsIG9wZXJhdGlvbik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKGUpO1xuICB9XG4gIHJldHVybiBmaW5pc2hEcmFmdChkcmFmdCkuY2hpbGRyZW47XG59XG5mdW5jdGlvbiBhcHBseU9wZXJhdGlvblRvUG9ydGFibGVUZXh0RHJhZnQoY29udGV4dCwgcm9vdCwgb3BlcmF0aW9uKSB7XG4gIHN3aXRjaCAob3BlcmF0aW9uLnR5cGUpIHtcbiAgICBjYXNlIFwiaW5zZXJ0X25vZGVcIjoge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXRoLFxuICAgICAgICBub2RlOiBpbnNlcnRlZE5vZGVcbiAgICAgIH0gPSBvcGVyYXRpb24sIHBhcmVudCA9IGdldFBhcmVudChjb250ZXh0LCByb290LCBwYXRoKSwgaW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoIXBhcmVudCB8fCBpbmRleCA+IHBhcmVudC5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgIGJyZWFrO1xuICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChpc1RleHRCbG9ja05vZGUoY29udGV4dCwgaW5zZXJ0ZWROb2RlKSkge1xuICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIHtcbiAgICAgICAgICAgIC4uLmluc2VydGVkTm9kZSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBpbnNlcnRlZE5vZGUuY2hpbGRyZW4ubWFwKChjaGlsZCkgPT4gXCJfX2lubGluZVwiIGluIGNoaWxkID8ge1xuICAgICAgICAgICAgICBfa2V5OiBjaGlsZC5fa2V5LFxuICAgICAgICAgICAgICBfdHlwZTogY2hpbGQuX3R5cGUsXG4gICAgICAgICAgICAgIC4uLlwidmFsdWVcIiBpbiBjaGlsZCAmJiB0eXBlb2YgY2hpbGQudmFsdWUgPT0gXCJvYmplY3RcIiA/IGNoaWxkLnZhbHVlIDoge31cbiAgICAgICAgICAgIH0gOiBjaGlsZClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoRWxlbWVudCQxLmlzRWxlbWVudChpbnNlcnRlZE5vZGUpICYmICEoXCJfX2lubGluZVwiIGluIGluc2VydGVkTm9kZSkpIHtcbiAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAwLCB7XG4gICAgICAgICAgICBfa2V5OiBpbnNlcnRlZE5vZGUuX2tleSxcbiAgICAgICAgICAgIF90eXBlOiBpbnNlcnRlZE5vZGUuX3R5cGUsXG4gICAgICAgICAgICAuLi5cInZhbHVlXCIgaW4gaW5zZXJ0ZWROb2RlICYmIHR5cGVvZiBpbnNlcnRlZE5vZGUudmFsdWUgPT0gXCJvYmplY3RcIiA/IGluc2VydGVkTm9kZS52YWx1ZSA6IHt9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBpZiAoIWlzVGV4dEJsb2NrTm9kZShjb250ZXh0LCBwYXJlbnQpKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAoaXNQYXJ0aWFsU3Bhbk5vZGUoaW5zZXJ0ZWROb2RlKSkge1xuICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIGluc2VydGVkTm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiX19pbmxpbmVcIiBpbiBpbnNlcnRlZE5vZGUpIHtcbiAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAwLCB7XG4gICAgICAgICAgICBfa2V5OiBpbnNlcnRlZE5vZGUuX2tleSxcbiAgICAgICAgICAgIF90eXBlOiBpbnNlcnRlZE5vZGUuX3R5cGUsXG4gICAgICAgICAgICAuLi5cInZhbHVlXCIgaW4gaW5zZXJ0ZWROb2RlICYmIHR5cGVvZiBpbnNlcnRlZE5vZGUudmFsdWUgPT0gXCJvYmplY3RcIiA/IGluc2VydGVkTm9kZS52YWx1ZSA6IHt9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiaW5zZXJ0X3RleHRcIjoge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXRoLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIHRleHRcbiAgICAgIH0gPSBvcGVyYXRpb247XG4gICAgICBpZiAodGV4dC5sZW5ndGggPT09IDApIGJyZWFrO1xuICAgICAgY29uc3Qgc3BhbiA9IGdldFNwYW4oY29udGV4dCwgcm9vdCwgcGF0aCk7XG4gICAgICBpZiAoIXNwYW4pXG4gICAgICAgIGJyZWFrO1xuICAgICAgY29uc3QgYmVmb3JlID0gc3Bhbi50ZXh0LnNsaWNlKDAsIG9mZnNldCksIGFmdGVyID0gc3Bhbi50ZXh0LnNsaWNlKG9mZnNldCk7XG4gICAgICBzcGFuLnRleHQgPSBiZWZvcmUgKyB0ZXh0ICsgYWZ0ZXI7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIm1lcmdlX25vZGVcIjoge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXRoXG4gICAgICB9ID0gb3BlcmF0aW9uLCBub2RlID0gZ2V0Tm9kZShjb250ZXh0LCByb290LCBwYXRoKSwgcHJldlBhdGggPSBQYXRoLnByZXZpb3VzKHBhdGgpLCBwcmV2ID0gZ2V0Tm9kZShjb250ZXh0LCByb290LCBwcmV2UGF0aCksIHBhcmVudCA9IGdldFBhcmVudChjb250ZXh0LCByb290LCBwYXRoKTtcbiAgICAgIGlmICghbm9kZSB8fCAhcHJldiB8fCAhcGFyZW50KVxuICAgICAgICBicmVhaztcbiAgICAgIGNvbnN0IGluZGV4ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGlzUGFydGlhbFNwYW5Ob2RlKG5vZGUpICYmIGlzUGFydGlhbFNwYW5Ob2RlKHByZXYpKVxuICAgICAgICBwcmV2LnRleHQgKz0gbm9kZS50ZXh0O1xuICAgICAgZWxzZSBpZiAoaXNUZXh0QmxvY2tOb2RlKGNvbnRleHQsIG5vZGUpICYmIGlzVGV4dEJsb2NrTm9kZShjb250ZXh0LCBwcmV2KSlcbiAgICAgICAgcHJldi5jaGlsZHJlbi5wdXNoKC4uLm5vZGUuY2hpbGRyZW4pO1xuICAgICAgZWxzZVxuICAgICAgICBicmVhaztcbiAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJtb3ZlX25vZGVcIjoge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXRoLFxuICAgICAgICBuZXdQYXRoXG4gICAgICB9ID0gb3BlcmF0aW9uO1xuICAgICAgaWYgKFBhdGguaXNBbmNlc3RvcihwYXRoLCBuZXdQYXRoKSlcbiAgICAgICAgYnJlYWs7XG4gICAgICBjb25zdCBub2RlID0gZ2V0Tm9kZShjb250ZXh0LCByb290LCBwYXRoKSwgcGFyZW50ID0gZ2V0UGFyZW50KGNvbnRleHQsIHJvb3QsIHBhdGgpLCBpbmRleCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgIGlmICghbm9kZSB8fCAhcGFyZW50KVxuICAgICAgICBicmVhaztcbiAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgY29uc3QgdHJ1ZVBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcGVyYXRpb24pLCBuZXdQYXJlbnQgPSBnZXROb2RlKGNvbnRleHQsIHJvb3QsIFBhdGgucGFyZW50KHRydWVQYXRoKSksIG5ld0luZGV4ID0gdHJ1ZVBhdGhbdHJ1ZVBhdGgubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoIW5ld1BhcmVudCB8fCAhKFwiY2hpbGRyZW5cIiBpbiBuZXdQYXJlbnQpIHx8ICFBcnJheS5pc0FycmF5KG5ld1BhcmVudC5jaGlsZHJlbikpXG4gICAgICAgIGJyZWFrO1xuICAgICAgbmV3UGFyZW50LmNoaWxkcmVuLnNwbGljZShuZXdJbmRleCwgMCwgbm9kZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInJlbW92ZV9ub2RlXCI6IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGF0aFxuICAgICAgfSA9IG9wZXJhdGlvbiwgaW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICBnZXRQYXJlbnQoY29udGV4dCwgcm9vdCwgcGF0aCk/LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInJlbW92ZV90ZXh0XCI6IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICB0ZXh0XG4gICAgICB9ID0gb3BlcmF0aW9uO1xuICAgICAgaWYgKHRleHQubGVuZ3RoID09PSAwKVxuICAgICAgICBicmVhaztcbiAgICAgIGNvbnN0IHNwYW4gPSBnZXRTcGFuKGNvbnRleHQsIHJvb3QsIHBhdGgpO1xuICAgICAgaWYgKCFzcGFuKVxuICAgICAgICBicmVhaztcbiAgICAgIGNvbnN0IGJlZm9yZSA9IHNwYW4udGV4dC5zbGljZSgwLCBvZmZzZXQpLCBhZnRlciA9IHNwYW4udGV4dC5zbGljZShvZmZzZXQgKyB0ZXh0Lmxlbmd0aCk7XG4gICAgICBzcGFuLnRleHQgPSBiZWZvcmUgKyBhZnRlcjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwic2V0X25vZGVcIjoge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXRoLFxuICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICBuZXdQcm9wZXJ0aWVzXG4gICAgICB9ID0gb3BlcmF0aW9uLCBub2RlID0gZ2V0Tm9kZShjb250ZXh0LCByb290LCBwYXRoKTtcbiAgICAgIGlmICghbm9kZSB8fCBpc0VkaXRvck5vZGUobm9kZSkpXG4gICAgICAgIGJyZWFrO1xuICAgICAgaWYgKGlzT2JqZWN0Tm9kZShjb250ZXh0LCBub2RlKSkge1xuICAgICAgICBjb25zdCB2YWx1ZUJlZm9yZSA9IFwidmFsdWVcIiBpbiBwcm9wZXJ0aWVzICYmIHR5cGVvZiBwcm9wZXJ0aWVzLnZhbHVlID09IFwib2JqZWN0XCIgPyBwcm9wZXJ0aWVzLnZhbHVlIDoge30sIHZhbHVlQWZ0ZXIgPSBcInZhbHVlXCIgaW4gbmV3UHJvcGVydGllcyAmJiB0eXBlb2YgbmV3UHJvcGVydGllcy52YWx1ZSA9PSBcIm9iamVjdFwiID8gbmV3UHJvcGVydGllcy52YWx1ZSA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXdQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgaWYgKGtleSA9PT0gXCJ2YWx1ZVwiKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBuZXdQcm9wZXJ0aWVzW2tleV07XG4gICAgICAgICAgdmFsdWUgPT0gbnVsbCA/IGRlbGV0ZSBub2RlW2tleV0gOiBub2RlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wZXJ0aWVzKVxuICAgICAgICAgIGtleSAhPT0gXCJ2YWx1ZVwiICYmIChuZXdQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGtleSkgfHwgZGVsZXRlIG5vZGVba2V5XSk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlQWZ0ZXIpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlQWZ0ZXJba2V5XTtcbiAgICAgICAgICB2YWx1ZSA9PSBudWxsID8gZGVsZXRlIG5vZGVba2V5XSA6IG5vZGVba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlQmVmb3JlKVxuICAgICAgICAgIHZhbHVlQWZ0ZXIuaGFzT3duUHJvcGVydHkoa2V5KSB8fCBkZWxldGUgbm9kZVtrZXldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChpc1RleHRCbG9ja05vZGUoY29udGV4dCwgbm9kZSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmV3UHJvcGVydGllcykge1xuICAgICAgICAgIGlmIChrZXkgPT09IFwiY2hpbGRyZW5cIiB8fCBrZXkgPT09IFwidGV4dFwiKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBuZXdQcm9wZXJ0aWVzW2tleV07XG4gICAgICAgICAgdmFsdWUgPT0gbnVsbCA/IGRlbGV0ZSBub2RlW2tleV0gOiBub2RlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wZXJ0aWVzKVxuICAgICAgICAgIG5ld1Byb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoa2V5KSB8fCBkZWxldGUgbm9kZVtrZXldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChpc1BhcnRpYWxTcGFuTm9kZShub2RlKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXdQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgaWYgKGtleSA9PT0gXCJ0ZXh0XCIpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IG5ld1Byb3BlcnRpZXNba2V5XTtcbiAgICAgICAgICB2YWx1ZSA9PSBudWxsID8gZGVsZXRlIG5vZGVba2V5XSA6IG5vZGVba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BlcnRpZXMpXG4gICAgICAgICAgbmV3UHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShrZXkpIHx8IGRlbGV0ZSBub2RlW2tleV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJzcGxpdF9ub2RlXCI6IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgcG9zaXRpb24sXG4gICAgICAgIHByb3BlcnRpZXNcbiAgICAgIH0gPSBvcGVyYXRpb247XG4gICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApXG4gICAgICAgIGJyZWFrO1xuICAgICAgY29uc3QgcGFyZW50ID0gZ2V0UGFyZW50KGNvbnRleHQsIHJvb3QsIHBhdGgpLCBpbmRleCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgIGlmICghcGFyZW50KVxuICAgICAgICBicmVhaztcbiAgICAgIGlmIChpc0VkaXRvck5vZGUocGFyZW50KSkge1xuICAgICAgICBjb25zdCBibG9jayA9IGdldEJsb2NrKHJvb3QsIHBhdGgpO1xuICAgICAgICBpZiAoIWJsb2NrIHx8ICFpc1RleHRCbG9ja05vZGUoY29udGV4dCwgYmxvY2spKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjb25zdCBiZWZvcmUgPSBibG9jay5jaGlsZHJlbi5zbGljZSgwLCBwb3NpdGlvbiksIGFmdGVyID0gYmxvY2suY2hpbGRyZW4uc2xpY2UocG9zaXRpb24pO1xuICAgICAgICBibG9jay5jaGlsZHJlbiA9IGJlZm9yZTtcbiAgICAgICAgY29uc3QgbmV3VGV4dEJsb2NrTm9kZSA9IHtcbiAgICAgICAgICAuLi5wcm9wZXJ0aWVzLFxuICAgICAgICAgIGNoaWxkcmVuOiBhZnRlcixcbiAgICAgICAgICBfdHlwZTogY29udGV4dC5zY2hlbWEuYmxvY2submFtZVxuICAgICAgICB9O1xuICAgICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4ICsgMSwgMCwgbmV3VGV4dEJsb2NrTm9kZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGlzVGV4dEJsb2NrTm9kZShjb250ZXh0LCBwYXJlbnQpKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBnZXROb2RlKGNvbnRleHQsIHJvb3QsIHBhdGgpO1xuICAgICAgICBpZiAoIW5vZGUgfHwgIWlzU3Bhbk5vZGUoY29udGV4dCwgbm9kZSkpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNvbnN0IGJlZm9yZSA9IG5vZGUudGV4dC5zbGljZSgwLCBwb3NpdGlvbiksIGFmdGVyID0gbm9kZS50ZXh0LnNsaWNlKHBvc2l0aW9uKTtcbiAgICAgICAgbm9kZS50ZXh0ID0gYmVmb3JlO1xuICAgICAgICBjb25zdCBuZXdTcGFuTm9kZSA9IHtcbiAgICAgICAgICAuLi5wcm9wZXJ0aWVzLFxuICAgICAgICAgIHRleHQ6IGFmdGVyXG4gICAgICAgIH07XG4gICAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXggKyAxLCAwLCBuZXdTcGFuTm9kZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJvb3Q7XG59XG5mdW5jdGlvbiBwbHVnaW5VcGRhdGVWYWx1ZShjb250ZXh0LCBlZGl0b3IpIHtcbiAgY29uc3Qge1xuICAgIGFwcGx5OiBhcHBseTJcbiAgfSA9IGVkaXRvcjtcbiAgcmV0dXJuIGVkaXRvci5hcHBseSA9IChvcGVyYXRpb24pID0+IHtcbiAgICBpZiAob3BlcmF0aW9uLnR5cGUgPT09IFwic2V0X3NlbGVjdGlvblwiKSB7XG4gICAgICBhcHBseTIob3BlcmF0aW9uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVkaXRvci52YWx1ZSA9IGFwcGx5T3BlcmF0aW9uVG9Qb3J0YWJsZVRleHQoY29udGV4dCwgZWRpdG9yLnZhbHVlLCBvcGVyYXRpb24pLCBvcGVyYXRpb24udHlwZSA9PT0gXCJpbnNlcnRfdGV4dFwiIHx8IG9wZXJhdGlvbi50eXBlID09PSBcInJlbW92ZV90ZXh0XCIpIHtcbiAgICAgIGFwcGx5MihvcGVyYXRpb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBidWlsZEluZGV4TWFwcyh7XG4gICAgICBzY2hlbWE6IGNvbnRleHQuc2NoZW1hLFxuICAgICAgdmFsdWU6IGVkaXRvci52YWx1ZVxuICAgIH0sIHtcbiAgICAgIGJsb2NrSW5kZXhNYXA6IGVkaXRvci5ibG9ja0luZGV4TWFwLFxuICAgICAgbGlzdEluZGV4TWFwOiBlZGl0b3IubGlzdEluZGV4TWFwXG4gICAgfSksIGFwcGx5MihvcGVyYXRpb24pO1xuICB9LCBlZGl0b3I7XG59XG5jb25zdCB3aXRoUGx1Z2lucyA9IChlZGl0b3IsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgZSA9IGVkaXRvciwge1xuICAgIGVkaXRvckFjdG9yLFxuICAgIHJlbGF5QWN0b3JcbiAgfSA9IG9wdGlvbnMsIHdpdGhPYmplY3RLZXlzID0gY3JlYXRlV2l0aE9iamVjdEtleXMoZWRpdG9yQWN0b3IpLCB3aXRoU2NoZW1hVHlwZXMgPSBjcmVhdGVXaXRoU2NoZW1hVHlwZXMoe1xuICAgIGVkaXRvckFjdG9yXG4gIH0pLCB3aXRoUGF0Y2hlcyA9IGNyZWF0ZVdpdGhQYXRjaGVzKHtcbiAgICBlZGl0b3JBY3RvcixcbiAgICByZWxheUFjdG9yLFxuICAgIHN1YnNjcmlwdGlvbnM6IG9wdGlvbnMuc3Vic2NyaXB0aW9uc1xuICB9KSwgd2l0aE1heEJsb2NrcyA9IGNyZWF0ZVdpdGhNYXhCbG9ja3MoZWRpdG9yQWN0b3IpLCB3aXRoVW5kb1JlZG8gPSBjcmVhdGVXaXRoVW5kb1JlZG8oe1xuICAgIGVkaXRvckFjdG9yLFxuICAgIHN1YnNjcmlwdGlvbnM6IG9wdGlvbnMuc3Vic2NyaXB0aW9uc1xuICB9KSwgd2l0aFBvcnRhYmxlVGV4dE1hcmtNb2RlbCA9IGNyZWF0ZVdpdGhQb3J0YWJsZVRleHRNYXJrTW9kZWwoZWRpdG9yQWN0b3IpLCB3aXRoUGxhY2Vob2xkZXJCbG9jayA9IGNyZWF0ZVdpdGhQbGFjZWhvbGRlckJsb2NrKGVkaXRvckFjdG9yKSwgd2l0aFV0aWxzID0gY3JlYXRlV2l0aFV0aWxzKHtcbiAgICBlZGl0b3JBY3RvclxuICB9KTtcbiAgcmV0dXJuIGNyZWF0ZVdpdGhFdmVudExpc3RlbmVycyhlZGl0b3JBY3Rvcikod2l0aFNjaGVtYVR5cGVzKHdpdGhPYmplY3RLZXlzKHdpdGhQb3J0YWJsZVRleHRNYXJrTW9kZWwod2l0aFBsYWNlaG9sZGVyQmxvY2sod2l0aFV0aWxzKHdpdGhNYXhCbG9ja3Mod2l0aFVuZG9SZWRvKHdpdGhQYXRjaGVzKHBsdWdpblVwZGF0ZVZhbHVlKGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dCwgcGx1Z2luVXBkYXRlU2VsZWN0aW9uKHtcbiAgICBlZGl0b3JBY3RvcixcbiAgICBlZGl0b3I6IGVcbiAgfSkpKSkpKSkpKSkpO1xufSwgZGVidWckNyA9IGRlYnVnV2l0aE5hbWUoXCJzZXR1cFwiKTtcbmZ1bmN0aW9uIGNyZWF0ZVNsYXRlRWRpdG9yKGNvbmZpZykge1xuICBkZWJ1ZyQ3KFwiQ3JlYXRpbmcgbmV3IFNsYXRlIGVkaXRvciBpbnN0YW5jZVwiKTtcbiAgY29uc3QgaW5zdGFuY2UgPSB3aXRoUGx1Z2lucyh3aXRoUmVhY3QoY3JlYXRlRWRpdG9yKCkpLCB7XG4gICAgZWRpdG9yQWN0b3I6IGNvbmZpZy5lZGl0b3JBY3RvcixcbiAgICByZWxheUFjdG9yOiBjb25maWcucmVsYXlBY3RvcixcbiAgICBzdWJzY3JpcHRpb25zOiBjb25maWcuc3Vic2NyaXB0aW9uc1xuICB9KTtcbiAgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuc2V0KGluc3RhbmNlLCB7fSksIEtFWV9UT19TTEFURV9FTEVNRU5ULnNldChpbnN0YW5jZSwge30pLCBpbnN0YW5jZS5kZWNvcmF0ZWRSYW5nZXMgPSBbXSwgaW5zdGFuY2UuZGVjb3JhdG9yU3RhdGUgPSB7fTtcbiAgY29uc3QgcGxhY2Vob2xkZXJCbG9jayA9IGNyZWF0ZVBsYWNlaG9sZGVyQmxvY2soY29uZmlnLmVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dCk7XG4gIGluc3RhbmNlLnZhbHVlID0gW3BsYWNlaG9sZGVyQmxvY2tdLCBpbnN0YW5jZS5ibG9ja0luZGV4TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgaW5zdGFuY2UubGlzdEluZGV4TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgYnVpbGRJbmRleE1hcHMoe1xuICAgIHNjaGVtYTogY29uZmlnLmVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEsXG4gICAgdmFsdWU6IGluc3RhbmNlLnZhbHVlXG4gIH0sIHtcbiAgICBibG9ja0luZGV4TWFwOiBpbnN0YW5jZS5ibG9ja0luZGV4TWFwLFxuICAgIGxpc3RJbmRleE1hcDogaW5zdGFuY2UubGlzdEluZGV4TWFwXG4gIH0pO1xuICBjb25zdCBpbml0aWFsVmFsdWUgPSB0b1NsYXRlVmFsdWUoaW5zdGFuY2UudmFsdWUsIHtcbiAgICBzY2hlbWFUeXBlczogY29uZmlnLmVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWFcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgaW5zdGFuY2UsXG4gICAgaW5pdGlhbFZhbHVlXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVFZGl0b3JEb20oc2VuZEJhY2ssIHNsYXRlRWRpdG9yKSB7XG4gIHJldHVybiB7XG4gICAgZ2V0QmxvY2tOb2RlczogKHNuYXBzaG90KSA9PiBnZXRCbG9ja05vZGVzKHNsYXRlRWRpdG9yLCBzbmFwc2hvdCksXG4gICAgZ2V0Q2hpbGROb2RlczogKHNuYXBzaG90KSA9PiBnZXRDaGlsZE5vZGVzKHNsYXRlRWRpdG9yLCBzbmFwc2hvdCksXG4gICAgc2V0RHJhZ0dob3N0OiAoe1xuICAgICAgZXZlbnQsXG4gICAgICBnaG9zdFxuICAgIH0pID0+IHNldERyYWdHaG9zdCh7XG4gICAgICBzZW5kQmFjayxcbiAgICAgIGV2ZW50LFxuICAgICAgZ2hvc3RcbiAgICB9KVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0QmxvY2tOb2RlcyhzbGF0ZUVkaXRvciwgc25hcHNob3QpIHtcbiAgaWYgKCFzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbilcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IHJhbmdlID0gdG9TbGF0ZVJhbmdlKHNuYXBzaG90KTtcbiAgaWYgKCFyYW5nZSlcbiAgICByZXR1cm4gW107XG4gIHRyeSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKHNsYXRlRWRpdG9yLCB7XG4gICAgICBhdDogcmFuZ2UsXG4gICAgICBtb2RlOiBcImhpZ2hlc3RcIixcbiAgICAgIG1hdGNoOiAobikgPT4gIUVkaXRvci5pc0VkaXRvcihuKVxuICAgIH0pKS5tYXAoKFtibG9ja05vZGVdKSA9PiBET01FZGl0b3IudG9ET01Ob2RlKHNsYXRlRWRpdG9yLCBibG9ja05vZGUpKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5mdW5jdGlvbiBnZXRDaGlsZE5vZGVzKHNsYXRlRWRpdG9yLCBzbmFwc2hvdCkge1xuICBpZiAoIXNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgcmFuZ2UgPSB0b1NsYXRlUmFuZ2Uoc25hcHNob3QpO1xuICBpZiAoIXJhbmdlKVxuICAgIHJldHVybiBbXTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoc2xhdGVFZGl0b3IsIHtcbiAgICAgIGF0OiByYW5nZSxcbiAgICAgIG1vZGU6IFwibG93ZXN0XCIsXG4gICAgICBtYXRjaDogKG4pID0+ICFFZGl0b3IuaXNFZGl0b3IobilcbiAgICB9KSkubWFwKChbY2hpbGROb2RlXSkgPT4gRE9NRWRpdG9yLnRvRE9NTm9kZShzbGF0ZUVkaXRvciwgY2hpbGROb2RlKSk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0RHJhZ0dob3N0KHtcbiAgc2VuZEJhY2ssXG4gIGV2ZW50LFxuICBnaG9zdFxufSkge1xuICBldmVudC5vcmlnaW5FdmVudC5kYXRhVHJhbnNmZXIuc2V0RHJhZ0ltYWdlKGdob3N0LmVsZW1lbnQsIGdob3N0LngsIGdob3N0LnkpLCBzZW5kQmFjayh7XG4gICAgdHlwZTogXCJzZXQgZHJhZyBnaG9zdFwiLFxuICAgIGdob3N0OiBnaG9zdC5lbGVtZW50XG4gIH0pO1xufVxuY29uc3QgYWRkQW5ub3RhdGlvbk9uQ29sbGFwc2VkU2VsZWN0aW9uID0gZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJhbm5vdGF0aW9uLmFkZFwiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdFxuICB9KSA9PiB7XG4gICAgaWYgKCFpc1NlbGVjdGlvbkNvbGxhcHNlZCQxKHNuYXBzaG90KSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBjYXJldFdvcmRTZWxlY3Rpb24gPSBnZXRDYXJldFdvcmRTZWxlY3Rpb24oc25hcHNob3QpO1xuICAgIHJldHVybiAhY2FyZXRXb3JkU2VsZWN0aW9uIHx8ICFpc1NlbGVjdGlvbkV4cGFuZGVkKHtcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgc2VsZWN0aW9uOiBjYXJldFdvcmRTZWxlY3Rpb25cbiAgICAgIH1cbiAgICB9KSA/ICExIDoge1xuICAgICAgY2FyZXRXb3JkU2VsZWN0aW9uXG4gICAgfTtcbiAgfSxcbiAgYWN0aW9uczogWyh7XG4gICAgZXZlbnRcbiAgfSwge1xuICAgIGNhcmV0V29yZFNlbGVjdGlvblxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwic2VsZWN0XCIsXG4gICAgYXQ6IGNhcmV0V29yZFNlbGVjdGlvblxuICB9KSwgcmFpc2Uoe1xuICAgIHR5cGU6IFwiYW5ub3RhdGlvbi5hZGRcIixcbiAgICBhbm5vdGF0aW9uOiBldmVudC5hbm5vdGF0aW9uXG4gIH0pXV1cbn0pLCBwcmV2ZW50T3ZlcmxhcHBpbmdBbm5vdGF0aW9ucyA9IGRlZmluZUJlaGF2aW9yKHtcbiAgLy8gR2l2ZW4gYW4gYGFubm90YXRpb24uYWRkYCBldmVudFxuICBvbjogXCJhbm5vdGF0aW9uLmFkZFwiLFxuICAvLyBXaGVuIHRoZSBhbm5vdGF0aW9uIGlzIGFjdGl2ZSBpbiB0aGUgc2VsZWN0aW9uXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IGlzQWN0aXZlQW5ub3RhdGlvbihldmVudC5hbm5vdGF0aW9uLm5hbWUsIHtcbiAgICBtb2RlOiBcInBhcnRpYWxcIlxuICB9KShzbmFwc2hvdCksXG4gIC8vIFRoZW4gdGhlIGV4aXN0aW5nIGFubm90YXRpb24gaXMgcmVtb3ZlZFxuICBhY3Rpb25zOiBbKHtcbiAgICBldmVudFxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwiYW5ub3RhdGlvbi5yZW1vdmVcIixcbiAgICBhbm5vdGF0aW9uOiBldmVudC5hbm5vdGF0aW9uXG4gIH0pLCByYWlzZShldmVudCldXVxufSksIGNvcmVBbm5vdGF0aW9uQmVoYXZpb3JzID0gW2FkZEFubm90YXRpb25PbkNvbGxhcHNlZFNlbGVjdGlvbiwgcHJldmVudE92ZXJsYXBwaW5nQW5ub3RhdGlvbnNdLCBkZWZhdWx0S2V5Ym9hcmRTaG9ydGN1dHMgPSB7XG4gIGFycm93RG93bjogY3JlYXRlS2V5Ym9hcmRTaG9ydGN1dCh7XG4gICAgZGVmYXVsdDogW3tcbiAgICAgIGtleTogXCJBcnJvd0Rvd25cIixcbiAgICAgIGFsdDogITEsXG4gICAgICBjdHJsOiAhMSxcbiAgICAgIG1ldGE6ICExLFxuICAgICAgc2hpZnQ6ICExXG4gICAgfV1cbiAgfSksXG4gIGFycm93VXA6IGNyZWF0ZUtleWJvYXJkU2hvcnRjdXQoe1xuICAgIGRlZmF1bHQ6IFt7XG4gICAgICBrZXk6IFwiQXJyb3dVcFwiLFxuICAgICAgYWx0OiAhMSxcbiAgICAgIGN0cmw6ICExLFxuICAgICAgbWV0YTogITEsXG4gICAgICBzaGlmdDogITFcbiAgICB9XVxuICB9KSxcbiAgYmFja3NwYWNlOiBjcmVhdGVLZXlib2FyZFNob3J0Y3V0KHtcbiAgICBkZWZhdWx0OiBbe1xuICAgICAga2V5OiBcIkJhY2tzcGFjZVwiLFxuICAgICAgYWx0OiAhMSxcbiAgICAgIGN0cmw6ICExLFxuICAgICAgbWV0YTogITEsXG4gICAgICBzaGlmdDogITFcbiAgICB9XVxuICB9KSxcbiAgYnJlYWs6IGNyZWF0ZUtleWJvYXJkU2hvcnRjdXQoe1xuICAgIGRlZmF1bHQ6IFt7XG4gICAgICBrZXk6IFwiRW50ZXJcIixcbiAgICAgIHNoaWZ0OiAhMVxuICAgIH1dXG4gIH0pLFxuICBsaW5lQnJlYWs6IGNyZWF0ZUtleWJvYXJkU2hvcnRjdXQoe1xuICAgIGRlZmF1bHQ6IFt7XG4gICAgICBrZXk6IFwiRW50ZXJcIixcbiAgICAgIHNoaWZ0OiAhMFxuICAgIH1dXG4gIH0pLFxuICBkZWNvcmF0b3JzOiB7XG4gICAgc3Ryb25nOiBib2xkLFxuICAgIGVtOiBpdGFsaWMsXG4gICAgdW5kZXJsaW5lLFxuICAgIGNvZGVcbiAgfSxcbiAgZGVsZXRlOiBjcmVhdGVLZXlib2FyZFNob3J0Y3V0KHtcbiAgICBkZWZhdWx0OiBbe1xuICAgICAga2V5OiBcIkRlbGV0ZVwiLFxuICAgICAgYWx0OiAhMSxcbiAgICAgIGN0cmw6ICExLFxuICAgICAgbWV0YTogITEsXG4gICAgICBzaGlmdDogITFcbiAgICB9XVxuICB9KSxcbiAgaGlzdG9yeToge1xuICAgIHVuZG8sXG4gICAgcmVkb1xuICB9LFxuICB0YWI6IGNyZWF0ZUtleWJvYXJkU2hvcnRjdXQoe1xuICAgIGRlZmF1bHQ6IFt7XG4gICAgICBrZXk6IFwiVGFiXCIsXG4gICAgICBhbHQ6ICExLFxuICAgICAgY3RybDogITEsXG4gICAgICBtZXRhOiAhMSxcbiAgICAgIHNoaWZ0OiAhMVxuICAgIH1dXG4gIH0pLFxuICBzaGlmdFRhYjogY3JlYXRlS2V5Ym9hcmRTaG9ydGN1dCh7XG4gICAgZGVmYXVsdDogW3tcbiAgICAgIGtleTogXCJUYWJcIixcbiAgICAgIGFsdDogITEsXG4gICAgICBjdHJsOiAhMSxcbiAgICAgIG1ldGE6ICExLFxuICAgICAgc2hpZnQ6ICEwXG4gICAgfV1cbiAgfSlcbn0sIGFycm93RG93bk9uTG9uZWx5QmxvY2tPYmplY3QgPSBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImtleWJvYXJkLmtleWRvd25cIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4ge1xuICAgIGlmICghZGVmYXVsdEtleWJvYXJkU2hvcnRjdXRzLmFycm93RG93bi5ndWFyZChldmVudC5vcmlnaW5FdmVudCkgfHwgIWlzU2VsZWN0aW9uQ29sbGFwc2VkJDEoc25hcHNob3QpKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IGZvY3VzQmxvY2tPYmplY3QgPSBnZXRGb2N1c0Jsb2NrT2JqZWN0KHNuYXBzaG90KSwgbmV4dEJsb2NrID0gZ2V0TmV4dEJsb2NrKHNuYXBzaG90KTtcbiAgICByZXR1cm4gZm9jdXNCbG9ja09iamVjdCAmJiAhbmV4dEJsb2NrO1xuICB9LFxuICBhY3Rpb25zOiBbKHtcbiAgICBzbmFwc2hvdFxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwiaW5zZXJ0LmJsb2NrXCIsXG4gICAgYmxvY2s6IHtcbiAgICAgIF90eXBlOiBzbmFwc2hvdC5jb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lXG4gICAgfSxcbiAgICBwbGFjZW1lbnQ6IFwiYWZ0ZXJcIlxuICB9KV1dXG59KSwgYXJyb3dVcE9uTG9uZWx5QmxvY2tPYmplY3QgPSBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImtleWJvYXJkLmtleWRvd25cIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4ge1xuICAgIGlmICghZGVmYXVsdEtleWJvYXJkU2hvcnRjdXRzLmFycm93VXAuZ3VhcmQoZXZlbnQub3JpZ2luRXZlbnQpIHx8ICFpc1NlbGVjdGlvbkNvbGxhcHNlZCQxKHNuYXBzaG90KSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBmb2N1c0Jsb2NrT2JqZWN0ID0gZ2V0Rm9jdXNCbG9ja09iamVjdChzbmFwc2hvdCksIHByZXZpb3VzQmxvY2sgPSBnZXRQcmV2aW91c0Jsb2NrKHNuYXBzaG90KTtcbiAgICByZXR1cm4gZm9jdXNCbG9ja09iamVjdCAmJiAhcHJldmlvdXNCbG9jaztcbiAgfSxcbiAgYWN0aW9uczogWyh7XG4gICAgc25hcHNob3RcbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcImluc2VydC5ibG9ja1wiLFxuICAgIGJsb2NrOiB7XG4gICAgICBfdHlwZTogc25hcHNob3QuY29udGV4dC5zY2hlbWEuYmxvY2submFtZVxuICAgIH0sXG4gICAgcGxhY2VtZW50OiBcImJlZm9yZVwiXG4gIH0pXV1cbn0pLCBicmVha2luZ0Jsb2NrT2JqZWN0ID0gZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJpbnNlcnQuYnJlYWtcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3RcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGZvY3VzQmxvY2tPYmplY3QgPSBnZXRGb2N1c0Jsb2NrT2JqZWN0KHNuYXBzaG90KTtcbiAgICByZXR1cm4gaXNTZWxlY3Rpb25Db2xsYXBzZWQkMShzbmFwc2hvdCkgJiYgZm9jdXNCbG9ja09iamVjdCAhPT0gdm9pZCAwO1xuICB9LFxuICBhY3Rpb25zOiBbKHtcbiAgICBzbmFwc2hvdFxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwiaW5zZXJ0LmJsb2NrXCIsXG4gICAgYmxvY2s6IHtcbiAgICAgIF90eXBlOiBzbmFwc2hvdC5jb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lXG4gICAgfSxcbiAgICBwbGFjZW1lbnQ6IFwiYWZ0ZXJcIlxuICB9KV1dXG59KSwgY2xpY2tpbmdBYm92ZUxvbmVseUJsb2NrT2JqZWN0ID0gZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJtb3VzZS5jbGlja1wiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9KSA9PiB7XG4gICAgaWYgKHNuYXBzaG90LmNvbnRleHQucmVhZE9ubHkgfHwgc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24gJiYgIWlzU2VsZWN0aW9uQ29sbGFwc2VkJDEoc25hcHNob3QpKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IGZvY3VzQmxvY2tPYmplY3QgPSBnZXRGb2N1c0Jsb2NrT2JqZWN0KHtcbiAgICAgIC4uLnNuYXBzaG90LFxuICAgICAgY29udGV4dDoge1xuICAgICAgICAuLi5zbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICBzZWxlY3Rpb246IGV2ZW50LnBvc2l0aW9uLnNlbGVjdGlvblxuICAgICAgfVxuICAgIH0pLCBwcmV2aW91c0Jsb2NrID0gZ2V0UHJldmlvdXNCbG9jayh7XG4gICAgICAuLi5zbmFwc2hvdCxcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgc2VsZWN0aW9uOiBldmVudC5wb3NpdGlvbi5zZWxlY3Rpb25cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZXZlbnQucG9zaXRpb24uaXNFZGl0b3IgJiYgZXZlbnQucG9zaXRpb24uYmxvY2sgPT09IFwic3RhcnRcIiAmJiBmb2N1c0Jsb2NrT2JqZWN0ICYmICFwcmV2aW91c0Jsb2NrO1xuICB9LFxuICBhY3Rpb25zOiBbKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwic2VsZWN0XCIsXG4gICAgYXQ6IGV2ZW50LnBvc2l0aW9uLnNlbGVjdGlvblxuICB9KSwgcmFpc2Uoe1xuICAgIHR5cGU6IFwiaW5zZXJ0LmJsb2NrXCIsXG4gICAgYmxvY2s6IHtcbiAgICAgIF90eXBlOiBzbmFwc2hvdC5jb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lXG4gICAgfSxcbiAgICBwbGFjZW1lbnQ6IFwiYmVmb3JlXCIsXG4gICAgc2VsZWN0OiBcInN0YXJ0XCJcbiAgfSldXVxufSksIGNsaWNraW5nQmVsb3dMb25lbHlCbG9ja09iamVjdCA9IGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwibW91c2UuY2xpY2tcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4ge1xuICAgIGlmIChzbmFwc2hvdC5jb250ZXh0LnJlYWRPbmx5IHx8IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uICYmICFpc1NlbGVjdGlvbkNvbGxhcHNlZCQxKHNuYXBzaG90KSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBmb2N1c0Jsb2NrT2JqZWN0ID0gZ2V0Rm9jdXNCbG9ja09iamVjdCh7XG4gICAgICAuLi5zbmFwc2hvdCxcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgc2VsZWN0aW9uOiBldmVudC5wb3NpdGlvbi5zZWxlY3Rpb25cbiAgICAgIH1cbiAgICB9KSwgbmV4dEJsb2NrID0gZ2V0TmV4dEJsb2NrKHtcbiAgICAgIC4uLnNuYXBzaG90LFxuICAgICAgY29udGV4dDoge1xuICAgICAgICAuLi5zbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICBzZWxlY3Rpb246IGV2ZW50LnBvc2l0aW9uLnNlbGVjdGlvblxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBldmVudC5wb3NpdGlvbi5pc0VkaXRvciAmJiBldmVudC5wb3NpdGlvbi5ibG9jayA9PT0gXCJlbmRcIiAmJiBmb2N1c0Jsb2NrT2JqZWN0ICYmICFuZXh0QmxvY2s7XG4gIH0sXG4gIGFjdGlvbnM6IFsoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJzZWxlY3RcIixcbiAgICBhdDogZXZlbnQucG9zaXRpb24uc2VsZWN0aW9uXG4gIH0pLCByYWlzZSh7XG4gICAgdHlwZTogXCJpbnNlcnQuYmxvY2tcIixcbiAgICBibG9jazoge1xuICAgICAgX3R5cGU6IHNuYXBzaG90LmNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWVcbiAgICB9LFxuICAgIHBsYWNlbWVudDogXCJhZnRlclwiLFxuICAgIHNlbGVjdDogXCJzdGFydFwiXG4gIH0pXV1cbn0pLCBkZWxldGluZ0VtcHR5VGV4dEJsb2NrQWZ0ZXJCbG9ja09iamVjdCA9IGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwiZGVsZXRlLmJhY2t3YXJkXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90XG4gIH0pID0+IHtcbiAgICBjb25zdCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHNuYXBzaG90KSwgc2VsZWN0aW9uQ29sbGFwc2VkID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQkMShzbmFwc2hvdCksIHByZXZpb3VzQmxvY2sgPSBnZXRQcmV2aW91c0Jsb2NrKHNuYXBzaG90KTtcbiAgICByZXR1cm4gIWZvY3VzVGV4dEJsb2NrIHx8ICFzZWxlY3Rpb25Db2xsYXBzZWQgfHwgIXByZXZpb3VzQmxvY2sgPyAhMSA6IGlzRW1wdHlUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgZm9jdXNUZXh0QmxvY2subm9kZSkgJiYgIWlzVGV4dEJsb2NrKHNuYXBzaG90LmNvbnRleHQsIHByZXZpb3VzQmxvY2subm9kZSkgPyB7XG4gICAgICBmb2N1c1RleHRCbG9jayxcbiAgICAgIHByZXZpb3VzQmxvY2tcbiAgICB9IDogITE7XG4gIH0sXG4gIGFjdGlvbnM6IFsoXywge1xuICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgIHByZXZpb3VzQmxvY2tcbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcImRlbGV0ZS5ibG9ja1wiLFxuICAgIGF0OiBmb2N1c1RleHRCbG9jay5wYXRoXG4gIH0pLCByYWlzZSh7XG4gICAgdHlwZTogXCJzZWxlY3RcIixcbiAgICBhdDoge1xuICAgICAgYW5jaG9yOiB7XG4gICAgICAgIHBhdGg6IHByZXZpb3VzQmxvY2sucGF0aCxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9LFxuICAgICAgZm9jdXM6IHtcbiAgICAgICAgcGF0aDogcHJldmlvdXNCbG9jay5wYXRoLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH1cbiAgICB9XG4gIH0pXV1cbn0pLCBkZWxldGluZ0VtcHR5VGV4dEJsb2NrQmVmb3JlQmxvY2tPYmplY3QgPSBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImRlbGV0ZS5mb3J3YXJkXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90XG4gIH0pID0+IHtcbiAgICBjb25zdCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHNuYXBzaG90KSwgc2VsZWN0aW9uQ29sbGFwc2VkID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQkMShzbmFwc2hvdCksIG5leHRCbG9jayA9IGdldE5leHRCbG9jayhzbmFwc2hvdCk7XG4gICAgcmV0dXJuICFmb2N1c1RleHRCbG9jayB8fCAhc2VsZWN0aW9uQ29sbGFwc2VkIHx8ICFuZXh0QmxvY2sgPyAhMSA6IGlzRW1wdHlUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgZm9jdXNUZXh0QmxvY2subm9kZSkgJiYgIWlzVGV4dEJsb2NrKHNuYXBzaG90LmNvbnRleHQsIG5leHRCbG9jay5ub2RlKSA/IHtcbiAgICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgICAgbmV4dEJsb2NrXG4gICAgfSA6ICExO1xuICB9LFxuICBhY3Rpb25zOiBbKF8sIHtcbiAgICBmb2N1c1RleHRCbG9jayxcbiAgICBuZXh0QmxvY2tcbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcImRlbGV0ZS5ibG9ja1wiLFxuICAgIGF0OiBmb2N1c1RleHRCbG9jay5wYXRoXG4gIH0pLCByYWlzZSh7XG4gICAgdHlwZTogXCJzZWxlY3RcIixcbiAgICBhdDoge1xuICAgICAgYW5jaG9yOiB7XG4gICAgICAgIHBhdGg6IG5leHRCbG9jay5wYXRoLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0sXG4gICAgICBmb2N1czoge1xuICAgICAgICBwYXRoOiBuZXh0QmxvY2sucGF0aCxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9XG4gICAgfVxuICB9KV1dXG59KSwgY29yZUJsb2NrT2JqZWN0QmVoYXZpb3JzID0ge1xuICBhcnJvd0Rvd25PbkxvbmVseUJsb2NrT2JqZWN0LFxuICBhcnJvd1VwT25Mb25lbHlCbG9ja09iamVjdCxcbiAgYnJlYWtpbmdCbG9ja09iamVjdCxcbiAgY2xpY2tpbmdBYm92ZUxvbmVseUJsb2NrT2JqZWN0LFxuICBjbGlja2luZ0JlbG93TG9uZWx5QmxvY2tPYmplY3QsXG4gIGRlbGV0aW5nRW1wdHlUZXh0QmxvY2tBZnRlckJsb2NrT2JqZWN0LFxuICBkZWxldGluZ0VtcHR5VGV4dEJsb2NrQmVmb3JlQmxvY2tPYmplY3Rcbn0sIGNvcmVEZWNvcmF0b3JCZWhhdmlvcnMgPSB7XG4gIHN0cm9uZ1Nob3J0Y3V0OiBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwia2V5Ym9hcmQua2V5ZG93blwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgc25hcHNob3QsXG4gICAgICBldmVudFxuICAgIH0pID0+IGRlZmF1bHRLZXlib2FyZFNob3J0Y3V0cy5kZWNvcmF0b3JzLnN0cm9uZy5ndWFyZChldmVudC5vcmlnaW5FdmVudCkgJiYgc25hcHNob3QuY29udGV4dC5zY2hlbWEuZGVjb3JhdG9ycy5zb21lKChkZWNvcmF0b3IpID0+IGRlY29yYXRvci5uYW1lID09PSBcInN0cm9uZ1wiKSxcbiAgICBhY3Rpb25zOiBbKCkgPT4gW3JhaXNlKHtcbiAgICAgIHR5cGU6IFwiZGVjb3JhdG9yLnRvZ2dsZVwiLFxuICAgICAgZGVjb3JhdG9yOiBcInN0cm9uZ1wiXG4gICAgfSldXVxuICB9KSxcbiAgZW1TaG9ydGN1dDogZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImtleWJvYXJkLmtleWRvd25cIixcbiAgICBndWFyZDogKHtcbiAgICAgIHNuYXBzaG90LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiBkZWZhdWx0S2V5Ym9hcmRTaG9ydGN1dHMuZGVjb3JhdG9ycy5lbS5ndWFyZChldmVudC5vcmlnaW5FdmVudCkgJiYgc25hcHNob3QuY29udGV4dC5zY2hlbWEuZGVjb3JhdG9ycy5zb21lKChkZWNvcmF0b3IpID0+IGRlY29yYXRvci5uYW1lID09PSBcImVtXCIpLFxuICAgIGFjdGlvbnM6IFsoKSA9PiBbcmFpc2Uoe1xuICAgICAgdHlwZTogXCJkZWNvcmF0b3IudG9nZ2xlXCIsXG4gICAgICBkZWNvcmF0b3I6IFwiZW1cIlxuICAgIH0pXV1cbiAgfSksXG4gIHVuZGVybGluZVNob3J0Y3V0OiBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwia2V5Ym9hcmQua2V5ZG93blwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgc25hcHNob3QsXG4gICAgICBldmVudFxuICAgIH0pID0+IGRlZmF1bHRLZXlib2FyZFNob3J0Y3V0cy5kZWNvcmF0b3JzLnVuZGVybGluZS5ndWFyZChldmVudC5vcmlnaW5FdmVudCkgJiYgc25hcHNob3QuY29udGV4dC5zY2hlbWEuZGVjb3JhdG9ycy5zb21lKChkZWNvcmF0b3IpID0+IGRlY29yYXRvci5uYW1lID09PSBcInVuZGVybGluZVwiKSxcbiAgICBhY3Rpb25zOiBbKCkgPT4gW3JhaXNlKHtcbiAgICAgIHR5cGU6IFwiZGVjb3JhdG9yLnRvZ2dsZVwiLFxuICAgICAgZGVjb3JhdG9yOiBcInVuZGVybGluZVwiXG4gICAgfSldXVxuICB9KSxcbiAgY29kZVNob3J0Y3V0OiBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwia2V5Ym9hcmQua2V5ZG93blwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgc25hcHNob3QsXG4gICAgICBldmVudFxuICAgIH0pID0+IGRlZmF1bHRLZXlib2FyZFNob3J0Y3V0cy5kZWNvcmF0b3JzLmNvZGUuZ3VhcmQoZXZlbnQub3JpZ2luRXZlbnQpICYmIHNuYXBzaG90LmNvbnRleHQuc2NoZW1hLmRlY29yYXRvcnMuc29tZSgoZGVjb3JhdG9yKSA9PiBkZWNvcmF0b3IubmFtZSA9PT0gXCJjb2RlXCIpLFxuICAgIGFjdGlvbnM6IFsoKSA9PiBbcmFpc2Uoe1xuICAgICAgdHlwZTogXCJkZWNvcmF0b3IudG9nZ2xlXCIsXG4gICAgICBkZWNvcmF0b3I6IFwiY29kZVwiXG4gICAgfSldXVxuICB9KVxufTtcbmZ1bmN0aW9uIGdldENvbXBvdW5kQ2xpZW50UmVjdChub2Rlcykge1xuICBpZiAobm9kZXMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBuZXcgRE9NUmVjdCgwLCAwLCAwLCAwKTtcbiAgY29uc3QgZWxlbWVudHMgPSBub2Rlcy5maWx0ZXIoKG5vZGUpID0+IG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50KSwgZmlyc3RSZWN0ID0gZWxlbWVudHMuYXQoMCk/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBpZiAoIWZpcnN0UmVjdClcbiAgICByZXR1cm4gbmV3IERPTVJlY3QoMCwgMCwgMCwgMCk7XG4gIGxldCBsZWZ0ID0gZmlyc3RSZWN0LmxlZnQsIHRvcCA9IGZpcnN0UmVjdC50b3AsIHJpZ2h0ID0gZmlyc3RSZWN0LnJpZ2h0LCBib3R0b20gPSBmaXJzdFJlY3QuYm90dG9tO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcmVjdCA9IGVsZW1lbnRzW2ldLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxlZnQgPSBNYXRoLm1pbihsZWZ0LCByZWN0LmxlZnQpLCB0b3AgPSBNYXRoLm1pbih0b3AsIHJlY3QudG9wKSwgcmlnaHQgPSBNYXRoLm1heChyaWdodCwgcmVjdC5yaWdodCksIGJvdHRvbSA9IE1hdGgubWF4KGJvdHRvbSwgcmVjdC5ib3R0b20pO1xuICB9XG4gIHJldHVybiBuZXcgRE9NUmVjdChsZWZ0LCB0b3AsIHJpZ2h0IC0gbGVmdCwgYm90dG9tIC0gdG9wKTtcbn1cbmNvbnN0IGNvcmVEbmRCZWhhdmlvcnMgPSBbXG4gIC8qKlxuICAgKiBDb3JlIEJlaGF2aW9yIHRoYXQ6XG4gICAqIDEuIENhbGN1bGF0ZXMgYW5kIHNlbGVjdHMgYSBcImRyYWcgc2VsZWN0aW9uXCJcbiAgICogMi4gQ29uc3RydWN0cyBhbmQgc2V0cyBhIGRyYWcgZ2hvc3QgZWxlbWVudFxuICAgKiAzLiBGb3J3YXJkcyB0aGUgZHJhZ3N0YXJ0IGV2ZW50XG4gICAqL1xuICBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwiZHJhZy5kcmFnc3RhcnRcIixcbiAgICBndWFyZDogKHtcbiAgICAgIHNuYXBzaG90LFxuICAgICAgZG9tLFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBkcmFnU2VsZWN0aW9uID0gZ2V0RHJhZ1NlbGVjdGlvbih7XG4gICAgICAgIHNuYXBzaG90LFxuICAgICAgICBldmVudFNlbGVjdGlvbjogZXZlbnQucG9zaXRpb24uc2VsZWN0aW9uXG4gICAgICB9KSwgc2VsZWN0aW5nRW50aXJlQmxvY2tzID0gaXNTZWxlY3RpbmdFbnRpcmVCbG9ja3Moe1xuICAgICAgICAuLi5zbmFwc2hvdCxcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgICAgc2VsZWN0aW9uOiBkcmFnU2VsZWN0aW9uXG4gICAgICAgIH1cbiAgICAgIH0pLCBkcmFnZ2VkRG9tTm9kZXMgPSB7XG4gICAgICAgIGJsb2NrTm9kZXM6IGRvbS5nZXRCbG9ja05vZGVzKHtcbiAgICAgICAgICAuLi5zbmFwc2hvdCxcbiAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAuLi5zbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICAgICAgc2VsZWN0aW9uOiBkcmFnU2VsZWN0aW9uXG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgY2hpbGROb2RlczogZG9tLmdldENoaWxkTm9kZXMoe1xuICAgICAgICAgIC4uLnNuYXBzaG90LFxuICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgICAgICBzZWxlY3Rpb246IGRyYWdTZWxlY3Rpb25cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZHJhZ1NlbGVjdGlvbixcbiAgICAgICAgZHJhZ2dlZERvbU5vZGVzLFxuICAgICAgICBzZWxlY3RpbmdFbnRpcmVCbG9ja3NcbiAgICAgIH07XG4gICAgfSxcbiAgICBhY3Rpb25zOiBbKHtcbiAgICAgIGRvbSxcbiAgICAgIGV2ZW50XG4gICAgfSwge1xuICAgICAgZHJhZ1NlbGVjdGlvbixcbiAgICAgIGRyYWdnZWREb21Ob2RlcyxcbiAgICAgIHNlbGVjdGluZ0VudGlyZUJsb2Nrc1xuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IGRyYWdHaG9zdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBpZiAoc2VsZWN0aW5nRW50aXJlQmxvY2tzKSB7XG4gICAgICAgIGNvbnN0IGNsb25lZEJsb2NrTm9kZXMgPSBkcmFnZ2VkRG9tTm9kZXMuYmxvY2tOb2Rlcy5tYXAoKG5vZGUpID0+IG5vZGUuY2xvbmVOb2RlKCEwKSk7XG4gICAgICAgIGZvciAoY29uc3QgYmxvY2sgb2YgY2xvbmVkQmxvY2tOb2RlcylcbiAgICAgICAgICBibG9jayBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIChibG9jay5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIiksIGRyYWdHaG9zdC5hcHBlbmRDaGlsZChibG9jayk7XG4gICAgICAgIGNvbnN0IGN1c3RvbUdob3N0ID0gZHJhZ0dob3N0LnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1wdC1kcmFnLWdob3N0LWVsZW1lbnRdXCIpO1xuICAgICAgICBpZiAoY3VzdG9tR2hvc3QgJiYgZHJhZ0dob3N0LnJlcGxhY2VDaGlsZHJlbihjdXN0b21HaG9zdCksIGRyYWdHaG9zdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWRyYWdnZWRcIiwgXCJcIiksIGRyYWdHaG9zdC5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIiwgZHJhZ0dob3N0LnN0eWxlLmxlZnQgPSBcIi05OTk5OXB4XCIsIGRyYWdHaG9zdC5zdHlsZS5ib3hTaXppbmcgPSBcImJvcmRlci1ib3hcIiwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkcmFnR2hvc3QpLCBjdXN0b21HaG9zdCkge1xuICAgICAgICAgIGNvbnN0IGN1c3RvbUdob3N0UmVjdCA9IGN1c3RvbUdob3N0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB4ID0gZXZlbnQub3JpZ2luRXZlbnQuY2xpZW50WCAtIGN1c3RvbUdob3N0UmVjdC5sZWZ0LCB5ID0gZXZlbnQub3JpZ2luRXZlbnQuY2xpZW50WSAtIGN1c3RvbUdob3N0UmVjdC50b3A7XG4gICAgICAgICAgcmV0dXJuIGRyYWdHaG9zdC5zdHlsZS53aWR0aCA9IGAke2N1c3RvbUdob3N0UmVjdC53aWR0aH1weGAsIGRyYWdHaG9zdC5zdHlsZS5oZWlnaHQgPSBgJHtjdXN0b21HaG9zdFJlY3QuaGVpZ2h0fXB4YCwgW3JhaXNlKHtcbiAgICAgICAgICAgIHR5cGU6IFwic2VsZWN0XCIsXG4gICAgICAgICAgICBhdDogZHJhZ1NlbGVjdGlvblxuICAgICAgICAgIH0pLCBlZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgZG9tLnNldERyYWdHaG9zdCh7XG4gICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICBnaG9zdDoge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGRyYWdHaG9zdCxcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSksIGZvcndhcmQoZXZlbnQpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBibG9ja3NEb21SZWN0ID0gZ2V0Q29tcG91bmRDbGllbnRSZWN0KGRyYWdnZWREb21Ob2Rlcy5ibG9ja05vZGVzKSwgeCA9IGV2ZW50Lm9yaWdpbkV2ZW50LmNsaWVudFggLSBibG9ja3NEb21SZWN0LmxlZnQsIHkgPSBldmVudC5vcmlnaW5FdmVudC5jbGllbnRZIC0gYmxvY2tzRG9tUmVjdC50b3A7XG4gICAgICAgICAgcmV0dXJuIGRyYWdHaG9zdC5zdHlsZS53aWR0aCA9IGAke2Jsb2Nrc0RvbVJlY3Qud2lkdGh9cHhgLCBkcmFnR2hvc3Quc3R5bGUuaGVpZ2h0ID0gYCR7YmxvY2tzRG9tUmVjdC5oZWlnaHR9cHhgLCBbcmFpc2Uoe1xuICAgICAgICAgICAgdHlwZTogXCJzZWxlY3RcIixcbiAgICAgICAgICAgIGF0OiBkcmFnU2VsZWN0aW9uXG4gICAgICAgICAgfSksIGVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBkb20uc2V0RHJhZ0dob3N0KHtcbiAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgIGdob3N0OiB7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogZHJhZ0dob3N0LFxuICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgeVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KSwgZm9yd2FyZChldmVudCldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjbG9uZWRDaGlsZE5vZGVzID0gZHJhZ2dlZERvbU5vZGVzLmNoaWxkTm9kZXMubWFwKChub2RlKSA9PiBub2RlLmNsb25lTm9kZSghMCkpO1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNsb25lZENoaWxkTm9kZXMpXG4gICAgICAgICAgZHJhZ0dob3N0LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgZHJhZ0dob3N0LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiLCBkcmFnR2hvc3Quc3R5bGUubGVmdCA9IFwiLTk5OTk5cHhcIiwgZHJhZ0dob3N0LnN0eWxlLmJveFNpemluZyA9IFwiYm9yZGVyLWJveFwiLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRyYWdHaG9zdCk7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuRG9tUmVjdCA9IGdldENvbXBvdW5kQ2xpZW50UmVjdChkcmFnZ2VkRG9tTm9kZXMuY2hpbGROb2RlcyksIHggPSBldmVudC5vcmlnaW5FdmVudC5jbGllbnRYIC0gY2hpbGRyZW5Eb21SZWN0LmxlZnQsIHkgPSBldmVudC5vcmlnaW5FdmVudC5jbGllbnRZIC0gY2hpbGRyZW5Eb21SZWN0LnRvcDtcbiAgICAgICAgcmV0dXJuIGRyYWdHaG9zdC5zdHlsZS53aWR0aCA9IGAke2NoaWxkcmVuRG9tUmVjdC53aWR0aH1weGAsIGRyYWdHaG9zdC5zdHlsZS5oZWlnaHQgPSBgJHtjaGlsZHJlbkRvbVJlY3QuaGVpZ2h0fXB4YCwgW3JhaXNlKHtcbiAgICAgICAgICB0eXBlOiBcInNlbGVjdFwiLFxuICAgICAgICAgIGF0OiBkcmFnU2VsZWN0aW9uXG4gICAgICAgIH0pLCBlZmZlY3QoKCkgPT4ge1xuICAgICAgICAgIGRvbS5zZXREcmFnR2hvc3Qoe1xuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICBnaG9zdDoge1xuICAgICAgICAgICAgICBlbGVtZW50OiBkcmFnR2hvc3QsXG4gICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgIHlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSksIGZvcndhcmQoZXZlbnQpXTtcbiAgICAgIH1cbiAgICB9XVxuICB9KSxcbiAgLyoqXG4gICAqIFdoZW4gZHJhZ2dpbmcgb3ZlciB0aGUgZHJhZyBvcmlnaW4sIHdlIGRvbid0IHdhbnQgdG8gc2hvdyB0aGUgY2FyZXQgaW4gdGhlXG4gICAqIHRleHQuXG4gICAqL1xuICBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwiZHJhZy5kcmFnb3ZlclwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgc25hcHNob3QsXG4gICAgICBldmVudFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IGRyYWdPcmlnaW4gPSBldmVudC5kcmFnT3JpZ2luO1xuICAgICAgcmV0dXJuIGRyYWdPcmlnaW4gPyBpc092ZXJsYXBwaW5nU2VsZWN0aW9uKGV2ZW50LnBvc2l0aW9uLnNlbGVjdGlvbikoe1xuICAgICAgICAuLi5zbmFwc2hvdCxcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgICAgc2VsZWN0aW9uOiBkcmFnT3JpZ2luLnNlbGVjdGlvblxuICAgICAgICB9XG4gICAgICB9KSA6ICExO1xuICAgIH0sXG4gICAgYWN0aW9uczogW11cbiAgfSksXG4gIC8qKlxuICAgKiBJZiB0aGUgZHJvcCBwb3NpdGlvbiBvdmVybGFwcyB0aGUgZHJhZyBvcmlnaW4sIHRoZW4gdGhlIGV2ZW50IHNob3VsZCBiZVxuICAgKiBjYW5jZWxsZWQuXG4gICAqL1xuICBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwiZHJhZy5kcm9wXCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBzbmFwc2hvdCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgZHJhZ09yaWdpbiA9IGV2ZW50LmRyYWdPcmlnaW4sIGRyb3BQb3NpdGlvbiA9IGV2ZW50LnBvc2l0aW9uLnNlbGVjdGlvbjtcbiAgICAgIHJldHVybiBkcmFnT3JpZ2luID8gaXNPdmVybGFwcGluZ1NlbGVjdGlvbihkcm9wUG9zaXRpb24pKHtcbiAgICAgICAgLi4uc25hcHNob3QsXG4gICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAuLi5zbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICAgIHNlbGVjdGlvbjogZHJhZ09yaWdpbi5zZWxlY3Rpb25cbiAgICAgICAgfVxuICAgICAgfSkgOiAhMTtcbiAgICB9LFxuICAgIGFjdGlvbnM6IFtdXG4gIH0pLFxuICAvKipcbiAgICogSWYgd2UgZHJvcCBhbmQgaGF2ZSBhY2Nlc3MgdG8gYSBkcmFnIG9yaWdpbiwgdGhlbiB3ZSBjYW4gZGVzZXJpYWxpemVcbiAgICogd2l0aG91dCBjcmVhdGluZyBhIG5ldyBzZWxlY3Rpb24uXG4gICAqL1xuICBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwiZHJhZy5kcm9wXCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBldmVudFxuICAgIH0pID0+IGV2ZW50LmRyYWdPcmlnaW4gIT09IHZvaWQgMCxcbiAgICBhY3Rpb25zOiBbKHtcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4gW3JhaXNlKHtcbiAgICAgIHR5cGU6IFwiZGVzZXJpYWxpemVcIixcbiAgICAgIG9yaWdpbkV2ZW50OiBldmVudFxuICAgIH0pXV1cbiAgfSksXG4gIC8qKlxuICAgKiBPdGhlcndpc2UsIHdlIHNob3VsZCB0byBjcmVhdGUgYSBuZXcgc2VsZWN0aW9uLlxuICAgKi9cbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImRyYWcuZHJvcFwiLFxuICAgIGFjdGlvbnM6IFsoe1xuICAgICAgZXZlbnRcbiAgICB9KSA9PiBbcmFpc2Uoe1xuICAgICAgdHlwZTogXCJzZWxlY3RcIixcbiAgICAgIGF0OiBldmVudC5wb3NpdGlvbi5zZWxlY3Rpb25cbiAgICB9KSwgcmFpc2Uoe1xuICAgICAgdHlwZTogXCJkZXNlcmlhbGl6ZVwiLFxuICAgICAgb3JpZ2luRXZlbnQ6IGV2ZW50XG4gICAgfSldXVxuICB9KSxcbiAgLyoqXG4gICAqIENvcmUgQmVoYXZpb3IgdGhhdCB1c2VzIHRoZSBkcmFnIG9yaWdpbiB0byBtaW1pYyBhIG1vdmUgb3BlcmF0aW9uIGR1cmluZ1xuICAgKiBpbnRlcm5hbCBkcmFnZ2luZy5cbiAgICovXG4gIGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJkZXNlcmlhbGl6YXRpb24uc3VjY2Vzc1wiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgc25hcHNob3QsXG4gICAgICBldmVudFxuICAgIH0pID0+IHtcbiAgICAgIGlmIChldmVudC5vcmlnaW5FdmVudC50eXBlICE9PSBcImRyYWcuZHJvcFwiIHx8IGV2ZW50Lm9yaWdpbkV2ZW50LmRyYWdPcmlnaW4gPT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgZHJhZ09yaWdpbiA9IGV2ZW50Lm9yaWdpbkV2ZW50LmRyYWdPcmlnaW4sIGRyYWdTZWxlY3Rpb24gPSBnZXREcmFnU2VsZWN0aW9uKHtcbiAgICAgICAgZXZlbnRTZWxlY3Rpb246IGRyYWdPcmlnaW4uc2VsZWN0aW9uLFxuICAgICAgICBzbmFwc2hvdFxuICAgICAgfSksIGRyb3BQb3NpdGlvbiA9IGV2ZW50Lm9yaWdpbkV2ZW50LnBvc2l0aW9uLnNlbGVjdGlvbiwgZHJvcHBpbmdPbkRyYWdPcmlnaW4gPSBkcmFnT3JpZ2luID8gaXNPdmVybGFwcGluZ1NlbGVjdGlvbihkcm9wUG9zaXRpb24pKHtcbiAgICAgICAgLi4uc25hcHNob3QsXG4gICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAuLi5zbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICAgIHNlbGVjdGlvbjogZHJhZ1NlbGVjdGlvblxuICAgICAgICB9XG4gICAgICB9KSA6ICExLCBkcmFnZ2luZ0VudGlyZUJsb2NrcyA9IGlzU2VsZWN0aW5nRW50aXJlQmxvY2tzKHtcbiAgICAgICAgLi4uc25hcHNob3QsXG4gICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAuLi5zbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICAgIHNlbGVjdGlvbjogZHJhZ1NlbGVjdGlvblxuICAgICAgICB9XG4gICAgICB9KSwgZHJhZ2dlZEJsb2NrcyA9IGdldFNlbGVjdGVkQmxvY2tzKHtcbiAgICAgICAgLi4uc25hcHNob3QsXG4gICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAuLi5zbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICAgIHNlbGVjdGlvbjogZHJhZ1NlbGVjdGlvblxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkcm9wcGluZ09uRHJhZ09yaWdpbiA/ICExIDoge1xuICAgICAgICBkcm9wUG9zaXRpb24sXG4gICAgICAgIGRyYWdnaW5nRW50aXJlQmxvY2tzLFxuICAgICAgICBkcmFnZ2VkQmxvY2tzLFxuICAgICAgICBkcmFnT3JpZ2luLFxuICAgICAgICBvcmlnaW5FdmVudDogZXZlbnQub3JpZ2luRXZlbnRcbiAgICAgIH07XG4gICAgfSxcbiAgICBhY3Rpb25zOiBbKHtcbiAgICAgIGV2ZW50XG4gICAgfSwge1xuICAgICAgZHJhZ2dpbmdFbnRpcmVCbG9ja3MsXG4gICAgICBkcmFnZ2VkQmxvY2tzLFxuICAgICAgZHJhZ09yaWdpbixcbiAgICAgIGRyb3BQb3NpdGlvbixcbiAgICAgIG9yaWdpbkV2ZW50XG4gICAgfSkgPT4gW3JhaXNlKHtcbiAgICAgIHR5cGU6IFwic2VsZWN0XCIsXG4gICAgICBhdDogZHJvcFBvc2l0aW9uXG4gICAgfSksIC4uLmRyYWdnaW5nRW50aXJlQmxvY2tzID8gZHJhZ2dlZEJsb2Nrcy5tYXAoKGJsb2NrKSA9PiByYWlzZSh7XG4gICAgICB0eXBlOiBcImRlbGV0ZS5ibG9ja1wiLFxuICAgICAgYXQ6IGJsb2NrLnBhdGhcbiAgICB9KSkgOiBbcmFpc2Uoe1xuICAgICAgdHlwZTogXCJkZWxldGVcIixcbiAgICAgIGF0OiBkcmFnT3JpZ2luLnNlbGVjdGlvblxuICAgIH0pXSwgcmFpc2Uoe1xuICAgICAgdHlwZTogXCJpbnNlcnQuYmxvY2tzXCIsXG4gICAgICBibG9ja3M6IGV2ZW50LmRhdGEsXG4gICAgICBwbGFjZW1lbnQ6IGRyYWdnaW5nRW50aXJlQmxvY2tzID8gb3JpZ2luRXZlbnQucG9zaXRpb24uYmxvY2sgPT09IFwic3RhcnRcIiA/IFwiYmVmb3JlXCIgOiBvcmlnaW5FdmVudC5wb3NpdGlvbi5ibG9jayA9PT0gXCJlbmRcIiA/IFwiYWZ0ZXJcIiA6IFwiYXV0b1wiIDogXCJhdXRvXCJcbiAgICB9KV1dXG4gIH0pXG5dLCBjb3JlSW5zZXJ0QmVoYXZpb3JzID0gW2RlZmluZUJlaGF2aW9yKHtcbiAgb246IFwiaW5zZXJ0LnRleHRcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3RcbiAgfSkgPT4ge1xuICAgIGlmICghZ2V0Rm9jdXNTcGFuJDEoc25hcHNob3QpKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IG1hcmtTdGF0ZSA9IGdldE1hcmtTdGF0ZShzbmFwc2hvdCksIGFjdGl2ZURlY29yYXRvcnMgPSBnZXRBY3RpdmVEZWNvcmF0b3JzKHNuYXBzaG90KSwgYWN0aXZlQW5ub3RhdGlvbnMgPSBnZXRBY3RpdmVBbm5vdGF0aW9uc01hcmtzKHNuYXBzaG90KTtcbiAgICBpZiAobWFya1N0YXRlICYmIG1hcmtTdGF0ZS5zdGF0ZSA9PT0gXCJ1bmNoYW5nZWRcIikge1xuICAgICAgY29uc3QgbWFya1N0YXRlRGVjb3JhdG9ycyA9IChtYXJrU3RhdGUubWFya3MgPz8gW10pLmZpbHRlcigobWFyaykgPT4gc25hcHNob3QuY29udGV4dC5zY2hlbWEuZGVjb3JhdG9ycy5tYXAoKGRlY29yYXRvcikgPT4gZGVjb3JhdG9yLm5hbWUpLmluY2x1ZGVzKG1hcmspKTtcbiAgICAgIGlmIChtYXJrU3RhdGVEZWNvcmF0b3JzLmxlbmd0aCA9PT0gYWN0aXZlRGVjb3JhdG9ycy5sZW5ndGggJiYgbWFya1N0YXRlRGVjb3JhdG9ycy5ldmVyeSgobWFyaykgPT4gYWN0aXZlRGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGl2ZURlY29yYXRvcnMsXG4gICAgICBhY3RpdmVBbm5vdGF0aW9uc1xuICAgIH07XG4gIH0sXG4gIGFjdGlvbnM6IFsoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0sIHtcbiAgICBhY3RpdmVEZWNvcmF0b3JzLFxuICAgIGFjdGl2ZUFubm90YXRpb25zXG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJpbnNlcnQuY2hpbGRcIixcbiAgICBjaGlsZDoge1xuICAgICAgX3R5cGU6IHNuYXBzaG90LmNvbnRleHQuc2NoZW1hLnNwYW4ubmFtZSxcbiAgICAgIHRleHQ6IGV2ZW50LnRleHQsXG4gICAgICBtYXJrczogWy4uLmFjdGl2ZURlY29yYXRvcnMsIC4uLmFjdGl2ZUFubm90YXRpb25zXVxuICAgIH1cbiAgfSldXVxufSldLCBicmVha2luZ0F0VGhlRW5kT2ZUZXh0QmxvY2sgPSBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImluc2VydC5icmVha1wiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdFxuICB9KSA9PiB7XG4gICAgY29uc3QgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayhzbmFwc2hvdCksIHNlbGVjdGlvbkNvbGxhcHNlZCA9IGlzU2VsZWN0aW9uQ29sbGFwc2VkJDEoc25hcHNob3QpO1xuICAgIGlmICghc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24gfHwgIWZvY3VzVGV4dEJsb2NrIHx8ICFzZWxlY3Rpb25Db2xsYXBzZWQpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgYXRUaGVFbmRPZkJsb2NrID0gaXNBdFRoZUVuZE9mQmxvY2soZm9jdXNUZXh0QmxvY2spKHNuYXBzaG90KSwgZm9jdXNMaXN0SXRlbSA9IGZvY3VzVGV4dEJsb2NrLm5vZGUubGlzdEl0ZW0sIGZvY3VzTGV2ZWwgPSBmb2N1c1RleHRCbG9jay5ub2RlLmxldmVsO1xuICAgIHJldHVybiBhdFRoZUVuZE9mQmxvY2sgPyB7XG4gICAgICBmb2N1c0xpc3RJdGVtLFxuICAgICAgZm9jdXNMZXZlbFxuICAgIH0gOiAhMTtcbiAgfSxcbiAgYWN0aW9uczogWyh7XG4gICAgc25hcHNob3RcbiAgfSwge1xuICAgIGZvY3VzTGlzdEl0ZW0sXG4gICAgZm9jdXNMZXZlbFxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwiaW5zZXJ0LmJsb2NrXCIsXG4gICAgYmxvY2s6IHtcbiAgICAgIF90eXBlOiBzbmFwc2hvdC5jb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIF90eXBlOiBzbmFwc2hvdC5jb250ZXh0LnNjaGVtYS5zcGFuLm5hbWUsXG4gICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgIG1hcmtzOiBbXVxuICAgICAgfV0sXG4gICAgICBtYXJrRGVmczogW10sXG4gICAgICBsaXN0SXRlbTogZm9jdXNMaXN0SXRlbSxcbiAgICAgIGxldmVsOiBmb2N1c0xldmVsLFxuICAgICAgc3R5bGU6IHNuYXBzaG90LmNvbnRleHQuc2NoZW1hLnN0eWxlc1swXT8ubmFtZVxuICAgIH0sXG4gICAgcGxhY2VtZW50OiBcImFmdGVyXCJcbiAgfSldXVxufSksIGJyZWFraW5nQXRUaGVTdGFydE9mVGV4dEJsb2NrID0gZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJpbnNlcnQuYnJlYWtcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3RcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGZvY3VzVGV4dEJsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soc25hcHNob3QpLCBzZWxlY3Rpb25Db2xsYXBzZWQgPSBpc1NlbGVjdGlvbkNvbGxhcHNlZCQxKHNuYXBzaG90KTtcbiAgICBpZiAoIXNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uIHx8ICFmb2N1c1RleHRCbG9jayB8fCAhc2VsZWN0aW9uQ29sbGFwc2VkKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IGZvY3VzU3BhbiA9IGdldEZvY3VzU3BhbiQxKHNuYXBzaG90KSwgZm9jdXNEZWNvcmF0b3JzID0gZm9jdXNTcGFuPy5ub2RlLm1hcmtzPy5maWx0ZXIoKG1hcmspID0+IHNuYXBzaG90LmNvbnRleHQuc2NoZW1hLmRlY29yYXRvcnMuc29tZSgoZGVjb3JhdG9yKSA9PiBkZWNvcmF0b3IubmFtZSA9PT0gbWFyaykgPz8gW10pLCBmb2N1c0Fubm90YXRpb25zID0gZm9jdXNTcGFuPy5ub2RlLm1hcmtzPy5maWx0ZXIoKG1hcmspID0+ICFzbmFwc2hvdC5jb250ZXh0LnNjaGVtYS5kZWNvcmF0b3JzLnNvbWUoKGRlY29yYXRvcikgPT4gZGVjb3JhdG9yLm5hbWUgPT09IG1hcmspKSA/PyBbXSwgZm9jdXNMaXN0SXRlbSA9IGZvY3VzVGV4dEJsb2NrLm5vZGUubGlzdEl0ZW0sIGZvY3VzTGV2ZWwgPSBmb2N1c1RleHRCbG9jay5ub2RlLmxldmVsO1xuICAgIHJldHVybiBpc0F0VGhlU3RhcnRPZkJsb2NrKGZvY3VzVGV4dEJsb2NrKShzbmFwc2hvdCkgPyB7XG4gICAgICBmb2N1c0Fubm90YXRpb25zLFxuICAgICAgZm9jdXNEZWNvcmF0b3JzLFxuICAgICAgZm9jdXNMaXN0SXRlbSxcbiAgICAgIGZvY3VzTGV2ZWxcbiAgICB9IDogITE7XG4gIH0sXG4gIGFjdGlvbnM6IFsoe1xuICAgIHNuYXBzaG90XG4gIH0sIHtcbiAgICBmb2N1c0Fubm90YXRpb25zLFxuICAgIGZvY3VzRGVjb3JhdG9ycyxcbiAgICBmb2N1c0xpc3RJdGVtLFxuICAgIGZvY3VzTGV2ZWxcbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcImluc2VydC5ibG9ja1wiLFxuICAgIGJsb2NrOiB7XG4gICAgICBfdHlwZTogc25hcHNob3QuY29udGV4dC5zY2hlbWEuYmxvY2submFtZSxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICBfdHlwZTogc25hcHNob3QuY29udGV4dC5zY2hlbWEuc3Bhbi5uYW1lLFxuICAgICAgICBtYXJrczogZm9jdXNBbm5vdGF0aW9ucy5sZW5ndGggPT09IDAgPyBmb2N1c0RlY29yYXRvcnMgOiBbXSxcbiAgICAgICAgdGV4dDogXCJcIlxuICAgICAgfV0sXG4gICAgICBsaXN0SXRlbTogZm9jdXNMaXN0SXRlbSxcbiAgICAgIGxldmVsOiBmb2N1c0xldmVsLFxuICAgICAgc3R5bGU6IHNuYXBzaG90LmNvbnRleHQuc2NoZW1hLnN0eWxlc1swXT8ubmFtZVxuICAgIH0sXG4gICAgcGxhY2VtZW50OiBcImJlZm9yZVwiLFxuICAgIHNlbGVjdDogXCJub25lXCJcbiAgfSldXVxufSksIGJyZWFraW5nRW50aXJlRG9jdW1lbnQgPSBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImluc2VydC5icmVha1wiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdFxuICB9KSA9PiB7XG4gICAgaWYgKCFzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbiB8fCAhaXNTZWxlY3Rpb25FeHBhbmRlZChzbmFwc2hvdCkpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgZmlyc3RCbG9jayA9IGdldEZpcnN0QmxvY2skMShzbmFwc2hvdCksIGxhc3RCbG9jayA9IGdldExhc3RCbG9jayQxKHNuYXBzaG90KTtcbiAgICBpZiAoIWZpcnN0QmxvY2sgfHwgIWxhc3RCbG9jaylcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBmaXJzdEJsb2NrU3RhcnRQb2ludCA9IGdldEJsb2NrU3RhcnRQb2ludCh7XG4gICAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgICAgYmxvY2s6IGZpcnN0QmxvY2tcbiAgICB9KSwgc2VsZWN0aW9uU3RhcnRQb2ludCA9IGdldFNlbGVjdGlvblN0YXJ0UG9pbnQoc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24pLCBsYXN0QmxvY2tFbmRQb2ludCA9IGdldEJsb2NrRW5kUG9pbnQoe1xuICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgIGJsb2NrOiBsYXN0QmxvY2tcbiAgICB9KSwgc2VsZWN0aW9uRW5kUG9pbnQgPSBnZXRTZWxlY3Rpb25FbmRQb2ludChzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbik7XG4gICAgcmV0dXJuIGlzRXF1YWxTZWxlY3Rpb25Qb2ludHMoZmlyc3RCbG9ja1N0YXJ0UG9pbnQsIHNlbGVjdGlvblN0YXJ0UG9pbnQpICYmIGlzRXF1YWxTZWxlY3Rpb25Qb2ludHMobGFzdEJsb2NrRW5kUG9pbnQsIHNlbGVjdGlvbkVuZFBvaW50KSA/IHtcbiAgICAgIHNlbGVjdGlvbjogc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb25cbiAgICB9IDogITE7XG4gIH0sXG4gIGFjdGlvbnM6IFsoXywge1xuICAgIHNlbGVjdGlvblxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwiZGVsZXRlXCIsXG4gICAgYXQ6IHNlbGVjdGlvblxuICB9KV1dXG59KSwgYnJlYWtpbmdFbnRpcmVCbG9ja3MgPSBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImluc2VydC5icmVha1wiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdFxuICB9KSA9PiB7XG4gICAgaWYgKCFzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbiB8fCAhaXNTZWxlY3Rpb25FeHBhbmRlZChzbmFwc2hvdCkpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3Qgc2VsZWN0ZWRCbG9ja3MgPSBnZXRTZWxlY3RlZEJsb2NrcyhzbmFwc2hvdCksIHNlbGVjdGlvblN0YXJ0QmxvY2sgPSBnZXRTZWxlY3Rpb25TdGFydEJsb2NrJDEoc25hcHNob3QpLCBzZWxlY3Rpb25FbmRCbG9jayA9IGdldFNlbGVjdGlvbkVuZEJsb2NrJDEoc25hcHNob3QpO1xuICAgIGlmICghc2VsZWN0aW9uU3RhcnRCbG9jayB8fCAhc2VsZWN0aW9uRW5kQmxvY2spXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3Qgc3RhcnRCbG9ja1N0YXJ0UG9pbnQgPSBnZXRCbG9ja1N0YXJ0UG9pbnQoe1xuICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgIGJsb2NrOiBzZWxlY3Rpb25TdGFydEJsb2NrXG4gICAgfSksIHNlbGVjdGlvblN0YXJ0UG9pbnQgPSBnZXRTZWxlY3Rpb25TdGFydFBvaW50KHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uKSwgZW5kQmxvY2tFbmRQb2ludCA9IGdldEJsb2NrRW5kUG9pbnQoe1xuICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgIGJsb2NrOiBzZWxlY3Rpb25FbmRCbG9ja1xuICAgIH0pLCBzZWxlY3Rpb25FbmRQb2ludCA9IGdldFNlbGVjdGlvbkVuZFBvaW50KHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uKTtcbiAgICByZXR1cm4gaXNFcXVhbFNlbGVjdGlvblBvaW50cyhzZWxlY3Rpb25TdGFydFBvaW50LCBzdGFydEJsb2NrU3RhcnRQb2ludCkgJiYgaXNFcXVhbFNlbGVjdGlvblBvaW50cyhzZWxlY3Rpb25FbmRQb2ludCwgZW5kQmxvY2tFbmRQb2ludCkgPyB7XG4gICAgICBzZWxlY3RlZEJsb2Nrc1xuICAgIH0gOiAhMTtcbiAgfSxcbiAgYWN0aW9uczogWyh7XG4gICAgc25hcHNob3RcbiAgfSwge1xuICAgIHNlbGVjdGVkQmxvY2tzXG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJpbnNlcnQuYmxvY2tcIixcbiAgICBibG9jazoge1xuICAgICAgX3R5cGU6IHNuYXBzaG90LmNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWUsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgX3R5cGU6IHNuYXBzaG90LmNvbnRleHQuc2NoZW1hLnNwYW4ubmFtZSxcbiAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgbWFya3M6IFtdXG4gICAgICB9XVxuICAgIH0sXG4gICAgcGxhY2VtZW50OiBcImJlZm9yZVwiLFxuICAgIHNlbGVjdDogXCJzdGFydFwiXG4gIH0pLCAuLi5zZWxlY3RlZEJsb2Nrcy5tYXAoKGJsb2NrKSA9PiByYWlzZSh7XG4gICAgdHlwZTogXCJkZWxldGUuYmxvY2tcIixcbiAgICBhdDogYmxvY2sucGF0aFxuICB9KSldXVxufSksIGJyZWFraW5nSW5saW5lT2JqZWN0ID0gZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJpbnNlcnQuYnJlYWtcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3RcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbkNvbGxhcHNlZCA9IGlzU2VsZWN0aW9uQ29sbGFwc2VkJDEoc25hcHNob3QpLCBmb2N1c0lubGluZU9iamVjdCA9IGdldEZvY3VzSW5saW5lT2JqZWN0KHNuYXBzaG90KTtcbiAgICByZXR1cm4gc2VsZWN0aW9uQ29sbGFwc2VkICYmIGZvY3VzSW5saW5lT2JqZWN0O1xuICB9LFxuICBhY3Rpb25zOiBbKCkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcIm1vdmUuZm9yd2FyZFwiLFxuICAgIGRpc3RhbmNlOiAxXG4gIH0pLCByYWlzZSh7XG4gICAgdHlwZTogXCJzcGxpdFwiXG4gIH0pXV1cbn0pLCBjb3JlSW5zZXJ0QnJlYWtCZWhhdmlvcnMgPSB7XG4gIGJyZWFraW5nQXRUaGVFbmRPZlRleHRCbG9jayxcbiAgYnJlYWtpbmdBdFRoZVN0YXJ0T2ZUZXh0QmxvY2ssXG4gIGJyZWFraW5nRW50aXJlRG9jdW1lbnQsXG4gIGJyZWFraW5nRW50aXJlQmxvY2tzLFxuICBicmVha2luZ0lubGluZU9iamVjdFxufTtcbmZ1bmN0aW9uIGlzQXRUaGVCZWdpbm5pbmdPZkJsb2NrKHtcbiAgY29udGV4dCxcbiAgYmxvY2tcbn0pIHtcbiAgcmV0dXJuICFpc1RleHRCbG9jayhjb250ZXh0LCBibG9jaykgfHwgIWNvbnRleHQuc2VsZWN0aW9uIHx8ICFpc1NlbGVjdGlvbkNvbGxhcHNlZChjb250ZXh0LnNlbGVjdGlvbikgPyAhMSA6IGdldENoaWxkS2V5RnJvbVNlbGVjdGlvblBvaW50KGNvbnRleHQuc2VsZWN0aW9uLmZvY3VzKSA9PT0gYmxvY2suY2hpbGRyZW5bMF0uX2tleSAmJiBjb250ZXh0LnNlbGVjdGlvbi5mb2N1cy5vZmZzZXQgPT09IDA7XG59XG5jb25zdCBNQVhfTElTVF9MRVZFTCA9IDEwLCBjbGVhckxpc3RPbkJhY2tzcGFjZSA9IGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwiZGVsZXRlLmJhY2t3YXJkXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90XG4gIH0pID0+IHtcbiAgICBjb25zdCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHNuYXBzaG90KTtcbiAgICByZXR1cm4gIWZvY3VzVGV4dEJsb2NrIHx8IGZvY3VzVGV4dEJsb2NrLm5vZGUubGV2ZWwgIT09IDEgfHwgIWlzQXRUaGVCZWdpbm5pbmdPZkJsb2NrKHtcbiAgICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgICBibG9jazogZm9jdXNUZXh0QmxvY2subm9kZVxuICAgIH0pID8gITEgOiB7XG4gICAgICBmb2N1c1RleHRCbG9ja1xuICAgIH07XG4gIH0sXG4gIGFjdGlvbnM6IFsoXywge1xuICAgIGZvY3VzVGV4dEJsb2NrXG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJibG9jay51bnNldFwiLFxuICAgIHByb3BzOiBbXCJsaXN0SXRlbVwiLCBcImxldmVsXCJdLFxuICAgIGF0OiBmb2N1c1RleHRCbG9jay5wYXRoXG4gIH0pXV1cbn0pLCB1bmluZGVudExpc3RPbkJhY2tzcGFjZSA9IGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwiZGVsZXRlLmJhY2t3YXJkXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90XG4gIH0pID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb25Db2xsYXBzZWQgPSBpc1NlbGVjdGlvbkNvbGxhcHNlZCQxKHNuYXBzaG90KSwgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayhzbmFwc2hvdCksIGZvY3VzU3BhbiA9IGdldEZvY3VzU3BhbiQxKHNuYXBzaG90KTtcbiAgICByZXR1cm4gIXNlbGVjdGlvbkNvbGxhcHNlZCB8fCAhZm9jdXNUZXh0QmxvY2sgfHwgIWZvY3VzU3BhbiA/ICExIDogZm9jdXNUZXh0QmxvY2subm9kZS5jaGlsZHJlblswXS5fa2V5ID09PSBmb2N1c1NwYW4ubm9kZS5fa2V5ICYmIHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uPy5mb2N1cy5vZmZzZXQgPT09IDAgJiYgZm9jdXNUZXh0QmxvY2subm9kZS5sZXZlbCAhPT0gdm9pZCAwICYmIGZvY3VzVGV4dEJsb2NrLm5vZGUubGV2ZWwgPiAxID8ge1xuICAgICAgZm9jdXNUZXh0QmxvY2ssXG4gICAgICBsZXZlbDogZm9jdXNUZXh0QmxvY2subm9kZS5sZXZlbCAtIDFcbiAgICB9IDogITE7XG4gIH0sXG4gIGFjdGlvbnM6IFsoXywge1xuICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgIGxldmVsXG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJibG9jay5zZXRcIixcbiAgICBwcm9wczoge1xuICAgICAgbGV2ZWxcbiAgICB9LFxuICAgIGF0OiBmb2N1c1RleHRCbG9jay5wYXRoXG4gIH0pXV1cbn0pLCBtZXJnZVRleHRJbnRvTGlzdE9uRGVsZXRlID0gZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJkZWxldGUuZm9yd2FyZFwiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdFxuICB9KSA9PiB7XG4gICAgY29uc3QgZm9jdXNMaXN0QmxvY2sgPSBnZXRGb2N1c0xpc3RCbG9jayhzbmFwc2hvdCksIG5leHRCbG9jayA9IGdldE5leHRCbG9jayhzbmFwc2hvdCk7XG4gICAgcmV0dXJuICFmb2N1c0xpc3RCbG9jayB8fCAhbmV4dEJsb2NrIHx8ICFpc1RleHRCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBuZXh0QmxvY2subm9kZSkgfHwgIWlzRW1wdHlUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgZm9jdXNMaXN0QmxvY2subm9kZSkgPyAhMSA6IHtcbiAgICAgIGZvY3VzTGlzdEJsb2NrLFxuICAgICAgbmV4dEJsb2NrXG4gICAgfTtcbiAgfSxcbiAgYWN0aW9uczogWyhfLCB7XG4gICAgbmV4dEJsb2NrXG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJpbnNlcnQuYmxvY2tcIixcbiAgICBibG9jazogbmV4dEJsb2NrLm5vZGUsXG4gICAgcGxhY2VtZW50OiBcImF1dG9cIixcbiAgICBzZWxlY3Q6IFwic3RhcnRcIlxuICB9KSwgcmFpc2Uoe1xuICAgIHR5cGU6IFwiZGVsZXRlLmJsb2NrXCIsXG4gICAgYXQ6IG5leHRCbG9jay5wYXRoXG4gIH0pXV1cbn0pLCBtZXJnZVRleHRJbnRvTGlzdE9uQmFja3NwYWNlID0gZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJkZWxldGUuYmFja3dhcmRcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3RcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGZvY3VzVGV4dEJsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soc25hcHNob3QpLCBwcmV2aW91c0Jsb2NrID0gZ2V0UHJldmlvdXNCbG9jayhzbmFwc2hvdCk7XG4gICAgaWYgKCFmb2N1c1RleHRCbG9jayB8fCAhcHJldmlvdXNCbG9jayB8fCAhaXNBdFRoZUJlZ2lubmluZ09mQmxvY2soe1xuICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgIGJsb2NrOiBmb2N1c1RleHRCbG9jay5ub2RlXG4gICAgfSkgfHwgIWlzTGlzdEJsb2NrKHNuYXBzaG90LmNvbnRleHQsIHByZXZpb3VzQmxvY2subm9kZSkgfHwgIWlzRW1wdHlUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgcHJldmlvdXNCbG9jay5ub2RlKSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBwcmV2aW91c0Jsb2NrRW5kUG9pbnQgPSBnZXRCbG9ja0VuZFBvaW50KHtcbiAgICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgICBibG9jazogcHJldmlvdXNCbG9ja1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBmb2N1c1RleHRCbG9jayxcbiAgICAgIHByZXZpb3VzQmxvY2tFbmRQb2ludFxuICAgIH07XG4gIH0sXG4gIGFjdGlvbnM6IFsoXywge1xuICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgIHByZXZpb3VzQmxvY2tFbmRQb2ludFxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwic2VsZWN0XCIsXG4gICAgYXQ6IHtcbiAgICAgIGFuY2hvcjogcHJldmlvdXNCbG9ja0VuZFBvaW50LFxuICAgICAgZm9jdXM6IHByZXZpb3VzQmxvY2tFbmRQb2ludFxuICAgIH1cbiAgfSksIHJhaXNlKHtcbiAgICB0eXBlOiBcImluc2VydC5ibG9ja1wiLFxuICAgIGJsb2NrOiBmb2N1c1RleHRCbG9jay5ub2RlLFxuICAgIHBsYWNlbWVudDogXCJhdXRvXCIsXG4gICAgc2VsZWN0OiBcInN0YXJ0XCJcbiAgfSksIHJhaXNlKHtcbiAgICB0eXBlOiBcImRlbGV0ZS5ibG9ja1wiLFxuICAgIGF0OiBmb2N1c1RleHRCbG9jay5wYXRoXG4gIH0pXV1cbn0pLCBkZWxldGluZ0xpc3RGcm9tU3RhcnQgPSBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImRlbGV0ZVwiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9KSA9PiB7XG4gICAgY29uc3QgYmxvY2tzVG9EZWxldGUgPSBnZXRTZWxlY3RlZEJsb2Nrcyh7XG4gICAgICAuLi5zbmFwc2hvdCxcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgc2VsZWN0aW9uOiBldmVudC5hdFxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChibG9ja3NUb0RlbGV0ZS5sZW5ndGggPCAyKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IHN0YXJ0QmxvY2sgPSBibG9ja3NUb0RlbGV0ZS5hdCgwKT8ubm9kZSwgbWlkZGxlQmxvY2tzID0gYmxvY2tzVG9EZWxldGUuc2xpY2UoMSwgLTEpLCBlbmRCbG9jayA9IGJsb2Nrc1RvRGVsZXRlLmF0KC0xKT8ubm9kZTtcbiAgICBpZiAoIWlzTGlzdEJsb2NrKHNuYXBzaG90LmNvbnRleHQsIHN0YXJ0QmxvY2spIHx8ICFpc0xpc3RCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBlbmRCbG9jaykpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgZGVsZXRlU3RhcnRQb2ludCA9IGdldFNlbGVjdGlvblN0YXJ0UG9pbnQkMSh7XG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgIHNlbGVjdGlvbjogZXZlbnQuYXRcbiAgICAgIH1cbiAgICB9KSwgZGVsZXRlRW5kUG9pbnQgPSBnZXRTZWxlY3Rpb25FbmRQb2ludCQxKHtcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgc2VsZWN0aW9uOiBldmVudC5hdFxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghZGVsZXRlU3RhcnRQb2ludCB8fCAhZGVsZXRlRW5kUG9pbnQpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3Qgc3RhcnRCbG9ja1N0YXJ0UG9pbnQgPSBnZXRCbG9ja1N0YXJ0UG9pbnQoe1xuICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgIGJsb2NrOiB7XG4gICAgICAgIG5vZGU6IHN0YXJ0QmxvY2ssXG4gICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgX2tleTogc3RhcnRCbG9jay5fa2V5XG4gICAgICAgIH1dXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFpc0VxdWFsU2VsZWN0aW9uUG9pbnRzKGRlbGV0ZVN0YXJ0UG9pbnQsIHN0YXJ0QmxvY2tTdGFydFBvaW50KSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBzdGFydEJsb2NrRW5kUG9pbnQgPSBnZXRCbG9ja0VuZFBvaW50KHtcbiAgICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgICBibG9jazoge1xuICAgICAgICBub2RlOiBzdGFydEJsb2NrLFxuICAgICAgICBwYXRoOiBbe1xuICAgICAgICAgIF9rZXk6IHN0YXJ0QmxvY2suX2tleVxuICAgICAgICB9XVxuICAgICAgfVxuICAgIH0pLCBlbmRCbG9ja0VuZFBvaW50ID0gZ2V0QmxvY2tFbmRQb2ludCh7XG4gICAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgICAgYmxvY2s6IHtcbiAgICAgICAgbm9kZTogZW5kQmxvY2ssXG4gICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgX2tleTogZW5kQmxvY2suX2tleVxuICAgICAgICB9XVxuICAgICAgfVxuICAgIH0pLCBzbGljZWRFbmRCbG9jayA9IHNsaWNlVGV4dEJsb2NrKHtcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgc2NoZW1hOiBzbmFwc2hvdC5jb250ZXh0LnNjaGVtYSxcbiAgICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgICAgYW5jaG9yOiBkZWxldGVFbmRQb2ludCxcbiAgICAgICAgICBmb2N1czogZW5kQmxvY2tFbmRQb2ludFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYmxvY2s6IGVuZEJsb2NrXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0QmxvY2tTdGFydFBvaW50LFxuICAgICAgc3RhcnRCbG9ja0VuZFBvaW50LFxuICAgICAgbWlkZGxlQmxvY2tzLFxuICAgICAgZW5kQmxvY2ssXG4gICAgICBzbGljZWRFbmRCbG9ja1xuICAgIH07XG4gIH0sXG4gIGFjdGlvbnM6IFsoXywge1xuICAgIHN0YXJ0QmxvY2tTdGFydFBvaW50LFxuICAgIHN0YXJ0QmxvY2tFbmRQb2ludCxcbiAgICBtaWRkbGVCbG9ja3MsXG4gICAgZW5kQmxvY2ssXG4gICAgc2xpY2VkRW5kQmxvY2tcbiAgfSkgPT4gW1xuICAgIC8vIEFsbCBibG9jayBpbiBiZXR3ZWVuIGNhbiBzYWZlbHkgYmUgZGVsZXRlZC5cbiAgICAuLi5taWRkbGVCbG9ja3MubWFwKChibG9jaykgPT4gcmFpc2Uoe1xuICAgICAgdHlwZTogXCJkZWxldGUuYmxvY2tcIixcbiAgICAgIGF0OiBibG9jay5wYXRoXG4gICAgfSkpLFxuICAgIC8vIFRoZSBsYXN0IGJsb2NrIGlzIGRlbGV0ZWQgYXMgd2VsbC5cbiAgICByYWlzZSh7XG4gICAgICB0eXBlOiBcImRlbGV0ZS5ibG9ja1wiLFxuICAgICAgYXQ6IFt7XG4gICAgICAgIF9rZXk6IGVuZEJsb2NrLl9rZXlcbiAgICAgIH1dXG4gICAgfSksXG4gICAgLy8gQnV0IGluIGNhc2UgdGhlIGRlbGV0ZSBvcGVyYXRpb24gZGlkbid0IHJlYWNoIGFsbCB0aGUgd2F5IHRvIHRoZSBlbmRcbiAgICAvLyBvZiBpdCwgd2UgZmlyc3QgcGxhY2UgdGhlIGNhcmV0IGF0IHRoZSBlbmQgb2YgdGhlIHN0YXJ0IGJsb2NrLi4uXG4gICAgcmFpc2Uoe1xuICAgICAgdHlwZTogXCJzZWxlY3RcIixcbiAgICAgIGF0OiB7XG4gICAgICAgIGFuY2hvcjogc3RhcnRCbG9ja0VuZFBvaW50LFxuICAgICAgICBmb2N1czogc3RhcnRCbG9ja0VuZFBvaW50XG4gICAgICB9XG4gICAgfSksXG4gICAgLy8gLi4uYW5kIGluc2VydCB0aGUgcmVzdCBvZiB0aGUgZW5kIGJsb2NrIGF0IHRoZSBlbmQgb2YgaXQuXG4gICAgcmFpc2Uoe1xuICAgICAgdHlwZTogXCJpbnNlcnQuYmxvY2tcIixcbiAgICAgIGJsb2NrOiBzbGljZWRFbmRCbG9jayxcbiAgICAgIHBsYWNlbWVudDogXCJhdXRvXCIsXG4gICAgICBzZWxlY3Q6IFwibm9uZVwiXG4gICAgfSksXG4gICAgLy8gQW5kIGZpbmFsbHksIHdlIGRlbGV0ZSB0aGUgb3JpZ2luYWwgdGV4dCBvZiB0aGUgc3RhcnQgYmxvY2suXG4gICAgcmFpc2Uoe1xuICAgICAgdHlwZTogXCJkZWxldGVcIixcbiAgICAgIGF0OiB7XG4gICAgICAgIGFuY2hvcjogc3RhcnRCbG9ja1N0YXJ0UG9pbnQsXG4gICAgICAgIGZvY3VzOiBzdGFydEJsb2NrRW5kUG9pbnRcbiAgICAgIH1cbiAgICB9KVxuICBdXVxufSksIGNsZWFyTGlzdE9uRW50ZXIgPSBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImluc2VydC5icmVha1wiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdFxuICB9KSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uQ29sbGFwc2VkID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQkMShzbmFwc2hvdCksIGZvY3VzTGlzdEJsb2NrID0gZ2V0Rm9jdXNMaXN0QmxvY2soc25hcHNob3QpO1xuICAgIHJldHVybiAhc2VsZWN0aW9uQ29sbGFwc2VkIHx8ICFmb2N1c0xpc3RCbG9jayB8fCAhaXNFbXB0eVRleHRCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBmb2N1c0xpc3RCbG9jay5ub2RlKSA/ICExIDoge1xuICAgICAgZm9jdXNMaXN0QmxvY2tcbiAgICB9O1xuICB9LFxuICBhY3Rpb25zOiBbKF8sIHtcbiAgICBmb2N1c0xpc3RCbG9ja1xuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwiYmxvY2sudW5zZXRcIixcbiAgICBwcm9wczogW1wibGlzdEl0ZW1cIiwgXCJsZXZlbFwiXSxcbiAgICBhdDogZm9jdXNMaXN0QmxvY2sucGF0aFxuICB9KV1dXG59KSwgaW5kZW50TGlzdE9uVGFiID0gZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJrZXlib2FyZC5rZXlkb3duXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IHtcbiAgICBpZiAoIWRlZmF1bHRLZXlib2FyZFNob3J0Y3V0cy50YWIuZ3VhcmQoZXZlbnQub3JpZ2luRXZlbnQpKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IHNlbGVjdGVkQmxvY2tzID0gZ2V0U2VsZWN0ZWRCbG9ja3Moc25hcHNob3QpLCBzZWxlY3RlZExpc3RCbG9ja3MgPSBzZWxlY3RlZEJsb2Nrcy5mbGF0TWFwKChibG9jaykgPT4gaXNMaXN0QmxvY2soc25hcHNob3QuY29udGV4dCwgYmxvY2subm9kZSkgPyBbe1xuICAgICAgbm9kZTogYmxvY2subm9kZSxcbiAgICAgIHBhdGg6IGJsb2NrLnBhdGhcbiAgICB9XSA6IFtdKTtcbiAgICByZXR1cm4gc2VsZWN0ZWRMaXN0QmxvY2tzLmxlbmd0aCA9PT0gc2VsZWN0ZWRCbG9ja3MubGVuZ3RoID8ge1xuICAgICAgc2VsZWN0ZWRMaXN0QmxvY2tzXG4gICAgfSA6ICExO1xuICB9LFxuICBhY3Rpb25zOiBbKF8sIHtcbiAgICBzZWxlY3RlZExpc3RCbG9ja3NcbiAgfSkgPT4gc2VsZWN0ZWRMaXN0QmxvY2tzLm1hcCgoc2VsZWN0ZWRMaXN0QmxvY2spID0+IHJhaXNlKHtcbiAgICB0eXBlOiBcImJsb2NrLnNldFwiLFxuICAgIHByb3BzOiB7XG4gICAgICBsZXZlbDogTWF0aC5taW4oTUFYX0xJU1RfTEVWRUwsIE1hdGgubWF4KDEsIHNlbGVjdGVkTGlzdEJsb2NrLm5vZGUubGV2ZWwgKyAxKSlcbiAgICB9LFxuICAgIGF0OiBzZWxlY3RlZExpc3RCbG9jay5wYXRoXG4gIH0pKV1cbn0pLCB1bmluZGVudExpc3RPblNoaWZ0VGFiID0gZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJrZXlib2FyZC5rZXlkb3duXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IHtcbiAgICBpZiAoIWRlZmF1bHRLZXlib2FyZFNob3J0Y3V0cy5zaGlmdFRhYi5ndWFyZChldmVudC5vcmlnaW5FdmVudCkpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3Qgc2VsZWN0ZWRCbG9ja3MgPSBnZXRTZWxlY3RlZEJsb2NrcyhzbmFwc2hvdCksIHNlbGVjdGVkTGlzdEJsb2NrcyA9IHNlbGVjdGVkQmxvY2tzLmZsYXRNYXAoKGJsb2NrKSA9PiBpc0xpc3RCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBibG9jay5ub2RlKSA/IFt7XG4gICAgICBub2RlOiBibG9jay5ub2RlLFxuICAgICAgcGF0aDogYmxvY2sucGF0aFxuICAgIH1dIDogW10pO1xuICAgIHJldHVybiBzZWxlY3RlZExpc3RCbG9ja3MubGVuZ3RoID09PSBzZWxlY3RlZEJsb2Nrcy5sZW5ndGggPyB7XG4gICAgICBzZWxlY3RlZExpc3RCbG9ja3NcbiAgICB9IDogITE7XG4gIH0sXG4gIGFjdGlvbnM6IFsoXywge1xuICAgIHNlbGVjdGVkTGlzdEJsb2Nrc1xuICB9KSA9PiBzZWxlY3RlZExpc3RCbG9ja3MubWFwKChzZWxlY3RlZExpc3RCbG9jaykgPT4gcmFpc2Uoe1xuICAgIHR5cGU6IFwiYmxvY2suc2V0XCIsXG4gICAgcHJvcHM6IHtcbiAgICAgIGxldmVsOiBNYXRoLm1pbihNQVhfTElTVF9MRVZFTCwgTWF0aC5tYXgoMSwgc2VsZWN0ZWRMaXN0QmxvY2subm9kZS5sZXZlbCAtIDEpKVxuICAgIH0sXG4gICAgYXQ6IHNlbGVjdGVkTGlzdEJsb2NrLnBhdGhcbiAgfSkpXVxufSksIGluaGVyaXRMaXN0TGV2ZWwgPSBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImluc2VydC5ibG9ja3NcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGZvY3VzTGlzdEJsb2NrID0gZ2V0Rm9jdXNMaXN0QmxvY2soc25hcHNob3QpO1xuICAgIGlmICghZm9jdXNMaXN0QmxvY2spXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgZmlyc3RJbnNlcnRlZEJsb2NrID0gZXZlbnQuYmxvY2tzLmF0KDApLCBzZWNvbmRJbnNlcnRlZEJsb2NrID0gZXZlbnQuYmxvY2tzLmF0KDEpLCBpbnNlcnRlZExpc3RCbG9jayA9IGlzTGlzdEJsb2NrKHNuYXBzaG90LmNvbnRleHQsIGZpcnN0SW5zZXJ0ZWRCbG9jaykgPyBmaXJzdEluc2VydGVkQmxvY2sgOiBpc0xpc3RCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBzZWNvbmRJbnNlcnRlZEJsb2NrKSA/IHNlY29uZEluc2VydGVkQmxvY2sgOiB2b2lkIDA7XG4gICAgaWYgKCFpbnNlcnRlZExpc3RCbG9jaylcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBsZXZlbERpZmZlcmVuY2UgPSBmb2N1c0xpc3RCbG9jay5ub2RlLmxldmVsIC0gaW5zZXJ0ZWRMaXN0QmxvY2subGV2ZWw7XG4gICAgcmV0dXJuIGxldmVsRGlmZmVyZW5jZSA9PT0gMCA/ICExIDoge1xuICAgICAgbGV2ZWxEaWZmZXJlbmNlLFxuICAgICAgaW5zZXJ0ZWRMaXN0QmxvY2tcbiAgICB9O1xuICB9LFxuICBhY3Rpb25zOiBbKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9LCB7XG4gICAgbGV2ZWxEaWZmZXJlbmNlLFxuICAgIGluc2VydGVkTGlzdEJsb2NrXG4gIH0pID0+IHtcbiAgICBsZXQgYWRqdXN0TGV2ZWwgPSAhMCwgbGlzdFN0YXJ0QmxvY2tGb3VuZCA9ICExO1xuICAgIHJldHVybiBbcmFpc2Uoe1xuICAgICAgLi4uZXZlbnQsXG4gICAgICBibG9ja3M6IGV2ZW50LmJsb2Nrcy5tYXAoKGJsb2NrKSA9PiAoYmxvY2suX2tleSA9PT0gaW5zZXJ0ZWRMaXN0QmxvY2suX2tleSAmJiAobGlzdFN0YXJ0QmxvY2tGb3VuZCA9ICEwKSwgYWRqdXN0TGV2ZWwgPyBsaXN0U3RhcnRCbG9ja0ZvdW5kICYmIGFkanVzdExldmVsICYmIGlzTGlzdEJsb2NrKHNuYXBzaG90LmNvbnRleHQsIGJsb2NrKSA/IHtcbiAgICAgICAgLi4uYmxvY2ssXG4gICAgICAgIGxldmVsOiBNYXRoLm1pbihNQVhfTElTVF9MRVZFTCwgTWF0aC5tYXgoMSwgYmxvY2subGV2ZWwgKyBsZXZlbERpZmZlcmVuY2UpKVxuICAgICAgfSA6IChsaXN0U3RhcnRCbG9ja0ZvdW5kICYmIChhZGp1c3RMZXZlbCA9ICExKSwgYmxvY2spIDogYmxvY2spKVxuICAgIH0pXTtcbiAgfV1cbn0pLCBpbmhlcml0TGlzdEl0ZW0gPSBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImluc2VydC5ibG9ja3NcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGZvY3VzTGlzdEJsb2NrID0gZ2V0Rm9jdXNMaXN0QmxvY2soc25hcHNob3QpO1xuICAgIGlmICghZm9jdXNMaXN0QmxvY2sgfHwgaXNFbXB0eVRleHRCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBmb2N1c0xpc3RCbG9jay5ub2RlKSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBmaXJzdEluc2VydGVkQmxvY2sgPSBldmVudC5ibG9ja3MuYXQoMCksIHNlY29uZEluc2VydGVkQmxvY2sgPSBldmVudC5ibG9ja3MuYXQoMSksIGluc2VydGVkTGlzdEJsb2NrID0gaXNMaXN0QmxvY2soc25hcHNob3QuY29udGV4dCwgZmlyc3RJbnNlcnRlZEJsb2NrKSA/IGZpcnN0SW5zZXJ0ZWRCbG9jayA6IGlzTGlzdEJsb2NrKHNuYXBzaG90LmNvbnRleHQsIHNlY29uZEluc2VydGVkQmxvY2spID8gc2Vjb25kSW5zZXJ0ZWRCbG9jayA6IHZvaWQgMDtcbiAgICByZXR1cm4gIWluc2VydGVkTGlzdEJsb2NrIHx8IGZvY3VzTGlzdEJsb2NrLm5vZGUubGV2ZWwgIT09IGluc2VydGVkTGlzdEJsb2NrLmxldmVsIHx8IGZvY3VzTGlzdEJsb2NrLm5vZGUubGlzdEl0ZW0gPT09IGluc2VydGVkTGlzdEJsb2NrLmxpc3RJdGVtID8gITEgOiB7XG4gICAgICBsaXN0SXRlbTogZm9jdXNMaXN0QmxvY2subm9kZS5saXN0SXRlbSxcbiAgICAgIGluc2VydGVkTGlzdEJsb2NrXG4gICAgfTtcbiAgfSxcbiAgYWN0aW9uczogWyh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSwge1xuICAgIGxpc3RJdGVtLFxuICAgIGluc2VydGVkTGlzdEJsb2NrXG4gIH0pID0+IHtcbiAgICBsZXQgYWRqdXN0TGlzdEl0ZW0gPSAhMCwgbGlzdFN0YXJ0QmxvY2tGb3VuZCA9ICExO1xuICAgIHJldHVybiBbcmFpc2Uoe1xuICAgICAgLi4uZXZlbnQsXG4gICAgICBibG9ja3M6IGV2ZW50LmJsb2Nrcy5tYXAoKGJsb2NrKSA9PiAoYmxvY2suX2tleSA9PT0gaW5zZXJ0ZWRMaXN0QmxvY2suX2tleSAmJiAobGlzdFN0YXJ0QmxvY2tGb3VuZCA9ICEwKSwgYWRqdXN0TGlzdEl0ZW0gPyBsaXN0U3RhcnRCbG9ja0ZvdW5kICYmIGFkanVzdExpc3RJdGVtICYmIGlzTGlzdEJsb2NrKHNuYXBzaG90LmNvbnRleHQsIGJsb2NrKSA/IHtcbiAgICAgICAgLi4uYmxvY2ssXG4gICAgICAgIGxpc3RJdGVtOiBibG9jay5sZXZlbCA9PT0gaW5zZXJ0ZWRMaXN0QmxvY2subGV2ZWwgPyBsaXN0SXRlbSA6IGJsb2NrLmxpc3RJdGVtXG4gICAgICB9IDogKGxpc3RTdGFydEJsb2NrRm91bmQgJiYgKGFkanVzdExpc3RJdGVtID0gITEpLCBibG9jaykgOiBibG9jaykpXG4gICAgfSldO1xuICB9XVxufSksIGluaGVyaXRMaXN0UHJvcGVydGllcyA9IGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwiaW5zZXJ0LmJsb2NrXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IHtcbiAgICBpZiAoZXZlbnQucGxhY2VtZW50ICE9PSBcImF1dG9cIiB8fCBldmVudC5ibG9jay5fdHlwZSAhPT0gc25hcHNob3QuY29udGV4dC5zY2hlbWEuYmxvY2submFtZSB8fCBldmVudC5ibG9jay5saXN0SXRlbSAhPT0gdm9pZCAwKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IGZvY3VzTGlzdEJsb2NrID0gZ2V0Rm9jdXNMaXN0QmxvY2soc25hcHNob3QpO1xuICAgIHJldHVybiAhZm9jdXNMaXN0QmxvY2sgfHwgIWlzRW1wdHlUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgZm9jdXNMaXN0QmxvY2subm9kZSkgPyAhMSA6IHtcbiAgICAgIGxldmVsOiBmb2N1c0xpc3RCbG9jay5ub2RlLmxldmVsLFxuICAgICAgbGlzdEl0ZW06IGZvY3VzTGlzdEJsb2NrLm5vZGUubGlzdEl0ZW1cbiAgICB9O1xuICB9LFxuICBhY3Rpb25zOiBbKHtcbiAgICBldmVudFxuICB9LCB7XG4gICAgbGV2ZWwsXG4gICAgbGlzdEl0ZW1cbiAgfSkgPT4gW3JhaXNlKHtcbiAgICAuLi5ldmVudCxcbiAgICBibG9jazoge1xuICAgICAgLi4uZXZlbnQuYmxvY2ssXG4gICAgICBsZXZlbCxcbiAgICAgIGxpc3RJdGVtXG4gICAgfVxuICB9KV1dXG59KSwgY29yZUxpc3RCZWhhdmlvcnMgPSB7XG4gIGNsZWFyTGlzdE9uQmFja3NwYWNlLFxuICB1bmluZGVudExpc3RPbkJhY2tzcGFjZSxcbiAgbWVyZ2VUZXh0SW50b0xpc3RPbkRlbGV0ZSxcbiAgbWVyZ2VUZXh0SW50b0xpc3RPbkJhY2tzcGFjZSxcbiAgZGVsZXRpbmdMaXN0RnJvbVN0YXJ0LFxuICBjbGVhckxpc3RPbkVudGVyLFxuICBpbmRlbnRMaXN0T25UYWIsXG4gIHVuaW5kZW50TGlzdE9uU2hpZnRUYWIsXG4gIGluaGVyaXRMaXN0TGV2ZWwsXG4gIGluaGVyaXRMaXN0SXRlbSxcbiAgaW5oZXJpdExpc3RQcm9wZXJ0aWVzXG59LCBjb3JlQmVoYXZpb3JzQ29uZmlnID0gWy4uLmNvcmVBbm5vdGF0aW9uQmVoYXZpb3JzLCBjb3JlRGVjb3JhdG9yQmVoYXZpb3JzLnN0cm9uZ1Nob3J0Y3V0LCBjb3JlRGVjb3JhdG9yQmVoYXZpb3JzLmVtU2hvcnRjdXQsIGNvcmVEZWNvcmF0b3JCZWhhdmlvcnMudW5kZXJsaW5lU2hvcnRjdXQsIGNvcmVEZWNvcmF0b3JCZWhhdmlvcnMuY29kZVNob3J0Y3V0LCAuLi5jb3JlRG5kQmVoYXZpb3JzLCBjb3JlQmxvY2tPYmplY3RCZWhhdmlvcnMuY2xpY2tpbmdBYm92ZUxvbmVseUJsb2NrT2JqZWN0LCBjb3JlQmxvY2tPYmplY3RCZWhhdmlvcnMuY2xpY2tpbmdCZWxvd0xvbmVseUJsb2NrT2JqZWN0LCBjb3JlQmxvY2tPYmplY3RCZWhhdmlvcnMuYXJyb3dEb3duT25Mb25lbHlCbG9ja09iamVjdCwgY29yZUJsb2NrT2JqZWN0QmVoYXZpb3JzLmFycm93VXBPbkxvbmVseUJsb2NrT2JqZWN0LCBjb3JlQmxvY2tPYmplY3RCZWhhdmlvcnMuYnJlYWtpbmdCbG9ja09iamVjdCwgY29yZUJsb2NrT2JqZWN0QmVoYXZpb3JzLmRlbGV0aW5nRW1wdHlUZXh0QmxvY2tBZnRlckJsb2NrT2JqZWN0LCBjb3JlQmxvY2tPYmplY3RCZWhhdmlvcnMuZGVsZXRpbmdFbXB0eVRleHRCbG9ja0JlZm9yZUJsb2NrT2JqZWN0LCAuLi5jb3JlSW5zZXJ0QmVoYXZpb3JzLCBjb3JlTGlzdEJlaGF2aW9ycy5jbGVhckxpc3RPbkJhY2tzcGFjZSwgY29yZUxpc3RCZWhhdmlvcnMudW5pbmRlbnRMaXN0T25CYWNrc3BhY2UsIGNvcmVMaXN0QmVoYXZpb3JzLm1lcmdlVGV4dEludG9MaXN0T25EZWxldGUsIGNvcmVMaXN0QmVoYXZpb3JzLm1lcmdlVGV4dEludG9MaXN0T25CYWNrc3BhY2UsIGNvcmVMaXN0QmVoYXZpb3JzLmRlbGV0aW5nTGlzdEZyb21TdGFydCwgY29yZUxpc3RCZWhhdmlvcnMuY2xlYXJMaXN0T25FbnRlciwgY29yZUxpc3RCZWhhdmlvcnMuaW5kZW50TGlzdE9uVGFiLCBjb3JlTGlzdEJlaGF2aW9ycy51bmluZGVudExpc3RPblNoaWZ0VGFiLCBjb3JlTGlzdEJlaGF2aW9ycy5pbmhlcml0TGlzdExldmVsLCBjb3JlTGlzdEJlaGF2aW9ycy5pbmhlcml0TGlzdEl0ZW0sIGNvcmVMaXN0QmVoYXZpb3JzLmluaGVyaXRMaXN0UHJvcGVydGllcywgY29yZUluc2VydEJyZWFrQmVoYXZpb3JzLmJyZWFraW5nQXRUaGVFbmRPZlRleHRCbG9jaywgY29yZUluc2VydEJyZWFrQmVoYXZpb3JzLmJyZWFraW5nQXRUaGVTdGFydE9mVGV4dEJsb2NrLCBjb3JlSW5zZXJ0QnJlYWtCZWhhdmlvcnMuYnJlYWtpbmdFbnRpcmVEb2N1bWVudCwgY29yZUluc2VydEJyZWFrQmVoYXZpb3JzLmJyZWFraW5nRW50aXJlQmxvY2tzLCBjb3JlSW5zZXJ0QnJlYWtCZWhhdmlvcnMuYnJlYWtpbmdJbmxpbmVPYmplY3RdLm1hcCgoYmVoYXZpb3IpID0+ICh7XG4gIGJlaGF2aW9yLFxuICBwcmlvcml0eTogY29yZVByaW9yaXR5XG59KSk7XG5mdW5jdGlvbiB3aXRob3V0Tm9ybWFsaXppbmdDb25kaXRpb25hbChlZGl0b3IsIHByZWRpY2F0ZSwgZm4pIHtcbiAgcHJlZGljYXRlKCkgPyBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZm4pIDogZm4oKTtcbn1cbmNvbnN0IGFic3RyYWN0QW5ub3RhdGlvbkJlaGF2aW9ycyA9IFtkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImFubm90YXRpb24uc2V0XCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IHtcbiAgICBjb25zdCBibG9ja0tleSA9IGV2ZW50LmF0WzBdLl9rZXksIG1hcmtEZWZLZXkgPSBldmVudC5hdFsyXS5fa2V5LCBibG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHtcbiAgICAgIC4uLnNuYXBzaG90LFxuICAgICAgY29udGV4dDoge1xuICAgICAgICAuLi5zbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICBzZWxlY3Rpb246IHtcbiAgICAgICAgICBhbmNob3I6IHtcbiAgICAgICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgICAgIF9rZXk6IGJsb2NrS2V5XG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgICAgIF9rZXk6IGJsb2NrS2V5XG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghYmxvY2spXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgdXBkYXRlZE1hcmtEZWZzID0gYmxvY2subm9kZS5tYXJrRGVmcz8ubWFwKChtYXJrRGVmKSA9PiBtYXJrRGVmLl9rZXkgPT09IG1hcmtEZWZLZXkgPyB7XG4gICAgICAuLi5tYXJrRGVmLFxuICAgICAgLi4uZXZlbnQucHJvcHNcbiAgICB9IDogbWFya0RlZik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJsb2NrS2V5LFxuICAgICAgdXBkYXRlZE1hcmtEZWZzXG4gICAgfTtcbiAgfSxcbiAgYWN0aW9uczogWyhfLCB7XG4gICAgYmxvY2tLZXksXG4gICAgdXBkYXRlZE1hcmtEZWZzXG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJibG9jay5zZXRcIixcbiAgICBhdDogW3tcbiAgICAgIF9rZXk6IGJsb2NrS2V5XG4gICAgfV0sXG4gICAgcHJvcHM6IHtcbiAgICAgIG1hcmtEZWZzOiB1cGRhdGVkTWFya0RlZnNcbiAgICB9XG4gIH0pXV1cbn0pLCBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImFubm90YXRpb24udG9nZ2xlXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IGlzQWN0aXZlQW5ub3RhdGlvbihldmVudC5hbm5vdGF0aW9uLm5hbWUpKHNuYXBzaG90KSxcbiAgYWN0aW9uczogWyh7XG4gICAgZXZlbnRcbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcImFubm90YXRpb24ucmVtb3ZlXCIsXG4gICAgYW5ub3RhdGlvbjogZXZlbnQuYW5ub3RhdGlvblxuICB9KV1dXG59KSwgZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJhbm5vdGF0aW9uLnRvZ2dsZVwiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9KSA9PiAhaXNBY3RpdmVBbm5vdGF0aW9uKGV2ZW50LmFubm90YXRpb24ubmFtZSkoc25hcHNob3QpLFxuICBhY3Rpb25zOiBbKHtcbiAgICBldmVudFxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwiYW5ub3RhdGlvbi5hZGRcIixcbiAgICBhbm5vdGF0aW9uOiBldmVudC5hbm5vdGF0aW9uXG4gIH0pXV1cbn0pXSwgYWJzdHJhY3REZWNvcmF0b3JCZWhhdmlvcnMgPSBbZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJkZWNvcmF0b3IudG9nZ2xlXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IGlzQWN0aXZlRGVjb3JhdG9yKGV2ZW50LmRlY29yYXRvcikoc25hcHNob3QpLFxuICBhY3Rpb25zOiBbKHtcbiAgICBldmVudFxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwiZGVjb3JhdG9yLnJlbW92ZVwiLFxuICAgIGRlY29yYXRvcjogZXZlbnQuZGVjb3JhdG9yXG4gIH0pXV1cbn0pLCBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImRlY29yYXRvci50b2dnbGVcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4ge1xuICAgIGNvbnN0IG1hbnVhbFNlbGVjdGlvbiA9IGV2ZW50LmF0ID8gYmxvY2tPZmZzZXRzVG9TZWxlY3Rpb24oe1xuICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgIG9mZnNldHM6IGV2ZW50LmF0XG4gICAgfSkgOiBudWxsO1xuICAgIHJldHVybiBtYW51YWxTZWxlY3Rpb24gPyAhaXNBY3RpdmVEZWNvcmF0b3IoZXZlbnQuZGVjb3JhdG9yKSh7XG4gICAgICAuLi5zbmFwc2hvdCxcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgc2VsZWN0aW9uOiBtYW51YWxTZWxlY3Rpb25cbiAgICAgIH1cbiAgICB9KSA6ICFpc0FjdGl2ZURlY29yYXRvcihldmVudC5kZWNvcmF0b3IpKHNuYXBzaG90KTtcbiAgfSxcbiAgYWN0aW9uczogWyh7XG4gICAgZXZlbnRcbiAgfSkgPT4gW3JhaXNlKHtcbiAgICAuLi5ldmVudCxcbiAgICB0eXBlOiBcImRlY29yYXRvci5hZGRcIlxuICB9KV1dXG59KV0sIGFic3RyYWN0RGVsZXRlQmVoYXZpb3JzID0gW2RlZmluZUJlaGF2aW9yKHtcbiAgb246IFwiZGVsZXRlLmJhY2t3YXJkXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90XG4gIH0pID0+IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uID8ge1xuICAgIHNlbGVjdGlvbjogc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb25cbiAgfSA6ICExLFxuICBhY3Rpb25zOiBbKHtcbiAgICBldmVudFxuICB9LCB7XG4gICAgc2VsZWN0aW9uXG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJkZWxldGVcIixcbiAgICBkaXJlY3Rpb246IFwiYmFja3dhcmRcIixcbiAgICB1bml0OiBldmVudC51bml0LFxuICAgIGF0OiBzZWxlY3Rpb25cbiAgfSldXVxufSksIGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwiZGVsZXRlXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IHtcbiAgICBpZiAoZXZlbnQuZGlyZWN0aW9uICE9PSBcImJhY2t3YXJkXCIpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgcHJldmlvdXNCbG9jayA9IGdldFByZXZpb3VzQmxvY2soc25hcHNob3QpLCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHNuYXBzaG90KTtcbiAgICBpZiAoIXByZXZpb3VzQmxvY2sgfHwgIWZvY3VzVGV4dEJsb2NrIHx8ICFpc0F0VGhlU3RhcnRPZkJsb2NrKGZvY3VzVGV4dEJsb2NrKShzbmFwc2hvdCkpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgcHJldmlvdXNCbG9ja0VuZFBvaW50ID0gZ2V0QmxvY2tFbmRQb2ludCh7XG4gICAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgICAgYmxvY2s6IHByZXZpb3VzQmxvY2tcbiAgICB9KTtcbiAgICByZXR1cm4gaXNUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgcHJldmlvdXNCbG9jay5ub2RlKSA/IHtcbiAgICAgIHByZXZpb3VzQmxvY2tFbmRQb2ludCxcbiAgICAgIGZvY3VzVGV4dEJsb2NrXG4gICAgfSA6ICExO1xuICB9LFxuICBhY3Rpb25zOiBbKF8sIHtcbiAgICBwcmV2aW91c0Jsb2NrRW5kUG9pbnQsXG4gICAgZm9jdXNUZXh0QmxvY2tcbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcImRlbGV0ZS5ibG9ja1wiLFxuICAgIGF0OiBmb2N1c1RleHRCbG9jay5wYXRoXG4gIH0pLCByYWlzZSh7XG4gICAgdHlwZTogXCJzZWxlY3RcIixcbiAgICBhdDoge1xuICAgICAgYW5jaG9yOiBwcmV2aW91c0Jsb2NrRW5kUG9pbnQsXG4gICAgICBmb2N1czogcHJldmlvdXNCbG9ja0VuZFBvaW50XG4gICAgfVxuICB9KSwgcmFpc2Uoe1xuICAgIHR5cGU6IFwiaW5zZXJ0LmJsb2NrXCIsXG4gICAgYmxvY2s6IGZvY3VzVGV4dEJsb2NrLm5vZGUsXG4gICAgcGxhY2VtZW50OiBcImF1dG9cIixcbiAgICBzZWxlY3Q6IFwic3RhcnRcIlxuICB9KV1dXG59KSwgZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJkZWxldGUuZm9yd2FyZFwiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdFxuICB9KSA9PiBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbiA/IHtcbiAgICBzZWxlY3Rpb246IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uXG4gIH0gOiAhMSxcbiAgYWN0aW9uczogWyh7XG4gICAgZXZlbnRcbiAgfSwge1xuICAgIHNlbGVjdGlvblxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwiZGVsZXRlXCIsXG4gICAgZGlyZWN0aW9uOiBcImZvcndhcmRcIixcbiAgICB1bml0OiBldmVudC51bml0LFxuICAgIGF0OiBzZWxlY3Rpb25cbiAgfSldXVxufSksIGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwiZGVsZXRlXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IHtcbiAgICBpZiAoZXZlbnQuZGlyZWN0aW9uICE9PSBcImZvcndhcmRcIilcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBuZXh0QmxvY2sgPSBnZXROZXh0QmxvY2soe1xuICAgICAgLi4uc25hcHNob3QsXG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgIHNlbGVjdGlvbjogZXZlbnQuYXRcbiAgICAgIH1cbiAgICB9KSwgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayh7XG4gICAgICAuLi5zbmFwc2hvdCxcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgc2VsZWN0aW9uOiBldmVudC5hdFxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghbmV4dEJsb2NrIHx8ICFmb2N1c1RleHRCbG9jayB8fCAhaXNFbXB0eVRleHRCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBmb2N1c1RleHRCbG9jay5ub2RlKSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBuZXh0QmxvY2tTdGFydFBvaW50ID0gZ2V0QmxvY2tTdGFydFBvaW50KHtcbiAgICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgICBibG9jazogbmV4dEJsb2NrXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgICAgbmV4dEJsb2NrU3RhcnRQb2ludFxuICAgIH07XG4gIH0sXG4gIGFjdGlvbnM6IFsoXywge1xuICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgIG5leHRCbG9ja1N0YXJ0UG9pbnRcbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcImRlbGV0ZS5ibG9ja1wiLFxuICAgIGF0OiBmb2N1c1RleHRCbG9jay5wYXRoXG4gIH0pLCByYWlzZSh7XG4gICAgdHlwZTogXCJzZWxlY3RcIixcbiAgICBhdDoge1xuICAgICAgYW5jaG9yOiBuZXh0QmxvY2tTdGFydFBvaW50LFxuICAgICAgZm9jdXM6IG5leHRCbG9ja1N0YXJ0UG9pbnRcbiAgICB9XG4gIH0pXV1cbn0pLCBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImRlbGV0ZVwiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9KSA9PiB7XG4gICAgaWYgKGV2ZW50LmRpcmVjdGlvbiAhPT0gXCJmb3J3YXJkXCIpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgbmV4dEJsb2NrID0gZ2V0TmV4dEJsb2NrKHNuYXBzaG90KSwgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayhzbmFwc2hvdCk7XG4gICAgcmV0dXJuICFuZXh0QmxvY2sgfHwgIWZvY3VzVGV4dEJsb2NrIHx8ICFpc0F0VGhlRW5kT2ZCbG9jayhmb2N1c1RleHRCbG9jaykoc25hcHNob3QpIHx8ICFpc1RleHRCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBuZXh0QmxvY2subm9kZSkgPyAhMSA6IHtcbiAgICAgIG5leHRCbG9ja1xuICAgIH07XG4gIH0sXG4gIGFjdGlvbnM6IFsoXywge1xuICAgIG5leHRCbG9ja1xuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwiZGVsZXRlLmJsb2NrXCIsXG4gICAgYXQ6IG5leHRCbG9jay5wYXRoXG4gIH0pLCByYWlzZSh7XG4gICAgdHlwZTogXCJpbnNlcnQuYmxvY2tcIixcbiAgICBibG9jazogbmV4dEJsb2NrLm5vZGUsXG4gICAgcGxhY2VtZW50OiBcImF1dG9cIixcbiAgICBzZWxlY3Q6IFwibm9uZVwiXG4gIH0pXV1cbn0pLCBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImRlbGV0ZS5ibG9ja1wiLFxuICBhY3Rpb25zOiBbKHtcbiAgICBldmVudFxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwiZGVsZXRlXCIsXG4gICAgYXQ6IHtcbiAgICAgIGFuY2hvcjoge1xuICAgICAgICBwYXRoOiBldmVudC5hdCxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9LFxuICAgICAgZm9jdXM6IHtcbiAgICAgICAgcGF0aDogZXZlbnQuYXQsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfVxuICAgIH0sXG4gICAgdW5pdDogXCJibG9ja1wiXG4gIH0pXV1cbn0pLCBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImRlbGV0ZS5jaGlsZFwiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9KSA9PiB7XG4gICAgY29uc3QgZm9jdXNDaGlsZCA9IGdldEZvY3VzQ2hpbGQkMSh7XG4gICAgICAuLi5zbmFwc2hvdCxcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgICBwYXRoOiBldmVudC5hdCxcbiAgICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICAgIHBhdGg6IGV2ZW50LmF0LFxuICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvY3VzQ2hpbGQgPyBpc1NwYW4oc25hcHNob3QuY29udGV4dCwgZm9jdXNDaGlsZC5ub2RlKSA/IHtcbiAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICBhbmNob3I6IHtcbiAgICAgICAgICBwYXRoOiBldmVudC5hdCxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICBwYXRoOiBldmVudC5hdCxcbiAgICAgICAgICBvZmZzZXQ6IGZvY3VzQ2hpbGQubm9kZS50ZXh0Lmxlbmd0aFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSA6IHtcbiAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICBhbmNob3I6IHtcbiAgICAgICAgICBwYXRoOiBldmVudC5hdCxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICBwYXRoOiBldmVudC5hdCxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gOiAhMTtcbiAgfSxcbiAgYWN0aW9uczogWyhfLCB7XG4gICAgc2VsZWN0aW9uXG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJkZWxldGVcIixcbiAgICBhdDogc2VsZWN0aW9uXG4gIH0pXV1cbn0pLCBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImRlbGV0ZS50ZXh0XCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBibG9ja09mZnNldHNUb1NlbGVjdGlvbih7XG4gICAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgICAgb2Zmc2V0czogZXZlbnQuYXRcbiAgICB9KTtcbiAgICBpZiAoIXNlbGVjdGlvbilcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCB0cmltbWVkU2VsZWN0aW9uID0gZ2V0VHJpbW1lZFNlbGVjdGlvbih7XG4gICAgICAuLi5zbmFwc2hvdCxcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgdmFsdWU6IHNuYXBzaG90LmNvbnRleHQudmFsdWUsXG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0cmltbWVkU2VsZWN0aW9uID8ge1xuICAgICAgc2VsZWN0aW9uOiB0cmltbWVkU2VsZWN0aW9uXG4gICAgfSA6ICExO1xuICB9LFxuICBhY3Rpb25zOiBbKF8sIHtcbiAgICBzZWxlY3Rpb25cbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcImRlbGV0ZVwiLFxuICAgIGF0OiBzZWxlY3Rpb25cbiAgfSldXVxufSldLCBhYnN0cmFjdERlc2VyaWFsaXplQmVoYXZpb3JzID0gW1xuICBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwiZGVzZXJpYWxpemVcIixcbiAgICBndWFyZDogKHtcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgcG9ydGFibGVUZXh0ID0gZXZlbnQub3JpZ2luRXZlbnQub3JpZ2luRXZlbnQuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJhcHBsaWNhdGlvbi94LXBvcnRhYmxlLXRleHRcIik7XG4gICAgICBpZiAocG9ydGFibGVUZXh0KVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiZGVzZXJpYWxpemUuZGF0YVwiLFxuICAgICAgICAgIG1pbWVUeXBlOiBcImFwcGxpY2F0aW9uL3gtcG9ydGFibGUtdGV4dFwiLFxuICAgICAgICAgIGRhdGE6IHBvcnRhYmxlVGV4dCxcbiAgICAgICAgICBvcmlnaW5FdmVudDogZXZlbnQub3JpZ2luRXZlbnRcbiAgICAgICAgfTtcbiAgICAgIGNvbnN0IGpzb24gPSBldmVudC5vcmlnaW5FdmVudC5vcmlnaW5FdmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICBpZiAoanNvbilcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcImRlc2VyaWFsaXplLmRhdGFcIixcbiAgICAgICAgICBtaW1lVHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgZGF0YToganNvbixcbiAgICAgICAgICBvcmlnaW5FdmVudDogZXZlbnQub3JpZ2luRXZlbnRcbiAgICAgICAgfTtcbiAgICAgIGNvbnN0IGh0bWwgPSBldmVudC5vcmlnaW5FdmVudC5vcmlnaW5FdmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcInRleHQvaHRtbFwiKTtcbiAgICAgIGlmIChodG1sKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiZGVzZXJpYWxpemUuZGF0YVwiLFxuICAgICAgICAgIG1pbWVUeXBlOiBcInRleHQvaHRtbFwiLFxuICAgICAgICAgIGRhdGE6IGh0bWwsXG4gICAgICAgICAgb3JpZ2luRXZlbnQ6IGV2ZW50Lm9yaWdpbkV2ZW50XG4gICAgICAgIH07XG4gICAgICBjb25zdCB0ZXh0ID0gZXZlbnQub3JpZ2luRXZlbnQub3JpZ2luRXZlbnQuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpO1xuICAgICAgcmV0dXJuIHRleHQgPyB7XG4gICAgICAgIHR5cGU6IFwiZGVzZXJpYWxpemUuZGF0YVwiLFxuICAgICAgICBtaW1lVHlwZTogXCJ0ZXh0L3BsYWluXCIsXG4gICAgICAgIGRhdGE6IHRleHQsXG4gICAgICAgIG9yaWdpbkV2ZW50OiBldmVudC5vcmlnaW5FdmVudFxuICAgICAgfSA6ICExO1xuICAgIH0sXG4gICAgYWN0aW9uczogWyhfLCBkZXNlcmlhbGl6ZUV2ZW50KSA9PiBbcmFpc2UoZGVzZXJpYWxpemVFdmVudCldXVxuICB9KSxcbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImRlc2VyaWFsaXplXCIsXG4gICAgYWN0aW9uczogWyh7XG4gICAgICBldmVudFxuICAgIH0pID0+IFtyYWlzZSh7XG4gICAgICB0eXBlOiBcImRlc2VyaWFsaXphdGlvbi5mYWlsdXJlXCIsXG4gICAgICBtaW1lVHlwZTogXCIqLypcIixcbiAgICAgIHJlYXNvbjogXCJObyBCZWhhdmlvciB3YXMgYWJsZSB0byBoYW5kbGUgdGhlIGluY29taW5nIGRhdGFcIixcbiAgICAgIG9yaWdpbkV2ZW50OiBldmVudC5vcmlnaW5FdmVudFxuICAgIH0pXV1cbiAgfSksXG4gIGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJkZXNlcmlhbGl6ZS5kYXRhXCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBzbmFwc2hvdCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgY29udmVydGVyID0gc25hcHNob3QuY29udGV4dC5jb252ZXJ0ZXJzLmZpbmQoKGNvbnZlcnRlcjIpID0+IGNvbnZlcnRlcjIubWltZVR5cGUgPT09IGV2ZW50Lm1pbWVUeXBlKTtcbiAgICAgIHJldHVybiBjb252ZXJ0ZXIgPyBjb252ZXJ0ZXIuZGVzZXJpYWxpemUoe1xuICAgICAgICBzbmFwc2hvdCxcbiAgICAgICAgZXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImRlc2VyaWFsaXplXCIsXG4gICAgICAgICAgZGF0YTogZXZlbnQuZGF0YVxuICAgICAgICB9XG4gICAgICB9KSA6ICExO1xuICAgIH0sXG4gICAgYWN0aW9uczogWyh7XG4gICAgICBldmVudFxuICAgIH0sIGRlc2VyaWFsaXplRXZlbnQpID0+IFtyYWlzZSh7XG4gICAgICAuLi5kZXNlcmlhbGl6ZUV2ZW50LFxuICAgICAgb3JpZ2luRXZlbnQ6IGV2ZW50Lm9yaWdpbkV2ZW50XG4gICAgfSldXVxuICB9KSxcbiAgLyoqXG4gICAqIElmIHdlIGFyZSBwYXN0aW5nIHRleHQvcGxhaW4gaW50byBhIHRleHQgYmxvY2sgdGhlbiB3ZSBjYW4gcHJvYmFibHlcbiAgICogYXNzdW1lIHRoYXQgdGhlIGludGVuZGVkIGJlaGF2aW9yIGlzIHRoYXQgdGhlIHBhc3RlZCB0ZXh0IGluaGVyaXRzXG4gICAqIGZvcm1hdHRpbmcgZnJvbSB0aGUgdGV4dCBpdCdzIHBhc3RlZCBpbnRvLlxuICAgKi9cbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImRlc2VyaWFsaXphdGlvbi5zdWNjZXNzXCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBzbmFwc2hvdCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4ge1xuICAgICAgaWYgKGdldEZvY3VzVGV4dEJsb2NrKHNuYXBzaG90KSAmJiBldmVudC5taW1lVHlwZSA9PT0gXCJ0ZXh0L3BsYWluXCIgJiYgZXZlbnQub3JpZ2luRXZlbnQudHlwZSA9PT0gXCJjbGlwYm9hcmQucGFzdGVcIikge1xuICAgICAgICBjb25zdCBhY3RpdmVEZWNvcmF0b3JzID0gZ2V0QWN0aXZlRGVjb3JhdG9ycyhzbmFwc2hvdCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYWN0aXZlQW5ub3RhdGlvbnM6IGdldEFjdGl2ZUFubm90YXRpb25zKHNuYXBzaG90KSxcbiAgICAgICAgICBhY3RpdmVEZWNvcmF0b3JzLFxuICAgICAgICAgIHRleHRSdW5zOiBldmVudC5kYXRhLmZsYXRNYXAoKGJsb2NrKSA9PiBpc1RleHRCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBibG9jaykgPyBbZ2V0VGV4dEJsb2NrVGV4dChibG9jayldIDogW10pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfSxcbiAgICBhY3Rpb25zOiBbKF8sIHtcbiAgICAgIGFjdGl2ZUFubm90YXRpb25zLFxuICAgICAgYWN0aXZlRGVjb3JhdG9ycyxcbiAgICAgIHRleHRSdW5zXG4gICAgfSkgPT4gdGV4dFJ1bnMuZmxhdE1hcCgodGV4dFJ1biwgaW5kZXgpID0+IGluZGV4ICE9PSB0ZXh0UnVucy5sZW5ndGggLSAxID8gW3JhaXNlKHtcbiAgICAgIHR5cGU6IFwiaW5zZXJ0LnNwYW5cIixcbiAgICAgIHRleHQ6IHRleHRSdW4sXG4gICAgICBkZWNvcmF0b3JzOiBhY3RpdmVEZWNvcmF0b3JzLFxuICAgICAgYW5ub3RhdGlvbnM6IGFjdGl2ZUFubm90YXRpb25zLm1hcCgoe1xuICAgICAgICBfa2V5LFxuICAgICAgICBfdHlwZSxcbiAgICAgICAgLi4udmFsdWVcbiAgICAgIH0pID0+ICh7XG4gICAgICAgIG5hbWU6IF90eXBlLFxuICAgICAgICB2YWx1ZVxuICAgICAgfSkpXG4gICAgfSksIHJhaXNlKHtcbiAgICAgIHR5cGU6IFwiaW5zZXJ0LmJyZWFrXCJcbiAgICB9KV0gOiBbcmFpc2Uoe1xuICAgICAgdHlwZTogXCJpbnNlcnQuc3BhblwiLFxuICAgICAgdGV4dDogdGV4dFJ1bixcbiAgICAgIGRlY29yYXRvcnM6IGFjdGl2ZURlY29yYXRvcnMsXG4gICAgICBhbm5vdGF0aW9uczogYWN0aXZlQW5ub3RhdGlvbnMubWFwKCh7XG4gICAgICAgIF9rZXksXG4gICAgICAgIF90eXBlLFxuICAgICAgICAuLi52YWx1ZVxuICAgICAgfSkgPT4gKHtcbiAgICAgICAgbmFtZTogX3R5cGUsXG4gICAgICAgIHZhbHVlXG4gICAgICB9KSlcbiAgICB9KV0pXVxuICB9KSxcbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImRlc2VyaWFsaXphdGlvbi5zdWNjZXNzXCIsXG4gICAgYWN0aW9uczogWyh7XG4gICAgICBldmVudFxuICAgIH0pID0+IFtyYWlzZSh7XG4gICAgICB0eXBlOiBcImluc2VydC5ibG9ja3NcIixcbiAgICAgIGJsb2NrczogZXZlbnQuZGF0YSxcbiAgICAgIHBsYWNlbWVudDogXCJhdXRvXCJcbiAgICB9KV1dXG4gIH0pLFxuICBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwiZGVzZXJpYWxpemF0aW9uLmZhaWx1cmVcIixcbiAgICBndWFyZDogKHtcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4ge1xuICAgICAgaWYgKGV2ZW50Lm1pbWVUeXBlID09PSBcImFwcGxpY2F0aW9uL3gtcG9ydGFibGUtdGV4dFwiKSB7XG4gICAgICAgIGNvbnN0IGpzb24gPSBldmVudC5vcmlnaW5FdmVudC5vcmlnaW5FdmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICAgIGlmIChqc29uKVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImRlc2VyaWFsaXplLmRhdGFcIixcbiAgICAgICAgICAgIG1pbWVUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIGRhdGE6IGpzb24sXG4gICAgICAgICAgICBvcmlnaW5FdmVudDogZXZlbnQub3JpZ2luRXZlbnRcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50Lm1pbWVUeXBlID09PSBcImFwcGxpY2F0aW9uL2pzb25cIikge1xuICAgICAgICBjb25zdCBodG1sID0gZXZlbnQub3JpZ2luRXZlbnQub3JpZ2luRXZlbnQuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJ0ZXh0L2h0bWxcIik7XG4gICAgICAgIGlmIChodG1sKVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImRlc2VyaWFsaXplLmRhdGFcIixcbiAgICAgICAgICAgIG1pbWVUeXBlOiBcInRleHQvaHRtbFwiLFxuICAgICAgICAgICAgZGF0YTogaHRtbCxcbiAgICAgICAgICAgIG9yaWdpbkV2ZW50OiBldmVudC5vcmlnaW5FdmVudFxuICAgICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQubWltZVR5cGUgPT09IFwidGV4dC9odG1sXCIpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IGV2ZW50Lm9yaWdpbkV2ZW50Lm9yaWdpbkV2ZW50LmRhdGFUcmFuc2Zlci5nZXREYXRhKFwidGV4dC9wbGFpblwiKTtcbiAgICAgICAgaWYgKHRleHQpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiZGVzZXJpYWxpemUuZGF0YVwiLFxuICAgICAgICAgICAgbWltZVR5cGU6IFwidGV4dC9wbGFpblwiLFxuICAgICAgICAgICAgZGF0YTogdGV4dCxcbiAgICAgICAgICAgIG9yaWdpbkV2ZW50OiBldmVudC5vcmlnaW5FdmVudFxuICAgICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfSxcbiAgICBhY3Rpb25zOiBbKF8sIGRlc2VyaWFsaXplRGF0YUV2ZW50KSA9PiBbcmFpc2UoZGVzZXJpYWxpemVEYXRhRXZlbnQpXV1cbiAgfSksXG4gIGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJkZXNlcmlhbGl6YXRpb24uZmFpbHVyZVwiLFxuICAgIGFjdGlvbnM6IFsoe1xuICAgICAgZXZlbnRcbiAgICB9KSA9PiBbe1xuICAgICAgdHlwZTogXCJlZmZlY3RcIixcbiAgICAgIGVmZmVjdDogKCkgPT4ge1xuICAgICAgICBjb25zb2xlLndhcm4oYERlc2VyaWFsaXphdGlvbiBvZiAke2V2ZW50Lm1pbWVUeXBlfSBmYWlsZWQgd2l0aCByZWFzb24gXCIke2V2ZW50LnJlYXNvbn1cImApO1xuICAgICAgfVxuICAgIH1dXVxuICB9KVxuXSwgYWJzdHJhY3RJbnNlcnRCZWhhdmlvcnMgPSBbZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJpbnNlcnQuYmxvY2tzXCIsXG4gIGd1YXJkOiAoe1xuICAgIGV2ZW50XG4gIH0pID0+IHtcbiAgICBjb25zdCBvbmx5QmxvY2sgPSBldmVudC5ibG9ja3MubGVuZ3RoID09PSAxID8gZXZlbnQuYmxvY2tzLmF0KDApIDogdm9pZCAwO1xuICAgIHJldHVybiBvbmx5QmxvY2sgPyB7XG4gICAgICBvbmx5QmxvY2tcbiAgICB9IDogITE7XG4gIH0sXG4gIGFjdGlvbnM6IFsoe1xuICAgIGV2ZW50XG4gIH0sIHtcbiAgICBvbmx5QmxvY2tcbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcImluc2VydC5ibG9ja1wiLFxuICAgIGJsb2NrOiBvbmx5QmxvY2ssXG4gICAgcGxhY2VtZW50OiBldmVudC5wbGFjZW1lbnQsXG4gICAgc2VsZWN0OiBldmVudC5zZWxlY3QgPz8gXCJlbmRcIlxuICB9KV1dXG59KSwgZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJpbnNlcnQuYmxvY2tzXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IHtcbiAgICBpZiAoZXZlbnQucGxhY2VtZW50ICE9PSBcImJlZm9yZVwiKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IGZpcnN0QmxvY2tLZXkgPSBldmVudC5ibG9ja3MuYXQoMCk/Ll9rZXkgPz8gc25hcHNob3QuY29udGV4dC5rZXlHZW5lcmF0b3IoKSwgbGFzdEJsb2NrS2V5ID0gZXZlbnQuYmxvY2tzLmF0KC0xKT8uX2tleSA/PyBzbmFwc2hvdC5jb250ZXh0LmtleUdlbmVyYXRvcigpO1xuICAgIHJldHVybiB7XG4gICAgICBmaXJzdEJsb2NrS2V5LFxuICAgICAgbGFzdEJsb2NrS2V5XG4gICAgfTtcbiAgfSxcbiAgYWN0aW9uczogWyh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSwge1xuICAgIGZpcnN0QmxvY2tLZXksXG4gICAgbGFzdEJsb2NrS2V5XG4gIH0pID0+IFsuLi5ldmVudC5ibG9ja3MubWFwKChibG9jaywgaW5kZXgpID0+IHJhaXNlKHtcbiAgICB0eXBlOiBcImluc2VydC5ibG9ja1wiLFxuICAgIGJsb2NrLFxuICAgIHBsYWNlbWVudDogaW5kZXggPT09IDAgPyBcImJlZm9yZVwiIDogXCJhZnRlclwiLFxuICAgIHNlbGVjdDogaW5kZXggIT09IGV2ZW50LmJsb2Nrcy5sZW5ndGggLSAxID8gXCJlbmRcIiA6IFwibm9uZVwiXG4gIH0pKSwgLi4uZXZlbnQuc2VsZWN0ID09PSBcIm5vbmVcIiA/IFtyYWlzZSh7XG4gICAgdHlwZTogXCJzZWxlY3RcIixcbiAgICBhdDogc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb25cbiAgfSldIDogZXZlbnQuc2VsZWN0ID09PSBcInN0YXJ0XCIgPyBbcmFpc2Uoe1xuICAgIHR5cGU6IFwic2VsZWN0LmJsb2NrXCIsXG4gICAgYXQ6IFt7XG4gICAgICBfa2V5OiBmaXJzdEJsb2NrS2V5XG4gICAgfV0sXG4gICAgc2VsZWN0OiBcInN0YXJ0XCJcbiAgfSldIDogW3JhaXNlKHtcbiAgICB0eXBlOiBcInNlbGVjdC5ibG9ja1wiLFxuICAgIGF0OiBbe1xuICAgICAgX2tleTogbGFzdEJsb2NrS2V5XG4gICAgfV0sXG4gICAgc2VsZWN0OiBcImVuZFwiXG4gIH0pXV1dXG59KSwgZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJpbnNlcnQuYmxvY2tzXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IHtcbiAgICBpZiAoZXZlbnQucGxhY2VtZW50ICE9PSBcImFmdGVyXCIpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgZmlyc3RCbG9ja0tleSA9IGV2ZW50LmJsb2Nrcy5hdCgwKT8uX2tleSA/PyBzbmFwc2hvdC5jb250ZXh0LmtleUdlbmVyYXRvcigpLCBsYXN0QmxvY2tLZXkgPSBldmVudC5ibG9ja3MuYXQoLTEpPy5fa2V5ID8/IHNuYXBzaG90LmNvbnRleHQua2V5R2VuZXJhdG9yKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpcnN0QmxvY2tLZXksXG4gICAgICBsYXN0QmxvY2tLZXlcbiAgICB9O1xuICB9LFxuICBhY3Rpb25zOiBbKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9LCB7XG4gICAgZmlyc3RCbG9ja0tleSxcbiAgICBsYXN0QmxvY2tLZXlcbiAgfSkgPT4gWy4uLmV2ZW50LmJsb2Nrcy5tYXAoKGJsb2NrLCBpbmRleCkgPT4gcmFpc2Uoe1xuICAgIHR5cGU6IFwiaW5zZXJ0LmJsb2NrXCIsXG4gICAgYmxvY2ssXG4gICAgcGxhY2VtZW50OiBcImFmdGVyXCIsXG4gICAgc2VsZWN0OiBpbmRleCAhPT0gZXZlbnQuYmxvY2tzLmxlbmd0aCAtIDEgPyBcImVuZFwiIDogXCJub25lXCJcbiAgfSkpLCAuLi5ldmVudC5zZWxlY3QgPT09IFwibm9uZVwiID8gW3JhaXNlKHtcbiAgICB0eXBlOiBcInNlbGVjdFwiLFxuICAgIGF0OiBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvblxuICB9KV0gOiBldmVudC5zZWxlY3QgPT09IFwic3RhcnRcIiA/IFtyYWlzZSh7XG4gICAgdHlwZTogXCJzZWxlY3QuYmxvY2tcIixcbiAgICBhdDogW3tcbiAgICAgIF9rZXk6IGZpcnN0QmxvY2tLZXlcbiAgICB9XSxcbiAgICBzZWxlY3Q6IFwic3RhcnRcIlxuICB9KV0gOiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwic2VsZWN0LmJsb2NrXCIsXG4gICAgYXQ6IFt7XG4gICAgICBfa2V5OiBsYXN0QmxvY2tLZXlcbiAgICB9XSxcbiAgICBzZWxlY3Q6IFwiZW5kXCJcbiAgfSldXV1cbn0pLCBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImluc2VydC5ibG9ja3NcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4ge1xuICAgIGlmIChldmVudC5wbGFjZW1lbnQgIT09IFwiYXV0b1wiKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IGZvY3VzVGV4dEJsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soc25hcHNob3QpO1xuICAgIGlmICghZm9jdXNUZXh0QmxvY2sgfHwgIWlzRW1wdHlUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgZm9jdXNUZXh0QmxvY2subm9kZSkpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgZmlyc3RCbG9ja0tleSA9IGV2ZW50LmJsb2Nrcy5hdCgwKT8uX2tleSA/PyBzbmFwc2hvdC5jb250ZXh0LmtleUdlbmVyYXRvcigpLCBsYXN0QmxvY2tLZXkgPSBldmVudC5ibG9ja3MuYXQoLTEpPy5fa2V5ID8/IHNuYXBzaG90LmNvbnRleHQua2V5R2VuZXJhdG9yKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgICAgZmlyc3RCbG9ja0tleSxcbiAgICAgIGxhc3RCbG9ja0tleVxuICAgIH07XG4gIH0sXG4gIGFjdGlvbnM6IFsoe1xuICAgIGV2ZW50XG4gIH0sIHtcbiAgICBmaXJzdEJsb2NrS2V5LFxuICAgIGxhc3RCbG9ja0tleVxuICB9KSA9PiBbLi4uZXZlbnQuYmxvY2tzLm1hcCgoYmxvY2ssIGluZGV4KSA9PiByYWlzZSh7XG4gICAgdHlwZTogXCJpbnNlcnQuYmxvY2tcIixcbiAgICBibG9jayxcbiAgICBwbGFjZW1lbnQ6IGluZGV4ID09PSAwID8gXCJhdXRvXCIgOiBcImFmdGVyXCIsXG4gICAgc2VsZWN0OiBpbmRleCAhPT0gZXZlbnQuYmxvY2tzLmxlbmd0aCAtIDEgPyBcImVuZFwiIDogXCJub25lXCJcbiAgfSkpLCAuLi5ldmVudC5zZWxlY3QgPT09IFwibm9uZVwiIHx8IGV2ZW50LnNlbGVjdCA9PT0gXCJzdGFydFwiID8gW3JhaXNlKHtcbiAgICB0eXBlOiBcInNlbGVjdC5ibG9ja1wiLFxuICAgIGF0OiBbe1xuICAgICAgX2tleTogZmlyc3RCbG9ja0tleVxuICAgIH1dLFxuICAgIHNlbGVjdDogXCJzdGFydFwiXG4gIH0pXSA6IFtyYWlzZSh7XG4gICAgdHlwZTogXCJzZWxlY3QuYmxvY2tcIixcbiAgICBhdDogW3tcbiAgICAgIF9rZXk6IGxhc3RCbG9ja0tleVxuICAgIH1dLFxuICAgIHNlbGVjdDogXCJlbmRcIlxuICB9KV1dXVxufSksIGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwiaW5zZXJ0LmJsb2Nrc1wiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9KSA9PiB7XG4gICAgaWYgKGV2ZW50LnBsYWNlbWVudCAhPT0gXCJhdXRvXCIpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayhzbmFwc2hvdCk7XG4gICAgaWYgKCFmb2N1c1RleHRCbG9jayB8fCAhc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24pXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgZm9jdXNCbG9ja1N0YXJ0UG9pbnQgPSBnZXRCbG9ja1N0YXJ0UG9pbnQoe1xuICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgIGJsb2NrOiBmb2N1c1RleHRCbG9ja1xuICAgIH0pLCBmb2N1c0Jsb2NrRW5kUG9pbnQgPSBnZXRCbG9ja0VuZFBvaW50KHtcbiAgICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgICBibG9jazogZm9jdXNUZXh0QmxvY2tcbiAgICB9KSwgZm9jdXNUZXh0QmxvY2tBZnRlciA9IHNsaWNlVGV4dEJsb2NrKHtcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgc2NoZW1hOiBzbmFwc2hvdC5jb250ZXh0LnNjaGVtYSxcbiAgICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgICAgYW5jaG9yOiBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5mb2N1cyxcbiAgICAgICAgICBmb2N1czogZm9jdXNCbG9ja0VuZFBvaW50XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBibG9jazogZm9jdXNUZXh0QmxvY2subm9kZVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBmaXJzdEJsb2NrS2V5OiBldmVudC5ibG9ja3MuYXQoMCk/Ll9rZXkgPz8gc25hcHNob3QuY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgIGZvY3VzQmxvY2tTdGFydFBvaW50LFxuICAgICAgZm9jdXNCbG9ja0VuZFBvaW50LFxuICAgICAgZm9jdXNUZXh0QmxvY2tBZnRlcixcbiAgICAgIHNlbGVjdGlvbjogc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb25cbiAgICB9O1xuICB9LFxuICBhY3Rpb25zOiBbKHtcbiAgICBldmVudFxuICB9LCB7XG4gICAgZm9jdXNCbG9ja0VuZFBvaW50LFxuICAgIGZvY3VzVGV4dEJsb2NrQWZ0ZXIsXG4gICAgc2VsZWN0aW9uLFxuICAgIGZpcnN0QmxvY2tLZXksXG4gICAgZm9jdXNCbG9ja1N0YXJ0UG9pbnRcbiAgfSkgPT4gWy4uLmV2ZW50LmJsb2Nrcy5mbGF0TWFwKChibG9jaywgaW5kZXgpID0+IGluZGV4ID09PSAwID8gWy4uLmlzRXF1YWxTZWxlY3Rpb25Qb2ludHMoc2VsZWN0aW9uLmZvY3VzLCBmb2N1c0Jsb2NrRW5kUG9pbnQpID8gW10gOiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwiZGVsZXRlXCIsXG4gICAgYXQ6IHtcbiAgICAgIGFuY2hvcjogc2VsZWN0aW9uLmZvY3VzLFxuICAgICAgZm9jdXM6IGZvY3VzQmxvY2tFbmRQb2ludFxuICAgIH1cbiAgfSldLCByYWlzZSh7XG4gICAgdHlwZTogXCJpbnNlcnQuYmxvY2tcIixcbiAgICBibG9jayxcbiAgICBwbGFjZW1lbnQ6IFwiYXV0b1wiLFxuICAgIHNlbGVjdDogXCJlbmRcIlxuICB9KV0gOiBpbmRleCA9PT0gZXZlbnQuYmxvY2tzLmxlbmd0aCAtIDEgPyBbcmFpc2Uoe1xuICAgIHR5cGU6IFwiaW5zZXJ0LmJsb2NrXCIsXG4gICAgYmxvY2ssXG4gICAgcGxhY2VtZW50OiBcImFmdGVyXCIsXG4gICAgc2VsZWN0OiBcImVuZFwiXG4gIH0pLCByYWlzZSh7XG4gICAgdHlwZTogXCJpbnNlcnQuYmxvY2tcIixcbiAgICBibG9jazogZm9jdXNUZXh0QmxvY2tBZnRlcixcbiAgICBwbGFjZW1lbnQ6IFwiYXV0b1wiLFxuICAgIHNlbGVjdDogZXZlbnQuc2VsZWN0ID09PSBcImVuZFwiID8gXCJub25lXCIgOiBcImVuZFwiXG4gIH0pXSA6IFtyYWlzZSh7XG4gICAgdHlwZTogXCJpbnNlcnQuYmxvY2tcIixcbiAgICBibG9jayxcbiAgICBwbGFjZW1lbnQ6IFwiYWZ0ZXJcIixcbiAgICBzZWxlY3Q6IFwiZW5kXCJcbiAgfSldKSwgLi4uZXZlbnQuc2VsZWN0ID09PSBcIm5vbmVcIiA/IFtyYWlzZSh7XG4gICAgdHlwZTogXCJzZWxlY3RcIixcbiAgICBhdDogc2VsZWN0aW9uXG4gIH0pXSA6IGV2ZW50LnNlbGVjdCA9PT0gXCJzdGFydFwiID8gW2lzRXF1YWxTZWxlY3Rpb25Qb2ludHMoc2VsZWN0aW9uLmZvY3VzLCBmb2N1c0Jsb2NrU3RhcnRQb2ludCkgPyByYWlzZSh7XG4gICAgdHlwZTogXCJzZWxlY3QuYmxvY2tcIixcbiAgICBhdDogW3tcbiAgICAgIF9rZXk6IGZpcnN0QmxvY2tLZXlcbiAgICB9XSxcbiAgICBzZWxlY3Q6IFwic3RhcnRcIlxuICB9KSA6IHJhaXNlKHtcbiAgICB0eXBlOiBcInNlbGVjdFwiLFxuICAgIGF0OiB7XG4gICAgICBhbmNob3I6IHNlbGVjdGlvbi5mb2N1cyxcbiAgICAgIGZvY3VzOiBzZWxlY3Rpb24uZm9jdXNcbiAgICB9XG4gIH0pXSA6IFtdXV1cbn0pLCBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImluc2VydC5ibG9ja3NcIixcbiAgZ3VhcmQ6ICh7XG4gICAgZXZlbnRcbiAgfSkgPT4gZXZlbnQucGxhY2VtZW50ID09PSBcImF1dG9cIixcbiAgYWN0aW9uczogWyh7XG4gICAgZXZlbnRcbiAgfSkgPT4gZXZlbnQuYmxvY2tzLm1hcCgoYmxvY2ssIGluZGV4KSA9PiByYWlzZSh7XG4gICAgdHlwZTogXCJpbnNlcnQuYmxvY2tcIixcbiAgICBibG9jayxcbiAgICBwbGFjZW1lbnQ6IGluZGV4ID09PSAwID8gXCJhdXRvXCIgOiBcImFmdGVyXCIsXG4gICAgc2VsZWN0OiBldmVudC5zZWxlY3QgPz8gXCJlbmRcIlxuICB9KSldXG59KSwgZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJpbnNlcnQuYnJlYWtcIixcbiAgYWN0aW9uczogWygpID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJzcGxpdFwiXG4gIH0pXV1cbn0pLCBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImluc2VydC5jaGlsZFwiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdFxuICB9KSA9PiB7XG4gICAgY29uc3QgbGFzdEJsb2NrID0gZ2V0TGFzdEJsb2NrJDEoc25hcHNob3QpO1xuICAgIHJldHVybiAhbGFzdEJsb2NrIHx8IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uID8gITEgOiB7XG4gICAgICBsYXN0QmxvY2tFbmRQb2ludDogZ2V0QmxvY2tFbmRQb2ludCh7XG4gICAgICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgIGJsb2NrOiBsYXN0QmxvY2tcbiAgICAgIH0pXG4gICAgfTtcbiAgfSxcbiAgYWN0aW9uczogWyh7XG4gICAgZXZlbnRcbiAgfSwge1xuICAgIGxhc3RCbG9ja0VuZFBvaW50XG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJzZWxlY3RcIixcbiAgICBhdDoge1xuICAgICAgYW5jaG9yOiBsYXN0QmxvY2tFbmRQb2ludCxcbiAgICAgIGZvY3VzOiBsYXN0QmxvY2tFbmRQb2ludFxuICAgIH1cbiAgfSksIHJhaXNlKGV2ZW50KV1dXG59KSwgZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJpbnNlcnQuY2hpbGRcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3RcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGZvY3VzVGV4dEJsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soc25hcHNob3QpO1xuICAgIHJldHVybiBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbiAmJiAhZm9jdXNUZXh0QmxvY2s7XG4gIH0sXG4gIGFjdGlvbnM6IFsoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJpbnNlcnQuYmxvY2tcIixcbiAgICBibG9jazoge1xuICAgICAgX3R5cGU6IHNuYXBzaG90LmNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWUsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgX3R5cGU6IHNuYXBzaG90LmNvbnRleHQuc2NoZW1hLnNwYW4ubmFtZSxcbiAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgbWFya3M6IFtdXG4gICAgICB9XVxuICAgIH0sXG4gICAgcGxhY2VtZW50OiBcImF1dG9cIixcbiAgICBzZWxlY3Q6IFwiZW5kXCJcbiAgfSksIHJhaXNlKGV2ZW50KV1dXG59KSwgZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJpbnNlcnQuaW5saW5lIG9iamVjdFwiLFxuICBhY3Rpb25zOiBbKHtcbiAgICBldmVudFxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwiaW5zZXJ0LmNoaWxkXCIsXG4gICAgY2hpbGQ6IHtcbiAgICAgIF90eXBlOiBldmVudC5pbmxpbmVPYmplY3QubmFtZSxcbiAgICAgIC4uLmV2ZW50LmlubGluZU9iamVjdC52YWx1ZVxuICAgIH1cbiAgfSldXVxufSksIGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwiaW5zZXJ0LnNvZnQgYnJlYWtcIixcbiAgYWN0aW9uczogWygpID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJpbnNlcnQudGV4dFwiLFxuICAgIHRleHQ6IGBcbmBcbiAgfSldXVxufSksIGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwiaW5zZXJ0LnNwYW5cIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3RcbiAgfSkgPT4gIWdldEZvY3VzVGV4dEJsb2NrKHNuYXBzaG90KSxcbiAgYWN0aW9uczogWyh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcImluc2VydC5ibG9ja1wiLFxuICAgIGJsb2NrOiB7XG4gICAgICBfdHlwZTogc25hcHNob3QuY29udGV4dC5zY2hlbWEuYmxvY2submFtZSxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICBfdHlwZTogc25hcHNob3QuY29udGV4dC5zY2hlbWEuc3Bhbi5uYW1lLFxuICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICBtYXJrczogW11cbiAgICAgIH1dXG4gICAgfSxcbiAgICBwbGFjZW1lbnQ6IFwiYXV0b1wiLFxuICAgIHNlbGVjdDogXCJlbmRcIlxuICB9KSwgcmFpc2UoZXZlbnQpXV1cbn0pLCBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImluc2VydC5zcGFuXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IHtcbiAgICBjb25zdCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHNuYXBzaG90KTtcbiAgICByZXR1cm4ge1xuICAgICAgbWFya0RlZnM6IGV2ZW50LmFubm90YXRpb25zPy5tYXAoKGFubm90YXRpb24pID0+ICh7XG4gICAgICAgIF90eXBlOiBhbm5vdGF0aW9uLm5hbWUsXG4gICAgICAgIF9rZXk6IHNuYXBzaG90LmNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgICAgIC4uLmFubm90YXRpb24udmFsdWVcbiAgICAgIH0pKSA/PyBbXSxcbiAgICAgIGZvY3VzVGV4dEJsb2NrXG4gICAgfTtcbiAgfSxcbiAgYWN0aW9uczogWyh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSwge1xuICAgIG1hcmtEZWZzLFxuICAgIGZvY3VzVGV4dEJsb2NrXG4gIH0pID0+IFsuLi5mb2N1c1RleHRCbG9jayA/IFtyYWlzZSh7XG4gICAgdHlwZTogXCJibG9jay5zZXRcIixcbiAgICBhdDogZm9jdXNUZXh0QmxvY2sucGF0aCxcbiAgICBwcm9wczoge1xuICAgICAgbWFya0RlZnM6IFsuLi5mb2N1c1RleHRCbG9jay5ub2RlLm1hcmtEZWZzID8/IFtdLCAuLi5tYXJrRGVmc11cbiAgICB9XG4gIH0pXSA6IFtdLCByYWlzZSh7XG4gICAgdHlwZTogXCJpbnNlcnQuY2hpbGRcIixcbiAgICBjaGlsZDoge1xuICAgICAgX3R5cGU6IHNuYXBzaG90LmNvbnRleHQuc2NoZW1hLnNwYW4ubmFtZSxcbiAgICAgIHRleHQ6IGV2ZW50LnRleHQsXG4gICAgICBtYXJrczogWy4uLmV2ZW50LmRlY29yYXRvcnMgPz8gW10sIC4uLm1hcmtEZWZzLm1hcCgobWFya0RlZikgPT4gbWFya0RlZi5fa2V5KV1cbiAgICB9XG4gIH0pXV1cbn0pXSwgc2hpZnRMZWZ0ID0gY3JlYXRlS2V5Ym9hcmRTaG9ydGN1dCh7XG4gIGRlZmF1bHQ6IFt7XG4gICAga2V5OiBcIkFycm93TGVmdFwiLFxuICAgIHNoaWZ0OiAhMCxcbiAgICBtZXRhOiAhMSxcbiAgICBjdHJsOiAhMSxcbiAgICBhbHQ6ICExXG4gIH1dXG59KSwgYWJzdHJhY3RLZXlib2FyZEJlaGF2aW9ycyA9IFtcbiAgLyoqXG4gICAqIFdoZW4gQmFja3NwYWNlIGlzIHByZXNzZWQgb24gYW4gaW5saW5lIG9iamVjdCwgU2xhdGUgd2lsbCByYWlzZSBhXG4gICAqIGBkZWxldGUuYmFja3dhcmRgIGV2ZW50IHdpdGggYHVuaXQ6ICdibG9jaydgLiBUaGlzIGlzIHdyb25nIGFuZCB0aGlzXG4gICAqIEJlaGF2aW9yIGFkanVzdHMgdGhhdC5cbiAgICovXG4gIGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJrZXlib2FyZC5rZXlkb3duXCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBzbmFwc2hvdCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4gZGVmYXVsdEtleWJvYXJkU2hvcnRjdXRzLmJhY2tzcGFjZS5ndWFyZChldmVudC5vcmlnaW5FdmVudCkgJiYgaXNTZWxlY3Rpb25Db2xsYXBzZWQkMShzbmFwc2hvdCkgJiYgZ2V0Rm9jdXNJbmxpbmVPYmplY3Qoc25hcHNob3QpLFxuICAgIGFjdGlvbnM6IFsoKSA9PiBbcmFpc2Uoe1xuICAgICAgdHlwZTogXCJkZWxldGUuYmFja3dhcmRcIixcbiAgICAgIHVuaXQ6IFwiY2hhcmFjdGVyXCJcbiAgICB9KV1dXG4gIH0pLFxuICAvKipcbiAgICogV2hlbiBEZWxldGUgaXMgcHJlc3NlZCBvbiBhbiBpbmxpbmUgb2JqZWN0LCBTbGF0ZSB3aWxsIHJhaXNlIGFcbiAgICogYGRlbGV0ZS5mb3J3YXJkYCBldmVudCB3aXRoIGB1bml0OiAnYmxvY2snYC4gVGhpcyBpcyB3cm9uZyBhbmQgdGhpc1xuICAgKiBCZWhhdmlvciBhZGp1c3RzIHRoYXQuXG4gICAqL1xuICBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwia2V5Ym9hcmQua2V5ZG93blwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgc25hcHNob3QsXG4gICAgICBldmVudFxuICAgIH0pID0+IGRlZmF1bHRLZXlib2FyZFNob3J0Y3V0cy5kZWxldGUuZ3VhcmQoZXZlbnQub3JpZ2luRXZlbnQpICYmIGlzU2VsZWN0aW9uQ29sbGFwc2VkJDEoc25hcHNob3QpICYmIGdldEZvY3VzSW5saW5lT2JqZWN0KHNuYXBzaG90KSxcbiAgICBhY3Rpb25zOiBbKCkgPT4gW3JhaXNlKHtcbiAgICAgIHR5cGU6IFwiZGVsZXRlLmZvcndhcmRcIixcbiAgICAgIHVuaXQ6IFwiY2hhcmFjdGVyXCJcbiAgICB9KV1dXG4gIH0pLFxuICAvKipcbiAgICogQWxsb3cgcmFpc2luZyBhbiBgaW5zZXJ0LmJyZWFrYCBldmVudCB3aGVuIHByZXNzaW5nIEVudGVyIG9uIGFuIGlubGluZVxuICAgKiBvYmplY3QuXG4gICAqL1xuICBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwia2V5Ym9hcmQua2V5ZG93blwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgc25hcHNob3QsXG4gICAgICBldmVudFxuICAgIH0pID0+IGRlZmF1bHRLZXlib2FyZFNob3J0Y3V0cy5icmVhay5ndWFyZChldmVudC5vcmlnaW5FdmVudCkgJiYgaXNTZWxlY3Rpb25Db2xsYXBzZWQkMShzbmFwc2hvdCkgJiYgZ2V0Rm9jdXNJbmxpbmVPYmplY3Qoc25hcHNob3QpLFxuICAgIGFjdGlvbnM6IFsoKSA9PiBbcmFpc2Uoe1xuICAgICAgdHlwZTogXCJpbnNlcnQuYnJlYWtcIlxuICAgIH0pXV1cbiAgfSksXG4gIC8qKlxuICAgKiBPbiBGaXJlZm94LCBFbnRlciBtaWdodCBjb2xsYXBzZSB0aGUgc2VsZWN0aW9uLiBUbyBtaXRpZ2F0ZSB0aGlzLCB3ZVxuICAgKiBgcmFpc2VgIGFuIGBpbnNlcnQuYnJlYWtgIGV2ZW50IG1hbnVhbGx5LlxuICAgKi9cbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImtleWJvYXJkLmtleWRvd25cIixcbiAgICBndWFyZDogKHtcbiAgICAgIHNuYXBzaG90LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiBkZWZhdWx0S2V5Ym9hcmRTaG9ydGN1dHMuYnJlYWsuZ3VhcmQoZXZlbnQub3JpZ2luRXZlbnQpICYmIGlzU2VsZWN0aW9uRXhwYW5kZWQoc25hcHNob3QpLFxuICAgIGFjdGlvbnM6IFsoKSA9PiBbcmFpc2Uoe1xuICAgICAgdHlwZTogXCJpbnNlcnQuYnJlYWtcIlxuICAgIH0pXV1cbiAgfSksXG4gIC8qKlxuICAgKiBPbiBXZWJLaXQsIFNoaWZ0K0VudGVyIHJlc3VsdHMgaW4gYW4gYGluc2VydFBhcmFncmFwaGAgaW5wdXQgZXZlbnQgcmF0aGVyXG4gICAqIHRoYW4gYW4gYGluc2VydExpbmVCcmVha2AgaW5wdXQgZXZlbnQuIFRoaXMgQmVoYXZpb3IgbWFrZXMgc3VyZSB3ZSBjYXRjaFxuICAgKiB0aGF0IGBrZXlib2FyZC5rZXlkb3duYCBldmVudCBiZWZvcmVoYW5kIGFuZCByYWlzZSBhbiBgaW5zZXJ0LnNvZnQgYnJlYWtgIG1hbnVhbGx5LlxuICAgKi9cbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImtleWJvYXJkLmtleWRvd25cIixcbiAgICBndWFyZDogKHtcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4gZGVmYXVsdEtleWJvYXJkU2hvcnRjdXRzLmxpbmVCcmVhay5ndWFyZChldmVudC5vcmlnaW5FdmVudCksXG4gICAgYWN0aW9uczogWygpID0+IFtyYWlzZSh7XG4gICAgICB0eXBlOiBcImluc2VydC5zb2Z0IGJyZWFrXCJcbiAgICB9KV1dXG4gIH0pLFxuICAvKipcbiAgICogTWFudWFsIGhhbmRsaW5nIG9mIHVuZG8gc2hvcnRjdXRzLlxuICAgKi9cbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImtleWJvYXJkLmtleWRvd25cIixcbiAgICBndWFyZDogKHtcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4gZGVmYXVsdEtleWJvYXJkU2hvcnRjdXRzLmhpc3RvcnkudW5kby5ndWFyZChldmVudC5vcmlnaW5FdmVudCksXG4gICAgYWN0aW9uczogWygpID0+IFtyYWlzZSh7XG4gICAgICB0eXBlOiBcImhpc3RvcnkudW5kb1wiXG4gICAgfSldXVxuICB9KSxcbiAgLyoqXG4gICAqIE1hbnVhbCBoYW5kbGluZyBvZiByZWRvIHNob3J0Y3V0cy5cbiAgICovXG4gIGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJrZXlib2FyZC5rZXlkb3duXCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBldmVudFxuICAgIH0pID0+IGRlZmF1bHRLZXlib2FyZFNob3J0Y3V0cy5oaXN0b3J5LnJlZG8uZ3VhcmQoZXZlbnQub3JpZ2luRXZlbnQpLFxuICAgIGFjdGlvbnM6IFsoKSA9PiBbcmFpc2Uoe1xuICAgICAgdHlwZTogXCJoaXN0b3J5LnJlZG9cIlxuICAgIH0pXV1cbiAgfSksXG4gIC8qKlxuICAgKiBGaXggZWRnZSBjYXNlIHdoZXJlIFNoaWZ0K0Fycm93TGVmdCBkaWRuJ3QgcmVkdWNlIGEgc2VsZWN0aW9uIGhhbmdpbmdcbiAgICogb250byBhbiBlbXB0eSB0ZXh0IGJsb2NrLlxuICAgKi9cbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImtleWJvYXJkLmtleWRvd25cIixcbiAgICBndWFyZDogKHtcbiAgICAgIHNuYXBzaG90LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiB7XG4gICAgICBpZiAoIXNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uIHx8ICFzaGlmdExlZnQuZ3VhcmQoZXZlbnQub3JpZ2luRXZlbnQpKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBmb2N1c0Jsb2NrID0gZ2V0Rm9jdXNCbG9jayQxKHNuYXBzaG90KTtcbiAgICAgIGlmICghZm9jdXNCbG9jaylcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgcHJldmlvdXNCbG9jayA9IGdldFByZXZpb3VzQmxvY2soe1xuICAgICAgICAuLi5zbmFwc2hvdCxcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgICAgICBhbmNob3I6IHtcbiAgICAgICAgICAgICAgcGF0aDogZm9jdXNCbG9jay5wYXRoLFxuICAgICAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb2N1czoge1xuICAgICAgICAgICAgICBwYXRoOiBmb2N1c0Jsb2NrLnBhdGgsXG4gICAgICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcHJldmlvdXNCbG9jayAmJiBpc1RleHRCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBmb2N1c0Jsb2NrLm5vZGUpICYmIHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLm9mZnNldCA9PT0gMCAmJiBpc0VtcHR5VGV4dEJsb2NrKHNuYXBzaG90LmNvbnRleHQsIGZvY3VzQmxvY2subm9kZSkgPyB7XG4gICAgICAgIHByZXZpb3VzQmxvY2ssXG4gICAgICAgIHNlbGVjdGlvbjogc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb25cbiAgICAgIH0gOiAhMTtcbiAgICB9LFxuICAgIGFjdGlvbnM6IFsoe1xuICAgICAgc25hcHNob3RcbiAgICB9LCB7XG4gICAgICBwcmV2aW91c0Jsb2NrLFxuICAgICAgc2VsZWN0aW9uXG4gICAgfSkgPT4gW3JhaXNlKHtcbiAgICAgIHR5cGU6IFwic2VsZWN0XCIsXG4gICAgICBhdDoge1xuICAgICAgICBhbmNob3I6IHNlbGVjdGlvbi5hbmNob3IsXG4gICAgICAgIGZvY3VzOiBnZXRCbG9ja0VuZFBvaW50KHtcbiAgICAgICAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICAgIGJsb2NrOiBwcmV2aW91c0Jsb2NrXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSldXVxuICB9KVxuXSwgYWJzdHJhY3RMaXN0SXRlbUJlaGF2aW9ycyA9IFtkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImxpc3QgaXRlbS5hZGRcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4gc25hcHNob3QuY29udGV4dC5zY2hlbWEubGlzdHMuc29tZSgobGlzdCkgPT4gbGlzdC5uYW1lID09PSBldmVudC5saXN0SXRlbSkgPyB7XG4gICAgc2VsZWN0ZWRUZXh0QmxvY2tzOiBnZXRTZWxlY3RlZFRleHRCbG9ja3Moc25hcHNob3QpXG4gIH0gOiAhMSxcbiAgYWN0aW9uczogWyh7XG4gICAgZXZlbnRcbiAgfSwge1xuICAgIHNlbGVjdGVkVGV4dEJsb2Nrc1xuICB9KSA9PiBzZWxlY3RlZFRleHRCbG9ja3MubWFwKChibG9jaykgPT4gcmFpc2Uoe1xuICAgIHR5cGU6IFwiYmxvY2suc2V0XCIsXG4gICAgYXQ6IGJsb2NrLnBhdGgsXG4gICAgcHJvcHM6IHtcbiAgICAgIGxldmVsOiBibG9jay5ub2RlLmxldmVsID8/IDEsXG4gICAgICBsaXN0SXRlbTogZXZlbnQubGlzdEl0ZW1cbiAgICB9XG4gIH0pKV1cbn0pLCBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImxpc3QgaXRlbS5yZW1vdmVcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3RcbiAgfSkgPT4gKHtcbiAgICBzZWxlY3RlZFRleHRCbG9ja3M6IGdldFNlbGVjdGVkVGV4dEJsb2NrcyhzbmFwc2hvdClcbiAgfSksXG4gIGFjdGlvbnM6IFsoXywge1xuICAgIHNlbGVjdGVkVGV4dEJsb2Nrc1xuICB9KSA9PiBzZWxlY3RlZFRleHRCbG9ja3MubWFwKChibG9jaykgPT4gcmFpc2Uoe1xuICAgIHR5cGU6IFwiYmxvY2sudW5zZXRcIixcbiAgICBhdDogYmxvY2sucGF0aCxcbiAgICBwcm9wczogW1wibGV2ZWxcIiwgXCJsaXN0SXRlbVwiXVxuICB9KSldXG59KSwgZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJsaXN0IGl0ZW0udG9nZ2xlXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IGlzQWN0aXZlTGlzdEl0ZW0oZXZlbnQubGlzdEl0ZW0pKHNuYXBzaG90KSxcbiAgYWN0aW9uczogWyh7XG4gICAgZXZlbnRcbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcImxpc3QgaXRlbS5yZW1vdmVcIixcbiAgICBsaXN0SXRlbTogZXZlbnQubGlzdEl0ZW1cbiAgfSldXVxufSksIGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwibGlzdCBpdGVtLnRvZ2dsZVwiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9KSA9PiAhaXNBY3RpdmVMaXN0SXRlbShldmVudC5saXN0SXRlbSkoc25hcHNob3QpLFxuICBhY3Rpb25zOiBbKHtcbiAgICBldmVudFxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwibGlzdCBpdGVtLmFkZFwiLFxuICAgIGxpc3RJdGVtOiBldmVudC5saXN0SXRlbVxuICB9KV1dXG59KV0sIGFic3RyYWN0TW92ZUJlaGF2aW9ycyA9IFtkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcIm1vdmUuYmxvY2sgdXBcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHByZXZpb3VzQmxvY2sgPSBnZXRQcmV2aW91c0Jsb2NrKHtcbiAgICAgIC4uLnNuYXBzaG90LFxuICAgICAgY29udGV4dDoge1xuICAgICAgICAuLi5zbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICBzZWxlY3Rpb246IHtcbiAgICAgICAgICBhbmNob3I6IHtcbiAgICAgICAgICAgIHBhdGg6IGV2ZW50LmF0LFxuICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBmb2N1czoge1xuICAgICAgICAgICAgcGF0aDogZXZlbnQuYXQsXG4gICAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcHJldmlvdXNCbG9jayA/IHtcbiAgICAgIHByZXZpb3VzQmxvY2tcbiAgICB9IDogITE7XG4gIH0sXG4gIGFjdGlvbnM6IFsoe1xuICAgIGV2ZW50XG4gIH0sIHtcbiAgICBwcmV2aW91c0Jsb2NrXG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJtb3ZlLmJsb2NrXCIsXG4gICAgYXQ6IGV2ZW50LmF0LFxuICAgIHRvOiBwcmV2aW91c0Jsb2NrLnBhdGhcbiAgfSldXVxufSksIGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwibW92ZS5ibG9jayBkb3duXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IHtcbiAgICBjb25zdCBuZXh0QmxvY2sgPSBnZXROZXh0QmxvY2soe1xuICAgICAgLi4uc25hcHNob3QsXG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgICAgcGF0aDogZXZlbnQuYXQsXG4gICAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZvY3VzOiB7XG4gICAgICAgICAgICBwYXRoOiBldmVudC5hdCxcbiAgICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXh0QmxvY2sgPyB7XG4gICAgICBuZXh0QmxvY2tcbiAgICB9IDogITE7XG4gIH0sXG4gIGFjdGlvbnM6IFsoe1xuICAgIGV2ZW50XG4gIH0sIHtcbiAgICBuZXh0QmxvY2tcbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcIm1vdmUuYmxvY2tcIixcbiAgICBhdDogZXZlbnQuYXQsXG4gICAgdG86IG5leHRCbG9jay5wYXRoXG4gIH0pXV1cbn0pXSwgYWJzdHJhY3RTZWxlY3RCZWhhdmlvcnMgPSBbZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJzZWxlY3QuYmxvY2tcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4ge1xuICAgIGlmIChldmVudC5zZWxlY3QgIT09IFwiZW5kXCIpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgYmxvY2sgPSBnZXRGb2N1c0Jsb2NrJDEoe1xuICAgICAgLi4uc25hcHNob3QsXG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgICAgcGF0aDogZXZlbnQuYXQsXG4gICAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZvY3VzOiB7XG4gICAgICAgICAgICBwYXRoOiBldmVudC5hdCxcbiAgICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBibG9jayA/IHtcbiAgICAgIGJsb2NrRW5kUG9pbnQ6IGdldEJsb2NrRW5kUG9pbnQoe1xuICAgICAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICBibG9ja1xuICAgICAgfSlcbiAgICB9IDogITE7XG4gIH0sXG4gIGFjdGlvbnM6IFsoXywge1xuICAgIGJsb2NrRW5kUG9pbnRcbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcInNlbGVjdFwiLFxuICAgIGF0OiB7XG4gICAgICBhbmNob3I6IGJsb2NrRW5kUG9pbnQsXG4gICAgICBmb2N1czogYmxvY2tFbmRQb2ludFxuICAgIH1cbiAgfSldXVxufSksIGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwic2VsZWN0LmJsb2NrXCIsXG4gIGFjdGlvbnM6IFsoe1xuICAgIGV2ZW50XG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJzZWxlY3RcIixcbiAgICBhdDoge1xuICAgICAgYW5jaG9yOiB7XG4gICAgICAgIHBhdGg6IGV2ZW50LmF0LFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0sXG4gICAgICBmb2N1czoge1xuICAgICAgICBwYXRoOiBldmVudC5hdCxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9XG4gICAgfVxuICB9KV1dXG59KSwgZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJzZWxlY3QucHJldmlvdXMgYmxvY2tcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3RcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHByZXZpb3VzQmxvY2sgPSBnZXRQcmV2aW91c0Jsb2NrKHNuYXBzaG90KTtcbiAgICByZXR1cm4gcHJldmlvdXNCbG9jayA/IHtcbiAgICAgIHByZXZpb3VzQmxvY2tcbiAgICB9IDogITE7XG4gIH0sXG4gIGFjdGlvbnM6IFsoe1xuICAgIGV2ZW50XG4gIH0sIHtcbiAgICBwcmV2aW91c0Jsb2NrXG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJzZWxlY3QuYmxvY2tcIixcbiAgICBhdDogcHJldmlvdXNCbG9jay5wYXRoLFxuICAgIHNlbGVjdDogZXZlbnQuc2VsZWN0XG4gIH0pXV1cbn0pLCBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcInNlbGVjdC5uZXh0IGJsb2NrXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90XG4gIH0pID0+IHtcbiAgICBjb25zdCBuZXh0QmxvY2sgPSBnZXROZXh0QmxvY2soc25hcHNob3QpO1xuICAgIHJldHVybiBuZXh0QmxvY2sgPyB7XG4gICAgICBuZXh0QmxvY2tcbiAgICB9IDogITE7XG4gIH0sXG4gIGFjdGlvbnM6IFsoe1xuICAgIGV2ZW50XG4gIH0sIHtcbiAgICBuZXh0QmxvY2tcbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcInNlbGVjdC5ibG9ja1wiLFxuICAgIGF0OiBuZXh0QmxvY2sucGF0aCxcbiAgICBzZWxlY3Q6IGV2ZW50LnNlbGVjdFxuICB9KV1dXG59KV0sIGFic3RyYWN0U2VyaWFsaXplQmVoYXZpb3JzID0gW2RlZmluZUJlaGF2aW9yKHtcbiAgb246IFwic2VyaWFsaXplXCIsXG4gIGFjdGlvbnM6IFsoe1xuICAgIGV2ZW50XG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJzZXJpYWxpemUuZGF0YVwiLFxuICAgIG1pbWVUeXBlOiBcImFwcGxpY2F0aW9uL3gtcG9ydGFibGUtdGV4dFwiLFxuICAgIG9yaWdpbkV2ZW50OiBldmVudC5vcmlnaW5FdmVudFxuICB9KSwgcmFpc2Uoe1xuICAgIHR5cGU6IFwic2VyaWFsaXplLmRhdGFcIixcbiAgICBtaW1lVHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgb3JpZ2luRXZlbnQ6IGV2ZW50Lm9yaWdpbkV2ZW50XG4gIH0pLCByYWlzZSh7XG4gICAgdHlwZTogXCJzZXJpYWxpemUuZGF0YVwiLFxuICAgIG1pbWVUeXBlOiBcInRleHQvaHRtbFwiLFxuICAgIG9yaWdpbkV2ZW50OiBldmVudC5vcmlnaW5FdmVudFxuICB9KSwgcmFpc2Uoe1xuICAgIHR5cGU6IFwic2VyaWFsaXplLmRhdGFcIixcbiAgICBtaW1lVHlwZTogXCJ0ZXh0L3BsYWluXCIsXG4gICAgb3JpZ2luRXZlbnQ6IGV2ZW50Lm9yaWdpbkV2ZW50XG4gIH0pXV1cbn0pLCBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcInNlcmlhbGl6ZS5kYXRhXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IHtcbiAgICBjb25zdCBjb252ZXJ0ZXIgPSBzbmFwc2hvdC5jb250ZXh0LmNvbnZlcnRlcnMuZmluZCgoY29udmVydGVyMikgPT4gY29udmVydGVyMi5taW1lVHlwZSA9PT0gZXZlbnQubWltZVR5cGUpO1xuICAgIHJldHVybiBjb252ZXJ0ZXIgPyBjb252ZXJ0ZXIuc2VyaWFsaXplKHtcbiAgICAgIHNuYXBzaG90LFxuICAgICAgZXZlbnQ6IHtcbiAgICAgICAgdHlwZTogXCJzZXJpYWxpemVcIixcbiAgICAgICAgb3JpZ2luRXZlbnQ6IGV2ZW50Lm9yaWdpbkV2ZW50LnR5cGVcbiAgICAgIH1cbiAgICB9KSA6ICExO1xuICB9LFxuICBhY3Rpb25zOiBbKHtcbiAgICBldmVudFxuICB9LCBzZXJpYWxpemVFdmVudCkgPT4gW3JhaXNlKHtcbiAgICAuLi5zZXJpYWxpemVFdmVudCxcbiAgICBvcmlnaW5FdmVudDogZXZlbnQub3JpZ2luRXZlbnRcbiAgfSldXVxufSksIGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwic2VyaWFsaXphdGlvbi5zdWNjZXNzXCIsXG4gIGFjdGlvbnM6IFsoe1xuICAgIGV2ZW50XG4gIH0pID0+IFt7XG4gICAgdHlwZTogXCJlZmZlY3RcIixcbiAgICBlZmZlY3Q6ICgpID0+IHtcbiAgICAgIGV2ZW50Lm9yaWdpbkV2ZW50Lm9yaWdpbkV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKGV2ZW50Lm1pbWVUeXBlLCBldmVudC5kYXRhKTtcbiAgICB9XG4gIH1dXVxufSksIGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwic2VyaWFsaXphdGlvbi5mYWlsdXJlXCIsXG4gIGFjdGlvbnM6IFsoe1xuICAgIGV2ZW50XG4gIH0pID0+IFt7XG4gICAgdHlwZTogXCJlZmZlY3RcIixcbiAgICBlZmZlY3Q6ICgpID0+IHtcbiAgICAgIGNvbnNvbGUud2FybihgU2VyaWFsaXphdGlvbiBvZiAke2V2ZW50Lm1pbWVUeXBlfSBmYWlsZWQgd2l0aCByZWFzb24gXCIke2V2ZW50LnJlYXNvbn1cImApO1xuICAgIH1cbiAgfV1dXG59KV0sIGFic3RyYWN0U3BsaXRCZWhhdmlvcnMgPSBbXG4gIC8qKlxuICAgKiBZb3UgY2FuJ3Qgc3BsaXQgYW4gaW5saW5lIG9iamVjdC5cbiAgICovXG4gIGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJzcGxpdFwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgc25hcHNob3RcbiAgICB9KSA9PiBpc1NlbGVjdGlvbkNvbGxhcHNlZChzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbikgJiYgZ2V0Rm9jdXNJbmxpbmVPYmplY3Qoc25hcHNob3QpLFxuICAgIGFjdGlvbnM6IFtdXG4gIH0pLFxuICAvKipcbiAgICogWW91IGNhbid0IHNwbGl0IGEgYmxvY2sgb2JqZWN0LlxuICAgKi9cbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcInNwbGl0XCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBzbmFwc2hvdFxuICAgIH0pID0+IGlzU2VsZWN0aW9uQ29sbGFwc2VkKHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uKSAmJiBnZXRGb2N1c0Jsb2NrT2JqZWN0KHNuYXBzaG90KSxcbiAgICBhY3Rpb25zOiBbXVxuICB9KSxcbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcInNwbGl0XCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBzbmFwc2hvdFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uO1xuICAgICAgaWYgKCFzZWxlY3Rpb24gfHwgaXNTZWxlY3Rpb25Db2xsYXBzZWQoc2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3Qgc2VsZWN0aW9uU3RhcnRCbG9jayA9IGdldFNlbGVjdGlvblN0YXJ0QmxvY2skMShzbmFwc2hvdCksIHNlbGVjdGlvbkVuZEJsb2NrID0gZ2V0U2VsZWN0aW9uRW5kQmxvY2skMShzbmFwc2hvdCk7XG4gICAgICByZXR1cm4gIXNlbGVjdGlvblN0YXJ0QmxvY2sgfHwgIXNlbGVjdGlvbkVuZEJsb2NrID8gITEgOiAhaXNUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgc2VsZWN0aW9uU3RhcnRCbG9jay5ub2RlKSAmJiBpc1RleHRCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBzZWxlY3Rpb25FbmRCbG9jay5ub2RlKSA/IHtcbiAgICAgICAgc2VsZWN0aW9uXG4gICAgICB9IDogITE7XG4gICAgfSxcbiAgICBhY3Rpb25zOiBbKF8sIHtcbiAgICAgIHNlbGVjdGlvblxuICAgIH0pID0+IFtyYWlzZSh7XG4gICAgICB0eXBlOiBcImRlbGV0ZVwiLFxuICAgICAgYXQ6IHNlbGVjdGlvblxuICAgIH0pXV1cbiAgfSksXG4gIGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJzcGxpdFwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgc25hcHNob3RcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbjtcbiAgICAgIGlmICghc2VsZWN0aW9uIHx8IGlzU2VsZWN0aW9uQ29sbGFwc2VkKHNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvblN0YXJ0QmxvY2sgPSBnZXRTZWxlY3Rpb25TdGFydEJsb2NrJDEoc25hcHNob3QpLCBzZWxlY3Rpb25FbmRCbG9jayA9IGdldFNlbGVjdGlvbkVuZEJsb2NrJDEoc25hcHNob3QpO1xuICAgICAgaWYgKCFzZWxlY3Rpb25TdGFydEJsb2NrIHx8ICFzZWxlY3Rpb25FbmRCbG9jayB8fCBzZWxlY3Rpb25TdGFydEJsb2NrLm5vZGUuX2tleSA9PT0gc2VsZWN0aW9uRW5kQmxvY2subm9kZS5fa2V5KVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBzdGFydFBvaW50ID0gZ2V0U2VsZWN0aW9uU3RhcnRQb2ludChzZWxlY3Rpb24pLCBzdGFydEJsb2NrRW5kUG9pbnQgPSBnZXRCbG9ja0VuZFBvaW50KHtcbiAgICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgYmxvY2s6IHNlbGVjdGlvblN0YXJ0QmxvY2tcbiAgICAgIH0pLCBlbmRQb2ludCA9IGdldFNlbGVjdGlvbkVuZFBvaW50KHNlbGVjdGlvbiksIGVuZEJsb2NrU3RhcnRQb2ludCA9IGdldEJsb2NrU3RhcnRQb2ludCh7XG4gICAgICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgIGJsb2NrOiBzZWxlY3Rpb25FbmRCbG9ja1xuICAgICAgfSksIGJsb2Nrc0luQmV0d2VlbiA9IGdldFNlbGVjdGVkVmFsdWUoc25hcHNob3QpLmZpbHRlcigoYmxvY2spID0+IGJsb2NrLl9rZXkgIT09IHNlbGVjdGlvblN0YXJ0QmxvY2subm9kZS5fa2V5ICYmIGJsb2NrLl9rZXkgIT09IHNlbGVjdGlvbkVuZEJsb2NrLm5vZGUuX2tleSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydFBvaW50LFxuICAgICAgICBzdGFydEJsb2NrRW5kUG9pbnQsXG4gICAgICAgIGVuZFBvaW50LFxuICAgICAgICBlbmRCbG9ja1N0YXJ0UG9pbnQsXG4gICAgICAgIGJsb2Nrc0luQmV0d2VlblxuICAgICAgfTtcbiAgICB9LFxuICAgIGFjdGlvbnM6IFsoXywge1xuICAgICAgc3RhcnRQb2ludCxcbiAgICAgIHN0YXJ0QmxvY2tFbmRQb2ludCxcbiAgICAgIGVuZFBvaW50LFxuICAgICAgZW5kQmxvY2tTdGFydFBvaW50LFxuICAgICAgYmxvY2tzSW5CZXR3ZWVuXG4gICAgfSkgPT4gW3JhaXNlKHtcbiAgICAgIHR5cGU6IFwiZGVsZXRlXCIsXG4gICAgICBhdDoge1xuICAgICAgICBhbmNob3I6IHN0YXJ0UG9pbnQsXG4gICAgICAgIGZvY3VzOiBzdGFydEJsb2NrRW5kUG9pbnRcbiAgICAgIH1cbiAgICB9KSwgLi4uYmxvY2tzSW5CZXR3ZWVuLm1hcCgoYmxvY2spID0+IHJhaXNlKHtcbiAgICAgIHR5cGU6IFwiZGVsZXRlLmJsb2NrXCIsXG4gICAgICBhdDogW3tcbiAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgfV1cbiAgICB9KSksIHJhaXNlKHtcbiAgICAgIHR5cGU6IFwiZGVsZXRlXCIsXG4gICAgICBhdDoge1xuICAgICAgICBhbmNob3I6IGVuZEJsb2NrU3RhcnRQb2ludCxcbiAgICAgICAgZm9jdXM6IGVuZFBvaW50XG4gICAgICB9XG4gICAgfSldXVxuICB9KSxcbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcInNwbGl0XCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBzbmFwc2hvdFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uO1xuICAgICAgcmV0dXJuICFzZWxlY3Rpb24gfHwgaXNTZWxlY3Rpb25Db2xsYXBzZWQoc2VsZWN0aW9uKSA/ICExIDoge1xuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH07XG4gICAgfSxcbiAgICBhY3Rpb25zOiBbKF8sIHtcbiAgICAgIHNlbGVjdGlvblxuICAgIH0pID0+IFtyYWlzZSh7XG4gICAgICB0eXBlOiBcImRlbGV0ZVwiLFxuICAgICAgYXQ6IHNlbGVjdGlvblxuICAgIH0pLCByYWlzZSh7XG4gICAgICB0eXBlOiBcInNwbGl0XCJcbiAgICB9KV1dXG4gIH0pLFxuICBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwic3BsaXRcIixcbiAgICBndWFyZDogKHtcbiAgICAgIHNuYXBzaG90XG4gICAgfSkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb247XG4gICAgICBpZiAoIXNlbGVjdGlvbiB8fCAhaXNTZWxlY3Rpb25Db2xsYXBzZWQoc2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3Qgc2VsZWN0aW9uU3RhcnRQb2ludCA9IGdldFNlbGVjdGlvblN0YXJ0UG9pbnQoc2VsZWN0aW9uKSwgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayhzbmFwc2hvdCk7XG4gICAgICBpZiAoIWZvY3VzVGV4dEJsb2NrKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBibG9ja0VuZFBvaW50ID0gZ2V0QmxvY2tFbmRQb2ludCh7XG4gICAgICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgIGJsb2NrOiBmb2N1c1RleHRCbG9ja1xuICAgICAgfSksIG5ld1RleHRCbG9ja1NlbGVjdGlvbiA9IHtcbiAgICAgICAgYW5jaG9yOiBzZWxlY3Rpb25TdGFydFBvaW50LFxuICAgICAgICBmb2N1czogYmxvY2tFbmRQb2ludFxuICAgICAgfSwgbmV3VGV4dEJsb2NrID0gcGFyc2VCbG9jayh7XG4gICAgICAgIGJsb2NrOiBzbGljZVRleHRCbG9jayh7XG4gICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogbmV3VGV4dEJsb2NrU2VsZWN0aW9uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBibG9jazogZm9jdXNUZXh0QmxvY2subm9kZVxuICAgICAgICB9KSxcbiAgICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHJlbW92ZVVudXNlZE1hcmtEZWZzOiAhMCxcbiAgICAgICAgICB2YWxpZGF0ZUZpZWxkczogITFcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3VGV4dEJsb2NrID8ge1xuICAgICAgICBuZXdUZXh0QmxvY2ssXG4gICAgICAgIG5ld1RleHRCbG9ja1NlbGVjdGlvblxuICAgICAgfSA6ICExO1xuICAgIH0sXG4gICAgYWN0aW9uczogWyhfLCB7XG4gICAgICBuZXdUZXh0QmxvY2ssXG4gICAgICBuZXdUZXh0QmxvY2tTZWxlY3Rpb25cbiAgICB9KSA9PiBpc1NlbGVjdGlvbkNvbGxhcHNlZChuZXdUZXh0QmxvY2tTZWxlY3Rpb24pID8gW3JhaXNlKHtcbiAgICAgIHR5cGU6IFwiaW5zZXJ0LmJsb2NrXCIsXG4gICAgICBibG9jazogbmV3VGV4dEJsb2NrLFxuICAgICAgcGxhY2VtZW50OiBcImFmdGVyXCIsXG4gICAgICBzZWxlY3Q6IFwic3RhcnRcIlxuICAgIH0pXSA6IFtyYWlzZSh7XG4gICAgICB0eXBlOiBcImRlbGV0ZVwiLFxuICAgICAgYXQ6IG5ld1RleHRCbG9ja1NlbGVjdGlvblxuICAgIH0pLCByYWlzZSh7XG4gICAgICB0eXBlOiBcImluc2VydC5ibG9ja1wiLFxuICAgICAgYmxvY2s6IG5ld1RleHRCbG9jayxcbiAgICAgIHBsYWNlbWVudDogXCJhZnRlclwiLFxuICAgICAgc2VsZWN0OiBcInN0YXJ0XCJcbiAgICB9KV1dXG4gIH0pXG5dLCBhYnN0cmFjdFN0eWxlQmVoYXZpb3JzID0gW2RlZmluZUJlaGF2aW9yKHtcbiAgb246IFwic3R5bGUuYWRkXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90XG4gIH0pID0+ICh7XG4gICAgc2VsZWN0ZWRUZXh0QmxvY2tzOiBnZXRTZWxlY3RlZFRleHRCbG9ja3Moc25hcHNob3QpXG4gIH0pLFxuICBhY3Rpb25zOiBbKHtcbiAgICBldmVudFxuICB9LCB7XG4gICAgc2VsZWN0ZWRUZXh0QmxvY2tzXG4gIH0pID0+IHNlbGVjdGVkVGV4dEJsb2Nrcy5tYXAoKGJsb2NrKSA9PiByYWlzZSh7XG4gICAgdHlwZTogXCJibG9jay5zZXRcIixcbiAgICBhdDogYmxvY2sucGF0aCxcbiAgICBwcm9wczoge1xuICAgICAgc3R5bGU6IGV2ZW50LnN0eWxlXG4gICAgfVxuICB9KSldXG59KSwgZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJzdHlsZS5yZW1vdmVcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3RcbiAgfSkgPT4gKHtcbiAgICBzZWxlY3RlZFRleHRCbG9ja3M6IGdldFNlbGVjdGVkVGV4dEJsb2NrcyhzbmFwc2hvdClcbiAgfSksXG4gIGFjdGlvbnM6IFsoXywge1xuICAgIHNlbGVjdGVkVGV4dEJsb2Nrc1xuICB9KSA9PiBzZWxlY3RlZFRleHRCbG9ja3MubWFwKChibG9jaykgPT4gcmFpc2Uoe1xuICAgIHR5cGU6IFwiYmxvY2sudW5zZXRcIixcbiAgICBhdDogYmxvY2sucGF0aCxcbiAgICBwcm9wczogW1wic3R5bGVcIl1cbiAgfSkpXVxufSksIGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwic3R5bGUudG9nZ2xlXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IGlzQWN0aXZlU3R5bGUoZXZlbnQuc3R5bGUpKHNuYXBzaG90KSxcbiAgYWN0aW9uczogWyh7XG4gICAgZXZlbnRcbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcInN0eWxlLnJlbW92ZVwiLFxuICAgIHN0eWxlOiBldmVudC5zdHlsZVxuICB9KV1dXG59KSwgZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJzdHlsZS50b2dnbGVcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4gIWlzQWN0aXZlU3R5bGUoZXZlbnQuc3R5bGUpKHNuYXBzaG90KSxcbiAgYWN0aW9uczogWyh7XG4gICAgZXZlbnRcbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcInN0eWxlLmFkZFwiLFxuICAgIHN0eWxlOiBldmVudC5zdHlsZVxuICB9KV1dXG59KV0sIGFic3RyYWN0QmVoYXZpb3JzID0gW2RlZmluZUJlaGF2aW9yKHtcbiAgb246IFwiY2xpcGJvYXJkLmNvcHlcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3RcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGZvY3VzU3BhbiA9IGdldEZvY3VzU3BhbiQxKHNuYXBzaG90KSwgc2VsZWN0aW9uQ29sbGFwc2VkID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQkMShzbmFwc2hvdCk7XG4gICAgcmV0dXJuIGZvY3VzU3BhbiAmJiBzZWxlY3Rpb25Db2xsYXBzZWQ7XG4gIH0sXG4gIGFjdGlvbnM6IFtdXG59KSwgZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJjbGlwYm9hcmQuY29weVwiLFxuICBhY3Rpb25zOiBbKHtcbiAgICBldmVudFxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwic2VyaWFsaXplXCIsXG4gICAgb3JpZ2luRXZlbnQ6IGV2ZW50XG4gIH0pXV1cbn0pLCBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImNsaXBib2FyZC5jdXRcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3RcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGZvY3VzU3BhbiA9IGdldEZvY3VzU3BhbiQxKHNuYXBzaG90KSwgc2VsZWN0aW9uQ29sbGFwc2VkID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQkMShzbmFwc2hvdCk7XG4gICAgcmV0dXJuIGZvY3VzU3BhbiAmJiBzZWxlY3Rpb25Db2xsYXBzZWQ7XG4gIH0sXG4gIGFjdGlvbnM6IFtdXG59KSwgZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJjbGlwYm9hcmQuY3V0XCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90XG4gIH0pID0+IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uID8ge1xuICAgIHNlbGVjdGlvbjogc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb25cbiAgfSA6ICExLFxuICBhY3Rpb25zOiBbKHtcbiAgICBldmVudFxuICB9LCB7XG4gICAgc2VsZWN0aW9uXG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJzZXJpYWxpemVcIixcbiAgICBvcmlnaW5FdmVudDogZXZlbnRcbiAgfSksIHJhaXNlKHtcbiAgICB0eXBlOiBcImRlbGV0ZVwiLFxuICAgIGF0OiBzZWxlY3Rpb25cbiAgfSldXVxufSksIGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwiZHJhZy5kcmFnc3RhcnRcIixcbiAgYWN0aW9uczogWyh7XG4gICAgZXZlbnRcbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcInNlcmlhbGl6ZVwiLFxuICAgIG9yaWdpbkV2ZW50OiBldmVudFxuICB9KV1dXG59KSwgZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJjbGlwYm9hcmQucGFzdGVcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3RcbiAgfSkgPT4gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24gJiYgaXNTZWxlY3Rpb25FeHBhbmRlZChzbmFwc2hvdCkgPyB7XG4gICAgc2VsZWN0aW9uOiBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvblxuICB9IDogITEsXG4gIGFjdGlvbnM6IFsoe1xuICAgIGV2ZW50XG4gIH0sIHtcbiAgICBzZWxlY3Rpb25cbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcImRlbGV0ZVwiLFxuICAgIGF0OiBzZWxlY3Rpb25cbiAgfSksIHJhaXNlKHtcbiAgICB0eXBlOiBcImRlc2VyaWFsaXplXCIsXG4gICAgb3JpZ2luRXZlbnQ6IGV2ZW50XG4gIH0pXV1cbn0pLCBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImNsaXBib2FyZC5wYXN0ZVwiLFxuICBhY3Rpb25zOiBbKHtcbiAgICBldmVudFxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwiZGVzZXJpYWxpemVcIixcbiAgICBvcmlnaW5FdmVudDogZXZlbnRcbiAgfSldXVxufSksIGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwiaW5wdXQuKlwiLFxuICBhY3Rpb25zOiBbKHtcbiAgICBldmVudFxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwiZGVzZXJpYWxpemVcIixcbiAgICBvcmlnaW5FdmVudDogZXZlbnRcbiAgfSldXVxufSksIC4uLmFic3RyYWN0QW5ub3RhdGlvbkJlaGF2aW9ycywgLi4uYWJzdHJhY3REZWNvcmF0b3JCZWhhdmlvcnMsIC4uLmFic3RyYWN0RGVsZXRlQmVoYXZpb3JzLCAuLi5hYnN0cmFjdERlc2VyaWFsaXplQmVoYXZpb3JzLCAuLi5hYnN0cmFjdEluc2VydEJlaGF2aW9ycywgLi4uYWJzdHJhY3RLZXlib2FyZEJlaGF2aW9ycywgLi4uYWJzdHJhY3RMaXN0SXRlbUJlaGF2aW9ycywgLi4uYWJzdHJhY3RNb3ZlQmVoYXZpb3JzLCAuLi5hYnN0cmFjdFN0eWxlQmVoYXZpb3JzLCAuLi5hYnN0cmFjdFNlbGVjdEJlaGF2aW9ycywgLi4uYWJzdHJhY3RTZXJpYWxpemVCZWhhdmlvcnMsIC4uLmFic3RyYWN0U3BsaXRCZWhhdmlvcnNdO1xuZnVuY3Rpb24gaXNTeW50aGV0aWNCZWhhdmlvckV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiAhaXNDdXN0b21CZWhhdmlvckV2ZW50KGV2ZW50KSAmJiAhaXNOYXRpdmVCZWhhdmlvckV2ZW50KGV2ZW50KSAmJiAhaXNBYnN0cmFjdEJlaGF2aW9yRXZlbnQoZXZlbnQpO1xufVxuY29uc3QgYWJzdHJhY3RCZWhhdmlvckV2ZW50VHlwZXMgPSBbXCJhbm5vdGF0aW9uLnNldFwiLCBcImFubm90YXRpb24udG9nZ2xlXCIsIFwiZGVjb3JhdG9yLnRvZ2dsZVwiLCBcImRlbGV0ZS5iYWNrd2FyZFwiLCBcImRlbGV0ZS5ibG9ja1wiLCBcImRlbGV0ZS5jaGlsZFwiLCBcImRlbGV0ZS5mb3J3YXJkXCIsIFwiZGVsZXRlLnRleHRcIiwgXCJkZXNlcmlhbGl6ZVwiLCBcImRlc2VyaWFsaXplLmRhdGFcIiwgXCJkZXNlcmlhbGl6YXRpb24uc3VjY2Vzc1wiLCBcImRlc2VyaWFsaXphdGlvbi5mYWlsdXJlXCIsIFwiaW5zZXJ0LmJsb2Nrc1wiLCBcImluc2VydC5icmVha1wiLCBcImluc2VydC5pbmxpbmUgb2JqZWN0XCIsIFwiaW5zZXJ0LnNvZnQgYnJlYWtcIiwgXCJpbnNlcnQuc3BhblwiLCBcImxpc3QgaXRlbS5hZGRcIiwgXCJsaXN0IGl0ZW0ucmVtb3ZlXCIsIFwibGlzdCBpdGVtLnRvZ2dsZVwiLCBcIm1vdmUuYmxvY2sgZG93blwiLCBcIm1vdmUuYmxvY2sgdXBcIiwgXCJzZWxlY3QuYmxvY2tcIiwgXCJzZWxlY3QucHJldmlvdXMgYmxvY2tcIiwgXCJzZWxlY3QubmV4dCBibG9ja1wiLCBcInNlcmlhbGl6ZVwiLCBcInNlcmlhbGl6ZS5kYXRhXCIsIFwic2VyaWFsaXphdGlvbi5zdWNjZXNzXCIsIFwic2VyaWFsaXphdGlvbi5mYWlsdXJlXCIsIFwic3BsaXRcIiwgXCJzdHlsZS5hZGRcIiwgXCJzdHlsZS5yZW1vdmVcIiwgXCJzdHlsZS50b2dnbGVcIl07XG5mdW5jdGlvbiBpc0Fic3RyYWN0QmVoYXZpb3JFdmVudChldmVudCkge1xuICByZXR1cm4gYWJzdHJhY3RCZWhhdmlvckV2ZW50VHlwZXMuaW5jbHVkZXMoZXZlbnQudHlwZSk7XG59XG5jb25zdCBuYXRpdmVCZWhhdmlvckV2ZW50VHlwZXMgPSBbXCJjbGlwYm9hcmQuY29weVwiLCBcImNsaXBib2FyZC5jdXRcIiwgXCJjbGlwYm9hcmQucGFzdGVcIiwgXCJkcmFnLmRyYWdzdGFydFwiLCBcImRyYWcuZHJhZ1wiLCBcImRyYWcuZHJhZ2VuZFwiLCBcImRyYWcuZHJhZ2VudGVyXCIsIFwiZHJhZy5kcmFnb3ZlclwiLCBcImRyYWcuZHJhZ2xlYXZlXCIsIFwiZHJhZy5kcm9wXCIsIFwiaW5wdXQuKlwiLCBcImtleWJvYXJkLmtleWRvd25cIiwgXCJrZXlib2FyZC5rZXl1cFwiLCBcIm1vdXNlLmNsaWNrXCJdO1xuZnVuY3Rpb24gaXNOYXRpdmVCZWhhdmlvckV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBuYXRpdmVCZWhhdmlvckV2ZW50VHlwZXMuaW5jbHVkZXMoZXZlbnQudHlwZSk7XG59XG5mdW5jdGlvbiBpc0N1c3RvbUJlaGF2aW9yRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnR5cGUuc3RhcnRzV2l0aChcImN1c3RvbS5cIik7XG59XG5jb25zdCBkZWJ1ZyQ2ID0gZGVidWdXaXRoTmFtZShcImJlaGF2aW9yczpldmVudFwiKTtcbmZ1bmN0aW9uIGV2ZW50Q2F0ZWdvcnkoZXZlbnQpIHtcbiAgcmV0dXJuIGlzTmF0aXZlQmVoYXZpb3JFdmVudChldmVudCkgPyBcIm5hdGl2ZVwiIDogaXNBYnN0cmFjdEJlaGF2aW9yRXZlbnQoZXZlbnQpID8gXCJzeW50aGV0aWNcIiA6IGlzQ3VzdG9tQmVoYXZpb3JFdmVudChldmVudCkgPyBcImN1c3RvbVwiIDogXCJzeW50aGV0aWNcIjtcbn1cbmZ1bmN0aW9uIHBlcmZvcm1FdmVudCh7XG4gIG1vZGUsXG4gIGJlaGF2aW9ycyxcbiAgcmVtYWluaW5nRXZlbnRCZWhhdmlvcnMsXG4gIGV2ZW50LFxuICBlZGl0b3IsXG4gIGtleUdlbmVyYXRvcixcbiAgc2NoZW1hLFxuICBnZXRTbmFwc2hvdCxcbiAgbmF0aXZlRXZlbnQsXG4gIHNlbmRCYWNrXG59KSB7XG4gIG1vZGUgPT09IFwic2VuZFwiICYmICFpc05hdGl2ZUJlaGF2aW9yRXZlbnQoZXZlbnQpICYmIGNyZWF0ZVVuZG9TdGVwKGVkaXRvciksIGRlYnVnJDYoYCgke21vZGV9OiR7ZXZlbnRDYXRlZ29yeShldmVudCl9KWAsIEpTT04uc3RyaW5naWZ5KGV2ZW50LCBudWxsLCAyKSk7XG4gIGNvbnN0IGV2ZW50QmVoYXZpb3JzID0gWy4uLnJlbWFpbmluZ0V2ZW50QmVoYXZpb3JzLCAuLi5hYnN0cmFjdEJlaGF2aW9yc10uZmlsdGVyKChiZWhhdmlvcikgPT4ge1xuICAgIGlmIChiZWhhdmlvci5vbiA9PT0gXCIqXCIpXG4gICAgICByZXR1cm4gITA7XG4gICAgY29uc3QgW2xpc3RlbmVkTmFtZXNwYWNlXSA9IGJlaGF2aW9yLm9uLmluY2x1ZGVzKFwiKlwiKSAmJiBiZWhhdmlvci5vbi5pbmNsdWRlcyhcIi5cIikgPyBiZWhhdmlvci5vbi5zcGxpdChcIi5cIikgOiBbdm9pZCAwXSwgW2V2ZW50TmFtZXNwYWNlXSA9IGV2ZW50LnR5cGUuaW5jbHVkZXMoXCIuXCIpID8gZXZlbnQudHlwZS5zcGxpdChcIi5cIikgOiBbdm9pZCAwXTtcbiAgICByZXR1cm4gbGlzdGVuZWROYW1lc3BhY2UgIT09IHZvaWQgMCAmJiBldmVudE5hbWVzcGFjZSAhPT0gdm9pZCAwICYmIGxpc3RlbmVkTmFtZXNwYWNlID09PSBldmVudE5hbWVzcGFjZSB8fCBsaXN0ZW5lZE5hbWVzcGFjZSAhPT0gdm9pZCAwICYmIGV2ZW50TmFtZXNwYWNlID09PSB2b2lkIDAgJiYgbGlzdGVuZWROYW1lc3BhY2UgPT09IGV2ZW50LnR5cGUgPyAhMCA6IGJlaGF2aW9yLm9uID09PSBldmVudC50eXBlO1xuICB9KTtcbiAgaWYgKGV2ZW50QmVoYXZpb3JzLmxlbmd0aCA9PT0gMCAmJiBpc1N5bnRoZXRpY0JlaGF2aW9yRXZlbnQoZXZlbnQpKSB7XG4gICAgbmF0aXZlRXZlbnQ/LnByZXZlbnREZWZhdWx0KCksIG1vZGUgPT09IFwic2VuZFwiICYmIGNsZWFyVW5kb1N0ZXAoZWRpdG9yKSwgd2l0aFBlcmZvcm1pbmdCZWhhdmlvck9wZXJhdGlvbihlZGl0b3IsICgpID0+IHtcbiAgICAgIGRlYnVnJDYoYChleGVjdXRlOiR7ZXZlbnRDYXRlZ29yeShldmVudCl9KWAsIEpTT04uc3RyaW5naWZ5KGV2ZW50LCBudWxsLCAyKSksIHBlcmZvcm1PcGVyYXRpb24oe1xuICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAga2V5R2VuZXJhdG9yLFxuICAgICAgICAgIHNjaGVtYVxuICAgICAgICB9LFxuICAgICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgICBlZGl0b3JcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSksIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBndWFyZFNuYXBzaG90ID0gZ2V0U25hcHNob3QoKTtcbiAgbGV0IG5hdGl2ZUV2ZW50UHJldmVudGVkID0gITEsIGRlZmF1bHRCZWhhdmlvck92ZXJ3cml0dGVuID0gITEsIGV2ZW50QmVoYXZpb3JJbmRleCA9IC0xO1xuICBmb3IgKGNvbnN0IGV2ZW50QmVoYXZpb3Igb2YgZXZlbnRCZWhhdmlvcnMpIHtcbiAgICBldmVudEJlaGF2aW9ySW5kZXgrKztcbiAgICBsZXQgc2hvdWxkUnVuID0gITE7XG4gICAgdHJ5IHtcbiAgICAgIHNob3VsZFJ1biA9IGV2ZW50QmVoYXZpb3IuZ3VhcmQgPT09IHZvaWQgMCB8fCBldmVudEJlaGF2aW9yLmd1YXJkKHtcbiAgICAgICAgc25hcHNob3Q6IGd1YXJkU25hcHNob3QsXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBkb206IGNyZWF0ZUVkaXRvckRvbShzZW5kQmFjaywgZWRpdG9yKVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobmV3IEVycm9yKGBFdmFsdWF0aW5nIGd1YXJkIGZvciBcIiR7ZXZlbnQudHlwZX1cIiBmYWlsZWQgZHVlIHRvOiAke2Vycm9yLm1lc3NhZ2V9YCkpO1xuICAgIH1cbiAgICBpZiAoIXNob3VsZFJ1bilcbiAgICAgIGNvbnRpbnVlO1xuICAgIGRlZmF1bHRCZWhhdmlvck92ZXJ3cml0dGVuID0gITAsIGV2ZW50QmVoYXZpb3IuYWN0aW9ucy5sZW5ndGggPT09IDAgJiYgKG5hdGl2ZUV2ZW50UHJldmVudGVkID0gITApO1xuICAgIGxldCBhY3Rpb25TZXRJbmRleCA9IC0xO1xuICAgIGZvciAoY29uc3QgYWN0aW9uU2V0IG9mIGV2ZW50QmVoYXZpb3IuYWN0aW9ucykge1xuICAgICAgYWN0aW9uU2V0SW5kZXgrKztcbiAgICAgIGNvbnN0IGFjdGlvbnNTbmFwc2hvdCA9IGdldFNuYXBzaG90KCk7XG4gICAgICBsZXQgYWN0aW9ucyA9IFtdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYWN0aW9ucyA9IGFjdGlvblNldCh7XG4gICAgICAgICAgc25hcHNob3Q6IGFjdGlvbnNTbmFwc2hvdCxcbiAgICAgICAgICBldmVudCxcbiAgICAgICAgICBkb206IGNyZWF0ZUVkaXRvckRvbShzZW5kQmFjaywgZWRpdG9yKVxuICAgICAgICB9LCBzaG91bGRSdW4pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihuZXcgRXJyb3IoYEV2YWx1YXRpbmcgYWN0aW9ucyBmb3IgXCIke2V2ZW50LnR5cGV9XCIgZmFpbGVkIGR1ZSB0bzogJHtlcnJvci5tZXNzYWdlfWApKTtcbiAgICAgIH1cbiAgICAgIGlmIChhY3Rpb25zLmxlbmd0aCA9PT0gMClcbiAgICAgICAgY29udGludWU7XG4gICAgICBuYXRpdmVFdmVudFByZXZlbnRlZCA9IGFjdGlvbnMuc29tZSgoYWN0aW9uKSA9PiBhY3Rpb24udHlwZSA9PT0gXCJyYWlzZVwiIHx8IGFjdGlvbi50eXBlID09PSBcImV4ZWN1dGVcIikgfHwgIWFjdGlvbnMuc29tZSgoYWN0aW9uKSA9PiBhY3Rpb24udHlwZSA9PT0gXCJmb3J3YXJkXCIpO1xuICAgICAgbGV0IHVuZG9TdGVwQ3JlYXRlZCA9ICExO1xuICAgICAgYWN0aW9uU2V0SW5kZXggPiAwICYmIChjcmVhdGVVbmRvU3RlcChlZGl0b3IpLCB1bmRvU3RlcENyZWF0ZWQgPSAhMCksICF1bmRvU3RlcENyZWF0ZWQgJiYgYWN0aW9ucy5zb21lKChhY3Rpb24pID0+IGFjdGlvbi50eXBlID09PSBcImV4ZWN1dGVcIikgJiYgKGNyZWF0ZVVuZG9TdGVwKGVkaXRvciksIHVuZG9TdGVwQ3JlYXRlZCA9ICEwKTtcbiAgICAgIGNvbnN0IGFjdGlvblR5cGVzID0gYWN0aW9ucy5tYXAoKGFjdGlvbikgPT4gYWN0aW9uLnR5cGUpLCB1bmlxdWVBY3Rpb25UeXBlcyA9IG5ldyBTZXQoYWN0aW9uVHlwZXMpLCByYWlzZUdyb3VwID0gYWN0aW9uVHlwZXMubGVuZ3RoID4gMSAmJiB1bmlxdWVBY3Rpb25UeXBlcy5zaXplID09PSAxICYmIHVuaXF1ZUFjdGlvblR5cGVzLmhhcyhcInJhaXNlXCIpLCBleGVjdXRlR3JvdXAgPSBhY3Rpb25UeXBlcy5sZW5ndGggPiAxICYmIHVuaXF1ZUFjdGlvblR5cGVzLnNpemUgPT09IDEgJiYgdW5pcXVlQWN0aW9uVHlwZXMuaGFzKFwiZXhlY3V0ZVwiKTtcbiAgICAgIHdpdGhvdXROb3JtYWxpemluZ0NvbmRpdGlvbmFsKGVkaXRvciwgKCkgPT4gcmFpc2VHcm91cCB8fCBleGVjdXRlR3JvdXAsICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBhY3Rpb24gb2YgYWN0aW9ucykge1xuICAgICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gXCJlZmZlY3RcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYWN0aW9uLmVmZmVjdCh7XG4gICAgICAgICAgICAgICAgc2VuZDogc2VuZEJhY2tcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKG5ldyBFcnJvcihgRXhlY3V0aW5nIGVmZmVjdCBhcyBhIHJlc3VsdCBvZiBcIiR7ZXZlbnQudHlwZX1cIiBmYWlsZWQgZHVlIHRvOiAke2Vycm9yLm1lc3NhZ2V9YCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gXCJmb3J3YXJkXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ0V2ZW50QmVoYXZpb3JzMiA9IGV2ZW50QmVoYXZpb3JzLnNsaWNlKGV2ZW50QmVoYXZpb3JJbmRleCArIDEpO1xuICAgICAgICAgICAgcGVyZm9ybUV2ZW50KHtcbiAgICAgICAgICAgICAgbW9kZTogbW9kZSA9PT0gXCJleGVjdXRlXCIgPyBcImV4ZWN1dGVcIiA6IFwiZm9yd2FyZFwiLFxuICAgICAgICAgICAgICBiZWhhdmlvcnMsXG4gICAgICAgICAgICAgIHJlbWFpbmluZ0V2ZW50QmVoYXZpb3JzOiByZW1haW5pbmdFdmVudEJlaGF2aW9yczIsXG4gICAgICAgICAgICAgIGV2ZW50OiBhY3Rpb24uZXZlbnQsXG4gICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAga2V5R2VuZXJhdG9yLFxuICAgICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgICAgICAgc2VuZEJhY2tcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gXCJyYWlzZVwiKSB7XG4gICAgICAgICAgICBwZXJmb3JtRXZlbnQoe1xuICAgICAgICAgICAgICBtb2RlOiBtb2RlID09PSBcImV4ZWN1dGVcIiA/IFwiZXhlY3V0ZVwiIDogXCJyYWlzZVwiLFxuICAgICAgICAgICAgICBiZWhhdmlvcnMsXG4gICAgICAgICAgICAgIHJlbWFpbmluZ0V2ZW50QmVoYXZpb3JzOiBtb2RlID09PSBcImV4ZWN1dGVcIiA/IHJlbWFpbmluZ0V2ZW50QmVoYXZpb3JzIDogYmVoYXZpb3JzLFxuICAgICAgICAgICAgICBldmVudDogYWN0aW9uLmV2ZW50LFxuICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgIGtleUdlbmVyYXRvcixcbiAgICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgICAgICAgbmF0aXZlRXZlbnQsXG4gICAgICAgICAgICAgIHNlbmRCYWNrXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwZXJmb3JtRXZlbnQoe1xuICAgICAgICAgICAgbW9kZTogXCJleGVjdXRlXCIsXG4gICAgICAgICAgICBiZWhhdmlvcnMsXG4gICAgICAgICAgICByZW1haW5pbmdFdmVudEJlaGF2aW9yczogW10sXG4gICAgICAgICAgICBldmVudDogYWN0aW9uLmV2ZW50LFxuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAga2V5R2VuZXJhdG9yLFxuICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgICAgICBuYXRpdmVFdmVudDogdm9pZCAwLFxuICAgICAgICAgICAgc2VuZEJhY2tcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSksIHVuZG9TdGVwQ3JlYXRlZCAmJiBjbGVhclVuZG9TdGVwKGVkaXRvcik7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gICFkZWZhdWx0QmVoYXZpb3JPdmVyd3JpdHRlbiAmJiBpc1N5bnRoZXRpY0JlaGF2aW9yRXZlbnQoZXZlbnQpID8gKG5hdGl2ZUV2ZW50Py5wcmV2ZW50RGVmYXVsdCgpLCBtb2RlID09PSBcInNlbmRcIiAmJiBjbGVhclVuZG9TdGVwKGVkaXRvciksIHdpdGhQZXJmb3JtaW5nQmVoYXZpb3JPcGVyYXRpb24oZWRpdG9yLCAoKSA9PiB7XG4gICAgZGVidWckNihgKGV4ZWN1dGU6JHtldmVudENhdGVnb3J5KGV2ZW50KX0pYCwgSlNPTi5zdHJpbmdpZnkoZXZlbnQsIG51bGwsIDIpKSwgcGVyZm9ybU9wZXJhdGlvbih7XG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIGtleUdlbmVyYXRvcixcbiAgICAgICAgc2NoZW1hXG4gICAgICB9LFxuICAgICAgb3BlcmF0aW9uOiB7XG4gICAgICAgIC4uLmV2ZW50LFxuICAgICAgICBlZGl0b3JcbiAgICAgIH1cbiAgICB9KTtcbiAgfSksIGVkaXRvci5vbkNoYW5nZSgpKSA6IG5hdGl2ZUV2ZW50UHJldmVudGVkICYmIG5hdGl2ZUV2ZW50Py5wcmV2ZW50RGVmYXVsdCgpO1xufVxuZnVuY3Rpb24gc29ydEJ5UHJpb3JpdHkoaXRlbXMpIHtcbiAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IGl0ZW1zV2l0aFByaW9yaXR5ID0gaXRlbXMuZmlsdGVyKChpdGVtKSA9PiBpdGVtLnByaW9yaXR5ICE9PSB2b2lkIDApLCBpdGVtc1dpdGhvdXRQcmlvcml0eSA9IGl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gaXRlbS5wcmlvcml0eSA9PT0gdm9pZCAwKTtcbiAgaWYgKGl0ZW1zV2l0aFByaW9yaXR5Lmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gaXRlbXM7XG4gIGNvbnN0IGl0ZW1zQnlQcmlvcml0eUlkID0gbmV3IE1hcChpdGVtc1dpdGhQcmlvcml0eS5tYXAoKGl0ZW0pID0+IFtpdGVtLnByaW9yaXR5LmlkLCBpdGVtXSkpLCBncmFwaCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIGluRGVncmVlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZnVuY3Rpb24gZW5zdXJlTm9kZShpZCkge1xuICAgIGdyYXBoLmhhcyhpZCkgfHwgKGdyYXBoLnNldChpZCwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSksIGluRGVncmVlLnNldChpZCwgMCkpO1xuICB9XG4gIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtc1dpdGhQcmlvcml0eSkge1xuICAgIGNvbnN0IGlkID0gaXRlbS5wcmlvcml0eS5pZDtcbiAgICBlbnN1cmVOb2RlKGlkKTtcbiAgfVxuICBmdW5jdGlvbiBhZGRFZGdlKGZyb21JZCwgdG9JZCkge1xuICAgICFncmFwaC5oYXMoZnJvbUlkKSB8fCAhZ3JhcGguaGFzKHRvSWQpIHx8IChncmFwaC5nZXQoZnJvbUlkKT8uYWRkKHRvSWQpLCBpbkRlZ3JlZS5zZXQodG9JZCwgKGluRGVncmVlLmdldCh0b0lkKSA/PyAwKSArIDEpKTtcbiAgfVxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXNXaXRoUHJpb3JpdHkpIHtcbiAgICBjb25zdCBpZCA9IGl0ZW0ucHJpb3JpdHkuaWQsIHZpc2l0ZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGxldCByZWYgPSBpdGVtLnByaW9yaXR5LnJlZmVyZW5jZTtcbiAgICBmb3IgKDsgcmVmOyApIHtcbiAgICAgIGNvbnN0IHJlZklkID0gcmVmLnByaW9yaXR5LmlkO1xuICAgICAgaWYgKGVuc3VyZU5vZGUocmVmSWQpLCB2aXNpdGVkLmhhcyhyZWZJZCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNpcmN1bGFyIGRlcGVuZGVuY3kgZGV0ZWN0ZWQgaW4gcHJpb3JpdGllc1wiKTtcbiAgICAgIHZpc2l0ZWQuYWRkKHJlZklkKSwgcmVmLmltcG9ydGFuY2UgPT09IFwiaGlnaGVyXCIgPyBhZGRFZGdlKGlkLCByZWZJZCkgOiBhZGRFZGdlKHJlZklkLCBpZCksIHJlZiA9IHJlZi5wcmlvcml0eS5yZWZlcmVuY2U7XG4gICAgfVxuICB9XG4gIGNvbnN0IHF1ZXVlID0gW107XG4gIGZvciAoY29uc3QgW2lkLCBkZWdyZWVdIG9mIGluRGVncmVlKVxuICAgIGRlZ3JlZSA9PT0gMCAmJiBxdWV1ZS5wdXNoKGlkKTtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAoOyBxdWV1ZS5sZW5ndGggPiAwOyApIHtcbiAgICBjb25zdCBjdXJyZW50SWQgPSBxdWV1ZS5zaGlmdCgpLCBjdXJyZW50SXRlbSA9IGl0ZW1zQnlQcmlvcml0eUlkLmdldChjdXJyZW50SWQpO1xuICAgIGN1cnJlbnRJdGVtICYmIHJlc3VsdC5wdXNoKGN1cnJlbnRJdGVtKTtcbiAgICBmb3IgKGNvbnN0IG5laWdoYm9ySWQgb2YgZ3JhcGguZ2V0KGN1cnJlbnRJZCkgPz8gW10pIHtcbiAgICAgIGNvbnN0IG5ld0RlZ3JlZSA9IChpbkRlZ3JlZS5nZXQobmVpZ2hib3JJZCkgPz8gMCkgLSAxO1xuICAgICAgaW5EZWdyZWUuc2V0KG5laWdoYm9ySWQsIG5ld0RlZ3JlZSksIG5ld0RlZ3JlZSA9PT0gMCAmJiBxdWV1ZS5wdXNoKG5laWdoYm9ySWQpO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXNXaXRoUHJpb3JpdHkpXG4gICAgcmVzdWx0LmluY2x1ZGVzKGl0ZW0pIHx8IHJlc3VsdC5wdXNoKGl0ZW0pO1xuICByZXR1cm4gWy4uLnJlc3VsdCwgLi4uaXRlbXNXaXRob3V0UHJpb3JpdHldO1xufVxuZnVuY3Rpb24gY3JlYXRlRWRpdG9yU25hcHNob3Qoe1xuICBjb252ZXJ0ZXJzLFxuICBlZGl0b3IsXG4gIGtleUdlbmVyYXRvcixcbiAgcmVhZE9ubHksXG4gIHNjaGVtYVxufSkge1xuICBjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uID8gc2xhdGVSYW5nZVRvU2VsZWN0aW9uKHtcbiAgICBzY2hlbWEsXG4gICAgZWRpdG9yLFxuICAgIHJhbmdlOiBlZGl0b3Iuc2VsZWN0aW9uXG4gIH0pIDogbnVsbCwgY29udGV4dCA9IHtcbiAgICBjb252ZXJ0ZXJzLFxuICAgIGtleUdlbmVyYXRvcixcbiAgICByZWFkT25seSxcbiAgICBzY2hlbWEsXG4gICAgc2VsZWN0aW9uLFxuICAgIHZhbHVlOiBlZGl0b3IudmFsdWVcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBibG9ja0luZGV4TWFwOiBlZGl0b3IuYmxvY2tJbmRleE1hcCxcbiAgICBjb250ZXh0LFxuICAgIGRlY29yYXRvclN0YXRlOiBlZGl0b3IuZGVjb3JhdG9yU3RhdGVcbiAgfTtcbn1cbmNvbnN0IGRlYnVnJDUgPSBkZWJ1Z1dpdGhOYW1lKFwiZWRpdG9yIG1hY2hpbmVcIik7XG5mdW5jdGlvbiByZXJvdXRlRXh0ZXJuYWxCZWhhdmlvckV2ZW50KHtcbiAgZXZlbnQsXG4gIHNsYXRlRWRpdG9yXG59KSB7XG4gIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgIGNhc2UgXCJibHVyXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImJsdXJcIixcbiAgICAgICAgZWRpdG9yOiBzbGF0ZUVkaXRvclxuICAgICAgfTtcbiAgICBjYXNlIFwiZm9jdXNcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZm9jdXNcIixcbiAgICAgICAgZWRpdG9yOiBzbGF0ZUVkaXRvclxuICAgICAgfTtcbiAgICBjYXNlIFwiaW5zZXJ0LmJsb2NrIG9iamVjdFwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJpbnNlcnQuYmxvY2tcIixcbiAgICAgICAgICBibG9jazoge1xuICAgICAgICAgICAgX3R5cGU6IGV2ZW50LmJsb2NrT2JqZWN0Lm5hbWUsXG4gICAgICAgICAgICAuLi5ldmVudC5ibG9ja09iamVjdC52YWx1ZSA/PyB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcGxhY2VtZW50OiBldmVudC5wbGFjZW1lbnRcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yOiBzbGF0ZUVkaXRvclxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiBldmVudCxcbiAgICAgICAgZWRpdG9yOiBzbGF0ZUVkaXRvclxuICAgICAgfTtcbiAgfVxufVxuY29uc3QgZWRpdG9yTWFjaGluZSA9IHNldHVwKHtcbiAgdHlwZXM6IHtcbiAgICBjb250ZXh0OiB7fSxcbiAgICBldmVudHM6IHt9LFxuICAgIGVtaXR0ZWQ6IHt9LFxuICAgIGlucHV0OiB7fSxcbiAgICB0YWdzOiB7fVxuICB9LFxuICBhY3Rpb25zOiB7XG4gICAgXCJhZGQgYmVoYXZpb3IgdG8gY29udGV4dFwiOiBhc3NpZ24oe1xuICAgICAgYmVoYXZpb3JzOiAoe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBcImFkZCBiZWhhdmlvclwiKSwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWy4uLmNvbnRleHQuYmVoYXZpb3JzLCBldmVudC5iZWhhdmlvckNvbmZpZ10pKSxcbiAgICAgIGJlaGF2aW9yc1NvcnRlZDogITFcbiAgICB9KSxcbiAgICBcInJlbW92ZSBiZWhhdmlvciBmcm9tIGNvbnRleHRcIjogYXNzaWduKHtcbiAgICAgIGJlaGF2aW9yczogKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJyZW1vdmUgYmVoYXZpb3JcIiksIGNvbnRleHQuYmVoYXZpb3JzLmRlbGV0ZShldmVudC5iZWhhdmlvckNvbmZpZyksIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFsuLi5jb250ZXh0LmJlaGF2aW9yc10pKVxuICAgIH0pLFxuICAgIFwiZW1pdCBwYXRjaCBldmVudFwiOiBlbWl0KCh7XG4gICAgICBldmVudFxuICAgIH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJpbnRlcm5hbC5wYXRjaFwiKSwgZXZlbnQpKSxcbiAgICBcImVtaXQgbXV0YXRpb24gZXZlbnRcIjogZW1pdCgoe1xuICAgICAgZXZlbnRcbiAgICB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwibXV0YXRpb25cIiksIGV2ZW50KSksXG4gICAgXCJlbWl0IHJlYWQgb25seVwiOiBlbWl0KHtcbiAgICAgIHR5cGU6IFwicmVhZCBvbmx5XCJcbiAgICB9KSxcbiAgICBcImVtaXQgZWRpdGFibGVcIjogZW1pdCh7XG4gICAgICB0eXBlOiBcImVkaXRhYmxlXCJcbiAgICB9KSxcbiAgICBcImRlZmVyIGV2ZW50XCI6IGFzc2lnbih7XG4gICAgICBwZW5kaW5nRXZlbnRzOiAoe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBbXCJpbnRlcm5hbC5wYXRjaFwiLCBcIm11dGF0aW9uXCJdKSwgWy4uLmNvbnRleHQucGVuZGluZ0V2ZW50cywgZXZlbnRdKVxuICAgIH0pLFxuICAgIFwiZW1pdCBwZW5kaW5nIGV2ZW50c1wiOiBlbnF1ZXVlQWN0aW9ucygoe1xuICAgICAgY29udGV4dCxcbiAgICAgIGVucXVldWVcbiAgICB9KSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGNvbnRleHQucGVuZGluZ0V2ZW50cylcbiAgICAgICAgZW5xdWV1ZS5lbWl0KGV2ZW50KTtcbiAgICB9KSxcbiAgICBcImVtaXQgcmVhZHlcIjogZW1pdCh7XG4gICAgICB0eXBlOiBcInJlYWR5XCJcbiAgICB9KSxcbiAgICBcImNsZWFyIHBlbmRpbmcgZXZlbnRzXCI6IGFzc2lnbih7XG4gICAgICBwZW5kaW5nRXZlbnRzOiBbXVxuICAgIH0pLFxuICAgIFwiZGVmZXIgaW5jb21pbmcgcGF0Y2hlc1wiOiBhc3NpZ24oe1xuICAgICAgcGVuZGluZ0luY29taW5nUGF0Y2hlc0V2ZW50czogKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IGV2ZW50LnR5cGUgPT09IFwicGF0Y2hlc1wiID8gWy4uLmNvbnRleHQucGVuZGluZ0luY29taW5nUGF0Y2hlc0V2ZW50cywgZXZlbnRdIDogY29udGV4dC5wZW5kaW5nSW5jb21pbmdQYXRjaGVzRXZlbnRzXG4gICAgfSksXG4gICAgXCJlbWl0IHBlbmRpbmcgaW5jb21pbmcgcGF0Y2hlc1wiOiBlbnF1ZXVlQWN0aW9ucygoe1xuICAgICAgY29udGV4dCxcbiAgICAgIGVucXVldWVcbiAgICB9KSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGNvbnRleHQucGVuZGluZ0luY29taW5nUGF0Y2hlc0V2ZW50cylcbiAgICAgICAgZW5xdWV1ZS5lbWl0KGV2ZW50KTtcbiAgICB9KSxcbiAgICBcImNsZWFyIHBlbmRpbmcgaW5jb21pbmcgcGF0Y2hlc1wiOiBhc3NpZ24oe1xuICAgICAgcGVuZGluZ0luY29taW5nUGF0Y2hlc0V2ZW50czogW11cbiAgICB9KSxcbiAgICBcImhhbmRsZSBibHVyXCI6ICh7XG4gICAgICBldmVudFxuICAgIH0pID0+IHtcbiAgICAgIGFzc2VydEV2ZW50KGV2ZW50LCBcImJsdXJcIik7XG4gICAgICB0cnkge1xuICAgICAgICBSZWFjdEVkaXRvci5ibHVyKGV2ZW50LmVkaXRvcik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKG5ldyBFcnJvcihgRmFpbGVkIHRvIGJsdXIgZWRpdG9yOiAke2Vycm9yLm1lc3NhZ2V9YCkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCJoYW5kbGUgZm9jdXNcIjogKHtcbiAgICAgIGNvbnRleHRcbiAgICB9KSA9PiB7XG4gICAgICBpZiAoIWNvbnRleHQuc2xhdGVFZGl0b3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk5vIFNsYXRlIGVkaXRvciBmb3VuZCB0byBmb2N1c1wiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9IGNvbnRleHQuc2xhdGVFZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgICBSZWFjdEVkaXRvci5mb2N1cyhjb250ZXh0LnNsYXRlRWRpdG9yKSwgY3VycmVudFNlbGVjdGlvbiAmJiBUcmFuc2Zvcm1zLnNlbGVjdChjb250ZXh0LnNsYXRlRWRpdG9yLCBjdXJyZW50U2VsZWN0aW9uKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobmV3IEVycm9yKGBGYWlsZWQgdG8gZm9jdXMgZWRpdG9yOiAke2Vycm9yLm1lc3NhZ2V9YCkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCJoYW5kbGUgYmVoYXZpb3IgZXZlbnRcIjogKHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBldmVudCxcbiAgICAgIHNlbGZcbiAgICB9KSA9PiB7XG4gICAgICBhc3NlcnRFdmVudChldmVudCwgW1wiYmVoYXZpb3IgZXZlbnRcIl0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYmVoYXZpb3JzID0gWy4uLmNvbnRleHQuYmVoYXZpb3JzLnZhbHVlcygpXS5tYXAoKGNvbmZpZykgPT4gY29uZmlnLmJlaGF2aW9yKTtcbiAgICAgICAgcGVyZm9ybUV2ZW50KHtcbiAgICAgICAgICBtb2RlOiBcInNlbmRcIixcbiAgICAgICAgICBiZWhhdmlvcnMsXG4gICAgICAgICAgcmVtYWluaW5nRXZlbnRCZWhhdmlvcnM6IGJlaGF2aW9ycyxcbiAgICAgICAgICBldmVudDogZXZlbnQuYmVoYXZpb3JFdmVudCxcbiAgICAgICAgICBlZGl0b3I6IGV2ZW50LmVkaXRvcixcbiAgICAgICAgICBrZXlHZW5lcmF0b3I6IGNvbnRleHQua2V5R2VuZXJhdG9yLFxuICAgICAgICAgIHNjaGVtYTogY29udGV4dC5zY2hlbWEsXG4gICAgICAgICAgZ2V0U25hcHNob3Q6ICgpID0+IGNyZWF0ZUVkaXRvclNuYXBzaG90KHtcbiAgICAgICAgICAgIGNvbnZlcnRlcnM6IFsuLi5jb250ZXh0LmNvbnZlcnRlcnNdLFxuICAgICAgICAgICAgZWRpdG9yOiBldmVudC5lZGl0b3IsXG4gICAgICAgICAgICBrZXlHZW5lcmF0b3I6IGNvbnRleHQua2V5R2VuZXJhdG9yLFxuICAgICAgICAgICAgcmVhZE9ubHk6IHNlbGYuZ2V0U25hcHNob3QoKS5tYXRjaGVzKHtcbiAgICAgICAgICAgICAgXCJlZGl0IG1vZGVcIjogXCJyZWFkIG9ubHlcIlxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBzY2hlbWE6IGNvbnRleHQuc2NoZW1hXG4gICAgICAgICAgfSksXG4gICAgICAgICAgbmF0aXZlRXZlbnQ6IGV2ZW50Lm5hdGl2ZUV2ZW50LFxuICAgICAgICAgIHNlbmRCYWNrOiAoZXZlbnRTZW50QmFjaykgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50U2VudEJhY2sudHlwZSA9PT0gXCJzZXQgZHJhZyBnaG9zdFwiKSB7XG4gICAgICAgICAgICAgIHNlbGYuc2VuZChldmVudFNlbnRCYWNrKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5zZW5kKHJlcm91dGVFeHRlcm5hbEJlaGF2aW9yRXZlbnQoe1xuICAgICAgICAgICAgICBldmVudDogZXZlbnRTZW50QmFjayxcbiAgICAgICAgICAgICAgc2xhdGVFZGl0b3I6IGV2ZW50LmVkaXRvclxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKG5ldyBFcnJvcihgUmFpc2luZyBcIiR7ZXZlbnQuYmVoYXZpb3JFdmVudC50eXBlfVwiIGZhaWxlZCBkdWUgdG86ICR7ZXJyb3IubWVzc2FnZX1gKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBcInNvcnQgYmVoYXZpb3JzXCI6IGFzc2lnbih7XG4gICAgICBiZWhhdmlvcnM6ICh7XG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pID0+IGNvbnRleHQuYmVoYXZpb3JzU29ydGVkID8gY29udGV4dC5iZWhhdmlvcnMgOiBuZXcgU2V0KHNvcnRCeVByaW9yaXR5KFsuLi5jb250ZXh0LmJlaGF2aW9ycy52YWx1ZXMoKV0pKSxcbiAgICAgIGJlaGF2aW9yc1NvcnRlZDogITBcbiAgICB9KVxuICB9LFxuICBndWFyZHM6IHtcbiAgICBcInNsYXRlIGlzIGJ1c3lcIjogKHtcbiAgICAgIGNvbnRleHRcbiAgICB9KSA9PiBjb250ZXh0LnNsYXRlRWRpdG9yID8gY29udGV4dC5zbGF0ZUVkaXRvci5vcGVyYXRpb25zLmxlbmd0aCA+IDAgOiAhMVxuICB9XG59KS5jcmVhdGVNYWNoaW5lKHtcbiAgaWQ6IFwiZWRpdG9yXCIsXG4gIGNvbnRleHQ6ICh7XG4gICAgaW5wdXRcbiAgfSkgPT4gKHtcbiAgICBiZWhhdmlvcnM6IG5ldyBTZXQoY29yZUJlaGF2aW9yc0NvbmZpZyksXG4gICAgYmVoYXZpb3JzU29ydGVkOiAhMSxcbiAgICBjb252ZXJ0ZXJzOiBuZXcgU2V0KGlucHV0LmNvbnZlcnRlcnMgPz8gW10pLFxuICAgIGdldExlZ2FjeVNjaGVtYTogaW5wdXQuZ2V0TGVnYWN5U2NoZW1hLFxuICAgIGtleUdlbmVyYXRvcjogaW5wdXQua2V5R2VuZXJhdG9yLFxuICAgIHBlbmRpbmdFdmVudHM6IFtdLFxuICAgIHBlbmRpbmdJbmNvbWluZ1BhdGNoZXNFdmVudHM6IFtdLFxuICAgIHNjaGVtYTogaW5wdXQuc2NoZW1hLFxuICAgIHNlbGVjdGlvbjogbnVsbCxcbiAgICBpbml0aWFsUmVhZE9ubHk6IGlucHV0LnJlYWRPbmx5ID8/ICExLFxuICAgIG1heEJsb2NrczogaW5wdXQubWF4QmxvY2tzLFxuICAgIGluaXRpYWxWYWx1ZTogaW5wdXQuaW5pdGlhbFZhbHVlXG4gIH0pLFxuICBvbjoge1xuICAgIFwiYWRkIGJlaGF2aW9yXCI6IHtcbiAgICAgIGFjdGlvbnM6IFwiYWRkIGJlaGF2aW9yIHRvIGNvbnRleHRcIlxuICAgIH0sXG4gICAgXCJyZW1vdmUgYmVoYXZpb3JcIjoge1xuICAgICAgYWN0aW9uczogXCJyZW1vdmUgYmVoYXZpb3IgZnJvbSBjb250ZXh0XCJcbiAgICB9LFxuICAgIFwidXBkYXRlIG1heEJsb2Nrc1wiOiB7XG4gICAgICBhY3Rpb25zOiBhc3NpZ24oe1xuICAgICAgICBtYXhCbG9ja3M6ICh7XG4gICAgICAgICAgZXZlbnRcbiAgICAgICAgfSkgPT4gZXZlbnQubWF4QmxvY2tzXG4gICAgICB9KVxuICAgIH0sXG4gICAgXCJ1cGRhdGUgc2VsZWN0aW9uXCI6IHtcbiAgICAgIGFjdGlvbnM6IFthc3NpZ24oe1xuICAgICAgICBzZWxlY3Rpb246ICh7XG4gICAgICAgICAgZXZlbnRcbiAgICAgICAgfSkgPT4gZXZlbnQuc2VsZWN0aW9uXG4gICAgICB9KSwgZW1pdCgoe1xuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gKHtcbiAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgIHR5cGU6IFwic2VsZWN0aW9uXCJcbiAgICAgIH0pKV1cbiAgICB9LFxuICAgIFwic2V0IGRyYWcgZ2hvc3RcIjoge1xuICAgICAgYWN0aW9uczogYXNzaWduKHtcbiAgICAgICAgZHJhZ0dob3N0OiAoe1xuICAgICAgICAgIGV2ZW50XG4gICAgICAgIH0pID0+IGV2ZW50Lmdob3N0XG4gICAgICB9KVxuICAgIH1cbiAgfSxcbiAgdHlwZTogXCJwYXJhbGxlbFwiLFxuICBzdGF0ZXM6IHtcbiAgICBcImVkaXQgbW9kZVwiOiB7XG4gICAgICBpbml0aWFsOiBcInJlYWQgb25seVwiLFxuICAgICAgc3RhdGVzOiB7XG4gICAgICAgIFwicmVhZCBvbmx5XCI6IHtcbiAgICAgICAgICBpbml0aWFsOiBcImRldGVybWluZSBpbml0aWFsIGVkaXQgbW9kZVwiLFxuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBcImJlaGF2aW9yIGV2ZW50XCI6IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogW1wic29ydCBiZWhhdmlvcnNcIiwgXCJoYW5kbGUgYmVoYXZpb3IgZXZlbnRcIl0sXG4gICAgICAgICAgICAgIGd1YXJkOiAoe1xuICAgICAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICAgIH0pID0+IGV2ZW50LmJlaGF2aW9yRXZlbnQudHlwZSA9PT0gXCJjbGlwYm9hcmQuY29weVwiIHx8IGV2ZW50LmJlaGF2aW9yRXZlbnQudHlwZSA9PT0gXCJtb3VzZS5jbGlja1wiIHx8IGV2ZW50LmJlaGF2aW9yRXZlbnQudHlwZSA9PT0gXCJzZXJpYWxpemVcIiB8fCBldmVudC5iZWhhdmlvckV2ZW50LnR5cGUgPT09IFwic2VyaWFsaXphdGlvbi5mYWlsdXJlXCIgfHwgZXZlbnQuYmVoYXZpb3JFdmVudC50eXBlID09PSBcInNlcmlhbGl6YXRpb24uc3VjY2Vzc1wiIHx8IGV2ZW50LmJlaGF2aW9yRXZlbnQudHlwZSA9PT0gXCJzZWxlY3RcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3RhdGVzOiB7XG4gICAgICAgICAgICBcImRldGVybWluZSBpbml0aWFsIGVkaXQgbW9kZVwiOiB7XG4gICAgICAgICAgICAgIGVudHJ5OiBbKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRlYnVnJDUoXCJlbnRyeTogZWRpdCBtb2RlLT5yZWFkIG9ubHktPmRldGVybWluZSBpbml0aWFsIGVkaXQgbW9kZVwiKTtcbiAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgIGV4aXQ6IFsoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVidWckNShcImV4aXQ6IGVkaXQgbW9kZS0+cmVhZCBvbmx5LT5kZXRlcm1pbmUgaW5pdGlhbCBlZGl0IG1vZGVcIik7XG4gICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgIFwiZG9uZSBzeW5jaW5nIHZhbHVlXCI6IFt7XG4gICAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiI2VkaXRvci5lZGl0IG1vZGUucmVhZCBvbmx5LnJlYWQgb25seVwiLFxuICAgICAgICAgICAgICAgICAgZ3VhcmQ6ICh7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICAgICAgICAgIH0pID0+IGNvbnRleHQuaW5pdGlhbFJlYWRPbmx5XG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBcIiNlZGl0b3IuZWRpdCBtb2RlLmVkaXRhYmxlXCJcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJyZWFkIG9ubHlcIjoge1xuICAgICAgICAgICAgICBlbnRyeTogWygpID0+IHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyQ1KFwiZW50cnk6IGVkaXQgbW9kZS0+cmVhZCBvbmx5LT5yZWFkIG9ubHlcIik7XG4gICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICBleGl0OiBbKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRlYnVnJDUoXCJleGl0OiBlZGl0IG1vZGUtPnJlYWQgb25seS0+cmVhZCBvbmx5XCIpO1xuICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBcInVwZGF0ZSByZWFkT25seVwiOiB7XG4gICAgICAgICAgICAgICAgICBndWFyZDogKHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgICAgIH0pID0+ICFldmVudC5yZWFkT25seSxcbiAgICAgICAgICAgICAgICAgIHRhcmdldDogXCIjZWRpdG9yLmVkaXQgbW9kZS5lZGl0YWJsZVwiLFxuICAgICAgICAgICAgICAgICAgYWN0aW9uczogW1wiZW1pdCBlZGl0YWJsZVwiXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZWRpdGFibGU6IHtcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgXCJ1cGRhdGUgcmVhZE9ubHlcIjoge1xuICAgICAgICAgICAgICBndWFyZDogKHtcbiAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgICB9KSA9PiBldmVudC5yZWFkT25seSxcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcIiNlZGl0b3IuZWRpdCBtb2RlLnJlYWQgb25seS5yZWFkIG9ubHlcIixcbiAgICAgICAgICAgICAgYWN0aW9uczogW1wiZW1pdCByZWFkIG9ubHlcIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImJlaGF2aW9yIGV2ZW50XCI6IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogW1wic29ydCBiZWhhdmlvcnNcIiwgXCJoYW5kbGUgYmVoYXZpb3IgZXZlbnRcIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBibHVyOiB7XG4gICAgICAgICAgICAgIGFjdGlvbnM6IFwiaGFuZGxlIGJsdXJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvY3VzOiB7XG4gICAgICAgICAgICAgIHRhcmdldDogXCIuZm9jdXNpbmdcIixcbiAgICAgICAgICAgICAgYWN0aW9uczogW2Fzc2lnbih7XG4gICAgICAgICAgICAgICAgc2xhdGVFZGl0b3I6ICh7XG4gICAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgICAgIH0pID0+IGV2ZW50LmVkaXRvclxuICAgICAgICAgICAgICB9KV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGluaXRpYWw6IFwiaWRsZVwiLFxuICAgICAgICAgIHN0YXRlczoge1xuICAgICAgICAgICAgaWRsZToge1xuICAgICAgICAgICAgICBlbnRyeTogWygpID0+IHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyQ1KFwiZW50cnk6IGVkaXQgbW9kZS0+ZWRpdGFibGUtPmlkbGVcIik7XG4gICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICBleGl0OiBbKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRlYnVnJDUoXCJleGl0OiBlZGl0IG1vZGUtPmVkaXRhYmxlLWlkbGVcIik7XG4gICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgIGRyYWdzdGFydDoge1xuICAgICAgICAgICAgICAgICAgYWN0aW9uczogW2Fzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgIGludGVybmFsRHJhZzogKHtcbiAgICAgICAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgICAgICAgICB9KSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogZXZlbnQub3JpZ2luXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICB9KV0sXG4gICAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiZHJhZ2dpbmcgaW50ZXJuYWxseVwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9jdXNpbmc6IHtcbiAgICAgICAgICAgICAgaW5pdGlhbDogXCJjaGVja2luZyBpZiBidXN5XCIsXG4gICAgICAgICAgICAgIHN0YXRlczoge1xuICAgICAgICAgICAgICAgIFwiY2hlY2tpbmcgaWYgYnVzeVwiOiB7XG4gICAgICAgICAgICAgICAgICBlbnRyeTogWygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWckNShcImVudHJ5OiBlZGl0IG1vZGUtPmVkaXRhYmxlLT5mb2N1c2luZy0+Y2hlY2tpbmcgaWYgYnVzeVwiKTtcbiAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgICAgZXhpdDogWygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWckNShcImV4aXQ6IGVkaXQgbW9kZS0+ZWRpdGFibGUtPmZvY3VzaW5nLT5jaGVja2luZyBpZiBidXN5XCIpO1xuICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgICBhbHdheXM6IFt7XG4gICAgICAgICAgICAgICAgICAgIGd1YXJkOiBcInNsYXRlIGlzIGJ1c3lcIixcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBcImJ1c3lcIlxuICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiI2VkaXRvci5lZGl0IG1vZGUuZWRpdGFibGUuaWRsZVwiLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJoYW5kbGUgZm9jdXNcIl1cbiAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBidXN5OiB7XG4gICAgICAgICAgICAgICAgICBlbnRyeTogWygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWckNShcImVudHJ5OiBlZGl0IG1vZGUtPmVkaXRhYmxlLT5mb2N1c2luZy1idXN5XCIpO1xuICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgICBleGl0OiBbKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyQ1KFwiZXhpdDogZWRpdCBtb2RlLT5lZGl0YWJsZS0+Zm9jdXNpbmctPmJ1c3lcIik7XG4gICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICAgIGFmdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgIDEwOiB7XG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBcImNoZWNraW5nIGlmIGJ1c3lcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJkcmFnZ2luZyBpbnRlcm5hbGx5XCI6IHtcbiAgICAgICAgICAgICAgZW50cnk6IFsoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVidWckNShcImVudHJ5OiBlZGl0IG1vZGUtPmVkaXRhYmxlLT5kcmFnZ2luZyBpbnRlcm5hbGx5XCIpO1xuICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgZXhpdDogWygpID0+IHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyQ1KFwiZXhpdDogZWRpdCBtb2RlLT5lZGl0YWJsZS0+ZHJhZ2dpbmcgaW50ZXJuYWxseVwiKTtcbiAgICAgICAgICAgICAgfSwgKHtcbiAgICAgICAgICAgICAgICBjb250ZXh0XG4gICAgICAgICAgICAgIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5kcmFnR2hvc3QpXG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRyYWdHaG9zdC5wYXJlbnROb2RlPy5yZW1vdmVDaGlsZChjb250ZXh0LmRyYWdHaG9zdCk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKG5ldyBFcnJvcihgUmVtb3ZpbmcgdGhlIGRyYWcgZ2hvc3QgZmFpbGVkIGR1ZSB0bzogJHtlcnJvci5tZXNzYWdlfWApKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgYXNzaWduKHtcbiAgICAgICAgICAgICAgICBkcmFnR2hvc3Q6IHZvaWQgMFxuICAgICAgICAgICAgICB9KSwgYXNzaWduKHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbERyYWc6IHZvaWQgMFxuICAgICAgICAgICAgICB9KV0sXG4gICAgICAgICAgICAgIHRhZ3M6IFtcImRyYWdnaW5nIGludGVybmFsbHlcIl0sXG4gICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgZHJhZ2VuZDoge1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBcImlkbGVcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZHJvcDoge1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBcImlkbGVcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgc2V0dXA6IHtcbiAgICAgIGluaXRpYWw6IFwic2V0dGluZyB1cFwiLFxuICAgICAgc3RhdGVzOiB7XG4gICAgICAgIFwic2V0dGluZyB1cFwiOiB7XG4gICAgICAgICAgZW50cnk6IFsoKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyQ1KFwiZW50cnk6IHNldHVwLT5zZXR0aW5nIHVwXCIpO1xuICAgICAgICAgIH1dLFxuICAgICAgICAgIGV4aXQ6IFsoKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyQ1KFwiZXhpdDogc2V0dXAtPnNldHRpbmcgdXBcIik7XG4gICAgICAgICAgfSwgXCJlbWl0IHJlYWR5XCIsIFwiZW1pdCBwZW5kaW5nIGluY29taW5nIHBhdGNoZXNcIiwgXCJjbGVhciBwZW5kaW5nIGluY29taW5nIHBhdGNoZXNcIl0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIFwiaW50ZXJuYWwucGF0Y2hcIjoge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBcImRlZmVyIGV2ZW50XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtdXRhdGlvbjoge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBcImRlZmVyIGV2ZW50XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImRvbmUgc3luY2luZyB2YWx1ZVwiOiB7XG4gICAgICAgICAgICAgIHRhcmdldDogXCJzZXQgdXBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdGNoZXM6IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogW1wiZGVmZXIgaW5jb21pbmcgcGF0Y2hlc1wiXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJzZXQgdXBcIjoge1xuICAgICAgICAgIHR5cGU6IFwicGFyYWxsZWxcIixcbiAgICAgICAgICBzdGF0ZXM6IHtcbiAgICAgICAgICAgIFwidmFsdWUgc3luY1wiOiB7XG4gICAgICAgICAgICAgIGluaXRpYWw6IFwiaWRsZVwiLFxuICAgICAgICAgICAgICBzdGF0ZXM6IHtcbiAgICAgICAgICAgICAgICBpZGxlOiB7XG4gICAgICAgICAgICAgICAgICBlbnRyeTogWygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWckNShcImVudHJ5OiBzZXR1cC0+c2V0IHVwLT52YWx1ZSBzeW5jLT5pZGxlXCIpO1xuICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgICBleGl0OiBbKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyQ1KFwiZXhpdDogc2V0dXAtPnNldCB1cC0+dmFsdWUgc3luYy0+aWRsZVwiKTtcbiAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hlczoge1xuICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IFtlbWl0KCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgICAgICAgICAgIH0pID0+IGV2ZW50KV1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJzeW5jaW5nIHZhbHVlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IFwic3luY2luZyB2YWx1ZVwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwic3luY2luZyB2YWx1ZVwiOiB7XG4gICAgICAgICAgICAgICAgICBlbnRyeTogWygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWckNShcImVudHJ5OiBzZXR1cC0+c2V0IHVwLT52YWx1ZSBzeW5jLT5zeW5jaW5nIHZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgICBleGl0OiBbKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyQ1KFwiZXhpdDogc2V0dXAtPnNldCB1cC0+dmFsdWUgc3luYy0+c3luY2luZyB2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICAgIH0sIFwiZW1pdCBwZW5kaW5nIGluY29taW5nIHBhdGNoZXNcIiwgXCJjbGVhciBwZW5kaW5nIGluY29taW5nIHBhdGNoZXNcIl0sXG4gICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICBwYXRjaGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogW1wiZGVmZXIgaW5jb21pbmcgcGF0Y2hlc1wiXVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcImRvbmUgc3luY2luZyB2YWx1ZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBcImlkbGVcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd3JpdGluZzoge1xuICAgICAgICAgICAgICBpbml0aWFsOiBcInByaXN0aW5lXCIsXG4gICAgICAgICAgICAgIHN0YXRlczoge1xuICAgICAgICAgICAgICAgIHByaXN0aW5lOiB7XG4gICAgICAgICAgICAgICAgICBpbml0aWFsOiBcImlkbGVcIixcbiAgICAgICAgICAgICAgICAgIHN0YXRlczoge1xuICAgICAgICAgICAgICAgICAgICBpZGxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgZW50cnk6IFsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZyQ1KFwiZW50cnk6IHNldHVwLT5zZXQgdXAtPndyaXRpbmctPnByaXN0aW5lLT5pZGxlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgICAgICAgIGV4aXQ6IFsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZyQ1KFwiZXhpdDogc2V0dXAtPnNldCB1cC0+d3JpdGluZy0+cHJpc3RpbmUtPmlkbGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6aW5nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogXCJub3JtYWxpemluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJpbnRlcm5hbC5wYXRjaFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IFwiZGVmZXIgZXZlbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBcIiNlZGl0b3Iuc2V0dXAuc2V0IHVwLndyaXRpbmcuZGlydHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IFwiZGVmZXIgZXZlbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBcIiNlZGl0b3Iuc2V0dXAuc2V0IHVwLndyaXRpbmcuZGlydHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXppbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgICBlbnRyeTogWygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnJDUoXCJlbnRyeTogc2V0dXAtPnNldCB1cC0+d3JpdGluZy0+cHJpc3RpbmUtPm5vcm1hbGl6aW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgICAgICAgIGV4aXQ6IFsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZyQ1KFwiZXhpdDogc2V0dXAtPnNldCB1cC0+d3JpdGluZy0+cHJpc3RpbmUtPm5vcm1hbGl6aW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImRvbmUgbm9ybWFsaXppbmdcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiaWRsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJpbnRlcm5hbC5wYXRjaFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IFwiZGVmZXIgZXZlbnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IFwiZGVmZXIgZXZlbnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGlydHk6IHtcbiAgICAgICAgICAgICAgICAgIGVudHJ5OiBbKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyQ1KFwiZW50cnk6IHNldHVwLT5zZXQgdXAtPndyaXRpbmctPmRpcnR5XCIpO1xuICAgICAgICAgICAgICAgICAgfSwgXCJlbWl0IHBlbmRpbmcgZXZlbnRzXCIsIFwiY2xlYXIgcGVuZGluZyBldmVudHNcIl0sXG4gICAgICAgICAgICAgICAgICBleGl0OiBbKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyQ1KFwiZXhpdDogc2V0dXAtPnNldCB1cC0+d3JpdGluZy0+ZGlydHlcIik7XG4gICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiaW50ZXJuYWwucGF0Y2hcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IFwiZW1pdCBwYXRjaCBldmVudFwiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogXCJlbWl0IG11dGF0aW9uIGV2ZW50XCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSksIGRlYnVnJDQgPSBkZWJ1Z1dpdGhOYW1lKFwibXV0YXRpb24tbWFjaGluZVwiKSwgbXV0YXRpb25NYWNoaW5lID0gc2V0dXAoe1xuICB0eXBlczoge1xuICAgIGNvbnRleHQ6IHt9LFxuICAgIGV2ZW50czoge30sXG4gICAgaW5wdXQ6IHt9LFxuICAgIGVtaXR0ZWQ6IHt9XG4gIH0sXG4gIGFjdGlvbnM6IHtcbiAgICBcImFzc2lnbiByZWFkT25seVwiOiBhc3NpZ24oe1xuICAgICAgcmVhZE9ubHk6ICh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiBldmVudC50eXBlID09PSBcInVwZGF0ZSByZWFkT25seVwiID8gZXZlbnQucmVhZE9ubHkgOiBjb250ZXh0LnJlYWRPbmx5XG4gICAgfSksXG4gICAgXCJlbWl0IHBhdGNoXCI6IGVtaXQoKHtcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBcInBhdGNoXCIpLCB7XG4gICAgICB0eXBlOiBcInBhdGNoXCIsXG4gICAgICBwYXRjaDogZXZlbnQucGF0Y2hcbiAgICB9KSksXG4gICAgXCJlbWl0IGhhcyBwZW5kaW5nIG11dGF0aW9uc1wiOiBlbWl0KHtcbiAgICAgIHR5cGU6IFwiaGFzIHBlbmRpbmcgbXV0YXRpb25zXCJcbiAgICB9KSxcbiAgICBcImVtaXQgbXV0YXRpb25zXCI6IGVucXVldWVBY3Rpb25zKCh7XG4gICAgICBjb250ZXh0LFxuICAgICAgZW5xdWV1ZVxuICAgIH0pID0+IHtcbiAgICAgIGZvciAoY29uc3QgYnVsayBvZiBjb250ZXh0LnBlbmRpbmdNdXRhdGlvbnMpXG4gICAgICAgIGVucXVldWUuZW1pdCh7XG4gICAgICAgICAgdHlwZTogXCJtdXRhdGlvblwiLFxuICAgICAgICAgIHBhdGNoZXM6IGJ1bGsucGF0Y2hlcyxcbiAgICAgICAgICBzbmFwc2hvdDogYnVsay52YWx1ZVxuICAgICAgICB9KTtcbiAgICB9KSxcbiAgICBcImNsZWFyIHBlbmRpbmcgbXV0YXRpb25zXCI6IGFzc2lnbih7XG4gICAgICBwZW5kaW5nTXV0YXRpb25zOiBbXVxuICAgIH0pLFxuICAgIFwiZGVmZXIgbXV0YXRpb25cIjogYXNzaWduKHtcbiAgICAgIHBlbmRpbmdNdXRhdGlvbnM6ICh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiB7XG4gICAgICAgIGlmIChhc3NlcnRFdmVudChldmVudCwgXCJwYXRjaFwiKSwgY29udGV4dC5wZW5kaW5nTXV0YXRpb25zLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgIG9wZXJhdGlvbklkOiBldmVudC5vcGVyYXRpb25JZCxcbiAgICAgICAgICAgIHZhbHVlOiBldmVudC52YWx1ZSxcbiAgICAgICAgICAgIHBhdGNoZXM6IFtldmVudC5wYXRjaF1cbiAgICAgICAgICB9XTtcbiAgICAgICAgY29uc3QgbGFzdEJ1bGsgPSBjb250ZXh0LnBlbmRpbmdNdXRhdGlvbnMuYXQoLTEpO1xuICAgICAgICByZXR1cm4gbGFzdEJ1bGsgJiYgbGFzdEJ1bGsub3BlcmF0aW9uSWQgPT09IGV2ZW50Lm9wZXJhdGlvbklkID8gY29udGV4dC5wZW5kaW5nTXV0YXRpb25zLnNsaWNlKDAsIC0xKS5jb25jYXQoe1xuICAgICAgICAgIHZhbHVlOiBldmVudC52YWx1ZSxcbiAgICAgICAgICBvcGVyYXRpb25JZDogbGFzdEJ1bGsub3BlcmF0aW9uSWQsXG4gICAgICAgICAgcGF0Y2hlczogWy4uLmxhc3RCdWxrLnBhdGNoZXMsIGV2ZW50LnBhdGNoXVxuICAgICAgICB9KSA6IGNvbnRleHQucGVuZGluZ011dGF0aW9ucy5jb25jYXQoe1xuICAgICAgICAgIHZhbHVlOiBldmVudC52YWx1ZSxcbiAgICAgICAgICBvcGVyYXRpb25JZDogZXZlbnQub3BlcmF0aW9uSWQsXG4gICAgICAgICAgcGF0Y2hlczogW2V2ZW50LnBhdGNoXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KSxcbiAgICBcImNsZWFyIHBlbmRpbmcgcGF0Y2ggZXZlbnRzXCI6IGFzc2lnbih7XG4gICAgICBwZW5kaW5nUGF0Y2hFdmVudHM6IFtdXG4gICAgfSksXG4gICAgXCJkZWZlciBwYXRjaFwiOiBhc3NpZ24oe1xuICAgICAgcGVuZGluZ1BhdGNoRXZlbnRzOiAoe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gZXZlbnQudHlwZSA9PT0gXCJwYXRjaFwiID8gWy4uLmNvbnRleHQucGVuZGluZ1BhdGNoRXZlbnRzLCBldmVudF0gOiBjb250ZXh0LnBlbmRpbmdQYXRjaEV2ZW50c1xuICAgIH0pLFxuICAgIFwiZW1pdCBwZW5kaW5nIHBhdGNoIGV2ZW50c1wiOiBlbnF1ZXVlQWN0aW9ucygoe1xuICAgICAgY29udGV4dCxcbiAgICAgIGVucXVldWVcbiAgICB9KSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGNvbnRleHQucGVuZGluZ1BhdGNoRXZlbnRzKVxuICAgICAgICBlbnF1ZXVlLmVtaXQoZXZlbnQpO1xuICAgIH0pXG4gIH0sXG4gIGFjdG9yczoge1xuICAgIFwidHlwZSBsaXN0ZW5lclwiOiBmcm9tQ2FsbGJhY2soKHtcbiAgICAgIGlucHV0LFxuICAgICAgc2VuZEJhY2tcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBvcmlnaW5hbEFwcGx5ID0gaW5wdXQuc2xhdGVFZGl0b3IuYXBwbHk7XG4gICAgICByZXR1cm4gaW5wdXQuc2xhdGVFZGl0b3IuYXBwbHkgPSAob3ApID0+IHtcbiAgICAgICAgb3AudHlwZSA9PT0gXCJpbnNlcnRfdGV4dFwiIHx8IG9wLnR5cGUgPT09IFwicmVtb3ZlX3RleHRcIiA/IHNlbmRCYWNrKHtcbiAgICAgICAgICB0eXBlOiBcInR5cGluZ1wiXG4gICAgICAgIH0pIDogc2VuZEJhY2soe1xuICAgICAgICAgIHR5cGU6IFwibm90IHR5cGluZ1wiXG4gICAgICAgIH0pLCBvcmlnaW5hbEFwcGx5KG9wKTtcbiAgICAgIH0sICgpID0+IHtcbiAgICAgICAgaW5wdXQuc2xhdGVFZGl0b3IuYXBwbHkgPSBvcmlnaW5hbEFwcGx5O1xuICAgICAgfTtcbiAgICB9KSxcbiAgICBcIm11dGF0aW9uIGludGVydmFsXCI6IGZyb21DYWxsYmFjaygoe1xuICAgICAgc2VuZEJhY2tcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgc2VuZEJhY2soe1xuICAgICAgICAgIHR5cGU6IFwiZW1pdCBjaGFuZ2VzXCJcbiAgICAgICAgfSk7XG4gICAgICB9LCBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIgPyAyNTAgOiAxZTMpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICB9O1xuICAgIH0pXG4gIH0sXG4gIGd1YXJkczoge1xuICAgIFwiaXMgcmVhZC1vbmx5XCI6ICh7XG4gICAgICBjb250ZXh0XG4gICAgfSkgPT4gY29udGV4dC5yZWFkT25seSxcbiAgICBcInNsYXRlIGlzIG5vcm1hbGl6aW5nXCI6ICh7XG4gICAgICBjb250ZXh0XG4gICAgfSkgPT4gRWRpdG9yLmlzTm9ybWFsaXppbmcoY29udGV4dC5zbGF0ZUVkaXRvcilcbiAgfSxcbiAgZGVsYXlzOiB7XG4gICAgXCJ0eXBlIGRlYm91bmNlXCI6IDI1MFxuICB9XG59KS5jcmVhdGVNYWNoaW5lKHtcbiAgaWQ6IFwibXV0YXRpb25cIixcbiAgY29udGV4dDogKHtcbiAgICBpbnB1dFxuICB9KSA9PiAoe1xuICAgIHBlbmRpbmdNdXRhdGlvbnM6IFtdLFxuICAgIHBlbmRpbmdQYXRjaEV2ZW50czogW10sXG4gICAgcmVhZE9ubHk6IGlucHV0LnJlYWRPbmx5LFxuICAgIHNjaGVtYTogaW5wdXQuc2NoZW1hLFxuICAgIHNsYXRlRWRpdG9yOiBpbnB1dC5zbGF0ZUVkaXRvclxuICB9KSxcbiAgb246IHtcbiAgICBcInVwZGF0ZSByZWFkT25seVwiOiB7XG4gICAgICBhY3Rpb25zOiBbXCJhc3NpZ24gcmVhZE9ubHlcIl1cbiAgICB9XG4gIH0sXG4gIHR5cGU6IFwicGFyYWxsZWxcIixcbiAgc3RhdGVzOiB7XG4gICAgdHlwaW5nOiB7XG4gICAgICBpbml0aWFsOiBcImlkbGVcIixcbiAgICAgIGludm9rZToge1xuICAgICAgICBzcmM6IFwidHlwZSBsaXN0ZW5lclwiLFxuICAgICAgICBpbnB1dDogKHtcbiAgICAgICAgICBjb250ZXh0XG4gICAgICAgIH0pID0+ICh7XG4gICAgICAgICAgc2xhdGVFZGl0b3I6IGNvbnRleHQuc2xhdGVFZGl0b3JcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICBzdGF0ZXM6IHtcbiAgICAgICAgaWRsZToge1xuICAgICAgICAgIGVudHJ5OiBbKCkgPT4ge1xuICAgICAgICAgICAgZGVidWckNChcImVudHJ5OiB0eXBpbmctPmlkbGVcIik7XG4gICAgICAgICAgfV0sXG4gICAgICAgICAgZXhpdDogWygpID0+IHtcbiAgICAgICAgICAgIGRlYnVnJDQoXCJleGl0OiB0eXBpbmctPmlkbGVcIiksIGRlYnVnJDQoXCJlbnRyeTogdHlwaW5nLT50eXBpbmdcIik7XG4gICAgICAgICAgfV0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIHR5cGluZzoge1xuICAgICAgICAgICAgICB0YXJnZXQ6IFwidHlwaW5nXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHR5cGluZzoge1xuICAgICAgICAgIGFmdGVyOiB7XG4gICAgICAgICAgICBcInR5cGUgZGVib3VuY2VcIjoge1xuICAgICAgICAgICAgICB0YXJnZXQ6IFwiaWRsZVwiLFxuICAgICAgICAgICAgICBhY3Rpb25zOiBbcmFpc2UkMSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJlbWl0IGNoYW5nZXNcIlxuICAgICAgICAgICAgICB9KSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRlYnVnJDQoXCJleGl0OiB0eXBpbmctPnR5cGluZ1wiKTtcbiAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBcIm5vdCB0eXBpbmdcIjoge1xuICAgICAgICAgICAgICB0YXJnZXQ6IFwiaWRsZVwiLFxuICAgICAgICAgICAgICBhY3Rpb25zOiBbcmFpc2UkMSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJlbWl0IGNoYW5nZXNcIlxuICAgICAgICAgICAgICB9KV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0eXBpbmc6IHtcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcInR5cGluZ1wiLFxuICAgICAgICAgICAgICByZWVudGVyOiAhMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbXV0YXRpb25zOiB7XG4gICAgICBpbml0aWFsOiBcImlkbGVcIixcbiAgICAgIHN0YXRlczoge1xuICAgICAgICBpZGxlOiB7XG4gICAgICAgICAgZW50cnk6IFsoKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyQ0KFwiZW50cnk6IG11dGF0aW9ucy0+aWRsZVwiKTtcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBleGl0OiBbKCkgPT4ge1xuICAgICAgICAgICAgZGVidWckNChcImV4aXQ6IG11dGF0aW9ucy0+aWRsZVwiKTtcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgcGF0Y2g6IFt7XG4gICAgICAgICAgICAgIGd1YXJkOiBcImlzIHJlYWQtb25seVwiLFxuICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJkZWZlciBwYXRjaFwiLCBcImRlZmVyIG11dGF0aW9uXCJdLFxuICAgICAgICAgICAgICB0YXJnZXQ6IFwiaGFzIHBlbmRpbmcgbXV0YXRpb25zXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgYWN0aW9uczogW1wiZW1pdCBwYXRjaFwiLCBcImRlZmVyIG11dGF0aW9uXCJdLFxuICAgICAgICAgICAgICB0YXJnZXQ6IFwiaGFzIHBlbmRpbmcgbXV0YXRpb25zXCJcbiAgICAgICAgICAgIH1dXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImhhcyBwZW5kaW5nIG11dGF0aW9uc1wiOiB7XG4gICAgICAgICAgZW50cnk6IFsoKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyQ0KFwiZW50cnk6IG11dGF0aW9ucy0+aGFzIHBlbmRpbmcgbXV0YXRpb25zXCIpO1xuICAgICAgICAgIH0sIFwiZW1pdCBoYXMgcGVuZGluZyBtdXRhdGlvbnNcIl0sXG4gICAgICAgICAgZXhpdDogWygpID0+IHtcbiAgICAgICAgICAgIGRlYnVnJDQoXCJleGl0OiBtdXRhdGlvbnMtPmhhcyBwZW5kaW5nIG11dGF0aW9uc1wiKTtcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBpbnZva2U6IHtcbiAgICAgICAgICAgIHNyYzogXCJtdXRhdGlvbiBpbnRlcnZhbFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgXCJlbWl0IGNoYW5nZXNcIjoge1xuICAgICAgICAgICAgICBndWFyZDogYW5kKFtub3QoXCJpcyByZWFkLW9ubHlcIiksIFwic2xhdGUgaXMgbm9ybWFsaXppbmdcIl0pLFxuICAgICAgICAgICAgICB0YXJnZXQ6IFwiaWRsZVwiLFxuICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJlbWl0IHBlbmRpbmcgcGF0Y2ggZXZlbnRzXCIsIFwiY2xlYXIgcGVuZGluZyBwYXRjaCBldmVudHNcIiwgXCJlbWl0IG11dGF0aW9uc1wiLCBcImNsZWFyIHBlbmRpbmcgbXV0YXRpb25zXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF0Y2g6IFt7XG4gICAgICAgICAgICAgIGd1YXJkOiBcImlzIHJlYWQtb25seVwiLFxuICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJkZWZlciBwYXRjaFwiLCBcImRlZmVyIG11dGF0aW9uXCJdXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGFjdGlvbnM6IFtcImVtaXQgcGF0Y2hcIiwgXCJkZWZlciBtdXRhdGlvblwiXVxuICAgICAgICAgICAgfV1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pLCBkZWJ1ZyQzID0gZGVidWdXaXRoTmFtZShcIkFQSTplZGl0YWJsZVwiKTtcbmZ1bmN0aW9uIGNyZWF0ZUVkaXRhYmxlQVBJKGVkaXRvciwgZWRpdG9yQWN0b3IpIHtcbiAgY29uc3QgdHlwZXMgPSBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hO1xuICByZXR1cm4ge1xuICAgIGZvY3VzOiAoKSA9PiB7XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJmb2N1c1wiLFxuICAgICAgICBlZGl0b3JcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgYmx1cjogKCkgPT4ge1xuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmx1clwiLFxuICAgICAgICBlZGl0b3JcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdG9nZ2xlTWFyazogKG1hcmspID0+IHtcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImRlY29yYXRvci50b2dnbGVcIixcbiAgICAgICAgICBkZWNvcmF0b3I6IG1hcmtcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHRvZ2dsZUxpc3Q6IChsaXN0SXRlbSkgPT4ge1xuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwibGlzdCBpdGVtLnRvZ2dsZVwiLFxuICAgICAgICAgIGxpc3RJdGVtXG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSxcbiAgICB0b2dnbGVCbG9ja1N0eWxlOiAoc3R5bGUpID0+IHtcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcInN0eWxlLnRvZ2dsZVwiLFxuICAgICAgICAgIHN0eWxlXG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSxcbiAgICBpc01hcmtBY3RpdmU6IChtYXJrKSA9PiB7XG4gICAgICBjb25zdCBzbmFwc2hvdCA9IGdldEVkaXRvclNuYXBzaG90KHtcbiAgICAgICAgZWRpdG9yQWN0b3JTbmFwc2hvdDogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKSxcbiAgICAgICAgc2xhdGVFZGl0b3JJbnN0YW5jZTogZWRpdG9yXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBnZXRBY3RpdmVEZWNvcmF0b3JzKHNuYXBzaG90KS5pbmNsdWRlcyhtYXJrKTtcbiAgICB9LFxuICAgIG1hcmtzOiAoKSA9PiB7XG4gICAgICBjb25zdCBzbmFwc2hvdCA9IGdldEVkaXRvclNuYXBzaG90KHtcbiAgICAgICAgZWRpdG9yQWN0b3JTbmFwc2hvdDogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKSxcbiAgICAgICAgc2xhdGVFZGl0b3JJbnN0YW5jZTogZWRpdG9yXG4gICAgICB9KSwgYWN0aXZlQW5ub3RhdGlvbnMgPSBnZXRBY3RpdmVBbm5vdGF0aW9uc01hcmtzKHNuYXBzaG90KSwgYWN0aXZlRGVjb3JhdG9ycyA9IGdldEFjdGl2ZURlY29yYXRvcnMoc25hcHNob3QpO1xuICAgICAgcmV0dXJuIFsuLi5hY3RpdmVBbm5vdGF0aW9ucywgLi4uYWN0aXZlRGVjb3JhdG9yc107XG4gICAgfSxcbiAgICB1bmRvOiAoKSA9PiB7XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJoaXN0b3J5LnVuZG9cIlxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3JcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcmVkbzogKCkgPT4ge1xuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwiaGlzdG9yeS5yZWRvXCJcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNlbGVjdDogKHNlbGVjdGlvbikgPT4ge1xuICAgICAgY29uc3Qgc2xhdGVTZWxlY3Rpb24gPSB0b1NsYXRlUmFuZ2Uoe1xuICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgc2NoZW1hOiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLFxuICAgICAgICAgIHZhbHVlOiBlZGl0b3IudmFsdWUsXG4gICAgICAgICAgc2VsZWN0aW9uXG4gICAgICAgIH0sXG4gICAgICAgIGJsb2NrSW5kZXhNYXA6IGVkaXRvci5ibG9ja0luZGV4TWFwXG4gICAgICB9KTtcbiAgICAgIHNsYXRlU2VsZWN0aW9uID8gVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzbGF0ZVNlbGVjdGlvbikgOiBUcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvciksIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgIH0sXG4gICAgZm9jdXNCbG9jazogKCkgPT4ge1xuICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBOb2RlLmRlc2NlbmRhbnQoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGguc2xpY2UoMCwgMSkpO1xuICAgICAgICBpZiAoYmxvY2spXG4gICAgICAgICAgcmV0dXJuIGZyb21TbGF0ZVZhbHVlKFtibG9ja10sIHR5cGVzLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKVswXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGZvY3VzQ2hpbGQ6ICgpID0+IHtcbiAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gTm9kZS5kZXNjZW5kYW50KGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLnNsaWNlKDAsIDEpKTtcbiAgICAgICAgaWYgKGJsb2NrICYmIGVkaXRvci5pc1RleHRCbG9jayhibG9jaykpXG4gICAgICAgICAgcmV0dXJuIGZyb21TbGF0ZVZhbHVlKFtibG9ja10sIHR5cGVzLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKVswXS5jaGlsZHJlbltlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMV1dO1xuICAgICAgfVxuICAgIH0sXG4gICAgaW5zZXJ0Q2hpbGQ6ICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHR5cGUubmFtZSAhPT0gdHlwZXMuc3Bhbi5uYW1lKVxuICAgICAgICByZXR1cm4gZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW5zZXJ0LmlubGluZSBvYmplY3RcIixcbiAgICAgICAgICAgIGlubGluZU9iamVjdDoge1xuICAgICAgICAgICAgICBuYW1lOiB0eXBlLm5hbWUsXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlZGl0b3JcbiAgICAgICAgfSksIGVkaXRvci5zZWxlY3Rpb24gPyBzbGF0ZVJhbmdlVG9TZWxlY3Rpb24oe1xuICAgICAgICAgIHNjaGVtYTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYSxcbiAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgcmFuZ2U6IGVkaXRvci5zZWxlY3Rpb25cbiAgICAgICAgfSk/LmZvY3VzLnBhdGggPz8gW10gOiBbXTtcbiAgICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGVkaXRvciBoYXMgbm8gc2VsZWN0aW9uXCIpO1xuICAgICAgY29uc3QgW2ZvY3VzQmxvY2tdID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGguc2xpY2UoMCwgMSksXG4gICAgICAgIG1hdGNoOiAobikgPT4gbi5fdHlwZSA9PT0gdHlwZXMuYmxvY2submFtZVxuICAgICAgfSkpWzBdIHx8IFt2b2lkIDBdO1xuICAgICAgaWYgKCFmb2N1c0Jsb2NrKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBmb2N1c2VkIHRleHQgYmxvY2tcIik7XG4gICAgICBpZiAodHlwZS5uYW1lICE9PSB0eXBlcy5zcGFuLm5hbWUgJiYgIXR5cGVzLmlubGluZU9iamVjdHMuc29tZSgodCkgPT4gdC5uYW1lID09PSB0eXBlLm5hbWUpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIHR5cGUgY2Fubm90IGJlIGluc2VydGVkIGFzIGEgY2hpbGQgdG8gYSB0ZXh0IGJsb2NrXCIpO1xuICAgICAgY29uc3QgY2hpbGQgPSB0b1NsYXRlVmFsdWUoW3tcbiAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgICBfdHlwZTogdHlwZXMuYmxvY2submFtZSxcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgICAgIF90eXBlOiB0eXBlLm5hbWUsXG4gICAgICAgICAgLi4udmFsdWUgfHwge31cbiAgICAgICAgfV1cbiAgICAgIH1dLCB7XG4gICAgICAgIHNjaGVtYVR5cGVzOiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hXG4gICAgICB9KVswXS5jaGlsZHJlblswXSwgZm9jdXNDaGlsZFBhdGggPSBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGguc2xpY2UoMCwgMiksIGlzU3Bhbk5vZGUyID0gY2hpbGQuX3R5cGUgPT09IHR5cGVzLnNwYW4ubmFtZSwgZm9jdXNOb2RlID0gTm9kZS5nZXQoZWRpdG9yLCBmb2N1c0NoaWxkUGF0aCk7XG4gICAgICByZXR1cm4gaXNTcGFuTm9kZTIgJiYgZm9jdXNOb2RlLl90eXBlICE9PSB0eXBlcy5zcGFuLm5hbWUgJiYgKGRlYnVnJDMoXCJJbnNlcnRpbmcgc3BhbiBjaGlsZCBuZXh0IHRvIGlubGluZSBvYmplY3QgY2hpbGQsIG1vdmluZyBzZWxlY3Rpb24gKyAxXCIpLCBlZGl0b3IubW92ZSh7XG4gICAgICAgIGRpc3RhbmNlOiAxLFxuICAgICAgICB1bml0OiBcImNoYXJhY3RlclwiXG4gICAgICB9KSksIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBjaGlsZCwge1xuICAgICAgICBzZWxlY3Q6ICEwLFxuICAgICAgICBhdDogZWRpdG9yLnNlbGVjdGlvblxuICAgICAgfSksIGVkaXRvci5vbkNoYW5nZSgpLCBlZGl0b3Iuc2VsZWN0aW9uID8gc2xhdGVSYW5nZVRvU2VsZWN0aW9uKHtcbiAgICAgICAgc2NoZW1hOiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLFxuICAgICAgICBlZGl0b3IsXG4gICAgICAgIHJhbmdlOiBlZGl0b3Iuc2VsZWN0aW9uXG4gICAgICB9KT8uZm9jdXMucGF0aCA/PyBbXSA6IFtdO1xuICAgIH0sXG4gICAgaW5zZXJ0QmxvY2s6ICh0eXBlLCB2YWx1ZSkgPT4gKGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICB0eXBlOiBcImluc2VydC5ibG9ja1wiLFxuICAgICAgICBibG9jazoge1xuICAgICAgICAgIF90eXBlOiB0eXBlLm5hbWUsXG4gICAgICAgICAgLi4udmFsdWUgfHwge31cbiAgICAgICAgfSxcbiAgICAgICAgcGxhY2VtZW50OiBcImF1dG9cIlxuICAgICAgfSxcbiAgICAgIGVkaXRvclxuICAgIH0pLCBlZGl0b3Iuc2VsZWN0aW9uID8gc2xhdGVSYW5nZVRvU2VsZWN0aW9uKHtcbiAgICAgIHNjaGVtYTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYSxcbiAgICAgIGVkaXRvcixcbiAgICAgIHJhbmdlOiBlZGl0b3Iuc2VsZWN0aW9uXG4gICAgfSk/LmZvY3VzLnBhdGggPz8gW10gOiBbXSksXG4gICAgaGFzQmxvY2tTdHlsZTogKHN0eWxlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gaXNTdHlsZUFjdGl2ZSh7XG4gICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgIHN0eWxlXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhhc0xpc3RTdHlsZTogKGxpc3RJdGVtKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gaXNMaXN0SXRlbUFjdGl2ZSh7XG4gICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgIGxpc3RJdGVtXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzVm9pZDogKGVsZW1lbnQpID0+ICFbdHlwZXMuYmxvY2submFtZSwgdHlwZXMuc3Bhbi5uYW1lXS5pbmNsdWRlcyhlbGVtZW50Ll90eXBlKSxcbiAgICBmaW5kQnlQYXRoOiAocGF0aCkgPT4ge1xuICAgICAgY29uc3Qgc2xhdGVQYXRoID0gdG9TbGF0ZVJhbmdlKHtcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgIHNjaGVtYTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYSxcbiAgICAgICAgICB2YWx1ZTogZWRpdG9yLnZhbHVlLFxuICAgICAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYmxvY2tJbmRleE1hcDogZWRpdG9yLmJsb2NrSW5kZXhNYXBcbiAgICAgIH0pO1xuICAgICAgaWYgKHNsYXRlUGF0aCkge1xuICAgICAgICBjb25zdCBbYmxvY2ssIGJsb2NrUGF0aF0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHNsYXRlUGF0aC5mb2N1cy5wYXRoLnNsaWNlKDAsIDEpKTtcbiAgICAgICAgaWYgKGJsb2NrICYmIGJsb2NrUGF0aCAmJiB0eXBlb2YgYmxvY2suX2tleSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAxICYmIHNsYXRlUGF0aC5mb2N1cy5wYXRoLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiBbZnJvbVNsYXRlVmFsdWUoW2Jsb2NrXSwgdHlwZXMuYmxvY2submFtZSlbMF0sIFt7XG4gICAgICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgICAgIH1dXTtcbiAgICAgICAgICBjb25zdCBwdEJsb2NrID0gZnJvbVNsYXRlVmFsdWUoW2Jsb2NrXSwgdHlwZXMuYmxvY2submFtZSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuZ2V0KGVkaXRvcikpWzBdO1xuICAgICAgICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2socHRCbG9jaykpIHtcbiAgICAgICAgICAgIGNvbnN0IHB0Q2hpbGQgPSBwdEJsb2NrLmNoaWxkcmVuW3NsYXRlUGF0aC5mb2N1cy5wYXRoWzFdXTtcbiAgICAgICAgICAgIGlmIChwdENoaWxkKVxuICAgICAgICAgICAgICByZXR1cm4gW3B0Q2hpbGQsIFt7XG4gICAgICAgICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgICAgICBfa2V5OiBwdENoaWxkLl9rZXlcbiAgICAgICAgICAgICAgfV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFt2b2lkIDAsIHZvaWQgMF07XG4gICAgfSxcbiAgICBmaW5kRE9NTm9kZTogKGVsZW1lbnQpID0+IHtcbiAgICAgIGxldCBub2RlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgW2l0ZW1dID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IFtdLFxuICAgICAgICAgIG1hdGNoOiAobikgPT4gbi5fa2V5ID09PSBlbGVtZW50Ll9rZXlcbiAgICAgICAgfSkgfHwgW10pWzBdIHx8IFt2b2lkIDBdO1xuICAgICAgICBub2RlID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgaXRlbSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG4gICAgYWN0aXZlQW5ub3RhdGlvbnM6ICgpID0+IHtcbiAgICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbiB8fCBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGgubGVuZ3RoIDwgMilcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYWN0aXZlQW5ub3RhdGlvbnMgPSBbXSwgc3BhbnMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBUZXh0LmlzVGV4dChub2RlKSAmJiBub2RlLm1hcmtzICE9PSB2b2lkIDAgJiYgQXJyYXkuaXNBcnJheShub2RlLm1hcmtzKSAmJiBub2RlLm1hcmtzLmxlbmd0aCA+IDBcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoY29uc3QgW3NwYW4sIHBhdGhdIG9mIHNwYW5zKSB7XG4gICAgICAgICAgY29uc3QgW2Jsb2NrXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCwge1xuICAgICAgICAgICAgZGVwdGg6IDFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIGJsb2NrLm1hcmtEZWZzPy5mb3JFYWNoKChkZWYpID0+IHtcbiAgICAgICAgICAgIFRleHQuaXNUZXh0KHNwYW4pICYmIHNwYW4ubWFya3MgJiYgQXJyYXkuaXNBcnJheShzcGFuLm1hcmtzKSAmJiBzcGFuLm1hcmtzLmluY2x1ZGVzKGRlZi5fa2V5KSAmJiBhY3RpdmVBbm5vdGF0aW9ucy5wdXNoKGRlZik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjdGl2ZUFubm90YXRpb25zO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzQW5ub3RhdGlvbkFjdGl2ZTogKGFubm90YXRpb25UeXBlKSA9PiB7XG4gICAgICBjb25zdCBzbmFwc2hvdCA9IGdldEVkaXRvclNuYXBzaG90KHtcbiAgICAgICAgZWRpdG9yQWN0b3JTbmFwc2hvdDogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKSxcbiAgICAgICAgc2xhdGVFZGl0b3JJbnN0YW5jZTogZWRpdG9yXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBpc0FjdGl2ZUFubm90YXRpb24oYW5ub3RhdGlvblR5cGUpKHNuYXBzaG90KTtcbiAgICB9LFxuICAgIGFkZEFubm90YXRpb246ICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgY29uc3Qgc25hcHNob3RCZWZvcmUgPSBnZXRFZGl0b3JTbmFwc2hvdCh7XG4gICAgICAgIGVkaXRvckFjdG9yU25hcHNob3Q6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCksXG4gICAgICAgIHNsYXRlRWRpdG9ySW5zdGFuY2U6IGVkaXRvclxuICAgICAgfSksIHNlbGVjdGVkVmFsdWVCZWZvcmUgPSBnZXRTZWxlY3RlZFZhbHVlKHNuYXBzaG90QmVmb3JlKSwgZm9jdXNTcGFuQmVmb3JlID0gZ2V0Rm9jdXNTcGFuJDEoc25hcHNob3RCZWZvcmUpLCBtYXJrRGVmc0JlZm9yZSA9IHNlbGVjdGVkVmFsdWVCZWZvcmUuZmxhdE1hcCgoYmxvY2spID0+IGlzVGV4dEJsb2NrKHNuYXBzaG90QmVmb3JlLmNvbnRleHQsIGJsb2NrKSA/IGJsb2NrLm1hcmtEZWZzID8/IFtdIDogW10pO1xuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwiYW5ub3RhdGlvbi5hZGRcIixcbiAgICAgICAgICBhbm5vdGF0aW9uOiB7XG4gICAgICAgICAgICBuYW1lOiB0eXBlLm5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUgPz8ge31cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgICBjb25zdCBzbmFwc2hvdEFmdGVyID0gZ2V0RWRpdG9yU25hcHNob3Qoe1xuICAgICAgICBlZGl0b3JBY3RvclNuYXBzaG90OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLFxuICAgICAgICBzbGF0ZUVkaXRvckluc3RhbmNlOiBlZGl0b3JcbiAgICAgIH0pLCBzZWxlY3RlZFZhbHVlQWZ0ZXIgPSBnZXRTZWxlY3RlZFZhbHVlKHNuYXBzaG90QWZ0ZXIpLCBmb2N1c0Jsb2NrQWZ0ZXIgPSBnZXRGb2N1c0Jsb2NrJDEoc25hcHNob3RBZnRlciksIGZvY3VzU3BhbkFmdGVyID0gZ2V0Rm9jdXNTcGFuJDEoc25hcHNob3RBZnRlciksIG5ld01hcmtEZWZLZXlzT25Gb2N1c1NwYW4gPSBmb2N1c1NwYW5BZnRlcj8ubm9kZS5tYXJrcz8uZmlsdGVyKChtYXJrKSA9PiAhZm9jdXNTcGFuQmVmb3JlPy5ub2RlLm1hcmtzPy5pbmNsdWRlcyhtYXJrKSAmJiAhc25hcHNob3RBZnRlci5jb250ZXh0LnNjaGVtYS5kZWNvcmF0b3JzLm1hcCgoZGVjb3JhdG9yKSA9PiBkZWNvcmF0b3IubmFtZSkuaW5jbHVkZXMobWFyaykpLCBtYXJrRGVmcyA9IHNlbGVjdGVkVmFsdWVBZnRlci5mbGF0TWFwKChibG9jaykgPT4gaXNUZXh0QmxvY2soc25hcHNob3RBZnRlci5jb250ZXh0LCBibG9jaykgPyBibG9jay5tYXJrRGVmcz8ubWFwKChtYXJrRGVmMikgPT4gKHtcbiAgICAgICAgbWFya0RlZjogbWFya0RlZjIsXG4gICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICB9LCBcIm1hcmtEZWZzXCIsIHtcbiAgICAgICAgICBfa2V5OiBtYXJrRGVmMi5fa2V5XG4gICAgICAgIH1dXG4gICAgICB9KSkgPz8gW10gOiBbXSkuZmlsdGVyKChtYXJrRGVmMikgPT4gIW1hcmtEZWZzQmVmb3JlLnNvbWUoKG1hcmtEZWZCZWZvcmUpID0+IG1hcmtEZWZCZWZvcmUuX2tleSA9PT0gbWFya0RlZjIubWFya0RlZi5fa2V5KSksIHNwYW5QYXRoID0gZm9jdXNTcGFuQWZ0ZXI/LnBhdGgsIG1hcmtEZWYgPSBtYXJrRGVmcy5maW5kKChtYXJrRGVmMikgPT4gbmV3TWFya0RlZktleXNPbkZvY3VzU3Bhbj8uc29tZSgobWFyaykgPT4gbWFyayA9PT0gbWFya0RlZjIubWFya0RlZi5fa2V5KSk7XG4gICAgICBpZiAoZm9jdXNCbG9ja0FmdGVyICYmIHNwYW5QYXRoICYmIG1hcmtEZWYpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWFya0RlZlBhdGg6IG1hcmtEZWYucGF0aCxcbiAgICAgICAgICBtYXJrRGVmUGF0aHM6IG1hcmtEZWZzLm1hcCgobWFya0RlZjIpID0+IG1hcmtEZWYyLnBhdGgpLFxuICAgICAgICAgIHNwYW5QYXRoXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBkZWxldGU6IChzZWxlY3Rpb24sIG9wdGlvbnMpID0+IHtcbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSB0b1NsYXRlUmFuZ2Uoe1xuICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgIHNjaGVtYTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYSxcbiAgICAgICAgICAgIHZhbHVlOiBlZGl0b3IudmFsdWUsXG4gICAgICAgICAgICBzZWxlY3Rpb25cbiAgICAgICAgICB9LFxuICAgICAgICAgIGJsb2NrSW5kZXhNYXA6IGVkaXRvci5ibG9ja0luZGV4TWFwXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIShyYW5nZSAmJiByYW5nZS5hbmNob3IucGF0aC5sZW5ndGggPiAwICYmIHJhbmdlLmZvY3VzLnBhdGgubGVuZ3RoID4gMCkpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByYW5nZVwiKTtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zPy5tb2RlIHx8IG9wdGlvbnM/Lm1vZGUgPT09IFwic2VsZWN0ZWRcIikge1xuICAgICAgICAgICAgZGVidWckMyhcIkRlbGV0aW5nIGNvbnRlbnQgaW4gc2VsZWN0aW9uXCIpLCBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgICAgICBoYW5naW5nOiAhMCxcbiAgICAgICAgICAgICAgdm9pZHM6ICEwXG4gICAgICAgICAgICB9KSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zPy5tb2RlID09PSBcImJsb2Nrc1wiICYmIChkZWJ1ZyQzKFwiRGVsZXRpbmcgYmxvY2tzIHRvdWNoZWQgYnkgc2VsZWN0aW9uXCIpLCBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgICAgdm9pZHM6ICEwLFxuICAgICAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSkgfHwgIWVkaXRvci5pc1RleHRCbG9jayhub2RlKSAmJiBFbGVtZW50JDEuaXNFbGVtZW50KG5vZGUpXG4gICAgICAgICAgfSkpLCBvcHRpb25zPy5tb2RlID09PSBcImNoaWxkcmVuXCIgJiYgKGRlYnVnJDMoXCJEZWxldGluZyBjaGlsZHJlbiB0b3VjaGVkIGJ5IHNlbGVjdGlvblwiKSwgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiByYW5nZSxcbiAgICAgICAgICAgIHZvaWRzOiAhMCxcbiAgICAgICAgICAgIG1hdGNoOiAobm9kZSkgPT4gbm9kZS5fdHlwZSA9PT0gdHlwZXMuc3Bhbi5uYW1lIHx8IC8vIFRleHQgY2hpbGRyZW5cbiAgICAgICAgICAgICFlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSkgJiYgRWxlbWVudCQxLmlzRWxlbWVudChub2RlKVxuICAgICAgICAgIH0pKSwgZWRpdG9yLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXJCbG9jayA9IGNyZWF0ZVBsYWNlaG9sZGVyQmxvY2soZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0KTtcbiAgICAgICAgICAgIGVkaXRvci5jaGlsZHJlbiA9IFtwbGFjZWhvbGRlckJsb2NrXSwgZWRpdG9yLnZhbHVlID0gW3BsYWNlaG9sZGVyQmxvY2tdLCBidWlsZEluZGV4TWFwcyh7XG4gICAgICAgICAgICAgIHNjaGVtYTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYSxcbiAgICAgICAgICAgICAgdmFsdWU6IGVkaXRvci52YWx1ZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBibG9ja0luZGV4TWFwOiBlZGl0b3IuYmxvY2tJbmRleE1hcCxcbiAgICAgICAgICAgICAgbGlzdEluZGV4TWFwOiBlZGl0b3IubGlzdEluZGV4TWFwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZUFubm90YXRpb246ICh0eXBlKSA9PiB7XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJhbm5vdGF0aW9uLnJlbW92ZVwiLFxuICAgICAgICAgIGFubm90YXRpb246IHtcbiAgICAgICAgICAgIG5hbWU6IHR5cGUubmFtZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldFNlbGVjdGlvbjogKCkgPT4ge1xuICAgICAgbGV0IHB0UmFuZ2UgPSBudWxsO1xuICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBTTEFURV9UT19QT1JUQUJMRV9URVhUX1JBTkdFLmdldChlZGl0b3Iuc2VsZWN0aW9uKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKVxuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgcHRSYW5nZSA9IHNsYXRlUmFuZ2VUb1NlbGVjdGlvbih7XG4gICAgICAgICAgc2NoZW1hOiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLFxuICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICByYW5nZTogZWRpdG9yLnNlbGVjdGlvblxuICAgICAgICB9KSwgU0xBVEVfVE9fUE9SVEFCTEVfVEVYVF9SQU5HRS5zZXQoZWRpdG9yLnNlbGVjdGlvbiwgcHRSYW5nZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHRSYW5nZTtcbiAgICB9LFxuICAgIGdldFZhbHVlOiAoKSA9PiBmcm9tU2xhdGVWYWx1ZShlZGl0b3IuY2hpbGRyZW4sIHR5cGVzLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKSxcbiAgICBpc0NvbGxhcHNlZFNlbGVjdGlvbjogKCkgPT4gISFlZGl0b3Iuc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pLFxuICAgIGlzRXhwYW5kZWRTZWxlY3Rpb246ICgpID0+ICEhZWRpdG9yLnNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKGVkaXRvci5zZWxlY3Rpb24pLFxuICAgIGluc2VydEJyZWFrOiAoKSA9PiB7XG4gICAgICBlZGl0b3IuaW5zZXJ0QnJlYWsoKSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgfSxcbiAgICBnZXRGcmFnbWVudDogKCkgPT4gZnJvbVNsYXRlVmFsdWUoZWRpdG9yLmdldEZyYWdtZW50KCksIHR5cGVzLmJsb2NrLm5hbWUpLFxuICAgIGlzU2VsZWN0aW9uc092ZXJsYXBwaW5nOiAoc2VsZWN0aW9uQSwgc2VsZWN0aW9uQikgPT4ge1xuICAgICAgY29uc3QgcmFuZ2VBID0gdG9TbGF0ZVJhbmdlKHtcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgIHNjaGVtYTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYSxcbiAgICAgICAgICB2YWx1ZTogZWRpdG9yLnZhbHVlLFxuICAgICAgICAgIHNlbGVjdGlvbjogc2VsZWN0aW9uQVxuICAgICAgICB9LFxuICAgICAgICBibG9ja0luZGV4TWFwOiBlZGl0b3IuYmxvY2tJbmRleE1hcFxuICAgICAgfSksIHJhbmdlQiA9IHRvU2xhdGVSYW5nZSh7XG4gICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICBzY2hlbWE6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEsXG4gICAgICAgICAgdmFsdWU6IGVkaXRvci52YWx1ZSxcbiAgICAgICAgICBzZWxlY3Rpb246IHNlbGVjdGlvbkJcbiAgICAgICAgfSxcbiAgICAgICAgYmxvY2tJbmRleE1hcDogZWRpdG9yLmJsb2NrSW5kZXhNYXBcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFJhbmdlLmlzUmFuZ2UocmFuZ2VBKSAmJiBSYW5nZS5pc1JhbmdlKHJhbmdlQikgJiYgUmFuZ2UuaW5jbHVkZXMocmFuZ2VBLCByYW5nZUIpO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IHJlbGF5TWFjaGluZSA9IHNldHVwKHtcbiAgdHlwZXM6IHtcbiAgICBjb250ZXh0OiB7fSxcbiAgICBldmVudHM6IHt9LFxuICAgIGVtaXR0ZWQ6IHt9XG4gIH1cbn0pLmNyZWF0ZU1hY2hpbmUoe1xuICBpZDogXCJyZWxheVwiLFxuICBjb250ZXh0OiB7XG4gICAgcHJldlNlbGVjdGlvbjogbnVsbCxcbiAgICBsYXN0RXZlbnRXYXNGb2N1c2VkOiAhMVxuICB9LFxuICBvbjoge1xuICAgIGZvY3VzZWQ6IHtcbiAgICAgIGFjdGlvbnM6IFthc3NpZ24oe1xuICAgICAgICBsYXN0RXZlbnRXYXNGb2N1c2VkOiAhMFxuICAgICAgfSksIGVtaXQoKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IGV2ZW50KV1cbiAgICB9LFxuICAgIHNlbGVjdGlvbjogW3tcbiAgICAgIGd1YXJkOiAoe1xuICAgICAgICBjb250ZXh0XG4gICAgICB9KSA9PiBjb250ZXh0Lmxhc3RFdmVudFdhc0ZvY3VzZWQsXG4gICAgICBhY3Rpb25zOiBbYXNzaWduKHtcbiAgICAgICAgcHJldlNlbGVjdGlvbjogKHtcbiAgICAgICAgICBldmVudFxuICAgICAgICB9KSA9PiBldmVudC5zZWxlY3Rpb25cbiAgICAgIH0pLCBlbWl0KCh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiBldmVudCksIGFzc2lnbih7XG4gICAgICAgIGxhc3RFdmVudFdhc0ZvY3VzZWQ6ICExXG4gICAgICB9KV1cbiAgICB9LCB7XG4gICAgICBndWFyZDogKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IGNvbnRleHQucHJldlNlbGVjdGlvbiAhPT0gZXZlbnQuc2VsZWN0aW9uLFxuICAgICAgYWN0aW9uczogW2Fzc2lnbih7XG4gICAgICAgIHByZXZTZWxlY3Rpb246ICh7XG4gICAgICAgICAgZXZlbnRcbiAgICAgICAgfSkgPT4gZXZlbnQuc2VsZWN0aW9uXG4gICAgICB9KSwgZW1pdCgoe1xuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gZXZlbnQpLCBhc3NpZ24oe1xuICAgICAgICBsYXN0RXZlbnRXYXNGb2N1c2VkOiAhMVxuICAgICAgfSldXG4gICAgfV0sXG4gICAgXCIqXCI6IHtcbiAgICAgIGFjdGlvbnM6IFtlbWl0KCh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiBldmVudCksIGFzc2lnbih7XG4gICAgICAgIGxhc3RFdmVudFdhc0ZvY3VzZWQ6ICExXG4gICAgICB9KV1cbiAgICB9XG4gIH1cbn0pO1xuZnVuY3Rpb24gdmFsaWRhdGVWYWx1ZSh2YWx1ZSwgdHlwZXMsIGtleUdlbmVyYXRvcikge1xuICBsZXQgcmVzb2x1dGlvbiA9IG51bGwsIHZhbGlkID0gITA7XG4gIGNvbnN0IHZhbGlkQ2hpbGRUeXBlcyA9IFt0eXBlcy5zcGFuLm5hbWUsIC4uLnR5cGVzLmlubGluZU9iamVjdHMubWFwKCh0KSA9PiB0Lm5hbWUpXSwgdmFsaWRCbG9ja1R5cGVzID0gW3R5cGVzLmJsb2NrLm5hbWUsIC4uLnR5cGVzLmJsb2NrT2JqZWN0cy5tYXAoKHQpID0+IHQubmFtZSldO1xuICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCA/IHtcbiAgICB2YWxpZDogITAsXG4gICAgcmVzb2x1dGlvbjogbnVsbCxcbiAgICB2YWx1ZVxuICB9IDogIUFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlLmxlbmd0aCA9PT0gMCA/IHtcbiAgICB2YWxpZDogITEsXG4gICAgcmVzb2x1dGlvbjoge1xuICAgICAgcGF0Y2hlczogW3Vuc2V0KFtdKV0sXG4gICAgICBkZXNjcmlwdGlvbjogXCJFZGl0b3IgdmFsdWUgbXVzdCBiZSBhbiBhcnJheSBvZiBQb3J0YWJsZSBUZXh0IGJsb2Nrcywgb3IgdW5kZWZpbmVkLlwiLFxuICAgICAgYWN0aW9uOiBcIlVuc2V0IHRoZSB2YWx1ZVwiLFxuICAgICAgaXRlbTogdmFsdWUsXG4gICAgICBpMThuOiB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubm90LWFuLWFycmF5LmRlc2NyaXB0aW9uXCIsXG4gICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm5vdC1hbi1hcnJheS5hY3Rpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgdmFsdWVcbiAgfSA6ICh2YWx1ZS5zb21lKChibGssIGluZGV4KSA9PiB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGJsaykpXG4gICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgcGF0Y2hlczogW3Vuc2V0KFtpbmRleF0pXSxcbiAgICAgICAgZGVzY3JpcHRpb246IGBCbG9jayBtdXN0IGJlIGFuIG9iamVjdCwgZ290ICR7U3RyaW5nKGJsayl9YCxcbiAgICAgICAgYWN0aW9uOiBcIlVuc2V0IGludmFsaWQgaXRlbVwiLFxuICAgICAgICBpdGVtOiBibGssXG4gICAgICAgIGkxOG46IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm5vdC1hbi1vYmplY3QuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5ub3QtYW4tb2JqZWN0LmFjdGlvblwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgaW5kZXhcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sICEwO1xuICAgIGlmICghYmxrLl9rZXkgfHwgdHlwZW9mIGJsay5fa2V5ICE9IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgcGF0Y2hlczogW3NldCh7XG4gICAgICAgICAgLi4uYmxrLFxuICAgICAgICAgIF9rZXk6IGtleUdlbmVyYXRvcigpXG4gICAgICAgIH0sIFtpbmRleF0pXSxcbiAgICAgICAgZGVzY3JpcHRpb246IGBCbG9jayBhdCBpbmRleCAke2luZGV4fSBpcyBtaXNzaW5nIHJlcXVpcmVkIF9rZXkuYCxcbiAgICAgICAgYWN0aW9uOiBcIlNldCB0aGUgYmxvY2sgd2l0aCBhIHJhbmRvbSBfa2V5IHZhbHVlXCIsXG4gICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgaTE4bjoge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy1rZXkuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5taXNzaW5nLWtleS5hY3Rpb25cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCAhMDtcbiAgICBpZiAoIWJsay5fdHlwZSB8fCAhdmFsaWRCbG9ja1R5cGVzLmluY2x1ZGVzKGJsay5fdHlwZSkpIHtcbiAgICAgIGlmIChibGsuX3R5cGUgPT09IFwiYmxvY2tcIikge1xuICAgICAgICBjb25zdCBjdXJyZW50QmxvY2tUeXBlTmFtZSA9IHR5cGVzLmJsb2NrLm5hbWU7XG4gICAgICAgIHJldHVybiByZXNvbHV0aW9uID0ge1xuICAgICAgICAgIHBhdGNoZXM6IFtzZXQoe1xuICAgICAgICAgICAgLi4uYmxrLFxuICAgICAgICAgICAgX3R5cGU6IGN1cnJlbnRCbG9ja1R5cGVOYW1lXG4gICAgICAgICAgfSwgW3tcbiAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgfV0pXSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2NrIHdpdGggX2tleSAnJHtibGsuX2tleX0nIGhhcyBpbnZhbGlkIHR5cGUgbmFtZSAnJHtibGsuX3R5cGV9Jy4gQWNjb3JkaW5nIHRvIHRoZSBzY2hlbWEsIHRoZSBibG9jayB0eXBlIG5hbWUgaXMgJyR7Y3VycmVudEJsb2NrVHlwZU5hbWV9J2AsXG4gICAgICAgICAgYWN0aW9uOiBgVXNlIHR5cGUgJyR7Y3VycmVudEJsb2NrVHlwZU5hbWV9J2AsXG4gICAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUuaW5jb3JyZWN0LWJsb2NrLXR5cGUuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLmluY29ycmVjdC1ibG9jay10eXBlLmFjdGlvblwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIGtleTogYmxrLl9rZXksXG4gICAgICAgICAgICAgIGV4cGVjdGVkVHlwZU5hbWU6IGN1cnJlbnRCbG9ja1R5cGVOYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCAhMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhYmxrLl90eXBlICYmIGlzVGV4dEJsb2NrKHtcbiAgICAgICAgc2NoZW1hOiB0eXBlc1xuICAgICAgfSwge1xuICAgICAgICAuLi5ibGssXG4gICAgICAgIF90eXBlOiB0eXBlcy5ibG9jay5uYW1lXG4gICAgICB9KSA/IChyZXNvbHV0aW9uID0ge1xuICAgICAgICBwYXRjaGVzOiBbc2V0KHtcbiAgICAgICAgICAuLi5ibGssXG4gICAgICAgICAgX3R5cGU6IHR5cGVzLmJsb2NrLm5hbWVcbiAgICAgICAgfSwgW3tcbiAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICB9XSldLFxuICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2NrIHdpdGggX2tleSAnJHtibGsuX2tleX0nIGlzIG1pc3NpbmcgYSB0eXBlIG5hbWUuIEFjY29yZGluZyB0byB0aGUgc2NoZW1hLCB0aGUgYmxvY2sgdHlwZSBuYW1lIGlzICcke3R5cGVzLmJsb2NrLm5hbWV9J2AsXG4gICAgICAgIGFjdGlvbjogYFVzZSB0eXBlICcke3R5cGVzLmJsb2NrLm5hbWV9J2AsXG4gICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgaTE4bjoge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy1ibG9jay10eXBlLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy1ibG9jay10eXBlLmFjdGlvblwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAga2V5OiBibGsuX2tleSxcbiAgICAgICAgICAgIGV4cGVjdGVkVHlwZU5hbWU6IHR5cGVzLmJsb2NrLm5hbWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sICEwKSA6IGJsay5fdHlwZSA/IChyZXNvbHV0aW9uID0ge1xuICAgICAgICBwYXRjaGVzOiBbdW5zZXQoW3tcbiAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICB9XSldLFxuICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2NrIHdpdGggX2tleSAnJHtibGsuX2tleX0nIGhhcyBpbnZhbGlkIF90eXBlICcke2Jsay5fdHlwZX0nYCxcbiAgICAgICAgYWN0aW9uOiBcIlJlbW92ZSB0aGUgYmxvY2tcIixcbiAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICBpMThuOiB7XG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5kaXNhbGxvd2VkLXR5cGUuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5kaXNhbGxvd2VkLXR5cGUuYWN0aW9uXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBrZXk6IGJsay5fa2V5LFxuICAgICAgICAgICAgdHlwZU5hbWU6IGJsay5fdHlwZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgITApIDogKHJlc29sdXRpb24gPSB7XG4gICAgICAgIHBhdGNoZXM6IFt1bnNldChbe1xuICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgIH1dKV0sXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvY2sgd2l0aCBfa2V5ICcke2Jsay5fa2V5fScgaXMgbWlzc2luZyBhbiBfdHlwZSBwcm9wZXJ0eWAsXG4gICAgICAgIGFjdGlvbjogXCJSZW1vdmUgdGhlIGJsb2NrXCIsXG4gICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgaTE4bjoge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy10eXBlLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy10eXBlLmFjdGlvblwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAga2V5OiBibGsuX2tleVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgITApO1xuICAgIH1cbiAgICBpZiAoYmxrLl90eXBlID09PSB0eXBlcy5ibG9jay5uYW1lKSB7XG4gICAgICBjb25zdCB0ZXh0QmxvY2sgPSBibGs7XG4gICAgICBpZiAodGV4dEJsb2NrLmNoaWxkcmVuICYmICFBcnJheS5pc0FycmF5KHRleHRCbG9jay5jaGlsZHJlbikpXG4gICAgICAgIHJldHVybiByZXNvbHV0aW9uID0ge1xuICAgICAgICAgIHBhdGNoZXM6IFtzZXQoe1xuICAgICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgICAgfSwgW3tcbiAgICAgICAgICAgIF9rZXk6IHRleHRCbG9jay5fa2V5XG4gICAgICAgICAgfV0pXSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYFRleHQgYmxvY2sgd2l0aCBfa2V5ICcke3RleHRCbG9jay5fa2V5fScgaGFzIGEgaW52YWxpZCByZXF1aXJlZCBwcm9wZXJ0eSAnY2hpbGRyZW4nLmAsXG4gICAgICAgICAgYWN0aW9uOiBcIlJlc2V0IHRoZSBjaGlsZHJlbiBwcm9wZXJ0eVwiLFxuICAgICAgICAgIGl0ZW06IHRleHRCbG9jayxcbiAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3Npbmctb3ItaW52YWxpZC1jaGlsZHJlbi5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy1vci1pbnZhbGlkLWNoaWxkcmVuLmFjdGlvblwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIGtleTogdGV4dEJsb2NrLl9rZXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sICEwO1xuICAgICAgaWYgKHRleHRCbG9jay5jaGlsZHJlbiA9PT0gdm9pZCAwIHx8IEFycmF5LmlzQXJyYXkodGV4dEJsb2NrLmNoaWxkcmVuKSAmJiB0ZXh0QmxvY2suY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnN0IG5ld1NwYW4gPSB7XG4gICAgICAgICAgX3R5cGU6IHR5cGVzLnNwYW4ubmFtZSxcbiAgICAgICAgICBfa2V5OiBrZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgIG1hcmtzOiBbXVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICBhdXRvUmVzb2x2ZTogITAsXG4gICAgICAgICAgcGF0Y2hlczogW3NldElmTWlzc2luZyhbXSwgW3tcbiAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgfSwgXCJjaGlsZHJlblwiXSksIGluc2VydChbbmV3U3Bhbl0sIFwiYWZ0ZXJcIiwgW3tcbiAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCAwXSldLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ2hpbGRyZW4gZm9yIHRleHQgYmxvY2sgd2l0aCBfa2V5ICcke2Jsay5fa2V5fScgaXMgZW1wdHkuYCxcbiAgICAgICAgICBhY3Rpb246IFwiSW5zZXJ0IGFuIGVtcHR5IHRleHRcIixcbiAgICAgICAgICBpdGVtOiBibGssXG4gICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5lbXB0eS1jaGlsZHJlbi5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUuZW1wdHktY2hpbGRyZW4uYWN0aW9uXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAga2V5OiBibGsuX2tleVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgITA7XG4gICAgICB9XG4gICAgICBjb25zdCBhbGxVc2VkTWFya3MgPSB1bmlxKGZsYXR0ZW4odGV4dEJsb2NrLmNoaWxkcmVuLmZpbHRlcigoY2xkKSA9PiBjbGQuX3R5cGUgPT09IHR5cGVzLnNwYW4ubmFtZSkubWFwKChjbGQpID0+IGNsZC5tYXJrcyB8fCBbXSkpKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGJsay5tYXJrRGVmcykgJiYgYmxrLm1hcmtEZWZzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgdW51c2VkTWFya0RlZnMgPSB1bmlxKGJsay5tYXJrRGVmcy5tYXAoKGRlZikgPT4gZGVmLl9rZXkpLmZpbHRlcigoa2V5KSA9PiAhYWxsVXNlZE1hcmtzLmluY2x1ZGVzKGtleSkpKTtcbiAgICAgICAgaWYgKHVudXNlZE1hcmtEZWZzLmxlbmd0aCA+IDApXG4gICAgICAgICAgcmV0dXJuIHJlc29sdXRpb24gPSB7XG4gICAgICAgICAgICBhdXRvUmVzb2x2ZTogITAsXG4gICAgICAgICAgICBwYXRjaGVzOiB1bnVzZWRNYXJrRGVmcy5tYXAoKG1hcmtEZWZLZXkpID0+IHVuc2V0KFt7XG4gICAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgICB9LCBcIm1hcmtEZWZzXCIsIHtcbiAgICAgICAgICAgICAgX2tleTogbWFya0RlZktleVxuICAgICAgICAgICAgfV0pKSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvY2sgY29udGFpbnMgb3JwaGFuZWQgZGF0YSAodW51c2VkIG1hcmsgZGVmaW5pdGlvbnMpOiAke3VudXNlZE1hcmtEZWZzLmpvaW4oXCIsIFwiKX0uYCxcbiAgICAgICAgICAgIGFjdGlvbjogXCJSZW1vdmUgdW51c2VkIG1hcmsgZGVmaW5pdGlvbiBpdGVtXCIsXG4gICAgICAgICAgICBpdGVtOiBibGssXG4gICAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUub3JwaGFuZWQtbWFyay1kZWZzLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm9ycGhhbmVkLW1hcmstZGVmcy5hY3Rpb25cIixcbiAgICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAga2V5OiBibGsuX2tleSxcbiAgICAgICAgICAgICAgICB1bnVzZWRNYXJrRGVmczogdW51c2VkTWFya0RlZnMubWFwKChtKSA9PiBtLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAhMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9ycGhhbmVkTWFya3MgPSBhbGxVc2VkTWFya3MuZmlsdGVyKChtYXJrKSA9PiAhdHlwZXMuZGVjb3JhdG9ycy5tYXAoKGRlYykgPT4gZGVjLm5hbWUpLmluY2x1ZGVzKG1hcmspKS5maWx0ZXIoKG1hcmspID0+IHRleHRCbG9jay5tYXJrRGVmcyA9PT0gdm9pZCAwIHx8ICF0ZXh0QmxvY2subWFya0RlZnMuZmluZCgoZGVmKSA9PiBkZWYuX2tleSA9PT0gbWFyaykpO1xuICAgICAgaWYgKG9ycGhhbmVkTWFya3MubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBzcGFuQ2hpbGRyZW4gPSB0ZXh0QmxvY2suY2hpbGRyZW4uZmlsdGVyKChjbGQpID0+IGNsZC5fdHlwZSA9PT0gdHlwZXMuc3Bhbi5uYW1lICYmIEFycmF5LmlzQXJyYXkoY2xkLm1hcmtzKSAmJiBjbGQubWFya3Muc29tZSgobWFyaykgPT4gb3JwaGFuZWRNYXJrcy5pbmNsdWRlcyhtYXJrKSkpO1xuICAgICAgICBpZiAoc3BhbkNoaWxkcmVuKSB7XG4gICAgICAgICAgY29uc3Qgb3JwaGFuZWQgPSBvcnBoYW5lZE1hcmtzLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICAgIGF1dG9SZXNvbHZlOiAhMCxcbiAgICAgICAgICAgIHBhdGNoZXM6IHNwYW5DaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiBzZXQoKGNoaWxkLm1hcmtzIHx8IFtdKS5maWx0ZXIoKGNNcmspID0+ICFvcnBoYW5lZE1hcmtzLmluY2x1ZGVzKGNNcmspKSwgW3tcbiAgICAgICAgICAgICAgX2tleTogYmxrLl9rZXlcbiAgICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICAgICAgICB9LCBcIm1hcmtzXCJdKSksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2NrIHdpdGggX2tleSAnJHtibGsuX2tleX0nIGNvbnRhaW5zIG1hcmtzICgke29ycGhhbmVkfSkgbm90IHN1cHBvcnRlZCBieSB0aGUgY3VycmVudCBjb250ZW50IG1vZGVsLmAsXG4gICAgICAgICAgICBhY3Rpb246IFwiUmVtb3ZlIGludmFsaWQgbWFya3NcIixcbiAgICAgICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5vcnBoYW5lZC1tYXJrcy5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5vcnBoYW5lZC1tYXJrcy5hY3Rpb25cIixcbiAgICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAga2V5OiBibGsuX2tleSxcbiAgICAgICAgICAgICAgICBvcnBoYW5lZE1hcmtzOiBvcnBoYW5lZE1hcmtzLm1hcCgobSkgPT4gbS50b1N0cmluZygpKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgITA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRleHRCbG9jay5jaGlsZHJlbi5zb21lKChjaGlsZCwgY0luZGV4KSA9PiB7XG4gICAgICAgIGlmICghaXNQbGFpbk9iamVjdChjaGlsZCkpXG4gICAgICAgICAgcmV0dXJuIHJlc29sdXRpb24gPSB7XG4gICAgICAgICAgICBwYXRjaGVzOiBbdW5zZXQoW3tcbiAgICAgICAgICAgICAgX2tleTogYmxrLl9rZXlcbiAgICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwgY0luZGV4XSldLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBDaGlsZCBhdCBpbmRleCAnJHtjSW5kZXh9JyBpbiBibG9jayB3aXRoIGtleSAnJHtibGsuX2tleX0nIGlzIG5vdCBhbiBvYmplY3QuYCxcbiAgICAgICAgICAgIGFjdGlvbjogXCJSZW1vdmUgdGhlIGl0ZW1cIixcbiAgICAgICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5ub24tb2JqZWN0LWNoaWxkLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm5vbi1vYmplY3QtY2hpbGQuYWN0aW9uXCIsXG4gICAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIGtleTogYmxrLl9rZXksXG4gICAgICAgICAgICAgICAgaW5kZXg6IGNJbmRleFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgITA7XG4gICAgICAgIGlmICghY2hpbGQuX2tleSB8fCB0eXBlb2YgY2hpbGQuX2tleSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY29uc3QgbmV3Q2hpbGQgPSB7XG4gICAgICAgICAgICAuLi5jaGlsZCxcbiAgICAgICAgICAgIF9rZXk6IGtleUdlbmVyYXRvcigpXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICAgIGF1dG9SZXNvbHZlOiAhMCxcbiAgICAgICAgICAgIHBhdGNoZXM6IFtzZXQobmV3Q2hpbGQsIFt7XG4gICAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIGNJbmRleF0pXSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ2hpbGQgYXQgaW5kZXggJHtjSW5kZXh9IGlzIG1pc3NpbmcgcmVxdWlyZWQgX2tleSBpbiBibG9jayB3aXRoIF9rZXkgJHtibGsuX2tleX0uYCxcbiAgICAgICAgICAgIGFjdGlvbjogXCJTZXQgYSBuZXcgcmFuZG9tIF9rZXkgb24gdGhlIG9iamVjdFwiLFxuICAgICAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3NpbmctY2hpbGQta2V5LmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3NpbmctY2hpbGQta2V5LmFjdGlvblwiLFxuICAgICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBrZXk6IGJsay5fa2V5LFxuICAgICAgICAgICAgICAgIGluZGV4OiBjSW5kZXhcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sICEwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZC5fdHlwZSA/IHZhbGlkQ2hpbGRUeXBlcy5pbmNsdWRlcyhjaGlsZC5fdHlwZSkgPyBjaGlsZC5fdHlwZSA9PT0gdHlwZXMuc3Bhbi5uYW1lICYmIHR5cGVvZiBjaGlsZC50ZXh0ICE9IFwic3RyaW5nXCIgPyAocmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICBwYXRjaGVzOiBbc2V0KHtcbiAgICAgICAgICAgIC4uLmNoaWxkLFxuICAgICAgICAgICAgdGV4dDogXCJcIlxuICAgICAgICAgIH0sIFt7XG4gICAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgICAgIH1dKV0sXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBDaGlsZCB3aXRoIF9rZXkgJyR7Y2hpbGQuX2tleX0nIGluIGJsb2NrIHdpdGgga2V5ICcke2Jsay5fa2V5fScgaGFzIG1pc3Npbmcgb3IgaW52YWxpZCB0ZXh0IHByb3BlcnR5IWAsXG4gICAgICAgICAgYWN0aW9uOiBcIldyaXRlIGFuIGVtcHR5IHRleHQgcHJvcGVydHkgdG8gdGhlIG9iamVjdFwiLFxuICAgICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLmludmFsaWQtc3Bhbi10ZXh0LmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5pbnZhbGlkLXNwYW4tdGV4dC5hY3Rpb25cIixcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICBrZXk6IGJsay5fa2V5LFxuICAgICAgICAgICAgICBjaGlsZEtleTogY2hpbGQuX2tleVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgITApIDogITEgOiAocmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICBwYXRjaGVzOiBbdW5zZXQoW3tcbiAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICAgICAgfV0pXSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYENoaWxkIHdpdGggX2tleSAnJHtjaGlsZC5fa2V5fScgaW4gYmxvY2sgd2l0aCBrZXkgJyR7YmxrLl9rZXl9JyBoYXMgaW52YWxpZCAnX3R5cGUnIHByb3BlcnR5ICgke2NoaWxkLl90eXBlfSkuYCxcbiAgICAgICAgICBhY3Rpb246IFwiUmVtb3ZlIHRoZSBvYmplY3RcIixcbiAgICAgICAgICBpdGVtOiBibGssXG4gICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5kaXNhbGxvd2VkLWNoaWxkLXR5cGUuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLmRpc2FsbG93ZWQtY2hpbGQtdHlwZS5hY3Rpb25cIixcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICBrZXk6IGJsay5fa2V5LFxuICAgICAgICAgICAgICBjaGlsZEtleTogY2hpbGQuX2tleSxcbiAgICAgICAgICAgICAgY2hpbGRUeXBlOiBjaGlsZC5fdHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgITApIDogKHJlc29sdXRpb24gPSB7XG4gICAgICAgICAgcGF0Y2hlczogW3Vuc2V0KFt7XG4gICAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgICAgIH1dKV0sXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBDaGlsZCB3aXRoIF9rZXkgJyR7Y2hpbGQuX2tleX0nIGluIGJsb2NrIHdpdGgga2V5ICcke2Jsay5fa2V5fScgaXMgbWlzc2luZyAnX3R5cGUnIHByb3BlcnR5LmAsXG4gICAgICAgICAgYWN0aW9uOiBcIlJlbW92ZSB0aGUgb2JqZWN0XCIsXG4gICAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy1jaGlsZC10eXBlLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5taXNzaW5nLWNoaWxkLXR5cGUuYWN0aW9uXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAga2V5OiBibGsuX2tleSxcbiAgICAgICAgICAgICAgY2hpbGRLZXk6IGNoaWxkLl9rZXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sICEwKTtcbiAgICAgIH0pICYmICh2YWxpZCA9ICExKTtcbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9KSAmJiAodmFsaWQgPSAhMSksIHtcbiAgICB2YWxpZCxcbiAgICByZXNvbHV0aW9uLFxuICAgIHZhbHVlXG4gIH0pO1xufVxuY29uc3QgZGVidWckMiA9IGRlYnVnV2l0aE5hbWUoXCJzeW5jIG1hY2hpbmVcIiksIHN5bmNWYWx1ZUNhbGxiYWNrID0gKHtcbiAgc2VuZEJhY2ssXG4gIGlucHV0XG59KSA9PiB7XG4gIHVwZGF0ZVZhbHVlKHtcbiAgICBjb250ZXh0OiBpbnB1dC5jb250ZXh0LFxuICAgIHNlbmRCYWNrLFxuICAgIHNsYXRlRWRpdG9yOiBpbnB1dC5zbGF0ZUVkaXRvcixcbiAgICB2YWx1ZTogaW5wdXQudmFsdWUsXG4gICAgc3RyZWFtQmxvY2tzOiBpbnB1dC5zdHJlYW1CbG9ja3NcbiAgfSk7XG59LCBzeW5jVmFsdWVMb2dpYyA9IGZyb21DYWxsYmFjayhzeW5jVmFsdWVDYWxsYmFjayksIHN5bmNNYWNoaW5lID0gc2V0dXAoe1xuICB0eXBlczoge1xuICAgIGNvbnRleHQ6IHt9LFxuICAgIGlucHV0OiB7fSxcbiAgICBldmVudHM6IHt9LFxuICAgIGVtaXR0ZWQ6IHt9XG4gIH0sXG4gIGFjdGlvbnM6IHtcbiAgICBcImFzc2lnbiBpbml0aWFsIHZhbHVlIHN5bmNlZFwiOiBhc3NpZ24oe1xuICAgICAgaW5pdGlhbFZhbHVlU3luY2VkOiAhMFxuICAgIH0pLFxuICAgIFwiYXNzaWduIHJlYWRPbmx5XCI6IGFzc2lnbih7XG4gICAgICByZWFkT25seTogKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJ1cGRhdGUgcmVhZE9ubHlcIiksIGV2ZW50LnJlYWRPbmx5KVxuICAgIH0pLFxuICAgIFwiYXNzaWduIHBlbmRpbmcgdmFsdWVcIjogYXNzaWduKHtcbiAgICAgIHBlbmRpbmdWYWx1ZTogKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJ1cGRhdGUgdmFsdWVcIiksIGV2ZW50LnZhbHVlKVxuICAgIH0pLFxuICAgIFwiY2xlYXIgcGVuZGluZyB2YWx1ZVwiOiBhc3NpZ24oe1xuICAgICAgcGVuZGluZ1ZhbHVlOiB2b2lkIDBcbiAgICB9KSxcbiAgICBcImFzc2lnbiBwcmV2aW91cyB2YWx1ZVwiOiBhc3NpZ24oe1xuICAgICAgcHJldmlvdXNWYWx1ZTogKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJkb25lIHN5bmNpbmdcIiksIGV2ZW50LnZhbHVlKVxuICAgIH0pLFxuICAgIFwiZW1pdCBkb25lIHN5bmNpbmcgdmFsdWVcIjogZW1pdCh7XG4gICAgICB0eXBlOiBcImRvbmUgc3luY2luZyB2YWx1ZVwiXG4gICAgfSksXG4gICAgXCJlbWl0IHN5bmNpbmcgdmFsdWVcIjogZW1pdCh7XG4gICAgICB0eXBlOiBcInN5bmNpbmcgdmFsdWVcIlxuICAgIH0pXG4gIH0sXG4gIGd1YXJkczoge1xuICAgIFwiaW5pdGlhbCB2YWx1ZSBzeW5jZWRcIjogKHtcbiAgICAgIGNvbnRleHRcbiAgICB9KSA9PiBjb250ZXh0LmluaXRpYWxWYWx1ZVN5bmNlZCxcbiAgICBcImlzIGJ1c3lcIjogKHtcbiAgICAgIGNvbnRleHRcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBpc1Byb2Nlc3NpbmdMb2NhbENoYW5nZXMgPSBjb250ZXh0LmlzUHJvY2Vzc2luZ0xvY2FsQ2hhbmdlcywgaXNDaGFuZ2luZyA9IGlzQ2hhbmdpbmdSZW1vdGVseShjb250ZXh0LnNsYXRlRWRpdG9yKSA/PyAhMSwgaXNCdXN5ID0gaXNQcm9jZXNzaW5nTG9jYWxDaGFuZ2VzIHx8IGlzQ2hhbmdpbmc7XG4gICAgICByZXR1cm4gZGVidWckMihcImlzQnVzeVwiLCB7XG4gICAgICAgIGlzQnVzeSxcbiAgICAgICAgaXNQcm9jZXNzaW5nTG9jYWxDaGFuZ2VzLFxuICAgICAgICBpc0NoYW5naW5nXG4gICAgICB9KSwgaXNCdXN5O1xuICAgIH0sXG4gICAgXCJpcyBlbXB0eSB2YWx1ZVwiOiAoe1xuICAgICAgZXZlbnRcbiAgICB9KSA9PiBldmVudC50eXBlID09PSBcInVwZGF0ZSB2YWx1ZVwiICYmIGV2ZW50LnZhbHVlID09PSB2b2lkIDAsXG4gICAgXCJpcyBlbXB0eSBhcnJheVwiOiAoe1xuICAgICAgZXZlbnRcbiAgICB9KSA9PiBldmVudC50eXBlID09PSBcInVwZGF0ZSB2YWx1ZVwiICYmIEFycmF5LmlzQXJyYXkoZXZlbnQudmFsdWUpICYmIGV2ZW50LnZhbHVlLmxlbmd0aCA9PT0gMCxcbiAgICBcImlzIG5ldyB2YWx1ZVwiOiAoe1xuICAgICAgY29udGV4dCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4gZXZlbnQudHlwZSA9PT0gXCJ1cGRhdGUgdmFsdWVcIiAmJiBjb250ZXh0LnByZXZpb3VzVmFsdWUgIT09IGV2ZW50LnZhbHVlLFxuICAgIFwidmFsdWUgY2hhbmdlZCB3aGlsZSBzeW5jaW5nXCI6ICh7XG4gICAgICBjb250ZXh0LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwiZG9uZSBzeW5jaW5nXCIpLCBjb250ZXh0LnBlbmRpbmdWYWx1ZSAhPT0gZXZlbnQudmFsdWUpLFxuICAgIFwicGVuZGluZyB2YWx1ZSBlcXVhbHMgcHJldmlvdXMgdmFsdWVcIjogKHtcbiAgICAgIGNvbnRleHRcbiAgICB9KSA9PiBpc0VxdWFsKGNvbnRleHQucGVuZGluZ1ZhbHVlLCBjb250ZXh0LnByZXZpb3VzVmFsdWUpXG4gIH0sXG4gIGFjdG9yczoge1xuICAgIFwic3luYyB2YWx1ZVwiOiBzeW5jVmFsdWVMb2dpY1xuICB9XG59KS5jcmVhdGVNYWNoaW5lKHtcbiAgaWQ6IFwic3luY1wiLFxuICBjb250ZXh0OiAoe1xuICAgIGlucHV0XG4gIH0pID0+ICh7XG4gICAgaW5pdGlhbFZhbHVlOiBpbnB1dC5pbml0aWFsVmFsdWUsXG4gICAgaW5pdGlhbFZhbHVlU3luY2VkOiAhMSxcbiAgICBpc1Byb2Nlc3NpbmdMb2NhbENoYW5nZXM6ICExLFxuICAgIGtleUdlbmVyYXRvcjogaW5wdXQua2V5R2VuZXJhdG9yLFxuICAgIHNjaGVtYTogaW5wdXQuc2NoZW1hLFxuICAgIHJlYWRPbmx5OiBpbnB1dC5yZWFkT25seSxcbiAgICBzbGF0ZUVkaXRvcjogaW5wdXQuc2xhdGVFZGl0b3IsXG4gICAgcGVuZGluZ1ZhbHVlOiB2b2lkIDAsXG4gICAgcHJldmlvdXNWYWx1ZTogdm9pZCAwXG4gIH0pLFxuICBlbnRyeTogW3JhaXNlJDEoKHtcbiAgICBjb250ZXh0XG4gIH0pID0+ICh7XG4gICAgdHlwZTogXCJ1cGRhdGUgdmFsdWVcIixcbiAgICB2YWx1ZTogY29udGV4dC5pbml0aWFsVmFsdWVcbiAgfSkpXSxcbiAgb246IHtcbiAgICBcImhhcyBwZW5kaW5nIG11dGF0aW9uc1wiOiB7XG4gICAgICBhY3Rpb25zOiBhc3NpZ24oe1xuICAgICAgICBpc1Byb2Nlc3NpbmdMb2NhbENoYW5nZXM6ICEwXG4gICAgICB9KVxuICAgIH0sXG4gICAgbXV0YXRpb246IHtcbiAgICAgIGFjdGlvbnM6IGFzc2lnbih7XG4gICAgICAgIGlzUHJvY2Vzc2luZ0xvY2FsQ2hhbmdlczogITFcbiAgICAgIH0pXG4gICAgfSxcbiAgICBcInVwZGF0ZSByZWFkT25seVwiOiB7XG4gICAgICBhY3Rpb25zOiBbXCJhc3NpZ24gcmVhZE9ubHlcIl1cbiAgICB9XG4gIH0sXG4gIGluaXRpYWw6IFwiaWRsZVwiLFxuICBzdGF0ZXM6IHtcbiAgICBpZGxlOiB7XG4gICAgICBlbnRyeTogWygpID0+IHtcbiAgICAgICAgZGVidWckMihcImVudHJ5OiBzeW5jaW5nLT5pZGxlXCIpO1xuICAgICAgfV0sXG4gICAgICBleGl0OiBbKCkgPT4ge1xuICAgICAgICBkZWJ1ZyQyKFwiZXhpdDogc3luY2luZy0+aWRsZVwiKTtcbiAgICAgIH1dLFxuICAgICAgb246IHtcbiAgICAgICAgXCJ1cGRhdGUgdmFsdWVcIjogW3tcbiAgICAgICAgICBndWFyZDogYW5kKFtcImlzIGVtcHR5IHZhbHVlXCIsIG5vdChcImluaXRpYWwgdmFsdWUgc3luY2VkXCIpXSksXG4gICAgICAgICAgYWN0aW9uczogW1wiYXNzaWduIGluaXRpYWwgdmFsdWUgc3luY2VkXCIsIFwiZW1pdCBkb25lIHN5bmNpbmcgdmFsdWVcIl1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGd1YXJkOiBhbmQoW1wiaXMgZW1wdHkgYXJyYXlcIiwgbm90KFwiaW5pdGlhbCB2YWx1ZSBzeW5jZWRcIildKSxcbiAgICAgICAgICBhY3Rpb25zOiBbXCJhc3NpZ24gaW5pdGlhbCB2YWx1ZSBzeW5jZWRcIiwgZW1pdCh7XG4gICAgICAgICAgICB0eXBlOiBcInZhbHVlIGNoYW5nZWRcIixcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICAgIH0pLCBcImVtaXQgZG9uZSBzeW5jaW5nIHZhbHVlXCJdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBndWFyZDogYW5kKFtcImlzIGJ1c3lcIiwgXCJpcyBuZXcgdmFsdWVcIl0pLFxuICAgICAgICAgIHRhcmdldDogXCJidXN5XCIsXG4gICAgICAgICAgYWN0aW9uczogW1wiYXNzaWduIHBlbmRpbmcgdmFsdWVcIl1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGd1YXJkOiBcImlzIG5ldyB2YWx1ZVwiLFxuICAgICAgICAgIHRhcmdldDogXCJzeW5jaW5nXCIsXG4gICAgICAgICAgYWN0aW9uczogW1wiYXNzaWduIHBlbmRpbmcgdmFsdWVcIl1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGd1YXJkOiBub3QoXCJpbml0aWFsIHZhbHVlIHN5bmNlZFwiKSxcbiAgICAgICAgICBhY3Rpb25zOiBbKCkgPT4ge1xuICAgICAgICAgICAgZGVidWckMihcIm5vIG5ldyB2YWx1ZSBcXHUyMDEzIHNldHRpbmcgaW5pdGlhbCB2YWx1ZSBhcyBzeW5jZWRcIik7XG4gICAgICAgICAgfSwgXCJhc3NpZ24gaW5pdGlhbCB2YWx1ZSBzeW5jZWRcIiwgXCJlbWl0IGRvbmUgc3luY2luZyB2YWx1ZVwiXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgYWN0aW9uczogWygpID0+IHtcbiAgICAgICAgICAgIGRlYnVnJDIoXCJubyBuZXcgdmFsdWUgYW5kIGluaXRpYWwgdmFsdWUgYWxyZWFkeSBzeW5jZWRcIik7XG4gICAgICAgICAgfV1cbiAgICAgICAgfV1cbiAgICAgIH1cbiAgICB9LFxuICAgIGJ1c3k6IHtcbiAgICAgIGVudHJ5OiBbKCkgPT4ge1xuICAgICAgICBkZWJ1ZyQyKFwiZW50cnk6IHN5bmNpbmctPmJ1c3lcIik7XG4gICAgICB9XSxcbiAgICAgIGV4aXQ6IFsoKSA9PiB7XG4gICAgICAgIGRlYnVnJDIoXCJleGl0OiBzeW5jaW5nLT5idXN5XCIpO1xuICAgICAgfV0sXG4gICAgICBhZnRlcjoge1xuICAgICAgICAxZTM6IFt7XG4gICAgICAgICAgZ3VhcmQ6IFwiaXMgYnVzeVwiLFxuICAgICAgICAgIHRhcmdldDogXCIuXCIsXG4gICAgICAgICAgcmVlbnRlcjogITAsXG4gICAgICAgICAgYWN0aW9uczogWygpID0+IHtcbiAgICAgICAgICAgIGRlYnVnJDIoXCJyZWVudGVyOiBzeW5jaW5nLT5idXN5XCIpO1xuICAgICAgICAgIH1dXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0YXJnZXQ6IFwic3luY2luZ1wiXG4gICAgICAgIH1dXG4gICAgICB9LFxuICAgICAgb246IHtcbiAgICAgICAgXCJ1cGRhdGUgdmFsdWVcIjogW3tcbiAgICAgICAgICBndWFyZDogXCJpcyBuZXcgdmFsdWVcIixcbiAgICAgICAgICBhY3Rpb25zOiBbXCJhc3NpZ24gcGVuZGluZyB2YWx1ZVwiXVxuICAgICAgICB9XVxuICAgICAgfVxuICAgIH0sXG4gICAgc3luY2luZzoge1xuICAgICAgZW50cnk6IFsoKSA9PiB7XG4gICAgICAgIGRlYnVnJDIoXCJlbnRyeTogc3luY2luZy0+c3luY2luZ1wiKTtcbiAgICAgIH0sIFwiZW1pdCBzeW5jaW5nIHZhbHVlXCJdLFxuICAgICAgZXhpdDogWygpID0+IHtcbiAgICAgICAgZGVidWckMihcImV4aXQ6IHN5bmNpbmctPnN5bmNpbmdcIik7XG4gICAgICB9LCBcImVtaXQgZG9uZSBzeW5jaW5nIHZhbHVlXCJdLFxuICAgICAgaW52b2tlOiB7XG4gICAgICAgIHNyYzogXCJzeW5jIHZhbHVlXCIsXG4gICAgICAgIGlkOiBcInN5bmMgdmFsdWVcIixcbiAgICAgICAgaW5wdXQ6ICh7XG4gICAgICAgICAgY29udGV4dFxuICAgICAgICB9KSA9PiAoe1xuICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgIGtleUdlbmVyYXRvcjogY29udGV4dC5rZXlHZW5lcmF0b3IsXG4gICAgICAgICAgICBwcmV2aW91c1ZhbHVlOiBjb250ZXh0LnByZXZpb3VzVmFsdWUsXG4gICAgICAgICAgICByZWFkT25seTogY29udGV4dC5yZWFkT25seSxcbiAgICAgICAgICAgIHNjaGVtYTogY29udGV4dC5zY2hlbWFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNsYXRlRWRpdG9yOiBjb250ZXh0LnNsYXRlRWRpdG9yLFxuICAgICAgICAgIHN0cmVhbUJsb2NrczogIWNvbnRleHQuaW5pdGlhbFZhbHVlU3luY2VkLFxuICAgICAgICAgIHZhbHVlOiBjb250ZXh0LnBlbmRpbmdWYWx1ZVxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIG9uOiB7XG4gICAgICAgIFwidXBkYXRlIHZhbHVlXCI6IHtcbiAgICAgICAgICBndWFyZDogXCJpcyBuZXcgdmFsdWVcIixcbiAgICAgICAgICBhY3Rpb25zOiBbXCJhc3NpZ24gcGVuZGluZyB2YWx1ZVwiXVxuICAgICAgICB9LFxuICAgICAgICBwYXRjaDoge1xuICAgICAgICAgIGFjdGlvbnM6IFtlbWl0KCh7XG4gICAgICAgICAgICBldmVudFxuICAgICAgICAgIH0pID0+IGV2ZW50KV1cbiAgICAgICAgfSxcbiAgICAgICAgXCJpbnZhbGlkIHZhbHVlXCI6IHtcbiAgICAgICAgICBhY3Rpb25zOiBbZW1pdCgoe1xuICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICB9KSA9PiBldmVudCldXG4gICAgICAgIH0sXG4gICAgICAgIFwidmFsdWUgY2hhbmdlZFwiOiB7XG4gICAgICAgICAgYWN0aW9uczogW2VtaXQoKHtcbiAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgfSkgPT4gZXZlbnQpXVxuICAgICAgICB9LFxuICAgICAgICBcImRvbmUgc3luY2luZ1wiOiBbe1xuICAgICAgICAgIGd1YXJkOiBcInZhbHVlIGNoYW5nZWQgd2hpbGUgc3luY2luZ1wiLFxuICAgICAgICAgIGFjdGlvbnM6IFtcImFzc2lnbiBwcmV2aW91cyB2YWx1ZVwiLCBcImFzc2lnbiBpbml0aWFsIHZhbHVlIHN5bmNlZFwiXSxcbiAgICAgICAgICB0YXJnZXQ6IFwic3luY2luZ1wiLFxuICAgICAgICAgIHJlZW50ZXI6ICEwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0YXJnZXQ6IFwiaWRsZVwiLFxuICAgICAgICAgIGFjdGlvbnM6IFtcImNsZWFyIHBlbmRpbmcgdmFsdWVcIiwgXCJhc3NpZ24gcHJldmlvdXMgdmFsdWVcIiwgXCJhc3NpZ24gaW5pdGlhbCB2YWx1ZSBzeW5jZWRcIl1cbiAgICAgICAgfV1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuYXN5bmMgZnVuY3Rpb24gdXBkYXRlVmFsdWUoe1xuICBjb250ZXh0LFxuICBzZW5kQmFjayxcbiAgc2xhdGVFZGl0b3IsXG4gIHN0cmVhbUJsb2NrcyxcbiAgdmFsdWVcbn0pIHtcbiAgbGV0IGRvbmVTeW5jaW5nID0gITEsIGlzQ2hhbmdlZCA9ICExLCBpc1ZhbGlkID0gITA7XG4gIGNvbnN0IGhhZFNlbGVjdGlvbiA9ICEhc2xhdGVFZGl0b3Iuc2VsZWN0aW9uO1xuICBpZiAoKCF2YWx1ZSB8fCB2YWx1ZS5sZW5ndGggPT09IDApICYmIChkZWJ1ZyQyKFwiVmFsdWUgaXMgZW1wdHlcIiksIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoc2xhdGVFZGl0b3IsICgpID0+IHtcbiAgICB3aXRob3V0U2F2aW5nKHNsYXRlRWRpdG9yLCAoKSA9PiB7XG4gICAgICB3aXRoUmVtb3RlQ2hhbmdlcyhzbGF0ZUVkaXRvciwgKCkgPT4ge1xuICAgICAgICB3aXRob3V0UGF0Y2hpbmcoc2xhdGVFZGl0b3IsICgpID0+IHtcbiAgICAgICAgICBpZiAoZG9uZVN5bmNpbmcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaGFkU2VsZWN0aW9uICYmIFRyYW5zZm9ybXMuZGVzZWxlY3Qoc2xhdGVFZGl0b3IpO1xuICAgICAgICAgIGNvbnN0IGNoaWxkcmVuTGVuZ3RoID0gc2xhdGVFZGl0b3IuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgIHNsYXRlRWRpdG9yLmNoaWxkcmVuLmZvckVhY2goKF8sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKHNsYXRlRWRpdG9yLCB7XG4gICAgICAgICAgICAgIGF0OiBbY2hpbGRyZW5MZW5ndGggLSAxIC0gaW5kZXhdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KSwgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhzbGF0ZUVkaXRvciwgc2xhdGVFZGl0b3IucHRlQ3JlYXRlVGV4dEJsb2NrKHtcbiAgICAgICAgICAgIGRlY29yYXRvcnM6IFtdXG4gICAgICAgICAgfSksIHtcbiAgICAgICAgICAgIGF0OiBbMF1cbiAgICAgICAgICB9KSwgaGFkU2VsZWN0aW9uICYmIFRyYW5zZm9ybXMuc2VsZWN0KHNsYXRlRWRpdG9yLCBbMCwgMF0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KSwgaXNDaGFuZ2VkID0gITApLCB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgY29uc3Qgc2xhdGVWYWx1ZUZyb21Qcm9wcyA9IHRvU2xhdGVWYWx1ZSh2YWx1ZSwge1xuICAgICAgc2NoZW1hVHlwZXM6IGNvbnRleHQuc2NoZW1hXG4gICAgfSk7XG4gICAgc3RyZWFtQmxvY2tzID8gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoc2xhdGVFZGl0b3IsICgpID0+IHtcbiAgICAgICAgd2l0aFJlbW90ZUNoYW5nZXMoc2xhdGVFZGl0b3IsICgpID0+IHtcbiAgICAgICAgICB3aXRob3V0UGF0Y2hpbmcoc2xhdGVFZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChkb25lU3luY2luZykge1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzQ2hhbmdlZCA9IHJlbW92ZUV4dHJhQmxvY2tzKHtcbiAgICAgICAgICAgICAgc2xhdGVFZGl0b3IsXG4gICAgICAgICAgICAgIHNsYXRlVmFsdWVGcm9tUHJvcHNcbiAgICAgICAgICAgIH0pLCAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IFtjdXJyZW50QmxvY2ssIGN1cnJlbnRCbG9ja0luZGV4XSBvZiBnZXRTdHJlYW1lZEJsb2Nrcyh7XG4gICAgICAgICAgICAgICAgc2xhdGVWYWx1ZTogc2xhdGVWYWx1ZUZyb21Qcm9wc1xuICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICAgIGJsb2NrQ2hhbmdlZCxcbiAgICAgICAgICAgICAgICAgIGJsb2NrVmFsaWRcbiAgICAgICAgICAgICAgICB9ID0gc3luY0Jsb2NrKHtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICBzZW5kQmFjayxcbiAgICAgICAgICAgICAgICAgIGJsb2NrOiBjdXJyZW50QmxvY2ssXG4gICAgICAgICAgICAgICAgICBpbmRleDogY3VycmVudEJsb2NrSW5kZXgsXG4gICAgICAgICAgICAgICAgICBzbGF0ZUVkaXRvcixcbiAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzQ2hhbmdlZCA9IGJsb2NrQ2hhbmdlZCB8fCBpc0NoYW5nZWQsIGlzVmFsaWQgPSBpc1ZhbGlkICYmIGJsb2NrVmFsaWQsICFpc1ZhbGlkKVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KSA6IEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoc2xhdGVFZGl0b3IsICgpID0+IHtcbiAgICAgIHdpdGhSZW1vdGVDaGFuZ2VzKHNsYXRlRWRpdG9yLCAoKSA9PiB7XG4gICAgICAgIHdpdGhvdXRQYXRjaGluZyhzbGF0ZUVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgIGlmIChkb25lU3luY2luZylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBpc0NoYW5nZWQgPSByZW1vdmVFeHRyYUJsb2Nrcyh7XG4gICAgICAgICAgICBzbGF0ZUVkaXRvcixcbiAgICAgICAgICAgIHNsYXRlVmFsdWVGcm9tUHJvcHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICAgIGZvciAoY29uc3QgY3VycmVudEJsb2NrIG9mIHNsYXRlVmFsdWVGcm9tUHJvcHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgYmxvY2tDaGFuZ2VkLFxuICAgICAgICAgICAgICBibG9ja1ZhbGlkXG4gICAgICAgICAgICB9ID0gc3luY0Jsb2NrKHtcbiAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgc2VuZEJhY2ssXG4gICAgICAgICAgICAgIGJsb2NrOiBjdXJyZW50QmxvY2ssXG4gICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICBzbGF0ZUVkaXRvcixcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGlzQ2hhbmdlZCA9IGJsb2NrQ2hhbmdlZCB8fCBpc0NoYW5nZWQsIGlzVmFsaWQgPSBpc1ZhbGlkICYmIGJsb2NrVmFsaWQsICFibG9ja1ZhbGlkKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGlmICghaXNWYWxpZCkge1xuICAgIGRlYnVnJDIoXCJJbnZhbGlkIHZhbHVlLCByZXR1cm5pbmdcIiksIGRvbmVTeW5jaW5nID0gITAsIHNlbmRCYWNrKHtcbiAgICAgIHR5cGU6IFwiZG9uZSBzeW5jaW5nXCIsXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNDaGFuZ2VkKSB7XG4gICAgZGVidWckMihcIlNlcnZlciB2YWx1ZSBjaGFuZ2VkLCBzeW5jaW5nIGVkaXRvclwiKTtcbiAgICB0cnkge1xuICAgICAgc2xhdGVFZGl0b3Iub25DaGFuZ2UoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKSwgc2VuZEJhY2soe1xuICAgICAgICB0eXBlOiBcImludmFsaWQgdmFsdWVcIixcbiAgICAgICAgcmVzb2x1dGlvbjogbnVsbCxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pLCBkb25lU3luY2luZyA9ICEwLCBzZW5kQmFjayh7XG4gICAgICAgIHR5cGU6IFwiZG9uZSBzeW5jaW5nXCIsXG4gICAgICAgIHZhbHVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGFkU2VsZWN0aW9uICYmICFzbGF0ZUVkaXRvci5zZWxlY3Rpb24gJiYgKFRyYW5zZm9ybXMuc2VsZWN0KHNsYXRlRWRpdG9yLCB7XG4gICAgICBhbmNob3I6IHtcbiAgICAgICAgcGF0aDogWzAsIDBdLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0sXG4gICAgICBmb2N1czoge1xuICAgICAgICBwYXRoOiBbMCwgMF0sXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfVxuICAgIH0pLCBzbGF0ZUVkaXRvci5vbkNoYW5nZSgpKSwgc2VuZEJhY2soe1xuICAgICAgdHlwZTogXCJ2YWx1ZSBjaGFuZ2VkXCIsXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICB9IGVsc2VcbiAgICBkZWJ1ZyQyKFwiU2VydmVyIHZhbHVlIGFuZCBlZGl0b3IgdmFsdWUgaXMgZXF1YWwsIG5vIG5lZWQgdG8gc3luYy5cIik7XG4gIGRvbmVTeW5jaW5nID0gITAsIHNlbmRCYWNrKHtcbiAgICB0eXBlOiBcImRvbmUgc3luY2luZ1wiLFxuICAgIHZhbHVlXG4gIH0pO1xufVxuZnVuY3Rpb24gcmVtb3ZlRXh0cmFCbG9ja3Moe1xuICBzbGF0ZUVkaXRvcixcbiAgc2xhdGVWYWx1ZUZyb21Qcm9wc1xufSkge1xuICBsZXQgaXNDaGFuZ2VkID0gITE7XG4gIGNvbnN0IGNoaWxkcmVuTGVuZ3RoID0gc2xhdGVFZGl0b3IuY2hpbGRyZW4ubGVuZ3RoO1xuICBpZiAoc2xhdGVWYWx1ZUZyb21Qcm9wcy5sZW5ndGggPCBjaGlsZHJlbkxlbmd0aCkge1xuICAgIGZvciAobGV0IGkgPSBjaGlsZHJlbkxlbmd0aCAtIDE7IGkgPiBzbGF0ZVZhbHVlRnJvbVByb3BzLmxlbmd0aCAtIDE7IGktLSlcbiAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoc2xhdGVFZGl0b3IsIHtcbiAgICAgICAgYXQ6IFtpXVxuICAgICAgfSk7XG4gICAgaXNDaGFuZ2VkID0gITA7XG4gIH1cbiAgcmV0dXJuIGlzQ2hhbmdlZDtcbn1cbmFzeW5jIGZ1bmN0aW9uKiBnZXRTdHJlYW1lZEJsb2Nrcyh7XG4gIHNsYXRlVmFsdWVcbn0pIHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgZm9yIGF3YWl0IChjb25zdCBibG9jayBvZiBzbGF0ZVZhbHVlKVxuICAgIGluZGV4ICUgMTAgPT09IDAgJiYgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMCkpLCB5aWVsZCBbYmxvY2ssIGluZGV4XSwgaW5kZXgrKztcbn1cbmZ1bmN0aW9uIHN5bmNCbG9jayh7XG4gIGNvbnRleHQsXG4gIHNlbmRCYWNrLFxuICBibG9jayxcbiAgaW5kZXgsXG4gIHNsYXRlRWRpdG9yLFxuICB2YWx1ZVxufSkge1xuICBsZXQgYmxvY2tDaGFuZ2VkID0gITEsIGJsb2NrVmFsaWQgPSAhMDtcbiAgY29uc3QgY3VycmVudEJsb2NrID0gYmxvY2ssIGN1cnJlbnRCbG9ja0luZGV4ID0gaW5kZXgsIG9sZEJsb2NrID0gc2xhdGVFZGl0b3IuY2hpbGRyZW5bY3VycmVudEJsb2NrSW5kZXhdLCBoYXNDaGFuZ2VzID0gb2xkQmxvY2sgJiYgIWlzRXF1YWwoY3VycmVudEJsb2NrLCBvbGRCbG9jayk7XG4gIHJldHVybiBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKHNsYXRlRWRpdG9yLCAoKSA9PiB7XG4gICAgd2l0aFJlbW90ZUNoYW5nZXMoc2xhdGVFZGl0b3IsICgpID0+IHtcbiAgICAgIHdpdGhvdXRQYXRjaGluZyhzbGF0ZUVkaXRvciwgKCkgPT4ge1xuICAgICAgICBpZiAoaGFzQ2hhbmdlcyAmJiBibG9ja1ZhbGlkKSB7XG4gICAgICAgICAgY29uc3QgdmFsaWRhdGlvblZhbHVlID0gW3ZhbHVlW2N1cnJlbnRCbG9ja0luZGV4XV0sIHZhbGlkYXRpb24gPSB2YWxpZGF0ZVZhbHVlKHZhbGlkYXRpb25WYWx1ZSwgY29udGV4dC5zY2hlbWEsIGNvbnRleHQua2V5R2VuZXJhdG9yKTtcbiAgICAgICAgICAhdmFsaWRhdGlvbi52YWxpZCAmJiB2YWxpZGF0aW9uLnJlc29sdXRpb24/LmF1dG9SZXNvbHZlICYmIHZhbGlkYXRpb24ucmVzb2x1dGlvbj8ucGF0Y2hlcy5sZW5ndGggPiAwICYmICFjb250ZXh0LnJlYWRPbmx5ICYmIGNvbnRleHQucHJldmlvdXNWYWx1ZSAmJiBjb250ZXh0LnByZXZpb3VzVmFsdWUgIT09IHZhbHVlICYmIChjb25zb2xlLndhcm4oYCR7dmFsaWRhdGlvbi5yZXNvbHV0aW9uLmFjdGlvbn0gZm9yIGJsb2NrIHdpdGggX2tleSAnJHt2YWxpZGF0aW9uVmFsdWVbMF0uX2tleX0nLiAke3ZhbGlkYXRpb24ucmVzb2x1dGlvbj8uZGVzY3JpcHRpb259YCksIHZhbGlkYXRpb24ucmVzb2x1dGlvbi5wYXRjaGVzLmZvckVhY2goKHBhdGNoKSA9PiB7XG4gICAgICAgICAgICBzZW5kQmFjayh7XG4gICAgICAgICAgICAgIHR5cGU6IFwicGF0Y2hcIixcbiAgICAgICAgICAgICAgcGF0Y2hcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pKSwgdmFsaWRhdGlvbi52YWxpZCB8fCB2YWxpZGF0aW9uLnJlc29sdXRpb24/LmF1dG9SZXNvbHZlID8gKG9sZEJsb2NrLl9rZXkgPT09IGN1cnJlbnRCbG9jay5fa2V5ID8gKGRlYnVnJDIuZW5hYmxlZCAmJiBkZWJ1ZyQyKFwiVXBkYXRpbmcgYmxvY2tcIiwgb2xkQmxvY2ssIGN1cnJlbnRCbG9jayksIF91cGRhdGVCbG9jayhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrLCBvbGRCbG9jaywgY3VycmVudEJsb2NrSW5kZXgpKSA6IChkZWJ1ZyQyLmVuYWJsZWQgJiYgZGVidWckMihcIlJlcGxhY2luZyBibG9ja1wiLCBvbGRCbG9jaywgY3VycmVudEJsb2NrKSwgX3JlcGxhY2VCbG9jayhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrLCBjdXJyZW50QmxvY2tJbmRleCkpLCBibG9ja0NoYW5nZWQgPSAhMCkgOiAoc2VuZEJhY2soe1xuICAgICAgICAgICAgdHlwZTogXCJpbnZhbGlkIHZhbHVlXCIsXG4gICAgICAgICAgICByZXNvbHV0aW9uOiB2YWxpZGF0aW9uLnJlc29sdXRpb24sXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0pLCBibG9ja1ZhbGlkID0gITEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb2xkQmxvY2sgJiYgYmxvY2tWYWxpZCkge1xuICAgICAgICAgIGNvbnN0IHZhbGlkYXRpb25WYWx1ZSA9IFt2YWx1ZVtjdXJyZW50QmxvY2tJbmRleF1dLCB2YWxpZGF0aW9uID0gdmFsaWRhdGVWYWx1ZSh2YWxpZGF0aW9uVmFsdWUsIGNvbnRleHQuc2NoZW1hLCBjb250ZXh0LmtleUdlbmVyYXRvcik7XG4gICAgICAgICAgZGVidWckMi5lbmFibGVkICYmIGRlYnVnJDIoXCJWYWxpZGF0aW5nIGFuZCBpbnNlcnRpbmcgbmV3IGJsb2NrIGluIHRoZSBlbmQgb2YgdGhlIHZhbHVlXCIsIGN1cnJlbnRCbG9jayksIHZhbGlkYXRpb24udmFsaWQgfHwgdmFsaWRhdGlvbi5yZXNvbHV0aW9uPy5hdXRvUmVzb2x2ZSA/IFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoc2xhdGVFZGl0b3IsIGN1cnJlbnRCbG9jaywge1xuICAgICAgICAgICAgYXQ6IFtjdXJyZW50QmxvY2tJbmRleF1cbiAgICAgICAgICB9KSA6IChkZWJ1ZyQyKFwiSW52YWxpZFwiLCB2YWxpZGF0aW9uKSwgc2VuZEJhY2soe1xuICAgICAgICAgICAgdHlwZTogXCJpbnZhbGlkIHZhbHVlXCIsXG4gICAgICAgICAgICByZXNvbHV0aW9uOiB2YWxpZGF0aW9uLnJlc29sdXRpb24sXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0pLCBibG9ja1ZhbGlkID0gITEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSksIHtcbiAgICBibG9ja0NoYW5nZWQsXG4gICAgYmxvY2tWYWxpZFxuICB9O1xufVxuZnVuY3Rpb24gX3JlcGxhY2VCbG9jayhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrLCBjdXJyZW50QmxvY2tJbmRleCkge1xuICBjb25zdCBjdXJyZW50U2VsZWN0aW9uID0gc2xhdGVFZGl0b3Iuc2VsZWN0aW9uLCBzZWxlY3Rpb25Gb2N1c09uQmxvY2sgPSBjdXJyZW50U2VsZWN0aW9uICYmIGN1cnJlbnRTZWxlY3Rpb24uZm9jdXMucGF0aFswXSA9PT0gY3VycmVudEJsb2NrSW5kZXg7XG4gIHNlbGVjdGlvbkZvY3VzT25CbG9jayAmJiBUcmFuc2Zvcm1zLmRlc2VsZWN0KHNsYXRlRWRpdG9yKSwgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhzbGF0ZUVkaXRvciwge1xuICAgIGF0OiBbY3VycmVudEJsb2NrSW5kZXhdXG4gIH0pLCBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKHNsYXRlRWRpdG9yLCBjdXJyZW50QmxvY2ssIHtcbiAgICBhdDogW2N1cnJlbnRCbG9ja0luZGV4XVxuICB9KSwgc2xhdGVFZGl0b3Iub25DaGFuZ2UoKSwgc2VsZWN0aW9uRm9jdXNPbkJsb2NrICYmIFRyYW5zZm9ybXMuc2VsZWN0KHNsYXRlRWRpdG9yLCBjdXJyZW50U2VsZWN0aW9uKTtcbn1cbmZ1bmN0aW9uIF91cGRhdGVCbG9jayhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrLCBvbGRCbG9jaywgY3VycmVudEJsb2NrSW5kZXgpIHtcbiAgaWYgKFRyYW5zZm9ybXMuc2V0Tm9kZXMoc2xhdGVFZGl0b3IsIGN1cnJlbnRCbG9jaywge1xuICAgIGF0OiBbY3VycmVudEJsb2NrSW5kZXhdXG4gIH0pLCBzbGF0ZUVkaXRvci5pc1RleHRCbG9jayhjdXJyZW50QmxvY2spICYmIHNsYXRlRWRpdG9yLmlzVGV4dEJsb2NrKG9sZEJsb2NrKSkge1xuICAgIGNvbnN0IG9sZEJsb2NrQ2hpbGRyZW5MZW5ndGggPSBvbGRCbG9jay5jaGlsZHJlbi5sZW5ndGg7XG4gICAgY3VycmVudEJsb2NrLmNoaWxkcmVuLmxlbmd0aCA8IG9sZEJsb2NrQ2hpbGRyZW5MZW5ndGggJiYgQXJyYXkuZnJvbShBcnJheShvbGRCbG9ja0NoaWxkcmVuTGVuZ3RoIC0gY3VycmVudEJsb2NrLmNoaWxkcmVuLmxlbmd0aCkpLmZvckVhY2goKF8sIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBjaGlsZEluZGV4ID0gb2xkQmxvY2tDaGlsZHJlbkxlbmd0aCAtIDEgLSBpbmRleDtcbiAgICAgIGNoaWxkSW5kZXggPiAwICYmIChkZWJ1ZyQyKFwiUmVtb3ZpbmcgY2hpbGRcIiksIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoc2xhdGVFZGl0b3IsIHtcbiAgICAgICAgYXQ6IFtjdXJyZW50QmxvY2tJbmRleCwgY2hpbGRJbmRleF1cbiAgICAgIH0pKTtcbiAgICB9KSwgY3VycmVudEJsb2NrLmNoaWxkcmVuLmZvckVhY2goKGN1cnJlbnRCbG9ja0NoaWxkLCBjdXJyZW50QmxvY2tDaGlsZEluZGV4KSA9PiB7XG4gICAgICBjb25zdCBvbGRCbG9ja0NoaWxkID0gb2xkQmxvY2suY2hpbGRyZW5bY3VycmVudEJsb2NrQ2hpbGRJbmRleF0sIGlzQ2hpbGRDaGFuZ2VkID0gIWlzRXF1YWwoY3VycmVudEJsb2NrQ2hpbGQsIG9sZEJsb2NrQ2hpbGQpLCBpc1RleHRDaGFuZ2VkID0gIWlzRXF1YWwoY3VycmVudEJsb2NrQ2hpbGQudGV4dCwgb2xkQmxvY2tDaGlsZD8udGV4dCksIHBhdGggPSBbY3VycmVudEJsb2NrSW5kZXgsIGN1cnJlbnRCbG9ja0NoaWxkSW5kZXhdO1xuICAgICAgaWYgKGlzQ2hpbGRDaGFuZ2VkKVxuICAgICAgICBpZiAoY3VycmVudEJsb2NrQ2hpbGQuX2tleSA9PT0gb2xkQmxvY2tDaGlsZD8uX2tleSkge1xuICAgICAgICAgIGRlYnVnJDIoXCJVcGRhdGluZyBjaGFuZ2VkIGNoaWxkXCIsIGN1cnJlbnRCbG9ja0NoaWxkLCBvbGRCbG9ja0NoaWxkKSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrQ2hpbGQsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgaXNTcGFuTm9kZTIgPSBUZXh0LmlzVGV4dChjdXJyZW50QmxvY2tDaGlsZCkgJiYgY3VycmVudEJsb2NrQ2hpbGQuX3R5cGUgPT09IFwic3BhblwiICYmIFRleHQuaXNUZXh0KG9sZEJsb2NrQ2hpbGQpICYmIG9sZEJsb2NrQ2hpbGQuX3R5cGUgPT09IFwic3BhblwiO1xuICAgICAgICAgIGlzU3Bhbk5vZGUyICYmIGlzVGV4dENoYW5nZWQgPyAob2xkQmxvY2tDaGlsZC50ZXh0Lmxlbmd0aCA+IDAgJiYgZGVsZXRlVGV4dChzbGF0ZUVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHtcbiAgICAgICAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBhbmNob3I6IHtcbiAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgIG9mZnNldDogb2xkQmxvY2tDaGlsZC50ZXh0Lmxlbmd0aFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIFRyYW5zZm9ybXMuaW5zZXJ0VGV4dChzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrQ2hpbGQudGV4dCwge1xuICAgICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgICB9KSwgc2xhdGVFZGl0b3Iub25DaGFuZ2UoKSkgOiBpc1NwYW5Ob2RlMiB8fCAoZGVidWckMihcIlVwZGF0aW5nIGNoYW5nZWQgaW5saW5lIG9iamVjdCBjaGlsZFwiLCBjdXJyZW50QmxvY2tDaGlsZCksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoc2xhdGVFZGl0b3IsIHtcbiAgICAgICAgICAgIF9rZXk6IFZPSURfQ0hJTERfS0VZXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IFsuLi5wYXRoLCAwXSxcbiAgICAgICAgICAgIHZvaWRzOiAhMFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIG9sZEJsb2NrQ2hpbGQgPyAoZGVidWckMihcIlJlcGxhY2luZyBjaGlsZFwiLCBjdXJyZW50QmxvY2tDaGlsZCksIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoc2xhdGVFZGl0b3IsIHtcbiAgICAgICAgICBhdDogW2N1cnJlbnRCbG9ja0luZGV4LCBjdXJyZW50QmxvY2tDaGlsZEluZGV4XVxuICAgICAgICB9KSwgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrQ2hpbGQsIHtcbiAgICAgICAgICBhdDogW2N1cnJlbnRCbG9ja0luZGV4LCBjdXJyZW50QmxvY2tDaGlsZEluZGV4XVxuICAgICAgICB9KSwgc2xhdGVFZGl0b3Iub25DaGFuZ2UoKSkgOiBvbGRCbG9ja0NoaWxkIHx8IChkZWJ1ZyQyKFwiSW5zZXJ0aW5nIG5ldyBjaGlsZFwiLCBjdXJyZW50QmxvY2tDaGlsZCksIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoc2xhdGVFZGl0b3IsIGN1cnJlbnRCbG9ja0NoaWxkLCB7XG4gICAgICAgICAgYXQ6IFtjdXJyZW50QmxvY2tJbmRleCwgY3VycmVudEJsb2NrQ2hpbGRJbmRleF1cbiAgICAgICAgfSksIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCkpO1xuICAgIH0pO1xuICB9XG59XG5jb25zdCBkZWJ1ZyQxID0gZGVidWdXaXRoTmFtZShcInNldHVwXCIpO1xuZnVuY3Rpb24gY3JlYXRlSW50ZXJuYWxFZGl0b3IoY29uZmlnKSB7XG4gIGRlYnVnJDEoXCJDcmVhdGluZyBuZXcgRWRpdG9yIGluc3RhbmNlXCIpO1xuICBjb25zdCBzdWJzY3JpcHRpb25zID0gW10sIGVkaXRvckFjdG9yID0gY3JlYXRlQWN0b3IoZWRpdG9yTWFjaGluZSwge1xuICAgIGlucHV0OiBlZGl0b3JDb25maWdUb01hY2hpbmVJbnB1dChjb25maWcpXG4gIH0pLCByZWxheUFjdG9yID0gY3JlYXRlQWN0b3IocmVsYXlNYWNoaW5lKSwgc2xhdGVFZGl0b3IgPSBjcmVhdGVTbGF0ZUVkaXRvcih7XG4gICAgZWRpdG9yQWN0b3IsXG4gICAgcmVsYXlBY3RvcixcbiAgICBzdWJzY3JpcHRpb25zXG4gIH0pLCBlZGl0YWJsZSA9IGNyZWF0ZUVkaXRhYmxlQVBJKHNsYXRlRWRpdG9yLmluc3RhbmNlLCBlZGl0b3JBY3RvciksIHtcbiAgICBtdXRhdGlvbkFjdG9yLFxuICAgIHN5bmNBY3RvclxuICB9ID0gY3JlYXRlQWN0b3JzKHtcbiAgICBlZGl0b3JBY3RvcixcbiAgICByZWxheUFjdG9yLFxuICAgIHNsYXRlRWRpdG9yOiBzbGF0ZUVkaXRvci5pbnN0YW5jZSxcbiAgICBzdWJzY3JpcHRpb25zXG4gIH0pLCBlZGl0b3IgPSB7XG4gICAgZG9tOiBjcmVhdGVFZGl0b3JEb20oKGV2ZW50KSA9PiBlZGl0b3JBY3Rvci5zZW5kKGV2ZW50KSwgc2xhdGVFZGl0b3IuaW5zdGFuY2UpLFxuICAgIGdldFNuYXBzaG90OiAoKSA9PiBnZXRFZGl0b3JTbmFwc2hvdCh7XG4gICAgICBlZGl0b3JBY3RvclNuYXBzaG90OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLFxuICAgICAgc2xhdGVFZGl0b3JJbnN0YW5jZTogc2xhdGVFZGl0b3IuaW5zdGFuY2VcbiAgICB9KSxcbiAgICByZWdpc3RlckJlaGF2aW9yOiAoYmVoYXZpb3JDb25maWcpID0+IHtcbiAgICAgIGNvbnN0IHByaW9yaXR5ID0gY3JlYXRlRWRpdG9yUHJpb3JpdHkoe1xuICAgICAgICBuYW1lOiBcImN1c3RvbVwiLFxuICAgICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgICBwcmlvcml0eTogY29yZVByaW9yaXR5LFxuICAgICAgICAgIGltcG9ydGFuY2U6IFwiaGlnaGVyXCJcbiAgICAgICAgfVxuICAgICAgfSksIGJlaGF2aW9yQ29uZmlnV2l0aFByaW9yaXR5ID0ge1xuICAgICAgICAuLi5iZWhhdmlvckNvbmZpZyxcbiAgICAgICAgcHJpb3JpdHlcbiAgICAgIH07XG4gICAgICByZXR1cm4gZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYWRkIGJlaGF2aW9yXCIsXG4gICAgICAgIGJlaGF2aW9yQ29uZmlnOiBiZWhhdmlvckNvbmZpZ1dpdGhQcmlvcml0eVxuICAgICAgfSksICgpID0+IHtcbiAgICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJyZW1vdmUgYmVoYXZpb3JcIixcbiAgICAgICAgICBiZWhhdmlvckNvbmZpZzogYmVoYXZpb3JDb25maWdXaXRoUHJpb3JpdHlcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0sXG4gICAgc2VuZDogKGV2ZW50KSA9PiB7XG4gICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgY2FzZSBcInVwZGF0ZSB2YWx1ZVwiOlxuICAgICAgICAgIHN5bmNBY3Rvci5zZW5kKGV2ZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInVwZGF0ZSByZWFkT25seVwiOlxuICAgICAgICBjYXNlIFwicGF0Y2hlc1wiOlxuICAgICAgICBjYXNlIFwidXBkYXRlIG1heEJsb2Nrc1wiOlxuICAgICAgICAgIGVkaXRvckFjdG9yLnNlbmQoZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGVkaXRvckFjdG9yLnNlbmQocmVyb3V0ZUV4dGVybmFsQmVoYXZpb3JFdmVudCh7XG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgIHNsYXRlRWRpdG9yOiBzbGF0ZUVkaXRvci5pbnN0YW5jZVxuICAgICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uOiAoZXZlbnQsIGxpc3RlbmVyKSA9PiByZWxheUFjdG9yLm9uKGV2ZW50LCAoZXZlbnQyKSA9PiB7XG4gICAgICBzd2l0Y2ggKGV2ZW50Mi50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJibHVycmVkXCI6XG4gICAgICAgIGNhc2UgXCJkb25lIGxvYWRpbmdcIjpcbiAgICAgICAgY2FzZSBcImVkaXRhYmxlXCI6XG4gICAgICAgIGNhc2UgXCJmb2N1c2VkXCI6XG4gICAgICAgIGNhc2UgXCJpbnZhbGlkIHZhbHVlXCI6XG4gICAgICAgIGNhc2UgXCJsb2FkaW5nXCI6XG4gICAgICAgIGNhc2UgXCJtdXRhdGlvblwiOlxuICAgICAgICBjYXNlIFwicGF0Y2hcIjpcbiAgICAgICAgY2FzZSBcInJlYWQgb25seVwiOlxuICAgICAgICBjYXNlIFwicmVhZHlcIjpcbiAgICAgICAgY2FzZSBcInNlbGVjdGlvblwiOlxuICAgICAgICBjYXNlIFwidmFsdWUgY2hhbmdlZFwiOlxuICAgICAgICAgIGxpc3RlbmVyKGV2ZW50Mik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSksXG4gICAgX2ludGVybmFsOiB7XG4gICAgICBlZGl0YWJsZSxcbiAgICAgIGVkaXRvckFjdG9yLFxuICAgICAgc2xhdGVFZGl0b3JcbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgYWN0b3JzOiB7XG4gICAgICBlZGl0b3JBY3RvcixcbiAgICAgIG11dGF0aW9uQWN0b3IsXG4gICAgICByZWxheUFjdG9yLFxuICAgICAgc3luY0FjdG9yXG4gICAgfSxcbiAgICBlZGl0b3IsXG4gICAgc3Vic2NyaXB0aW9uc1xuICB9O1xufVxuZnVuY3Rpb24gZWRpdG9yQ29uZmlnVG9NYWNoaW5lSW5wdXQoY29uZmlnKSB7XG4gIGNvbnN0IHtcbiAgICBsZWdhY3lTY2hlbWEsXG4gICAgc2NoZW1hXG4gIH0gPSBjb21waWxlU2NoZW1hc0Zyb21FZGl0b3JDb25maWcoY29uZmlnKTtcbiAgcmV0dXJuIHtcbiAgICBjb252ZXJ0ZXJzOiBjcmVhdGVDb3JlQ29udmVydGVycyhsZWdhY3lTY2hlbWEpLFxuICAgIGdldExlZ2FjeVNjaGVtYTogKCkgPT4gbGVnYWN5U2NoZW1hLFxuICAgIGtleUdlbmVyYXRvcjogY29uZmlnLmtleUdlbmVyYXRvciA/PyBkZWZhdWx0S2V5R2VuZXJhdG9yLFxuICAgIG1heEJsb2NrczogY29uZmlnLm1heEJsb2NrcyxcbiAgICByZWFkT25seTogY29uZmlnLnJlYWRPbmx5LFxuICAgIHNjaGVtYSxcbiAgICBpbml0aWFsVmFsdWU6IGNvbmZpZy5pbml0aWFsVmFsdWVcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVTY2hlbWFzRnJvbUVkaXRvckNvbmZpZyhjb25maWcpIHtcbiAgY29uc3QgbGVnYWN5U2NoZW1hID0gY29uZmlnLnNjaGVtYURlZmluaXRpb24gPyBjb21waWxlU2NoZW1hRGVmaW5pdGlvblRvUG9ydGFibGVUZXh0TWVtYmVyU2NoZW1hVHlwZXMoY29uZmlnLnNjaGVtYURlZmluaXRpb24pIDogY3JlYXRlUG9ydGFibGVUZXh0TWVtYmVyU2NoZW1hVHlwZXMoY29uZmlnLnNjaGVtYS5oYXNPd25Qcm9wZXJ0eShcImpzb25UeXBlXCIpID8gY29uZmlnLnNjaGVtYSA6IGNvbXBpbGVUeXBlKGNvbmZpZy5zY2hlbWEpKSwgc2NoZW1hID0gY29uZmlnLnNjaGVtYURlZmluaXRpb24gPyBjb21waWxlU2NoZW1hKGNvbmZpZy5zY2hlbWFEZWZpbml0aW9uKSA6IHBvcnRhYmxlVGV4dE1lbWJlclNjaGVtYVR5cGVzVG9TY2hlbWEobGVnYWN5U2NoZW1hKTtcbiAgcmV0dXJuIHtcbiAgICBsZWdhY3lTY2hlbWEsXG4gICAgc2NoZW1hXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVBY3RvcnMoY29uZmlnKSB7XG4gIGRlYnVnJDEoXCJDcmVhdGluZyBuZXcgQWN0b3JzXCIpO1xuICBjb25zdCBtdXRhdGlvbkFjdG9yID0gY3JlYXRlQWN0b3IobXV0YXRpb25NYWNoaW5lLCB7XG4gICAgaW5wdXQ6IHtcbiAgICAgIHJlYWRPbmx5OiBjb25maWcuZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5tYXRjaGVzKHtcbiAgICAgICAgXCJlZGl0IG1vZGVcIjogXCJyZWFkIG9ubHlcIlxuICAgICAgfSksXG4gICAgICBzY2hlbWE6IGNvbmZpZy5lZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLFxuICAgICAgc2xhdGVFZGl0b3I6IGNvbmZpZy5zbGF0ZUVkaXRvclxuICAgIH1cbiAgfSksIHN5bmNBY3RvciA9IGNyZWF0ZUFjdG9yKHN5bmNNYWNoaW5lLCB7XG4gICAgaW5wdXQ6IHtcbiAgICAgIGluaXRpYWxWYWx1ZTogY29uZmlnLmVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5pbml0aWFsVmFsdWUsXG4gICAgICBrZXlHZW5lcmF0b3I6IGNvbmZpZy5lZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yLFxuICAgICAgcmVhZE9ubHk6IGNvbmZpZy5lZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLm1hdGNoZXMoe1xuICAgICAgICBcImVkaXQgbW9kZVwiOiBcInJlYWQgb25seVwiXG4gICAgICB9KSxcbiAgICAgIHNjaGVtYTogY29uZmlnLmVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEsXG4gICAgICBzbGF0ZUVkaXRvcjogY29uZmlnLnNsYXRlRWRpdG9yXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNvbmZpZy5zdWJzY3JpcHRpb25zLnB1c2goKCkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IG11dGF0aW9uQWN0b3Iub24oXCIqXCIsIChldmVudCkgPT4ge1xuICAgICAgZXZlbnQudHlwZSA9PT0gXCJoYXMgcGVuZGluZyBtdXRhdGlvbnNcIiAmJiBzeW5jQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiaGFzIHBlbmRpbmcgbXV0YXRpb25zXCJcbiAgICAgIH0pLCBldmVudC50eXBlID09PSBcIm11dGF0aW9uXCIgJiYgKHN5bmNBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJtdXRhdGlvblwiXG4gICAgICB9KSwgY29uZmlnLmVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcIm11dGF0aW9uXCIsXG4gICAgICAgIHBhdGNoZXM6IGV2ZW50LnBhdGNoZXMsXG4gICAgICAgIHNuYXBzaG90OiBldmVudC5zbmFwc2hvdCxcbiAgICAgICAgdmFsdWU6IGV2ZW50LnNuYXBzaG90XG4gICAgICB9KSksIGV2ZW50LnR5cGUgPT09IFwicGF0Y2hcIiAmJiBjb25maWcucmVsYXlBY3Rvci5zZW5kKGV2ZW50KTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSksIGNvbmZpZy5zdWJzY3JpcHRpb25zLnB1c2goKCkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHN5bmNBY3Rvci5vbihcIipcIiwgKGV2ZW50KSA9PiB7XG4gICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImludmFsaWQgdmFsdWVcIjpcbiAgICAgICAgICBjb25maWcucmVsYXlBY3Rvci5zZW5kKGV2ZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInZhbHVlIGNoYW5nZWRcIjpcbiAgICAgICAgICBjb25maWcucmVsYXlBY3Rvci5zZW5kKGV2ZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInBhdGNoXCI6XG4gICAgICAgICAgY29uZmlnLmVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgICAgICB0eXBlOiBcImludGVybmFsLnBhdGNoXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnJvbVNsYXRlVmFsdWUoY29uZmlnLnNsYXRlRWRpdG9yLmNoaWxkcmVuLCBjb25maWcuZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoY29uZmlnLnNsYXRlRWRpdG9yKSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb25maWcuZWRpdG9yQWN0b3Iuc2VuZChldmVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0pLCBjb25maWcuc3Vic2NyaXB0aW9ucy5wdXNoKCgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBjb25maWcuZWRpdG9yQWN0b3Iuc3Vic2NyaWJlKChzbmFwc2hvdCkgPT4ge1xuICAgICAgc25hcHNob3QubWF0Y2hlcyh7XG4gICAgICAgIFwiZWRpdCBtb2RlXCI6IFwicmVhZCBvbmx5XCJcbiAgICAgIH0pID8gKG11dGF0aW9uQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwidXBkYXRlIHJlYWRPbmx5XCIsXG4gICAgICAgIHJlYWRPbmx5OiAhMFxuICAgICAgfSksIHN5bmNBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJ1cGRhdGUgcmVhZE9ubHlcIixcbiAgICAgICAgcmVhZE9ubHk6ICEwXG4gICAgICB9KSkgOiAobXV0YXRpb25BY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJ1cGRhdGUgcmVhZE9ubHlcIixcbiAgICAgICAgcmVhZE9ubHk6ICExXG4gICAgICB9KSwgc3luY0FjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcInVwZGF0ZSByZWFkT25seVwiLFxuICAgICAgICByZWFkT25seTogITFcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSksIGNvbmZpZy5zdWJzY3JpcHRpb25zLnB1c2goKCkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGNvbmZpZy5lZGl0b3JBY3Rvci5vbihcIipcIiwgKGV2ZW50KSA9PiB7XG4gICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImVkaXRhYmxlXCI6XG4gICAgICAgIGNhc2UgXCJtdXRhdGlvblwiOlxuICAgICAgICBjYXNlIFwicmVhZHlcIjpcbiAgICAgICAgY2FzZSBcInJlYWQgb25seVwiOlxuICAgICAgICBjYXNlIFwic2VsZWN0aW9uXCI6XG4gICAgICAgICAgY29uZmlnLnJlbGF5QWN0b3Iuc2VuZChldmVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpbnRlcm5hbC5wYXRjaFwiOlxuICAgICAgICAgIG11dGF0aW9uQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgICAgIHR5cGU6IFwicGF0Y2hcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9KSwge1xuICAgIG11dGF0aW9uQWN0b3IsXG4gICAgc3luY0FjdG9yXG4gIH07XG59XG5mdW5jdGlvbiBldmVudFRvQ2hhbmdlKGV2ZW50KSB7XG4gIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgIGNhc2UgXCJibHVycmVkXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImJsdXJcIixcbiAgICAgICAgZXZlbnQ6IGV2ZW50LmV2ZW50XG4gICAgICB9O1xuICAgIGNhc2UgXCJwYXRjaFwiOlxuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIGNhc2UgXCJsb2FkaW5nXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImxvYWRpbmdcIixcbiAgICAgICAgaXNMb2FkaW5nOiAhMFxuICAgICAgfTtcbiAgICBjYXNlIFwiZG9uZSBsb2FkaW5nXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImxvYWRpbmdcIixcbiAgICAgICAgaXNMb2FkaW5nOiAhMVxuICAgICAgfTtcbiAgICBjYXNlIFwiZm9jdXNlZFwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJmb2N1c1wiLFxuICAgICAgICBldmVudDogZXZlbnQuZXZlbnRcbiAgICAgIH07XG4gICAgY2FzZSBcInZhbHVlIGNoYW5nZWRcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidmFsdWVcIixcbiAgICAgICAgdmFsdWU6IGV2ZW50LnZhbHVlXG4gICAgICB9O1xuICAgIGNhc2UgXCJpbnZhbGlkIHZhbHVlXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImludmFsaWRWYWx1ZVwiLFxuICAgICAgICByZXNvbHV0aW9uOiBldmVudC5yZXNvbHV0aW9uLFxuICAgICAgICB2YWx1ZTogZXZlbnQudmFsdWVcbiAgICAgIH07XG4gICAgY2FzZSBcIm11dGF0aW9uXCI6XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgY2FzZSBcInJlYWR5XCI6XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgY2FzZSBcInNlbGVjdGlvblwiOlxuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIGNhc2UgXCJ1bnNldFwiOlxuICAgICAgcmV0dXJuIGV2ZW50O1xuICB9XG59XG5jb25zdCBkZWJ1ZyA9IGRlYnVnV2l0aE5hbWUoXCJjb21wb25lbnQ6UG9ydGFibGVUZXh0RWRpdG9yXCIpO1xuY2xhc3MgUG9ydGFibGVUZXh0RWRpdG9yIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgc3RhdGljIGRpc3BsYXlOYW1lID0gXCJQb3J0YWJsZVRleHRFZGl0b3JcIjtcbiAgLyoqXG4gICAqIEFuIG9ic2VydmFibGUgb2YgYWxsIHRoZSBlZGl0b3IgY2hhbmdlcy5cbiAgICovXG4gIGNoYW5nZSQgPSBuZXcgU3ViamVjdCgpO1xuICAvKipcbiAgICogQSBsb29rdXAgdGFibGUgZm9yIGFsbCB0aGUgcmVsZXZhbnQgc2NoZW1hIHR5cGVzIGZvciB0aGlzIHBvcnRhYmxlIHRleHQgdHlwZS5cbiAgICovXG4gIC8qKlxuICAgKiBUaGUgZWRpdG9yIGluc3RhbmNlXG4gICAqL1xuICAvKlxuICAgKiBUaGUgZWRpdG9yIEFQSSAoY3VycmVudGx5IGltcGxlbWVudGVkIHdpdGggU2xhdGUpLlxuICAgKi9cbiAgc3Vic2NyaXB0aW9ucyA9IFtdO1xuICB1bnN1YnNjcmliZXJzID0gW107XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgaWYgKHN1cGVyKHByb3BzKSwgcHJvcHMuZWRpdG9yKVxuICAgICAgdGhpcy5lZGl0b3IgPSBwcm9wcy5lZGl0b3IsIHRoaXMuc2NoZW1hVHlwZXMgPSB0aGlzLmVkaXRvci5faW50ZXJuYWwuZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmdldExlZ2FjeVNjaGVtYSgpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhY3RvcnMsXG4gICAgICAgIGVkaXRvcixcbiAgICAgICAgc3Vic2NyaXB0aW9uc1xuICAgICAgfSA9IGNyZWF0ZUludGVybmFsRWRpdG9yKHtcbiAgICAgICAgaW5pdGlhbFZhbHVlOiBwcm9wcy52YWx1ZSxcbiAgICAgICAga2V5R2VuZXJhdG9yOiBwcm9wcy5rZXlHZW5lcmF0b3IsXG4gICAgICAgIG1heEJsb2NrczogcHJvcHMubWF4QmxvY2tzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBOdW1iZXIucGFyc2VJbnQocHJvcHMubWF4QmxvY2tzLnRvU3RyaW5nKCksIDEwKSxcbiAgICAgICAgcmVhZE9ubHk6IHByb3BzLnJlYWRPbmx5LFxuICAgICAgICBzY2hlbWE6IHByb3BzLnNjaGVtYVR5cGVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gc3Vic2NyaXB0aW9ucywgdGhpcy5hY3RvcnMgPSBhY3RvcnMsIHRoaXMuZWRpdG9yID0gZWRpdG9yLCB0aGlzLnNjaGVtYVR5cGVzID0gYWN0b3JzLmVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5nZXRMZWdhY3lTY2hlbWEoKTtcbiAgICB9XG4gICAgdGhpcy5lZGl0YWJsZSA9IHRoaXMuZWRpdG9yLl9pbnRlcm5hbC5lZGl0YWJsZTtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpZiAoIXRoaXMuYWN0b3JzKVxuICAgICAgcmV0dXJuO1xuICAgIGZvciAoY29uc3Qgc3Vic2NyaXB0aW9uIG9mIHRoaXMuc3Vic2NyaXB0aW9ucylcbiAgICAgIHRoaXMudW5zdWJzY3JpYmVycy5wdXNoKHN1YnNjcmlwdGlvbigpKTtcbiAgICBjb25zdCByZWxheUFjdG9yU3Vic2NyaXB0aW9uID0gdGhpcy5hY3RvcnMucmVsYXlBY3Rvci5vbihcIipcIiwgKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBjaGFuZ2UgPSBldmVudFRvQ2hhbmdlKGV2ZW50KTtcbiAgICAgIGNoYW5nZSAmJiAodGhpcy5wcm9wcy5lZGl0b3IgfHwgdGhpcy5wcm9wcy5vbkNoYW5nZShjaGFuZ2UpLCB0aGlzLmNoYW5nZSQubmV4dChjaGFuZ2UpKTtcbiAgICB9KTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlcnMucHVzaChyZWxheUFjdG9yU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKSwgdGhpcy5hY3RvcnMuZWRpdG9yQWN0b3Iuc3RhcnQoKSwgdGhpcy5hY3RvcnMubXV0YXRpb25BY3Rvci5zdGFydCgpLCB0aGlzLmFjdG9ycy5yZWxheUFjdG9yLnN0YXJ0KCksIHRoaXMuYWN0b3JzLnN5bmNBY3Rvci5zdGFydCgpO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAhdGhpcy5wcm9wcy5lZGl0b3IgJiYgIXByZXZQcm9wcy5lZGl0b3IgJiYgdGhpcy5wcm9wcy5zY2hlbWFUeXBlICE9PSBwcmV2UHJvcHMuc2NoZW1hVHlwZSAmJiBjb25zb2xlLndhcm4oXCJVcGRhdGluZyBzY2hlbWEgdHlwZSBpcyBubyBsb25nZXIgc3VwcG9ydGVkXCIpLCAhdGhpcy5wcm9wcy5lZGl0b3IgJiYgIXByZXZQcm9wcy5lZGl0b3IgJiYgKHRoaXMucHJvcHMucmVhZE9ubHkgIT09IHByZXZQcm9wcy5yZWFkT25seSAmJiB0aGlzLmVkaXRvci5faW50ZXJuYWwuZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICB0eXBlOiBcInVwZGF0ZSByZWFkT25seVwiLFxuICAgICAgcmVhZE9ubHk6IHRoaXMucHJvcHMucmVhZE9ubHkgPz8gITFcbiAgICB9KSwgdGhpcy5wcm9wcy5tYXhCbG9ja3MgIT09IHByZXZQcm9wcy5tYXhCbG9ja3MgJiYgdGhpcy5lZGl0b3IuX2ludGVybmFsLmVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgdHlwZTogXCJ1cGRhdGUgbWF4QmxvY2tzXCIsXG4gICAgICBtYXhCbG9ja3M6IHRoaXMucHJvcHMubWF4QmxvY2tzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBOdW1iZXIucGFyc2VJbnQodGhpcy5wcm9wcy5tYXhCbG9ja3MudG9TdHJpbmcoKSwgMTApXG4gICAgfSksIHRoaXMucHJvcHMudmFsdWUgIT09IHByZXZQcm9wcy52YWx1ZSAmJiB0aGlzLmVkaXRvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwidXBkYXRlIHZhbHVlXCIsXG4gICAgICB2YWx1ZTogdGhpcy5wcm9wcy52YWx1ZVxuICAgIH0pLCB0aGlzLnByb3BzLmVkaXRvclJlZiAhPT0gcHJldlByb3BzLmVkaXRvclJlZiAmJiB0aGlzLnByb3BzLmVkaXRvclJlZiAmJiAodGhpcy5wcm9wcy5lZGl0b3JSZWYuY3VycmVudCA9IHRoaXMpKTtcbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBmb3IgKGNvbnN0IHVuc3Vic2NyaWJlIG9mIHRoaXMudW5zdWJzY3JpYmVycylcbiAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgdGhpcy5hY3RvcnMgJiYgKHN0b3BBY3Rvcih0aGlzLmFjdG9ycy5lZGl0b3JBY3RvciksIHN0b3BBY3Rvcih0aGlzLmFjdG9ycy5tdXRhdGlvbkFjdG9yKSwgc3RvcEFjdG9yKHRoaXMuYWN0b3JzLnJlbGF5QWN0b3IpLCBzdG9wQWN0b3IodGhpcy5hY3RvcnMuc3luY0FjdG9yKSk7XG4gIH1cbiAgc2V0RWRpdGFibGUgPSAoZWRpdGFibGUpID0+IHtcbiAgICB0aGlzLmVkaXRvci5faW50ZXJuYWwuZWRpdGFibGUgPSB7XG4gICAgICAuLi50aGlzLmVkaXRvci5faW50ZXJuYWwuZWRpdGFibGUsXG4gICAgICAuLi5lZGl0YWJsZVxuICAgIH07XG4gIH07XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBsZWdhY3lQYXRjaGVzID0gdGhpcy5wcm9wcy5lZGl0b3IgPyB2b2lkIDAgOiB0aGlzLnByb3BzLmluY29taW5nUGF0Y2hlcyQgPz8gdGhpcy5wcm9wcy5wYXRjaGVzJDtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtcbiAgICAgIGxlZ2FjeVBhdGNoZXMgPyAvKiBAX19QVVJFX18gKi8ganN4KFJvdXRlUGF0Y2hlc09ic2VydmFibGVUb0VkaXRvckFjdG9yLCB7IGVkaXRvckFjdG9yOiB0aGlzLmVkaXRvci5faW50ZXJuYWwuZWRpdG9yQWN0b3IsIHBhdGNoZXMkOiBsZWdhY3lQYXRjaGVzIH0pIDogbnVsbCxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goRWRpdG9yQWN0b3JDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB0aGlzLmVkaXRvci5faW50ZXJuYWwuZWRpdG9yQWN0b3IsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFJlbGF5QWN0b3JDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB0aGlzLmFjdG9ycy5yZWxheUFjdG9yLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChTbGF0ZSwgeyBlZGl0b3I6IHRoaXMuZWRpdG9yLl9pbnRlcm5hbC5zbGF0ZUVkaXRvci5pbnN0YW5jZSwgaW5pdGlhbFZhbHVlOiB0aGlzLmVkaXRvci5faW50ZXJuYWwuc2xhdGVFZGl0b3IuaW5pdGlhbFZhbHVlLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChQb3J0YWJsZVRleHRFZGl0b3JDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB0aGlzLCBjaGlsZHJlbjogdGhpcy5wcm9wcy5jaGlsZHJlbiB9KSB9KSB9KSB9KVxuICAgIF0gfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIFVzZSBidWlsdC1pbiBzZWxlY3RvcnMgb3Igd3JpdGUgeW91ciBvd246IGh0dHBzOi8vd3d3LnBvcnRhYmxldGV4dC5vcmcvcmVmZXJlbmNlL3NlbGVjdG9ycy9cbiAgICpcbiAgICogYGBgXG4gICAqIGltcG9ydCAqIGFzIHNlbGVjdG9ycyBmcm9tICdAcG9ydGFibGV0ZXh0L2VkaXRvci9zZWxlY3RvcnMnXG4gICAqIGNvbnN0IGVkaXRvciA9IHVzZUVkaXRvcigpXG4gICAqIGNvbnN0IGlzQWN0aXZlID0gdXNlRWRpdG9yU2VsZWN0b3IoZWRpdG9yLCBzZWxlY3RvcnMuZ2V0QWN0aXZlQW5ub3RhdGlvbnMpXG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIGFjdGl2ZUFubm90YXRpb25zID0gKGVkaXRvcikgPT4gZWRpdG9yICYmIGVkaXRvci5lZGl0YWJsZSA/IGVkaXRvci5lZGl0YWJsZS5hY3RpdmVBbm5vdGF0aW9ucygpIDogW107XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBVc2UgYnVpbHQtaW4gc2VsZWN0b3JzIG9yIHdyaXRlIHlvdXIgb3duOiBodHRwczovL3d3dy5wb3J0YWJsZXRleHQub3JnL3JlZmVyZW5jZS9zZWxlY3RvcnMvXG4gICAqXG4gICAqIGBgYFxuICAgKiBpbXBvcnQgKiBhcyBzZWxlY3RvcnMgZnJvbSAnQHBvcnRhYmxldGV4dC9lZGl0b3Ivc2VsZWN0b3JzJ1xuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBjb25zdCBpc0FjdGl2ZSA9IHVzZUVkaXRvclNlbGVjdG9yKGVkaXRvciwgc2VsZWN0b3JzLmlzQWN0aXZlQW5ub3RhdGlvbiguLi4pKVxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBpc0Fubm90YXRpb25BY3RpdmUgPSAoZWRpdG9yLCBhbm5vdGF0aW9uVHlwZSkgPT4gZWRpdG9yICYmIGVkaXRvci5lZGl0YWJsZSA/IGVkaXRvci5lZGl0YWJsZS5pc0Fubm90YXRpb25BY3RpdmUoYW5ub3RhdGlvblR5cGUpIDogITE7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBVc2UgYGVkaXRvci5zZW5kKC4uLilgIGluc3RlYWRcbiAgICpcbiAgICogYGBgXG4gICAqIGNvbnN0IGVkaXRvciA9IHVzZUVkaXRvcigpXG4gICAqIGVkaXRvci5zZW5kKHtcbiAgICogIHR5cGU6ICdhbm5vdGF0aW9uLmFkZCcsXG4gICAqICBhbm5vdGF0aW9uOiB7XG4gICAqICAgIG5hbWU6ICcuLi4nLFxuICAgKiAgICB2YWx1ZTogey4uLn0sXG4gICAqICB9XG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIGFkZEFubm90YXRpb24gPSAoZWRpdG9yLCB0eXBlLCB2YWx1ZSkgPT4gZWRpdG9yLmVkaXRhYmxlPy5hZGRBbm5vdGF0aW9uKHR5cGUsIHZhbHVlKTtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIFVzZSBgZWRpdG9yLnNlbmQoLi4uKWAgaW5zdGVhZFxuICAgKlxuICAgKiBgYGBcbiAgICogY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKClcbiAgICogZWRpdG9yLnNlbmQoe1xuICAgKiAgdHlwZTogJ2JsdXInLFxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBibHVyID0gKGVkaXRvcikgPT4ge1xuICAgIGRlYnVnKFwiSG9zdCBibHVycmVkXCIpLCBlZGl0b3IuZWRpdGFibGU/LmJsdXIoKTtcbiAgfTtcbiAgc3RhdGljIGRlbGV0ZSA9IChlZGl0b3IsIHNlbGVjdGlvbiwgb3B0aW9ucykgPT4gZWRpdG9yLmVkaXRhYmxlPy5kZWxldGUoc2VsZWN0aW9uLCBvcHRpb25zKTtcbiAgc3RhdGljIGZpbmRET01Ob2RlID0gKGVkaXRvciwgZWxlbWVudCkgPT4gZWRpdG9yLmVkaXRhYmxlPy5maW5kRE9NTm9kZShlbGVtZW50KTtcbiAgc3RhdGljIGZpbmRCeVBhdGggPSAoZWRpdG9yLCBwYXRoKSA9PiBlZGl0b3IuZWRpdGFibGU/LmZpbmRCeVBhdGgocGF0aCkgfHwgW107XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBVc2UgYGVkaXRvci5zZW5kKC4uLilgIGluc3RlYWRcbiAgICpcbiAgICogYGBgXG4gICAqIGNvbnN0IGVkaXRvciA9IHVzZUVkaXRvcigpXG4gICAqIGVkaXRvci5zZW5kKHtcbiAgICogIHR5cGU6ICdmb2N1cycsXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIGZvY3VzID0gKGVkaXRvcikgPT4ge1xuICAgIGRlYnVnKFwiSG9zdCByZXF1ZXN0aW5nIGZvY3VzXCIpLCBlZGl0b3IuZWRpdGFibGU/LmZvY3VzKCk7XG4gIH07XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBVc2UgYnVpbHQtaW4gc2VsZWN0b3JzIG9yIHdyaXRlIHlvdXIgb3duOiBodHRwczovL3d3dy5wb3J0YWJsZXRleHQub3JnL3JlZmVyZW5jZS9zZWxlY3RvcnMvXG4gICAqXG4gICAqIGBgYFxuICAgKiBpbXBvcnQgKiBhcyBzZWxlY3RvcnMgZnJvbSAnQHBvcnRhYmxldGV4dC9lZGl0b3Ivc2VsZWN0b3JzJ1xuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBjb25zdCBmb2N1c0Jsb2NrID0gdXNlRWRpdG9yU2VsZWN0b3IoZWRpdG9yLCBzZWxlY3RvcnMuZ2V0Rm9jdXNCbG9jaylcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgZm9jdXNCbG9jayA9IChlZGl0b3IpID0+IGVkaXRvci5lZGl0YWJsZT8uZm9jdXNCbG9jaygpO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVXNlIGJ1aWx0LWluIHNlbGVjdG9ycyBvciB3cml0ZSB5b3VyIG93bjogaHR0cHM6Ly93d3cucG9ydGFibGV0ZXh0Lm9yZy9yZWZlcmVuY2Uvc2VsZWN0b3JzL1xuICAgKlxuICAgKiBgYGBcbiAgICogaW1wb3J0ICogYXMgc2VsZWN0b3JzIGZyb20gJ0Bwb3J0YWJsZXRleHQvZWRpdG9yL3NlbGVjdG9ycydcbiAgICogY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKClcbiAgICogY29uc3QgZm9jdXNDaGlsZCA9IHVzZUVkaXRvclNlbGVjdG9yKGVkaXRvciwgc2VsZWN0b3JzLmdldEZvY3VzQ2hpbGQpXG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIGZvY3VzQ2hpbGQgPSAoZWRpdG9yKSA9PiBlZGl0b3IuZWRpdGFibGU/LmZvY3VzQ2hpbGQoKTtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIFVzZSBidWlsdC1pbiBzZWxlY3RvcnMgb3Igd3JpdGUgeW91ciBvd246IGh0dHBzOi8vd3d3LnBvcnRhYmxldGV4dC5vcmcvcmVmZXJlbmNlL3NlbGVjdG9ycy9cbiAgICpcbiAgICogYGBgXG4gICAqIGltcG9ydCAqIGFzIHNlbGVjdG9ycyBmcm9tICdAcG9ydGFibGV0ZXh0L2VkaXRvci9zZWxlY3RvcnMnXG4gICAqIGNvbnN0IGVkaXRvciA9IHVzZUVkaXRvcigpXG4gICAqIGNvbnN0IHNlbGVjdGlvbiA9IHVzZUVkaXRvclNlbGVjdG9yKGVkaXRvciwgc2VsZWN0b3JzLmdldFNlbGVjdGlvbilcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgZ2V0U2VsZWN0aW9uID0gKGVkaXRvcikgPT4gZWRpdG9yLmVkaXRhYmxlID8gZWRpdG9yLmVkaXRhYmxlLmdldFNlbGVjdGlvbigpIDogbnVsbDtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIFVzZSBidWlsdC1pbiBzZWxlY3RvcnMgb3Igd3JpdGUgeW91ciBvd246IGh0dHBzOi8vd3d3LnBvcnRhYmxldGV4dC5vcmcvcmVmZXJlbmNlL3NlbGVjdG9ycy9cbiAgICpcbiAgICogYGBgXG4gICAqIGltcG9ydCAqIGFzIHNlbGVjdG9ycyBmcm9tICdAcG9ydGFibGV0ZXh0L2VkaXRvci9zZWxlY3RvcnMnXG4gICAqIGNvbnN0IGVkaXRvciA9IHVzZUVkaXRvcigpXG4gICAqIGNvbnN0IHZhbHVlID0gdXNlRWRpdG9yU2VsZWN0b3IoZWRpdG9yLCBzZWxlY3RvcnMuZ2V0VmFsdWUpXG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIGdldFZhbHVlID0gKGVkaXRvcikgPT4gZWRpdG9yLmVkaXRhYmxlPy5nZXRWYWx1ZSgpO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVXNlIGJ1aWx0LWluIHNlbGVjdG9ycyBvciB3cml0ZSB5b3VyIG93bjogaHR0cHM6Ly93d3cucG9ydGFibGV0ZXh0Lm9yZy9yZWZlcmVuY2Uvc2VsZWN0b3JzL1xuICAgKlxuICAgKiBgYGBcbiAgICogaW1wb3J0ICogYXMgc2VsZWN0b3JzIGZyb20gJ0Bwb3J0YWJsZXRleHQvZWRpdG9yL3NlbGVjdG9ycydcbiAgICogY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKClcbiAgICogY29uc3QgaXNBY3RpdmUgPSB1c2VFZGl0b3JTZWxlY3RvcihlZGl0b3IsIHNlbGVjdG9ycy5pc0FjdGl2ZVN0eWxlKC4uLikpXG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIGhhc0Jsb2NrU3R5bGUgPSAoZWRpdG9yLCBibG9ja1N0eWxlKSA9PiBlZGl0b3IuZWRpdGFibGU/Lmhhc0Jsb2NrU3R5bGUoYmxvY2tTdHlsZSk7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBVc2UgYnVpbHQtaW4gc2VsZWN0b3JzIG9yIHdyaXRlIHlvdXIgb3duOiBodHRwczovL3d3dy5wb3J0YWJsZXRleHQub3JnL3JlZmVyZW5jZS9zZWxlY3RvcnMvXG4gICAqXG4gICAqIGBgYFxuICAgKiBpbXBvcnQgKiBhcyBzZWxlY3RvcnMgZnJvbSAnQHBvcnRhYmxldGV4dC9lZGl0b3Ivc2VsZWN0b3JzJ1xuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBjb25zdCBpc0FjdGl2ZSA9IHVzZUVkaXRvclNlbGVjdG9yKGVkaXRvciwgc2VsZWN0b3JzLmlzQWN0aXZlTGlzdEl0ZW0oLi4uKSlcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgaGFzTGlzdFN0eWxlID0gKGVkaXRvciwgbGlzdFN0eWxlKSA9PiBlZGl0b3IuZWRpdGFibGU/Lmhhc0xpc3RTdHlsZShsaXN0U3R5bGUpO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVXNlIGJ1aWx0LWluIHNlbGVjdG9ycyBvciB3cml0ZSB5b3VyIG93bjogaHR0cHM6Ly93d3cucG9ydGFibGV0ZXh0Lm9yZy9yZWZlcmVuY2Uvc2VsZWN0b3JzL1xuICAgKlxuICAgKiBgYGBcbiAgICogaW1wb3J0ICogYXMgc2VsZWN0b3JzIGZyb20gJ0Bwb3J0YWJsZXRleHQvZWRpdG9yL3NlbGVjdG9ycydcbiAgICogY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKClcbiAgICogY29uc3QgaXNTZWxlY3Rpb25Db2xsYXBzZWQgPSB1c2VFZGl0b3JTZWxlY3RvcihlZGl0b3IsIHNlbGVjdG9ycy5pc1NlbGVjdGlvbkNvbGxhcHNlZClcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgaXNDb2xsYXBzZWRTZWxlY3Rpb24gPSAoZWRpdG9yKSA9PiBlZGl0b3IuZWRpdGFibGU/LmlzQ29sbGFwc2VkU2VsZWN0aW9uKCk7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBVc2UgYnVpbHQtaW4gc2VsZWN0b3JzIG9yIHdyaXRlIHlvdXIgb3duOiBodHRwczovL3d3dy5wb3J0YWJsZXRleHQub3JnL3JlZmVyZW5jZS9zZWxlY3RvcnMvXG4gICAqXG4gICAqIGBgYFxuICAgKiBpbXBvcnQgKiBhcyBzZWxlY3RvcnMgZnJvbSAnQHBvcnRhYmxldGV4dC9lZGl0b3Ivc2VsZWN0b3JzJ1xuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBjb25zdCBpc1NlbGVjdGlvbkV4cGFuZGVkID0gdXNlRWRpdG9yU2VsZWN0b3IoZWRpdG9yLCBzZWxlY3RvcnMuaXNTZWxlY3Rpb25FeHBhbmRlZClcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgaXNFeHBhbmRlZFNlbGVjdGlvbiA9IChlZGl0b3IpID0+IGVkaXRvci5lZGl0YWJsZT8uaXNFeHBhbmRlZFNlbGVjdGlvbigpO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVXNlIGJ1aWx0LWluIHNlbGVjdG9ycyBvciB3cml0ZSB5b3VyIG93bjogaHR0cHM6Ly93d3cucG9ydGFibGV0ZXh0Lm9yZy9yZWZlcmVuY2Uvc2VsZWN0b3JzL1xuICAgKlxuICAgKiBgYGBcbiAgICogaW1wb3J0ICogYXMgc2VsZWN0b3JzIGZyb20gJ0Bwb3J0YWJsZXRleHQvZWRpdG9yL3NlbGVjdG9ycydcbiAgICogY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKClcbiAgICogY29uc3QgaXNBY3RpdmUgPSB1c2VFZGl0b3JTZWxlY3RvcihlZGl0b3IsIHNlbGVjdG9ycy5pc0FjdGl2ZURlY29yYXRvciguLi4pKVxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBpc01hcmtBY3RpdmUgPSAoZWRpdG9yLCBtYXJrKSA9PiBlZGl0b3IuZWRpdGFibGU/LmlzTWFya0FjdGl2ZShtYXJrKTtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIFVzZSBgZWRpdG9yLnNlbmQoLi4uKWAgaW5zdGVhZFxuICAgKlxuICAgKiBgYGBcbiAgICogY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKClcbiAgICogZWRpdG9yLnNlbmQoe1xuICAgKiAgdHlwZTogJ2luc2VydC5zcGFuJyxcbiAgICogIHRleHQ6ICcuLi4nLFxuICAgKiAgYW5ub3RhdGlvbnM6IFt7bmFtZTogJy4uLicsIHZhbHVlOiB7Li4ufX1dLFxuICAgKiAgZGVjb3JhdG9yczogWycuLi4nXSxcbiAgICogfSlcbiAgICogZWRpdG9yLnNlbmQoe1xuICAgKiAgdHlwZTogJ2luc2VydC5pbmxpbmUgb2JqZWN0JyxcbiAgICogIGlubGluZU9iamVjdDoge1xuICAgKiAgICBuYW1lOiAnLi4uJyxcbiAgICogICAgdmFsdWU6IHsuLi59LFxuICAgKiAgfSxcbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgaW5zZXJ0Q2hpbGQgPSAoZWRpdG9yLCB0eXBlLCB2YWx1ZSkgPT4gKGRlYnVnKFwiSG9zdCBpbnNlcnRpbmcgY2hpbGRcIiksIGVkaXRvci5lZGl0YWJsZT8uaW5zZXJ0Q2hpbGQodHlwZSwgdmFsdWUpKTtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIFVzZSBgZWRpdG9yLnNlbmQoLi4uKWAgaW5zdGVhZFxuICAgKlxuICAgKiBgYGBcbiAgICogY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKClcbiAgICogZWRpdG9yLnNlbmQoe1xuICAgKiAgdHlwZTogJ2luc2VydC5ibG9jayBvYmplY3QnLFxuICAgKiAgYmxvY2tPYmplY3Q6IHtcbiAgICogICAgbmFtZTogJy4uLicsXG4gICAqICAgIHZhbHVlOiB7Li4ufSxcbiAgICogIH0sXG4gICAqICBwbGFjZW1lbnQ6ICdhdXRvJyB8ICdhZnRlcicgfCAnYmVmb3JlJyxcbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgaW5zZXJ0QmxvY2sgPSAoZWRpdG9yLCB0eXBlLCB2YWx1ZSkgPT4gZWRpdG9yLmVkaXRhYmxlPy5pbnNlcnRCbG9jayh0eXBlLCB2YWx1ZSk7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBVc2UgYGVkaXRvci5zZW5kKC4uLilgIGluc3RlYWRcbiAgICpcbiAgICogYGBgXG4gICAqIGNvbnN0IGVkaXRvciA9IHVzZUVkaXRvcigpXG4gICAqIGVkaXRvci5zZW5kKHtcbiAgICogIHR5cGU6ICdpbnNlcnQuYnJlYWsnLFxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBpbnNlcnRCcmVhayA9IChlZGl0b3IpID0+IGVkaXRvci5lZGl0YWJsZT8uaW5zZXJ0QnJlYWsoKTtcbiAgc3RhdGljIGlzVm9pZCA9IChlZGl0b3IsIGVsZW1lbnQpID0+IGVkaXRvci5lZGl0YWJsZT8uaXNWb2lkKGVsZW1lbnQpO1xuICBzdGF0aWMgaXNPYmplY3RQYXRoID0gKF9lZGl0b3IsIHBhdGgpID0+IHtcbiAgICBpZiAoIXBhdGggfHwgIUFycmF5LmlzQXJyYXkocGF0aCkpIHJldHVybiAhMTtcbiAgICBjb25zdCBpc0NoaWxkT2JqZWN0RWRpdFBhdGggPSBwYXRoLmxlbmd0aCA+IDMgJiYgcGF0aFsxXSA9PT0gXCJjaGlsZHJlblwiO1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA+IDEgJiYgcGF0aFsxXSAhPT0gXCJjaGlsZHJlblwiIHx8IGlzQ2hpbGRPYmplY3RFZGl0UGF0aDtcbiAgfTtcbiAgc3RhdGljIG1hcmtzID0gKGVkaXRvcikgPT4gZWRpdG9yLmVkaXRhYmxlPy5tYXJrcygpO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVXNlIGBlZGl0b3Iuc2VuZCguLi4pYCBpbnN0ZWFkXG4gICAqXG4gICAqIGBgYFxuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBlZGl0b3Iuc2VuZCh7XG4gICAqICB0eXBlOiAnc2VsZWN0JyxcbiAgICogIHNlbGVjdGlvbjogey4uLn0sXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIHNlbGVjdCA9IChlZGl0b3IsIHNlbGVjdGlvbikgPT4ge1xuICAgIGRlYnVnKFwiSG9zdCBzZXR0aW5nIHNlbGVjdGlvblwiLCBzZWxlY3Rpb24pLCBlZGl0b3IuZWRpdGFibGU/LnNlbGVjdChzZWxlY3Rpb24pO1xuICB9O1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVXNlIGBlZGl0b3Iuc2VuZCguLi4pYCBpbnN0ZWFkXG4gICAqXG4gICAqIGBgYFxuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBlZGl0b3Iuc2VuZCh7XG4gICAqICB0eXBlOiAnYW5ub3RhdGlvbi5yZW1vdmUnLFxuICAgKiAgYW5ub3RhdGlvbjoge1xuICAgKiAgICBuYW1lOiAnLi4uJyxcbiAgICogIH0sXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIHJlbW92ZUFubm90YXRpb24gPSAoZWRpdG9yLCB0eXBlKSA9PiBlZGl0b3IuZWRpdGFibGU/LnJlbW92ZUFubm90YXRpb24odHlwZSk7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBVc2UgYGVkaXRvci5zZW5kKC4uLilgIGluc3RlYWRcbiAgICpcbiAgICogYGBgXG4gICAqIGNvbnN0IGVkaXRvciA9IHVzZUVkaXRvcigpXG4gICAqIGVkaXRvci5zZW5kKHtcbiAgICogIHR5cGU6ICdzdHlsZS50b2dnbGUnLFxuICAgKiAgc3R5bGU6ICcuLi4nLFxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyB0b2dnbGVCbG9ja1N0eWxlID0gKGVkaXRvciwgYmxvY2tTdHlsZSkgPT4gKGRlYnVnKFwiSG9zdCBpcyB0b2dnbGluZyBibG9jayBzdHlsZVwiKSwgZWRpdG9yLmVkaXRhYmxlPy50b2dnbGVCbG9ja1N0eWxlKGJsb2NrU3R5bGUpKTtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIFVzZSBgZWRpdG9yLnNlbmQoLi4uKWAgaW5zdGVhZFxuICAgKlxuICAgKiBgYGBcbiAgICogY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKClcbiAgICogZWRpdG9yLnNlbmQoe1xuICAgKiAgdHlwZTogJ2xpc3QgaXRlbS50b2dnbGUnLFxuICAgKiAgbGlzdEl0ZW06ICcuLi4nLFxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyB0b2dnbGVMaXN0ID0gKGVkaXRvciwgbGlzdFN0eWxlKSA9PiBlZGl0b3IuZWRpdGFibGU/LnRvZ2dsZUxpc3QobGlzdFN0eWxlKTtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIFVzZSBgZWRpdG9yLnNlbmQoLi4uKWAgaW5zdGVhZFxuICAgKlxuICAgKiBgYGBcbiAgICogY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKClcbiAgICogZWRpdG9yLnNlbmQoe1xuICAgKiAgdHlwZTogJ2RlY29yYXRvci50b2dnbGUnLFxuICAgKiAgZGVjb3JhdG9yOiAnLi4uJyxcbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgdG9nZ2xlTWFyayA9IChlZGl0b3IsIG1hcmspID0+IHtcbiAgICBkZWJ1ZyhcIkhvc3QgdG9nZ2xpbmcgbWFya1wiLCBtYXJrKSwgZWRpdG9yLmVkaXRhYmxlPy50b2dnbGVNYXJrKG1hcmspO1xuICB9O1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVXNlIGJ1aWx0LWluIHNlbGVjdG9ycyBvciB3cml0ZSB5b3VyIG93bjogaHR0cHM6Ly93d3cucG9ydGFibGV0ZXh0Lm9yZy9yZWZlcmVuY2Uvc2VsZWN0b3JzL1xuICAgKlxuICAgKiBgYGBcbiAgICogaW1wb3J0ICogYXMgc2VsZWN0b3JzIGZyb20gJ0Bwb3J0YWJsZXRleHQvZWRpdG9yL3NlbGVjdG9ycydcbiAgICogY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKClcbiAgICogY29uc3Qgc2VsZWN0ZWRTbGljZSA9IHVzZUVkaXRvclNlbGVjdG9yKGVkaXRvciwgc2VsZWN0b3JzLmdldFNlbGVjdGVkU2xpY2UpXG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIGdldEZyYWdtZW50ID0gKGVkaXRvcikgPT4gZWRpdG9yLmVkaXRhYmxlPy5nZXRGcmFnbWVudCgpO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVXNlIGBlZGl0b3Iuc2VuZCguLi4pYCBpbnN0ZWFkXG4gICAqXG4gICAqIGBgYFxuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBlZGl0b3Iuc2VuZCh7XG4gICAqICAgdHlwZTogJ2hpc3RvcnkudW5kbycsXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIHVuZG8gPSAoZWRpdG9yKSA9PiB7XG4gICAgZGVidWcoXCJIb3N0IHVuZG9pbmdcIiksIGVkaXRvci5lZGl0YWJsZT8udW5kbygpO1xuICB9O1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVXNlIGBlZGl0b3Iuc2VuZCguLi4pYCBpbnN0ZWFkXG4gICAqXG4gICAqIGBgYFxuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBlZGl0b3Iuc2VuZCh7XG4gICAqICAgdHlwZTogJ2hpc3RvcnkucmVkbycsXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIHJlZG8gPSAoZWRpdG9yKSA9PiB7XG4gICAgZGVidWcoXCJIb3N0IHJlZG9pbmdcIiksIGVkaXRvci5lZGl0YWJsZT8ucmVkbygpO1xuICB9O1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVXNlIGJ1aWx0LWluIHNlbGVjdG9ycyBvciB3cml0ZSB5b3VyIG93bjogaHR0cHM6Ly93d3cucG9ydGFibGV0ZXh0Lm9yZy9yZWZlcmVuY2Uvc2VsZWN0b3JzL1xuICAgKlxuICAgKiBgYGBcbiAgICogaW1wb3J0ICogYXMgc2VsZWN0b3JzIGZyb20gJ0Bwb3J0YWJsZXRleHQvZWRpdG9yL3NlbGVjdG9ycydcbiAgICogY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKClcbiAgICogY29uc3QgaXNPdmVybGFwcGluZyA9IHVzZUVkaXRvclNlbGVjdG9yKGVkaXRvciwgc2VsZWN0b3JzLmlzT3ZlcmxhcHBpbmdTZWxlY3Rpb24oc2VsZWN0aW9uQikpXG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIGlzU2VsZWN0aW9uc092ZXJsYXBwaW5nID0gKGVkaXRvciwgc2VsZWN0aW9uQSwgc2VsZWN0aW9uQikgPT4gZWRpdG9yLmVkaXRhYmxlPy5pc1NlbGVjdGlvbnNPdmVybGFwcGluZyhzZWxlY3Rpb25BLCBzZWxlY3Rpb25CKTtcbn1cbmZ1bmN0aW9uIFJvdXRlUGF0Y2hlc09ic2VydmFibGVUb0VkaXRvckFjdG9yKHByb3BzKSB7XG4gIGNvbnN0ICQgPSBjKDQpO1xuICBsZXQgdDAsIHQxO1xuICByZXR1cm4gJFswXSAhPT0gcHJvcHMuZWRpdG9yQWN0b3IgfHwgJFsxXSAhPT0gcHJvcHMucGF0Y2hlcyQgPyAodDAgPSAoKSA9PiB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gcHJvcHMucGF0Y2hlcyQuc3Vic2NyaWJlKChwYXlsb2FkKSA9PiB7XG4gICAgICBwcm9wcy5lZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJwYXRjaGVzXCIsXG4gICAgICAgIC4uLnBheWxvYWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCB0MSA9IFtwcm9wcy5lZGl0b3JBY3RvciwgcHJvcHMucGF0Y2hlcyRdLCAkWzBdID0gcHJvcHMuZWRpdG9yQWN0b3IsICRbMV0gPSBwcm9wcy5wYXRjaGVzJCwgJFsyXSA9IHQwLCAkWzNdID0gdDEpIDogKHQwID0gJFsyXSwgdDEgPSAkWzNdKSwgdXNlRWZmZWN0KHQwLCB0MSksIG51bGw7XG59XG5mdW5jdGlvbiBFZGl0b3JQcm92aWRlcihwcm9wcykge1xuICBjb25zdCAkID0gYygyOCk7XG4gIGxldCB0MDtcbiAgJFswXSAhPT0gcHJvcHMuaW5pdGlhbENvbmZpZyA/ICh0MCA9ICgpID0+IHtcbiAgICBjb25zdCBpbnRlcm5hbEVkaXRvciA9IGNyZWF0ZUludGVybmFsRWRpdG9yKHByb3BzLmluaXRpYWxDb25maWcpLCBwb3J0YWJsZVRleHRFZGl0b3IgPSBuZXcgUG9ydGFibGVUZXh0RWRpdG9yKHtcbiAgICAgIGVkaXRvcjogaW50ZXJuYWxFZGl0b3IuZWRpdG9yXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGludGVybmFsRWRpdG9yLFxuICAgICAgcG9ydGFibGVUZXh0RWRpdG9yXG4gICAgfTtcbiAgfSwgJFswXSA9IHByb3BzLmluaXRpYWxDb25maWcsICRbMV0gPSB0MCkgOiB0MCA9ICRbMV07XG4gIGNvbnN0IFt0MV0gPSB1c2VTdGF0ZSh0MCksIHtcbiAgICBpbnRlcm5hbEVkaXRvcjogaW50ZXJuYWxFZGl0b3JfMCxcbiAgICBwb3J0YWJsZVRleHRFZGl0b3I6IHBvcnRhYmxlVGV4dEVkaXRvcl8wXG4gIH0gPSB0MTtcbiAgbGV0IHQyO1xuICAkWzJdICE9PSBpbnRlcm5hbEVkaXRvcl8wLmFjdG9ycy5lZGl0b3JBY3RvciB8fCAkWzNdICE9PSBpbnRlcm5hbEVkaXRvcl8wLmFjdG9ycy5tdXRhdGlvbkFjdG9yIHx8ICRbNF0gIT09IGludGVybmFsRWRpdG9yXzAuYWN0b3JzLnJlbGF5QWN0b3IgfHwgJFs1XSAhPT0gaW50ZXJuYWxFZGl0b3JfMC5hY3RvcnMuc3luY0FjdG9yIHx8ICRbNl0gIT09IGludGVybmFsRWRpdG9yXzAuc3Vic2NyaXB0aW9ucyB8fCAkWzddICE9PSBwb3J0YWJsZVRleHRFZGl0b3JfMCA/ICh0MiA9ICgpID0+IHtcbiAgICBjb25zdCB1bnN1YnNjcmliZXJzID0gW107XG4gICAgZm9yIChjb25zdCBzdWJzY3JpcHRpb24gb2YgaW50ZXJuYWxFZGl0b3JfMC5zdWJzY3JpcHRpb25zKVxuICAgICAgdW5zdWJzY3JpYmVycy5wdXNoKHN1YnNjcmlwdGlvbigpKTtcbiAgICBjb25zdCByZWxheUFjdG9yU3Vic2NyaXB0aW9uID0gaW50ZXJuYWxFZGl0b3JfMC5hY3RvcnMucmVsYXlBY3Rvci5vbihcIipcIiwgKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBjaGFuZ2UgPSBldmVudFRvQ2hhbmdlKGV2ZW50KTtcbiAgICAgIGNoYW5nZSAmJiBwb3J0YWJsZVRleHRFZGl0b3JfMC5jaGFuZ2UkLm5leHQoY2hhbmdlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdW5zdWJzY3JpYmVycy5wdXNoKHJlbGF5QWN0b3JTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUpLCBpbnRlcm5hbEVkaXRvcl8wLmFjdG9ycy5lZGl0b3JBY3Rvci5zdGFydCgpLCBpbnRlcm5hbEVkaXRvcl8wLmFjdG9ycy5tdXRhdGlvbkFjdG9yLnN0YXJ0KCksIGludGVybmFsRWRpdG9yXzAuYWN0b3JzLnJlbGF5QWN0b3Iuc3RhcnQoKSwgaW50ZXJuYWxFZGl0b3JfMC5hY3RvcnMuc3luY0FjdG9yLnN0YXJ0KCksICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgdW5zdWJzY3JpYmUgb2YgdW5zdWJzY3JpYmVycylcbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgIHN0b3BBY3RvcihpbnRlcm5hbEVkaXRvcl8wLmFjdG9ycy5lZGl0b3JBY3RvciksIHN0b3BBY3RvcihpbnRlcm5hbEVkaXRvcl8wLmFjdG9ycy5tdXRhdGlvbkFjdG9yKSwgc3RvcEFjdG9yKGludGVybmFsRWRpdG9yXzAuYWN0b3JzLnJlbGF5QWN0b3IpLCBzdG9wQWN0b3IoaW50ZXJuYWxFZGl0b3JfMC5hY3RvcnMuc3luY0FjdG9yKTtcbiAgICB9O1xuICB9LCAkWzJdID0gaW50ZXJuYWxFZGl0b3JfMC5hY3RvcnMuZWRpdG9yQWN0b3IsICRbM10gPSBpbnRlcm5hbEVkaXRvcl8wLmFjdG9ycy5tdXRhdGlvbkFjdG9yLCAkWzRdID0gaW50ZXJuYWxFZGl0b3JfMC5hY3RvcnMucmVsYXlBY3RvciwgJFs1XSA9IGludGVybmFsRWRpdG9yXzAuYWN0b3JzLnN5bmNBY3RvciwgJFs2XSA9IGludGVybmFsRWRpdG9yXzAuc3Vic2NyaXB0aW9ucywgJFs3XSA9IHBvcnRhYmxlVGV4dEVkaXRvcl8wLCAkWzhdID0gdDIpIDogdDIgPSAkWzhdO1xuICBsZXQgdDM7XG4gICRbOV0gIT09IGludGVybmFsRWRpdG9yXzAgfHwgJFsxMF0gIT09IHBvcnRhYmxlVGV4dEVkaXRvcl8wID8gKHQzID0gW2ludGVybmFsRWRpdG9yXzAsIHBvcnRhYmxlVGV4dEVkaXRvcl8wXSwgJFs5XSA9IGludGVybmFsRWRpdG9yXzAsICRbMTBdID0gcG9ydGFibGVUZXh0RWRpdG9yXzAsICRbMTFdID0gdDMpIDogdDMgPSAkWzExXSwgdXNlRWZmZWN0KHQyLCB0Myk7XG4gIGxldCB0NDtcbiAgJFsxMl0gIT09IHBvcnRhYmxlVGV4dEVkaXRvcl8wIHx8ICRbMTNdICE9PSBwcm9wcy5jaGlsZHJlbiA/ICh0NCA9IC8qIEBfX1BVUkVfXyAqLyBqc3goUG9ydGFibGVUZXh0RWRpdG9yQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogcG9ydGFibGVUZXh0RWRpdG9yXzAsIGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbiB9KSwgJFsxMl0gPSBwb3J0YWJsZVRleHRFZGl0b3JfMCwgJFsxM10gPSBwcm9wcy5jaGlsZHJlbiwgJFsxNF0gPSB0NCkgOiB0NCA9ICRbMTRdO1xuICBsZXQgdDU7XG4gICRbMTVdICE9PSBpbnRlcm5hbEVkaXRvcl8wLmVkaXRvci5faW50ZXJuYWwuc2xhdGVFZGl0b3IuaW5pdGlhbFZhbHVlIHx8ICRbMTZdICE9PSBpbnRlcm5hbEVkaXRvcl8wLmVkaXRvci5faW50ZXJuYWwuc2xhdGVFZGl0b3IuaW5zdGFuY2UgfHwgJFsxN10gIT09IHQ0ID8gKHQ1ID0gLyogQF9fUFVSRV9fICovIGpzeChTbGF0ZSwgeyBlZGl0b3I6IGludGVybmFsRWRpdG9yXzAuZWRpdG9yLl9pbnRlcm5hbC5zbGF0ZUVkaXRvci5pbnN0YW5jZSwgaW5pdGlhbFZhbHVlOiBpbnRlcm5hbEVkaXRvcl8wLmVkaXRvci5faW50ZXJuYWwuc2xhdGVFZGl0b3IuaW5pdGlhbFZhbHVlLCBjaGlsZHJlbjogdDQgfSksICRbMTVdID0gaW50ZXJuYWxFZGl0b3JfMC5lZGl0b3IuX2ludGVybmFsLnNsYXRlRWRpdG9yLmluaXRpYWxWYWx1ZSwgJFsxNl0gPSBpbnRlcm5hbEVkaXRvcl8wLmVkaXRvci5faW50ZXJuYWwuc2xhdGVFZGl0b3IuaW5zdGFuY2UsICRbMTddID0gdDQsICRbMThdID0gdDUpIDogdDUgPSAkWzE4XTtcbiAgbGV0IHQ2O1xuICAkWzE5XSAhPT0gaW50ZXJuYWxFZGl0b3JfMC5hY3RvcnMucmVsYXlBY3RvciB8fCAkWzIwXSAhPT0gdDUgPyAodDYgPSAvKiBAX19QVVJFX18gKi8ganN4KFJlbGF5QWN0b3JDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBpbnRlcm5hbEVkaXRvcl8wLmFjdG9ycy5yZWxheUFjdG9yLCBjaGlsZHJlbjogdDUgfSksICRbMTldID0gaW50ZXJuYWxFZGl0b3JfMC5hY3RvcnMucmVsYXlBY3RvciwgJFsyMF0gPSB0NSwgJFsyMV0gPSB0NikgOiB0NiA9ICRbMjFdO1xuICBsZXQgdDc7XG4gICRbMjJdICE9PSBpbnRlcm5hbEVkaXRvcl8wLmFjdG9ycy5lZGl0b3JBY3RvciB8fCAkWzIzXSAhPT0gdDYgPyAodDcgPSAvKiBAX19QVVJFX18gKi8ganN4KEVkaXRvckFjdG9yQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogaW50ZXJuYWxFZGl0b3JfMC5hY3RvcnMuZWRpdG9yQWN0b3IsIGNoaWxkcmVuOiB0NiB9KSwgJFsyMl0gPSBpbnRlcm5hbEVkaXRvcl8wLmFjdG9ycy5lZGl0b3JBY3RvciwgJFsyM10gPSB0NiwgJFsyNF0gPSB0NykgOiB0NyA9ICRbMjRdO1xuICBsZXQgdDg7XG4gIHJldHVybiAkWzI1XSAhPT0gaW50ZXJuYWxFZGl0b3JfMC5lZGl0b3IgfHwgJFsyNl0gIT09IHQ3ID8gKHQ4ID0gLyogQF9fUFVSRV9fICovIGpzeChFZGl0b3JDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBpbnRlcm5hbEVkaXRvcl8wLmVkaXRvciwgY2hpbGRyZW46IHQ3IH0pLCAkWzI1XSA9IGludGVybmFsRWRpdG9yXzAuZWRpdG9yLCAkWzI2XSA9IHQ3LCAkWzI3XSA9IHQ4KSA6IHQ4ID0gJFsyN10sIHQ4O1xufVxuY29uc3QgdXNlUG9ydGFibGVUZXh0RWRpdG9yU2VsZWN0aW9uID0gKCkgPT4ge1xuICBjb25zdCAkID0gYygzKSwgZWRpdG9yQWN0b3IgPSB1c2VDb250ZXh0KEVkaXRvckFjdG9yQ29udGV4dCksIFtzZWxlY3Rpb24sIHNldFNlbGVjdGlvbjJdID0gdXNlU3RhdGUobnVsbCk7XG4gIGxldCB0MCwgdDE7XG4gIHJldHVybiAkWzBdICE9PSBlZGl0b3JBY3RvciA/ICh0MCA9ICgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBlZGl0b3JBY3Rvci5vbihcInNlbGVjdGlvblwiLCAoZXZlbnQpID0+IHtcbiAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgIHNldFNlbGVjdGlvbjIoZXZlbnQuc2VsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCB0MSA9IFtlZGl0b3JBY3Rvcl0sICRbMF0gPSBlZGl0b3JBY3RvciwgJFsxXSA9IHQwLCAkWzJdID0gdDEpIDogKHQwID0gJFsxXSwgdDEgPSAkWzJdKSwgdXNlRWZmZWN0KHQwLCB0MSksIHNlbGVjdGlvbjtcbn07XG5leHBvcnQge1xuICBFZGl0b3JFdmVudExpc3RlbmVyLFxuICBFZGl0b3JQcm92aWRlcixcbiAgUG9ydGFibGVUZXh0RWRpdGFibGUsXG4gIFBvcnRhYmxlVGV4dEVkaXRvcixcbiAgZGVmaW5lU2NoZW1hLFxuICBkZWZhdWx0S2V5R2VuZXJhdG9yIGFzIGtleUdlbmVyYXRvcixcbiAgdXNlRWRpdG9yLFxuICB1c2VFZGl0b3JTZWxlY3RvcixcbiAgdXNlUG9ydGFibGVUZXh0RWRpdG9yLFxuICB1c2VQb3J0YWJsZVRleHRFZGl0b3JTZWxlY3Rpb25cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@portabletext/editor/lib/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@portabletext/editor/lib/plugins/index.js":
/*!*****************************************************************!*\
  !*** ../node_modules/@portabletext/editor/lib/plugins/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BehaviorPlugin: () => (/* binding */ BehaviorPlugin),\n/* harmony export */   DecoratorShortcutPlugin: () => (/* binding */ DecoratorShortcutPlugin),\n/* harmony export */   EditorRefPlugin: () => (/* binding */ EditorRefPlugin),\n/* harmony export */   EventListenerPlugin: () => (/* binding */ EventListenerPlugin),\n/* harmony export */   MarkdownPlugin: () => (/* binding */ MarkdownPlugin),\n/* harmony export */   OneLinePlugin: () => (/* binding */ OneLinePlugin)\n/* harmony export */ });\n/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-compiler-runtime */ \"(ssr)/../node_modules/react-compiler-runtime/dist/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/../node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _chunks_es_use_editor_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../_chunks-es/use-editor.js */ \"(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/use-editor.js\");\n/* harmony import */ var _xstate_react__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @xstate/react */ \"(ssr)/../node_modules/@xstate/react/dist/xstate-react.development.esm.js\");\n/* harmony import */ var lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/isEqual.js */ \"(ssr)/../node_modules/lodash/isEqual.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! xstate */ \"(ssr)/../node_modules/xstate/dist/xstate.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! xstate */ \"(ssr)/../node_modules/xstate/actors/dist/xstate-actors.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! xstate */ \"(ssr)/../node_modules/xstate/dist/assign-fb4707fe.development.esm.js\");\n/* harmony import */ var _chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../_chunks-es/selector.get-selection-text.js */ \"(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/selector.get-selection-text.js\");\n/* harmony import */ var _chunks_es_selector_get_text_before_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../_chunks-es/selector.get-text-before.js */ \"(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/selector.get-text-before.js\");\n/* harmony import */ var _chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../_chunks-es/util.get-text-block-text.js */ \"(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/util.get-text-block-text.js\");\n/* harmony import */ var _chunks_es_util_child_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../_chunks-es/util.child-selection-point-to-block-offset.js */ \"(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/util.child-selection-point-to-block-offset.js\");\n/* harmony import */ var _behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../behaviors/index.js */ \"(ssr)/../node_modules/@portabletext/editor/lib/behaviors/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/../node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _portabletext_schema__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @portabletext/schema */ \"(ssr)/../node_modules/@portabletext/schema/dist/index.js\");\n/* harmony import */ var _chunks_es_util_merge_text_blocks_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../_chunks-es/util.merge-text-blocks.js */ \"(ssr)/../node_modules/@portabletext/editor/lib/_chunks-es/util.merge-text-blocks.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction BehaviorPlugin(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(4), editor = (0,_chunks_es_use_editor_js__WEBPACK_IMPORTED_MODULE_4__.useEditor)();\n  let t0, t1;\n  return $[0] !== editor || $[1] !== props.behaviors ? (t0 = () => {\n    const unregisterBehaviors = props.behaviors.map((behavior) => editor.registerBehavior({\n      behavior\n    }));\n    return () => {\n      unregisterBehaviors.forEach(_temp);\n    };\n  }, t1 = [editor, props.behaviors], $[0] = editor, $[1] = props.behaviors, $[2] = t0, $[3] = t1) : (t0 = $[2], t1 = $[3]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(t0, t1), null;\n}\nfunction _temp(unregister) {\n  unregister();\n}\nfunction createPairRegex(char, amount) {\n  const prePrefix = `(?<!\\\\${char})`, prefix = `\\\\${char}`.repeat(Math.max(amount, 1)), postPrefix = \"(?!\\\\s)\", content = `([^${char}\\\\n]+?)`, preSuffix = \"(?<!\\\\s)\", suffix = `\\\\${char}`.repeat(Math.max(amount, 1)), postSuffix = `(?!\\\\${char})`;\n  return `${prePrefix}${prefix}${postPrefix}${content}${preSuffix}${suffix}${postSuffix}`;\n}\nfunction createDecoratorPairBehavior(config) {\n  config.pair.amount < 1 && console.warn(\"The amount of characters in the pair should be greater than 0\");\n  const pairRegex = createPairRegex(config.pair.char, config.pair.amount), regEx = new RegExp(`(${pairRegex})$`);\n  return (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"insert.text\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      if (config.pair.amount < 1)\n        return !1;\n      const decorator = config.decorator({\n        schema: snapshot.context.schema\n      });\n      if (decorator === void 0)\n        return !1;\n      const focusTextBlock = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_6__.getFocusTextBlock)(snapshot), selectionStartPoint = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_6__.getSelectionStartPoint)(snapshot), selectionStartOffset = selectionStartPoint ? (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_7__.spanSelectionPointToBlockOffset)({\n        context: {\n          schema: snapshot.context.schema,\n          value: snapshot.context.value\n        },\n        selectionPoint: selectionStartPoint\n      }) : void 0;\n      if (!focusTextBlock || !selectionStartOffset)\n        return !1;\n      const newText = `${(0,_chunks_es_selector_get_text_before_js__WEBPACK_IMPORTED_MODULE_8__.getBlockTextBefore)(snapshot)}${event.text}`, textToDecorate = newText.match(regEx)?.at(0);\n      if (textToDecorate === void 0)\n        return !1;\n      const prefixOffsets = {\n        anchor: {\n          path: focusTextBlock.path,\n          // Example: \"foo **bar**\".length - \"**bar**\".length = 4\n          offset: newText.length - textToDecorate.length\n        },\n        focus: {\n          path: focusTextBlock.path,\n          // Example: \"foo **bar**\".length - \"**bar**\".length + \"*\".length * 2 = 6\n          offset: newText.length - textToDecorate.length + config.pair.char.length * config.pair.amount\n        }\n      }, suffixOffsets = {\n        anchor: {\n          path: focusTextBlock.path,\n          // Example: \"foo **bar*|\" (10) + \"*\".length - 2 = 9\n          offset: selectionStartOffset.offset + event.text.length - config.pair.char.length * config.pair.amount\n        },\n        focus: {\n          path: focusTextBlock.path,\n          // Example: \"foo **bar*|\" (10) + \"*\".length = 11\n          offset: selectionStartOffset.offset + event.text.length\n        }\n      };\n      if (prefixOffsets.focus.offset - prefixOffsets.anchor.offset > 1) {\n        const prefixSelection = (0,_chunks_es_util_child_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_9__.blockOffsetsToSelection)({\n          context: snapshot.context,\n          offsets: prefixOffsets\n        }), inlineObjectBeforePrefixFocus = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_6__.getPreviousInlineObject)({\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: prefixSelection ? {\n              anchor: prefixSelection.focus,\n              focus: prefixSelection.focus\n            } : null\n          }\n        }), inlineObjectBeforePrefixFocusOffset = inlineObjectBeforePrefixFocus ? (0,_chunks_es_util_child_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_9__.childSelectionPointToBlockOffset)({\n          context: {\n            schema: snapshot.context.schema,\n            value: snapshot.context.value\n          },\n          selectionPoint: {\n            path: inlineObjectBeforePrefixFocus.path,\n            offset: 0\n          }\n        }) : void 0;\n        if (inlineObjectBeforePrefixFocusOffset && inlineObjectBeforePrefixFocusOffset.offset > prefixOffsets.anchor.offset && inlineObjectBeforePrefixFocusOffset.offset < prefixOffsets.focus.offset)\n          return !1;\n      }\n      if (suffixOffsets.focus.offset - suffixOffsets.anchor.offset > 1) {\n        const previousInlineObject = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_6__.getPreviousInlineObject)(snapshot), previousInlineObjectOffset = previousInlineObject ? (0,_chunks_es_util_child_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_9__.childSelectionPointToBlockOffset)({\n          context: {\n            schema: snapshot.context.schema,\n            value: snapshot.context.value\n          },\n          selectionPoint: {\n            path: previousInlineObject.path,\n            offset: 0\n          }\n        }) : void 0;\n        if (previousInlineObjectOffset && previousInlineObjectOffset.offset > suffixOffsets.anchor.offset && previousInlineObjectOffset.offset < suffixOffsets.focus.offset)\n          return !1;\n      }\n      return {\n        prefixOffsets,\n        suffixOffsets,\n        decorator\n      };\n    },\n    actions: [\n      // Insert the text as usual in its own undo step\n      ({\n        event\n      }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)(event)],\n      (_, {\n        prefixOffsets,\n        suffixOffsets,\n        decorator\n      }) => [\n        // Decorate the text between the prefix and suffix\n        (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n          type: \"decorator.add\",\n          decorator,\n          at: {\n            anchor: prefixOffsets.focus,\n            focus: suffixOffsets.anchor\n          }\n        }),\n        // Delete the suffix\n        (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n          type: \"delete.text\",\n          at: suffixOffsets\n        }),\n        // Delete the prefix\n        (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n          type: \"delete.text\",\n          at: prefixOffsets\n        }),\n        // Toggle the decorator off so the next inserted text isn't emphasized\n        (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n          type: \"decorator.remove\",\n          decorator\n        }),\n        (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.effect)(() => {\n          config.onDecorate({\n            ...suffixOffsets.anchor,\n            offset: suffixOffsets.anchor.offset - (prefixOffsets.focus.offset - prefixOffsets.anchor.offset)\n          });\n        })\n      ]\n    ]\n  });\n}\nfunction DecoratorShortcutPlugin(config) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(4), editor = (0,_chunks_es_use_editor_js__WEBPACK_IMPORTED_MODULE_4__.useEditor)();\n  let t0;\n  return $[0] !== config.decorator || $[1] !== config.pair || $[2] !== editor ? (t0 = {\n    input: {\n      editor,\n      decorator: config.decorator,\n      pair: config.pair\n    }\n  }, $[0] = config.decorator, $[1] = config.pair, $[2] = editor, $[3] = t0) : t0 = $[3], (0,_xstate_react__WEBPACK_IMPORTED_MODULE_10__.useActorRef)(decoratorPairMachine, t0), null;\n}\nconst emphasisListener = ({\n  sendBack,\n  input\n}) => input.editor.registerBehavior({\n  behavior: createDecoratorPairBehavior({\n    decorator: input.decorator,\n    pair: input.pair,\n    onDecorate: (offset) => {\n      sendBack({\n        type: \"emphasis.add\",\n        blockOffset: offset\n      });\n    }\n  })\n}), selectionListenerCallback = ({\n  sendBack,\n  input\n}) => input.editor.registerBehavior({\n  behavior: (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"select\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      if (!event.at)\n        return {\n          blockOffsets: void 0\n        };\n      const anchor = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_7__.spanSelectionPointToBlockOffset)({\n        context: snapshot.context,\n        selectionPoint: event.at.anchor\n      }), focus = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_7__.spanSelectionPointToBlockOffset)({\n        context: snapshot.context,\n        selectionPoint: event.at.focus\n      });\n      return !anchor || !focus ? {\n        blockOffsets: void 0\n      } : {\n        blockOffsets: {\n          anchor,\n          focus\n        }\n      };\n    },\n    actions: [({\n      event\n    }, {\n      blockOffsets\n    }) => [{\n      type: \"effect\",\n      effect: () => {\n        sendBack({\n          type: \"selection\",\n          blockOffsets\n        });\n      }\n    }, (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.forward)(event)]]\n  })\n}), deleteBackwardListenerCallback = ({\n  sendBack,\n  input\n}) => input.editor.registerBehavior({\n  behavior: (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"delete.backward\",\n    actions: [() => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"history.undo\"\n    }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.effect)(() => {\n      sendBack({\n        type: \"delete.backward\"\n      });\n    })]]\n  })\n}), decoratorPairMachine = (0,xstate__WEBPACK_IMPORTED_MODULE_11__.setup)({\n  types: {\n    context: {},\n    input: {},\n    events: {}\n  },\n  actors: {\n    \"emphasis listener\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.fromCallback)(emphasisListener),\n    \"delete.backward listener\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.fromCallback)(deleteBackwardListenerCallback),\n    \"selection listener\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.fromCallback)(selectionListenerCallback)\n  }\n}).createMachine({\n  id: \"decorator pair\",\n  context: ({\n    input\n  }) => ({\n    decorator: input.decorator,\n    editor: input.editor,\n    pair: input.pair\n  }),\n  initial: \"idle\",\n  states: {\n    idle: {\n      invoke: [{\n        src: \"emphasis listener\",\n        input: ({\n          context\n        }) => ({\n          decorator: context.decorator,\n          editor: context.editor,\n          pair: context.pair\n        })\n      }],\n      on: {\n        \"emphasis.add\": {\n          target: \"emphasis added\",\n          actions: (0,xstate__WEBPACK_IMPORTED_MODULE_13__.a)({\n            offsetAfterEmphasis: ({\n              event\n            }) => event.blockOffset\n          })\n        }\n      }\n    },\n    \"emphasis added\": {\n      exit: [(0,xstate__WEBPACK_IMPORTED_MODULE_13__.a)({\n        offsetAfterEmphasis: void 0\n      })],\n      invoke: [{\n        src: \"selection listener\",\n        input: ({\n          context\n        }) => ({\n          editor: context.editor\n        })\n      }, {\n        src: \"delete.backward listener\",\n        input: ({\n          context\n        }) => ({\n          editor: context.editor\n        })\n      }],\n      on: {\n        selection: {\n          target: \"idle\",\n          guard: ({\n            context,\n            event\n          }) => !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__({\n            anchor: context.offsetAfterEmphasis,\n            focus: context.offsetAfterEmphasis\n          }, event.blockOffsets)\n        },\n        \"delete.backward\": {\n          target: \"idle\"\n        }\n      }\n    }\n  }\n}), EditorRefPlugin = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef((_, ref) => {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(2), editor = (0,_chunks_es_use_editor_js__WEBPACK_IMPORTED_MODULE_4__.useEditor)(), portableTextEditorRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(editor);\n  let t0, t1;\n  return $[0] === Symbol.for(\"react.memo_cache_sentinel\") ? (t0 = () => portableTextEditorRef.current, t1 = [], $[0] = t0, $[1] = t1) : (t0 = $[0], t1 = $[1]), react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(ref, t0, t1), null;\n});\nEditorRefPlugin.displayName = \"EditorRefPlugin\";\nfunction EventListenerPlugin(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(4), editor = (0,_chunks_es_use_editor_js__WEBPACK_IMPORTED_MODULE_4__.useEditor)();\n  let t0, t1;\n  return $[0] !== editor || $[1] !== props.on ? (t0 = () => {\n    const subscription = editor.on(\"*\", props.on);\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, t1 = [editor, props.on], $[0] = editor, $[1] = props.on, $[2] = t0, $[3] = t1) : (t0 = $[2], t1 = $[3]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(t0, t1), null;\n}\nfunction createMarkdownBehaviors(config) {\n  const automaticBlockquoteOnSpace = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"insert.text\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      if (event.text !== \" \")\n        return !1;\n      const selectionCollapsed = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_6__.isSelectionCollapsed)(snapshot), focusTextBlock = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_6__.getFocusTextBlock)(snapshot), focusSpan = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_6__.getFocusSpan)(snapshot);\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan)\n        return !1;\n      const previousInlineObject = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_6__.getPreviousInlineObject)(snapshot), blockOffset = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_7__.spanSelectionPointToBlockOffset)({\n        context: snapshot.context,\n        selectionPoint: {\n          path: [{\n            _key: focusTextBlock.node._key\n          }, \"children\", {\n            _key: focusSpan.node._key\n          }],\n          offset: snapshot.context.selection?.focus.offset ?? 0\n        }\n      });\n      if (previousInlineObject || !blockOffset)\n        return !1;\n      const blockText = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_7__.getTextBlockText)(focusTextBlock.node), caretAtTheEndOfQuote = blockOffset.offset === 1, looksLikeMarkdownQuote = /^>/.test(blockText), blockquoteStyle = config.blockquoteStyle?.(snapshot.context);\n      return caretAtTheEndOfQuote && looksLikeMarkdownQuote && blockquoteStyle !== void 0 ? {\n        focusTextBlock,\n        style: blockquoteStyle\n      } : !1;\n    },\n    actions: [() => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"insert.text\",\n      text: \" \"\n    })], (_, {\n      focusTextBlock,\n      style\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"block.unset\",\n      props: [\"listItem\", \"level\"],\n      at: focusTextBlock.path\n    }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"block.set\",\n      props: {\n        style\n      },\n      at: focusTextBlock.path\n    }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"delete.text\",\n      at: {\n        anchor: {\n          path: focusTextBlock.path,\n          offset: 0\n        },\n        focus: {\n          path: focusTextBlock.path,\n          offset: 2\n        }\n      }\n    })]]\n  }), automaticHr = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"insert.text\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      const hrCharacter = event.text === \"-\" ? \"-\" : event.text === \"*\" ? \"*\" : event.text === \"_\" ? \"_\" : void 0;\n      if (hrCharacter === void 0)\n        return !1;\n      const hrObject = config.horizontalRuleObject?.(snapshot.context), focusBlock = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_6__.getFocusTextBlock)(snapshot), selectionCollapsed = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_6__.isSelectionCollapsed)(snapshot);\n      if (!hrObject || !focusBlock || !selectionCollapsed)\n        return !1;\n      const previousInlineObject = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_6__.getPreviousInlineObject)(snapshot), textBefore = (0,_chunks_es_selector_get_text_before_js__WEBPACK_IMPORTED_MODULE_8__.getBlockTextBefore)(snapshot), hrBlockOffsets = {\n        anchor: {\n          path: focusBlock.path,\n          offset: 0\n        },\n        focus: {\n          path: focusBlock.path,\n          offset: 3\n        }\n      };\n      return !previousInlineObject && textBefore === `${hrCharacter}${hrCharacter}` ? {\n        hrObject,\n        focusBlock,\n        hrCharacter,\n        hrBlockOffsets\n      } : !1;\n    },\n    actions: [(_, {\n      hrCharacter\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"insert.text\",\n      text: hrCharacter\n    })], (_, {\n      hrObject,\n      hrBlockOffsets\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"insert.block\",\n      placement: \"before\",\n      block: {\n        _type: hrObject.name,\n        ...hrObject.value ?? {}\n      }\n    }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"delete.text\",\n      at: hrBlockOffsets\n    })]]\n  }), automaticHrOnPaste = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"clipboard.paste\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      const text = event.originEvent.dataTransfer.getData(\"text/plain\"), hrRegExp = /^(---)$|(___)$|(\\*\\*\\*)$/, hrCharacters = text.match(hrRegExp)?.[0], hrObject = config.horizontalRuleObject?.(snapshot.context), focusBlock = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_6__.getFocusBlock)(snapshot);\n      return !hrCharacters || !hrObject || !focusBlock ? !1 : {\n        hrCharacters,\n        hrObject,\n        focusBlock\n      };\n    },\n    actions: [(_, {\n      hrCharacters\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"insert.text\",\n      text: hrCharacters\n    })], ({\n      snapshot\n    }, {\n      hrObject,\n      focusBlock\n    }) => (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_14__.isTextBlock)(snapshot.context, focusBlock.node) ? [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"insert.block\",\n      block: {\n        _type: snapshot.context.schema.block.name,\n        children: focusBlock.node.children\n      },\n      placement: \"after\"\n    }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"insert.block\",\n      block: {\n        _type: hrObject.name,\n        ...hrObject.value ?? {}\n      },\n      placement: \"after\"\n    }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"delete.block\",\n      at: focusBlock.path\n    })] : [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"insert.block\",\n      block: {\n        _type: hrObject.name,\n        ...hrObject.value ?? {}\n      },\n      placement: \"after\"\n    })]]\n  }), automaticHeadingOnSpace = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"insert.text\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      if (event.text !== \" \")\n        return !1;\n      const selectionCollapsed = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_6__.isSelectionCollapsed)(snapshot), focusTextBlock = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_6__.getFocusTextBlock)(snapshot), focusSpan = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_6__.getFocusSpan)(snapshot);\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan)\n        return !1;\n      const blockOffset = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_7__.spanSelectionPointToBlockOffset)({\n        context: snapshot.context,\n        selectionPoint: {\n          path: [{\n            _key: focusTextBlock.node._key\n          }, \"children\", {\n            _key: focusSpan.node._key\n          }],\n          offset: snapshot.context.selection?.focus.offset ?? 0\n        }\n      });\n      if (!blockOffset)\n        return !1;\n      const previousInlineObject = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_6__.getPreviousInlineObject)(snapshot), blockText = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_7__.getTextBlockText)(focusTextBlock.node), markdownHeadingSearch = /^#+/.exec(blockText), level = markdownHeadingSearch ? markdownHeadingSearch[0].length : void 0, caretAtTheEndOfHeading = blockOffset.offset === level;\n      if (previousInlineObject || !caretAtTheEndOfHeading)\n        return !1;\n      const style = level !== void 0 ? config.headingStyle?.({\n        schema: snapshot.context.schema,\n        level\n      }) : void 0;\n      return level !== void 0 && style !== void 0 ? {\n        focusTextBlock,\n        style,\n        level\n      } : !1;\n    },\n    actions: [({\n      event\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)(event)], (_, {\n      focusTextBlock,\n      style,\n      level\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"block.unset\",\n      props: [\"listItem\", \"level\"],\n      at: focusTextBlock.path\n    }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"block.set\",\n      props: {\n        style\n      },\n      at: focusTextBlock.path\n    }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"delete.text\",\n      at: {\n        anchor: {\n          path: focusTextBlock.path,\n          offset: 0\n        },\n        focus: {\n          path: focusTextBlock.path,\n          offset: level + 1\n        }\n      }\n    })]]\n  }), clearStyleOnBackspace = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"delete.backward\",\n    guard: ({\n      snapshot\n    }) => {\n      const selectionCollapsed = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_6__.isSelectionCollapsed)(snapshot), focusTextBlock = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_6__.getFocusTextBlock)(snapshot), focusSpan = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_6__.getFocusSpan)(snapshot);\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan)\n        return !1;\n      const atTheBeginningOfBLock = focusTextBlock.node.children[0]._key === focusSpan.node._key && snapshot.context.selection?.focus.offset === 0, defaultStyle = config.defaultStyle?.(snapshot.context);\n      return atTheBeginningOfBLock && defaultStyle && focusTextBlock.node.style !== defaultStyle ? {\n        defaultStyle,\n        focusTextBlock\n      } : !1;\n    },\n    actions: [(_, {\n      defaultStyle,\n      focusTextBlock\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"block.set\",\n      props: {\n        style: defaultStyle\n      },\n      at: focusTextBlock.path\n    })]]\n  }), automaticListOnSpace = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"insert.text\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      if (event.text !== \" \")\n        return !1;\n      const selectionCollapsed = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_6__.isSelectionCollapsed)(snapshot), focusTextBlock = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_6__.getFocusTextBlock)(snapshot), focusSpan = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_6__.getFocusSpan)(snapshot);\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan)\n        return !1;\n      const previousInlineObject = (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_6__.getPreviousInlineObject)(snapshot), blockOffset = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_7__.spanSelectionPointToBlockOffset)({\n        context: snapshot.context,\n        selectionPoint: {\n          path: [{\n            _key: focusTextBlock.node._key\n          }, \"children\", {\n            _key: focusSpan.node._key\n          }],\n          offset: snapshot.context.selection?.focus.offset ?? 0\n        }\n      });\n      if (previousInlineObject || !blockOffset)\n        return !1;\n      const blockText = (0,_chunks_es_util_get_text_block_text_js__WEBPACK_IMPORTED_MODULE_7__.getTextBlockText)(focusTextBlock.node), defaultStyle = config.defaultStyle?.(snapshot.context), looksLikeUnorderedList = /^(-|\\*)/.test(blockText), unorderedListStyle = config.unorderedListStyle?.(snapshot.context), caretAtTheEndOfUnorderedList = blockOffset.offset === 1;\n      if (defaultStyle && caretAtTheEndOfUnorderedList && looksLikeUnorderedList && unorderedListStyle !== void 0)\n        return {\n          focusTextBlock,\n          listItem: unorderedListStyle,\n          listItemLength: 1,\n          style: defaultStyle\n        };\n      const looksLikeOrderedList = /^1\\./.test(blockText), orderedListStyle = config.orderedListStyle?.(snapshot.context), caretAtTheEndOfOrderedList = blockOffset.offset === 2;\n      return defaultStyle && caretAtTheEndOfOrderedList && looksLikeOrderedList && orderedListStyle !== void 0 ? {\n        focusTextBlock,\n        listItem: orderedListStyle,\n        listItemLength: 2,\n        style: defaultStyle\n      } : !1;\n    },\n    actions: [({\n      event\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)(event)], (_, {\n      focusTextBlock,\n      style,\n      listItem,\n      listItemLength\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"block.set\",\n      props: {\n        listItem,\n        level: 1,\n        style\n      },\n      at: focusTextBlock.path\n    }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"delete.text\",\n      at: {\n        anchor: {\n          path: focusTextBlock.path,\n          offset: 0\n        },\n        focus: {\n          path: focusTextBlock.path,\n          offset: listItemLength + 1\n        }\n      }\n    })]]\n  });\n  return [automaticBlockquoteOnSpace, automaticHeadingOnSpace, automaticHr, automaticHrOnPaste, clearStyleOnBackspace, automaticListOnSpace];\n}\nfunction MarkdownPlugin(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(17), editor = (0,_chunks_es_use_editor_js__WEBPACK_IMPORTED_MODULE_4__.useEditor)();\n  let t0, t1;\n  $[0] !== editor || $[1] !== props.config ? (t0 = () => {\n    const unregisterBehaviors = createMarkdownBehaviors(props.config).map((behavior) => editor.registerBehavior({\n      behavior\n    }));\n    return () => {\n      for (const unregisterBehavior of unregisterBehaviors)\n        unregisterBehavior();\n    };\n  }, t1 = [editor, props.config], $[0] = editor, $[1] = props.config, $[2] = t0, $[3] = t1) : (t0 = $[2], t1 = $[3]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(t0, t1);\n  let t2;\n  $[4] !== props.config.boldDecorator ? (t2 = props.config.boldDecorator ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, { children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(DecoratorShortcutPlugin, { decorator: props.config.boldDecorator, pair: {\n      char: \"*\",\n      amount: 2\n    } }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(DecoratorShortcutPlugin, { decorator: props.config.boldDecorator, pair: {\n      char: \"_\",\n      amount: 2\n    } })\n  ] }) : null, $[4] = props.config.boldDecorator, $[5] = t2) : t2 = $[5];\n  let t3;\n  $[6] !== props.config.codeDecorator ? (t3 = props.config.codeDecorator ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(DecoratorShortcutPlugin, { decorator: props.config.codeDecorator, pair: {\n    char: \"`\",\n    amount: 1\n  } }) : null, $[6] = props.config.codeDecorator, $[7] = t3) : t3 = $[7];\n  let t4;\n  $[8] !== props.config.italicDecorator ? (t4 = props.config.italicDecorator ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, { children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(DecoratorShortcutPlugin, { decorator: props.config.italicDecorator, pair: {\n      char: \"*\",\n      amount: 1\n    } }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(DecoratorShortcutPlugin, { decorator: props.config.italicDecorator, pair: {\n      char: \"_\",\n      amount: 1\n    } })\n  ] }) : null, $[8] = props.config.italicDecorator, $[9] = t4) : t4 = $[9];\n  let t5;\n  $[10] !== props.config.strikeThroughDecorator ? (t5 = props.config.strikeThroughDecorator ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(DecoratorShortcutPlugin, { decorator: props.config.strikeThroughDecorator, pair: {\n    char: \"~\",\n    amount: 2\n  } }) : null, $[10] = props.config.strikeThroughDecorator, $[11] = t5) : t5 = $[11];\n  let t6;\n  return $[12] !== t2 || $[13] !== t3 || $[14] !== t4 || $[15] !== t5 ? (t6 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, { children: [\n    t2,\n    t3,\n    t4,\n    t5\n  ] }), $[12] = t2, $[13] = t3, $[14] = t4, $[15] = t5, $[16] = t6) : t6 = $[16], t6;\n}\nconst oneLineBehaviors = [\n  /**\n   * Hitting Enter on an expanded selection should just delete that selection\n   * without causing a line break.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"insert.break\",\n    guard: ({\n      snapshot\n    }) => snapshot.context.selection && (0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_6__.isSelectionExpanded)(snapshot) ? {\n      selection: snapshot.context.selection\n    } : !1,\n    actions: [(_, {\n      selection\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"delete\",\n      at: selection\n    })]]\n  }),\n  /**\n   * All other cases of `insert.break` should be aborted.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"insert.break\",\n    actions: []\n  }),\n  /**\n   * `insert.block` `before` or `after` is not allowed in a one-line editor.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"insert.block\",\n    guard: ({\n      event\n    }) => event.placement === \"before\" || event.placement === \"after\",\n    actions: []\n  }),\n  /**\n   * An ordinary `insert.block` is acceptable if it's a text block. In that\n   * case it will get merged into the existing text block.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"insert.block\",\n    guard: ({\n      snapshot,\n      event\n    }) => !(!(0,_chunks_es_selector_get_selection_text_js__WEBPACK_IMPORTED_MODULE_6__.getFocusTextBlock)(snapshot) || !(0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_14__.isTextBlock)(snapshot.context, event.block)),\n    actions: [({\n      event\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"insert.block\",\n      block: event.block,\n      placement: \"auto\",\n      select: \"end\"\n    })]]\n  }),\n  /**\n   * Fallback Behavior to avoid `insert.block` in case the Behaviors above all\n   * end up with a falsy guard.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"insert.block\",\n    actions: []\n  }),\n  /**\n   * If multiple blocks are inserted, then the non-text blocks are filtered out\n   * and the text blocks are merged into one block\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"insert.blocks\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      const textBlocks = event.blocks.filter((block) => (0,_portabletext_schema__WEBPACK_IMPORTED_MODULE_14__.isTextBlock)(snapshot.context, block));\n      return textBlocks.length === 0 ? !1 : textBlocks.reduce((targetBlock, incomingBlock) => (0,_chunks_es_util_merge_text_blocks_js__WEBPACK_IMPORTED_MODULE_15__.mergeTextBlocks)({\n        context: snapshot.context,\n        targetBlock,\n        incomingBlock\n      }));\n    },\n    actions: [\n      // `insert.block` is raised so the Behavior above can handle the\n      // insertion\n      (_, block) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.raise)({\n        type: \"insert.block\",\n        block,\n        placement: \"auto\"\n      })]\n    ]\n  }),\n  /**\n   * Fallback Behavior to avoid `insert.blocks` in case the Behavior above\n   * ends up with a falsy guard.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"insert.blocks\",\n    actions: []\n  })\n];\nfunction OneLinePlugin() {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(1);\n  let t0;\n  return $[0] === Symbol.for(\"react.memo_cache_sentinel\") ? (t0 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(BehaviorPlugin, { behaviors: oneLineBehaviors }), $[0] = t0) : t0 = $[0], t0;\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9wbHVnaW5zL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMkM7QUFDRjtBQUNlO0FBQ1o7QUFDSjtBQUNhO0FBQ3FKO0FBQzNIO0FBQytCO0FBQzBCO0FBQ2hEO0FBQ2hDO0FBQ0w7QUFDdUI7QUFDMUU7QUFDQSxZQUFZLHlEQUFDLGNBQWMsbUVBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRyx5SEFBeUgsZ0RBQVM7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixLQUFLLGtCQUFrQixLQUFLLHVFQUF1RSxLQUFLLGdEQUFnRCxLQUFLLG9EQUFvRCxLQUFLO0FBQ25QLFlBQVksVUFBVSxFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsV0FBVztBQUN4RjtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csVUFBVTtBQUM1RyxTQUFTLG1FQUFjO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQWlCLGtDQUFrQyxpR0FBc0IseURBQXlELHVHQUErQjtBQUM5TDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHlCQUF5QiwwRkFBa0IsV0FBVyxFQUFFLFdBQVc7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpSEFBdUI7QUFDdkQ7QUFDQTtB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Q0EsS0FBSyxtQ0FBbUMsOEZBQW1CO0FBQzNEO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLLE1BQU0sNERBQU87QUFDbEI7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRSxtRUFBYztBQUNoQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUUsbUVBQWM7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxtRUFBYztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssUUFBUSw0RkFBaUIsZUFBZSxrRUFBVztBQUN4RDtBQUNBO0FBQ0EsS0FBSyxNQUFNLDREQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsbUVBQWM7QUFDaEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsbUVBQWM7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0RBQXdELGtFQUFXO0FBQ25FLDhGQUE4RixzRkFBZTtBQUM3RztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwREFBSztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLG1FQUFjO0FBQ2hCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFlBQVkseURBQUM7QUFDYjtBQUNBLGtGQUFrRixzREFBRyxtQkFBbUIsNkJBQTZCO0FBQ3JJO0FBUUU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL0dhbG9jay9DUy9iZWhvbWUtc2l0ZS9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL3BsdWdpbnMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYyB9IGZyb20gXCJyZWFjdC1jb21waWxlci1ydW50aW1lXCI7XG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VFZGl0b3IgfSBmcm9tIFwiLi4vX2NodW5rcy1lcy91c2UtZWRpdG9yLmpzXCI7XG5pbXBvcnQgeyB1c2VBY3RvclJlZiB9IGZyb20gXCJAeHN0YXRlL3JlYWN0XCI7XG5pbXBvcnQgaXNFcXVhbCBmcm9tIFwibG9kYXNoL2lzRXF1YWwuanNcIjtcbmltcG9ydCB7IHNldHVwLCBmcm9tQ2FsbGJhY2ssIGFzc2lnbiB9IGZyb20gXCJ4c3RhdGVcIjtcbmltcG9ydCB7IGdldEZvY3VzVGV4dEJsb2NrLCBnZXRTZWxlY3Rpb25TdGFydFBvaW50LCBnZXRQcmV2aW91c0lubGluZU9iamVjdCwgaXNTZWxlY3Rpb25Db2xsYXBzZWQsIGdldEZvY3VzU3BhbiwgZ2V0Rm9jdXNCbG9jaywgaXNTZWxlY3Rpb25FeHBhbmRlZCB9IGZyb20gXCIuLi9fY2h1bmtzLWVzL3NlbGVjdG9yLmdldC1zZWxlY3Rpb24tdGV4dC5qc1wiO1xuaW1wb3J0IHsgZ2V0QmxvY2tUZXh0QmVmb3JlIH0gZnJvbSBcIi4uL19jaHVua3MtZXMvc2VsZWN0b3IuZ2V0LXRleHQtYmVmb3JlLmpzXCI7XG5pbXBvcnQgeyBzcGFuU2VsZWN0aW9uUG9pbnRUb0Jsb2NrT2Zmc2V0LCBnZXRUZXh0QmxvY2tUZXh0IH0gZnJvbSBcIi4uL19jaHVua3MtZXMvdXRpbC5nZXQtdGV4dC1ibG9jay10ZXh0LmpzXCI7XG5pbXBvcnQgeyBibG9ja09mZnNldHNUb1NlbGVjdGlvbiwgY2hpbGRTZWxlY3Rpb25Qb2ludFRvQmxvY2tPZmZzZXQgfSBmcm9tIFwiLi4vX2NodW5rcy1lcy91dGlsLmNoaWxkLXNlbGVjdGlvbi1wb2ludC10by1ibG9jay1vZmZzZXQuanNcIjtcbmltcG9ydCB7IGRlZmluZUJlaGF2aW9yLCBleGVjdXRlLCBlZmZlY3QsIGZvcndhcmQsIHJhaXNlIH0gZnJvbSBcIi4uL2JlaGF2aW9ycy9pbmRleC5qc1wiO1xuaW1wb3J0IHsganN4cywgRnJhZ21lbnQsIGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgaXNUZXh0QmxvY2sgfSBmcm9tIFwiQHBvcnRhYmxldGV4dC9zY2hlbWFcIjtcbmltcG9ydCB7IG1lcmdlVGV4dEJsb2NrcyB9IGZyb20gXCIuLi9fY2h1bmtzLWVzL3V0aWwubWVyZ2UtdGV4dC1ibG9ja3MuanNcIjtcbmZ1bmN0aW9uIEJlaGF2aW9yUGx1Z2luKHByb3BzKSB7XG4gIGNvbnN0ICQgPSBjKDQpLCBlZGl0b3IgPSB1c2VFZGl0b3IoKTtcbiAgbGV0IHQwLCB0MTtcbiAgcmV0dXJuICRbMF0gIT09IGVkaXRvciB8fCAkWzFdICE9PSBwcm9wcy5iZWhhdmlvcnMgPyAodDAgPSAoKSA9PiB7XG4gICAgY29uc3QgdW5yZWdpc3RlckJlaGF2aW9ycyA9IHByb3BzLmJlaGF2aW9ycy5tYXAoKGJlaGF2aW9yKSA9PiBlZGl0b3IucmVnaXN0ZXJCZWhhdmlvcih7XG4gICAgICBiZWhhdmlvclxuICAgIH0pKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdW5yZWdpc3RlckJlaGF2aW9ycy5mb3JFYWNoKF90ZW1wKTtcbiAgICB9O1xuICB9LCB0MSA9IFtlZGl0b3IsIHByb3BzLmJlaGF2aW9yc10sICRbMF0gPSBlZGl0b3IsICRbMV0gPSBwcm9wcy5iZWhhdmlvcnMsICRbMl0gPSB0MCwgJFszXSA9IHQxKSA6ICh0MCA9ICRbMl0sIHQxID0gJFszXSksIHVzZUVmZmVjdCh0MCwgdDEpLCBudWxsO1xufVxuZnVuY3Rpb24gX3RlbXAodW5yZWdpc3Rlcikge1xuICB1bnJlZ2lzdGVyKCk7XG59XG5mdW5jdGlvbiBjcmVhdGVQYWlyUmVnZXgoY2hhciwgYW1vdW50KSB7XG4gIGNvbnN0IHByZVByZWZpeCA9IGAoPzwhXFxcXCR7Y2hhcn0pYCwgcHJlZml4ID0gYFxcXFwke2NoYXJ9YC5yZXBlYXQoTWF0aC5tYXgoYW1vdW50LCAxKSksIHBvc3RQcmVmaXggPSBcIig/IVxcXFxzKVwiLCBjb250ZW50ID0gYChbXiR7Y2hhcn1cXFxcbl0rPylgLCBwcmVTdWZmaXggPSBcIig/PCFcXFxccylcIiwgc3VmZml4ID0gYFxcXFwke2NoYXJ9YC5yZXBlYXQoTWF0aC5tYXgoYW1vdW50LCAxKSksIHBvc3RTdWZmaXggPSBgKD8hXFxcXCR7Y2hhcn0pYDtcbiAgcmV0dXJuIGAke3ByZVByZWZpeH0ke3ByZWZpeH0ke3Bvc3RQcmVmaXh9JHtjb250ZW50fSR7cHJlU3VmZml4fSR7c3VmZml4fSR7cG9zdFN1ZmZpeH1gO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVjb3JhdG9yUGFpckJlaGF2aW9yKGNvbmZpZykge1xuICBjb25maWcucGFpci5hbW91bnQgPCAxICYmIGNvbnNvbGUud2FybihcIlRoZSBhbW91bnQgb2YgY2hhcmFjdGVycyBpbiB0aGUgcGFpciBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIDBcIik7XG4gIGNvbnN0IHBhaXJSZWdleCA9IGNyZWF0ZVBhaXJSZWdleChjb25maWcucGFpci5jaGFyLCBjb25maWcucGFpci5hbW91bnQpLCByZWdFeCA9IG5ldyBSZWdFeHAoYCgke3BhaXJSZWdleH0pJGApO1xuICByZXR1cm4gZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImluc2VydC50ZXh0XCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBzbmFwc2hvdCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4ge1xuICAgICAgaWYgKGNvbmZpZy5wYWlyLmFtb3VudCA8IDEpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IGRlY29yYXRvciA9IGNvbmZpZy5kZWNvcmF0b3Ioe1xuICAgICAgICBzY2hlbWE6IHNuYXBzaG90LmNvbnRleHQuc2NoZW1hXG4gICAgICB9KTtcbiAgICAgIGlmIChkZWNvcmF0b3IgPT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayhzbmFwc2hvdCksIHNlbGVjdGlvblN0YXJ0UG9pbnQgPSBnZXRTZWxlY3Rpb25TdGFydFBvaW50KHNuYXBzaG90KSwgc2VsZWN0aW9uU3RhcnRPZmZzZXQgPSBzZWxlY3Rpb25TdGFydFBvaW50ID8gc3BhblNlbGVjdGlvblBvaW50VG9CbG9ja09mZnNldCh7XG4gICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICBzY2hlbWE6IHNuYXBzaG90LmNvbnRleHQuc2NoZW1hLFxuICAgICAgICAgIHZhbHVlOiBzbmFwc2hvdC5jb250ZXh0LnZhbHVlXG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdGlvblBvaW50OiBzZWxlY3Rpb25TdGFydFBvaW50XG4gICAgICB9KSA6IHZvaWQgMDtcbiAgICAgIGlmICghZm9jdXNUZXh0QmxvY2sgfHwgIXNlbGVjdGlvblN0YXJ0T2Zmc2V0KVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBuZXdUZXh0ID0gYCR7Z2V0QmxvY2tUZXh0QmVmb3JlKHNuYXBzaG90KX0ke2V2ZW50LnRleHR9YCwgdGV4dFRvRGVjb3JhdGUgPSBuZXdUZXh0Lm1hdGNoKHJlZ0V4KT8uYXQoMCk7XG4gICAgICBpZiAodGV4dFRvRGVjb3JhdGUgPT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgcHJlZml4T2Zmc2V0cyA9IHtcbiAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgcGF0aDogZm9jdXNUZXh0QmxvY2sucGF0aCxcbiAgICAgICAgICAvLyBFeGFtcGxlOiBcImZvbyAqKmJhcioqXCIubGVuZ3RoIC0gXCIqKmJhcioqXCIubGVuZ3RoID0gNFxuICAgICAgICAgIG9mZnNldDogbmV3VGV4dC5sZW5ndGggLSB0ZXh0VG9EZWNvcmF0ZS5sZW5ndGhcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICBwYXRoOiBmb2N1c1RleHRCbG9jay5wYXRoLFxuICAgICAgICAgIC8vIEV4YW1wbGU6IFwiZm9vICoqYmFyKipcIi5sZW5ndGggLSBcIioqYmFyKipcIi5sZW5ndGggKyBcIipcIi5sZW5ndGggKiAyID0gNlxuICAgICAgICAgIG9mZnNldDogbmV3VGV4dC5sZW5ndGggLSB0ZXh0VG9EZWNvcmF0ZS5sZW5ndGggKyBjb25maWcucGFpci5jaGFyLmxlbmd0aCAqIGNvbmZpZy5wYWlyLmFtb3VudFxuICAgICAgICB9XG4gICAgICB9LCBzdWZmaXhPZmZzZXRzID0ge1xuICAgICAgICBhbmNob3I6IHtcbiAgICAgICAgICBwYXRoOiBmb2N1c1RleHRCbG9jay5wYXRoLFxuICAgICAgICAgIC8vIEV4YW1wbGU6IFwiZm9vICoqYmFyKnxcIiAoMTApICsgXCIqXCIubGVuZ3RoIC0gMiA9IDlcbiAgICAgICAgICBvZmZzZXQ6IHNlbGVjdGlvblN0YXJ0T2Zmc2V0Lm9mZnNldCArIGV2ZW50LnRleHQubGVuZ3RoIC0gY29uZmlnLnBhaXIuY2hhci5sZW5ndGggKiBjb25maWcucGFpci5hbW91bnRcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICBwYXRoOiBmb2N1c1RleHRCbG9jay5wYXRoLFxuICAgICAgICAgIC8vIEV4YW1wbGU6IFwiZm9vICoqYmFyKnxcIiAoMTApICsgXCIqXCIubGVuZ3RoID0gMTFcbiAgICAgICAgICBvZmZzZXQ6IHNlbGVjdGlvblN0YXJ0T2Zmc2V0Lm9mZnNldCArIGV2ZW50LnRleHQubGVuZ3RoXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAocHJlZml4T2Zmc2V0cy5mb2N1cy5vZmZzZXQgLSBwcmVmaXhPZmZzZXRzLmFuY2hvci5vZmZzZXQgPiAxKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeFNlbGVjdGlvbiA9IGJsb2NrT2Zmc2V0c1RvU2VsZWN0aW9uKHtcbiAgICAgICAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICAgIG9mZnNldHM6IHByZWZpeE9mZnNldHNcbiAgICAgICAgfSksIGlubGluZU9iamVjdEJlZm9yZVByZWZpeEZvY3VzID0gZ2V0UHJldmlvdXNJbmxpbmVPYmplY3Qoe1xuICAgICAgICAgIC4uLnNuYXBzaG90LFxuICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgICAgICBzZWxlY3Rpb246IHByZWZpeFNlbGVjdGlvbiA/IHtcbiAgICAgICAgICAgICAgYW5jaG9yOiBwcmVmaXhTZWxlY3Rpb24uZm9jdXMsXG4gICAgICAgICAgICAgIGZvY3VzOiBwcmVmaXhTZWxlY3Rpb24uZm9jdXNcbiAgICAgICAgICAgIH0gOiBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB9KSwgaW5saW5lT2JqZWN0QmVmb3JlUHJlZml4Rm9jdXNPZmZzZXQgPSBpbmxpbmVPYmplY3RCZWZvcmVQcmVmaXhGb2N1cyA/IGNoaWxkU2VsZWN0aW9uUG9pbnRUb0Jsb2NrT2Zmc2V0KHtcbiAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICBzY2hlbWE6IHNuYXBzaG90LmNvbnRleHQuc2NoZW1hLFxuICAgICAgICAgICAgdmFsdWU6IHNuYXBzaG90LmNvbnRleHQudmFsdWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNlbGVjdGlvblBvaW50OiB7XG4gICAgICAgICAgICBwYXRoOiBpbmxpbmVPYmplY3RCZWZvcmVQcmVmaXhGb2N1cy5wYXRoLFxuICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgICAgfVxuICAgICAgICB9KSA6IHZvaWQgMDtcbiAgICAgICAgaWYgKGlubGluZU9iamVjdEJlZm9yZVByZWZpeEZvY3VzT2Zmc2V0ICYmIGlubGluZU9iamVjdEJlZm9yZVByZWZpeEZvY3VzT2Zmc2V0Lm9mZnNldCA+IHByZWZpeE9mZnNldHMuYW5jaG9yLm9mZnNldCAmJiBpbmxpbmVPYmplY3RCZWZvcmVQcmVmaXhGb2N1c09mZnNldC5vZmZzZXQgPCBwcmVmaXhPZmZzZXRzLmZvY3VzLm9mZnNldClcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICBpZiAoc3VmZml4T2Zmc2V0cy5mb2N1cy5vZmZzZXQgLSBzdWZmaXhPZmZzZXRzLmFuY2hvci5vZmZzZXQgPiAxKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzSW5saW5lT2JqZWN0ID0gZ2V0UHJldmlvdXNJbmxpbmVPYmplY3Qoc25hcHNob3QpLCBwcmV2aW91c0lubGluZU9iamVjdE9mZnNldCA9IHByZXZpb3VzSW5saW5lT2JqZWN0ID8gY2hpbGRTZWxlY3Rpb25Qb2ludFRvQmxvY2tPZmZzZXQoe1xuICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgIHNjaGVtYTogc25hcHNob3QuY29udGV4dC5zY2hlbWEsXG4gICAgICAgICAgICB2YWx1ZTogc25hcHNob3QuY29udGV4dC52YWx1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2VsZWN0aW9uUG9pbnQ6IHtcbiAgICAgICAgICAgIHBhdGg6IHByZXZpb3VzSW5saW5lT2JqZWN0LnBhdGgsXG4gICAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0pIDogdm9pZCAwO1xuICAgICAgICBpZiAocHJldmlvdXNJbmxpbmVPYmplY3RPZmZzZXQgJiYgcHJldmlvdXNJbmxpbmVPYmplY3RPZmZzZXQub2Zmc2V0ID4gc3VmZml4T2Zmc2V0cy5hbmNob3Iub2Zmc2V0ICYmIHByZXZpb3VzSW5saW5lT2JqZWN0T2Zmc2V0Lm9mZnNldCA8IHN1ZmZpeE9mZnNldHMuZm9jdXMub2Zmc2V0KVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByZWZpeE9mZnNldHMsXG4gICAgICAgIHN1ZmZpeE9mZnNldHMsXG4gICAgICAgIGRlY29yYXRvclxuICAgICAgfTtcbiAgICB9LFxuICAgIGFjdGlvbnM6IFtcbiAgICAgIC8vIEluc2VydCB0aGUgdGV4dCBhcyB1c3VhbCBpbiBpdHMgb3duIHVuZG8gc3RlcFxuICAgICAgKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IFtleGVjdXRlKGV2ZW50KV0sXG4gICAgICAoXywge1xuICAgICAgICBwcmVmaXhPZmZzZXRzLFxuICAgICAgICBzdWZmaXhPZmZzZXRzLFxuICAgICAgICBkZWNvcmF0b3JcbiAgICAgIH0pID0+IFtcbiAgICAgICAgLy8gRGVjb3JhdGUgdGhlIHRleHQgYmV0d2VlbiB0aGUgcHJlZml4IGFuZCBzdWZmaXhcbiAgICAgICAgZXhlY3V0ZSh7XG4gICAgICAgICAgdHlwZTogXCJkZWNvcmF0b3IuYWRkXCIsXG4gICAgICAgICAgZGVjb3JhdG9yLFxuICAgICAgICAgIGF0OiB7XG4gICAgICAgICAgICBhbmNob3I6IHByZWZpeE9mZnNldHMuZm9jdXMsXG4gICAgICAgICAgICBmb2N1czogc3VmZml4T2Zmc2V0cy5hbmNob3JcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICAvLyBEZWxldGUgdGhlIHN1ZmZpeFxuICAgICAgICBleGVjdXRlKHtcbiAgICAgICAgICB0eXBlOiBcImRlbGV0ZS50ZXh0XCIsXG4gICAgICAgICAgYXQ6IHN1ZmZpeE9mZnNldHNcbiAgICAgICAgfSksXG4gICAgICAgIC8vIERlbGV0ZSB0aGUgcHJlZml4XG4gICAgICAgIGV4ZWN1dGUoe1xuICAgICAgICAgIHR5cGU6IFwiZGVsZXRlLnRleHRcIixcbiAgICAgICAgICBhdDogcHJlZml4T2Zmc2V0c1xuICAgICAgICB9KSxcbiAgICAgICAgLy8gVG9nZ2xlIHRoZSBkZWNvcmF0b3Igb2ZmIHNvIHRoZSBuZXh0IGluc2VydGVkIHRleHQgaXNuJ3QgZW1waGFzaXplZFxuICAgICAgICBleGVjdXRlKHtcbiAgICAgICAgICB0eXBlOiBcImRlY29yYXRvci5yZW1vdmVcIixcbiAgICAgICAgICBkZWNvcmF0b3JcbiAgICAgICAgfSksXG4gICAgICAgIGVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgY29uZmlnLm9uRGVjb3JhdGUoe1xuICAgICAgICAgICAgLi4uc3VmZml4T2Zmc2V0cy5hbmNob3IsXG4gICAgICAgICAgICBvZmZzZXQ6IHN1ZmZpeE9mZnNldHMuYW5jaG9yLm9mZnNldCAtIChwcmVmaXhPZmZzZXRzLmZvY3VzLm9mZnNldCAtIHByZWZpeE9mZnNldHMuYW5jaG9yLm9mZnNldClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgIF1cbiAgICBdXG4gIH0pO1xufVxuZnVuY3Rpb24gRGVjb3JhdG9yU2hvcnRjdXRQbHVnaW4oY29uZmlnKSB7XG4gIGNvbnN0ICQgPSBjKDQpLCBlZGl0b3IgPSB1c2VFZGl0b3IoKTtcbiAgbGV0IHQwO1xuICByZXR1cm4gJFswXSAhPT0gY29uZmlnLmRlY29yYXRvciB8fCAkWzFdICE9PSBjb25maWcucGFpciB8fCAkWzJdICE9PSBlZGl0b3IgPyAodDAgPSB7XG4gICAgaW5wdXQ6IHtcbiAgICAgIGVkaXRvcixcbiAgICAgIGRlY29yYXRvcjogY29uZmlnLmRlY29yYXRvcixcbiAgICAgIHBhaXI6IGNvbmZpZy5wYWlyXG4gICAgfVxuICB9LCAkWzBdID0gY29uZmlnLmRlY29yYXRvciwgJFsxXSA9IGNvbmZpZy5wYWlyLCAkWzJdID0gZWRpdG9yLCAkWzNdID0gdDApIDogdDAgPSAkWzNdLCB1c2VBY3RvclJlZihkZWNvcmF0b3JQYWlyTWFjaGluZSwgdDApLCBudWxsO1xufVxuY29uc3QgZW1waGFzaXNMaXN0ZW5lciA9ICh7XG4gIHNlbmRCYWNrLFxuICBpbnB1dFxufSkgPT4gaW5wdXQuZWRpdG9yLnJlZ2lzdGVyQmVoYXZpb3Ioe1xuICBiZWhhdmlvcjogY3JlYXRlRGVjb3JhdG9yUGFpckJlaGF2aW9yKHtcbiAgICBkZWNvcmF0b3I6IGlucHV0LmRlY29yYXRvcixcbiAgICBwYWlyOiBpbnB1dC5wYWlyLFxuICAgIG9uRGVjb3JhdGU6IChvZmZzZXQpID0+IHtcbiAgICAgIHNlbmRCYWNrKHtcbiAgICAgICAgdHlwZTogXCJlbXBoYXNpcy5hZGRcIixcbiAgICAgICAgYmxvY2tPZmZzZXQ6IG9mZnNldFxuICAgICAgfSk7XG4gICAgfVxuICB9KVxufSksIHNlbGVjdGlvbkxpc3RlbmVyQ2FsbGJhY2sgPSAoe1xuICBzZW5kQmFjayxcbiAgaW5wdXRcbn0pID0+IGlucHV0LmVkaXRvci5yZWdpc3RlckJlaGF2aW9yKHtcbiAgYmVoYXZpb3I6IGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJzZWxlY3RcIixcbiAgICBndWFyZDogKHtcbiAgICAgIHNuYXBzaG90LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiB7XG4gICAgICBpZiAoIWV2ZW50LmF0KVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJsb2NrT2Zmc2V0czogdm9pZCAwXG4gICAgICAgIH07XG4gICAgICBjb25zdCBhbmNob3IgPSBzcGFuU2VsZWN0aW9uUG9pbnRUb0Jsb2NrT2Zmc2V0KHtcbiAgICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgc2VsZWN0aW9uUG9pbnQ6IGV2ZW50LmF0LmFuY2hvclxuICAgICAgfSksIGZvY3VzID0gc3BhblNlbGVjdGlvblBvaW50VG9CbG9ja09mZnNldCh7XG4gICAgICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgIHNlbGVjdGlvblBvaW50OiBldmVudC5hdC5mb2N1c1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gIWFuY2hvciB8fCAhZm9jdXMgPyB7XG4gICAgICAgIGJsb2NrT2Zmc2V0czogdm9pZCAwXG4gICAgICB9IDoge1xuICAgICAgICBibG9ja09mZnNldHM6IHtcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgZm9jdXNcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIGFjdGlvbnM6IFsoe1xuICAgICAgZXZlbnRcbiAgICB9LCB7XG4gICAgICBibG9ja09mZnNldHNcbiAgICB9KSA9PiBbe1xuICAgICAgdHlwZTogXCJlZmZlY3RcIixcbiAgICAgIGVmZmVjdDogKCkgPT4ge1xuICAgICAgICBzZW5kQmFjayh7XG4gICAgICAgICAgdHlwZTogXCJzZWxlY3Rpb25cIixcbiAgICAgICAgICBibG9ja09mZnNldHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgZm9yd2FyZChldmVudCldXVxuICB9KVxufSksIGRlbGV0ZUJhY2t3YXJkTGlzdGVuZXJDYWxsYmFjayA9ICh7XG4gIHNlbmRCYWNrLFxuICBpbnB1dFxufSkgPT4gaW5wdXQuZWRpdG9yLnJlZ2lzdGVyQmVoYXZpb3Ioe1xuICBiZWhhdmlvcjogZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImRlbGV0ZS5iYWNrd2FyZFwiLFxuICAgIGFjdGlvbnM6IFsoKSA9PiBbZXhlY3V0ZSh7XG4gICAgICB0eXBlOiBcImhpc3RvcnkudW5kb1wiXG4gICAgfSksIGVmZmVjdCgoKSA9PiB7XG4gICAgICBzZW5kQmFjayh7XG4gICAgICAgIHR5cGU6IFwiZGVsZXRlLmJhY2t3YXJkXCJcbiAgICAgIH0pO1xuICAgIH0pXV1cbiAgfSlcbn0pLCBkZWNvcmF0b3JQYWlyTWFjaGluZSA9IHNldHVwKHtcbiAgdHlwZXM6IHtcbiAgICBjb250ZXh0OiB7fSxcbiAgICBpbnB1dDoge30sXG4gICAgZXZlbnRzOiB7fVxuICB9LFxuICBhY3RvcnM6IHtcbiAgICBcImVtcGhhc2lzIGxpc3RlbmVyXCI6IGZyb21DYWxsYmFjayhlbXBoYXNpc0xpc3RlbmVyKSxcbiAgICBcImRlbGV0ZS5iYWNrd2FyZCBsaXN0ZW5lclwiOiBmcm9tQ2FsbGJhY2soZGVsZXRlQmFja3dhcmRMaXN0ZW5lckNhbGxiYWNrKSxcbiAgICBcInNlbGVjdGlvbiBsaXN0ZW5lclwiOiBmcm9tQ2FsbGJhY2soc2VsZWN0aW9uTGlzdGVuZXJDYWxsYmFjaylcbiAgfVxufSkuY3JlYXRlTWFjaGluZSh7XG4gIGlkOiBcImRlY29yYXRvciBwYWlyXCIsXG4gIGNvbnRleHQ6ICh7XG4gICAgaW5wdXRcbiAgfSkgPT4gKHtcbiAgICBkZWNvcmF0b3I6IGlucHV0LmRlY29yYXRvcixcbiAgICBlZGl0b3I6IGlucHV0LmVkaXRvcixcbiAgICBwYWlyOiBpbnB1dC5wYWlyXG4gIH0pLFxuICBpbml0aWFsOiBcImlkbGVcIixcbiAgc3RhdGVzOiB7XG4gICAgaWRsZToge1xuICAgICAgaW52b2tlOiBbe1xuICAgICAgICBzcmM6IFwiZW1waGFzaXMgbGlzdGVuZXJcIixcbiAgICAgICAgaW5wdXQ6ICh7XG4gICAgICAgICAgY29udGV4dFxuICAgICAgICB9KSA9PiAoe1xuICAgICAgICAgIGRlY29yYXRvcjogY29udGV4dC5kZWNvcmF0b3IsXG4gICAgICAgICAgZWRpdG9yOiBjb250ZXh0LmVkaXRvcixcbiAgICAgICAgICBwYWlyOiBjb250ZXh0LnBhaXJcbiAgICAgICAgfSlcbiAgICAgIH1dLFxuICAgICAgb246IHtcbiAgICAgICAgXCJlbXBoYXNpcy5hZGRcIjoge1xuICAgICAgICAgIHRhcmdldDogXCJlbXBoYXNpcyBhZGRlZFwiLFxuICAgICAgICAgIGFjdGlvbnM6IGFzc2lnbih7XG4gICAgICAgICAgICBvZmZzZXRBZnRlckVtcGhhc2lzOiAoe1xuICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgfSkgPT4gZXZlbnQuYmxvY2tPZmZzZXRcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImVtcGhhc2lzIGFkZGVkXCI6IHtcbiAgICAgIGV4aXQ6IFthc3NpZ24oe1xuICAgICAgICBvZmZzZXRBZnRlckVtcGhhc2lzOiB2b2lkIDBcbiAgICAgIH0pXSxcbiAgICAgIGludm9rZTogW3tcbiAgICAgICAgc3JjOiBcInNlbGVjdGlvbiBsaXN0ZW5lclwiLFxuICAgICAgICBpbnB1dDogKHtcbiAgICAgICAgICBjb250ZXh0XG4gICAgICAgIH0pID0+ICh7XG4gICAgICAgICAgZWRpdG9yOiBjb250ZXh0LmVkaXRvclxuICAgICAgICB9KVxuICAgICAgfSwge1xuICAgICAgICBzcmM6IFwiZGVsZXRlLmJhY2t3YXJkIGxpc3RlbmVyXCIsXG4gICAgICAgIGlucHV0OiAoe1xuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgfSkgPT4gKHtcbiAgICAgICAgICBlZGl0b3I6IGNvbnRleHQuZWRpdG9yXG4gICAgICAgIH0pXG4gICAgICB9XSxcbiAgICAgIG9uOiB7XG4gICAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICAgIHRhcmdldDogXCJpZGxlXCIsXG4gICAgICAgICAgZ3VhcmQ6ICh7XG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICB9KSA9PiAhaXNFcXVhbCh7XG4gICAgICAgICAgICBhbmNob3I6IGNvbnRleHQub2Zmc2V0QWZ0ZXJFbXBoYXNpcyxcbiAgICAgICAgICAgIGZvY3VzOiBjb250ZXh0Lm9mZnNldEFmdGVyRW1waGFzaXNcbiAgICAgICAgICB9LCBldmVudC5ibG9ja09mZnNldHMpXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGVsZXRlLmJhY2t3YXJkXCI6IHtcbiAgICAgICAgICB0YXJnZXQ6IFwiaWRsZVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pLCBFZGl0b3JSZWZQbHVnaW4gPSBSZWFjdC5mb3J3YXJkUmVmKChfLCByZWYpID0+IHtcbiAgY29uc3QgJCA9IGMoMiksIGVkaXRvciA9IHVzZUVkaXRvcigpLCBwb3J0YWJsZVRleHRFZGl0b3JSZWYgPSBSZWFjdC51c2VSZWYoZWRpdG9yKTtcbiAgbGV0IHQwLCB0MTtcbiAgcmV0dXJuICRbMF0gPT09IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vX2NhY2hlX3NlbnRpbmVsXCIpID8gKHQwID0gKCkgPT4gcG9ydGFibGVUZXh0RWRpdG9yUmVmLmN1cnJlbnQsIHQxID0gW10sICRbMF0gPSB0MCwgJFsxXSA9IHQxKSA6ICh0MCA9ICRbMF0sIHQxID0gJFsxXSksIFJlYWN0LnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCB0MCwgdDEpLCBudWxsO1xufSk7XG5FZGl0b3JSZWZQbHVnaW4uZGlzcGxheU5hbWUgPSBcIkVkaXRvclJlZlBsdWdpblwiO1xuZnVuY3Rpb24gRXZlbnRMaXN0ZW5lclBsdWdpbihwcm9wcykge1xuICBjb25zdCAkID0gYyg0KSwgZWRpdG9yID0gdXNlRWRpdG9yKCk7XG4gIGxldCB0MCwgdDE7XG4gIHJldHVybiAkWzBdICE9PSBlZGl0b3IgfHwgJFsxXSAhPT0gcHJvcHMub24gPyAodDAgPSAoKSA9PiB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gZWRpdG9yLm9uKFwiKlwiLCBwcm9wcy5vbik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIHQxID0gW2VkaXRvciwgcHJvcHMub25dLCAkWzBdID0gZWRpdG9yLCAkWzFdID0gcHJvcHMub24sICRbMl0gPSB0MCwgJFszXSA9IHQxKSA6ICh0MCA9ICRbMl0sIHQxID0gJFszXSksIHVzZUVmZmVjdCh0MCwgdDEpLCBudWxsO1xufVxuZnVuY3Rpb24gY3JlYXRlTWFya2Rvd25CZWhhdmlvcnMoY29uZmlnKSB7XG4gIGNvbnN0IGF1dG9tYXRpY0Jsb2NrcXVvdGVPblNwYWNlID0gZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImluc2VydC50ZXh0XCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBzbmFwc2hvdCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4ge1xuICAgICAgaWYgKGV2ZW50LnRleHQgIT09IFwiIFwiKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBzZWxlY3Rpb25Db2xsYXBzZWQgPSBpc1NlbGVjdGlvbkNvbGxhcHNlZChzbmFwc2hvdCksIGZvY3VzVGV4dEJsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soc25hcHNob3QpLCBmb2N1c1NwYW4gPSBnZXRGb2N1c1NwYW4oc25hcHNob3QpO1xuICAgICAgaWYgKCFzZWxlY3Rpb25Db2xsYXBzZWQgfHwgIWZvY3VzVGV4dEJsb2NrIHx8ICFmb2N1c1NwYW4pXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHByZXZpb3VzSW5saW5lT2JqZWN0ID0gZ2V0UHJldmlvdXNJbmxpbmVPYmplY3Qoc25hcHNob3QpLCBibG9ja09mZnNldCA9IHNwYW5TZWxlY3Rpb25Qb2ludFRvQmxvY2tPZmZzZXQoe1xuICAgICAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICBzZWxlY3Rpb25Qb2ludDoge1xuICAgICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgICBfa2V5OiBmb2N1c1RleHRCbG9jay5ub2RlLl9rZXlcbiAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgIF9rZXk6IGZvY3VzU3Bhbi5ub2RlLl9rZXlcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBvZmZzZXQ6IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uPy5mb2N1cy5vZmZzZXQgPz8gMFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChwcmV2aW91c0lubGluZU9iamVjdCB8fCAhYmxvY2tPZmZzZXQpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IGJsb2NrVGV4dCA9IGdldFRleHRCbG9ja1RleHQoZm9jdXNUZXh0QmxvY2subm9kZSksIGNhcmV0QXRUaGVFbmRPZlF1b3RlID0gYmxvY2tPZmZzZXQub2Zmc2V0ID09PSAxLCBsb29rc0xpa2VNYXJrZG93blF1b3RlID0gL14+Ly50ZXN0KGJsb2NrVGV4dCksIGJsb2NrcXVvdGVTdHlsZSA9IGNvbmZpZy5ibG9ja3F1b3RlU3R5bGU/LihzbmFwc2hvdC5jb250ZXh0KTtcbiAgICAgIHJldHVybiBjYXJldEF0VGhlRW5kT2ZRdW90ZSAmJiBsb29rc0xpa2VNYXJrZG93blF1b3RlICYmIGJsb2NrcXVvdGVTdHlsZSAhPT0gdm9pZCAwID8ge1xuICAgICAgICBmb2N1c1RleHRCbG9jayxcbiAgICAgICAgc3R5bGU6IGJsb2NrcXVvdGVTdHlsZVxuICAgICAgfSA6ICExO1xuICAgIH0sXG4gICAgYWN0aW9uczogWygpID0+IFtleGVjdXRlKHtcbiAgICAgIHR5cGU6IFwiaW5zZXJ0LnRleHRcIixcbiAgICAgIHRleHQ6IFwiIFwiXG4gICAgfSldLCAoXywge1xuICAgICAgZm9jdXNUZXh0QmxvY2ssXG4gICAgICBzdHlsZVxuICAgIH0pID0+IFtleGVjdXRlKHtcbiAgICAgIHR5cGU6IFwiYmxvY2sudW5zZXRcIixcbiAgICAgIHByb3BzOiBbXCJsaXN0SXRlbVwiLCBcImxldmVsXCJdLFxuICAgICAgYXQ6IGZvY3VzVGV4dEJsb2NrLnBhdGhcbiAgICB9KSwgZXhlY3V0ZSh7XG4gICAgICB0eXBlOiBcImJsb2NrLnNldFwiLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgc3R5bGVcbiAgICAgIH0sXG4gICAgICBhdDogZm9jdXNUZXh0QmxvY2sucGF0aFxuICAgIH0pLCBleGVjdXRlKHtcbiAgICAgIHR5cGU6IFwiZGVsZXRlLnRleHRcIixcbiAgICAgIGF0OiB7XG4gICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgIHBhdGg6IGZvY3VzVGV4dEJsb2NrLnBhdGgsXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIGZvY3VzOiB7XG4gICAgICAgICAgcGF0aDogZm9jdXNUZXh0QmxvY2sucGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IDJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXV1cbiAgfSksIGF1dG9tYXRpY0hyID0gZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImluc2VydC50ZXh0XCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBzbmFwc2hvdCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgaHJDaGFyYWN0ZXIgPSBldmVudC50ZXh0ID09PSBcIi1cIiA/IFwiLVwiIDogZXZlbnQudGV4dCA9PT0gXCIqXCIgPyBcIipcIiA6IGV2ZW50LnRleHQgPT09IFwiX1wiID8gXCJfXCIgOiB2b2lkIDA7XG4gICAgICBpZiAoaHJDaGFyYWN0ZXIgPT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgaHJPYmplY3QgPSBjb25maWcuaG9yaXpvbnRhbFJ1bGVPYmplY3Q/LihzbmFwc2hvdC5jb250ZXh0KSwgZm9jdXNCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHNuYXBzaG90KSwgc2VsZWN0aW9uQ29sbGFwc2VkID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQoc25hcHNob3QpO1xuICAgICAgaWYgKCFock9iamVjdCB8fCAhZm9jdXNCbG9jayB8fCAhc2VsZWN0aW9uQ29sbGFwc2VkKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBwcmV2aW91c0lubGluZU9iamVjdCA9IGdldFByZXZpb3VzSW5saW5lT2JqZWN0KHNuYXBzaG90KSwgdGV4dEJlZm9yZSA9IGdldEJsb2NrVGV4dEJlZm9yZShzbmFwc2hvdCksIGhyQmxvY2tPZmZzZXRzID0ge1xuICAgICAgICBhbmNob3I6IHtcbiAgICAgICAgICBwYXRoOiBmb2N1c0Jsb2NrLnBhdGgsXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIGZvY3VzOiB7XG4gICAgICAgICAgcGF0aDogZm9jdXNCbG9jay5wYXRoLFxuICAgICAgICAgIG9mZnNldDogM1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuICFwcmV2aW91c0lubGluZU9iamVjdCAmJiB0ZXh0QmVmb3JlID09PSBgJHtockNoYXJhY3Rlcn0ke2hyQ2hhcmFjdGVyfWAgPyB7XG4gICAgICAgIGhyT2JqZWN0LFxuICAgICAgICBmb2N1c0Jsb2NrLFxuICAgICAgICBockNoYXJhY3RlcixcbiAgICAgICAgaHJCbG9ja09mZnNldHNcbiAgICAgIH0gOiAhMTtcbiAgICB9LFxuICAgIGFjdGlvbnM6IFsoXywge1xuICAgICAgaHJDaGFyYWN0ZXJcbiAgICB9KSA9PiBbZXhlY3V0ZSh7XG4gICAgICB0eXBlOiBcImluc2VydC50ZXh0XCIsXG4gICAgICB0ZXh0OiBockNoYXJhY3RlclxuICAgIH0pXSwgKF8sIHtcbiAgICAgIGhyT2JqZWN0LFxuICAgICAgaHJCbG9ja09mZnNldHNcbiAgICB9KSA9PiBbZXhlY3V0ZSh7XG4gICAgICB0eXBlOiBcImluc2VydC5ibG9ja1wiLFxuICAgICAgcGxhY2VtZW50OiBcImJlZm9yZVwiLFxuICAgICAgYmxvY2s6IHtcbiAgICAgICAgX3R5cGU6IGhyT2JqZWN0Lm5hbWUsXG4gICAgICAgIC4uLmhyT2JqZWN0LnZhbHVlID8/IHt9XG4gICAgICB9XG4gICAgfSksIGV4ZWN1dGUoe1xuICAgICAgdHlwZTogXCJkZWxldGUudGV4dFwiLFxuICAgICAgYXQ6IGhyQmxvY2tPZmZzZXRzXG4gICAgfSldXVxuICB9KSwgYXV0b21hdGljSHJPblBhc3RlID0gZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImNsaXBib2FyZC5wYXN0ZVwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgc25hcHNob3QsXG4gICAgICBldmVudFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IHRleHQgPSBldmVudC5vcmlnaW5FdmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcInRleHQvcGxhaW5cIiksIGhyUmVnRXhwID0gL14oLS0tKSR8KF9fXykkfChcXCpcXCpcXCopJC8sIGhyQ2hhcmFjdGVycyA9IHRleHQubWF0Y2goaHJSZWdFeHApPy5bMF0sIGhyT2JqZWN0ID0gY29uZmlnLmhvcml6b250YWxSdWxlT2JqZWN0Py4oc25hcHNob3QuY29udGV4dCksIGZvY3VzQmxvY2sgPSBnZXRGb2N1c0Jsb2NrKHNuYXBzaG90KTtcbiAgICAgIHJldHVybiAhaHJDaGFyYWN0ZXJzIHx8ICFock9iamVjdCB8fCAhZm9jdXNCbG9jayA/ICExIDoge1xuICAgICAgICBockNoYXJhY3RlcnMsXG4gICAgICAgIGhyT2JqZWN0LFxuICAgICAgICBmb2N1c0Jsb2NrXG4gICAgICB9O1xuICAgIH0sXG4gICAgYWN0aW9uczogWyhfLCB7XG4gICAgICBockNoYXJhY3RlcnNcbiAgICB9KSA9PiBbZXhlY3V0ZSh7XG4gICAgICB0eXBlOiBcImluc2VydC50ZXh0XCIsXG4gICAgICB0ZXh0OiBockNoYXJhY3RlcnNcbiAgICB9KV0sICh7XG4gICAgICBzbmFwc2hvdFxuICAgIH0sIHtcbiAgICAgIGhyT2JqZWN0LFxuICAgICAgZm9jdXNCbG9ja1xuICAgIH0pID0+IGlzVGV4dEJsb2NrKHNuYXBzaG90LmNvbnRleHQsIGZvY3VzQmxvY2subm9kZSkgPyBbZXhlY3V0ZSh7XG4gICAgICB0eXBlOiBcImluc2VydC5ibG9ja1wiLFxuICAgICAgYmxvY2s6IHtcbiAgICAgICAgX3R5cGU6IHNuYXBzaG90LmNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWUsXG4gICAgICAgIGNoaWxkcmVuOiBmb2N1c0Jsb2NrLm5vZGUuY2hpbGRyZW5cbiAgICAgIH0sXG4gICAgICBwbGFjZW1lbnQ6IFwiYWZ0ZXJcIlxuICAgIH0pLCBleGVjdXRlKHtcbiAgICAgIHR5cGU6IFwiaW5zZXJ0LmJsb2NrXCIsXG4gICAgICBibG9jazoge1xuICAgICAgICBfdHlwZTogaHJPYmplY3QubmFtZSxcbiAgICAgICAgLi4uaHJPYmplY3QudmFsdWUgPz8ge31cbiAgICAgIH0sXG4gICAgICBwbGFjZW1lbnQ6IFwiYWZ0ZXJcIlxuICAgIH0pLCBleGVjdXRlKHtcbiAgICAgIHR5cGU6IFwiZGVsZXRlLmJsb2NrXCIsXG4gICAgICBhdDogZm9jdXNCbG9jay5wYXRoXG4gICAgfSldIDogW2V4ZWN1dGUoe1xuICAgICAgdHlwZTogXCJpbnNlcnQuYmxvY2tcIixcbiAgICAgIGJsb2NrOiB7XG4gICAgICAgIF90eXBlOiBock9iamVjdC5uYW1lLFxuICAgICAgICAuLi5ock9iamVjdC52YWx1ZSA/PyB7fVxuICAgICAgfSxcbiAgICAgIHBsYWNlbWVudDogXCJhZnRlclwiXG4gICAgfSldXVxuICB9KSwgYXV0b21hdGljSGVhZGluZ09uU3BhY2UgPSBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwiaW5zZXJ0LnRleHRcIixcbiAgICBndWFyZDogKHtcbiAgICAgIHNuYXBzaG90LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiB7XG4gICAgICBpZiAoZXZlbnQudGV4dCAhPT0gXCIgXCIpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbkNvbGxhcHNlZCA9IGlzU2VsZWN0aW9uQ29sbGFwc2VkKHNuYXBzaG90KSwgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayhzbmFwc2hvdCksIGZvY3VzU3BhbiA9IGdldEZvY3VzU3BhbihzbmFwc2hvdCk7XG4gICAgICBpZiAoIXNlbGVjdGlvbkNvbGxhcHNlZCB8fCAhZm9jdXNUZXh0QmxvY2sgfHwgIWZvY3VzU3BhbilcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgYmxvY2tPZmZzZXQgPSBzcGFuU2VsZWN0aW9uUG9pbnRUb0Jsb2NrT2Zmc2V0KHtcbiAgICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgc2VsZWN0aW9uUG9pbnQ6IHtcbiAgICAgICAgICBwYXRoOiBbe1xuICAgICAgICAgICAgX2tleTogZm9jdXNUZXh0QmxvY2subm9kZS5fa2V5XG4gICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICBfa2V5OiBmb2N1c1NwYW4ubm9kZS5fa2V5XG4gICAgICAgICAgfV0sXG4gICAgICAgICAgb2Zmc2V0OiBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbj8uZm9jdXMub2Zmc2V0ID8/IDBcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIWJsb2NrT2Zmc2V0KVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBwcmV2aW91c0lubGluZU9iamVjdCA9IGdldFByZXZpb3VzSW5saW5lT2JqZWN0KHNuYXBzaG90KSwgYmxvY2tUZXh0ID0gZ2V0VGV4dEJsb2NrVGV4dChmb2N1c1RleHRCbG9jay5ub2RlKSwgbWFya2Rvd25IZWFkaW5nU2VhcmNoID0gL14jKy8uZXhlYyhibG9ja1RleHQpLCBsZXZlbCA9IG1hcmtkb3duSGVhZGluZ1NlYXJjaCA/IG1hcmtkb3duSGVhZGluZ1NlYXJjaFswXS5sZW5ndGggOiB2b2lkIDAsIGNhcmV0QXRUaGVFbmRPZkhlYWRpbmcgPSBibG9ja09mZnNldC5vZmZzZXQgPT09IGxldmVsO1xuICAgICAgaWYgKHByZXZpb3VzSW5saW5lT2JqZWN0IHx8ICFjYXJldEF0VGhlRW5kT2ZIZWFkaW5nKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBzdHlsZSA9IGxldmVsICE9PSB2b2lkIDAgPyBjb25maWcuaGVhZGluZ1N0eWxlPy4oe1xuICAgICAgICBzY2hlbWE6IHNuYXBzaG90LmNvbnRleHQuc2NoZW1hLFxuICAgICAgICBsZXZlbFxuICAgICAgfSkgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gbGV2ZWwgIT09IHZvaWQgMCAmJiBzdHlsZSAhPT0gdm9pZCAwID8ge1xuICAgICAgICBmb2N1c1RleHRCbG9jayxcbiAgICAgICAgc3R5bGUsXG4gICAgICAgIGxldmVsXG4gICAgICB9IDogITE7XG4gICAgfSxcbiAgICBhY3Rpb25zOiBbKHtcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4gW2V4ZWN1dGUoZXZlbnQpXSwgKF8sIHtcbiAgICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgICAgc3R5bGUsXG4gICAgICBsZXZlbFxuICAgIH0pID0+IFtleGVjdXRlKHtcbiAgICAgIHR5cGU6IFwiYmxvY2sudW5zZXRcIixcbiAgICAgIHByb3BzOiBbXCJsaXN0SXRlbVwiLCBcImxldmVsXCJdLFxuICAgICAgYXQ6IGZvY3VzVGV4dEJsb2NrLnBhdGhcbiAgICB9KSwgZXhlY3V0ZSh7XG4gICAgICB0eXBlOiBcImJsb2NrLnNldFwiLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgc3R5bGVcbiAgICAgIH0sXG4gICAgICBhdDogZm9jdXNUZXh0QmxvY2sucGF0aFxuICAgIH0pLCBleGVjdXRlKHtcbiAgICAgIHR5cGU6IFwiZGVsZXRlLnRleHRcIixcbiAgICAgIGF0OiB7XG4gICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgIHBhdGg6IGZvY3VzVGV4dEJsb2NrLnBhdGgsXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIGZvY3VzOiB7XG4gICAgICAgICAgcGF0aDogZm9jdXNUZXh0QmxvY2sucGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IGxldmVsICsgMVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSldXVxuICB9KSwgY2xlYXJTdHlsZU9uQmFja3NwYWNlID0gZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImRlbGV0ZS5iYWNrd2FyZFwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgc25hcHNob3RcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb25Db2xsYXBzZWQgPSBpc1NlbGVjdGlvbkNvbGxhcHNlZChzbmFwc2hvdCksIGZvY3VzVGV4dEJsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soc25hcHNob3QpLCBmb2N1c1NwYW4gPSBnZXRGb2N1c1NwYW4oc25hcHNob3QpO1xuICAgICAgaWYgKCFzZWxlY3Rpb25Db2xsYXBzZWQgfHwgIWZvY3VzVGV4dEJsb2NrIHx8ICFmb2N1c1NwYW4pXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IGF0VGhlQmVnaW5uaW5nT2ZCTG9jayA9IGZvY3VzVGV4dEJsb2NrLm5vZGUuY2hpbGRyZW5bMF0uX2tleSA9PT0gZm9jdXNTcGFuLm5vZGUuX2tleSAmJiBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbj8uZm9jdXMub2Zmc2V0ID09PSAwLCBkZWZhdWx0U3R5bGUgPSBjb25maWcuZGVmYXVsdFN0eWxlPy4oc25hcHNob3QuY29udGV4dCk7XG4gICAgICByZXR1cm4gYXRUaGVCZWdpbm5pbmdPZkJMb2NrICYmIGRlZmF1bHRTdHlsZSAmJiBmb2N1c1RleHRCbG9jay5ub2RlLnN0eWxlICE9PSBkZWZhdWx0U3R5bGUgPyB7XG4gICAgICAgIGRlZmF1bHRTdHlsZSxcbiAgICAgICAgZm9jdXNUZXh0QmxvY2tcbiAgICAgIH0gOiAhMTtcbiAgICB9LFxuICAgIGFjdGlvbnM6IFsoXywge1xuICAgICAgZGVmYXVsdFN0eWxlLFxuICAgICAgZm9jdXNUZXh0QmxvY2tcbiAgICB9KSA9PiBbZXhlY3V0ZSh7XG4gICAgICB0eXBlOiBcImJsb2NrLnNldFwiLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgc3R5bGU6IGRlZmF1bHRTdHlsZVxuICAgICAgfSxcbiAgICAgIGF0OiBmb2N1c1RleHRCbG9jay5wYXRoXG4gICAgfSldXVxuICB9KSwgYXV0b21hdGljTGlzdE9uU3BhY2UgPSBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwiaW5zZXJ0LnRleHRcIixcbiAgICBndWFyZDogKHtcbiAgICAgIHNuYXBzaG90LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiB7XG4gICAgICBpZiAoZXZlbnQudGV4dCAhPT0gXCIgXCIpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbkNvbGxhcHNlZCA9IGlzU2VsZWN0aW9uQ29sbGFwc2VkKHNuYXBzaG90KSwgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayhzbmFwc2hvdCksIGZvY3VzU3BhbiA9IGdldEZvY3VzU3BhbihzbmFwc2hvdCk7XG4gICAgICBpZiAoIXNlbGVjdGlvbkNvbGxhcHNlZCB8fCAhZm9jdXNUZXh0QmxvY2sgfHwgIWZvY3VzU3BhbilcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgcHJldmlvdXNJbmxpbmVPYmplY3QgPSBnZXRQcmV2aW91c0lubGluZU9iamVjdChzbmFwc2hvdCksIGJsb2NrT2Zmc2V0ID0gc3BhblNlbGVjdGlvblBvaW50VG9CbG9ja09mZnNldCh7XG4gICAgICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgIHNlbGVjdGlvblBvaW50OiB7XG4gICAgICAgICAgcGF0aDogW3tcbiAgICAgICAgICAgIF9rZXk6IGZvY3VzVGV4dEJsb2NrLm5vZGUuX2tleVxuICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgX2tleTogZm9jdXNTcGFuLm5vZGUuX2tleVxuICAgICAgICAgIH1dLFxuICAgICAgICAgIG9mZnNldDogc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24/LmZvY3VzLm9mZnNldCA/PyAwXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHByZXZpb3VzSW5saW5lT2JqZWN0IHx8ICFibG9ja09mZnNldClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgYmxvY2tUZXh0ID0gZ2V0VGV4dEJsb2NrVGV4dChmb2N1c1RleHRCbG9jay5ub2RlKSwgZGVmYXVsdFN0eWxlID0gY29uZmlnLmRlZmF1bHRTdHlsZT8uKHNuYXBzaG90LmNvbnRleHQpLCBsb29rc0xpa2VVbm9yZGVyZWRMaXN0ID0gL14oLXxcXCopLy50ZXN0KGJsb2NrVGV4dCksIHVub3JkZXJlZExpc3RTdHlsZSA9IGNvbmZpZy51bm9yZGVyZWRMaXN0U3R5bGU/LihzbmFwc2hvdC5jb250ZXh0KSwgY2FyZXRBdFRoZUVuZE9mVW5vcmRlcmVkTGlzdCA9IGJsb2NrT2Zmc2V0Lm9mZnNldCA9PT0gMTtcbiAgICAgIGlmIChkZWZhdWx0U3R5bGUgJiYgY2FyZXRBdFRoZUVuZE9mVW5vcmRlcmVkTGlzdCAmJiBsb29rc0xpa2VVbm9yZGVyZWRMaXN0ICYmIHVub3JkZXJlZExpc3RTdHlsZSAhPT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgICAgICAgIGxpc3RJdGVtOiB1bm9yZGVyZWRMaXN0U3R5bGUsXG4gICAgICAgICAgbGlzdEl0ZW1MZW5ndGg6IDEsXG4gICAgICAgICAgc3R5bGU6IGRlZmF1bHRTdHlsZVxuICAgICAgICB9O1xuICAgICAgY29uc3QgbG9va3NMaWtlT3JkZXJlZExpc3QgPSAvXjFcXC4vLnRlc3QoYmxvY2tUZXh0KSwgb3JkZXJlZExpc3RTdHlsZSA9IGNvbmZpZy5vcmRlcmVkTGlzdFN0eWxlPy4oc25hcHNob3QuY29udGV4dCksIGNhcmV0QXRUaGVFbmRPZk9yZGVyZWRMaXN0ID0gYmxvY2tPZmZzZXQub2Zmc2V0ID09PSAyO1xuICAgICAgcmV0dXJuIGRlZmF1bHRTdHlsZSAmJiBjYXJldEF0VGhlRW5kT2ZPcmRlcmVkTGlzdCAmJiBsb29rc0xpa2VPcmRlcmVkTGlzdCAmJiBvcmRlcmVkTGlzdFN0eWxlICE9PSB2b2lkIDAgPyB7XG4gICAgICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgICAgICBsaXN0SXRlbTogb3JkZXJlZExpc3RTdHlsZSxcbiAgICAgICAgbGlzdEl0ZW1MZW5ndGg6IDIsXG4gICAgICAgIHN0eWxlOiBkZWZhdWx0U3R5bGVcbiAgICAgIH0gOiAhMTtcbiAgICB9LFxuICAgIGFjdGlvbnM6IFsoe1xuICAgICAgZXZlbnRcbiAgICB9KSA9PiBbZXhlY3V0ZShldmVudCldLCAoXywge1xuICAgICAgZm9jdXNUZXh0QmxvY2ssXG4gICAgICBzdHlsZSxcbiAgICAgIGxpc3RJdGVtLFxuICAgICAgbGlzdEl0ZW1MZW5ndGhcbiAgICB9KSA9PiBbZXhlY3V0ZSh7XG4gICAgICB0eXBlOiBcImJsb2NrLnNldFwiLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgbGlzdEl0ZW0sXG4gICAgICAgIGxldmVsOiAxLFxuICAgICAgICBzdHlsZVxuICAgICAgfSxcbiAgICAgIGF0OiBmb2N1c1RleHRCbG9jay5wYXRoXG4gICAgfSksIGV4ZWN1dGUoe1xuICAgICAgdHlwZTogXCJkZWxldGUudGV4dFwiLFxuICAgICAgYXQ6IHtcbiAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgcGF0aDogZm9jdXNUZXh0QmxvY2sucGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICBwYXRoOiBmb2N1c1RleHRCbG9jay5wYXRoLFxuICAgICAgICAgIG9mZnNldDogbGlzdEl0ZW1MZW5ndGggKyAxXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KV1dXG4gIH0pO1xuICByZXR1cm4gW2F1dG9tYXRpY0Jsb2NrcXVvdGVPblNwYWNlLCBhdXRvbWF0aWNIZWFkaW5nT25TcGFjZSwgYXV0b21hdGljSHIsIGF1dG9tYXRpY0hyT25QYXN0ZSwgY2xlYXJTdHlsZU9uQmFja3NwYWNlLCBhdXRvbWF0aWNMaXN0T25TcGFjZV07XG59XG5mdW5jdGlvbiBNYXJrZG93blBsdWdpbihwcm9wcykge1xuICBjb25zdCAkID0gYygxNyksIGVkaXRvciA9IHVzZUVkaXRvcigpO1xuICBsZXQgdDAsIHQxO1xuICAkWzBdICE9PSBlZGl0b3IgfHwgJFsxXSAhPT0gcHJvcHMuY29uZmlnID8gKHQwID0gKCkgPT4ge1xuICAgIGNvbnN0IHVucmVnaXN0ZXJCZWhhdmlvcnMgPSBjcmVhdGVNYXJrZG93bkJlaGF2aW9ycyhwcm9wcy5jb25maWcpLm1hcCgoYmVoYXZpb3IpID0+IGVkaXRvci5yZWdpc3RlckJlaGF2aW9yKHtcbiAgICAgIGJlaGF2aW9yXG4gICAgfSkpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHVucmVnaXN0ZXJCZWhhdmlvciBvZiB1bnJlZ2lzdGVyQmVoYXZpb3JzKVxuICAgICAgICB1bnJlZ2lzdGVyQmVoYXZpb3IoKTtcbiAgICB9O1xuICB9LCB0MSA9IFtlZGl0b3IsIHByb3BzLmNvbmZpZ10sICRbMF0gPSBlZGl0b3IsICRbMV0gPSBwcm9wcy5jb25maWcsICRbMl0gPSB0MCwgJFszXSA9IHQxKSA6ICh0MCA9ICRbMl0sIHQxID0gJFszXSksIHVzZUVmZmVjdCh0MCwgdDEpO1xuICBsZXQgdDI7XG4gICRbNF0gIT09IHByb3BzLmNvbmZpZy5ib2xkRGVjb3JhdG9yID8gKHQyID0gcHJvcHMuY29uZmlnLmJvbGREZWNvcmF0b3IgPyAvKiBAX19QVVJFX18gKi8ganN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW1xuICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goRGVjb3JhdG9yU2hvcnRjdXRQbHVnaW4sIHsgZGVjb3JhdG9yOiBwcm9wcy5jb25maWcuYm9sZERlY29yYXRvciwgcGFpcjoge1xuICAgICAgY2hhcjogXCIqXCIsXG4gICAgICBhbW91bnQ6IDJcbiAgICB9IH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goRGVjb3JhdG9yU2hvcnRjdXRQbHVnaW4sIHsgZGVjb3JhdG9yOiBwcm9wcy5jb25maWcuYm9sZERlY29yYXRvciwgcGFpcjoge1xuICAgICAgY2hhcjogXCJfXCIsXG4gICAgICBhbW91bnQ6IDJcbiAgICB9IH0pXG4gIF0gfSkgOiBudWxsLCAkWzRdID0gcHJvcHMuY29uZmlnLmJvbGREZWNvcmF0b3IsICRbNV0gPSB0MikgOiB0MiA9ICRbNV07XG4gIGxldCB0MztcbiAgJFs2XSAhPT0gcHJvcHMuY29uZmlnLmNvZGVEZWNvcmF0b3IgPyAodDMgPSBwcm9wcy5jb25maWcuY29kZURlY29yYXRvciA/IC8qIEBfX1BVUkVfXyAqLyBqc3goRGVjb3JhdG9yU2hvcnRjdXRQbHVnaW4sIHsgZGVjb3JhdG9yOiBwcm9wcy5jb25maWcuY29kZURlY29yYXRvciwgcGFpcjoge1xuICAgIGNoYXI6IFwiYFwiLFxuICAgIGFtb3VudDogMVxuICB9IH0pIDogbnVsbCwgJFs2XSA9IHByb3BzLmNvbmZpZy5jb2RlRGVjb3JhdG9yLCAkWzddID0gdDMpIDogdDMgPSAkWzddO1xuICBsZXQgdDQ7XG4gICRbOF0gIT09IHByb3BzLmNvbmZpZy5pdGFsaWNEZWNvcmF0b3IgPyAodDQgPSBwcm9wcy5jb25maWcuaXRhbGljRGVjb3JhdG9yID8gLyogQF9fUFVSRV9fICovIGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8ganN4KERlY29yYXRvclNob3J0Y3V0UGx1Z2luLCB7IGRlY29yYXRvcjogcHJvcHMuY29uZmlnLml0YWxpY0RlY29yYXRvciwgcGFpcjoge1xuICAgICAgY2hhcjogXCIqXCIsXG4gICAgICBhbW91bnQ6IDFcbiAgICB9IH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goRGVjb3JhdG9yU2hvcnRjdXRQbHVnaW4sIHsgZGVjb3JhdG9yOiBwcm9wcy5jb25maWcuaXRhbGljRGVjb3JhdG9yLCBwYWlyOiB7XG4gICAgICBjaGFyOiBcIl9cIixcbiAgICAgIGFtb3VudDogMVxuICAgIH0gfSlcbiAgXSB9KSA6IG51bGwsICRbOF0gPSBwcm9wcy5jb25maWcuaXRhbGljRGVjb3JhdG9yLCAkWzldID0gdDQpIDogdDQgPSAkWzldO1xuICBsZXQgdDU7XG4gICRbMTBdICE9PSBwcm9wcy5jb25maWcuc3RyaWtlVGhyb3VnaERlY29yYXRvciA/ICh0NSA9IHByb3BzLmNvbmZpZy5zdHJpa2VUaHJvdWdoRGVjb3JhdG9yID8gLyogQF9fUFVSRV9fICovIGpzeChEZWNvcmF0b3JTaG9ydGN1dFBsdWdpbiwgeyBkZWNvcmF0b3I6IHByb3BzLmNvbmZpZy5zdHJpa2VUaHJvdWdoRGVjb3JhdG9yLCBwYWlyOiB7XG4gICAgY2hhcjogXCJ+XCIsXG4gICAgYW1vdW50OiAyXG4gIH0gfSkgOiBudWxsLCAkWzEwXSA9IHByb3BzLmNvbmZpZy5zdHJpa2VUaHJvdWdoRGVjb3JhdG9yLCAkWzExXSA9IHQ1KSA6IHQ1ID0gJFsxMV07XG4gIGxldCB0NjtcbiAgcmV0dXJuICRbMTJdICE9PSB0MiB8fCAkWzEzXSAhPT0gdDMgfHwgJFsxNF0gIT09IHQ0IHx8ICRbMTVdICE9PSB0NSA/ICh0NiA9IC8qIEBfX1BVUkVfXyAqLyBqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbXG4gICAgdDIsXG4gICAgdDMsXG4gICAgdDQsXG4gICAgdDVcbiAgXSB9KSwgJFsxMl0gPSB0MiwgJFsxM10gPSB0MywgJFsxNF0gPSB0NCwgJFsxNV0gPSB0NSwgJFsxNl0gPSB0NikgOiB0NiA9ICRbMTZdLCB0Njtcbn1cbmNvbnN0IG9uZUxpbmVCZWhhdmlvcnMgPSBbXG4gIC8qKlxuICAgKiBIaXR0aW5nIEVudGVyIG9uIGFuIGV4cGFuZGVkIHNlbGVjdGlvbiBzaG91bGQganVzdCBkZWxldGUgdGhhdCBzZWxlY3Rpb25cbiAgICogd2l0aG91dCBjYXVzaW5nIGEgbGluZSBicmVhay5cbiAgICovXG4gIGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJpbnNlcnQuYnJlYWtcIixcbiAgICBndWFyZDogKHtcbiAgICAgIHNuYXBzaG90XG4gICAgfSkgPT4gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24gJiYgaXNTZWxlY3Rpb25FeHBhbmRlZChzbmFwc2hvdCkgPyB7XG4gICAgICBzZWxlY3Rpb246IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uXG4gICAgfSA6ICExLFxuICAgIGFjdGlvbnM6IFsoXywge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSkgPT4gW2V4ZWN1dGUoe1xuICAgICAgdHlwZTogXCJkZWxldGVcIixcbiAgICAgIGF0OiBzZWxlY3Rpb25cbiAgICB9KV1dXG4gIH0pLFxuICAvKipcbiAgICogQWxsIG90aGVyIGNhc2VzIG9mIGBpbnNlcnQuYnJlYWtgIHNob3VsZCBiZSBhYm9ydGVkLlxuICAgKi9cbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImluc2VydC5icmVha1wiLFxuICAgIGFjdGlvbnM6IFtdXG4gIH0pLFxuICAvKipcbiAgICogYGluc2VydC5ibG9ja2AgYGJlZm9yZWAgb3IgYGFmdGVyYCBpcyBub3QgYWxsb3dlZCBpbiBhIG9uZS1saW5lIGVkaXRvci5cbiAgICovXG4gIGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJpbnNlcnQuYmxvY2tcIixcbiAgICBndWFyZDogKHtcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4gZXZlbnQucGxhY2VtZW50ID09PSBcImJlZm9yZVwiIHx8IGV2ZW50LnBsYWNlbWVudCA9PT0gXCJhZnRlclwiLFxuICAgIGFjdGlvbnM6IFtdXG4gIH0pLFxuICAvKipcbiAgICogQW4gb3JkaW5hcnkgYGluc2VydC5ibG9ja2AgaXMgYWNjZXB0YWJsZSBpZiBpdCdzIGEgdGV4dCBibG9jay4gSW4gdGhhdFxuICAgKiBjYXNlIGl0IHdpbGwgZ2V0IG1lcmdlZCBpbnRvIHRoZSBleGlzdGluZyB0ZXh0IGJsb2NrLlxuICAgKi9cbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImluc2VydC5ibG9ja1wiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgc25hcHNob3QsXG4gICAgICBldmVudFxuICAgIH0pID0+ICEoIWdldEZvY3VzVGV4dEJsb2NrKHNuYXBzaG90KSB8fCAhaXNUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgZXZlbnQuYmxvY2spKSxcbiAgICBhY3Rpb25zOiBbKHtcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4gW2V4ZWN1dGUoe1xuICAgICAgdHlwZTogXCJpbnNlcnQuYmxvY2tcIixcbiAgICAgIGJsb2NrOiBldmVudC5ibG9jayxcbiAgICAgIHBsYWNlbWVudDogXCJhdXRvXCIsXG4gICAgICBzZWxlY3Q6IFwiZW5kXCJcbiAgICB9KV1dXG4gIH0pLFxuICAvKipcbiAgICogRmFsbGJhY2sgQmVoYXZpb3IgdG8gYXZvaWQgYGluc2VydC5ibG9ja2AgaW4gY2FzZSB0aGUgQmVoYXZpb3JzIGFib3ZlIGFsbFxuICAgKiBlbmQgdXAgd2l0aCBhIGZhbHN5IGd1YXJkLlxuICAgKi9cbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImluc2VydC5ibG9ja1wiLFxuICAgIGFjdGlvbnM6IFtdXG4gIH0pLFxuICAvKipcbiAgICogSWYgbXVsdGlwbGUgYmxvY2tzIGFyZSBpbnNlcnRlZCwgdGhlbiB0aGUgbm9uLXRleHQgYmxvY2tzIGFyZSBmaWx0ZXJlZCBvdXRcbiAgICogYW5kIHRoZSB0ZXh0IGJsb2NrcyBhcmUgbWVyZ2VkIGludG8gb25lIGJsb2NrXG4gICAqL1xuICBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwiaW5zZXJ0LmJsb2Nrc1wiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgc25hcHNob3QsXG4gICAgICBldmVudFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IHRleHRCbG9ja3MgPSBldmVudC5ibG9ja3MuZmlsdGVyKChibG9jaykgPT4gaXNUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgYmxvY2spKTtcbiAgICAgIHJldHVybiB0ZXh0QmxvY2tzLmxlbmd0aCA9PT0gMCA/ICExIDogdGV4dEJsb2Nrcy5yZWR1Y2UoKHRhcmdldEJsb2NrLCBpbmNvbWluZ0Jsb2NrKSA9PiBtZXJnZVRleHRCbG9ja3Moe1xuICAgICAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICB0YXJnZXRCbG9jayxcbiAgICAgICAgaW5jb21pbmdCbG9ja1xuICAgICAgfSkpO1xuICAgIH0sXG4gICAgYWN0aW9uczogW1xuICAgICAgLy8gYGluc2VydC5ibG9ja2AgaXMgcmFpc2VkIHNvIHRoZSBCZWhhdmlvciBhYm92ZSBjYW4gaGFuZGxlIHRoZVxuICAgICAgLy8gaW5zZXJ0aW9uXG4gICAgICAoXywgYmxvY2spID0+IFtyYWlzZSh7XG4gICAgICAgIHR5cGU6IFwiaW5zZXJ0LmJsb2NrXCIsXG4gICAgICAgIGJsb2NrLFxuICAgICAgICBwbGFjZW1lbnQ6IFwiYXV0b1wiXG4gICAgICB9KV1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogRmFsbGJhY2sgQmVoYXZpb3IgdG8gYXZvaWQgYGluc2VydC5ibG9ja3NgIGluIGNhc2UgdGhlIEJlaGF2aW9yIGFib3ZlXG4gICAqIGVuZHMgdXAgd2l0aCBhIGZhbHN5IGd1YXJkLlxuICAgKi9cbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImluc2VydC5ibG9ja3NcIixcbiAgICBhY3Rpb25zOiBbXVxuICB9KVxuXTtcbmZ1bmN0aW9uIE9uZUxpbmVQbHVnaW4oKSB7XG4gIGNvbnN0ICQgPSBjKDEpO1xuICBsZXQgdDA7XG4gIHJldHVybiAkWzBdID09PSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb19jYWNoZV9zZW50aW5lbFwiKSA/ICh0MCA9IC8qIEBfX1BVUkVfXyAqLyBqc3goQmVoYXZpb3JQbHVnaW4sIHsgYmVoYXZpb3JzOiBvbmVMaW5lQmVoYXZpb3JzIH0pLCAkWzBdID0gdDApIDogdDAgPSAkWzBdLCB0MDtcbn1cbmV4cG9ydCB7XG4gIEJlaGF2aW9yUGx1Z2luLFxuICBEZWNvcmF0b3JTaG9ydGN1dFBsdWdpbixcbiAgRWRpdG9yUmVmUGx1Z2luLFxuICBFdmVudExpc3RlbmVyUGx1Z2luLFxuICBNYXJrZG93blBsdWdpbixcbiAgT25lTGluZVBsdWdpblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@portabletext/editor/lib/plugins/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@portabletext/editor/node_modules/slate-react/dist/index.es.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/@portabletext/editor/node_modules/slate-react/dist/index.es.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultElement: () => (/* binding */ DefaultElement),\n/* harmony export */   DefaultLeaf: () => (/* binding */ DefaultLeaf),\n/* harmony export */   DefaultPlaceholder: () => (/* binding */ DefaultPlaceholder),\n/* harmony export */   DefaultText: () => (/* binding */ DefaultText),\n/* harmony export */   Editable: () => (/* binding */ Editable),\n/* harmony export */   NODE_TO_INDEX: () => (/* reexport safe */ slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_INDEX),\n/* harmony export */   NODE_TO_PARENT: () => (/* reexport safe */ slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_PARENT),\n/* harmony export */   ReactEditor: () => (/* binding */ ReactEditor),\n/* harmony export */   Slate: () => (/* binding */ Slate),\n/* harmony export */   defaultScrollSelectionIntoView: () => (/* binding */ defaultScrollSelectionIntoView),\n/* harmony export */   useComposing: () => (/* binding */ useComposing),\n/* harmony export */   useEditor: () => (/* binding */ useEditor),\n/* harmony export */   useElement: () => (/* binding */ useElement),\n/* harmony export */   useElementIf: () => (/* binding */ useElementIf),\n/* harmony export */   useFocused: () => (/* binding */ useFocused),\n/* harmony export */   useReadOnly: () => (/* binding */ useReadOnly),\n/* harmony export */   useSelected: () => (/* binding */ useSelected),\n/* harmony export */   useSlate: () => (/* binding */ useSlate),\n/* harmony export */   useSlateSelection: () => (/* binding */ useSlateSelection),\n/* harmony export */   useSlateSelector: () => (/* binding */ useSlateSelector),\n/* harmony export */   useSlateStatic: () => (/* binding */ useSlateStatic),\n/* harmony export */   useSlateWithV: () => (/* binding */ useSlateWithV),\n/* harmony export */   withReact: () => (/* binding */ withReact)\n/* harmony export */ });\n/* harmony import */ var direction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! direction */ \"(ssr)/../node_modules/direction/index.js\");\n/* harmony import */ var direction__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(direction__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/debounce */ \"(ssr)/../node_modules/lodash/debounce.js\");\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/throttle */ \"(ssr)/../node_modules/lodash/throttle.js\");\n/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_throttle__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(ssr)/../node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var scroll_into_view_if_needed__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! scroll-into-view-if-needed */ \"(ssr)/../node_modules/scroll-into-view-if-needed/dist/index.js\");\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! slate */ \"(ssr)/../node_modules/slate/dist/index.es.js\");\n/* harmony import */ var slate_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! slate-dom */ \"(ssr)/../node_modules/slate-dom/dist/index.es.js\");\n/* harmony import */ var _juggle_resize_observer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @juggle/resize-observer */ \"(ssr)/../node_modules/@juggle/resize-observer/lib/exports/resize-observer.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-dom */ \"(ssr)/../node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n\n\n\n\n\n\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\n\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * A React context for sharing the editor object.\n */\nvar EditorContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(null);\n/**\n * Get the current editor object from the React context.\n */\nvar useSlateStatic = () => {\n  var editor = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(EditorContext);\n  if (!editor) {\n    throw new Error(\"The `useSlateStatic` hook must be used inside the <Slate> component's context.\");\n  }\n  return editor;\n};\n\n// eslint-disable-next-line no-redeclare\nvar ReactEditor = slate_dom__WEBPACK_IMPORTED_MODULE_4__.DOMEditor;\n\nfunction ownKeys$7(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$7(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$7(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$7(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n// https://github.com/facebook/draft-js/blob/main/src/component/handlers/composition/DraftEditorCompositionHandler.js#L41\n// When using keyboard English association function, conpositionEnd triggered too fast, resulting in after `insertText` still maintain association state.\nvar RESOLVE_DELAY = 25;\n// Time with no user interaction before the current user action is considered as done.\nvar FLUSH_DELAY = 200;\n// Replace with `const debug = console.log` to debug\nvar debug = function debug() {};\n// Type guard to check if a value is a DataTransfer\nvar isDataTransfer = value => (value === null || value === void 0 ? void 0 : value.constructor.name) === 'DataTransfer';\nfunction createAndroidInputManager(_ref) {\n  var {\n    editor,\n    scheduleOnDOMSelectionChange,\n    onDOMSelectionChange\n  } = _ref;\n  var flushing = false;\n  var compositionEndTimeoutId = null;\n  var flushTimeoutId = null;\n  var actionTimeoutId = null;\n  var idCounter = 0;\n  var insertPositionHint = false;\n  var applyPendingSelection = () => {\n    var pendingSelection = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_SELECTION.get(editor);\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_SELECTION.delete(editor);\n    if (pendingSelection) {\n      var {\n        selection\n      } = editor;\n      var normalized = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.normalizeRange)(editor, pendingSelection);\n      if (normalized && (!selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(normalized, selection))) {\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, normalized);\n      }\n    }\n  };\n  var performAction = () => {\n    var action = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_ACTION.get(editor);\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_ACTION.delete(editor);\n    if (!action) {\n      return;\n    }\n    if (action.at) {\n      var target = slate__WEBPACK_IMPORTED_MODULE_7__.Point.isPoint(action.at) ? (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.normalizePoint)(editor, action.at) : (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.normalizeRange)(editor, action.at);\n      if (!target) {\n        return;\n      }\n      var _targetRange = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, target);\n      if (!editor.selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(editor.selection, _targetRange)) {\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, target);\n      }\n    }\n    action.run();\n  };\n  var flush = () => {\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n    if (actionTimeoutId) {\n      clearTimeout(actionTimeoutId);\n      actionTimeoutId = null;\n    }\n    if (!hasPendingDiffs() && !hasPendingAction()) {\n      applyPendingSelection();\n      return;\n    }\n    if (!flushing) {\n      flushing = true;\n      setTimeout(() => flushing = false);\n    }\n    if (hasPendingAction()) {\n      flushing = 'action';\n    }\n    var selectionRef = editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.rangeRef(editor, editor.selection, {\n      affinity: 'forward'\n    });\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_MARKS.set(editor, editor.marks);\n    debug('flush', slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_ACTION.get(editor), slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_DIFFS.get(editor));\n    var scheduleSelectionChange = hasPendingDiffs();\n    var diff;\n    while (diff = (_EDITOR_TO_PENDING_DI = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI === void 0 ? void 0 : _EDITOR_TO_PENDING_DI[0]) {\n      var _EDITOR_TO_PENDING_DI, _EDITOR_TO_PENDING_DI2;\n      var pendingMarks = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);\n      if (pendingMarks !== undefined) {\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n        editor.marks = pendingMarks;\n      }\n      if (pendingMarks && insertPositionHint === false) {\n        insertPositionHint = null;\n      }\n      var range = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.targetRange)(diff);\n      if (!editor.selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(editor.selection, range)) {\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n      }\n      if (diff.diff.text) {\n        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, diff.diff.text);\n      } else {\n        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor);\n      }\n      // Remove diff only after we have applied it to account for it when transforming\n      // pending ranges.\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_DIFFS.set(editor, (_EDITOR_TO_PENDING_DI2 = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI2 === void 0 ? void 0 : _EDITOR_TO_PENDING_DI2.filter(_ref2 => {\n        var {\n          id\n        } = _ref2;\n        return id !== diff.id;\n      }));\n      if (!(0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.verifyDiffState)(editor, diff)) {\n        scheduleSelectionChange = false;\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_ACTION.delete(editor);\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_MARKS.delete(editor);\n        flushing = 'action';\n        // Ensure we don't restore the pending user (dom) selection\n        // since the document and dom state do not match.\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_SELECTION.delete(editor);\n        scheduleOnDOMSelectionChange.cancel();\n        onDOMSelectionChange.cancel();\n        selectionRef === null || selectionRef === void 0 || selectionRef.unref();\n      }\n    }\n    var selection = selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();\n    if (selection && !slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_SELECTION.get(editor) && (!editor.selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(selection, editor.selection))) {\n      slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, selection);\n    }\n    if (hasPendingAction()) {\n      performAction();\n      return;\n    }\n    // COMPAT: The selectionChange event is fired after the action is performed,\n    // so we have to manually schedule it to ensure we don't 'throw away' the selection\n    // while rendering if we have pending changes.\n    if (scheduleSelectionChange) {\n      scheduleOnDOMSelectionChange();\n    }\n    scheduleOnDOMSelectionChange.flush();\n    onDOMSelectionChange.flush();\n    applyPendingSelection();\n    var userMarks = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_MARKS.get(editor);\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_MARKS.delete(editor);\n    if (userMarks !== undefined) {\n      editor.marks = userMarks;\n      editor.onChange();\n    }\n  };\n  var handleCompositionEnd = _event => {\n    if (compositionEndTimeoutId) {\n      clearTimeout(compositionEndTimeoutId);\n    }\n    compositionEndTimeoutId = setTimeout(() => {\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_COMPOSING.set(editor, false);\n      flush();\n    }, RESOLVE_DELAY);\n  };\n  var handleCompositionStart = _event => {\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_COMPOSING.set(editor, true);\n    if (compositionEndTimeoutId) {\n      clearTimeout(compositionEndTimeoutId);\n      compositionEndTimeoutId = null;\n    }\n  };\n  var updatePlaceholderVisibility = function updatePlaceholderVisibility() {\n    var forceHide = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var placeholderElement = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PLACEHOLDER_ELEMENT.get(editor);\n    if (!placeholderElement) {\n      return;\n    }\n    if (hasPendingDiffs() || forceHide) {\n      placeholderElement.style.display = 'none';\n      return;\n    }\n    placeholderElement.style.removeProperty('display');\n  };\n  var storeDiff = (path, diff) => {\n    var _EDITOR_TO_PENDING_DI3;\n    var pendingDiffs = (_EDITOR_TO_PENDING_DI3 = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI3 !== void 0 ? _EDITOR_TO_PENDING_DI3 : [];\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_DIFFS.set(editor, pendingDiffs);\n    var target = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, path);\n    var idx = pendingDiffs.findIndex(change => slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(change.path, path));\n    if (idx < 0) {\n      var normalized = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.normalizeStringDiff)(target.text, diff);\n      if (normalized) {\n        pendingDiffs.push({\n          path,\n          diff,\n          id: idCounter++\n        });\n      }\n      updatePlaceholderVisibility();\n      return;\n    }\n    var merged = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.mergeStringDiffs)(target.text, pendingDiffs[idx].diff, diff);\n    if (!merged) {\n      pendingDiffs.splice(idx, 1);\n      updatePlaceholderVisibility();\n      return;\n    }\n    pendingDiffs[idx] = _objectSpread$7(_objectSpread$7({}, pendingDiffs[idx]), {}, {\n      diff: merged\n    });\n  };\n  var scheduleAction = function scheduleAction(run) {\n    var {\n      at\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    insertPositionHint = false;\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_SELECTION.delete(editor);\n    scheduleOnDOMSelectionChange.cancel();\n    onDOMSelectionChange.cancel();\n    if (hasPendingAction()) {\n      flush();\n    }\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_ACTION.set(editor, {\n      at,\n      run\n    });\n    // COMPAT: When deleting before a non-contenteditable element chrome only fires a beforeinput,\n    // (no input) and doesn't perform any dom mutations. Without a flush timeout we would never flush\n    // in this case and thus never actually perform the action.\n    actionTimeoutId = setTimeout(flush);\n  };\n  var handleDOMBeforeInput = event => {\n    var _targetRange2;\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n    if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_NODE_MAP_DIRTY.get(editor)) {\n      return;\n    }\n    var {\n      inputType: type\n    } = event;\n    var targetRange = null;\n    var data = event.dataTransfer || event.data || undefined;\n    if (insertPositionHint !== false && type !== 'insertText' && type !== 'insertCompositionText') {\n      insertPositionHint = false;\n    }\n    var [nativeTargetRange] = event.getTargetRanges();\n    if (nativeTargetRange) {\n      targetRange = ReactEditor.toSlateRange(editor, nativeTargetRange, {\n        exactMatch: false,\n        suppressThrow: true\n      });\n    }\n    // COMPAT: SelectionChange event is fired after the action is performed, so we\n    // have to manually get the selection here to ensure it's up-to-date.\n    var window = ReactEditor.getWindow(editor);\n    var domSelection = window.getSelection();\n    if (!targetRange && domSelection) {\n      nativeTargetRange = domSelection;\n      targetRange = ReactEditor.toSlateRange(editor, domSelection, {\n        exactMatch: false,\n        suppressThrow: true\n      });\n    }\n    targetRange = (_targetRange2 = targetRange) !== null && _targetRange2 !== void 0 ? _targetRange2 : editor.selection;\n    if (!targetRange) {\n      return;\n    }\n    // By default, the input manager tries to store text diffs so that we can\n    // defer flushing them at a later point in time. We don't want to flush\n    // for every input event as this can be expensive. However, there are some\n    // scenarios where we cannot safely store the text diff and must instead\n    // schedule an action to let Slate normalize the editor state.\n    var canStoreDiff = true;\n    if (type.startsWith('delete')) {\n      var direction = type.endsWith('Backward') ? 'backward' : 'forward';\n      var [start, end] = slate__WEBPACK_IMPORTED_MODULE_7__.Range.edges(targetRange);\n      var [leaf, path] = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.leaf(editor, start.path);\n      if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(targetRange)) {\n        if (leaf.text.length === start.offset && end.offset === 0) {\n          var next = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.next(editor, {\n            at: start.path,\n            match: slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText\n          });\n          if (next && slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(next[1], end.path)) {\n            // when deleting a linebreak, targetRange will span across the break (ie start in the node before and end in the node after)\n            // if the node before is empty, this will look like a hanging range and get unhung later--which will take the break we want to remove out of the range\n            // so to avoid this we collapse the target range to default to single character deletion\n            if (direction === 'backward') {\n              targetRange = {\n                anchor: end,\n                focus: end\n              };\n              start = end;\n              [leaf, path] = next;\n            } else {\n              targetRange = {\n                anchor: start,\n                focus: start\n              };\n              end = start;\n            }\n          }\n        }\n      }\n      var diff = {\n        text: '',\n        start: start.offset,\n        end: end.offset\n      };\n      var pendingDiffs = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_DIFFS.get(editor);\n      var relevantPendingDiffs = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find(change => slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(change.path, path));\n      var diffs = relevantPendingDiffs ? [relevantPendingDiffs.diff, diff] : [diff];\n      var text = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.applyStringDiff)(leaf.text, ...diffs);\n      if (text.length === 0) {\n        // Text leaf will be removed, so we need to schedule an\n        // action to remove it so that Slate can normalize instead\n        // of storing as a diff\n        canStoreDiff = false;\n      }\n      if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(targetRange)) {\n        if (canStoreDiff && slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(targetRange.anchor.path, targetRange.focus.path)) {\n          var point = {\n            path: targetRange.anchor.path,\n            offset: start.offset\n          };\n          var range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, point, point);\n          handleUserSelect(range);\n          return storeDiff(targetRange.anchor.path, {\n            text: '',\n            end: end.offset,\n            start: start.offset\n          });\n        }\n        return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n          direction\n        }), {\n          at: targetRange\n        });\n      }\n    }\n    switch (type) {\n      case 'deleteByComposition':\n      case 'deleteByCut':\n      case 'deleteByDrag':\n        {\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor), {\n            at: targetRange\n          });\n        }\n      case 'deleteContent':\n      case 'deleteContentForward':\n        {\n          var {\n            anchor\n          } = targetRange;\n          if (canStoreDiff && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(targetRange)) {\n            var targetNode = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, anchor.path);\n            if (anchor.offset < targetNode.text.length) {\n              return storeDiff(anchor.path, {\n                text: '',\n                start: anchor.offset,\n                end: anchor.offset + 1\n              });\n            }\n          }\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor), {\n            at: targetRange\n          });\n        }\n      case 'deleteContentBackward':\n        {\n          var _nativeTargetRange;\n          var {\n            anchor: _anchor\n          } = targetRange;\n          // If we have a mismatch between the native and slate selection being collapsed\n          // we are most likely deleting a zero-width placeholder and thus should perform it\n          // as an action to ensure correct behavior (mostly happens with mark placeholders)\n          var nativeCollapsed = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isDOMSelection)(nativeTargetRange) ? nativeTargetRange.isCollapsed : !!((_nativeTargetRange = nativeTargetRange) !== null && _nativeTargetRange !== void 0 && _nativeTargetRange.collapsed);\n          if (canStoreDiff && nativeCollapsed && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(targetRange) && _anchor.offset > 0) {\n            return storeDiff(_anchor.path, {\n              text: '',\n              start: _anchor.offset - 1,\n              end: _anchor.offset\n            });\n          }\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor), {\n            at: targetRange\n          });\n        }\n      case 'deleteEntireSoftLine':\n        {\n          return scheduleAction(() => {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n          }, {\n            at: targetRange\n          });\n        }\n      case 'deleteHardLineBackward':\n        {\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n            unit: 'block'\n          }), {\n            at: targetRange\n          });\n        }\n      case 'deleteSoftLineBackward':\n        {\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n            unit: 'line'\n          }), {\n            at: targetRange\n          });\n        }\n      case 'deleteHardLineForward':\n        {\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n            unit: 'block'\n          }), {\n            at: targetRange\n          });\n        }\n      case 'deleteSoftLineForward':\n        {\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n            unit: 'line'\n          }), {\n            at: targetRange\n          });\n        }\n      case 'deleteWordBackward':\n        {\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n            unit: 'word'\n          }), {\n            at: targetRange\n          });\n        }\n      case 'deleteWordForward':\n        {\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n            unit: 'word'\n          }), {\n            at: targetRange\n          });\n        }\n      case 'insertLineBreak':\n        {\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertSoftBreak(editor), {\n            at: targetRange\n          });\n        }\n      case 'insertParagraph':\n        {\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertBreak(editor), {\n            at: targetRange\n          });\n        }\n      case 'insertCompositionText':\n      case 'deleteCompositionText':\n      case 'insertFromComposition':\n      case 'insertFromDrop':\n      case 'insertFromPaste':\n      case 'insertFromYank':\n      case 'insertReplacementText':\n      case 'insertText':\n        {\n          if (isDataTransfer(data)) {\n            return scheduleAction(() => ReactEditor.insertData(editor, data), {\n              at: targetRange\n            });\n          }\n          var _text = data !== null && data !== void 0 ? data : '';\n          // COMPAT: If we are writing inside a placeholder, the ime inserts the text inside\n          // the placeholder itself and thus includes the zero-width space inside edit events.\n          if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_INSERTION_MARKS.get(editor)) {\n            _text = _text.replace('\\uFEFF', '');\n          }\n          // Pastes from the Android clipboard will generate `insertText` events.\n          // If the copied text contains any newlines, Android will append an\n          // extra newline to the end of the copied text.\n          if (type === 'insertText' && /.*\\n.*\\n$/.test(_text)) {\n            _text = _text.slice(0, -1);\n          }\n          // If the text includes a newline, split it at newlines and paste each component\n          // string, with soft breaks in between each.\n          if (_text.includes('\\n')) {\n            return scheduleAction(() => {\n              var parts = _text.split('\\n');\n              parts.forEach((line, i) => {\n                if (line) {\n                  slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, line);\n                }\n                if (i !== parts.length - 1) {\n                  slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertSoftBreak(editor);\n                }\n              });\n            }, {\n              at: targetRange\n            });\n          }\n          if (slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(targetRange.anchor.path, targetRange.focus.path)) {\n            var [_start, _end] = slate__WEBPACK_IMPORTED_MODULE_7__.Range.edges(targetRange);\n            var _diff = {\n              start: _start.offset,\n              end: _end.offset,\n              text: _text\n            };\n            // COMPAT: Swiftkey has a weird bug where the target range of the 2nd word\n            // inserted after a mark placeholder is inserted with an anchor offset off by 1.\n            // So writing 'some text' will result in 'some ttext'. Luckily all 'normal' insert\n            // text events are fired with the correct target ranges, only the final 'insertComposition'\n            // isn't, so we can adjust the target range start offset if we are confident this is the\n            // swiftkey insert causing the issue.\n            if (_text && insertPositionHint && type === 'insertCompositionText') {\n              var hintPosition = insertPositionHint.start + insertPositionHint.text.search(/\\S|$/);\n              var diffPosition = _diff.start + _diff.text.search(/\\S|$/);\n              if (diffPosition === hintPosition + 1 && _diff.end === insertPositionHint.start + insertPositionHint.text.length) {\n                _diff.start -= 1;\n                insertPositionHint = null;\n                scheduleFlush();\n              } else {\n                insertPositionHint = false;\n              }\n            } else if (type === 'insertText') {\n              if (insertPositionHint === null) {\n                insertPositionHint = _diff;\n              } else if (insertPositionHint && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(targetRange) && insertPositionHint.end + insertPositionHint.text.length === _start.offset) {\n                insertPositionHint = _objectSpread$7(_objectSpread$7({}, insertPositionHint), {}, {\n                  text: insertPositionHint.text + _text\n                });\n              } else {\n                insertPositionHint = false;\n              }\n            } else {\n              insertPositionHint = false;\n            }\n            if (canStoreDiff) {\n              var currentSelection = editor.selection;\n              storeDiff(_start.path, _diff);\n              if (currentSelection) {\n                var newPoint = {\n                  path: _start.path,\n                  offset: _start.offset + _text.length\n                };\n                scheduleAction(() => {\n                  slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, {\n                    anchor: newPoint,\n                    focus: newPoint\n                  });\n                }, {\n                  at: newPoint\n                });\n              }\n              return;\n            }\n          }\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, _text), {\n            at: targetRange\n          });\n        }\n    }\n  };\n  var hasPendingAction = () => {\n    return !!slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_ACTION.get(editor);\n  };\n  var hasPendingDiffs = () => {\n    var _EDITOR_TO_PENDING_DI4;\n    return !!((_EDITOR_TO_PENDING_DI4 = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI4 !== void 0 && _EDITOR_TO_PENDING_DI4.length);\n  };\n  var hasPendingChanges = () => {\n    return hasPendingAction() || hasPendingDiffs();\n  };\n  var isFlushing = () => {\n    return flushing;\n  };\n  var handleUserSelect = range => {\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_SELECTION.set(editor, range);\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n    var {\n      selection\n    } = editor;\n    if (!range) {\n      return;\n    }\n    var pathChanged = !selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(selection.anchor.path, range.anchor.path);\n    var parentPathChanged = !selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(selection.anchor.path.slice(0, -1), range.anchor.path.slice(0, -1));\n    if (pathChanged && insertPositionHint || parentPathChanged) {\n      insertPositionHint = false;\n    }\n    if (pathChanged || hasPendingDiffs()) {\n      flushTimeoutId = setTimeout(flush, FLUSH_DELAY);\n    }\n  };\n  var handleInput = () => {\n    if (hasPendingAction() || !hasPendingDiffs()) {\n      flush();\n    }\n  };\n  var handleKeyDown = _ => {\n    // COMPAT: Swiftkey closes the keyboard when typing inside a empty node\n    // directly next to a non-contenteditable element (= the placeholder).\n    // The only event fired soon enough for us to allow hiding the placeholder\n    // without swiftkey picking it up is the keydown event, so we have to hide it\n    // here. See https://github.com/ianstormtaylor/slate/pull/4988#issuecomment-1201050535\n    if (!hasPendingDiffs()) {\n      updatePlaceholderVisibility(true);\n      setTimeout(updatePlaceholderVisibility);\n    }\n  };\n  var scheduleFlush = () => {\n    if (!hasPendingAction()) {\n      actionTimeoutId = setTimeout(flush);\n    }\n  };\n  var handleDomMutations = mutations => {\n    if (hasPendingDiffs() || hasPendingAction()) {\n      return;\n    }\n    if (mutations.some(mutation => (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isTrackedMutation)(editor, mutation, mutations))) {\n      var _EDITOR_TO_FORCE_REND;\n      // Cause a re-render to restore the dom state if we encounter tracked mutations without\n      // a corresponding pending action.\n      (_EDITOR_TO_FORCE_REND = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_FORCE_RENDER.get(editor)) === null || _EDITOR_TO_FORCE_REND === void 0 || _EDITOR_TO_FORCE_REND();\n    }\n  };\n  return {\n    flush,\n    scheduleFlush,\n    hasPendingDiffs,\n    hasPendingAction,\n    hasPendingChanges,\n    isFlushing,\n    handleUserSelect,\n    handleCompositionEnd,\n    handleCompositionStart,\n    handleDOMBeforeInput,\n    handleKeyDown,\n    handleDomMutations,\n    handleInput\n  };\n}\n\nfunction useIsMounted() {\n  var isMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n  return isMountedRef.current;\n}\n\n/**\n * Prevent warning on SSR by falling back to useEffect when DOM isn't available\n */\nvar useIsomorphicLayoutEffect = slate_dom__WEBPACK_IMPORTED_MODULE_4__.CAN_USE_DOM ? react__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_3__.useEffect;\n\nfunction useMutationObserver(node, callback, options) {\n  var [mutationObserver] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(() => new MutationObserver(callback));\n  useIsomorphicLayoutEffect(() => {\n    // Discard mutations caused during render phase. This works due to react calling\n    // useLayoutEffect synchronously after the render phase before the next tick.\n    mutationObserver.takeRecords();\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    if (!node.current) {\n      throw new Error('Failed to attach MutationObserver, `node` is undefined');\n    }\n    mutationObserver.observe(node.current, options);\n    return () => mutationObserver.disconnect();\n  }, [mutationObserver, node, options]);\n}\n\nvar _excluded$2 = [\"node\"];\nfunction ownKeys$6(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$6(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$6(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar MUTATION_OBSERVER_CONFIG$1 = {\n  subtree: true,\n  childList: true,\n  characterData: true\n};\nvar useAndroidInputManager = !slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID ? () => null : _ref => {\n  var {\n      node\n    } = _ref,\n    options = _objectWithoutProperties(_ref, _excluded$2);\n  if (!slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID) {\n    return null;\n  }\n  var editor = useSlateStatic();\n  var isMounted = useIsMounted();\n  var [inputManager] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(() => createAndroidInputManager(_objectSpread$6({\n    editor\n  }, options)));\n  useMutationObserver(node, inputManager.handleDomMutations, MUTATION_OBSERVER_CONFIG$1);\n  slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_SCHEDULE_FLUSH.set(editor, inputManager.scheduleFlush);\n  if (isMounted) {\n    inputManager.flush();\n  }\n  return inputManager;\n};\n\nfunction ownKeys$5(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$5(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$5(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n/**\n * Leaf content strings.\n */\nvar String$1 = props => {\n  var {\n    isLast,\n    leaf,\n    parent,\n    text\n  } = props;\n  var editor = useSlateStatic();\n  var path = ReactEditor.findPath(editor, text);\n  var parentPath = slate__WEBPACK_IMPORTED_MODULE_7__.Path.parent(path);\n  var isMarkPlaceholder = Boolean(leaf[slate_dom__WEBPACK_IMPORTED_MODULE_4__.MARK_PLACEHOLDER_SYMBOL]);\n  // COMPAT: Render text inside void nodes with a zero-width space.\n  // So the node can contain selection but the text is not visible.\n  if (editor.isVoid(parent)) {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ZeroWidthString, {\n      length: slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(parent).length\n    });\n  }\n  // COMPAT: If this is the last text node in an empty block, render a zero-\n  // width space that will convert into a line break when copying and pasting\n  // to support expected plain text.\n  if (leaf.text === '' && parent.children[parent.children.length - 1] === text && !editor.isInline(parent) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.string(editor, parentPath) === '') {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ZeroWidthString, {\n      isLineBreak: true,\n      isMarkPlaceholder: isMarkPlaceholder\n    });\n  }\n  // COMPAT: If the text is empty, it's because it's on the edge of an inline\n  // node, so we render a zero-width space so that the selection can be\n  // inserted next to it still.\n  if (leaf.text === '') {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ZeroWidthString, {\n      isMarkPlaceholder: isMarkPlaceholder\n    });\n  }\n  // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n  // so we need to add an extra trailing new lines to prevent that.\n  if (isLast && leaf.text.slice(-1) === '\\n') {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(TextString, {\n      isTrailing: true,\n      text: leaf.text\n    });\n  }\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(TextString, {\n    text: leaf.text\n  });\n};\n/**\n * Leaf strings with text in them.\n */\nvar TextString = props => {\n  var {\n    text,\n    isTrailing = false\n  } = props;\n  var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n  var getTextContent = () => {\n    return \"\".concat(text !== null && text !== void 0 ? text : '').concat(isTrailing ? '\\n' : '');\n  };\n  var [initialText] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(getTextContent);\n  // This is the actual text rendering boundary where we interface with the DOM\n  // The text is not rendered as part of the virtual DOM, as since we handle basic character insertions natively,\n  // updating the DOM is not a one way dataflow anymore. What we need here is not reconciliation and diffing\n  // with previous version of the virtual DOM, but rather diffing with the actual DOM element, and replace the DOM <span> content\n  // exactly if and only if its current content does not match our current virtual DOM.\n  // Otherwise the DOM TextNode would always be replaced by React as the user types, which interferes with native text features,\n  // eg makes native spellcheck opt out from checking the text node.\n  // useLayoutEffect: updating our span before browser paint\n  useIsomorphicLayoutEffect(() => {\n    // null coalescing text to make sure we're not outputing \"null\" as a string in the extreme case it is nullish at runtime\n    var textWithTrailing = getTextContent();\n    if (ref.current && ref.current.textContent !== textWithTrailing) {\n      ref.current.textContent = textWithTrailing;\n    }\n    // intentionally not specifying dependencies, so that this effect runs on every render\n    // as this effectively replaces \"specifying the text in the virtual DOM under the <span> below\" on each render\n  });\n  // We intentionally render a memoized <span> that only receives the initial text content when the component is mounted.\n  // We defer to the layout effect above to update the `textContent` of the span element when needed.\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedText$1, {\n    ref: ref\n  }, initialText);\n};\nvar MemoizedText$1 = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.memo)( /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)((props, ref) => {\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", {\n    \"data-slate-string\": true,\n    ref: ref\n  }, props.children);\n}));\n/**\n * Leaf strings without text, render as zero-width strings.\n */\nvar ZeroWidthString = props => {\n  var {\n    length = 0,\n    isLineBreak = false,\n    isMarkPlaceholder = false\n  } = props;\n  var attributes = {\n    'data-slate-zero-width': isLineBreak ? 'n' : 'z',\n    'data-slate-length': length\n  };\n  if (isMarkPlaceholder) {\n    attributes['data-slate-mark-placeholder'] = true;\n  }\n  // FIXME: Inserting the \\uFEFF on iOS breaks capitalization at the start of an\n  // empty editor (https://github.com/ianstormtaylor/slate/issues/5199).\n  //\n  // However, not inserting the \\uFEFF on iOS causes the editor to crash when\n  // inserting any text using an IME at the start of a block. This appears to\n  // be because accepting an IME suggestion when at the start of a block (no\n  // preceding \\uFEFF) removes one or more DOM elements that `toSlateRange`\n  // depends on. (https://github.com/ianstormtaylor/slate/issues/5703)\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", _objectSpread$5({}, attributes), !slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID || !isLineBreak ? '\\uFEFF' : null, isLineBreak ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"br\", null) : null);\n};\n\nfunction ownKeys$4(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$4(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$4(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n// Delay the placeholder on Android to prevent the keyboard from closing.\n// (https://github.com/ianstormtaylor/slate/pull/5368)\nvar PLACEHOLDER_DELAY = slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID ? 300 : 0;\nfunction disconnectPlaceholderResizeObserver(placeholderResizeObserver, releaseObserver) {\n  if (placeholderResizeObserver.current) {\n    placeholderResizeObserver.current.disconnect();\n    if (releaseObserver) {\n      placeholderResizeObserver.current = null;\n    }\n  }\n}\nfunction clearTimeoutRef(timeoutRef) {\n  if (timeoutRef.current) {\n    clearTimeout(timeoutRef.current);\n    timeoutRef.current = null;\n  }\n}\nvar defaultRenderLeaf = props => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(DefaultLeaf, _objectSpread$4({}, props));\n/**\n * Individual leaves in a text node with unique formatting.\n */\nvar Leaf = props => {\n  var {\n    leaf,\n    isLast,\n    text,\n    parent,\n    renderPlaceholder,\n    renderLeaf = defaultRenderLeaf,\n    leafPosition\n  } = props;\n  var editor = useSlateStatic();\n  var placeholderResizeObserver = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n  var placeholderRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n  var [showPlaceholder, setShowPlaceholder] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n  var showPlaceholderTimeoutRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n  var callbackPlaceholderRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(placeholderEl => {\n    disconnectPlaceholderResizeObserver(placeholderResizeObserver, placeholderEl == null);\n    if (placeholderEl == null) {\n      var _leaf$onPlaceholderRe;\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PLACEHOLDER_ELEMENT.delete(editor);\n      (_leaf$onPlaceholderRe = leaf.onPlaceholderResize) === null || _leaf$onPlaceholderRe === void 0 || _leaf$onPlaceholderRe.call(leaf, null);\n    } else {\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PLACEHOLDER_ELEMENT.set(editor, placeholderEl);\n      if (!placeholderResizeObserver.current) {\n        // Create a new observer and observe the placeholder element.\n        var ResizeObserver$1 = window.ResizeObserver || _juggle_resize_observer__WEBPACK_IMPORTED_MODULE_5__.ResizeObserver;\n        placeholderResizeObserver.current = new ResizeObserver$1(() => {\n          var _leaf$onPlaceholderRe2;\n          (_leaf$onPlaceholderRe2 = leaf.onPlaceholderResize) === null || _leaf$onPlaceholderRe2 === void 0 || _leaf$onPlaceholderRe2.call(leaf, placeholderEl);\n        });\n      }\n      placeholderResizeObserver.current.observe(placeholderEl);\n      placeholderRef.current = placeholderEl;\n    }\n  }, [placeholderRef, leaf, editor]);\n  var children = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(String$1, {\n    isLast: isLast,\n    leaf: leaf,\n    parent: parent,\n    text: text\n  });\n  var leafIsPlaceholder = Boolean(leaf[slate_dom__WEBPACK_IMPORTED_MODULE_4__.PLACEHOLDER_SYMBOL]);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    if (leafIsPlaceholder) {\n      if (!showPlaceholderTimeoutRef.current) {\n        // Delay the placeholder, so it will not render in a selection\n        showPlaceholderTimeoutRef.current = setTimeout(() => {\n          setShowPlaceholder(true);\n          showPlaceholderTimeoutRef.current = null;\n        }, PLACEHOLDER_DELAY);\n      }\n    } else {\n      clearTimeoutRef(showPlaceholderTimeoutRef);\n      setShowPlaceholder(false);\n    }\n    return () => clearTimeoutRef(showPlaceholderTimeoutRef);\n  }, [leafIsPlaceholder, setShowPlaceholder]);\n  if (leafIsPlaceholder && showPlaceholder) {\n    var placeholderProps = {\n      children: leaf.placeholder,\n      attributes: {\n        'data-slate-placeholder': true,\n        style: {\n          position: 'absolute',\n          top: 0,\n          pointerEvents: 'none',\n          width: '100%',\n          maxWidth: '100%',\n          display: 'block',\n          opacity: '0.333',\n          userSelect: 'none',\n          textDecoration: 'none',\n          // Fixes https://github.com/udecode/plate/issues/2315\n          WebkitUserModify: slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_WEBKIT ? 'inherit' : undefined\n        },\n        contentEditable: false,\n        ref: callbackPlaceholderRef\n      }\n    };\n    children = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement((react__WEBPACK_IMPORTED_MODULE_3___default().Fragment), null, children, renderPlaceholder(placeholderProps));\n  }\n  // COMPAT: Having the `data-` attributes on these leaf elements ensures that\n  // in certain misbehaving browsers they aren't weirdly cloned/destroyed by\n  // contenteditable behaviors. (2019/05/08)\n  var attributes = {\n    'data-slate-leaf': true\n  };\n  return renderLeaf({\n    attributes,\n    children,\n    leaf,\n    text,\n    leafPosition\n  });\n};\nvar MemoizedLeaf = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().memo(Leaf, (prev, next) => {\n  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.renderPlaceholder === prev.renderPlaceholder && next.text === prev.text && slate__WEBPACK_IMPORTED_MODULE_7__.Text.equals(next.leaf, prev.leaf) && next.leaf[slate_dom__WEBPACK_IMPORTED_MODULE_4__.PLACEHOLDER_SYMBOL] === prev.leaf[slate_dom__WEBPACK_IMPORTED_MODULE_4__.PLACEHOLDER_SYMBOL];\n});\nvar DefaultLeaf = props => {\n  var {\n    attributes,\n    children\n  } = props;\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", _objectSpread$4({}, attributes), children);\n};\n\n/**\n * Create a selector that updates when an `update` function is called, and\n * which only causes the component to render when the result of `selector`\n * differs from the previous result according to `equalityFn`.\n *\n * If `selector` is memoized using `useCallback`, then it will only be called\n * when it changes or when `update` is called. Otherwise, `selector` will be\n * called every time the component renders.\n *\n * @example\n * const [state, update] = useGenericSelector(selector, equalityFn)\n *\n * useIsomorphicLayoutEffect(() => {\n *   return addEventListener(update)\n * }, [addEventListener, update])\n *\n * return state\n */\nfunction useGenericSelector(selector, equalityFn) {\n  var [, forceRender] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useReducer)(s => s + 1, 0);\n  var latestSubscriptionCallbackError = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();\n  var latestSelector = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(() => null);\n  var latestSelectedState = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n  var selectedState;\n  try {\n    if (selector !== latestSelector.current || latestSubscriptionCallbackError.current) {\n      var selectorResult = selector();\n      if (equalityFn(latestSelectedState.current, selectorResult)) {\n        selectedState = latestSelectedState.current;\n      } else {\n        selectedState = selectorResult;\n      }\n    } else {\n      selectedState = latestSelectedState.current;\n    }\n  } catch (err) {\n    if (latestSubscriptionCallbackError.current && isError(err)) {\n      err.message += \"\\nThe error may be correlated with this previous error:\\n\".concat(latestSubscriptionCallbackError.current.stack, \"\\n\\n\");\n    }\n    throw err;\n  }\n  latestSelector.current = selector;\n  latestSelectedState.current = selectedState;\n  latestSubscriptionCallbackError.current = undefined;\n  var update = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => {\n    try {\n      var newSelectedState = latestSelector.current();\n      if (equalityFn(latestSelectedState.current, newSelectedState)) {\n        return;\n      }\n      latestSelectedState.current = newSelectedState;\n    } catch (err) {\n      // we ignore all errors here, since when the component\n      // is re-rendered, the selectors are called again, and\n      // will throw again, if neither props nor store state\n      // changed\n      if (err instanceof Error) {\n        latestSubscriptionCallbackError.current = err;\n      } else {\n        latestSubscriptionCallbackError.current = new Error(String(err));\n      }\n    }\n    forceRender();\n    // don't rerender on equalityFn change since we want to be able to define it inline\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return [selectedState, update];\n}\nfunction isError(error) {\n  return error instanceof Error;\n}\n\n/**\n * A React context for sharing the `decorate` prop of the editable and\n * subscribing to changes on this prop.\n */\nvar DecorateContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)({});\nvar useDecorations = (node, parentDecorations) => {\n  var editor = useSlateStatic();\n  var {\n    decorate,\n    addEventListener\n  } = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(DecorateContext);\n  // Not memoized since we want nodes to be decorated on each render\n  var selector = () => {\n    var path = ReactEditor.findPath(editor, node);\n    return decorate([node, path]);\n  };\n  var equalityFn = slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText(node) ? slate_dom__WEBPACK_IMPORTED_MODULE_4__.isTextDecorationsEqual : slate_dom__WEBPACK_IMPORTED_MODULE_4__.isElementDecorationsEqual;\n  var [decorations, update] = useGenericSelector(selector, equalityFn);\n  useIsomorphicLayoutEffect(() => {\n    var unsubscribe = addEventListener(update);\n    update();\n    return unsubscribe;\n  }, [addEventListener, update]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => [...decorations, ...parentDecorations], [decorations, parentDecorations]);\n};\nvar useDecorateContext = decorateProp => {\n  var eventListeners = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(new Set());\n  var latestDecorate = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(decorateProp);\n  useIsomorphicLayoutEffect(() => {\n    latestDecorate.current = decorateProp;\n    eventListeners.current.forEach(listener => listener());\n  }, [decorateProp]);\n  var decorate = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(entry => latestDecorate.current(entry), []);\n  var addEventListener = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(callback => {\n    eventListeners.current.add(callback);\n    return () => {\n      eventListeners.current.delete(callback);\n    };\n  }, []);\n  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => ({\n    decorate,\n    addEventListener\n  }), [decorate, addEventListener]);\n};\n\nfunction ownKeys$3(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$3(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$3(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar defaultRenderText = props => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(DefaultText, _objectSpread$3({}, props));\n/**\n * Text.\n */\nvar Text = props => {\n  var {\n    decorations: parentDecorations,\n    isLast,\n    parent,\n    renderPlaceholder,\n    renderLeaf,\n    renderText = defaultRenderText,\n    text\n  } = props;\n  var editor = useSlateStatic();\n  var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n  var decorations = useDecorations(text, parentDecorations);\n  var decoratedLeaves = slate__WEBPACK_IMPORTED_MODULE_7__.Text.decorations(text, decorations);\n  var key = ReactEditor.findKey(editor, text);\n  var children = [];\n  for (var i = 0; i < decoratedLeaves.length; i++) {\n    var {\n      leaf,\n      position\n    } = decoratedLeaves[i];\n    children.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedLeaf, {\n      isLast: isLast && i === decoratedLeaves.length - 1,\n      key: \"\".concat(key.id, \"-\").concat(i),\n      renderPlaceholder: renderPlaceholder,\n      leaf: leaf,\n      leafPosition: position,\n      text: text,\n      parent: parent,\n      renderLeaf: renderLeaf\n    }));\n  }\n  // Update element-related weak maps with the DOM element ref.\n  var callbackRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(span => {\n    var KEY_TO_ELEMENT = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n    if (span) {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 || KEY_TO_ELEMENT.set(key, span);\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_ELEMENT.set(text, span);\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.ELEMENT_TO_NODE.set(span, text);\n    } else {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 || KEY_TO_ELEMENT.delete(key);\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_ELEMENT.delete(text);\n      if (ref.current) {\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.ELEMENT_TO_NODE.delete(ref.current);\n      }\n    }\n    ref.current = span;\n  }, [ref, editor, key, text]);\n  var attributes = {\n    'data-slate-node': 'text',\n    ref: callbackRef\n  };\n  return renderText({\n    text,\n    children,\n    attributes\n  });\n};\nvar MemoizedText = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().memo(Text, (prev, next) => {\n  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderText === prev.renderText && next.renderLeaf === prev.renderLeaf && next.renderPlaceholder === prev.renderPlaceholder && next.text === prev.text && (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isTextDecorationsEqual)(next.decorations, prev.decorations);\n});\nvar DefaultText = props => {\n  var {\n    attributes,\n    children\n  } = props;\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", _objectSpread$3({}, attributes), children);\n};\n\nfunction ownKeys$2(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$2(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$2(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar defaultRenderElement = props => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(DefaultElement, _objectSpread$2({}, props));\n/**\n * Element.\n */\nvar Element = props => {\n  var {\n    decorations: parentDecorations,\n    element,\n    renderElement = defaultRenderElement,\n    renderChunk,\n    renderPlaceholder,\n    renderLeaf,\n    renderText\n  } = props;\n  var editor = useSlateStatic();\n  var readOnly = useReadOnly();\n  var isInline = editor.isInline(element);\n  var decorations = useDecorations(element, parentDecorations);\n  var key = ReactEditor.findKey(editor, element);\n  var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(ref => {\n    // Update element-related weak maps with the DOM element ref.\n    var KEY_TO_ELEMENT = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n    if (ref) {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 || KEY_TO_ELEMENT.set(key, ref);\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_ELEMENT.set(element, ref);\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.ELEMENT_TO_NODE.set(ref, element);\n    } else {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 || KEY_TO_ELEMENT.delete(key);\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_ELEMENT.delete(element);\n    }\n  }, [editor, key, element]);\n  var children = useChildren({\n    decorations,\n    node: element,\n    renderElement,\n    renderChunk,\n    renderPlaceholder,\n    renderLeaf,\n    renderText\n  });\n  // Attributes that the developer must mix into the element in their\n  // custom node renderer component.\n  var attributes = {\n    'data-slate-node': 'element',\n    ref\n  };\n  if (isInline) {\n    attributes['data-slate-inline'] = true;\n  }\n  // If it's a block node with inline children, add the proper `dir` attribute\n  // for text direction.\n  if (!isInline && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasInlines(editor, element)) {\n    var text = slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(element);\n    var dir = direction__WEBPACK_IMPORTED_MODULE_0___default()(text);\n    if (dir === 'rtl') {\n      attributes.dir = dir;\n    }\n  }\n  // If it's a void node, wrap the children in extra void-specific elements.\n  if (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, element)) {\n    attributes['data-slate-void'] = true;\n    if (!readOnly && isInline) {\n      attributes.contentEditable = false;\n    }\n    var Tag = isInline ? 'span' : 'div';\n    var [[_text]] = slate__WEBPACK_IMPORTED_MODULE_7__.Node.texts(element);\n    children = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(Tag, {\n      \"data-slate-spacer\": true,\n      style: {\n        height: '0',\n        color: 'transparent',\n        outline: 'none',\n        position: 'absolute'\n      }\n    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedText, {\n      renderPlaceholder: renderPlaceholder,\n      decorations: [],\n      isLast: false,\n      parent: element,\n      text: _text\n    }));\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_INDEX.set(_text, 0);\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_PARENT.set(_text, element);\n  }\n  return renderElement({\n    attributes,\n    children,\n    element\n  });\n};\nvar MemoizedElement = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().memo(Element, (prev, next) => {\n  return prev.element === next.element && prev.renderElement === next.renderElement && prev.renderChunk === next.renderChunk && prev.renderText === next.renderText && prev.renderLeaf === next.renderLeaf && prev.renderPlaceholder === next.renderPlaceholder && (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isElementDecorationsEqual)(prev.decorations, next.decorations);\n});\n/**\n * The default element renderer.\n */\nvar DefaultElement = props => {\n  var {\n    attributes,\n    children,\n    element\n  } = props;\n  var editor = useSlateStatic();\n  var Tag = editor.isInline(element) ? 'span' : 'div';\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(Tag, _objectSpread$2(_objectSpread$2({}, attributes), {}, {\n    style: {\n      position: 'relative'\n    }\n  }), children);\n};\n\n/**\n * Traverse and modify a chunk tree\n */\nclass ChunkTreeHelper {\n  constructor(chunkTree, _ref) {\n    var {\n      chunkSize,\n      debug\n    } = _ref;\n    /**\n     * The root of the chunk tree\n     */\n    _defineProperty(this, \"root\", void 0);\n    /**\n     * The ideal size of a chunk\n     */\n    _defineProperty(this, \"chunkSize\", void 0);\n    /**\n     * Whether debug mode is enabled\n     *\n     * If enabled, the pointer state will be checked for internal consistency\n     * after each mutating operation.\n     */\n    _defineProperty(this, \"debug\", void 0);\n    /**\n     * Whether the traversal has reached the end of the chunk tree\n     *\n     * When this is true, the pointerChunk and pointerIndex point to the last\n     * top-level node in the chunk tree, although pointerNode returns null.\n     */\n    _defineProperty(this, \"reachedEnd\", void 0);\n    /**\n     * The chunk containing the current node\n     */\n    _defineProperty(this, \"pointerChunk\", void 0);\n    /**\n     * The index of the current node within pointerChunk\n     *\n     * Can be -1 to indicate that the pointer is before the start of the tree.\n     */\n    _defineProperty(this, \"pointerIndex\", void 0);\n    /**\n     * Similar to a Slate path; tracks the path of pointerChunk relative to the\n     * root.\n     *\n     * Used to move the pointer from the current chunk to the parent chunk more\n     * efficiently.\n     */\n    _defineProperty(this, \"pointerIndexStack\", void 0);\n    /**\n     * Indexing the current chunk's children has a slight time cost, which adds up\n     * when traversing very large trees, so the current node is cached.\n     *\n     * A value of undefined means that the current node is not cached. This\n     * property must be set to undefined whenever the pointer is moved, unless\n     * the pointer is guaranteed to point to the same node that it did previously.\n     */\n    _defineProperty(this, \"cachedPointerNode\", void 0);\n    this.root = chunkTree;\n    this.chunkSize = chunkSize;\n    // istanbul ignore next\n    this.debug = debug !== null && debug !== void 0 ? debug : false;\n    this.pointerChunk = chunkTree;\n    this.pointerIndex = -1;\n    this.pointerIndexStack = [];\n    this.reachedEnd = false;\n    this.validateState();\n  }\n  /**\n   * Move the pointer to the next leaf in the chunk tree\n   */\n  readLeaf() {\n    // istanbul ignore next\n    if (this.reachedEnd) return null;\n    // Get the next sibling or aunt node\n    while (true) {\n      if (this.pointerIndex + 1 < this.pointerSiblings.length) {\n        this.pointerIndex++;\n        this.cachedPointerNode = undefined;\n        break;\n      } else if (this.pointerChunk.type === 'root') {\n        this.reachedEnd = true;\n        return null;\n      } else {\n        this.exitChunk();\n      }\n    }\n    this.validateState();\n    // If the next sibling or aunt is a chunk, descend into it\n    this.enterChunkUntilLeaf(false);\n    return this.pointerNode;\n  }\n  /**\n   * Move the pointer to the previous leaf in the chunk tree\n   */\n  returnToPreviousLeaf() {\n    // If we were at the end of the tree, descend into the end of the last\n    // chunk in the tree\n    if (this.reachedEnd) {\n      this.reachedEnd = false;\n      this.enterChunkUntilLeaf(true);\n      return;\n    }\n    // Get the previous sibling or aunt node\n    while (true) {\n      if (this.pointerIndex >= 1) {\n        this.pointerIndex--;\n        this.cachedPointerNode = undefined;\n        break;\n      } else if (this.pointerChunk.type === 'root') {\n        this.pointerIndex = -1;\n        return;\n      } else {\n        this.exitChunk();\n      }\n    }\n    this.validateState();\n    // If the previous sibling or aunt is a chunk, descend into it\n    this.enterChunkUntilLeaf(true);\n  }\n  /**\n   * Insert leaves before the current leaf, leaving the pointer unchanged\n   */\n  insertBefore(leaves) {\n    this.returnToPreviousLeaf();\n    this.insertAfter(leaves);\n    this.readLeaf();\n  }\n  /**\n   * Insert leaves after the current leaf, leaving the pointer on the last\n   * inserted leaf\n   *\n   * The insertion algorithm first checks for any chunk we're currently at the\n   * end of that can receive additional leaves. Next, it tries to insert leaves\n   * at the starts of any subsequent chunks.\n   *\n   * Any remaining leaves are passed to rawInsertAfter to be chunked and\n   * inserted at the highest possible level.\n   */\n  insertAfter(leaves) {\n    // istanbul ignore next\n    if (leaves.length === 0) return;\n    var beforeDepth = 0;\n    var afterDepth = 0;\n    // While at the end of a chunk, insert any leaves that will fit, and then\n    // exit the chunk\n    while (this.pointerChunk.type === 'chunk' && this.pointerIndex === this.pointerSiblings.length - 1) {\n      var remainingCapacity = this.chunkSize - this.pointerSiblings.length;\n      var toInsertCount = Math.min(remainingCapacity, leaves.length);\n      if (toInsertCount > 0) {\n        var leavesToInsert = leaves.splice(0, toInsertCount);\n        this.rawInsertAfter(leavesToInsert, beforeDepth);\n      }\n      this.exitChunk();\n      beforeDepth++;\n    }\n    if (leaves.length === 0) return;\n    // Save the pointer so that we can come back here after inserting leaves\n    // into the starts of subsequent blocks\n    var rawInsertPointer = this.savePointer();\n    // If leaves are inserted into the start of a subsequent block, then we\n    // eventually need to restore the pointer to the last such inserted leaf\n    var finalPointer = null;\n    // Move the pointer into the chunk containing the next leaf, if it exists\n    if (this.readLeaf()) {\n      // While at the start of a chunk, insert any leaves that will fit, and\n      // then exit the chunk\n      while (this.pointerChunk.type === 'chunk' && this.pointerIndex === 0) {\n        var _remainingCapacity = this.chunkSize - this.pointerSiblings.length;\n        var _toInsertCount = Math.min(_remainingCapacity, leaves.length);\n        if (_toInsertCount > 0) {\n          var _leavesToInsert = leaves.splice(-_toInsertCount, _toInsertCount);\n          // Insert the leaves at the start of the chunk\n          this.pointerIndex = -1;\n          this.cachedPointerNode = undefined;\n          this.rawInsertAfter(_leavesToInsert, afterDepth);\n          // If this is the first batch of insertions at the start of a\n          // subsequent chunk, set the final pointer to the last inserted leaf\n          if (!finalPointer) {\n            finalPointer = this.savePointer();\n          }\n        }\n        this.exitChunk();\n        afterDepth++;\n      }\n    }\n    this.restorePointer(rawInsertPointer);\n    // If there are leaves left to insert, insert them between the end of the\n    // previous chunk and the start of the first subsequent chunk, or wherever\n    // the pointer ended up after the first batch of insertions\n    var minDepth = Math.max(beforeDepth, afterDepth);\n    this.rawInsertAfter(leaves, minDepth);\n    if (finalPointer) {\n      this.restorePointer(finalPointer);\n    }\n    this.validateState();\n  }\n  /**\n   * Remove the current node and decrement the pointer, deleting any ancestor\n   * chunk that becomes empty as a result\n   */\n  remove() {\n    this.pointerSiblings.splice(this.pointerIndex--, 1);\n    this.cachedPointerNode = undefined;\n    if (this.pointerSiblings.length === 0 && this.pointerChunk.type === 'chunk') {\n      this.exitChunk();\n      this.remove();\n    } else {\n      this.invalidateChunk();\n    }\n    this.validateState();\n  }\n  /**\n   * Add the current chunk and all ancestor chunks to the list of modified\n   * chunks\n   */\n  invalidateChunk() {\n    for (var c = this.pointerChunk; c.type === 'chunk'; c = c.parent) {\n      this.root.modifiedChunks.add(c);\n    }\n  }\n  /**\n   * Whether the pointer is at the start of the tree\n   */\n  get atStart() {\n    return this.pointerChunk.type === 'root' && this.pointerIndex === -1;\n  }\n  /**\n   * The siblings of the current node\n   */\n  get pointerSiblings() {\n    return this.pointerChunk.children;\n  }\n  /**\n   * Get the current node (uncached)\n   *\n   * If the pointer is at the start or end of the document, returns null.\n   *\n   * Usually, the current node is a chunk leaf, although it can be a chunk\n   * while insertions are in progress.\n   */\n  getPointerNode() {\n    if (this.reachedEnd || this.pointerIndex === -1) {\n      return null;\n    }\n    return this.pointerSiblings[this.pointerIndex];\n  }\n  /**\n   * Cached getter for the current node\n   */\n  get pointerNode() {\n    if (this.cachedPointerNode !== undefined) return this.cachedPointerNode;\n    var pointerNode = this.getPointerNode();\n    this.cachedPointerNode = pointerNode;\n    return pointerNode;\n  }\n  /**\n   * Get the path of a chunk relative to the root, returning null if the chunk\n   * is not connected to the root\n   */\n  getChunkPath(chunk) {\n    var path = [];\n    for (var c = chunk; c.type === 'chunk'; c = c.parent) {\n      var index = c.parent.children.indexOf(c);\n      // istanbul ignore next\n      if (index === -1) {\n        return null;\n      }\n      path.unshift(index);\n    }\n    return path;\n  }\n  /**\n   * Save the current pointer to be restored later\n   */\n  savePointer() {\n    if (this.atStart) return 'start';\n    // istanbul ignore next\n    if (!this.pointerNode) {\n      throw new Error('Cannot save pointer when pointerNode is null');\n    }\n    return {\n      chunk: this.pointerChunk,\n      node: this.pointerNode\n    };\n  }\n  /**\n   * Restore the pointer to a previous state\n   */\n  restorePointer(savedPointer) {\n    if (savedPointer === 'start') {\n      this.pointerChunk = this.root;\n      this.pointerIndex = -1;\n      this.pointerIndexStack = [];\n      this.reachedEnd = false;\n      this.cachedPointerNode = undefined;\n      return;\n    }\n    // Since nodes may have been inserted or removed prior to the saved\n    // pointer since it was saved, the index and index stack must be\n    // recomputed. This is slow, but this is fine since restoring a pointer is\n    // not a frequent operation.\n    var {\n      chunk,\n      node\n    } = savedPointer;\n    var index = chunk.children.indexOf(node);\n    // istanbul ignore next\n    if (index === -1) {\n      throw new Error('Cannot restore point because saved node is no longer in saved chunk');\n    }\n    var indexStack = this.getChunkPath(chunk);\n    // istanbul ignore next\n    if (!indexStack) {\n      throw new Error('Cannot restore point because saved chunk is no longer connected to root');\n    }\n    this.pointerChunk = chunk;\n    this.pointerIndex = index;\n    this.pointerIndexStack = indexStack;\n    this.reachedEnd = false;\n    this.cachedPointerNode = node;\n    this.validateState();\n  }\n  /**\n   * Assuming the current node is a chunk, move the pointer into that chunk\n   *\n   * @param end If true, place the pointer on the last node of the chunk.\n   * Otherwise, place the pointer on the first node.\n   */\n  enterChunk(end) {\n    var _this$pointerNode;\n    // istanbul ignore next\n    if (((_this$pointerNode = this.pointerNode) === null || _this$pointerNode === void 0 ? void 0 : _this$pointerNode.type) !== 'chunk') {\n      throw new Error('Cannot enter non-chunk');\n    }\n    this.pointerIndexStack.push(this.pointerIndex);\n    this.pointerChunk = this.pointerNode;\n    this.pointerIndex = end ? this.pointerSiblings.length - 1 : 0;\n    this.cachedPointerNode = undefined;\n    this.validateState();\n    // istanbul ignore next\n    if (this.pointerChunk.children.length === 0) {\n      throw new Error('Cannot enter empty chunk');\n    }\n  }\n  /**\n   * Assuming the current node is a chunk, move the pointer into that chunk\n   * repeatedly until the current node is a leaf\n   *\n   * @param end If true, place the pointer on the last node of the chunk.\n   * Otherwise, place the pointer on the first node.\n   */\n  enterChunkUntilLeaf(end) {\n    while (((_this$pointerNode2 = this.pointerNode) === null || _this$pointerNode2 === void 0 ? void 0 : _this$pointerNode2.type) === 'chunk') {\n      var _this$pointerNode2;\n      this.enterChunk(end);\n    }\n  }\n  /**\n   * Move the pointer to the parent chunk\n   */\n  exitChunk() {\n    // istanbul ignore next\n    if (this.pointerChunk.type === 'root') {\n      throw new Error('Cannot exit root');\n    }\n    var previousPointerChunk = this.pointerChunk;\n    this.pointerChunk = previousPointerChunk.parent;\n    this.pointerIndex = this.pointerIndexStack.pop();\n    this.cachedPointerNode = undefined;\n    this.validateState();\n  }\n  /**\n   * Insert leaves immediately after the current node, leaving the pointer on\n   * the last inserted leaf\n   *\n   * Leaves are chunked according to the number of nodes already in the parent\n   * plus the number of nodes being inserted, or the minimum depth if larger\n   */\n  rawInsertAfter(leaves, minDepth) {\n    if (leaves.length === 0) return;\n    var groupIntoChunks = (leaves, parent, perChunk) => {\n      if (perChunk === 1) return leaves;\n      var chunks = [];\n      for (var i = 0; i < this.chunkSize; i++) {\n        var chunkNodes = leaves.slice(i * perChunk, (i + 1) * perChunk);\n        if (chunkNodes.length === 0) break;\n        var chunk = {\n          type: 'chunk',\n          key: new slate_dom__WEBPACK_IMPORTED_MODULE_4__.Key(),\n          parent,\n          children: []\n        };\n        chunk.children = groupIntoChunks(chunkNodes, chunk, perChunk / this.chunkSize);\n        chunks.push(chunk);\n      }\n      return chunks;\n    };\n    // Determine the chunking depth based on the number of existing nodes in\n    // the chunk and the number of nodes being inserted\n    var newTotal = this.pointerSiblings.length + leaves.length;\n    var depthForTotal = 0;\n    for (var i = this.chunkSize; i < newTotal; i *= this.chunkSize) {\n      depthForTotal++;\n    }\n    // A depth of 0 means no chunking\n    var depth = Math.max(depthForTotal, minDepth);\n    var perTopLevelChunk = Math.pow(this.chunkSize, depth);\n    var chunks = groupIntoChunks(leaves, this.pointerChunk, perTopLevelChunk);\n    this.pointerSiblings.splice(this.pointerIndex + 1, 0, ...chunks);\n    this.pointerIndex += chunks.length;\n    this.cachedPointerNode = undefined;\n    this.invalidateChunk();\n    this.validateState();\n  }\n  /**\n   * If debug mode is enabled, ensure that the state is internally consistent\n   */\n  // istanbul ignore next\n  validateState() {\n    if (!this.debug) return;\n    var validateDescendant = node => {\n      if (node.type === 'chunk') {\n        var {\n          parent,\n          children\n        } = node;\n        if (!parent.children.includes(node)) {\n          throw new Error(\"Debug: Chunk \".concat(node.key.id, \" has an incorrect parent property\"));\n        }\n        children.forEach(validateDescendant);\n      }\n    };\n    this.root.children.forEach(validateDescendant);\n    if (this.cachedPointerNode !== undefined && this.cachedPointerNode !== this.getPointerNode()) {\n      throw new Error('Debug: The cached pointer is incorrect and has not been invalidated');\n    }\n    var actualIndexStack = this.getChunkPath(this.pointerChunk);\n    if (!actualIndexStack) {\n      throw new Error('Debug: The pointer chunk is not connected to the root');\n    }\n    if (!slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(this.pointerIndexStack, actualIndexStack)) {\n      throw new Error(\"Debug: The cached index stack [\".concat(this.pointerIndexStack.join(', '), \"] does not match the path of the pointer chunk [\").concat(actualIndexStack.join(', '), \"]\"));\n    }\n  }\n}\n\n/**\n * Traverse an array of children, providing helpers useful for reconciling the\n * children array with a chunk tree\n */\nclass ChildrenHelper {\n  constructor(editor, children) {\n    _defineProperty(this, \"editor\", void 0);\n    _defineProperty(this, \"children\", void 0);\n    /**\n     * Sparse array of Slate node keys, each index corresponding to an index in\n     * the children array\n     *\n     * Fetching the key for a Slate node is expensive, so we cache them here.\n     */\n    _defineProperty(this, \"cachedKeys\", void 0);\n    /**\n     * The index of the next node to be read in the children array\n     */\n    _defineProperty(this, \"pointerIndex\", void 0);\n    this.editor = editor;\n    this.children = children;\n    this.cachedKeys = new Array(children.length);\n    this.pointerIndex = 0;\n  }\n  /**\n   * Read a given number of nodes, advancing the pointer by that amount\n   */\n  read(n) {\n    // PERF: If only one child was requested (the most common case), use array\n    // indexing instead of slice\n    if (n === 1) {\n      return [this.children[this.pointerIndex++]];\n    }\n    var slicedChildren = this.remaining(n);\n    this.pointerIndex += n;\n    return slicedChildren;\n  }\n  /**\n   * Get the remaining children without advancing the pointer\n   *\n   * @param [maxChildren] Limit the number of children returned.\n   */\n  remaining(maxChildren) {\n    if (maxChildren === undefined) {\n      return this.children.slice(this.pointerIndex);\n    }\n    return this.children.slice(this.pointerIndex, this.pointerIndex + maxChildren);\n  }\n  /**\n   * Whether all children have been read\n   */\n  get reachedEnd() {\n    return this.pointerIndex >= this.children.length;\n  }\n  /**\n   * Determine whether a node with a given key appears in the unread part of the\n   * children array, and return its index relative to the current pointer if so\n   *\n   * Searching for the node object itself using indexOf is most efficient, but\n   * will fail to locate nodes that have been modified. In this case, nodes\n   * should be identified by their keys instead.\n   *\n   * Searching an array of keys using indexOf is very inefficient since fetching\n   * the keys for all children in advance is very slow. Insead, if the node\n   * search fails to return a value, fetch the keys of each remaining child one\n   * by one and compare it to the known key.\n   */\n  lookAhead(node, key) {\n    var elementResult = this.children.indexOf(node, this.pointerIndex);\n    if (elementResult > -1) return elementResult - this.pointerIndex;\n    for (var i = this.pointerIndex; i < this.children.length; i++) {\n      var candidateNode = this.children[i];\n      var candidateKey = this.findKey(candidateNode, i);\n      if (candidateKey === key) return i - this.pointerIndex;\n    }\n    return -1;\n  }\n  /**\n   * Convert an array of Slate nodes to an array of chunk leaves, each\n   * containing the node and its key\n   */\n  toChunkLeaves(nodes, startIndex) {\n    return nodes.map((node, i) => ({\n      type: 'leaf',\n      node,\n      key: this.findKey(node, startIndex + i),\n      index: startIndex + i\n    }));\n  }\n  /**\n   * Get the key for a Slate node, cached using the node's index\n   */\n  findKey(node, index) {\n    var cachedKey = this.cachedKeys[index];\n    if (cachedKey) return cachedKey;\n    var key = ReactEditor.findKey(this.editor, node);\n    this.cachedKeys[index] = key;\n    return key;\n  }\n}\n\n/**\n * Update the chunk tree to match the children array, inserting, removing and\n * updating differing nodes\n */\nvar reconcileChildren = (editor, _ref) => {\n  var {\n    chunkTree,\n    children,\n    chunkSize,\n    rerenderChildren = [],\n    onInsert,\n    onUpdate,\n    onIndexChange,\n    debug\n  } = _ref;\n  chunkTree.modifiedChunks.clear();\n  var chunkTreeHelper = new ChunkTreeHelper(chunkTree, {\n    chunkSize,\n    debug\n  });\n  var childrenHelper = new ChildrenHelper(editor, children);\n  var treeLeaf;\n  // Read leaves from the tree one by one, each one representing a single Slate\n  // node. Each leaf from the tree is compared to the current node in the\n  // children array to determine whether nodes have been inserted, removed or\n  // updated.\n  var _loop = function _loop() {\n    // Check where the tree node appears in the children array. In the most\n    // common case (where no insertions or removals have occurred), this will be\n    // 0. If the node has been removed, this will be -1. If new nodes have been\n    // inserted before the node, or if the node has been moved to a later\n    // position in the same children array, this will be a positive number.\n    var lookAhead = childrenHelper.lookAhead(treeLeaf.node, treeLeaf.key);\n    // If the node was moved, we want to remove it and insert it later, rather\n    // then re-inserting all intermediate nodes before it.\n    var wasMoved = lookAhead > 0 && chunkTree.movedNodeKeys.has(treeLeaf.key);\n    // If the tree leaf was moved or removed, remove it\n    if (lookAhead === -1 || wasMoved) {\n      chunkTreeHelper.remove();\n      return 1; // continue\n    }\n    // Get the matching Slate node and any nodes that may have been inserted\n    // prior to it. Insert these into the chunk tree.\n    var insertedChildrenStartIndex = childrenHelper.pointerIndex;\n    var insertedChildren = childrenHelper.read(lookAhead + 1);\n    var matchingChild = insertedChildren.pop();\n    if (insertedChildren.length) {\n      var _leavesToInsert = childrenHelper.toChunkLeaves(insertedChildren, insertedChildrenStartIndex);\n      chunkTreeHelper.insertBefore(_leavesToInsert);\n      insertedChildren.forEach((node, relativeIndex) => {\n        onInsert === null || onInsert === void 0 || onInsert(node, insertedChildrenStartIndex + relativeIndex);\n      });\n    }\n    var matchingChildIndex = childrenHelper.pointerIndex - 1;\n    // Make sure the chunk tree contains the most recent version of the Slate\n    // node\n    if (treeLeaf.node !== matchingChild) {\n      treeLeaf.node = matchingChild;\n      chunkTreeHelper.invalidateChunk();\n      onUpdate === null || onUpdate === void 0 || onUpdate(matchingChild, matchingChildIndex);\n    }\n    // Update the index if it has changed\n    if (treeLeaf.index !== matchingChildIndex) {\n      treeLeaf.index = matchingChildIndex;\n      onIndexChange === null || onIndexChange === void 0 || onIndexChange(matchingChild, matchingChildIndex);\n    }\n    // Manually invalidate chunks containing specific children that we want to\n    // re-render\n    if (rerenderChildren.includes(matchingChildIndex)) {\n      chunkTreeHelper.invalidateChunk();\n    }\n  };\n  while (treeLeaf = chunkTreeHelper.readLeaf()) {\n    if (_loop()) continue;\n  }\n  // If there are still Slate nodes remaining from the children array that were\n  // not matched to nodes in the tree, insert them at the end of the tree\n  if (!childrenHelper.reachedEnd) {\n    var remainingChildren = childrenHelper.remaining();\n    var leavesToInsert = childrenHelper.toChunkLeaves(remainingChildren, childrenHelper.pointerIndex);\n    // Move the pointer back to the final leaf in the tree, or the start of the\n    // tree if the tree is currently empty\n    chunkTreeHelper.returnToPreviousLeaf();\n    chunkTreeHelper.insertAfter(leavesToInsert);\n    remainingChildren.forEach((node, relativeIndex) => {\n      onInsert === null || onInsert === void 0 || onInsert(node, childrenHelper.pointerIndex + relativeIndex);\n    });\n  }\n  chunkTree.movedNodeKeys.clear();\n};\n\nfunction ownKeys$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar KEY_TO_CHUNK_TREE = new WeakMap();\n/**\n * Get or create the chunk tree for a Slate node\n *\n * If the reconcile option is provided, the chunk tree will be updated to\n * match the current children of the node. The children are chunked\n * automatically using the given chunk size.\n */\nvar getChunkTreeForNode = function getChunkTreeForNode(editor, node) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var key = ReactEditor.findKey(editor, node);\n  var chunkTree = KEY_TO_CHUNK_TREE.get(key);\n  if (!chunkTree) {\n    chunkTree = {\n      type: 'root',\n      movedNodeKeys: new Set(),\n      modifiedChunks: new Set(),\n      children: []\n    };\n    KEY_TO_CHUNK_TREE.set(key, chunkTree);\n  }\n  if (options.reconcile) {\n    reconcileChildren(editor, _objectSpread$1({\n      chunkTree,\n      children: node.children\n    }, options.reconcile));\n  }\n  return chunkTree;\n};\n\nvar defaultRenderChunk = _ref => {\n  var {\n    children\n  } = _ref;\n  return children;\n};\nvar ChunkAncestor = props => {\n  var {\n    root,\n    ancestor,\n    renderElement,\n    renderChunk = defaultRenderChunk\n  } = props;\n  return ancestor.children.map(chunkNode => {\n    if (chunkNode.type === 'chunk') {\n      var key = chunkNode.key.id;\n      var renderedChunk = renderChunk({\n        highest: ancestor === root,\n        lowest: chunkNode.children.some(c => c.type === 'leaf'),\n        attributes: {\n          'data-slate-chunk': true\n        },\n        children: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedChunk, {\n          root: root,\n          ancestor: chunkNode,\n          renderElement: renderElement,\n          renderChunk: renderChunk\n        })\n      });\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(react__WEBPACK_IMPORTED_MODULE_3__.Fragment, {\n        key: key\n      }, renderedChunk);\n    }\n    // Only blocks containing no inlines are chunked\n    var element = chunkNode.node;\n    return renderElement(element, chunkNode.index, chunkNode.key);\n  });\n};\nvar ChunkTree = ChunkAncestor;\nvar MemoizedChunk = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().memo(ChunkAncestor, (prev, next) => prev.root === next.root && prev.renderElement === next.renderElement && prev.renderChunk === next.renderChunk && !next.root.modifiedChunks.has(next.ancestor));\n\nvar ElementContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(null);\n/**\n * Get the current element.\n */\nvar useElement = () => {\n  var context = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(ElementContext);\n  if (!context) {\n    throw new Error('The `useElement` hook must be used inside `renderElement`.');\n  }\n  return context;\n};\n/**\n * Get the current element, or return null if not inside `renderElement`.\n */\nvar useElementIf = () => (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(ElementContext);\n\n/**\n * Children.\n */\nvar useChildren = props => {\n  var {\n    decorations,\n    node,\n    renderElement,\n    renderChunk,\n    renderPlaceholder,\n    renderText,\n    renderLeaf\n  } = props;\n  var editor = useSlateStatic();\n  slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_NODE_MAP_DIRTY.set(editor, false);\n  var isEditor = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isEditor(node);\n  var isBlock = !isEditor && slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && !editor.isInline(node);\n  var isLeafBlock = isBlock && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasInlines(editor, node);\n  var chunkSize = isLeafBlock ? null : editor.getChunkSize(node);\n  var chunking = !!chunkSize;\n  var {\n    decorationsByChild,\n    childrenToRedecorate\n  } = useDecorationsByChild(editor, node, decorations);\n  // Update the index and parent of each child.\n  // PERF: If chunking is enabled, this is done while traversing the chunk tree\n  // instead to eliminate unnecessary weak map operations.\n  if (!chunking) {\n    node.children.forEach((n, i) => {\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_INDEX.set(n, i);\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_PARENT.set(n, node);\n    });\n  }\n  var renderElementComponent = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((n, i, cachedKey) => {\n    var key = cachedKey !== null && cachedKey !== void 0 ? cachedKey : ReactEditor.findKey(editor, n);\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ElementContext.Provider, {\n      key: \"provider-\".concat(key.id),\n      value: n\n    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedElement, {\n      decorations: decorationsByChild[i],\n      element: n,\n      key: key.id,\n      renderElement: renderElement,\n      renderChunk: renderChunk,\n      renderPlaceholder: renderPlaceholder,\n      renderLeaf: renderLeaf,\n      renderText: renderText\n    }));\n  }, [editor, decorationsByChild, renderElement, renderChunk, renderPlaceholder, renderLeaf, renderText]);\n  var renderTextComponent = (n, i) => {\n    var key = ReactEditor.findKey(editor, n);\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedText, {\n      decorations: decorationsByChild[i],\n      key: key.id,\n      isLast: i === node.children.length - 1,\n      parent: node,\n      renderPlaceholder: renderPlaceholder,\n      renderLeaf: renderLeaf,\n      renderText: renderText,\n      text: n\n    });\n  };\n  if (!chunking) {\n    return node.children.map((n, i) => slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText(n) ? renderTextComponent(n, i) : renderElementComponent(n, i));\n  }\n  var chunkTree = getChunkTreeForNode(editor, node, {\n    reconcile: {\n      chunkSize,\n      rerenderChildren: childrenToRedecorate,\n      onInsert: (n, i) => {\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_INDEX.set(n, i);\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_PARENT.set(n, node);\n      },\n      onUpdate: (n, i) => {\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_INDEX.set(n, i);\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_PARENT.set(n, node);\n      },\n      onIndexChange: (n, i) => {\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_INDEX.set(n, i);\n      }\n    }\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ChunkTree, {\n    root: chunkTree,\n    ancestor: chunkTree,\n    renderElement: renderElementComponent,\n    renderChunk: renderChunk\n  });\n};\nvar useDecorationsByChild = (editor, node, decorations) => {\n  var decorationsByChild = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.splitDecorationsByChild)(editor, node, decorations);\n  // The value we return is a mutable array of `DecoratedRange[]` arrays. This\n  // lets us avoid passing an immutable array of decorations for each child into\n  // `ChunkTree` using props. Each `DecoratedRange[]` is only updated if the\n  // decorations at that index have changed, which speeds up the equality check\n  // for the `decorations` prop in the memoized `Element` and `Text` components.\n  var mutableDecorationsByChild = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(decorationsByChild).current;\n  // Track the list of child indices whose decorations have changed, so that we\n  // can tell the chunk tree to re-render these children.\n  var childrenToRedecorate = [];\n  // Resize the mutable array to match the latest result\n  mutableDecorationsByChild.length = decorationsByChild.length;\n  for (var i = 0; i < decorationsByChild.length; i++) {\n    var _mutableDecorationsBy;\n    var _decorations = decorationsByChild[i];\n    var previousDecorations = (_mutableDecorationsBy = mutableDecorationsByChild[i]) !== null && _mutableDecorationsBy !== void 0 ? _mutableDecorationsBy : null;\n    if (!(0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isElementDecorationsEqual)(previousDecorations, _decorations)) {\n      mutableDecorationsByChild[i] = _decorations;\n      childrenToRedecorate.push(i);\n    }\n  }\n  return {\n    decorationsByChild: mutableDecorationsByChild,\n    childrenToRedecorate\n  };\n};\n\n/**\n * A React context for sharing the `readOnly` state of the editor.\n */\nvar ReadOnlyContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(false);\n/**\n * Get the current `readOnly` state of the editor.\n */\nvar useReadOnly = () => {\n  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(ReadOnlyContext);\n};\n\n/**\n * A React context for sharing the editor selector context in a way to control\n * re-renders.\n */\nvar SlateSelectorContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)({});\nvar refEquality = (a, b) => a === b;\n/**\n * Use redux style selectors to prevent re-rendering on every keystroke.\n *\n * Bear in mind re-rendering can only prevented if the returned value is a value\n * type or for reference types (e.g. objects and arrays) add a custom equality\n * function.\n *\n * If `selector` is memoized using `useCallback`, then it will only be called\n * when it or the editor state changes. Otherwise, `selector` will be called\n * every time the component renders.\n *\n * @example\n * const isSelectionActive = useSlateSelector(editor => Boolean(editor.selection))\n */\nfunction useSlateSelector(selector) {\n  var equalityFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : refEquality;\n  var {\n    deferred\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var context = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SlateSelectorContext);\n  if (!context) {\n    throw new Error(\"The `useSlateSelector` hook must be used inside the <Slate> component's context.\");\n  }\n  var {\n    addEventListener\n  } = context;\n  var editor = useSlateStatic();\n  var genericSelector = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => selector(editor), [editor, selector]);\n  var [selectedState, update] = useGenericSelector(genericSelector, equalityFn);\n  useIsomorphicLayoutEffect(() => {\n    var unsubscribe = addEventListener(update, {\n      deferred\n    });\n    update();\n    return unsubscribe;\n  }, [addEventListener, update, deferred]);\n  return selectedState;\n}\n/**\n * Create selector context with editor updating on every editor change\n */\nfunction useSelectorContext() {\n  var eventListeners = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(new Set());\n  var deferredEventListeners = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(new Set());\n  var onChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => {\n    eventListeners.current.forEach(listener => listener());\n  }, []);\n  var flushDeferred = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => {\n    deferredEventListeners.current.forEach(listener => listener());\n    deferredEventListeners.current.clear();\n  }, []);\n  var addEventListener = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(function (callbackProp) {\n    var {\n      deferred = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var callback = deferred ? () => deferredEventListeners.current.add(callbackProp) : callbackProp;\n    eventListeners.current.add(callback);\n    return () => {\n      eventListeners.current.delete(callback);\n    };\n  }, []);\n  var selectorContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => ({\n    addEventListener,\n    flushDeferred\n  }), [addEventListener, flushDeferred]);\n  return {\n    selectorContext,\n    onChange\n  };\n}\nfunction useFlushDeferredSelectorsOnRender() {\n  var {\n    flushDeferred\n  } = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SlateSelectorContext);\n  useIsomorphicLayoutEffect(flushDeferred);\n}\n\n/**\n * Get the current editor object and re-render whenever it changes.\n */\nvar useSlate = () => {\n  var {\n    addEventListener\n  } = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SlateSelectorContext);\n  var [, forceRender] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useReducer)(s => s + 1, 0);\n  if (!addEventListener) {\n    throw new Error(\"The `useSlate` hook must be used inside the <Slate> component's context.\");\n  }\n  useIsomorphicLayoutEffect(() => addEventListener(forceRender), [addEventListener]);\n  return useSlateStatic();\n};\nvar EDITOR_TO_V = new WeakMap();\nvar getEditorVersionRef = editor => {\n  var v = EDITOR_TO_V.get(editor);\n  if (v) {\n    return v;\n  }\n  v = {\n    current: 0\n  };\n  EDITOR_TO_V.set(editor, v);\n  // Register the `onChange` handler exactly once per editor\n  var {\n    onChange\n  } = editor;\n  editor.onChange = options => {\n    v.current++;\n    onChange(options);\n  };\n  return v;\n};\n/**\n * Get the current editor object and its version, which increments on every\n * change.\n *\n * @deprecated The `v` counter is no longer used except for this hook, and may\n * be removed in a future version.\n */\nvar useSlateWithV = () => {\n  var editor = useSlate();\n  var vRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => getEditorVersionRef(editor), [editor]);\n  return {\n    editor,\n    v: vRef.current\n  };\n};\n\nfunction useTrackUserInput() {\n  var editor = useSlateStatic();\n  var receivedUserInput = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);\n  var animationFrameIdRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(0);\n  var onUserInput = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => {\n    if (receivedUserInput.current) {\n      return;\n    }\n    receivedUserInput.current = true;\n    var window = ReactEditor.getWindow(editor);\n    window.cancelAnimationFrame(animationFrameIdRef.current);\n    animationFrameIdRef.current = window.requestAnimationFrame(() => {\n      receivedUserInput.current = false;\n    });\n  }, [editor]);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => () => cancelAnimationFrame(animationFrameIdRef.current), []);\n  return {\n    receivedUserInput,\n    onUserInput\n  };\n}\n\nvar createRestoreDomManager = (editor, receivedUserInput) => {\n  var bufferedMutations = [];\n  var clear = () => {\n    bufferedMutations = [];\n  };\n  var registerMutations = mutations => {\n    if (!receivedUserInput.current) {\n      return;\n    }\n    var trackedMutations = mutations.filter(mutation => (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isTrackedMutation)(editor, mutation, mutations));\n    bufferedMutations.push(...trackedMutations);\n  };\n  function restoreDOM() {\n    if (bufferedMutations.length > 0) {\n      bufferedMutations.reverse().forEach(mutation => {\n        if (mutation.type === 'characterData') {\n          // We don't want to restore the DOM for characterData mutations\n          // because this interrupts the composition.\n          return;\n        }\n        mutation.removedNodes.forEach(node => {\n          mutation.target.insertBefore(node, mutation.nextSibling);\n        });\n        mutation.addedNodes.forEach(node => {\n          mutation.target.removeChild(node);\n        });\n      });\n      // Clear buffered mutations to ensure we don't undo them twice\n      clear();\n    }\n  }\n  return {\n    registerMutations,\n    restoreDOM,\n    clear\n  };\n};\n\nvar MUTATION_OBSERVER_CONFIG = {\n  subtree: true,\n  childList: true,\n  characterData: true,\n  characterDataOldValue: true\n};\n// We have to use a class component here since we rely on `getSnapshotBeforeUpdate` which has no FC equivalent\n// to run code synchronously immediately before react commits the component update to the DOM.\nclass RestoreDOMComponent extends react__WEBPACK_IMPORTED_MODULE_3__.Component {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"context\", null);\n    _defineProperty(this, \"manager\", null);\n    _defineProperty(this, \"mutationObserver\", null);\n  }\n  observe() {\n    var _this$mutationObserve;\n    var {\n      node\n    } = this.props;\n    if (!node.current) {\n      throw new Error('Failed to attach MutationObserver, `node` is undefined');\n    }\n    (_this$mutationObserve = this.mutationObserver) === null || _this$mutationObserve === void 0 || _this$mutationObserve.observe(node.current, MUTATION_OBSERVER_CONFIG);\n  }\n  componentDidMount() {\n    var {\n      receivedUserInput\n    } = this.props;\n    var editor = this.context;\n    this.manager = createRestoreDomManager(editor, receivedUserInput);\n    this.mutationObserver = new MutationObserver(this.manager.registerMutations);\n    this.observe();\n  }\n  getSnapshotBeforeUpdate() {\n    var _this$mutationObserve2, _this$mutationObserve3, _this$manager2;\n    var pendingMutations = (_this$mutationObserve2 = this.mutationObserver) === null || _this$mutationObserve2 === void 0 ? void 0 : _this$mutationObserve2.takeRecords();\n    if (pendingMutations !== null && pendingMutations !== void 0 && pendingMutations.length) {\n      var _this$manager;\n      (_this$manager = this.manager) === null || _this$manager === void 0 || _this$manager.registerMutations(pendingMutations);\n    }\n    (_this$mutationObserve3 = this.mutationObserver) === null || _this$mutationObserve3 === void 0 || _this$mutationObserve3.disconnect();\n    (_this$manager2 = this.manager) === null || _this$manager2 === void 0 || _this$manager2.restoreDOM();\n    return null;\n  }\n  componentDidUpdate() {\n    var _this$manager3;\n    (_this$manager3 = this.manager) === null || _this$manager3 === void 0 || _this$manager3.clear();\n    this.observe();\n  }\n  componentWillUnmount() {\n    var _this$mutationObserve4;\n    (_this$mutationObserve4 = this.mutationObserver) === null || _this$mutationObserve4 === void 0 || _this$mutationObserve4.disconnect();\n  }\n  render() {\n    return this.props.children;\n  }\n}\n_defineProperty(RestoreDOMComponent, \"contextType\", EditorContext);\nvar RestoreDOM = slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID ? RestoreDOMComponent : _ref => {\n  var {\n    children\n  } = _ref;\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement((react__WEBPACK_IMPORTED_MODULE_3___default().Fragment), null, children);\n};\n\n/**\n * A React context for sharing the `composing` state of the editor.\n */\nvar ComposingContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(false);\n/**\n * Get the current `composing` state of the editor.\n */\nvar useComposing = () => {\n  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(ComposingContext);\n};\n\nvar _excluded$1 = [\"autoFocus\", \"decorate\", \"onDOMBeforeInput\", \"placeholder\", \"readOnly\", \"renderElement\", \"renderChunk\", \"renderLeaf\", \"renderText\", \"renderPlaceholder\", \"scrollSelectionIntoView\", \"style\", \"as\", \"disableDefaultStyles\"],\n  _excluded2 = [\"text\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar Children = props => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement((react__WEBPACK_IMPORTED_MODULE_3___default().Fragment), null, useChildren(props));\n/**\n * Editable.\n */\nvar Editable = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)((props, forwardedRef) => {\n  var defaultRenderPlaceholder = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(props => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(DefaultPlaceholder, _objectSpread({}, props)), []);\n  var {\n      autoFocus,\n      decorate = defaultDecorate,\n      onDOMBeforeInput: propsOnDOMBeforeInput,\n      placeholder,\n      readOnly = false,\n      renderElement,\n      renderChunk,\n      renderLeaf,\n      renderText,\n      renderPlaceholder = defaultRenderPlaceholder,\n      scrollSelectionIntoView = defaultScrollSelectionIntoView,\n      style: userStyle = {},\n      as: Component = 'div',\n      disableDefaultStyles = false\n    } = props,\n    attributes = _objectWithoutProperties(props, _excluded$1);\n  var editor = useSlate();\n  // Rerender editor when composition status changed\n  var [isComposing, setIsComposing] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n  var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n  var deferredOperations = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)([]);\n  var [placeholderHeight, setPlaceholderHeight] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)();\n  var processing = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);\n  var {\n    onUserInput,\n    receivedUserInput\n  } = useTrackUserInput();\n  var [, forceRender] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useReducer)(s => s + 1, 0);\n  slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_FORCE_RENDER.set(editor, forceRender);\n  // Update internal state on each render.\n  slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_READ_ONLY.set(editor, readOnly);\n  // Keep track of some state for the event handler logic.\n  var state = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => ({\n    isDraggingInternally: false,\n    isUpdatingSelection: false,\n    latestElement: null,\n    hasMarkPlaceholder: false\n  }), []);\n  // The autoFocus TextareaHTMLAttribute doesn't do anything on a div, so it\n  // needs to be manually focused.\n  //\n  // If this stops working in Firefox, make sure nothing is causing this\n  // component to re-render during the initial mount. If the DOM selection is\n  // set by `useIsomorphicLayoutEffect` before `onDOMSelectionChange` updates\n  // `editor.selection`, the DOM selection can be removed accidentally.\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    if (ref.current && autoFocus) {\n      ref.current.focus();\n    }\n  }, [autoFocus]);\n  /**\n   * The AndroidInputManager object has a cyclical dependency on onDOMSelectionChange\n   *\n   * It is defined as a reference to simplify hook dependencies and clarify that\n   * it needs to be initialized.\n   */\n  var androidInputManagerRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();\n  // Listen on the native `selectionchange` event to be able to update any time\n  // the selection changes. This is required because React's `onSelect` is leaky\n  // and non-standard so it doesn't fire until after a selection has been\n  // released. This causes issues in situations where another change happens\n  // while a selection is being dragged.\n  var onDOMSelectionChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => lodash_throttle__WEBPACK_IMPORTED_MODULE_2___default()(() => {\n    if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_NODE_MAP_DIRTY.get(editor)) {\n      onDOMSelectionChange();\n      return;\n    }\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root = el.getRootNode();\n    if (!processing.current && slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_WEBKIT && root instanceof ShadowRoot) {\n      processing.current = true;\n      var active = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.getActiveElement)();\n      if (active) {\n        document.execCommand('indent');\n      } else {\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.deselect(editor);\n      }\n      processing.current = false;\n      return;\n    }\n    var androidInputManager = androidInputManagerRef.current;\n    if ((slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID || !ReactEditor.isComposing(editor)) && (!state.isUpdatingSelection || androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing()) && !state.isDraggingInternally) {\n      var _root = ReactEditor.findDocumentOrShadowRoot(editor);\n      var {\n        activeElement\n      } = _root;\n      var _el = ReactEditor.toDOMNode(editor, editor);\n      var domSelection = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.getSelection)(_root);\n      if (activeElement === _el) {\n        state.latestElement = activeElement;\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_FOCUSED.set(editor, true);\n      } else {\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_FOCUSED.delete(editor);\n      }\n      if (!domSelection) {\n        return slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.deselect(editor);\n      }\n      var {\n        anchorNode,\n        focusNode\n      } = domSelection;\n      var anchorNodeSelectable = ReactEditor.hasEditableTarget(editor, anchorNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, anchorNode);\n      var focusNodeInEditor = ReactEditor.hasTarget(editor, focusNode);\n      if (anchorNodeSelectable && focusNodeInEditor) {\n        var range = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: false,\n          suppressThrow: true\n        });\n        if (range) {\n          if (!ReactEditor.isComposing(editor) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.hasPendingChanges()) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing())) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n          } else {\n            androidInputManager === null || androidInputManager === void 0 || androidInputManager.handleUserSelect(range);\n          }\n        }\n      }\n      // Deselect the editor if the dom selection is not selectable in readonly mode\n      if (readOnly && (!anchorNodeSelectable || !focusNodeInEditor)) {\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.deselect(editor);\n      }\n    }\n  }, 100), [editor, readOnly, state]);\n  var scheduleOnDOMSelectionChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default()(onDOMSelectionChange, 0), [onDOMSelectionChange]);\n  androidInputManagerRef.current = useAndroidInputManager({\n    node: ref,\n    onDOMSelectionChange,\n    scheduleOnDOMSelectionChange\n  });\n  useIsomorphicLayoutEffect(() => {\n    var _androidInputManagerR, _androidInputManagerR2;\n    // Update element-related weak maps with the DOM element ref.\n    var window;\n    if (ref.current && (window = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.getDefaultView)(ref.current))) {\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_WINDOW.set(editor, window);\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_ELEMENT.set(editor, ref.current);\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_ELEMENT.set(editor, ref.current);\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.ELEMENT_TO_NODE.set(ref.current, editor);\n    } else {\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_ELEMENT.delete(editor);\n    }\n    // Make sure the DOM selection state is in sync.\n    var {\n      selection\n    } = editor;\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    var domSelection = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.getSelection)(root);\n    if (!domSelection || !ReactEditor.isFocused(editor) || (_androidInputManagerR = androidInputManagerRef.current) !== null && _androidInputManagerR !== void 0 && _androidInputManagerR.hasPendingAction()) {\n      return;\n    }\n    var setDomSelection = forceChange => {\n      var hasDomSelection = domSelection.type !== 'None';\n      // If the DOM selection is properly unset, we're done.\n      if (!selection && !hasDomSelection) {\n        return;\n      }\n      // Get anchorNode and focusNode\n      var focusNode = domSelection.focusNode;\n      var anchorNode;\n      // COMPAT: In firefox the normal selection way does not work\n      // (https://github.com/ianstormtaylor/slate/pull/5486#issue-1820720223)\n      if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_FIREFOX && domSelection.rangeCount > 1) {\n        var firstRange = domSelection.getRangeAt(0);\n        var lastRange = domSelection.getRangeAt(domSelection.rangeCount - 1);\n        // Right to left\n        if (firstRange.startContainer === focusNode) {\n          anchorNode = lastRange.endContainer;\n        } else {\n          // Left to right\n          anchorNode = firstRange.startContainer;\n        }\n      } else {\n        anchorNode = domSelection.anchorNode;\n      }\n      // verify that the dom selection is in the editor\n      var editorElement = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_ELEMENT.get(editor);\n      var hasDomSelectionInEditor = false;\n      if (editorElement.contains(anchorNode) && editorElement.contains(focusNode)) {\n        hasDomSelectionInEditor = true;\n      }\n      // If the DOM selection is in the editor and the editor selection is already correct, we're done.\n      if (hasDomSelection && hasDomSelectionInEditor && selection && !forceChange) {\n        var slateRange = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: true,\n          // domSelection is not necessarily a valid Slate range\n          // (e.g. when clicking on contentEditable:false element)\n          suppressThrow: true\n        });\n        if (slateRange && slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(slateRange, selection)) {\n          var _anchorNode;\n          if (!state.hasMarkPlaceholder) {\n            return;\n          }\n          // Ensure selection is inside the mark placeholder\n          if ((_anchorNode = anchorNode) !== null && _anchorNode !== void 0 && (_anchorNode = _anchorNode.parentElement) !== null && _anchorNode !== void 0 && _anchorNode.hasAttribute('data-slate-mark-placeholder')) {\n            return;\n          }\n        }\n      }\n      // when <Editable/> is being controlled through external value\n      // then its children might just change - DOM responds to it on its own\n      // but Slate's value is not being updated through any operation\n      // and thus it doesn't transform selection on its own\n      if (selection && !ReactEditor.hasRange(editor, selection)) {\n        editor.selection = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: false,\n          suppressThrow: true\n        });\n        return;\n      }\n      // Otherwise the DOM selection is out of sync, so update it.\n      state.isUpdatingSelection = true;\n      var newDomRange = null;\n      try {\n        newDomRange = selection && ReactEditor.toDOMRange(editor, selection);\n      } catch (e) {\n        // Ignore, dom and state might be out of sync\n      }\n      if (newDomRange) {\n        if (ReactEditor.isComposing(editor) && !slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID) {\n          domSelection.collapseToEnd();\n        } else if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isBackward(selection)) {\n          domSelection.setBaseAndExtent(newDomRange.endContainer, newDomRange.endOffset, newDomRange.startContainer, newDomRange.startOffset);\n        } else {\n          domSelection.setBaseAndExtent(newDomRange.startContainer, newDomRange.startOffset, newDomRange.endContainer, newDomRange.endOffset);\n        }\n        scrollSelectionIntoView(editor, newDomRange);\n      } else {\n        domSelection.removeAllRanges();\n      }\n      return newDomRange;\n    };\n    // In firefox if there is more then 1 range and we call setDomSelection we remove the ability to select more cells in a table\n    if (domSelection.rangeCount <= 1) {\n      setDomSelection();\n    }\n    var ensureSelection = ((_androidInputManagerR2 = androidInputManagerRef.current) === null || _androidInputManagerR2 === void 0 ? void 0 : _androidInputManagerR2.isFlushing()) === 'action';\n    if (!slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID || !ensureSelection) {\n      setTimeout(() => {\n        state.isUpdatingSelection = false;\n      });\n      return;\n    }\n    var timeoutId = null;\n    var animationFrameId = requestAnimationFrame(() => {\n      if (ensureSelection) {\n        var ensureDomSelection = forceChange => {\n          try {\n            var el = ReactEditor.toDOMNode(editor, editor);\n            el.focus();\n            setDomSelection(forceChange);\n          } catch (e) {\n            // Ignore, dom and state might be out of sync\n          }\n        };\n        // Compat: Android IMEs try to force their selection by manually re-applying it even after we set it.\n        // This essentially would make setting the slate selection during an update meaningless, so we force it\n        // again here. We can't only do it in the setTimeout after the animation frame since that would cause a\n        // visible flicker.\n        ensureDomSelection();\n        timeoutId = setTimeout(() => {\n          // COMPAT: While setting the selection in an animation frame visually correctly sets the selection,\n          // it doesn't update GBoards spellchecker state. We have to manually trigger a selection change after\n          // the animation frame to ensure it displays the correct state.\n          ensureDomSelection(true);\n          state.isUpdatingSelection = false;\n        });\n      }\n    });\n    return () => {\n      cancelAnimationFrame(animationFrameId);\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    };\n  });\n  // Listen on the native `beforeinput` event to get real \"Level 2\" events. This\n  // is required because React's `beforeinput` is fake and never really attaches\n  // to the real event sadly. (2019/11/01)\n  // https://github.com/facebook/react/issues/11211\n  var onDOMBeforeInput = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n    handleNativeHistoryEvents(editor, event);\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root = el.getRootNode();\n    if (processing !== null && processing !== void 0 && processing.current && slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_WEBKIT && root instanceof ShadowRoot) {\n      var ranges = event.getTargetRanges();\n      var range = ranges[0];\n      var newRange = new window.Range();\n      newRange.setStart(range.startContainer, range.startOffset);\n      newRange.setEnd(range.endContainer, range.endOffset);\n      // Translate the DOM Range into a Slate Range\n      var slateRange = ReactEditor.toSlateRange(editor, newRange, {\n        exactMatch: false,\n        suppressThrow: false\n      });\n      slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, slateRange);\n      event.preventDefault();\n      event.stopImmediatePropagation();\n      return;\n    }\n    onUserInput();\n    if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isDOMEventHandled(event, propsOnDOMBeforeInput)) {\n      var _EDITOR_TO_USER_SELEC;\n      // COMPAT: BeforeInput events aren't cancelable on android, so we have to handle them differently using the android input manager.\n      if (androidInputManagerRef.current) {\n        return androidInputManagerRef.current.handleDOMBeforeInput(event);\n      }\n      // Some IMEs/Chrome extensions like e.g. Grammarly set the selection immediately before\n      // triggering a `beforeinput` expecting the change to be applied to the immediately before\n      // set selection.\n      scheduleOnDOMSelectionChange.flush();\n      onDOMSelectionChange.flush();\n      var {\n        selection\n      } = editor;\n      var {\n        inputType: type\n      } = event;\n      var data = event.dataTransfer || event.data || undefined;\n      var isCompositionChange = type === 'insertCompositionText' || type === 'deleteCompositionText';\n      // COMPAT: use composition change events as a hint to where we should insert\n      // composition text if we aren't composing to work around https://github.com/ianstormtaylor/slate/issues/5038\n      if (isCompositionChange && ReactEditor.isComposing(editor)) {\n        return;\n      }\n      var native = false;\n      if (type === 'insertText' && selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection) &&\n      // Only use native character insertion for single characters a-z or space for now.\n      // Long-press events (hold a + press 4 = ä) to choose a special character otherwise\n      // causes duplicate inserts.\n      event.data && event.data.length === 1 && /[a-z ]/i.test(event.data) &&\n      // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405\n      // When there is an inline element, e.g. a link, and you select\n      // right after it (the start of the next node).\n      selection.anchor.offset !== 0) {\n        native = true;\n        // Skip native if there are marks, as\n        // `insertText` will insert a node, not just text.\n        if (editor.marks) {\n          native = false;\n        }\n        // If the NODE_MAP is dirty, we can't trust the selection anchor (eg ReactEditor.toDOMPoint)\n        if (!slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_NODE_MAP_DIRTY.get(editor)) {\n          var _node$parentElement, _window$getComputedSt;\n          // Chrome also has issues correctly editing the end of anchor elements: https://bugs.chromium.org/p/chromium/issues/detail?id=1259100\n          // Therefore we don't allow native events to insert text at the end of anchor nodes.\n          var {\n            anchor\n          } = selection;\n          var [node, offset] = ReactEditor.toDOMPoint(editor, anchor);\n          var anchorNode = (_node$parentElement = node.parentElement) === null || _node$parentElement === void 0 ? void 0 : _node$parentElement.closest('a');\n          var _window = ReactEditor.getWindow(editor);\n          if (native && anchorNode && ReactEditor.hasDOMNode(editor, anchorNode)) {\n            var _lastText$textContent;\n            // Find the last text node inside the anchor.\n            var lastText = _window === null || _window === void 0 ? void 0 : _window.document.createTreeWalker(anchorNode, NodeFilter.SHOW_TEXT).lastChild();\n            if (lastText === node && ((_lastText$textContent = lastText.textContent) === null || _lastText$textContent === void 0 ? void 0 : _lastText$textContent.length) === offset) {\n              native = false;\n            }\n          }\n          // Chrome has issues with the presence of tab characters inside elements with whiteSpace = 'pre'\n          // causing abnormal insert behavior: https://bugs.chromium.org/p/chromium/issues/detail?id=1219139\n          if (native && node.parentElement && (_window === null || _window === void 0 || (_window$getComputedSt = _window.getComputedStyle(node.parentElement)) === null || _window$getComputedSt === void 0 ? void 0 : _window$getComputedSt.whiteSpace) === 'pre') {\n            var block = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n              at: anchor.path,\n              match: n => slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, n)\n            });\n            if (block && slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(block[0]).includes('\\t')) {\n              native = false;\n            }\n          }\n        }\n      }\n      // COMPAT: For the deleting forward/backward input types we don't want\n      // to change the selection because it is the range that will be deleted,\n      // and those commands determine that for themselves.\n      // If the NODE_MAP is dirty, we can't trust the selection anchor (eg ReactEditor.toDOMPoint via ReactEditor.toSlateRange)\n      if ((!type.startsWith('delete') || type.startsWith('deleteBy')) && !slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_NODE_MAP_DIRTY.get(editor)) {\n        var [targetRange] = event.getTargetRanges();\n        if (targetRange) {\n          var _range = ReactEditor.toSlateRange(editor, targetRange, {\n            exactMatch: false,\n            suppressThrow: false\n          });\n          if (!selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(selection, _range)) {\n            native = false;\n            var selectionRef = !isCompositionChange && editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.rangeRef(editor, editor.selection);\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, _range);\n            if (selectionRef) {\n              slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_SELECTION.set(editor, selectionRef);\n            }\n          }\n        }\n      }\n      // Composition change types occur while a user is composing text and can't be\n      // cancelled. Let them through and wait for the composition to end.\n      if (isCompositionChange) {\n        return;\n      }\n      if (!native) {\n        event.preventDefault();\n      }\n      // COMPAT: If the selection is expanded, even if the command seems like\n      // a delete forward/backward command it should delete the selection.\n      if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection) && type.startsWith('delete')) {\n        var direction = type.endsWith('Backward') ? 'backward' : 'forward';\n        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n          direction\n        });\n        return;\n      }\n      switch (type) {\n        case 'deleteByComposition':\n        case 'deleteByCut':\n        case 'deleteByDrag':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor);\n            break;\n          }\n        case 'deleteContent':\n        case 'deleteContentForward':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor);\n            break;\n          }\n        case 'deleteContentBackward':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor);\n            break;\n          }\n        case 'deleteEntireSoftLine':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n        case 'deleteHardLineBackward':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n              unit: 'block'\n            });\n            break;\n          }\n        case 'deleteSoftLineBackward':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n        case 'deleteHardLineForward':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n              unit: 'block'\n            });\n            break;\n          }\n        case 'deleteSoftLineForward':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n        case 'deleteWordBackward':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n              unit: 'word'\n            });\n            break;\n          }\n        case 'deleteWordForward':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n              unit: 'word'\n            });\n            break;\n          }\n        case 'insertLineBreak':\n          slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertSoftBreak(editor);\n          break;\n        case 'insertParagraph':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertBreak(editor);\n            break;\n          }\n        case 'insertFromComposition':\n        case 'insertFromDrop':\n        case 'insertFromPaste':\n        case 'insertFromYank':\n        case 'insertReplacementText':\n        case 'insertText':\n          {\n            if (type === 'insertFromComposition') {\n              // COMPAT: in Safari, `compositionend` is dispatched after the\n              // `beforeinput` for \"insertFromComposition\". But if we wait for it\n              // then we will abort because we're still composing and the selection\n              // won't be updated properly.\n              // https://www.w3.org/TR/input-events-2/\n              if (ReactEditor.isComposing(editor)) {\n                setIsComposing(false);\n                slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_COMPOSING.set(editor, false);\n              }\n            }\n            // use a weak comparison instead of 'instanceof' to allow\n            // programmatic access of paste events coming from external windows\n            // like cypress where cy.window does not work realibly\n            if ((data === null || data === void 0 ? void 0 : data.constructor.name) === 'DataTransfer') {\n              ReactEditor.insertData(editor, data);\n            } else if (typeof data === 'string') {\n              // Only insertText operations use the native functionality, for now.\n              // Potentially expand to single character deletes, as well.\n              if (native) {\n                deferredOperations.current.push(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, data));\n              } else {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, data);\n              }\n            }\n            break;\n          }\n      }\n      // Restore the actual user section if nothing manually set it.\n      var toRestore = (_EDITOR_TO_USER_SELEC = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_SELECTION.get(editor)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_SELECTION.delete(editor);\n      if (toRestore && (!editor.selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(editor.selection, toRestore))) {\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, toRestore);\n      }\n    }\n  }, [editor, onDOMSelectionChange, onUserInput, propsOnDOMBeforeInput, readOnly, scheduleOnDOMSelectionChange]);\n  var callbackRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(node => {\n    if (node == null) {\n      onDOMSelectionChange.cancel();\n      scheduleOnDOMSelectionChange.cancel();\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_ELEMENT.delete(editor);\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_ELEMENT.delete(editor);\n      if (ref.current && slate_dom__WEBPACK_IMPORTED_MODULE_4__.HAS_BEFORE_INPUT_SUPPORT) {\n        // @ts-ignore The `beforeinput` event isn't recognized.\n        ref.current.removeEventListener('beforeinput', onDOMBeforeInput);\n      }\n    } else {\n      // Attach a native DOM event handler for `beforeinput` events, because React's\n      // built-in `onBeforeInput` is actually a leaky polyfill that doesn't expose\n      // real `beforeinput` events sadly... (2019/11/04)\n      // https://github.com/facebook/react/issues/11211\n      if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.HAS_BEFORE_INPUT_SUPPORT) {\n        // @ts-ignore The `beforeinput` event isn't recognized.\n        node.addEventListener('beforeinput', onDOMBeforeInput);\n      }\n    }\n    ref.current = node;\n    if (typeof forwardedRef === 'function') {\n      forwardedRef(node);\n    } else if (forwardedRef) {\n      forwardedRef.current = node;\n    }\n  }, [onDOMSelectionChange, scheduleOnDOMSelectionChange, editor, onDOMBeforeInput, forwardedRef]);\n  useIsomorphicLayoutEffect(() => {\n    var window = ReactEditor.getWindow(editor);\n    // COMPAT: In Chrome, `selectionchange` events can fire when <input> and\n    // <textarea> elements are appended to the DOM, causing\n    // `editor.selection` to be overwritten in some circumstances.\n    // (2025/01/16) https://issues.chromium.org/issues/389368412\n    var onSelectionChange = _ref => {\n      var {\n        target\n      } = _ref;\n      var targetElement = target instanceof HTMLElement ? target : null;\n      var targetTagName = targetElement === null || targetElement === void 0 ? void 0 : targetElement.tagName;\n      if (targetTagName === 'INPUT' || targetTagName === 'TEXTAREA') {\n        return;\n      }\n      scheduleOnDOMSelectionChange();\n    };\n    // Attach a native DOM event handler for `selectionchange`, because React's\n    // built-in `onSelect` handler doesn't fire for all selection changes. It's\n    // a leaky polyfill that only fires on keypresses or clicks. Instead, we\n    // want to fire for any change to the selection inside the editor.\n    // (2019/11/04) https://github.com/facebook/react/issues/5785\n    window.document.addEventListener('selectionchange', onSelectionChange);\n    // Listen for dragend and drop globally. In Firefox, if a drop handler\n    // initiates an operation that causes the originally dragged element to\n    // unmount, that element will not emit a dragend event. (2024/06/21)\n    var stoppedDragging = () => {\n      state.isDraggingInternally = false;\n    };\n    window.document.addEventListener('dragend', stoppedDragging);\n    window.document.addEventListener('drop', stoppedDragging);\n    return () => {\n      window.document.removeEventListener('selectionchange', onSelectionChange);\n      window.document.removeEventListener('dragend', stoppedDragging);\n      window.document.removeEventListener('drop', stoppedDragging);\n    };\n  }, [scheduleOnDOMSelectionChange, state]);\n  var decorations = decorate([editor, []]);\n  var decorateContext = useDecorateContext(decorate);\n  var showPlaceholder = placeholder && editor.children.length === 1 && Array.from(slate__WEBPACK_IMPORTED_MODULE_7__.Node.texts(editor)).length === 1 && slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(editor) === '' && !isComposing;\n  var placeHolderResizeHandler = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(placeholderEl => {\n    if (placeholderEl && showPlaceholder) {\n      var _placeholderEl$getBou;\n      setPlaceholderHeight((_placeholderEl$getBou = placeholderEl.getBoundingClientRect()) === null || _placeholderEl$getBou === void 0 ? void 0 : _placeholderEl$getBou.height);\n    } else {\n      setPlaceholderHeight(undefined);\n    }\n  }, [showPlaceholder]);\n  if (showPlaceholder) {\n    var start = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.start(editor, []);\n    decorations.push({\n      [slate_dom__WEBPACK_IMPORTED_MODULE_4__.PLACEHOLDER_SYMBOL]: true,\n      placeholder,\n      onPlaceholderResize: placeHolderResizeHandler,\n      anchor: start,\n      focus: start\n    });\n  }\n  var {\n    marks\n  } = editor;\n  state.hasMarkPlaceholder = false;\n  if (editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(editor.selection) && marks) {\n    var {\n      anchor\n    } = editor.selection;\n    var leaf = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, anchor.path);\n    var rest = _objectWithoutProperties(leaf, _excluded2);\n    // While marks isn't a 'complete' text, we can still use loose Text.equals\n    // here which only compares marks anyway.\n    if (!slate__WEBPACK_IMPORTED_MODULE_7__.Text.equals(leaf, marks, {\n      loose: true\n    })) {\n      state.hasMarkPlaceholder = true;\n      var unset = Object.fromEntries(Object.keys(rest).map(mark => [mark, null]));\n      decorations.push(_objectSpread(_objectSpread(_objectSpread({\n        [slate_dom__WEBPACK_IMPORTED_MODULE_4__.MARK_PLACEHOLDER_SYMBOL]: true\n      }, unset), marks), {}, {\n        anchor,\n        focus: anchor\n      }));\n    }\n  }\n  // Update EDITOR_TO_MARK_PLACEHOLDER_MARKS in setTimeout useEffect to ensure we don't set it\n  // before we receive the composition end event.\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    setTimeout(() => {\n      var {\n        selection\n      } = editor;\n      if (selection) {\n        var {\n          anchor: _anchor\n        } = selection;\n        var _text = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, _anchor.path);\n        // While marks isn't a 'complete' text, we can still use loose Text.equals\n        // here which only compares marks anyway.\n        if (marks && !slate__WEBPACK_IMPORTED_MODULE_7__.Text.equals(_text, marks, {\n          loose: true\n        })) {\n          slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_INSERTION_MARKS.set(editor, marks);\n          return;\n        }\n      }\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n    });\n  });\n  useFlushDeferredSelectorsOnRender();\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ReadOnlyContext.Provider, {\n    value: readOnly\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ComposingContext.Provider, {\n    value: isComposing\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(DecorateContext.Provider, {\n    value: decorateContext\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(RestoreDOM, {\n    node: ref,\n    receivedUserInput: receivedUserInput\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(Component, _objectSpread(_objectSpread({\n    role: readOnly ? undefined : 'textbox',\n    \"aria-multiline\": readOnly ? undefined : true\n  }, attributes), {}, {\n    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd\n    // have to use hacks to make these replacement-based features work.\n    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop\n    // mismatch warning app moves to browser. Pass-through consumer props when\n    // not CAN_USE_DOM (SSR) and default to falsy value\n    spellCheck: slate_dom__WEBPACK_IMPORTED_MODULE_4__.HAS_BEFORE_INPUT_SUPPORT || !slate_dom__WEBPACK_IMPORTED_MODULE_4__.CAN_USE_DOM ? attributes.spellCheck : false,\n    autoCorrect: slate_dom__WEBPACK_IMPORTED_MODULE_4__.HAS_BEFORE_INPUT_SUPPORT || !slate_dom__WEBPACK_IMPORTED_MODULE_4__.CAN_USE_DOM ? attributes.autoCorrect : 'false',\n    autoCapitalize: slate_dom__WEBPACK_IMPORTED_MODULE_4__.HAS_BEFORE_INPUT_SUPPORT || !slate_dom__WEBPACK_IMPORTED_MODULE_4__.CAN_USE_DOM ? attributes.autoCapitalize : 'false',\n    \"data-slate-editor\": true,\n    \"data-slate-node\": \"value\",\n    // explicitly set this\n    contentEditable: !readOnly,\n    // in some cases, a decoration needs access to the range / selection to decorate a text node,\n    // then you will select the whole text node when you select part the of text\n    // this magic zIndex=\"-1\" will fix it\n    zindex: -1,\n    suppressContentEditableWarning: true,\n    ref: callbackRef,\n    style: _objectSpread(_objectSpread({}, disableDefaultStyles ? {} : _objectSpread({\n      // Allow positioning relative to the editable element.\n      position: 'relative',\n      // Preserve adjacent whitespace and new lines.\n      whiteSpace: 'pre-wrap',\n      // Allow words to break if they are too long.\n      wordWrap: 'break-word'\n    }, placeholderHeight ? {\n      minHeight: placeholderHeight\n    } : {})), userStyle),\n    onBeforeInput: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n      // fall back to React's leaky polyfill instead just for it. It\n      // only works for the `insertText` input type.\n      if (!slate_dom__WEBPACK_IMPORTED_MODULE_4__.HAS_BEFORE_INPUT_SUPPORT && !readOnly && !isEventHandled(event, attributes.onBeforeInput) && ReactEditor.hasSelectableTarget(editor, event.target)) {\n        event.preventDefault();\n        if (!ReactEditor.isComposing(editor)) {\n          var _text2 = event.data;\n          slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, _text2);\n        }\n      }\n    }, [attributes.onBeforeInput, editor, readOnly]),\n    onInput: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (isEventHandled(event, attributes.onInput)) {\n        return;\n      }\n      if (androidInputManagerRef.current) {\n        androidInputManagerRef.current.handleInput();\n        return;\n      }\n      // Flush native operations, as native events will have propogated\n      // and we can correctly compare DOM text values in components\n      // to stop rendering, so that browser functions like autocorrect\n      // and spellcheck work as expected.\n      for (var op of deferredOperations.current) {\n        op();\n      }\n      deferredOperations.current = [];\n      // COMPAT: Since `beforeinput` doesn't fully `preventDefault`,\n      // there's a chance that content might be placed in the browser's undo stack.\n      // This means undo can be triggered even when the div is not focused,\n      // and it only triggers the input event for the node. (2024/10/09)\n      if (!ReactEditor.isFocused(editor)) {\n        handleNativeHistoryEvents(editor, event.nativeEvent);\n      }\n    }, [attributes.onInput, editor]),\n    onBlur: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (readOnly || state.isUpdatingSelection || !ReactEditor.hasSelectableTarget(editor, event.target) || isEventHandled(event, attributes.onBlur)) {\n        return;\n      }\n      // COMPAT: If the current `activeElement` is still the previous\n      // one, this is due to the window being blurred when the tab\n      // itself becomes unfocused, so we want to abort early to allow to\n      // editor to stay focused when the tab becomes focused again.\n      var root = ReactEditor.findDocumentOrShadowRoot(editor);\n      if (state.latestElement === root.activeElement) {\n        return;\n      }\n      var {\n        relatedTarget\n      } = event;\n      var el = ReactEditor.toDOMNode(editor, editor);\n      // COMPAT: The event should be ignored if the focus is returning\n      // to the editor from an embedded editable element (eg. an <input>\n      // element inside a void node).\n      if (relatedTarget === el) {\n        return;\n      }\n      // COMPAT: The event should be ignored if the focus is moving from\n      // the editor to inside a void node's spacer element.\n      if ((0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isDOMElement)(relatedTarget) && relatedTarget.hasAttribute('data-slate-spacer')) {\n        return;\n      }\n      // COMPAT: The event should be ignored if the focus is moving to a\n      // non- editable section of an element that isn't a void node (eg.\n      // a list item of the check list example).\n      if (relatedTarget != null && (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isDOMNode)(relatedTarget) && ReactEditor.hasDOMNode(editor, relatedTarget)) {\n        var node = ReactEditor.toSlateNode(editor, relatedTarget);\n        if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && !editor.isVoid(node)) {\n          return;\n        }\n      }\n      // COMPAT: Safari doesn't always remove the selection even if the content-\n      // editable element no longer has focus. Refer to:\n      // https://stackoverflow.com/questions/12353247/force-contenteditable-div-to-stop-accepting-input-after-it-loses-focus-under-web\n      if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_WEBKIT) {\n        var domSelection = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.getSelection)(root);\n        domSelection === null || domSelection === void 0 || domSelection.removeAllRanges();\n      }\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_FOCUSED.delete(editor);\n    }, [readOnly, state.isUpdatingSelection, state.latestElement, editor, attributes.onBlur]),\n    onClick: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onClick) && (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isDOMNode)(event.target)) {\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        var path = ReactEditor.findPath(editor, node);\n        // At this time, the Slate document may be arbitrarily different,\n        // because onClick handlers can change the document before we get here.\n        // Therefore we must check that this path actually exists,\n        // and that it still refers to the same node.\n        if (!slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasPath(editor, path) || slate__WEBPACK_IMPORTED_MODULE_7__.Node.get(editor, path) !== node) {\n          return;\n        }\n        if (event.detail === slate_dom__WEBPACK_IMPORTED_MODULE_4__.TRIPLE_CLICK && path.length >= 1) {\n          var blockPath = path;\n          if (!(slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, node))) {\n            var _block$;\n            var block = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n              match: n => slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, n),\n              at: path\n            });\n            blockPath = (_block$ = block === null || block === void 0 ? void 0 : block[1]) !== null && _block$ !== void 0 ? _block$ : path.slice(0, 1);\n          }\n          var range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, blockPath);\n          slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n          return;\n        }\n        if (readOnly) {\n          return;\n        }\n        var _start = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.start(editor, path);\n        var end = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.end(editor, path);\n        var startVoid = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n          at: _start\n        });\n        var endVoid = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n          at: end\n        });\n        if (startVoid && endVoid && slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(startVoid[1], endVoid[1])) {\n          var _range2 = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, _start);\n          slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, _range2);\n        }\n      }\n    }, [editor, attributes.onClick, readOnly]),\n    onCompositionEnd: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (ReactEditor.hasSelectableTarget(editor, event.target)) {\n        var _androidInputManagerR3;\n        if (ReactEditor.isComposing(editor)) {\n          Promise.resolve().then(() => {\n            setIsComposing(false);\n            slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_COMPOSING.set(editor, false);\n          });\n        }\n        (_androidInputManagerR3 = androidInputManagerRef.current) === null || _androidInputManagerR3 === void 0 || _androidInputManagerR3.handleCompositionEnd(event);\n        if (isEventHandled(event, attributes.onCompositionEnd) || slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID) {\n          return;\n        }\n        // COMPAT: In Chrome, `beforeinput` events for compositions\n        // aren't correct and never fire the \"insertFromComposition\"\n        // type that we need. So instead, insert whenever a composition\n        // ends since it will already have been committed to the DOM.\n        if (!slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_WEBKIT && !slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_FIREFOX_LEGACY && !slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_IOS && !slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_WECHATBROWSER && !slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_UC_MOBILE && event.data) {\n          var placeholderMarks = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);\n          slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n          // Ensure we insert text with the marks the user was actually seeing\n          if (placeholderMarks !== undefined) {\n            slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_MARKS.set(editor, editor.marks);\n            editor.marks = placeholderMarks;\n          }\n          slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, event.data);\n          var userMarks = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_MARKS.get(editor);\n          slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_MARKS.delete(editor);\n          if (userMarks !== undefined) {\n            editor.marks = userMarks;\n          }\n        }\n      }\n    }, [attributes.onCompositionEnd, editor]),\n    onCompositionUpdate: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionUpdate)) {\n        if (!ReactEditor.isComposing(editor)) {\n          setIsComposing(true);\n          slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_COMPOSING.set(editor, true);\n        }\n      }\n    }, [attributes.onCompositionUpdate, editor]),\n    onCompositionStart: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (ReactEditor.hasSelectableTarget(editor, event.target)) {\n        var _androidInputManagerR4;\n        (_androidInputManagerR4 = androidInputManagerRef.current) === null || _androidInputManagerR4 === void 0 || _androidInputManagerR4.handleCompositionStart(event);\n        if (isEventHandled(event, attributes.onCompositionStart) || slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID) {\n          return;\n        }\n        setIsComposing(true);\n        var {\n          selection\n        } = editor;\n        if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n          slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor);\n          return;\n        }\n      }\n    }, [attributes.onCompositionStart, editor]),\n    onCopy: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCopy) && !isDOMEventTargetInput(event)) {\n        event.preventDefault();\n        ReactEditor.setFragmentData(editor, event.clipboardData, 'copy');\n      }\n    }, [attributes.onCopy, editor]),\n    onCut: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (!readOnly && ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCut) && !isDOMEventTargetInput(event)) {\n        event.preventDefault();\n        ReactEditor.setFragmentData(editor, event.clipboardData, 'cut');\n        var {\n          selection\n        } = editor;\n        if (selection) {\n          if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor);\n          } else {\n            var node = slate__WEBPACK_IMPORTED_MODULE_7__.Node.parent(editor, selection.anchor.path);\n            if (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, node)) {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.delete(editor);\n            }\n          }\n        }\n      }\n    }, [readOnly, editor, attributes.onCut]),\n    onDragOver: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragOver)) {\n        // Only when the target is void, call `preventDefault` to signal\n        // that drops are allowed. Editable content is droppable by\n        // default, and calling `preventDefault` hides the cursor.\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, node)) {\n          event.preventDefault();\n        }\n      }\n    }, [attributes.onDragOver, editor]),\n    onDragStart: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragStart)) {\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        var path = ReactEditor.findPath(editor, node);\n        var voidMatch = slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, node) || slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n          at: path,\n          voids: true\n        });\n        // If starting a drag on a void node, make sure it is selected\n        // so that it shows up in the selection's fragment.\n        if (voidMatch) {\n          var range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, path);\n          slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n        }\n        state.isDraggingInternally = true;\n        ReactEditor.setFragmentData(editor, event.dataTransfer, 'drag');\n      }\n    }, [readOnly, editor, attributes.onDragStart, state]),\n    onDrop: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDrop)) {\n        event.preventDefault();\n        // Keep a reference to the dragged range before updating selection\n        var draggedRange = editor.selection;\n        // Find the range where the drop happened\n        var range = ReactEditor.findEventRange(editor, event);\n        var data = event.dataTransfer;\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n        if (state.isDraggingInternally) {\n          if (draggedRange && !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(draggedRange, range) && !slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n            at: range,\n            voids: true\n          })) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.delete(editor, {\n              at: draggedRange\n            });\n          }\n        }\n        ReactEditor.insertData(editor, data);\n        // When dragging from another source into the editor, it's possible\n        // that the current editor does not have focus.\n        if (!ReactEditor.isFocused(editor)) {\n          ReactEditor.focus(editor);\n        }\n      }\n    }, [readOnly, editor, attributes.onDrop, state]),\n    onDragEnd: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (!readOnly && state.isDraggingInternally && attributes.onDragEnd && ReactEditor.hasTarget(editor, event.target)) {\n        attributes.onDragEnd(event);\n      }\n    }, [readOnly, state, attributes, editor]),\n    onFocus: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (!readOnly && !state.isUpdatingSelection && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onFocus)) {\n        var el = ReactEditor.toDOMNode(editor, editor);\n        var root = ReactEditor.findDocumentOrShadowRoot(editor);\n        state.latestElement = root.activeElement;\n        // COMPAT: If the editor has nested editable elements, the focus\n        // can go to them. In Firefox, this must be prevented because it\n        // results in issues with keyboard navigation. (2017/03/30)\n        if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_FIREFOX && event.target !== el) {\n          el.focus();\n          return;\n        }\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_FOCUSED.set(editor, true);\n      }\n    }, [readOnly, state, editor, attributes.onFocus]),\n    onKeyDown: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target)) {\n        var _androidInputManagerR5;\n        (_androidInputManagerR5 = androidInputManagerRef.current) === null || _androidInputManagerR5 === void 0 || _androidInputManagerR5.handleKeyDown(event);\n        var {\n          nativeEvent\n        } = event;\n        // COMPAT: The composition end event isn't fired reliably in all browsers,\n        // so we sometimes might end up stuck in a composition state even though we\n        // aren't composing any more.\n        if (ReactEditor.isComposing(editor) && nativeEvent.isComposing === false) {\n          slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_COMPOSING.set(editor, false);\n          setIsComposing(false);\n        }\n        if (isEventHandled(event, attributes.onKeyDown) || ReactEditor.isComposing(editor)) {\n          return;\n        }\n        var {\n          selection\n        } = editor;\n        var element = editor.children[selection !== null ? selection.focus.path[0] : 0];\n        var isRTL = direction__WEBPACK_IMPORTED_MODULE_0___default()(slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(element)) === 'rtl';\n        // COMPAT: Since we prevent the default behavior on\n        // `beforeinput` events, the browser doesn't think there's ever\n        // any history stack to undo or redo, so we have to manage these\n        // hotkeys ourselves. (2019/11/06)\n        if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isRedo(nativeEvent)) {\n          event.preventDefault();\n          var maybeHistoryEditor = editor;\n          if (typeof maybeHistoryEditor.redo === 'function') {\n            maybeHistoryEditor.redo();\n          }\n          return;\n        }\n        if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isUndo(nativeEvent)) {\n          event.preventDefault();\n          var _maybeHistoryEditor = editor;\n          if (typeof _maybeHistoryEditor.undo === 'function') {\n            _maybeHistoryEditor.undo();\n          }\n          return;\n        }\n        // COMPAT: Certain browsers don't handle the selection updates\n        // properly. In Chrome, the selection isn't properly extended.\n        // And in Firefox, the selection isn't properly collapsed.\n        // (2017/10/17)\n        if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isMoveLineBackward(nativeEvent)) {\n          event.preventDefault();\n          slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n            unit: 'line',\n            reverse: true\n          });\n          return;\n        }\n        if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isMoveLineForward(nativeEvent)) {\n          event.preventDefault();\n          slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n            unit: 'line'\n          });\n          return;\n        }\n        if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isExtendLineBackward(nativeEvent)) {\n          event.preventDefault();\n          slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n            unit: 'line',\n            edge: 'focus',\n            reverse: true\n          });\n          return;\n        }\n        if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isExtendLineForward(nativeEvent)) {\n          event.preventDefault();\n          slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n            unit: 'line',\n            edge: 'focus'\n          });\n          return;\n        }\n        // COMPAT: If a void node is selected, or a zero-width text node\n        // adjacent to an inline is selected, we need to handle these\n        // hotkeys manually because browsers won't be able to skip over\n        // the void node with the zero-width space not being an empty\n        // string.\n        if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isMoveBackward(nativeEvent)) {\n          event.preventDefault();\n          if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection)) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n              reverse: !isRTL\n            });\n          } else {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.collapse(editor, {\n              edge: isRTL ? 'end' : 'start'\n            });\n          }\n          return;\n        }\n        if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isMoveForward(nativeEvent)) {\n          event.preventDefault();\n          if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection)) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n              reverse: isRTL\n            });\n          } else {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.collapse(editor, {\n              edge: isRTL ? 'start' : 'end'\n            });\n          }\n          return;\n        }\n        if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isMoveWordBackward(nativeEvent)) {\n          event.preventDefault();\n          if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.collapse(editor, {\n              edge: 'focus'\n            });\n          }\n          slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n            unit: 'word',\n            reverse: !isRTL\n          });\n          return;\n        }\n        if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isMoveWordForward(nativeEvent)) {\n          event.preventDefault();\n          if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.collapse(editor, {\n              edge: 'focus'\n            });\n          }\n          slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n            unit: 'word',\n            reverse: isRTL\n          });\n          return;\n        }\n        // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n        // fall back to guessing at the input intention for hotkeys.\n        // COMPAT: In iOS, some of these hotkeys are handled in the\n        if (!slate_dom__WEBPACK_IMPORTED_MODULE_4__.HAS_BEFORE_INPUT_SUPPORT) {\n          // We don't have a core behavior for these, but they change the\n          // DOM if we don't prevent them, so we have to.\n          if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isBold(nativeEvent) || slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isItalic(nativeEvent) || slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isTransposeCharacter(nativeEvent)) {\n            event.preventDefault();\n            return;\n          }\n          if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isSoftBreak(nativeEvent)) {\n            event.preventDefault();\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertSoftBreak(editor);\n            return;\n          }\n          if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isSplitBlock(nativeEvent)) {\n            event.preventDefault();\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertBreak(editor);\n            return;\n          }\n          if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isDeleteBackward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor);\n            }\n            return;\n          }\n          if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isDeleteForward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor);\n            }\n            return;\n          }\n          if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isDeleteLineBackward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                unit: 'line'\n              });\n            }\n            return;\n          }\n          if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isDeleteLineForward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                unit: 'line'\n              });\n            }\n            return;\n          }\n          if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isDeleteWordBackward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                unit: 'word'\n              });\n            }\n            return;\n          }\n          if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isDeleteWordForward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                unit: 'word'\n              });\n            }\n            return;\n          }\n        } else {\n          if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_CHROME || slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_WEBKIT) {\n            // COMPAT: Chrome and Safari support `beforeinput` event but do not fire\n            // an event when deleting backwards in a selected void inline node\n            if (selection && (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isDeleteBackward(nativeEvent) || slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isDeleteForward(nativeEvent)) && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection)) {\n              var currentNode = slate__WEBPACK_IMPORTED_MODULE_7__.Node.parent(editor, selection.anchor.path);\n              if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(currentNode) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, currentNode) && (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isInline(editor, currentNode) || slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, currentNode))) {\n                event.preventDefault();\n                slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                  unit: 'block'\n                });\n                return;\n              }\n            }\n          }\n        }\n      }\n    }, [readOnly, editor, attributes.onKeyDown]),\n    onPaste: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onPaste)) {\n        // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n        // fall back to React's `onPaste` here instead.\n        // COMPAT: Firefox, Chrome and Safari don't emit `beforeinput` events\n        // when \"paste without formatting\" is used, so fallback. (2020/02/20)\n        // COMPAT: Safari InputEvents generated by pasting won't include\n        // application/x-slate-fragment items, so use the\n        // ClipboardEvent here. (2023/03/15)\n        if (!slate_dom__WEBPACK_IMPORTED_MODULE_4__.HAS_BEFORE_INPUT_SUPPORT || (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isPlainTextOnlyPaste)(event.nativeEvent) || slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_WEBKIT) {\n          event.preventDefault();\n          ReactEditor.insertData(editor, event.clipboardData);\n        }\n      }\n    }, [readOnly, editor, attributes.onPaste])\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(Children, {\n    decorations: decorations,\n    node: editor,\n    renderElement: renderElement,\n    renderChunk: renderChunk,\n    renderPlaceholder: renderPlaceholder,\n    renderLeaf: renderLeaf,\n    renderText: renderText\n  }))))));\n});\n/**\n * The default placeholder element\n */\nvar DefaultPlaceholder = _ref2 => {\n  var {\n    attributes,\n    children\n  } = _ref2;\n  return (\n    /*#__PURE__*/\n    // COMPAT: Artificially add a line-break to the end on the placeholder element\n    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter\n    react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", _objectSpread({}, attributes), children, slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"br\", null))\n  );\n};\n/**\n * A default memoized decorate function.\n */\nvar defaultDecorate = () => [];\n/**\n * A default implement to scroll dom range into view.\n */\nvar defaultScrollSelectionIntoView = (editor, domRange) => {\n  // This was affecting the selection of multiple blocks and dragging behavior,\n  // so enabled only if the selection has been collapsed.\n  if (domRange.getBoundingClientRect && (!editor.selection || editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(editor.selection))) {\n    var leafEl = domRange.startContainer.parentElement;\n    // COMPAT: In Chrome, domRange.getBoundingClientRect() can return zero dimensions for valid ranges (e.g. line breaks).\n    // When this happens, do not scroll like most editors do.\n    var domRect = domRange.getBoundingClientRect();\n    var isZeroDimensionRect = domRect.width === 0 && domRect.height === 0 && domRect.x === 0 && domRect.y === 0;\n    if (isZeroDimensionRect) {\n      var leafRect = leafEl.getBoundingClientRect();\n      var leafHasDimensions = leafRect.width > 0 || leafRect.height > 0;\n      if (leafHasDimensions) {\n        return;\n      }\n    }\n    // Default behavior: use domRange's getBoundingClientRect\n    leafEl.getBoundingClientRect = domRange.getBoundingClientRect.bind(domRange);\n    (0,scroll_into_view_if_needed__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(leafEl, {\n      scrollMode: 'if-needed'\n    });\n    // @ts-expect-error an unorthodox delete D:\n    delete leafEl.getBoundingClientRect;\n  }\n};\n/**\n * Check if an event is overrided by a handler.\n */\nvar isEventHandled = (event, handler) => {\n  if (!handler) {\n    return false;\n  }\n  // The custom event handler may return a boolean to specify whether the event\n  // shall be treated as being handled or not.\n  var shouldTreatEventAsHandled = handler(event);\n  if (shouldTreatEventAsHandled != null) {\n    return shouldTreatEventAsHandled;\n  }\n  return event.isDefaultPrevented() || event.isPropagationStopped();\n};\n/**\n * Check if the event's target is an input element\n */\nvar isDOMEventTargetInput = event => {\n  return (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isDOMNode)(event.target) && (event.target instanceof HTMLInputElement || event.target instanceof HTMLTextAreaElement);\n};\n/**\n * Check if a DOM event is overrided by a handler.\n */\nvar isDOMEventHandled = (event, handler) => {\n  if (!handler) {\n    return false;\n  }\n  // The custom event handler may return a boolean to specify whether the event\n  // shall be treated as being handled or not.\n  var shouldTreatEventAsHandled = handler(event);\n  if (shouldTreatEventAsHandled != null) {\n    return shouldTreatEventAsHandled;\n  }\n  return event.defaultPrevented;\n};\nvar handleNativeHistoryEvents = (editor, event) => {\n  var maybeHistoryEditor = editor;\n  if (event.inputType === 'historyUndo' && typeof maybeHistoryEditor.undo === 'function') {\n    maybeHistoryEditor.undo();\n    return;\n  }\n  if (event.inputType === 'historyRedo' && typeof maybeHistoryEditor.redo === 'function') {\n    maybeHistoryEditor.redo();\n    return;\n  }\n};\n\n/**\n * A React context for sharing the `focused` state of the editor.\n */\nvar FocusedContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(false);\n/**\n * Get the current `focused` state of the editor.\n */\nvar useFocused = () => {\n  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(FocusedContext);\n};\n\nvar REACT_MAJOR_VERSION = parseInt(react__WEBPACK_IMPORTED_MODULE_3___default().version.split('.')[0], 10);\n\nvar _excluded = [\"editor\", \"children\", \"onChange\", \"onSelectionChange\", \"onValueChange\", \"initialValue\"];\n/**\n * A wrapper around the provider to handle `onChange` events, because the editor\n * is a mutable singleton so it won't ever register as \"changed\" otherwise.\n */\nvar Slate = props => {\n  var {\n      editor,\n      children,\n      onChange,\n      onSelectionChange,\n      onValueChange,\n      initialValue\n    } = props,\n    rest = _objectWithoutProperties(props, _excluded);\n  // Run once on first mount, but before `useEffect` or render\n  react__WEBPACK_IMPORTED_MODULE_3___default().useState(() => {\n    if (!slate__WEBPACK_IMPORTED_MODULE_7__.Node.isNodeList(initialValue)) {\n      throw new Error(\"[Slate] initialValue is invalid! Expected a list of elements but got: \".concat(slate__WEBPACK_IMPORTED_MODULE_7__.Scrubber.stringify(initialValue)));\n    }\n    if (!slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isEditor(editor)) {\n      throw new Error(\"[Slate] editor is invalid! You passed: \".concat(slate__WEBPACK_IMPORTED_MODULE_7__.Scrubber.stringify(editor)));\n    }\n    editor.children = initialValue;\n    Object.assign(editor, rest);\n  });\n  var {\n    selectorContext,\n    onChange: handleSelectorChange\n  } = useSelectorContext();\n  var onContextChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(options => {\n    var _options$operation;\n    if (onChange) {\n      onChange(editor.children);\n    }\n    switch (options === null || options === void 0 || (_options$operation = options.operation) === null || _options$operation === void 0 ? void 0 : _options$operation.type) {\n      case 'set_selection':\n        onSelectionChange === null || onSelectionChange === void 0 || onSelectionChange(editor.selection);\n        break;\n      default:\n        onValueChange === null || onValueChange === void 0 || onValueChange(editor.children);\n    }\n    handleSelectorChange();\n  }, [editor, handleSelectorChange, onChange, onSelectionChange, onValueChange]);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_ON_CHANGE.set(editor, onContextChange);\n    return () => {\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_ON_CHANGE.set(editor, () => {});\n    };\n  }, [editor, onContextChange]);\n  var [isFocused, setIsFocused] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(ReactEditor.isFocused(editor));\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    setIsFocused(ReactEditor.isFocused(editor));\n  }, [editor]);\n  useIsomorphicLayoutEffect(() => {\n    var fn = () => setIsFocused(ReactEditor.isFocused(editor));\n    if (REACT_MAJOR_VERSION >= 17) {\n      // In React >= 17 onFocus and onBlur listen to the focusin and focusout events during the bubbling phase.\n      // Therefore in order for <Editable />'s handlers to run first, which is necessary for ReactEditor.isFocused(editor)\n      // to return the correct value, we have to listen to the focusin and focusout events without useCapture here.\n      document.addEventListener('focusin', fn);\n      document.addEventListener('focusout', fn);\n      return () => {\n        document.removeEventListener('focusin', fn);\n        document.removeEventListener('focusout', fn);\n      };\n    } else {\n      document.addEventListener('focus', fn, true);\n      document.addEventListener('blur', fn, true);\n      return () => {\n        document.removeEventListener('focus', fn, true);\n        document.removeEventListener('blur', fn, true);\n      };\n    }\n  }, []);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(SlateSelectorContext.Provider, {\n    value: selectorContext\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(EditorContext.Provider, {\n    value: editor\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(FocusedContext.Provider, {\n    value: isFocused\n  }, children)));\n};\n\n/**\n * Get the current editor object from the React context.\n * @deprecated Use useSlateStatic instead.\n */\nvar useEditor = () => {\n  var editor = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(EditorContext);\n  if (!editor) {\n    throw new Error(\"The `useEditor` hook must be used inside the <Slate> component's context.\");\n  }\n  return editor;\n};\n\n/**\n * Get the current `selected` state of an element.\n */\nvar useSelected = () => {\n  var element = useElementIf();\n  // Breaking the rules of hooks is fine here since `!element` will remain true\n  // or false for the entire lifetime of the component this hook is called from.\n  // TODO: Decide if we want to throw an error instead when calling\n  // `useSelected` outside of an element (potentially a breaking change).\n  if (!element) return false;\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  var selector = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(editor => {\n    if (!editor.selection) return false;\n    var path = ReactEditor.findPath(editor, element);\n    var range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, path);\n    return !!slate__WEBPACK_IMPORTED_MODULE_7__.Range.intersection(range, editor.selection);\n  }, [element]);\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  return useSlateSelector(selector, undefined, {\n    // Defer the selector until after `Editable` has rendered so that the path\n    // will be accurate.\n    deferred: true\n  });\n};\n\n/**\n * Get the current slate selection.\n * Only triggers a rerender when the selection actually changes\n */\nvar useSlateSelection = () => {\n  return useSlateSelector(editor => editor.selection, isSelectionEqual);\n};\nvar isSelectionEqual = (a, b) => {\n  if (!a && !b) return true;\n  if (!a || !b) return false;\n  return slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(a, b);\n};\n\n/**\n * `withReact` adds React and DOM specific behaviors to the editor.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\n * this plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */\nvar withReact = function withReact(editor) {\n  var clipboardFormatKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x-slate-fragment';\n  var e = editor;\n  e = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.withDOM)(e, clipboardFormatKey);\n  var {\n    onChange,\n    apply,\n    insertText\n  } = e;\n  e.getChunkSize = () => null;\n  if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID) {\n    e.insertText = (text, options) => {\n      // COMPAT: Android devices, specifically Samsung devices, experience cursor jumping.\n      // This issue occurs when the ⁠insertText function is called immediately after typing.\n      // The problem arises because typing schedules a selection change.\n      // However, this selection change is only executed after the ⁠insertText function.\n      // As a result, the already obsolete selection is applied, leading to incorrect\n      // final cursor position.\n      slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_SELECTION.delete(e);\n      return insertText(text, options);\n    };\n  }\n  e.onChange = options => {\n    // COMPAT: React < 18 doesn't batch `setState` hook calls, which means\n    // that the children and selection can get out of sync for one render\n    // pass. So we have to use this unstable API to ensure it batches them.\n    // (2019/12/03)\n    // https://github.com/facebook/react/issues/14259#issuecomment-439702367\n    var maybeBatchUpdates = REACT_MAJOR_VERSION < 18 ? (react_dom__WEBPACK_IMPORTED_MODULE_6___default().unstable_batchedUpdates) : callback => callback();\n    maybeBatchUpdates(() => {\n      onChange(options);\n    });\n  };\n  // On move_node, if the chunking optimization is enabled for the parent of the\n  // node being moved, add the moved node to the movedNodeKeys set of the\n  // parent's chunk tree.\n  e.apply = operation => {\n    if (operation.type === 'move_node') {\n      var parent = slate__WEBPACK_IMPORTED_MODULE_7__.Node.parent(e, operation.path);\n      var chunking = !!e.getChunkSize(parent);\n      if (chunking) {\n        var node = slate__WEBPACK_IMPORTED_MODULE_7__.Node.get(e, operation.path);\n        var chunkTree = getChunkTreeForNode(e, parent);\n        var key = ReactEditor.findKey(e, node);\n        chunkTree.movedNodeKeys.add(key);\n      }\n    }\n    apply(operation);\n  };\n  return e;\n};\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL25vZGVfbW9kdWxlcy9zbGF0ZS1yZWFjdC9kaXN0L2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUM7QUFDRTtBQUNBO0FBQ3lJO0FBQ3hIO0FBQzZEO0FBQzI1QjtBQUN0OUI7QUFDRDtBQUN4Qjs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxvREFBYTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaURBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixnREFBUzs7QUFFM0IsMkJBQTJCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3RQLDhCQUE4QixnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHdEQUF3RCw4QkFBOEIscUpBQXFKLHFFQUFxRSxLQUFLO0FBQ2xiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0JBQW9CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBDQUFHO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsdUNBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBLGVBQWUsaURBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtEQUFXO0FBQzVCO0FBQ0E7QUFDQSxnQkFBZ0IseUNBQU07QUFDdEIsYUFBYSx3Q0FBSztBQUNsQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0NBQUs7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxrREFBTztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsTUFBTSxpREFBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sa0VBQTJCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCwwRUFBZ0M7QUFDdkY7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUNBQUk7QUFDdkI7QUFDQTtBQUNBLG1CQUFtQix1Q0FBSTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXdUO0FBQ3hUIiwic291cmNlcyI6WyIvVXNlcnMvR2Fsb2NrL0NTL2JlaG9tZS1zaXRlL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L2VkaXRvci9ub2RlX21vZHVsZXMvc2xhdGUtcmVhY3QvZGlzdC9pbmRleC5lcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZ2V0RGlyZWN0aW9uIGZyb20gJ2RpcmVjdGlvbic7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSAnbG9kYXNoL2RlYm91bmNlJztcbmltcG9ydCB0aHJvdHRsZSBmcm9tICdsb2Rhc2gvdGhyb3R0bGUnO1xuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVJlZiwgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QsIHVzZVN0YXRlLCBtZW1vLCBmb3J3YXJkUmVmLCB1c2VDYWxsYmFjaywgdXNlUmVkdWNlciwgdXNlTWVtbywgRnJhZ21lbnQsIENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBzY3JvbGxJbnRvVmlldyBmcm9tICdzY3JvbGwtaW50by12aWV3LWlmLW5lZWRlZCc7XG5pbXBvcnQgeyBFZGl0b3IsIFJhbmdlLCBUcmFuc2Zvcm1zLCBUZXh0IGFzIFRleHQkMSwgUGF0aCwgTm9kZSwgUG9pbnQsIEVsZW1lbnQgYXMgRWxlbWVudCQxLCBTY3J1YmJlciB9IGZyb20gJ3NsYXRlJztcbmltcG9ydCB7IERPTUVkaXRvciwgRURJVE9SX1RPX1VTRVJfTUFSS1MsIEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLCBFRElUT1JfVE9fUEVORElOR19BQ1RJT04sIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUywgdGFyZ2V0UmFuZ2UsIHZlcmlmeURpZmZTdGF0ZSwgRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLCBJU19DT01QT1NJTkcsIElTX05PREVfTUFQX0RJUlRZLCBhcHBseVN0cmluZ0RpZmYsIGlzRE9NU2VsZWN0aW9uLCBpc1RyYWNrZWRNdXRhdGlvbiwgRURJVE9SX1RPX0ZPUkNFX1JFTkRFUiwgbm9ybWFsaXplUmFuZ2UsIG5vcm1hbGl6ZVBvaW50LCBFRElUT1JfVE9fUExBQ0VIT0xERVJfRUxFTUVOVCwgbm9ybWFsaXplU3RyaW5nRGlmZiwgbWVyZ2VTdHJpbmdEaWZmcywgQ0FOX1VTRV9ET00sIElTX0FORFJPSUQsIEVESVRPUl9UT19TQ0hFRFVMRV9GTFVTSCwgTUFSS19QTEFDRUhPTERFUl9TWU1CT0wsIFBMQUNFSE9MREVSX1NZTUJPTCwgSVNfV0VCS0lULCBpc1RleHREZWNvcmF0aW9uc0VxdWFsLCBpc0VsZW1lbnREZWNvcmF0aW9uc0VxdWFsLCBFRElUT1JfVE9fS0VZX1RPX0VMRU1FTlQsIE5PREVfVE9fRUxFTUVOVCwgRUxFTUVOVF9UT19OT0RFLCBOT0RFX1RPX0lOREVYLCBOT0RFX1RPX1BBUkVOVCwgS2V5LCBzcGxpdERlY29yYXRpb25zQnlDaGlsZCwgSVNfUkVBRF9PTkxZLCBnZXRBY3RpdmVFbGVtZW50LCBnZXRTZWxlY3Rpb24sIElTX0ZPQ1VTRUQsIGdldERlZmF1bHRWaWV3LCBFRElUT1JfVE9fV0lORE9XLCBFRElUT1JfVE9fRUxFTUVOVCwgSVNfRklSRUZPWCwgRURJVE9SX1RPX1VTRVJfU0VMRUNUSU9OLCBIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQsIGlzRE9NRWxlbWVudCwgaXNET01Ob2RlLCBUUklQTEVfQ0xJQ0ssIElTX0ZJUkVGT1hfTEVHQUNZLCBJU19JT1MsIElTX1dFQ0hBVEJST1dTRVIsIElTX1VDX01PQklMRSwgSG90a2V5cywgSVNfQ0hST01FLCBpc1BsYWluVGV4dE9ubHlQYXN0ZSwgRURJVE9SX1RPX09OX0NIQU5HRSwgd2l0aERPTSB9IGZyb20gJ3NsYXRlLWRvbSc7XG5leHBvcnQgeyBOT0RFX1RPX0lOREVYLCBOT0RFX1RPX1BBUkVOVCB9IGZyb20gJ3NsYXRlLWRvbSc7XG5pbXBvcnQgeyBSZXNpemVPYnNlcnZlciB9IGZyb20gJ0BqdWdnbGUvcmVzaXplLW9ic2VydmVyJztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICB2YXIga2V5LCBpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIG87XG4gIH0gOiBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvO1xuICB9LCBfdHlwZW9mKG8pO1xufVxuXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgaWYgKF90eXBlb2YoaW5wdXQpICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChfdHlwZW9mKHJlcykgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpO1xufVxuXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHtcbiAgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBBIFJlYWN0IGNvbnRleHQgZm9yIHNoYXJpbmcgdGhlIGVkaXRvciBvYmplY3QuXG4gKi9cbnZhciBFZGl0b3JDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQobnVsbCk7XG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBlZGl0b3Igb2JqZWN0IGZyb20gdGhlIFJlYWN0IGNvbnRleHQuXG4gKi9cbnZhciB1c2VTbGF0ZVN0YXRpYyA9ICgpID0+IHtcbiAgdmFyIGVkaXRvciA9IHVzZUNvbnRleHQoRWRpdG9yQ29udGV4dCk7XG4gIGlmICghZWRpdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGB1c2VTbGF0ZVN0YXRpY2AgaG9vayBtdXN0IGJlIHVzZWQgaW5zaWRlIHRoZSA8U2xhdGU+IGNvbXBvbmVudCdzIGNvbnRleHQuXCIpO1xuICB9XG4gIHJldHVybiBlZGl0b3I7XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgUmVhY3RFZGl0b3IgPSBET01FZGl0b3I7XG5cbmZ1bmN0aW9uIG93bktleXMkNyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDcoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQ3KE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQ3KE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZHJhZnQtanMvYmxvYi9tYWluL3NyYy9jb21wb25lbnQvaGFuZGxlcnMvY29tcG9zaXRpb24vRHJhZnRFZGl0b3JDb21wb3NpdGlvbkhhbmRsZXIuanMjTDQxXG4vLyBXaGVuIHVzaW5nIGtleWJvYXJkIEVuZ2xpc2ggYXNzb2NpYXRpb24gZnVuY3Rpb24sIGNvbnBvc2l0aW9uRW5kIHRyaWdnZXJlZCB0b28gZmFzdCwgcmVzdWx0aW5nIGluIGFmdGVyIGBpbnNlcnRUZXh0YCBzdGlsbCBtYWludGFpbiBhc3NvY2lhdGlvbiBzdGF0ZS5cbnZhciBSRVNPTFZFX0RFTEFZID0gMjU7XG4vLyBUaW1lIHdpdGggbm8gdXNlciBpbnRlcmFjdGlvbiBiZWZvcmUgdGhlIGN1cnJlbnQgdXNlciBhY3Rpb24gaXMgY29uc2lkZXJlZCBhcyBkb25lLlxudmFyIEZMVVNIX0RFTEFZID0gMjAwO1xuLy8gUmVwbGFjZSB3aXRoIGBjb25zdCBkZWJ1ZyA9IGNvbnNvbGUubG9nYCB0byBkZWJ1Z1xudmFyIGRlYnVnID0gZnVuY3Rpb24gZGVidWcoKSB7fTtcbi8vIFR5cGUgZ3VhcmQgdG8gY2hlY2sgaWYgYSB2YWx1ZSBpcyBhIERhdGFUcmFuc2ZlclxudmFyIGlzRGF0YVRyYW5zZmVyID0gdmFsdWUgPT4gKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSA9PT0gJ0RhdGFUcmFuc2Zlcic7XG5mdW5jdGlvbiBjcmVhdGVBbmRyb2lkSW5wdXRNYW5hZ2VyKF9yZWYpIHtcbiAgdmFyIHtcbiAgICBlZGl0b3IsXG4gICAgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZSxcbiAgICBvbkRPTVNlbGVjdGlvbkNoYW5nZVxuICB9ID0gX3JlZjtcbiAgdmFyIGZsdXNoaW5nID0gZmFsc2U7XG4gIHZhciBjb21wb3NpdGlvbkVuZFRpbWVvdXRJZCA9IG51bGw7XG4gIHZhciBmbHVzaFRpbWVvdXRJZCA9IG51bGw7XG4gIHZhciBhY3Rpb25UaW1lb3V0SWQgPSBudWxsO1xuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgdmFyIGluc2VydFBvc2l0aW9uSGludCA9IGZhbHNlO1xuICB2YXIgYXBwbHlQZW5kaW5nU2VsZWN0aW9uID0gKCkgPT4ge1xuICAgIHZhciBwZW5kaW5nU2VsZWN0aW9uID0gRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLmdldChlZGl0b3IpO1xuICAgIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTi5kZWxldGUoZWRpdG9yKTtcbiAgICBpZiAocGVuZGluZ1NlbGVjdGlvbikge1xuICAgICAgdmFyIHtcbiAgICAgICAgc2VsZWN0aW9uXG4gICAgICB9ID0gZWRpdG9yO1xuICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVSYW5nZShlZGl0b3IsIHBlbmRpbmdTZWxlY3Rpb24pO1xuICAgICAgaWYgKG5vcm1hbGl6ZWQgJiYgKCFzZWxlY3Rpb24gfHwgIVJhbmdlLmVxdWFscyhub3JtYWxpemVkLCBzZWxlY3Rpb24pKSkge1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIG5vcm1hbGl6ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdmFyIHBlcmZvcm1BY3Rpb24gPSAoKSA9PiB7XG4gICAgdmFyIGFjdGlvbiA9IEVESVRPUl9UT19QRU5ESU5HX0FDVElPTi5nZXQoZWRpdG9yKTtcbiAgICBFRElUT1JfVE9fUEVORElOR19BQ1RJT04uZGVsZXRlKGVkaXRvcik7XG4gICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGFjdGlvbi5hdCkge1xuICAgICAgdmFyIHRhcmdldCA9IFBvaW50LmlzUG9pbnQoYWN0aW9uLmF0KSA/IG5vcm1hbGl6ZVBvaW50KGVkaXRvciwgYWN0aW9uLmF0KSA6IG5vcm1hbGl6ZVJhbmdlKGVkaXRvciwgYWN0aW9uLmF0KTtcbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBfdGFyZ2V0UmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCB0YXJnZXQpO1xuICAgICAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uIHx8ICFSYW5nZS5lcXVhbHMoZWRpdG9yLnNlbGVjdGlvbiwgX3RhcmdldFJhbmdlKSkge1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuICAgIGFjdGlvbi5ydW4oKTtcbiAgfTtcbiAgdmFyIGZsdXNoID0gKCkgPT4ge1xuICAgIGlmIChmbHVzaFRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGZsdXNoVGltZW91dElkKTtcbiAgICAgIGZsdXNoVGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGFjdGlvblRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGFjdGlvblRpbWVvdXRJZCk7XG4gICAgICBhY3Rpb25UaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoIWhhc1BlbmRpbmdEaWZmcygpICYmICFoYXNQZW5kaW5nQWN0aW9uKCkpIHtcbiAgICAgIGFwcGx5UGVuZGluZ1NlbGVjdGlvbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICBmbHVzaGluZyA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IGZsdXNoaW5nID0gZmFsc2UpO1xuICAgIH1cbiAgICBpZiAoaGFzUGVuZGluZ0FjdGlvbigpKSB7XG4gICAgICBmbHVzaGluZyA9ICdhY3Rpb24nO1xuICAgIH1cbiAgICB2YXIgc2VsZWN0aW9uUmVmID0gZWRpdG9yLnNlbGVjdGlvbiAmJiBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uLCB7XG4gICAgICBhZmZpbml0eTogJ2ZvcndhcmQnXG4gICAgfSk7XG4gICAgRURJVE9SX1RPX1VTRVJfTUFSS1Muc2V0KGVkaXRvciwgZWRpdG9yLm1hcmtzKTtcbiAgICBkZWJ1ZygnZmx1c2gnLCBFRElUT1JfVE9fUEVORElOR19BQ1RJT04uZ2V0KGVkaXRvciksIEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlZGl0b3IpKTtcbiAgICB2YXIgc2NoZWR1bGVTZWxlY3Rpb25DaGFuZ2UgPSBoYXNQZW5kaW5nRGlmZnMoKTtcbiAgICB2YXIgZGlmZjtcbiAgICB3aGlsZSAoZGlmZiA9IChfRURJVE9SX1RPX1BFTkRJTkdfREkgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZWRpdG9yKSkgPT09IG51bGwgfHwgX0VESVRPUl9UT19QRU5ESU5HX0RJID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfRURJVE9SX1RPX1BFTkRJTkdfRElbMF0pIHtcbiAgICAgIHZhciBfRURJVE9SX1RPX1BFTkRJTkdfREksIF9FRElUT1JfVE9fUEVORElOR19ESTI7XG4gICAgICB2YXIgcGVuZGluZ01hcmtzID0gRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLmdldChlZGl0b3IpO1xuICAgICAgaWYgKHBlbmRpbmdNYXJrcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5kZWxldGUoZWRpdG9yKTtcbiAgICAgICAgZWRpdG9yLm1hcmtzID0gcGVuZGluZ01hcmtzO1xuICAgICAgfVxuICAgICAgaWYgKHBlbmRpbmdNYXJrcyAmJiBpbnNlcnRQb3NpdGlvbkhpbnQgPT09IGZhbHNlKSB7XG4gICAgICAgIGluc2VydFBvc2l0aW9uSGludCA9IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgcmFuZ2UgPSB0YXJnZXRSYW5nZShkaWZmKTtcbiAgICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbiB8fCAhUmFuZ2UuZXF1YWxzKGVkaXRvci5zZWxlY3Rpb24sIHJhbmdlKSkge1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHJhbmdlKTtcbiAgICAgIH1cbiAgICAgIGlmIChkaWZmLmRpZmYudGV4dCkge1xuICAgICAgICBFZGl0b3IuaW5zZXJ0VGV4dChlZGl0b3IsIGRpZmYuZGlmZi50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IpO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIGRpZmYgb25seSBhZnRlciB3ZSBoYXZlIGFwcGxpZWQgaXQgdG8gYWNjb3VudCBmb3IgaXQgd2hlbiB0cmFuc2Zvcm1pbmdcbiAgICAgIC8vIHBlbmRpbmcgcmFuZ2VzLlxuICAgICAgRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuc2V0KGVkaXRvciwgKF9FRElUT1JfVE9fUEVORElOR19ESTIgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZWRpdG9yKSkgPT09IG51bGwgfHwgX0VESVRPUl9UT19QRU5ESU5HX0RJMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX0VESVRPUl9UT19QRU5ESU5HX0RJMi5maWx0ZXIoX3JlZjIgPT4ge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIGlkXG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgcmV0dXJuIGlkICE9PSBkaWZmLmlkO1xuICAgICAgfSkpO1xuICAgICAgaWYgKCF2ZXJpZnlEaWZmU3RhdGUoZWRpdG9yLCBkaWZmKSkge1xuICAgICAgICBzY2hlZHVsZVNlbGVjdGlvbkNoYW5nZSA9IGZhbHNlO1xuICAgICAgICBFRElUT1JfVE9fUEVORElOR19BQ1RJT04uZGVsZXRlKGVkaXRvcik7XG4gICAgICAgIEVESVRPUl9UT19VU0VSX01BUktTLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgICBmbHVzaGluZyA9ICdhY3Rpb24nO1xuICAgICAgICAvLyBFbnN1cmUgd2UgZG9uJ3QgcmVzdG9yZSB0aGUgcGVuZGluZyB1c2VyIChkb20pIHNlbGVjdGlvblxuICAgICAgICAvLyBzaW5jZSB0aGUgZG9jdW1lbnQgYW5kIGRvbSBzdGF0ZSBkbyBub3QgbWF0Y2guXG4gICAgICAgIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTi5kZWxldGUoZWRpdG9yKTtcbiAgICAgICAgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZS5jYW5jZWwoKTtcbiAgICAgICAgb25ET01TZWxlY3Rpb25DaGFuZ2UuY2FuY2VsKCk7XG4gICAgICAgIHNlbGVjdGlvblJlZiA9PT0gbnVsbCB8fCBzZWxlY3Rpb25SZWYgPT09IHZvaWQgMCB8fCBzZWxlY3Rpb25SZWYudW5yZWYoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHNlbGVjdGlvbiA9IHNlbGVjdGlvblJlZiA9PT0gbnVsbCB8fCBzZWxlY3Rpb25SZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbGVjdGlvblJlZi51bnJlZigpO1xuICAgIGlmIChzZWxlY3Rpb24gJiYgIUVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTi5nZXQoZWRpdG9yKSAmJiAoIWVkaXRvci5zZWxlY3Rpb24gfHwgIVJhbmdlLmVxdWFscyhzZWxlY3Rpb24sIGVkaXRvci5zZWxlY3Rpb24pKSkge1xuICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzZWxlY3Rpb24pO1xuICAgIH1cbiAgICBpZiAoaGFzUGVuZGluZ0FjdGlvbigpKSB7XG4gICAgICBwZXJmb3JtQWN0aW9uKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIENPTVBBVDogVGhlIHNlbGVjdGlvbkNoYW5nZSBldmVudCBpcyBmaXJlZCBhZnRlciB0aGUgYWN0aW9uIGlzIHBlcmZvcm1lZCxcbiAgICAvLyBzbyB3ZSBoYXZlIHRvIG1hbnVhbGx5IHNjaGVkdWxlIGl0IHRvIGVuc3VyZSB3ZSBkb24ndCAndGhyb3cgYXdheScgdGhlIHNlbGVjdGlvblxuICAgIC8vIHdoaWxlIHJlbmRlcmluZyBpZiB3ZSBoYXZlIHBlbmRpbmcgY2hhbmdlcy5cbiAgICBpZiAoc2NoZWR1bGVTZWxlY3Rpb25DaGFuZ2UpIHtcbiAgICAgIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UoKTtcbiAgICB9XG4gICAgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZS5mbHVzaCgpO1xuICAgIG9uRE9NU2VsZWN0aW9uQ2hhbmdlLmZsdXNoKCk7XG4gICAgYXBwbHlQZW5kaW5nU2VsZWN0aW9uKCk7XG4gICAgdmFyIHVzZXJNYXJrcyA9IEVESVRPUl9UT19VU0VSX01BUktTLmdldChlZGl0b3IpO1xuICAgIEVESVRPUl9UT19VU0VSX01BUktTLmRlbGV0ZShlZGl0b3IpO1xuICAgIGlmICh1c2VyTWFya3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZWRpdG9yLm1hcmtzID0gdXNlck1hcmtzO1xuICAgICAgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgfVxuICB9O1xuICB2YXIgaGFuZGxlQ29tcG9zaXRpb25FbmQgPSBfZXZlbnQgPT4ge1xuICAgIGlmIChjb21wb3NpdGlvbkVuZFRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGNvbXBvc2l0aW9uRW5kVGltZW91dElkKTtcbiAgICB9XG4gICAgY29tcG9zaXRpb25FbmRUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIElTX0NPTVBPU0lORy5zZXQoZWRpdG9yLCBmYWxzZSk7XG4gICAgICBmbHVzaCgpO1xuICAgIH0sIFJFU09MVkVfREVMQVkpO1xuICB9O1xuICB2YXIgaGFuZGxlQ29tcG9zaXRpb25TdGFydCA9IF9ldmVudCA9PiB7XG4gICAgSVNfQ09NUE9TSU5HLnNldChlZGl0b3IsIHRydWUpO1xuICAgIGlmIChjb21wb3NpdGlvbkVuZFRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGNvbXBvc2l0aW9uRW5kVGltZW91dElkKTtcbiAgICAgIGNvbXBvc2l0aW9uRW5kVGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gIH07XG4gIHZhciB1cGRhdGVQbGFjZWhvbGRlclZpc2liaWxpdHkgPSBmdW5jdGlvbiB1cGRhdGVQbGFjZWhvbGRlclZpc2liaWxpdHkoKSB7XG4gICAgdmFyIGZvcmNlSGlkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgdmFyIHBsYWNlaG9sZGVyRWxlbWVudCA9IEVESVRPUl9UT19QTEFDRUhPTERFUl9FTEVNRU5ULmdldChlZGl0b3IpO1xuICAgIGlmICghcGxhY2Vob2xkZXJFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChoYXNQZW5kaW5nRGlmZnMoKSB8fCBmb3JjZUhpZGUpIHtcbiAgICAgIHBsYWNlaG9sZGVyRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwbGFjZWhvbGRlckVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2Rpc3BsYXknKTtcbiAgfTtcbiAgdmFyIHN0b3JlRGlmZiA9IChwYXRoLCBkaWZmKSA9PiB7XG4gICAgdmFyIF9FRElUT1JfVE9fUEVORElOR19ESTM7XG4gICAgdmFyIHBlbmRpbmdEaWZmcyA9IChfRURJVE9SX1RPX1BFTkRJTkdfREkzID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGVkaXRvcikpICE9PSBudWxsICYmIF9FRElUT1JfVE9fUEVORElOR19ESTMgIT09IHZvaWQgMCA/IF9FRElUT1JfVE9fUEVORElOR19ESTMgOiBbXTtcbiAgICBFRElUT1JfVE9fUEVORElOR19ESUZGUy5zZXQoZWRpdG9yLCBwZW5kaW5nRGlmZnMpO1xuICAgIHZhciB0YXJnZXQgPSBOb2RlLmxlYWYoZWRpdG9yLCBwYXRoKTtcbiAgICB2YXIgaWR4ID0gcGVuZGluZ0RpZmZzLmZpbmRJbmRleChjaGFuZ2UgPT4gUGF0aC5lcXVhbHMoY2hhbmdlLnBhdGgsIHBhdGgpKTtcbiAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTdHJpbmdEaWZmKHRhcmdldC50ZXh0LCBkaWZmKTtcbiAgICAgIGlmIChub3JtYWxpemVkKSB7XG4gICAgICAgIHBlbmRpbmdEaWZmcy5wdXNoKHtcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIGRpZmYsXG4gICAgICAgICAgaWQ6IGlkQ291bnRlcisrXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdXBkYXRlUGxhY2Vob2xkZXJWaXNpYmlsaXR5KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBtZXJnZWQgPSBtZXJnZVN0cmluZ0RpZmZzKHRhcmdldC50ZXh0LCBwZW5kaW5nRGlmZnNbaWR4XS5kaWZmLCBkaWZmKTtcbiAgICBpZiAoIW1lcmdlZCkge1xuICAgICAgcGVuZGluZ0RpZmZzLnNwbGljZShpZHgsIDEpO1xuICAgICAgdXBkYXRlUGxhY2Vob2xkZXJWaXNpYmlsaXR5KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBlbmRpbmdEaWZmc1tpZHhdID0gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgcGVuZGluZ0RpZmZzW2lkeF0pLCB7fSwge1xuICAgICAgZGlmZjogbWVyZ2VkXG4gICAgfSk7XG4gIH07XG4gIHZhciBzY2hlZHVsZUFjdGlvbiA9IGZ1bmN0aW9uIHNjaGVkdWxlQWN0aW9uKHJ1bikge1xuICAgIHZhciB7XG4gICAgICBhdFxuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGluc2VydFBvc2l0aW9uSGludCA9IGZhbHNlO1xuICAgIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTi5kZWxldGUoZWRpdG9yKTtcbiAgICBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlLmNhbmNlbCgpO1xuICAgIG9uRE9NU2VsZWN0aW9uQ2hhbmdlLmNhbmNlbCgpO1xuICAgIGlmIChoYXNQZW5kaW5nQWN0aW9uKCkpIHtcbiAgICAgIGZsdXNoKCk7XG4gICAgfVxuICAgIEVESVRPUl9UT19QRU5ESU5HX0FDVElPTi5zZXQoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIHJ1blxuICAgIH0pO1xuICAgIC8vIENPTVBBVDogV2hlbiBkZWxldGluZyBiZWZvcmUgYSBub24tY29udGVudGVkaXRhYmxlIGVsZW1lbnQgY2hyb21lIG9ubHkgZmlyZXMgYSBiZWZvcmVpbnB1dCxcbiAgICAvLyAobm8gaW5wdXQpIGFuZCBkb2Vzbid0IHBlcmZvcm0gYW55IGRvbSBtdXRhdGlvbnMuIFdpdGhvdXQgYSBmbHVzaCB0aW1lb3V0IHdlIHdvdWxkIG5ldmVyIGZsdXNoXG4gICAgLy8gaW4gdGhpcyBjYXNlIGFuZCB0aHVzIG5ldmVyIGFjdHVhbGx5IHBlcmZvcm0gdGhlIGFjdGlvbi5cbiAgICBhY3Rpb25UaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZsdXNoKTtcbiAgfTtcbiAgdmFyIGhhbmRsZURPTUJlZm9yZUlucHV0ID0gZXZlbnQgPT4ge1xuICAgIHZhciBfdGFyZ2V0UmFuZ2UyO1xuICAgIGlmIChmbHVzaFRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGZsdXNoVGltZW91dElkKTtcbiAgICAgIGZsdXNoVGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKElTX05PREVfTUFQX0RJUlRZLmdldChlZGl0b3IpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB7XG4gICAgICBpbnB1dFR5cGU6IHR5cGVcbiAgICB9ID0gZXZlbnQ7XG4gICAgdmFyIHRhcmdldFJhbmdlID0gbnVsbDtcbiAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGFUcmFuc2ZlciB8fCBldmVudC5kYXRhIHx8IHVuZGVmaW5lZDtcbiAgICBpZiAoaW5zZXJ0UG9zaXRpb25IaW50ICE9PSBmYWxzZSAmJiB0eXBlICE9PSAnaW5zZXJ0VGV4dCcgJiYgdHlwZSAhPT0gJ2luc2VydENvbXBvc2l0aW9uVGV4dCcpIHtcbiAgICAgIGluc2VydFBvc2l0aW9uSGludCA9IGZhbHNlO1xuICAgIH1cbiAgICB2YXIgW25hdGl2ZVRhcmdldFJhbmdlXSA9IGV2ZW50LmdldFRhcmdldFJhbmdlcygpO1xuICAgIGlmIChuYXRpdmVUYXJnZXRSYW5nZSkge1xuICAgICAgdGFyZ2V0UmFuZ2UgPSBSZWFjdEVkaXRvci50b1NsYXRlUmFuZ2UoZWRpdG9yLCBuYXRpdmVUYXJnZXRSYW5nZSwge1xuICAgICAgICBleGFjdE1hdGNoOiBmYWxzZSxcbiAgICAgICAgc3VwcHJlc3NUaHJvdzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIENPTVBBVDogU2VsZWN0aW9uQ2hhbmdlIGV2ZW50IGlzIGZpcmVkIGFmdGVyIHRoZSBhY3Rpb24gaXMgcGVyZm9ybWVkLCBzbyB3ZVxuICAgIC8vIGhhdmUgdG8gbWFudWFsbHkgZ2V0IHRoZSBzZWxlY3Rpb24gaGVyZSB0byBlbnN1cmUgaXQncyB1cC10by1kYXRlLlxuICAgIHZhciB3aW5kb3cgPSBSZWFjdEVkaXRvci5nZXRXaW5kb3coZWRpdG9yKTtcbiAgICB2YXIgZG9tU2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghdGFyZ2V0UmFuZ2UgJiYgZG9tU2VsZWN0aW9uKSB7XG4gICAgICBuYXRpdmVUYXJnZXRSYW5nZSA9IGRvbVNlbGVjdGlvbjtcbiAgICAgIHRhcmdldFJhbmdlID0gUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgZG9tU2VsZWN0aW9uLCB7XG4gICAgICAgIGV4YWN0TWF0Y2g6IGZhbHNlLFxuICAgICAgICBzdXBwcmVzc1Rocm93OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGFyZ2V0UmFuZ2UgPSAoX3RhcmdldFJhbmdlMiA9IHRhcmdldFJhbmdlKSAhPT0gbnVsbCAmJiBfdGFyZ2V0UmFuZ2UyICE9PSB2b2lkIDAgPyBfdGFyZ2V0UmFuZ2UyIDogZWRpdG9yLnNlbGVjdGlvbjtcbiAgICBpZiAoIXRhcmdldFJhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEJ5IGRlZmF1bHQsIHRoZSBpbnB1dCBtYW5hZ2VyIHRyaWVzIHRvIHN0b3JlIHRleHQgZGlmZnMgc28gdGhhdCB3ZSBjYW5cbiAgICAvLyBkZWZlciBmbHVzaGluZyB0aGVtIGF0IGEgbGF0ZXIgcG9pbnQgaW4gdGltZS4gV2UgZG9uJ3Qgd2FudCB0byBmbHVzaFxuICAgIC8vIGZvciBldmVyeSBpbnB1dCBldmVudCBhcyB0aGlzIGNhbiBiZSBleHBlbnNpdmUuIEhvd2V2ZXIsIHRoZXJlIGFyZSBzb21lXG4gICAgLy8gc2NlbmFyaW9zIHdoZXJlIHdlIGNhbm5vdCBzYWZlbHkgc3RvcmUgdGhlIHRleHQgZGlmZiBhbmQgbXVzdCBpbnN0ZWFkXG4gICAgLy8gc2NoZWR1bGUgYW4gYWN0aW9uIHRvIGxldCBTbGF0ZSBub3JtYWxpemUgdGhlIGVkaXRvciBzdGF0ZS5cbiAgICB2YXIgY2FuU3RvcmVEaWZmID0gdHJ1ZTtcbiAgICBpZiAodHlwZS5zdGFydHNXaXRoKCdkZWxldGUnKSkge1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IHR5cGUuZW5kc1dpdGgoJ0JhY2t3YXJkJykgPyAnYmFja3dhcmQnIDogJ2ZvcndhcmQnO1xuICAgICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHRhcmdldFJhbmdlKTtcbiAgICAgIHZhciBbbGVhZiwgcGF0aF0gPSBFZGl0b3IubGVhZihlZGl0b3IsIHN0YXJ0LnBhdGgpO1xuICAgICAgaWYgKFJhbmdlLmlzRXhwYW5kZWQodGFyZ2V0UmFuZ2UpKSB7XG4gICAgICAgIGlmIChsZWFmLnRleHQubGVuZ3RoID09PSBzdGFydC5vZmZzZXQgJiYgZW5kLm9mZnNldCA9PT0gMCkge1xuICAgICAgICAgIHZhciBuZXh0ID0gRWRpdG9yLm5leHQoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogc3RhcnQucGF0aCxcbiAgICAgICAgICAgIG1hdGNoOiBUZXh0JDEuaXNUZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKG5leHQgJiYgUGF0aC5lcXVhbHMobmV4dFsxXSwgZW5kLnBhdGgpKSB7XG4gICAgICAgICAgICAvLyB3aGVuIGRlbGV0aW5nIGEgbGluZWJyZWFrLCB0YXJnZXRSYW5nZSB3aWxsIHNwYW4gYWNyb3NzIHRoZSBicmVhayAoaWUgc3RhcnQgaW4gdGhlIG5vZGUgYmVmb3JlIGFuZCBlbmQgaW4gdGhlIG5vZGUgYWZ0ZXIpXG4gICAgICAgICAgICAvLyBpZiB0aGUgbm9kZSBiZWZvcmUgaXMgZW1wdHksIHRoaXMgd2lsbCBsb29rIGxpa2UgYSBoYW5naW5nIHJhbmdlIGFuZCBnZXQgdW5odW5nIGxhdGVyLS13aGljaCB3aWxsIHRha2UgdGhlIGJyZWFrIHdlIHdhbnQgdG8gcmVtb3ZlIG91dCBvZiB0aGUgcmFuZ2VcbiAgICAgICAgICAgIC8vIHNvIHRvIGF2b2lkIHRoaXMgd2UgY29sbGFwc2UgdGhlIHRhcmdldCByYW5nZSB0byBkZWZhdWx0IHRvIHNpbmdsZSBjaGFyYWN0ZXIgZGVsZXRpb25cbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdiYWNrd2FyZCcpIHtcbiAgICAgICAgICAgICAgdGFyZ2V0UmFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgYW5jaG9yOiBlbmQsXG4gICAgICAgICAgICAgICAgZm9jdXM6IGVuZFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgICAgICAgW2xlYWYsIHBhdGhdID0gbmV4dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRhcmdldFJhbmdlID0ge1xuICAgICAgICAgICAgICAgIGFuY2hvcjogc3RhcnQsXG4gICAgICAgICAgICAgICAgZm9jdXM6IHN0YXJ0XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGRpZmYgPSB7XG4gICAgICAgIHRleHQ6ICcnLFxuICAgICAgICBzdGFydDogc3RhcnQub2Zmc2V0LFxuICAgICAgICBlbmQ6IGVuZC5vZmZzZXRcbiAgICAgIH07XG4gICAgICB2YXIgcGVuZGluZ0RpZmZzID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGVkaXRvcik7XG4gICAgICB2YXIgcmVsZXZhbnRQZW5kaW5nRGlmZnMgPSBwZW5kaW5nRGlmZnMgPT09IG51bGwgfHwgcGVuZGluZ0RpZmZzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZW5kaW5nRGlmZnMuZmluZChjaGFuZ2UgPT4gUGF0aC5lcXVhbHMoY2hhbmdlLnBhdGgsIHBhdGgpKTtcbiAgICAgIHZhciBkaWZmcyA9IHJlbGV2YW50UGVuZGluZ0RpZmZzID8gW3JlbGV2YW50UGVuZGluZ0RpZmZzLmRpZmYsIGRpZmZdIDogW2RpZmZdO1xuICAgICAgdmFyIHRleHQgPSBhcHBseVN0cmluZ0RpZmYobGVhZi50ZXh0LCAuLi5kaWZmcyk7XG4gICAgICBpZiAodGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gVGV4dCBsZWFmIHdpbGwgYmUgcmVtb3ZlZCwgc28gd2UgbmVlZCB0byBzY2hlZHVsZSBhblxuICAgICAgICAvLyBhY3Rpb24gdG8gcmVtb3ZlIGl0IHNvIHRoYXQgU2xhdGUgY2FuIG5vcm1hbGl6ZSBpbnN0ZWFkXG4gICAgICAgIC8vIG9mIHN0b3JpbmcgYXMgYSBkaWZmXG4gICAgICAgIGNhblN0b3JlRGlmZiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKFJhbmdlLmlzRXhwYW5kZWQodGFyZ2V0UmFuZ2UpKSB7XG4gICAgICAgIGlmIChjYW5TdG9yZURpZmYgJiYgUGF0aC5lcXVhbHModGFyZ2V0UmFuZ2UuYW5jaG9yLnBhdGgsIHRhcmdldFJhbmdlLmZvY3VzLnBhdGgpKSB7XG4gICAgICAgICAgdmFyIHBvaW50ID0ge1xuICAgICAgICAgICAgcGF0aDogdGFyZ2V0UmFuZ2UuYW5jaG9yLnBhdGgsXG4gICAgICAgICAgICBvZmZzZXQ6IHN0YXJ0Lm9mZnNldFxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9pbnQsIHBvaW50KTtcbiAgICAgICAgICBoYW5kbGVVc2VyU2VsZWN0KHJhbmdlKTtcbiAgICAgICAgICByZXR1cm4gc3RvcmVEaWZmKHRhcmdldFJhbmdlLmFuY2hvci5wYXRoLCB7XG4gICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgIGVuZDogZW5kLm9mZnNldCxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydC5vZmZzZXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciwge1xuICAgICAgICAgIGRpcmVjdGlvblxuICAgICAgICB9KSwge1xuICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdkZWxldGVCeUNvbXBvc2l0aW9uJzpcbiAgICAgIGNhc2UgJ2RlbGV0ZUJ5Q3V0JzpcbiAgICAgIGNhc2UgJ2RlbGV0ZUJ5RHJhZyc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlICdkZWxldGVDb250ZW50JzpcbiAgICAgIGNhc2UgJ2RlbGV0ZUNvbnRlbnRGb3J3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBhbmNob3JcbiAgICAgICAgICB9ID0gdGFyZ2V0UmFuZ2U7XG4gICAgICAgICAgaWYgKGNhblN0b3JlRGlmZiAmJiBSYW5nZS5pc0NvbGxhcHNlZCh0YXJnZXRSYW5nZSkpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXROb2RlID0gTm9kZS5sZWFmKGVkaXRvciwgYW5jaG9yLnBhdGgpO1xuICAgICAgICAgICAgaWYgKGFuY2hvci5vZmZzZXQgPCB0YXJnZXROb2RlLnRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzdG9yZURpZmYoYW5jaG9yLnBhdGgsIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgICAgICBzdGFydDogYW5jaG9yLm9mZnNldCxcbiAgICAgICAgICAgICAgICBlbmQ6IGFuY2hvci5vZmZzZXQgKyAxXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yKSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2RlbGV0ZUNvbnRlbnRCYWNrd2FyZCc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX25hdGl2ZVRhcmdldFJhbmdlO1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBhbmNob3I6IF9hbmNob3JcbiAgICAgICAgICB9ID0gdGFyZ2V0UmFuZ2U7XG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIG1pc21hdGNoIGJldHdlZW4gdGhlIG5hdGl2ZSBhbmQgc2xhdGUgc2VsZWN0aW9uIGJlaW5nIGNvbGxhcHNlZFxuICAgICAgICAgIC8vIHdlIGFyZSBtb3N0IGxpa2VseSBkZWxldGluZyBhIHplcm8td2lkdGggcGxhY2Vob2xkZXIgYW5kIHRodXMgc2hvdWxkIHBlcmZvcm0gaXRcbiAgICAgICAgICAvLyBhcyBhbiBhY3Rpb24gdG8gZW5zdXJlIGNvcnJlY3QgYmVoYXZpb3IgKG1vc3RseSBoYXBwZW5zIHdpdGggbWFyayBwbGFjZWhvbGRlcnMpXG4gICAgICAgICAgdmFyIG5hdGl2ZUNvbGxhcHNlZCA9IGlzRE9NU2VsZWN0aW9uKG5hdGl2ZVRhcmdldFJhbmdlKSA/IG5hdGl2ZVRhcmdldFJhbmdlLmlzQ29sbGFwc2VkIDogISEoKF9uYXRpdmVUYXJnZXRSYW5nZSA9IG5hdGl2ZVRhcmdldFJhbmdlKSAhPT0gbnVsbCAmJiBfbmF0aXZlVGFyZ2V0UmFuZ2UgIT09IHZvaWQgMCAmJiBfbmF0aXZlVGFyZ2V0UmFuZ2UuY29sbGFwc2VkKTtcbiAgICAgICAgICBpZiAoY2FuU3RvcmVEaWZmICYmIG5hdGl2ZUNvbGxhcHNlZCAmJiBSYW5nZS5pc0NvbGxhcHNlZCh0YXJnZXRSYW5nZSkgJiYgX2FuY2hvci5vZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmVEaWZmKF9hbmNob3IucGF0aCwge1xuICAgICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgICAgc3RhcnQ6IF9hbmNob3Iub2Zmc2V0IC0gMSxcbiAgICAgICAgICAgICAgZW5kOiBfYW5jaG9yLm9mZnNldFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yKSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2RlbGV0ZUVudGlyZVNvZnRMaW5lJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAnZGVsZXRlSGFyZExpbmVCYWNrd2FyZCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ2Jsb2NrJ1xuICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAnZGVsZXRlU29mdExpbmVCYWNrd2FyZCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgfSksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlICdkZWxldGVIYXJkTGluZUZvcndhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ2Jsb2NrJ1xuICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAnZGVsZXRlU29mdExpbmVGb3J3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAnZGVsZXRlV29yZEJhY2t3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnd29yZCdcbiAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2RlbGV0ZVdvcmRGb3J3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICd3b3JkJ1xuICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAnaW5zZXJ0TGluZUJyZWFrJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuaW5zZXJ0U29mdEJyZWFrKGVkaXRvciksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlICdpbnNlcnRQYXJhZ3JhcGgnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5pbnNlcnRCcmVhayhlZGl0b3IpLCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAnaW5zZXJ0Q29tcG9zaXRpb25UZXh0JzpcbiAgICAgIGNhc2UgJ2RlbGV0ZUNvbXBvc2l0aW9uVGV4dCc6XG4gICAgICBjYXNlICdpbnNlcnRGcm9tQ29tcG9zaXRpb24nOlxuICAgICAgY2FzZSAnaW5zZXJ0RnJvbURyb3AnOlxuICAgICAgY2FzZSAnaW5zZXJ0RnJvbVBhc3RlJzpcbiAgICAgIGNhc2UgJ2luc2VydEZyb21ZYW5rJzpcbiAgICAgIGNhc2UgJ2luc2VydFJlcGxhY2VtZW50VGV4dCc6XG4gICAgICBjYXNlICdpbnNlcnRUZXh0JzpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChpc0RhdGFUcmFuc2ZlcihkYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IFJlYWN0RWRpdG9yLmluc2VydERhdGEoZWRpdG9yLCBkYXRhKSwge1xuICAgICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgX3RleHQgPSBkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHZvaWQgMCA/IGRhdGEgOiAnJztcbiAgICAgICAgICAvLyBDT01QQVQ6IElmIHdlIGFyZSB3cml0aW5nIGluc2lkZSBhIHBsYWNlaG9sZGVyLCB0aGUgaW1lIGluc2VydHMgdGhlIHRleHQgaW5zaWRlXG4gICAgICAgICAgLy8gdGhlIHBsYWNlaG9sZGVyIGl0c2VsZiBhbmQgdGh1cyBpbmNsdWRlcyB0aGUgemVyby13aWR0aCBzcGFjZSBpbnNpZGUgZWRpdCBldmVudHMuXG4gICAgICAgICAgaWYgKEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5nZXQoZWRpdG9yKSkge1xuICAgICAgICAgICAgX3RleHQgPSBfdGV4dC5yZXBsYWNlKCdcXHVGRUZGJywgJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBQYXN0ZXMgZnJvbSB0aGUgQW5kcm9pZCBjbGlwYm9hcmQgd2lsbCBnZW5lcmF0ZSBgaW5zZXJ0VGV4dGAgZXZlbnRzLlxuICAgICAgICAgIC8vIElmIHRoZSBjb3BpZWQgdGV4dCBjb250YWlucyBhbnkgbmV3bGluZXMsIEFuZHJvaWQgd2lsbCBhcHBlbmQgYW5cbiAgICAgICAgICAvLyBleHRyYSBuZXdsaW5lIHRvIHRoZSBlbmQgb2YgdGhlIGNvcGllZCB0ZXh0LlxuICAgICAgICAgIGlmICh0eXBlID09PSAnaW5zZXJ0VGV4dCcgJiYgLy4qXFxuLipcXG4kLy50ZXN0KF90ZXh0KSkge1xuICAgICAgICAgICAgX3RleHQgPSBfdGV4dC5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIElmIHRoZSB0ZXh0IGluY2x1ZGVzIGEgbmV3bGluZSwgc3BsaXQgaXQgYXQgbmV3bGluZXMgYW5kIHBhc3RlIGVhY2ggY29tcG9uZW50XG4gICAgICAgICAgLy8gc3RyaW5nLCB3aXRoIHNvZnQgYnJlYWtzIGluIGJldHdlZW4gZWFjaC5cbiAgICAgICAgICBpZiAoX3RleHQuaW5jbHVkZXMoJ1xcbicpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4ge1xuICAgICAgICAgICAgICB2YXIgcGFydHMgPSBfdGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgIHBhcnRzLmZvckVhY2goKGxpbmUsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgICAgICAgICAgRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBsaW5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IHBhcnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgIEVkaXRvci5pbnNlcnRTb2Z0QnJlYWsoZWRpdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHModGFyZ2V0UmFuZ2UuYW5jaG9yLnBhdGgsIHRhcmdldFJhbmdlLmZvY3VzLnBhdGgpKSB7XG4gICAgICAgICAgICB2YXIgW19zdGFydCwgX2VuZF0gPSBSYW5nZS5lZGdlcyh0YXJnZXRSYW5nZSk7XG4gICAgICAgICAgICB2YXIgX2RpZmYgPSB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBfc3RhcnQub2Zmc2V0LFxuICAgICAgICAgICAgICBlbmQ6IF9lbmQub2Zmc2V0LFxuICAgICAgICAgICAgICB0ZXh0OiBfdGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIENPTVBBVDogU3dpZnRrZXkgaGFzIGEgd2VpcmQgYnVnIHdoZXJlIHRoZSB0YXJnZXQgcmFuZ2Ugb2YgdGhlIDJuZCB3b3JkXG4gICAgICAgICAgICAvLyBpbnNlcnRlZCBhZnRlciBhIG1hcmsgcGxhY2Vob2xkZXIgaXMgaW5zZXJ0ZWQgd2l0aCBhbiBhbmNob3Igb2Zmc2V0IG9mZiBieSAxLlxuICAgICAgICAgICAgLy8gU28gd3JpdGluZyAnc29tZSB0ZXh0JyB3aWxsIHJlc3VsdCBpbiAnc29tZSB0dGV4dCcuIEx1Y2tpbHkgYWxsICdub3JtYWwnIGluc2VydFxuICAgICAgICAgICAgLy8gdGV4dCBldmVudHMgYXJlIGZpcmVkIHdpdGggdGhlIGNvcnJlY3QgdGFyZ2V0IHJhbmdlcywgb25seSB0aGUgZmluYWwgJ2luc2VydENvbXBvc2l0aW9uJ1xuICAgICAgICAgICAgLy8gaXNuJ3QsIHNvIHdlIGNhbiBhZGp1c3QgdGhlIHRhcmdldCByYW5nZSBzdGFydCBvZmZzZXQgaWYgd2UgYXJlIGNvbmZpZGVudCB0aGlzIGlzIHRoZVxuICAgICAgICAgICAgLy8gc3dpZnRrZXkgaW5zZXJ0IGNhdXNpbmcgdGhlIGlzc3VlLlxuICAgICAgICAgICAgaWYgKF90ZXh0ICYmIGluc2VydFBvc2l0aW9uSGludCAmJiB0eXBlID09PSAnaW5zZXJ0Q29tcG9zaXRpb25UZXh0Jykge1xuICAgICAgICAgICAgICB2YXIgaGludFBvc2l0aW9uID0gaW5zZXJ0UG9zaXRpb25IaW50LnN0YXJ0ICsgaW5zZXJ0UG9zaXRpb25IaW50LnRleHQuc2VhcmNoKC9cXFN8JC8pO1xuICAgICAgICAgICAgICB2YXIgZGlmZlBvc2l0aW9uID0gX2RpZmYuc3RhcnQgKyBfZGlmZi50ZXh0LnNlYXJjaCgvXFxTfCQvKTtcbiAgICAgICAgICAgICAgaWYgKGRpZmZQb3NpdGlvbiA9PT0gaGludFBvc2l0aW9uICsgMSAmJiBfZGlmZi5lbmQgPT09IGluc2VydFBvc2l0aW9uSGludC5zdGFydCArIGluc2VydFBvc2l0aW9uSGludC50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIF9kaWZmLnN0YXJ0IC09IDE7XG4gICAgICAgICAgICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2luc2VydFRleHQnKSB7XG4gICAgICAgICAgICAgIGlmIChpbnNlcnRQb3NpdGlvbkhpbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRQb3NpdGlvbkhpbnQgPSBfZGlmZjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnNlcnRQb3NpdGlvbkhpbnQgJiYgUmFuZ2UuaXNDb2xsYXBzZWQodGFyZ2V0UmFuZ2UpICYmIGluc2VydFBvc2l0aW9uSGludC5lbmQgKyBpbnNlcnRQb3NpdGlvbkhpbnQudGV4dC5sZW5ndGggPT09IF9zdGFydC5vZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRQb3NpdGlvbkhpbnQgPSBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBpbnNlcnRQb3NpdGlvbkhpbnQpLCB7fSwge1xuICAgICAgICAgICAgICAgICAgdGV4dDogaW5zZXJ0UG9zaXRpb25IaW50LnRleHQgKyBfdGV4dFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluc2VydFBvc2l0aW9uSGludCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbnNlcnRQb3NpdGlvbkhpbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW5TdG9yZURpZmYpIHtcbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgICAgICAgICBzdG9yZURpZmYoX3N0YXJ0LnBhdGgsIF9kaWZmKTtcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3UG9pbnQgPSB7XG4gICAgICAgICAgICAgICAgICBwYXRoOiBfc3RhcnQucGF0aCxcbiAgICAgICAgICAgICAgICAgIG9mZnNldDogX3N0YXJ0Lm9mZnNldCArIF90ZXh0Lmxlbmd0aFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVBY3Rpb24oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgICAgIGFuY2hvcjogbmV3UG9pbnQsXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzOiBuZXdQb2ludFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgYXQ6IG5ld1BvaW50XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBfdGV4dCksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgaGFzUGVuZGluZ0FjdGlvbiA9ICgpID0+IHtcbiAgICByZXR1cm4gISFFRElUT1JfVE9fUEVORElOR19BQ1RJT04uZ2V0KGVkaXRvcik7XG4gIH07XG4gIHZhciBoYXNQZW5kaW5nRGlmZnMgPSAoKSA9PiB7XG4gICAgdmFyIF9FRElUT1JfVE9fUEVORElOR19ESTQ7XG4gICAgcmV0dXJuICEhKChfRURJVE9SX1RPX1BFTkRJTkdfREk0ID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGVkaXRvcikpICE9PSBudWxsICYmIF9FRElUT1JfVE9fUEVORElOR19ESTQgIT09IHZvaWQgMCAmJiBfRURJVE9SX1RPX1BFTkRJTkdfREk0Lmxlbmd0aCk7XG4gIH07XG4gIHZhciBoYXNQZW5kaW5nQ2hhbmdlcyA9ICgpID0+IHtcbiAgICByZXR1cm4gaGFzUGVuZGluZ0FjdGlvbigpIHx8IGhhc1BlbmRpbmdEaWZmcygpO1xuICB9O1xuICB2YXIgaXNGbHVzaGluZyA9ICgpID0+IHtcbiAgICByZXR1cm4gZmx1c2hpbmc7XG4gIH07XG4gIHZhciBoYW5kbGVVc2VyU2VsZWN0ID0gcmFuZ2UgPT4ge1xuICAgIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTi5zZXQoZWRpdG9yLCByYW5nZSk7XG4gICAgaWYgKGZsdXNoVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQoZmx1c2hUaW1lb3V0SWQpO1xuICAgICAgZmx1c2hUaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcbiAgICBpZiAoIXJhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwYXRoQ2hhbmdlZCA9ICFzZWxlY3Rpb24gfHwgIVBhdGguZXF1YWxzKHNlbGVjdGlvbi5hbmNob3IucGF0aCwgcmFuZ2UuYW5jaG9yLnBhdGgpO1xuICAgIHZhciBwYXJlbnRQYXRoQ2hhbmdlZCA9ICFzZWxlY3Rpb24gfHwgIVBhdGguZXF1YWxzKHNlbGVjdGlvbi5hbmNob3IucGF0aC5zbGljZSgwLCAtMSksIHJhbmdlLmFuY2hvci5wYXRoLnNsaWNlKDAsIC0xKSk7XG4gICAgaWYgKHBhdGhDaGFuZ2VkICYmIGluc2VydFBvc2l0aW9uSGludCB8fCBwYXJlbnRQYXRoQ2hhbmdlZCkge1xuICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwYXRoQ2hhbmdlZCB8fCBoYXNQZW5kaW5nRGlmZnMoKSkge1xuICAgICAgZmx1c2hUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZsdXNoLCBGTFVTSF9ERUxBWSk7XG4gICAgfVxuICB9O1xuICB2YXIgaGFuZGxlSW5wdXQgPSAoKSA9PiB7XG4gICAgaWYgKGhhc1BlbmRpbmdBY3Rpb24oKSB8fCAhaGFzUGVuZGluZ0RpZmZzKCkpIHtcbiAgICAgIGZsdXNoKCk7XG4gICAgfVxuICB9O1xuICB2YXIgaGFuZGxlS2V5RG93biA9IF8gPT4ge1xuICAgIC8vIENPTVBBVDogU3dpZnRrZXkgY2xvc2VzIHRoZSBrZXlib2FyZCB3aGVuIHR5cGluZyBpbnNpZGUgYSBlbXB0eSBub2RlXG4gICAgLy8gZGlyZWN0bHkgbmV4dCB0byBhIG5vbi1jb250ZW50ZWRpdGFibGUgZWxlbWVudCAoPSB0aGUgcGxhY2Vob2xkZXIpLlxuICAgIC8vIFRoZSBvbmx5IGV2ZW50IGZpcmVkIHNvb24gZW5vdWdoIGZvciB1cyB0byBhbGxvdyBoaWRpbmcgdGhlIHBsYWNlaG9sZGVyXG4gICAgLy8gd2l0aG91dCBzd2lmdGtleSBwaWNraW5nIGl0IHVwIGlzIHRoZSBrZXlkb3duIGV2ZW50LCBzbyB3ZSBoYXZlIHRvIGhpZGUgaXRcbiAgICAvLyBoZXJlLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2lhbnN0b3JtdGF5bG9yL3NsYXRlL3B1bGwvNDk4OCNpc3N1ZWNvbW1lbnQtMTIwMTA1MDUzNVxuICAgIGlmICghaGFzUGVuZGluZ0RpZmZzKCkpIHtcbiAgICAgIHVwZGF0ZVBsYWNlaG9sZGVyVmlzaWJpbGl0eSh0cnVlKTtcbiAgICAgIHNldFRpbWVvdXQodXBkYXRlUGxhY2Vob2xkZXJWaXNpYmlsaXR5KTtcbiAgICB9XG4gIH07XG4gIHZhciBzY2hlZHVsZUZsdXNoID0gKCkgPT4ge1xuICAgIGlmICghaGFzUGVuZGluZ0FjdGlvbigpKSB7XG4gICAgICBhY3Rpb25UaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZsdXNoKTtcbiAgICB9XG4gIH07XG4gIHZhciBoYW5kbGVEb21NdXRhdGlvbnMgPSBtdXRhdGlvbnMgPT4ge1xuICAgIGlmIChoYXNQZW5kaW5nRGlmZnMoKSB8fCBoYXNQZW5kaW5nQWN0aW9uKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG11dGF0aW9ucy5zb21lKG11dGF0aW9uID0+IGlzVHJhY2tlZE11dGF0aW9uKGVkaXRvciwgbXV0YXRpb24sIG11dGF0aW9ucykpKSB7XG4gICAgICB2YXIgX0VESVRPUl9UT19GT1JDRV9SRU5EO1xuICAgICAgLy8gQ2F1c2UgYSByZS1yZW5kZXIgdG8gcmVzdG9yZSB0aGUgZG9tIHN0YXRlIGlmIHdlIGVuY291bnRlciB0cmFja2VkIG11dGF0aW9ucyB3aXRob3V0XG4gICAgICAvLyBhIGNvcnJlc3BvbmRpbmcgcGVuZGluZyBhY3Rpb24uXG4gICAgICAoX0VESVRPUl9UT19GT1JDRV9SRU5EID0gRURJVE9SX1RPX0ZPUkNFX1JFTkRFUi5nZXQoZWRpdG9yKSkgPT09IG51bGwgfHwgX0VESVRPUl9UT19GT1JDRV9SRU5EID09PSB2b2lkIDAgfHwgX0VESVRPUl9UT19GT1JDRV9SRU5EKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIGZsdXNoLFxuICAgIHNjaGVkdWxlRmx1c2gsXG4gICAgaGFzUGVuZGluZ0RpZmZzLFxuICAgIGhhc1BlbmRpbmdBY3Rpb24sXG4gICAgaGFzUGVuZGluZ0NoYW5nZXMsXG4gICAgaXNGbHVzaGluZyxcbiAgICBoYW5kbGVVc2VyU2VsZWN0LFxuICAgIGhhbmRsZUNvbXBvc2l0aW9uRW5kLFxuICAgIGhhbmRsZUNvbXBvc2l0aW9uU3RhcnQsXG4gICAgaGFuZGxlRE9NQmVmb3JlSW5wdXQsXG4gICAgaGFuZGxlS2V5RG93bixcbiAgICBoYW5kbGVEb21NdXRhdGlvbnMsXG4gICAgaGFuZGxlSW5wdXRcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlSXNNb3VudGVkKCkge1xuICB2YXIgaXNNb3VudGVkUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gaXNNb3VudGVkUmVmLmN1cnJlbnQ7XG59XG5cbi8qKlxuICogUHJldmVudCB3YXJuaW5nIG9uIFNTUiBieSBmYWxsaW5nIGJhY2sgdG8gdXNlRWZmZWN0IHdoZW4gRE9NIGlzbid0IGF2YWlsYWJsZVxuICovXG52YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IENBTl9VU0VfRE9NID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG5mdW5jdGlvbiB1c2VNdXRhdGlvbk9ic2VydmVyKG5vZGUsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIHZhciBbbXV0YXRpb25PYnNlcnZlcl0gPSB1c2VTdGF0ZSgoKSA9PiBuZXcgTXV0YXRpb25PYnNlcnZlcihjYWxsYmFjaykpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAvLyBEaXNjYXJkIG11dGF0aW9ucyBjYXVzZWQgZHVyaW5nIHJlbmRlciBwaGFzZS4gVGhpcyB3b3JrcyBkdWUgdG8gcmVhY3QgY2FsbGluZ1xuICAgIC8vIHVzZUxheW91dEVmZmVjdCBzeW5jaHJvbm91c2x5IGFmdGVyIHRoZSByZW5kZXIgcGhhc2UgYmVmb3JlIHRoZSBuZXh0IHRpY2suXG4gICAgbXV0YXRpb25PYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICB9KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW5vZGUuY3VycmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gYXR0YWNoIE11dGF0aW9uT2JzZXJ2ZXIsIGBub2RlYCBpcyB1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgbXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKG5vZGUuY3VycmVudCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuICgpID0+IG11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9LCBbbXV0YXRpb25PYnNlcnZlciwgbm9kZSwgb3B0aW9uc10pO1xufVxuXG52YXIgX2V4Y2x1ZGVkJDIgPSBbXCJub2RlXCJdO1xuZnVuY3Rpb24gb3duS2V5cyQ2KGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNihlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDYoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDYoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbnZhciBNVVRBVElPTl9PQlNFUlZFUl9DT05GSUckMSA9IHtcbiAgc3VidHJlZTogdHJ1ZSxcbiAgY2hpbGRMaXN0OiB0cnVlLFxuICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG59O1xudmFyIHVzZUFuZHJvaWRJbnB1dE1hbmFnZXIgPSAhSVNfQU5EUk9JRCA/ICgpID0+IG51bGwgOiBfcmVmID0+IHtcbiAgdmFyIHtcbiAgICAgIG5vZGVcbiAgICB9ID0gX3JlZixcbiAgICBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCQyKTtcbiAgaWYgKCFJU19BTkRST0lEKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGVkaXRvciA9IHVzZVNsYXRlU3RhdGljKCk7XG4gIHZhciBpc01vdW50ZWQgPSB1c2VJc01vdW50ZWQoKTtcbiAgdmFyIFtpbnB1dE1hbmFnZXJdID0gdXNlU3RhdGUoKCkgPT4gY3JlYXRlQW5kcm9pZElucHV0TWFuYWdlcihfb2JqZWN0U3ByZWFkJDYoe1xuICAgIGVkaXRvclxuICB9LCBvcHRpb25zKSkpO1xuICB1c2VNdXRhdGlvbk9ic2VydmVyKG5vZGUsIGlucHV0TWFuYWdlci5oYW5kbGVEb21NdXRhdGlvbnMsIE1VVEFUSU9OX09CU0VSVkVSX0NPTkZJRyQxKTtcbiAgRURJVE9SX1RPX1NDSEVEVUxFX0ZMVVNILnNldChlZGl0b3IsIGlucHV0TWFuYWdlci5zY2hlZHVsZUZsdXNoKTtcbiAgaWYgKGlzTW91bnRlZCkge1xuICAgIGlucHV0TWFuYWdlci5mbHVzaCgpO1xuICB9XG4gIHJldHVybiBpbnB1dE1hbmFnZXI7XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDUoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ1KGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkNShPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkNShPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuLyoqXG4gKiBMZWFmIGNvbnRlbnQgc3RyaW5ncy5cbiAqL1xudmFyIFN0cmluZyQxID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGlzTGFzdCxcbiAgICBsZWFmLFxuICAgIHBhcmVudCxcbiAgICB0ZXh0XG4gIH0gPSBwcm9wcztcbiAgdmFyIGVkaXRvciA9IHVzZVNsYXRlU3RhdGljKCk7XG4gIHZhciBwYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCB0ZXh0KTtcbiAgdmFyIHBhcmVudFBhdGggPSBQYXRoLnBhcmVudChwYXRoKTtcbiAgdmFyIGlzTWFya1BsYWNlaG9sZGVyID0gQm9vbGVhbihsZWFmW01BUktfUExBQ0VIT0xERVJfU1lNQk9MXSk7XG4gIC8vIENPTVBBVDogUmVuZGVyIHRleHQgaW5zaWRlIHZvaWQgbm9kZXMgd2l0aCBhIHplcm8td2lkdGggc3BhY2UuXG4gIC8vIFNvIHRoZSBub2RlIGNhbiBjb250YWluIHNlbGVjdGlvbiBidXQgdGhlIHRleHQgaXMgbm90IHZpc2libGUuXG4gIGlmIChlZGl0b3IuaXNWb2lkKHBhcmVudCkpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoWmVyb1dpZHRoU3RyaW5nLCB7XG4gICAgICBsZW5ndGg6IE5vZGUuc3RyaW5nKHBhcmVudCkubGVuZ3RoXG4gICAgfSk7XG4gIH1cbiAgLy8gQ09NUEFUOiBJZiB0aGlzIGlzIHRoZSBsYXN0IHRleHQgbm9kZSBpbiBhbiBlbXB0eSBibG9jaywgcmVuZGVyIGEgemVyby1cbiAgLy8gd2lkdGggc3BhY2UgdGhhdCB3aWxsIGNvbnZlcnQgaW50byBhIGxpbmUgYnJlYWsgd2hlbiBjb3B5aW5nIGFuZCBwYXN0aW5nXG4gIC8vIHRvIHN1cHBvcnQgZXhwZWN0ZWQgcGxhaW4gdGV4dC5cbiAgaWYgKGxlYWYudGV4dCA9PT0gJycgJiYgcGFyZW50LmNoaWxkcmVuW3BhcmVudC5jaGlsZHJlbi5sZW5ndGggLSAxXSA9PT0gdGV4dCAmJiAhZWRpdG9yLmlzSW5saW5lKHBhcmVudCkgJiYgRWRpdG9yLnN0cmluZyhlZGl0b3IsIHBhcmVudFBhdGgpID09PSAnJykge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChaZXJvV2lkdGhTdHJpbmcsIHtcbiAgICAgIGlzTGluZUJyZWFrOiB0cnVlLFxuICAgICAgaXNNYXJrUGxhY2Vob2xkZXI6IGlzTWFya1BsYWNlaG9sZGVyXG4gICAgfSk7XG4gIH1cbiAgLy8gQ09NUEFUOiBJZiB0aGUgdGV4dCBpcyBlbXB0eSwgaXQncyBiZWNhdXNlIGl0J3Mgb24gdGhlIGVkZ2Ugb2YgYW4gaW5saW5lXG4gIC8vIG5vZGUsIHNvIHdlIHJlbmRlciBhIHplcm8td2lkdGggc3BhY2Ugc28gdGhhdCB0aGUgc2VsZWN0aW9uIGNhbiBiZVxuICAvLyBpbnNlcnRlZCBuZXh0IHRvIGl0IHN0aWxsLlxuICBpZiAobGVhZi50ZXh0ID09PSAnJykge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChaZXJvV2lkdGhTdHJpbmcsIHtcbiAgICAgIGlzTWFya1BsYWNlaG9sZGVyOiBpc01hcmtQbGFjZWhvbGRlclxuICAgIH0pO1xuICB9XG4gIC8vIENPTVBBVDogQnJvd3NlcnMgd2lsbCBjb2xsYXBzZSB0cmFpbGluZyBuZXcgbGluZXMgYXQgdGhlIGVuZCBvZiBibG9ja3MsXG4gIC8vIHNvIHdlIG5lZWQgdG8gYWRkIGFuIGV4dHJhIHRyYWlsaW5nIG5ldyBsaW5lcyB0byBwcmV2ZW50IHRoYXQuXG4gIGlmIChpc0xhc3QgJiYgbGVhZi50ZXh0LnNsaWNlKC0xKSA9PT0gJ1xcbicpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVGV4dFN0cmluZywge1xuICAgICAgaXNUcmFpbGluZzogdHJ1ZSxcbiAgICAgIHRleHQ6IGxlYWYudGV4dFxuICAgIH0pO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUZXh0U3RyaW5nLCB7XG4gICAgdGV4dDogbGVhZi50ZXh0XG4gIH0pO1xufTtcbi8qKlxuICogTGVhZiBzdHJpbmdzIHdpdGggdGV4dCBpbiB0aGVtLlxuICovXG52YXIgVGV4dFN0cmluZyA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICB0ZXh0LFxuICAgIGlzVHJhaWxpbmcgPSBmYWxzZVxuICB9ID0gcHJvcHM7XG4gIHZhciByZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBnZXRUZXh0Q29udGVudCA9ICgpID0+IHtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQodGV4dCAhPT0gbnVsbCAmJiB0ZXh0ICE9PSB2b2lkIDAgPyB0ZXh0IDogJycpLmNvbmNhdChpc1RyYWlsaW5nID8gJ1xcbicgOiAnJyk7XG4gIH07XG4gIHZhciBbaW5pdGlhbFRleHRdID0gdXNlU3RhdGUoZ2V0VGV4dENvbnRlbnQpO1xuICAvLyBUaGlzIGlzIHRoZSBhY3R1YWwgdGV4dCByZW5kZXJpbmcgYm91bmRhcnkgd2hlcmUgd2UgaW50ZXJmYWNlIHdpdGggdGhlIERPTVxuICAvLyBUaGUgdGV4dCBpcyBub3QgcmVuZGVyZWQgYXMgcGFydCBvZiB0aGUgdmlydHVhbCBET00sIGFzIHNpbmNlIHdlIGhhbmRsZSBiYXNpYyBjaGFyYWN0ZXIgaW5zZXJ0aW9ucyBuYXRpdmVseSxcbiAgLy8gdXBkYXRpbmcgdGhlIERPTSBpcyBub3QgYSBvbmUgd2F5IGRhdGFmbG93IGFueW1vcmUuIFdoYXQgd2UgbmVlZCBoZXJlIGlzIG5vdCByZWNvbmNpbGlhdGlvbiBhbmQgZGlmZmluZ1xuICAvLyB3aXRoIHByZXZpb3VzIHZlcnNpb24gb2YgdGhlIHZpcnR1YWwgRE9NLCBidXQgcmF0aGVyIGRpZmZpbmcgd2l0aCB0aGUgYWN0dWFsIERPTSBlbGVtZW50LCBhbmQgcmVwbGFjZSB0aGUgRE9NIDxzcGFuPiBjb250ZW50XG4gIC8vIGV4YWN0bHkgaWYgYW5kIG9ubHkgaWYgaXRzIGN1cnJlbnQgY29udGVudCBkb2VzIG5vdCBtYXRjaCBvdXIgY3VycmVudCB2aXJ0dWFsIERPTS5cbiAgLy8gT3RoZXJ3aXNlIHRoZSBET00gVGV4dE5vZGUgd291bGQgYWx3YXlzIGJlIHJlcGxhY2VkIGJ5IFJlYWN0IGFzIHRoZSB1c2VyIHR5cGVzLCB3aGljaCBpbnRlcmZlcmVzIHdpdGggbmF0aXZlIHRleHQgZmVhdHVyZXMsXG4gIC8vIGVnIG1ha2VzIG5hdGl2ZSBzcGVsbGNoZWNrIG9wdCBvdXQgZnJvbSBjaGVja2luZyB0aGUgdGV4dCBub2RlLlxuICAvLyB1c2VMYXlvdXRFZmZlY3Q6IHVwZGF0aW5nIG91ciBzcGFuIGJlZm9yZSBicm93c2VyIHBhaW50XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIC8vIG51bGwgY29hbGVzY2luZyB0ZXh0IHRvIG1ha2Ugc3VyZSB3ZSdyZSBub3Qgb3V0cHV0aW5nIFwibnVsbFwiIGFzIGEgc3RyaW5nIGluIHRoZSBleHRyZW1lIGNhc2UgaXQgaXMgbnVsbGlzaCBhdCBydW50aW1lXG4gICAgdmFyIHRleHRXaXRoVHJhaWxpbmcgPSBnZXRUZXh0Q29udGVudCgpO1xuICAgIGlmIChyZWYuY3VycmVudCAmJiByZWYuY3VycmVudC50ZXh0Q29udGVudCAhPT0gdGV4dFdpdGhUcmFpbGluZykge1xuICAgICAgcmVmLmN1cnJlbnQudGV4dENvbnRlbnQgPSB0ZXh0V2l0aFRyYWlsaW5nO1xuICAgIH1cbiAgICAvLyBpbnRlbnRpb25hbGx5IG5vdCBzcGVjaWZ5aW5nIGRlcGVuZGVuY2llcywgc28gdGhhdCB0aGlzIGVmZmVjdCBydW5zIG9uIGV2ZXJ5IHJlbmRlclxuICAgIC8vIGFzIHRoaXMgZWZmZWN0aXZlbHkgcmVwbGFjZXMgXCJzcGVjaWZ5aW5nIHRoZSB0ZXh0IGluIHRoZSB2aXJ0dWFsIERPTSB1bmRlciB0aGUgPHNwYW4+IGJlbG93XCIgb24gZWFjaCByZW5kZXJcbiAgfSk7XG4gIC8vIFdlIGludGVudGlvbmFsbHkgcmVuZGVyIGEgbWVtb2l6ZWQgPHNwYW4+IHRoYXQgb25seSByZWNlaXZlcyB0aGUgaW5pdGlhbCB0ZXh0IGNvbnRlbnQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gIC8vIFdlIGRlZmVyIHRvIHRoZSBsYXlvdXQgZWZmZWN0IGFib3ZlIHRvIHVwZGF0ZSB0aGUgYHRleHRDb250ZW50YCBvZiB0aGUgc3BhbiBlbGVtZW50IHdoZW4gbmVlZGVkLlxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTWVtb2l6ZWRUZXh0JDEsIHtcbiAgICByZWY6IHJlZlxuICB9LCBpbml0aWFsVGV4dCk7XG59O1xudmFyIE1lbW9pemVkVGV4dCQxID0gLyojX19QVVJFX18qL21lbW8oIC8qI19fUFVSRV9fKi9mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIFwiZGF0YS1zbGF0ZS1zdHJpbmdcIjogdHJ1ZSxcbiAgICByZWY6IHJlZlxuICB9LCBwcm9wcy5jaGlsZHJlbik7XG59KSk7XG4vKipcbiAqIExlYWYgc3RyaW5ncyB3aXRob3V0IHRleHQsIHJlbmRlciBhcyB6ZXJvLXdpZHRoIHN0cmluZ3MuXG4gKi9cbnZhciBaZXJvV2lkdGhTdHJpbmcgPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgbGVuZ3RoID0gMCxcbiAgICBpc0xpbmVCcmVhayA9IGZhbHNlLFxuICAgIGlzTWFya1BsYWNlaG9sZGVyID0gZmFsc2VcbiAgfSA9IHByb3BzO1xuICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJzogaXNMaW5lQnJlYWsgPyAnbicgOiAneicsXG4gICAgJ2RhdGEtc2xhdGUtbGVuZ3RoJzogbGVuZ3RoXG4gIH07XG4gIGlmIChpc01hcmtQbGFjZWhvbGRlcikge1xuICAgIGF0dHJpYnV0ZXNbJ2RhdGEtc2xhdGUtbWFyay1wbGFjZWhvbGRlciddID0gdHJ1ZTtcbiAgfVxuICAvLyBGSVhNRTogSW5zZXJ0aW5nIHRoZSBcXHVGRUZGIG9uIGlPUyBicmVha3MgY2FwaXRhbGl6YXRpb24gYXQgdGhlIHN0YXJ0IG9mIGFuXG4gIC8vIGVtcHR5IGVkaXRvciAoaHR0cHM6Ly9naXRodWIuY29tL2lhbnN0b3JtdGF5bG9yL3NsYXRlL2lzc3Vlcy81MTk5KS5cbiAgLy9cbiAgLy8gSG93ZXZlciwgbm90IGluc2VydGluZyB0aGUgXFx1RkVGRiBvbiBpT1MgY2F1c2VzIHRoZSBlZGl0b3IgdG8gY3Jhc2ggd2hlblxuICAvLyBpbnNlcnRpbmcgYW55IHRleHQgdXNpbmcgYW4gSU1FIGF0IHRoZSBzdGFydCBvZiBhIGJsb2NrLiBUaGlzIGFwcGVhcnMgdG9cbiAgLy8gYmUgYmVjYXVzZSBhY2NlcHRpbmcgYW4gSU1FIHN1Z2dlc3Rpb24gd2hlbiBhdCB0aGUgc3RhcnQgb2YgYSBibG9jayAobm9cbiAgLy8gcHJlY2VkaW5nIFxcdUZFRkYpIHJlbW92ZXMgb25lIG9yIG1vcmUgRE9NIGVsZW1lbnRzIHRoYXQgYHRvU2xhdGVSYW5nZWBcbiAgLy8gZGVwZW5kcyBvbi4gKGh0dHBzOi8vZ2l0aHViLmNvbS9pYW5zdG9ybXRheWxvci9zbGF0ZS9pc3N1ZXMvNTcwMylcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBfb2JqZWN0U3ByZWFkJDUoe30sIGF0dHJpYnV0ZXMpLCAhSVNfQU5EUk9JRCB8fCAhaXNMaW5lQnJlYWsgPyAnXFx1RkVGRicgOiBudWxsLCBpc0xpbmVCcmVhayA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYnJcIiwgbnVsbCkgOiBudWxsKTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkNChlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQ0KE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQ0KE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4vLyBEZWxheSB0aGUgcGxhY2Vob2xkZXIgb24gQW5kcm9pZCB0byBwcmV2ZW50IHRoZSBrZXlib2FyZCBmcm9tIGNsb3NpbmcuXG4vLyAoaHR0cHM6Ly9naXRodWIuY29tL2lhbnN0b3JtdGF5bG9yL3NsYXRlL3B1bGwvNTM2OClcbnZhciBQTEFDRUhPTERFUl9ERUxBWSA9IElTX0FORFJPSUQgPyAzMDAgOiAwO1xuZnVuY3Rpb24gZGlzY29ubmVjdFBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIocGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlciwgcmVsZWFzZU9ic2VydmVyKSB7XG4gIGlmIChwbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyLmN1cnJlbnQpIHtcbiAgICBwbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyLmN1cnJlbnQuZGlzY29ubmVjdCgpO1xuICAgIGlmIChyZWxlYXNlT2JzZXJ2ZXIpIHtcbiAgICAgIHBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjbGVhclRpbWVvdXRSZWYodGltZW91dFJlZikge1xuICBpZiAodGltZW91dFJlZi5jdXJyZW50KSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgdGltZW91dFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgfVxufVxudmFyIGRlZmF1bHRSZW5kZXJMZWFmID0gcHJvcHMgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGVmYXVsdExlYWYsIF9vYmplY3RTcHJlYWQkNCh7fSwgcHJvcHMpKTtcbi8qKlxuICogSW5kaXZpZHVhbCBsZWF2ZXMgaW4gYSB0ZXh0IG5vZGUgd2l0aCB1bmlxdWUgZm9ybWF0dGluZy5cbiAqL1xudmFyIExlYWYgPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgbGVhZixcbiAgICBpc0xhc3QsXG4gICAgdGV4dCxcbiAgICBwYXJlbnQsXG4gICAgcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgcmVuZGVyTGVhZiA9IGRlZmF1bHRSZW5kZXJMZWFmLFxuICAgIGxlYWZQb3NpdGlvblxuICB9ID0gcHJvcHM7XG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpO1xuICB2YXIgcGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlciA9IHVzZVJlZihudWxsKTtcbiAgdmFyIHBsYWNlaG9sZGVyUmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgW3Nob3dQbGFjZWhvbGRlciwgc2V0U2hvd1BsYWNlaG9sZGVyXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgdmFyIHNob3dQbGFjZWhvbGRlclRpbWVvdXRSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBjYWxsYmFja1BsYWNlaG9sZGVyUmVmID0gdXNlQ2FsbGJhY2socGxhY2Vob2xkZXJFbCA9PiB7XG4gICAgZGlzY29ubmVjdFBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIocGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlciwgcGxhY2Vob2xkZXJFbCA9PSBudWxsKTtcbiAgICBpZiAocGxhY2Vob2xkZXJFbCA9PSBudWxsKSB7XG4gICAgICB2YXIgX2xlYWYkb25QbGFjZWhvbGRlclJlO1xuICAgICAgRURJVE9SX1RPX1BMQUNFSE9MREVSX0VMRU1FTlQuZGVsZXRlKGVkaXRvcik7XG4gICAgICAoX2xlYWYkb25QbGFjZWhvbGRlclJlID0gbGVhZi5vblBsYWNlaG9sZGVyUmVzaXplKSA9PT0gbnVsbCB8fCBfbGVhZiRvblBsYWNlaG9sZGVyUmUgPT09IHZvaWQgMCB8fCBfbGVhZiRvblBsYWNlaG9sZGVyUmUuY2FsbChsZWFmLCBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgRURJVE9SX1RPX1BMQUNFSE9MREVSX0VMRU1FTlQuc2V0KGVkaXRvciwgcGxhY2Vob2xkZXJFbCk7XG4gICAgICBpZiAoIXBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIuY3VycmVudCkge1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgb2JzZXJ2ZXIgYW5kIG9ic2VydmUgdGhlIHBsYWNlaG9sZGVyIGVsZW1lbnQuXG4gICAgICAgIHZhciBSZXNpemVPYnNlcnZlciQxID0gd2luZG93LlJlc2l6ZU9ic2VydmVyIHx8IFJlc2l6ZU9ic2VydmVyO1xuICAgICAgICBwbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyLmN1cnJlbnQgPSBuZXcgUmVzaXplT2JzZXJ2ZXIkMSgoKSA9PiB7XG4gICAgICAgICAgdmFyIF9sZWFmJG9uUGxhY2Vob2xkZXJSZTI7XG4gICAgICAgICAgKF9sZWFmJG9uUGxhY2Vob2xkZXJSZTIgPSBsZWFmLm9uUGxhY2Vob2xkZXJSZXNpemUpID09PSBudWxsIHx8IF9sZWFmJG9uUGxhY2Vob2xkZXJSZTIgPT09IHZvaWQgMCB8fCBfbGVhZiRvblBsYWNlaG9sZGVyUmUyLmNhbGwobGVhZiwgcGxhY2Vob2xkZXJFbCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlci5jdXJyZW50Lm9ic2VydmUocGxhY2Vob2xkZXJFbCk7XG4gICAgICBwbGFjZWhvbGRlclJlZi5jdXJyZW50ID0gcGxhY2Vob2xkZXJFbDtcbiAgICB9XG4gIH0sIFtwbGFjZWhvbGRlclJlZiwgbGVhZiwgZWRpdG9yXSk7XG4gIHZhciBjaGlsZHJlbiA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFN0cmluZyQxLCB7XG4gICAgaXNMYXN0OiBpc0xhc3QsXG4gICAgbGVhZjogbGVhZixcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICB0ZXh0OiB0ZXh0XG4gIH0pO1xuICB2YXIgbGVhZklzUGxhY2Vob2xkZXIgPSBCb29sZWFuKGxlYWZbUExBQ0VIT0xERVJfU1lNQk9MXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGxlYWZJc1BsYWNlaG9sZGVyKSB7XG4gICAgICBpZiAoIXNob3dQbGFjZWhvbGRlclRpbWVvdXRSZWYuY3VycmVudCkge1xuICAgICAgICAvLyBEZWxheSB0aGUgcGxhY2Vob2xkZXIsIHNvIGl0IHdpbGwgbm90IHJlbmRlciBpbiBhIHNlbGVjdGlvblxuICAgICAgICBzaG93UGxhY2Vob2xkZXJUaW1lb3V0UmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBzZXRTaG93UGxhY2Vob2xkZXIodHJ1ZSk7XG4gICAgICAgICAgc2hvd1BsYWNlaG9sZGVyVGltZW91dFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfSwgUExBQ0VIT0xERVJfREVMQVkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhclRpbWVvdXRSZWYoc2hvd1BsYWNlaG9sZGVyVGltZW91dFJlZik7XG4gICAgICBzZXRTaG93UGxhY2Vob2xkZXIoZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0UmVmKHNob3dQbGFjZWhvbGRlclRpbWVvdXRSZWYpO1xuICB9LCBbbGVhZklzUGxhY2Vob2xkZXIsIHNldFNob3dQbGFjZWhvbGRlcl0pO1xuICBpZiAobGVhZklzUGxhY2Vob2xkZXIgJiYgc2hvd1BsYWNlaG9sZGVyKSB7XG4gICAgdmFyIHBsYWNlaG9sZGVyUHJvcHMgPSB7XG4gICAgICBjaGlsZHJlbjogbGVhZi5wbGFjZWhvbGRlcixcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgJ2RhdGEtc2xhdGUtcGxhY2Vob2xkZXInOiB0cnVlLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICBtYXhXaWR0aDogJzEwMCUnLFxuICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgICAgb3BhY2l0eTogJzAuMzMzJyxcbiAgICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgICAgICAgdGV4dERlY29yYXRpb246ICdub25lJyxcbiAgICAgICAgICAvLyBGaXhlcyBodHRwczovL2dpdGh1Yi5jb20vdWRlY29kZS9wbGF0ZS9pc3N1ZXMvMjMxNVxuICAgICAgICAgIFdlYmtpdFVzZXJNb2RpZnk6IElTX1dFQktJVCA/ICdpbmhlcml0JyA6IHVuZGVmaW5lZFxuICAgICAgICB9LFxuICAgICAgICBjb250ZW50RWRpdGFibGU6IGZhbHNlLFxuICAgICAgICByZWY6IGNhbGxiYWNrUGxhY2Vob2xkZXJSZWZcbiAgICAgIH1cbiAgICB9O1xuICAgIGNoaWxkcmVuID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuLCByZW5kZXJQbGFjZWhvbGRlcihwbGFjZWhvbGRlclByb3BzKSk7XG4gIH1cbiAgLy8gQ09NUEFUOiBIYXZpbmcgdGhlIGBkYXRhLWAgYXR0cmlidXRlcyBvbiB0aGVzZSBsZWFmIGVsZW1lbnRzIGVuc3VyZXMgdGhhdFxuICAvLyBpbiBjZXJ0YWluIG1pc2JlaGF2aW5nIGJyb3dzZXJzIHRoZXkgYXJlbid0IHdlaXJkbHkgY2xvbmVkL2Rlc3Ryb3llZCBieVxuICAvLyBjb250ZW50ZWRpdGFibGUgYmVoYXZpb3JzLiAoMjAxOS8wNS8wOClcbiAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgJ2RhdGEtc2xhdGUtbGVhZic6IHRydWVcbiAgfTtcbiAgcmV0dXJuIHJlbmRlckxlYWYoe1xuICAgIGF0dHJpYnV0ZXMsXG4gICAgY2hpbGRyZW4sXG4gICAgbGVhZixcbiAgICB0ZXh0LFxuICAgIGxlYWZQb3NpdGlvblxuICB9KTtcbn07XG52YXIgTWVtb2l6ZWRMZWFmID0gLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oTGVhZiwgKHByZXYsIG5leHQpID0+IHtcbiAgcmV0dXJuIG5leHQucGFyZW50ID09PSBwcmV2LnBhcmVudCAmJiBuZXh0LmlzTGFzdCA9PT0gcHJldi5pc0xhc3QgJiYgbmV4dC5yZW5kZXJMZWFmID09PSBwcmV2LnJlbmRlckxlYWYgJiYgbmV4dC5yZW5kZXJQbGFjZWhvbGRlciA9PT0gcHJldi5yZW5kZXJQbGFjZWhvbGRlciAmJiBuZXh0LnRleHQgPT09IHByZXYudGV4dCAmJiBUZXh0JDEuZXF1YWxzKG5leHQubGVhZiwgcHJldi5sZWFmKSAmJiBuZXh0LmxlYWZbUExBQ0VIT0xERVJfU1lNQk9MXSA9PT0gcHJldi5sZWFmW1BMQUNFSE9MREVSX1NZTUJPTF07XG59KTtcbnZhciBEZWZhdWx0TGVhZiA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGNoaWxkcmVuXG4gIH0gPSBwcm9wcztcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBfb2JqZWN0U3ByZWFkJDQoe30sIGF0dHJpYnV0ZXMpLCBjaGlsZHJlbik7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHNlbGVjdG9yIHRoYXQgdXBkYXRlcyB3aGVuIGFuIGB1cGRhdGVgIGZ1bmN0aW9uIGlzIGNhbGxlZCwgYW5kXG4gKiB3aGljaCBvbmx5IGNhdXNlcyB0aGUgY29tcG9uZW50IHRvIHJlbmRlciB3aGVuIHRoZSByZXN1bHQgb2YgYHNlbGVjdG9yYFxuICogZGlmZmVycyBmcm9tIHRoZSBwcmV2aW91cyByZXN1bHQgYWNjb3JkaW5nIHRvIGBlcXVhbGl0eUZuYC5cbiAqXG4gKiBJZiBgc2VsZWN0b3JgIGlzIG1lbW9pemVkIHVzaW5nIGB1c2VDYWxsYmFja2AsIHRoZW4gaXQgd2lsbCBvbmx5IGJlIGNhbGxlZFxuICogd2hlbiBpdCBjaGFuZ2VzIG9yIHdoZW4gYHVwZGF0ZWAgaXMgY2FsbGVkLiBPdGhlcndpc2UsIGBzZWxlY3RvcmAgd2lsbCBiZVxuICogY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIGNvbXBvbmVudCByZW5kZXJzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBbc3RhdGUsIHVwZGF0ZV0gPSB1c2VHZW5lcmljU2VsZWN0b3Ioc2VsZWN0b3IsIGVxdWFsaXR5Rm4pXG4gKlxuICogdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gKiAgIHJldHVybiBhZGRFdmVudExpc3RlbmVyKHVwZGF0ZSlcbiAqIH0sIFthZGRFdmVudExpc3RlbmVyLCB1cGRhdGVdKVxuICpcbiAqIHJldHVybiBzdGF0ZVxuICovXG5mdW5jdGlvbiB1c2VHZW5lcmljU2VsZWN0b3Ioc2VsZWN0b3IsIGVxdWFsaXR5Rm4pIHtcbiAgdmFyIFssIGZvcmNlUmVuZGVyXSA9IHVzZVJlZHVjZXIocyA9PiBzICsgMSwgMCk7XG4gIHZhciBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yID0gdXNlUmVmKCk7XG4gIHZhciBsYXRlc3RTZWxlY3RvciA9IHVzZVJlZigoKSA9PiBudWxsKTtcbiAgdmFyIGxhdGVzdFNlbGVjdGVkU3RhdGUgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBzZWxlY3RlZFN0YXRlO1xuICB0cnkge1xuICAgIGlmIChzZWxlY3RvciAhPT0gbGF0ZXN0U2VsZWN0b3IuY3VycmVudCB8fCBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQpIHtcbiAgICAgIHZhciBzZWxlY3RvclJlc3VsdCA9IHNlbGVjdG9yKCk7XG4gICAgICBpZiAoZXF1YWxpdHlGbihsYXRlc3RTZWxlY3RlZFN0YXRlLmN1cnJlbnQsIHNlbGVjdG9yUmVzdWx0KSkge1xuICAgICAgICBzZWxlY3RlZFN0YXRlID0gbGF0ZXN0U2VsZWN0ZWRTdGF0ZS5jdXJyZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0ZWRTdGF0ZSA9IHNlbGVjdG9yUmVzdWx0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3RlZFN0YXRlID0gbGF0ZXN0U2VsZWN0ZWRTdGF0ZS5jdXJyZW50O1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudCAmJiBpc0Vycm9yKGVycikpIHtcbiAgICAgIGVyci5tZXNzYWdlICs9IFwiXFxuVGhlIGVycm9yIG1heSBiZSBjb3JyZWxhdGVkIHdpdGggdGhpcyBwcmV2aW91cyBlcnJvcjpcXG5cIi5jb25jYXQobGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50LnN0YWNrLCBcIlxcblxcblwiKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG4gIGxhdGVzdFNlbGVjdG9yLmN1cnJlbnQgPSBzZWxlY3RvcjtcbiAgbGF0ZXN0U2VsZWN0ZWRTdGF0ZS5jdXJyZW50ID0gc2VsZWN0ZWRTdGF0ZTtcbiAgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICB2YXIgdXBkYXRlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICB2YXIgbmV3U2VsZWN0ZWRTdGF0ZSA9IGxhdGVzdFNlbGVjdG9yLmN1cnJlbnQoKTtcbiAgICAgIGlmIChlcXVhbGl0eUZuKGxhdGVzdFNlbGVjdGVkU3RhdGUuY3VycmVudCwgbmV3U2VsZWN0ZWRTdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGF0ZXN0U2VsZWN0ZWRTdGF0ZS5jdXJyZW50ID0gbmV3U2VsZWN0ZWRTdGF0ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIHdlIGlnbm9yZSBhbGwgZXJyb3JzIGhlcmUsIHNpbmNlIHdoZW4gdGhlIGNvbXBvbmVudFxuICAgICAgLy8gaXMgcmUtcmVuZGVyZWQsIHRoZSBzZWxlY3RvcnMgYXJlIGNhbGxlZCBhZ2FpbiwgYW5kXG4gICAgICAvLyB3aWxsIHRocm93IGFnYWluLCBpZiBuZWl0aGVyIHByb3BzIG5vciBzdG9yZSBzdGF0ZVxuICAgICAgLy8gY2hhbmdlZFxuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudCA9IGVycjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudCA9IG5ldyBFcnJvcihTdHJpbmcoZXJyKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgLy8gZG9uJ3QgcmVyZW5kZXIgb24gZXF1YWxpdHlGbiBjaGFuZ2Ugc2luY2Ugd2Ugd2FudCB0byBiZSBhYmxlIHRvIGRlZmluZSBpdCBpbmxpbmVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtdKTtcbiAgcmV0dXJuIFtzZWxlY3RlZFN0YXRlLCB1cGRhdGVdO1xufVxuZnVuY3Rpb24gaXNFcnJvcihlcnJvcikge1xuICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvcjtcbn1cblxuLyoqXG4gKiBBIFJlYWN0IGNvbnRleHQgZm9yIHNoYXJpbmcgdGhlIGBkZWNvcmF0ZWAgcHJvcCBvZiB0aGUgZWRpdGFibGUgYW5kXG4gKiBzdWJzY3JpYmluZyB0byBjaGFuZ2VzIG9uIHRoaXMgcHJvcC5cbiAqL1xudmFyIERlY29yYXRlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KHt9KTtcbnZhciB1c2VEZWNvcmF0aW9ucyA9IChub2RlLCBwYXJlbnREZWNvcmF0aW9ucykgPT4ge1xuICB2YXIgZWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKTtcbiAgdmFyIHtcbiAgICBkZWNvcmF0ZSxcbiAgICBhZGRFdmVudExpc3RlbmVyXG4gIH0gPSB1c2VDb250ZXh0KERlY29yYXRlQ29udGV4dCk7XG4gIC8vIE5vdCBtZW1vaXplZCBzaW5jZSB3ZSB3YW50IG5vZGVzIHRvIGJlIGRlY29yYXRlZCBvbiBlYWNoIHJlbmRlclxuICB2YXIgc2VsZWN0b3IgPSAoKSA9PiB7XG4gICAgdmFyIHBhdGggPSBSZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIG5vZGUpO1xuICAgIHJldHVybiBkZWNvcmF0ZShbbm9kZSwgcGF0aF0pO1xuICB9O1xuICB2YXIgZXF1YWxpdHlGbiA9IFRleHQkMS5pc1RleHQobm9kZSkgPyBpc1RleHREZWNvcmF0aW9uc0VxdWFsIDogaXNFbGVtZW50RGVjb3JhdGlvbnNFcXVhbDtcbiAgdmFyIFtkZWNvcmF0aW9ucywgdXBkYXRlXSA9IHVzZUdlbmVyaWNTZWxlY3RvcihzZWxlY3RvciwgZXF1YWxpdHlGbik7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHZhciB1bnN1YnNjcmliZSA9IGFkZEV2ZW50TGlzdGVuZXIodXBkYXRlKTtcbiAgICB1cGRhdGUoKTtcbiAgICByZXR1cm4gdW5zdWJzY3JpYmU7XG4gIH0sIFthZGRFdmVudExpc3RlbmVyLCB1cGRhdGVdKTtcbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gWy4uLmRlY29yYXRpb25zLCAuLi5wYXJlbnREZWNvcmF0aW9uc10sIFtkZWNvcmF0aW9ucywgcGFyZW50RGVjb3JhdGlvbnNdKTtcbn07XG52YXIgdXNlRGVjb3JhdGVDb250ZXh0ID0gZGVjb3JhdGVQcm9wID0+IHtcbiAgdmFyIGV2ZW50TGlzdGVuZXJzID0gdXNlUmVmKG5ldyBTZXQoKSk7XG4gIHZhciBsYXRlc3REZWNvcmF0ZSA9IHVzZVJlZihkZWNvcmF0ZVByb3ApO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBsYXRlc3REZWNvcmF0ZS5jdXJyZW50ID0gZGVjb3JhdGVQcm9wO1xuICAgIGV2ZW50TGlzdGVuZXJzLmN1cnJlbnQuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcigpKTtcbiAgfSwgW2RlY29yYXRlUHJvcF0pO1xuICB2YXIgZGVjb3JhdGUgPSB1c2VDYWxsYmFjayhlbnRyeSA9PiBsYXRlc3REZWNvcmF0ZS5jdXJyZW50KGVudHJ5KSwgW10pO1xuICB2YXIgYWRkRXZlbnRMaXN0ZW5lciA9IHVzZUNhbGxiYWNrKGNhbGxiYWNrID0+IHtcbiAgICBldmVudExpc3RlbmVycy5jdXJyZW50LmFkZChjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGV2ZW50TGlzdGVuZXJzLmN1cnJlbnQuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+ICh7XG4gICAgZGVjb3JhdGUsXG4gICAgYWRkRXZlbnRMaXN0ZW5lclxuICB9KSwgW2RlY29yYXRlLCBhZGRFdmVudExpc3RlbmVyXSk7XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQzKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkMyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkMyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxudmFyIGRlZmF1bHRSZW5kZXJUZXh0ID0gcHJvcHMgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGVmYXVsdFRleHQsIF9vYmplY3RTcHJlYWQkMyh7fSwgcHJvcHMpKTtcbi8qKlxuICogVGV4dC5cbiAqL1xudmFyIFRleHQgPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgZGVjb3JhdGlvbnM6IHBhcmVudERlY29yYXRpb25zLFxuICAgIGlzTGFzdCxcbiAgICBwYXJlbnQsXG4gICAgcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgcmVuZGVyTGVhZixcbiAgICByZW5kZXJUZXh0ID0gZGVmYXVsdFJlbmRlclRleHQsXG4gICAgdGV4dFxuICB9ID0gcHJvcHM7XG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpO1xuICB2YXIgcmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgZGVjb3JhdGlvbnMgPSB1c2VEZWNvcmF0aW9ucyh0ZXh0LCBwYXJlbnREZWNvcmF0aW9ucyk7XG4gIHZhciBkZWNvcmF0ZWRMZWF2ZXMgPSBUZXh0JDEuZGVjb3JhdGlvbnModGV4dCwgZGVjb3JhdGlvbnMpO1xuICB2YXIga2V5ID0gUmVhY3RFZGl0b3IuZmluZEtleShlZGl0b3IsIHRleHQpO1xuICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWNvcmF0ZWRMZWF2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIge1xuICAgICAgbGVhZixcbiAgICAgIHBvc2l0aW9uXG4gICAgfSA9IGRlY29yYXRlZExlYXZlc1tpXTtcbiAgICBjaGlsZHJlbi5wdXNoKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChNZW1vaXplZExlYWYsIHtcbiAgICAgIGlzTGFzdDogaXNMYXN0ICYmIGkgPT09IGRlY29yYXRlZExlYXZlcy5sZW5ndGggLSAxLFxuICAgICAga2V5OiBcIlwiLmNvbmNhdChrZXkuaWQsIFwiLVwiKS5jb25jYXQoaSksXG4gICAgICByZW5kZXJQbGFjZWhvbGRlcjogcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgICBsZWFmOiBsZWFmLFxuICAgICAgbGVhZlBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgIHRleHQ6IHRleHQsXG4gICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgIHJlbmRlckxlYWY6IHJlbmRlckxlYWZcbiAgICB9KSk7XG4gIH1cbiAgLy8gVXBkYXRlIGVsZW1lbnQtcmVsYXRlZCB3ZWFrIG1hcHMgd2l0aCB0aGUgRE9NIGVsZW1lbnQgcmVmLlxuICB2YXIgY2FsbGJhY2tSZWYgPSB1c2VDYWxsYmFjayhzcGFuID0+IHtcbiAgICB2YXIgS0VZX1RPX0VMRU1FTlQgPSBFRElUT1JfVE9fS0VZX1RPX0VMRU1FTlQuZ2V0KGVkaXRvcik7XG4gICAgaWYgKHNwYW4pIHtcbiAgICAgIEtFWV9UT19FTEVNRU5UID09PSBudWxsIHx8IEtFWV9UT19FTEVNRU5UID09PSB2b2lkIDAgfHwgS0VZX1RPX0VMRU1FTlQuc2V0KGtleSwgc3Bhbik7XG4gICAgICBOT0RFX1RPX0VMRU1FTlQuc2V0KHRleHQsIHNwYW4pO1xuICAgICAgRUxFTUVOVF9UT19OT0RFLnNldChzcGFuLCB0ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgS0VZX1RPX0VMRU1FTlQgPT09IG51bGwgfHwgS0VZX1RPX0VMRU1FTlQgPT09IHZvaWQgMCB8fCBLRVlfVE9fRUxFTUVOVC5kZWxldGUoa2V5KTtcbiAgICAgIE5PREVfVE9fRUxFTUVOVC5kZWxldGUodGV4dCk7XG4gICAgICBpZiAocmVmLmN1cnJlbnQpIHtcbiAgICAgICAgRUxFTUVOVF9UT19OT0RFLmRlbGV0ZShyZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlZi5jdXJyZW50ID0gc3BhbjtcbiAgfSwgW3JlZiwgZWRpdG9yLCBrZXksIHRleHRdKTtcbiAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgJ2RhdGEtc2xhdGUtbm9kZSc6ICd0ZXh0JyxcbiAgICByZWY6IGNhbGxiYWNrUmVmXG4gIH07XG4gIHJldHVybiByZW5kZXJUZXh0KHtcbiAgICB0ZXh0LFxuICAgIGNoaWxkcmVuLFxuICAgIGF0dHJpYnV0ZXNcbiAgfSk7XG59O1xudmFyIE1lbW9pemVkVGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5tZW1vKFRleHQsIChwcmV2LCBuZXh0KSA9PiB7XG4gIHJldHVybiBuZXh0LnBhcmVudCA9PT0gcHJldi5wYXJlbnQgJiYgbmV4dC5pc0xhc3QgPT09IHByZXYuaXNMYXN0ICYmIG5leHQucmVuZGVyVGV4dCA9PT0gcHJldi5yZW5kZXJUZXh0ICYmIG5leHQucmVuZGVyTGVhZiA9PT0gcHJldi5yZW5kZXJMZWFmICYmIG5leHQucmVuZGVyUGxhY2Vob2xkZXIgPT09IHByZXYucmVuZGVyUGxhY2Vob2xkZXIgJiYgbmV4dC50ZXh0ID09PSBwcmV2LnRleHQgJiYgaXNUZXh0RGVjb3JhdGlvbnNFcXVhbChuZXh0LmRlY29yYXRpb25zLCBwcmV2LmRlY29yYXRpb25zKTtcbn0pO1xudmFyIERlZmF1bHRUZXh0ID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGF0dHJpYnV0ZXMsXG4gICAgY2hpbGRyZW5cbiAgfSA9IHByb3BzO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIF9vYmplY3RTcHJlYWQkMyh7fSwgYXR0cmlidXRlcyksIGNoaWxkcmVuKTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkMihlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDIoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQyKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQyKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgZGVmYXVsdFJlbmRlckVsZW1lbnQgPSBwcm9wcyA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEZWZhdWx0RWxlbWVudCwgX29iamVjdFNwcmVhZCQyKHt9LCBwcm9wcykpO1xuLyoqXG4gKiBFbGVtZW50LlxuICovXG52YXIgRWxlbWVudCA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBkZWNvcmF0aW9uczogcGFyZW50RGVjb3JhdGlvbnMsXG4gICAgZWxlbWVudCxcbiAgICByZW5kZXJFbGVtZW50ID0gZGVmYXVsdFJlbmRlckVsZW1lbnQsXG4gICAgcmVuZGVyQ2h1bmssXG4gICAgcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgcmVuZGVyTGVhZixcbiAgICByZW5kZXJUZXh0XG4gIH0gPSBwcm9wcztcbiAgdmFyIGVkaXRvciA9IHVzZVNsYXRlU3RhdGljKCk7XG4gIHZhciByZWFkT25seSA9IHVzZVJlYWRPbmx5KCk7XG4gIHZhciBpc0lubGluZSA9IGVkaXRvci5pc0lubGluZShlbGVtZW50KTtcbiAgdmFyIGRlY29yYXRpb25zID0gdXNlRGVjb3JhdGlvbnMoZWxlbWVudCwgcGFyZW50RGVjb3JhdGlvbnMpO1xuICB2YXIga2V5ID0gUmVhY3RFZGl0b3IuZmluZEtleShlZGl0b3IsIGVsZW1lbnQpO1xuICB2YXIgcmVmID0gdXNlQ2FsbGJhY2socmVmID0+IHtcbiAgICAvLyBVcGRhdGUgZWxlbWVudC1yZWxhdGVkIHdlYWsgbWFwcyB3aXRoIHRoZSBET00gZWxlbWVudCByZWYuXG4gICAgdmFyIEtFWV9UT19FTEVNRU5UID0gRURJVE9SX1RPX0tFWV9UT19FTEVNRU5ULmdldChlZGl0b3IpO1xuICAgIGlmIChyZWYpIHtcbiAgICAgIEtFWV9UT19FTEVNRU5UID09PSBudWxsIHx8IEtFWV9UT19FTEVNRU5UID09PSB2b2lkIDAgfHwgS0VZX1RPX0VMRU1FTlQuc2V0KGtleSwgcmVmKTtcbiAgICAgIE5PREVfVE9fRUxFTUVOVC5zZXQoZWxlbWVudCwgcmVmKTtcbiAgICAgIEVMRU1FTlRfVE9fTk9ERS5zZXQocmVmLCBlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgS0VZX1RPX0VMRU1FTlQgPT09IG51bGwgfHwgS0VZX1RPX0VMRU1FTlQgPT09IHZvaWQgMCB8fCBLRVlfVE9fRUxFTUVOVC5kZWxldGUoa2V5KTtcbiAgICAgIE5PREVfVE9fRUxFTUVOVC5kZWxldGUoZWxlbWVudCk7XG4gICAgfVxuICB9LCBbZWRpdG9yLCBrZXksIGVsZW1lbnRdKTtcbiAgdmFyIGNoaWxkcmVuID0gdXNlQ2hpbGRyZW4oe1xuICAgIGRlY29yYXRpb25zLFxuICAgIG5vZGU6IGVsZW1lbnQsXG4gICAgcmVuZGVyRWxlbWVudCxcbiAgICByZW5kZXJDaHVuayxcbiAgICByZW5kZXJQbGFjZWhvbGRlcixcbiAgICByZW5kZXJMZWFmLFxuICAgIHJlbmRlclRleHRcbiAgfSk7XG4gIC8vIEF0dHJpYnV0ZXMgdGhhdCB0aGUgZGV2ZWxvcGVyIG11c3QgbWl4IGludG8gdGhlIGVsZW1lbnQgaW4gdGhlaXJcbiAgLy8gY3VzdG9tIG5vZGUgcmVuZGVyZXIgY29tcG9uZW50LlxuICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAnZGF0YS1zbGF0ZS1ub2RlJzogJ2VsZW1lbnQnLFxuICAgIHJlZlxuICB9O1xuICBpZiAoaXNJbmxpbmUpIHtcbiAgICBhdHRyaWJ1dGVzWydkYXRhLXNsYXRlLWlubGluZSddID0gdHJ1ZTtcbiAgfVxuICAvLyBJZiBpdCdzIGEgYmxvY2sgbm9kZSB3aXRoIGlubGluZSBjaGlsZHJlbiwgYWRkIHRoZSBwcm9wZXIgYGRpcmAgYXR0cmlidXRlXG4gIC8vIGZvciB0ZXh0IGRpcmVjdGlvbi5cbiAgaWYgKCFpc0lubGluZSAmJiBFZGl0b3IuaGFzSW5saW5lcyhlZGl0b3IsIGVsZW1lbnQpKSB7XG4gICAgdmFyIHRleHQgPSBOb2RlLnN0cmluZyhlbGVtZW50KTtcbiAgICB2YXIgZGlyID0gZ2V0RGlyZWN0aW9uKHRleHQpO1xuICAgIGlmIChkaXIgPT09ICdydGwnKSB7XG4gICAgICBhdHRyaWJ1dGVzLmRpciA9IGRpcjtcbiAgICB9XG4gIH1cbiAgLy8gSWYgaXQncyBhIHZvaWQgbm9kZSwgd3JhcCB0aGUgY2hpbGRyZW4gaW4gZXh0cmEgdm9pZC1zcGVjaWZpYyBlbGVtZW50cy5cbiAgaWYgKEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBlbGVtZW50KSkge1xuICAgIGF0dHJpYnV0ZXNbJ2RhdGEtc2xhdGUtdm9pZCddID0gdHJ1ZTtcbiAgICBpZiAoIXJlYWRPbmx5ICYmIGlzSW5saW5lKSB7XG4gICAgICBhdHRyaWJ1dGVzLmNvbnRlbnRFZGl0YWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICB2YXIgVGFnID0gaXNJbmxpbmUgPyAnc3BhbicgOiAnZGl2JztcbiAgICB2YXIgW1tfdGV4dF1dID0gTm9kZS50ZXh0cyhlbGVtZW50KTtcbiAgICBjaGlsZHJlbiA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRhZywge1xuICAgICAgXCJkYXRhLXNsYXRlLXNwYWNlclwiOiB0cnVlLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgaGVpZ2h0OiAnMCcsXG4gICAgICAgIGNvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICBvdXRsaW5lOiAnbm9uZScsXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgICB9XG4gICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTWVtb2l6ZWRUZXh0LCB7XG4gICAgICByZW5kZXJQbGFjZWhvbGRlcjogcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgICBkZWNvcmF0aW9uczogW10sXG4gICAgICBpc0xhc3Q6IGZhbHNlLFxuICAgICAgcGFyZW50OiBlbGVtZW50LFxuICAgICAgdGV4dDogX3RleHRcbiAgICB9KSk7XG4gICAgTk9ERV9UT19JTkRFWC5zZXQoX3RleHQsIDApO1xuICAgIE5PREVfVE9fUEFSRU5ULnNldChfdGV4dCwgZWxlbWVudCk7XG4gIH1cbiAgcmV0dXJuIHJlbmRlckVsZW1lbnQoe1xuICAgIGF0dHJpYnV0ZXMsXG4gICAgY2hpbGRyZW4sXG4gICAgZWxlbWVudFxuICB9KTtcbn07XG52YXIgTWVtb2l6ZWRFbGVtZW50ID0gLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oRWxlbWVudCwgKHByZXYsIG5leHQpID0+IHtcbiAgcmV0dXJuIHByZXYuZWxlbWVudCA9PT0gbmV4dC5lbGVtZW50ICYmIHByZXYucmVuZGVyRWxlbWVudCA9PT0gbmV4dC5yZW5kZXJFbGVtZW50ICYmIHByZXYucmVuZGVyQ2h1bmsgPT09IG5leHQucmVuZGVyQ2h1bmsgJiYgcHJldi5yZW5kZXJUZXh0ID09PSBuZXh0LnJlbmRlclRleHQgJiYgcHJldi5yZW5kZXJMZWFmID09PSBuZXh0LnJlbmRlckxlYWYgJiYgcHJldi5yZW5kZXJQbGFjZWhvbGRlciA9PT0gbmV4dC5yZW5kZXJQbGFjZWhvbGRlciAmJiBpc0VsZW1lbnREZWNvcmF0aW9uc0VxdWFsKHByZXYuZGVjb3JhdGlvbnMsIG5leHQuZGVjb3JhdGlvbnMpO1xufSk7XG4vKipcbiAqIFRoZSBkZWZhdWx0IGVsZW1lbnQgcmVuZGVyZXIuXG4gKi9cbnZhciBEZWZhdWx0RWxlbWVudCA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGNoaWxkcmVuLFxuICAgIGVsZW1lbnRcbiAgfSA9IHByb3BzO1xuICB2YXIgZWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKTtcbiAgdmFyIFRhZyA9IGVkaXRvci5pc0lubGluZShlbGVtZW50KSA/ICdzcGFuJyA6ICdkaXYnO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVGFnLCBfb2JqZWN0U3ByZWFkJDIoX29iamVjdFNwcmVhZCQyKHt9LCBhdHRyaWJ1dGVzKSwge30sIHtcbiAgICBzdHlsZToge1xuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgICB9XG4gIH0pLCBjaGlsZHJlbik7XG59O1xuXG4vKipcbiAqIFRyYXZlcnNlIGFuZCBtb2RpZnkgYSBjaHVuayB0cmVlXG4gKi9cbmNsYXNzIENodW5rVHJlZUhlbHBlciB7XG4gIGNvbnN0cnVjdG9yKGNodW5rVHJlZSwgX3JlZikge1xuICAgIHZhciB7XG4gICAgICBjaHVua1NpemUsXG4gICAgICBkZWJ1Z1xuICAgIH0gPSBfcmVmO1xuICAgIC8qKlxuICAgICAqIFRoZSByb290IG9mIHRoZSBjaHVuayB0cmVlXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicm9vdFwiLCB2b2lkIDApO1xuICAgIC8qKlxuICAgICAqIFRoZSBpZGVhbCBzaXplIG9mIGEgY2h1bmtcbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaHVua1NpemVcIiwgdm9pZCAwKTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGRlYnVnIG1vZGUgaXMgZW5hYmxlZFxuICAgICAqXG4gICAgICogSWYgZW5hYmxlZCwgdGhlIHBvaW50ZXIgc3RhdGUgd2lsbCBiZSBjaGVja2VkIGZvciBpbnRlcm5hbCBjb25zaXN0ZW5jeVxuICAgICAqIGFmdGVyIGVhY2ggbXV0YXRpbmcgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlYnVnXCIsIHZvaWQgMCk7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgdHJhdmVyc2FsIGhhcyByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGNodW5rIHRyZWVcbiAgICAgKlxuICAgICAqIFdoZW4gdGhpcyBpcyB0cnVlLCB0aGUgcG9pbnRlckNodW5rIGFuZCBwb2ludGVySW5kZXggcG9pbnQgdG8gdGhlIGxhc3RcbiAgICAgKiB0b3AtbGV2ZWwgbm9kZSBpbiB0aGUgY2h1bmsgdHJlZSwgYWx0aG91Z2ggcG9pbnRlck5vZGUgcmV0dXJucyBudWxsLlxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlYWNoZWRFbmRcIiwgdm9pZCAwKTtcbiAgICAvKipcbiAgICAgKiBUaGUgY2h1bmsgY29udGFpbmluZyB0aGUgY3VycmVudCBub2RlXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicG9pbnRlckNodW5rXCIsIHZvaWQgMCk7XG4gICAgLyoqXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IG5vZGUgd2l0aGluIHBvaW50ZXJDaHVua1xuICAgICAqXG4gICAgICogQ2FuIGJlIC0xIHRvIGluZGljYXRlIHRoYXQgdGhlIHBvaW50ZXIgaXMgYmVmb3JlIHRoZSBzdGFydCBvZiB0aGUgdHJlZS5cbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwb2ludGVySW5kZXhcIiwgdm9pZCAwKTtcbiAgICAvKipcbiAgICAgKiBTaW1pbGFyIHRvIGEgU2xhdGUgcGF0aDsgdHJhY2tzIHRoZSBwYXRoIG9mIHBvaW50ZXJDaHVuayByZWxhdGl2ZSB0byB0aGVcbiAgICAgKiByb290LlxuICAgICAqXG4gICAgICogVXNlZCB0byBtb3ZlIHRoZSBwb2ludGVyIGZyb20gdGhlIGN1cnJlbnQgY2h1bmsgdG8gdGhlIHBhcmVudCBjaHVuayBtb3JlXG4gICAgICogZWZmaWNpZW50bHkuXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicG9pbnRlckluZGV4U3RhY2tcIiwgdm9pZCAwKTtcbiAgICAvKipcbiAgICAgKiBJbmRleGluZyB0aGUgY3VycmVudCBjaHVuaydzIGNoaWxkcmVuIGhhcyBhIHNsaWdodCB0aW1lIGNvc3QsIHdoaWNoIGFkZHMgdXBcbiAgICAgKiB3aGVuIHRyYXZlcnNpbmcgdmVyeSBsYXJnZSB0cmVlcywgc28gdGhlIGN1cnJlbnQgbm9kZSBpcyBjYWNoZWQuXG4gICAgICpcbiAgICAgKiBBIHZhbHVlIG9mIHVuZGVmaW5lZCBtZWFucyB0aGF0IHRoZSBjdXJyZW50IG5vZGUgaXMgbm90IGNhY2hlZC4gVGhpc1xuICAgICAqIHByb3BlcnR5IG11c3QgYmUgc2V0IHRvIHVuZGVmaW5lZCB3aGVuZXZlciB0aGUgcG9pbnRlciBpcyBtb3ZlZCwgdW5sZXNzXG4gICAgICogdGhlIHBvaW50ZXIgaXMgZ3VhcmFudGVlZCB0byBwb2ludCB0byB0aGUgc2FtZSBub2RlIHRoYXQgaXQgZGlkIHByZXZpb3VzbHkuXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2FjaGVkUG9pbnRlck5vZGVcIiwgdm9pZCAwKTtcbiAgICB0aGlzLnJvb3QgPSBjaHVua1RyZWU7XG4gICAgdGhpcy5jaHVua1NpemUgPSBjaHVua1NpemU7XG4gICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICB0aGlzLmRlYnVnID0gZGVidWcgIT09IG51bGwgJiYgZGVidWcgIT09IHZvaWQgMCA/IGRlYnVnIDogZmFsc2U7XG4gICAgdGhpcy5wb2ludGVyQ2h1bmsgPSBjaHVua1RyZWU7XG4gICAgdGhpcy5wb2ludGVySW5kZXggPSAtMTtcbiAgICB0aGlzLnBvaW50ZXJJbmRleFN0YWNrID0gW107XG4gICAgdGhpcy5yZWFjaGVkRW5kID0gZmFsc2U7XG4gICAgdGhpcy52YWxpZGF0ZVN0YXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIE1vdmUgdGhlIHBvaW50ZXIgdG8gdGhlIG5leHQgbGVhZiBpbiB0aGUgY2h1bmsgdHJlZVxuICAgKi9cbiAgcmVhZExlYWYoKSB7XG4gICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICBpZiAodGhpcy5yZWFjaGVkRW5kKSByZXR1cm4gbnVsbDtcbiAgICAvLyBHZXQgdGhlIG5leHQgc2libGluZyBvciBhdW50IG5vZGVcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKHRoaXMucG9pbnRlckluZGV4ICsgMSA8IHRoaXMucG9pbnRlclNpYmxpbmdzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnBvaW50ZXJJbmRleCsrO1xuICAgICAgICB0aGlzLmNhY2hlZFBvaW50ZXJOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5wb2ludGVyQ2h1bmsudHlwZSA9PT0gJ3Jvb3QnKSB7XG4gICAgICAgIHRoaXMucmVhY2hlZEVuZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leGl0Q2h1bmsoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy52YWxpZGF0ZVN0YXRlKCk7XG4gICAgLy8gSWYgdGhlIG5leHQgc2libGluZyBvciBhdW50IGlzIGEgY2h1bmssIGRlc2NlbmQgaW50byBpdFxuICAgIHRoaXMuZW50ZXJDaHVua1VudGlsTGVhZihmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRlck5vZGU7XG4gIH1cbiAgLyoqXG4gICAqIE1vdmUgdGhlIHBvaW50ZXIgdG8gdGhlIHByZXZpb3VzIGxlYWYgaW4gdGhlIGNodW5rIHRyZWVcbiAgICovXG4gIHJldHVyblRvUHJldmlvdXNMZWFmKCkge1xuICAgIC8vIElmIHdlIHdlcmUgYXQgdGhlIGVuZCBvZiB0aGUgdHJlZSwgZGVzY2VuZCBpbnRvIHRoZSBlbmQgb2YgdGhlIGxhc3RcbiAgICAvLyBjaHVuayBpbiB0aGUgdHJlZVxuICAgIGlmICh0aGlzLnJlYWNoZWRFbmQpIHtcbiAgICAgIHRoaXMucmVhY2hlZEVuZCA9IGZhbHNlO1xuICAgICAgdGhpcy5lbnRlckNodW5rVW50aWxMZWFmKHRydWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIHByZXZpb3VzIHNpYmxpbmcgb3IgYXVudCBub2RlXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICh0aGlzLnBvaW50ZXJJbmRleCA+PSAxKSB7XG4gICAgICAgIHRoaXMucG9pbnRlckluZGV4LS07XG4gICAgICAgIHRoaXMuY2FjaGVkUG9pbnRlck5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnBvaW50ZXJDaHVuay50eXBlID09PSAncm9vdCcpIHtcbiAgICAgICAgdGhpcy5wb2ludGVySW5kZXggPSAtMTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leGl0Q2h1bmsoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy52YWxpZGF0ZVN0YXRlKCk7XG4gICAgLy8gSWYgdGhlIHByZXZpb3VzIHNpYmxpbmcgb3IgYXVudCBpcyBhIGNodW5rLCBkZXNjZW5kIGludG8gaXRcbiAgICB0aGlzLmVudGVyQ2h1bmtVbnRpbExlYWYodHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBsZWF2ZXMgYmVmb3JlIHRoZSBjdXJyZW50IGxlYWYsIGxlYXZpbmcgdGhlIHBvaW50ZXIgdW5jaGFuZ2VkXG4gICAqL1xuICBpbnNlcnRCZWZvcmUobGVhdmVzKSB7XG4gICAgdGhpcy5yZXR1cm5Ub1ByZXZpb3VzTGVhZigpO1xuICAgIHRoaXMuaW5zZXJ0QWZ0ZXIobGVhdmVzKTtcbiAgICB0aGlzLnJlYWRMZWFmKCk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBsZWF2ZXMgYWZ0ZXIgdGhlIGN1cnJlbnQgbGVhZiwgbGVhdmluZyB0aGUgcG9pbnRlciBvbiB0aGUgbGFzdFxuICAgKiBpbnNlcnRlZCBsZWFmXG4gICAqXG4gICAqIFRoZSBpbnNlcnRpb24gYWxnb3JpdGhtIGZpcnN0IGNoZWNrcyBmb3IgYW55IGNodW5rIHdlJ3JlIGN1cnJlbnRseSBhdCB0aGVcbiAgICogZW5kIG9mIHRoYXQgY2FuIHJlY2VpdmUgYWRkaXRpb25hbCBsZWF2ZXMuIE5leHQsIGl0IHRyaWVzIHRvIGluc2VydCBsZWF2ZXNcbiAgICogYXQgdGhlIHN0YXJ0cyBvZiBhbnkgc3Vic2VxdWVudCBjaHVua3MuXG4gICAqXG4gICAqIEFueSByZW1haW5pbmcgbGVhdmVzIGFyZSBwYXNzZWQgdG8gcmF3SW5zZXJ0QWZ0ZXIgdG8gYmUgY2h1bmtlZCBhbmRcbiAgICogaW5zZXJ0ZWQgYXQgdGhlIGhpZ2hlc3QgcG9zc2libGUgbGV2ZWwuXG4gICAqL1xuICBpbnNlcnRBZnRlcihsZWF2ZXMpIHtcbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgIGlmIChsZWF2ZXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgdmFyIGJlZm9yZURlcHRoID0gMDtcbiAgICB2YXIgYWZ0ZXJEZXB0aCA9IDA7XG4gICAgLy8gV2hpbGUgYXQgdGhlIGVuZCBvZiBhIGNodW5rLCBpbnNlcnQgYW55IGxlYXZlcyB0aGF0IHdpbGwgZml0LCBhbmQgdGhlblxuICAgIC8vIGV4aXQgdGhlIGNodW5rXG4gICAgd2hpbGUgKHRoaXMucG9pbnRlckNodW5rLnR5cGUgPT09ICdjaHVuaycgJiYgdGhpcy5wb2ludGVySW5kZXggPT09IHRoaXMucG9pbnRlclNpYmxpbmdzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHZhciByZW1haW5pbmdDYXBhY2l0eSA9IHRoaXMuY2h1bmtTaXplIC0gdGhpcy5wb2ludGVyU2libGluZ3MubGVuZ3RoO1xuICAgICAgdmFyIHRvSW5zZXJ0Q291bnQgPSBNYXRoLm1pbihyZW1haW5pbmdDYXBhY2l0eSwgbGVhdmVzLmxlbmd0aCk7XG4gICAgICBpZiAodG9JbnNlcnRDb3VudCA+IDApIHtcbiAgICAgICAgdmFyIGxlYXZlc1RvSW5zZXJ0ID0gbGVhdmVzLnNwbGljZSgwLCB0b0luc2VydENvdW50KTtcbiAgICAgICAgdGhpcy5yYXdJbnNlcnRBZnRlcihsZWF2ZXNUb0luc2VydCwgYmVmb3JlRGVwdGgpO1xuICAgICAgfVxuICAgICAgdGhpcy5leGl0Q2h1bmsoKTtcbiAgICAgIGJlZm9yZURlcHRoKys7XG4gICAgfVxuICAgIGlmIChsZWF2ZXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgLy8gU2F2ZSB0aGUgcG9pbnRlciBzbyB0aGF0IHdlIGNhbiBjb21lIGJhY2sgaGVyZSBhZnRlciBpbnNlcnRpbmcgbGVhdmVzXG4gICAgLy8gaW50byB0aGUgc3RhcnRzIG9mIHN1YnNlcXVlbnQgYmxvY2tzXG4gICAgdmFyIHJhd0luc2VydFBvaW50ZXIgPSB0aGlzLnNhdmVQb2ludGVyKCk7XG4gICAgLy8gSWYgbGVhdmVzIGFyZSBpbnNlcnRlZCBpbnRvIHRoZSBzdGFydCBvZiBhIHN1YnNlcXVlbnQgYmxvY2ssIHRoZW4gd2VcbiAgICAvLyBldmVudHVhbGx5IG5lZWQgdG8gcmVzdG9yZSB0aGUgcG9pbnRlciB0byB0aGUgbGFzdCBzdWNoIGluc2VydGVkIGxlYWZcbiAgICB2YXIgZmluYWxQb2ludGVyID0gbnVsbDtcbiAgICAvLyBNb3ZlIHRoZSBwb2ludGVyIGludG8gdGhlIGNodW5rIGNvbnRhaW5pbmcgdGhlIG5leHQgbGVhZiwgaWYgaXQgZXhpc3RzXG4gICAgaWYgKHRoaXMucmVhZExlYWYoKSkge1xuICAgICAgLy8gV2hpbGUgYXQgdGhlIHN0YXJ0IG9mIGEgY2h1bmssIGluc2VydCBhbnkgbGVhdmVzIHRoYXQgd2lsbCBmaXQsIGFuZFxuICAgICAgLy8gdGhlbiBleGl0IHRoZSBjaHVua1xuICAgICAgd2hpbGUgKHRoaXMucG9pbnRlckNodW5rLnR5cGUgPT09ICdjaHVuaycgJiYgdGhpcy5wb2ludGVySW5kZXggPT09IDApIHtcbiAgICAgICAgdmFyIF9yZW1haW5pbmdDYXBhY2l0eSA9IHRoaXMuY2h1bmtTaXplIC0gdGhpcy5wb2ludGVyU2libGluZ3MubGVuZ3RoO1xuICAgICAgICB2YXIgX3RvSW5zZXJ0Q291bnQgPSBNYXRoLm1pbihfcmVtYWluaW5nQ2FwYWNpdHksIGxlYXZlcy5sZW5ndGgpO1xuICAgICAgICBpZiAoX3RvSW5zZXJ0Q291bnQgPiAwKSB7XG4gICAgICAgICAgdmFyIF9sZWF2ZXNUb0luc2VydCA9IGxlYXZlcy5zcGxpY2UoLV90b0luc2VydENvdW50LCBfdG9JbnNlcnRDb3VudCk7XG4gICAgICAgICAgLy8gSW5zZXJ0IHRoZSBsZWF2ZXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBjaHVua1xuICAgICAgICAgIHRoaXMucG9pbnRlckluZGV4ID0gLTE7XG4gICAgICAgICAgdGhpcy5jYWNoZWRQb2ludGVyTm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB0aGlzLnJhd0luc2VydEFmdGVyKF9sZWF2ZXNUb0luc2VydCwgYWZ0ZXJEZXB0aCk7XG4gICAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgYmF0Y2ggb2YgaW5zZXJ0aW9ucyBhdCB0aGUgc3RhcnQgb2YgYVxuICAgICAgICAgIC8vIHN1YnNlcXVlbnQgY2h1bmssIHNldCB0aGUgZmluYWwgcG9pbnRlciB0byB0aGUgbGFzdCBpbnNlcnRlZCBsZWFmXG4gICAgICAgICAgaWYgKCFmaW5hbFBvaW50ZXIpIHtcbiAgICAgICAgICAgIGZpbmFsUG9pbnRlciA9IHRoaXMuc2F2ZVBvaW50ZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5leGl0Q2h1bmsoKTtcbiAgICAgICAgYWZ0ZXJEZXB0aCsrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlc3RvcmVQb2ludGVyKHJhd0luc2VydFBvaW50ZXIpO1xuICAgIC8vIElmIHRoZXJlIGFyZSBsZWF2ZXMgbGVmdCB0byBpbnNlcnQsIGluc2VydCB0aGVtIGJldHdlZW4gdGhlIGVuZCBvZiB0aGVcbiAgICAvLyBwcmV2aW91cyBjaHVuayBhbmQgdGhlIHN0YXJ0IG9mIHRoZSBmaXJzdCBzdWJzZXF1ZW50IGNodW5rLCBvciB3aGVyZXZlclxuICAgIC8vIHRoZSBwb2ludGVyIGVuZGVkIHVwIGFmdGVyIHRoZSBmaXJzdCBiYXRjaCBvZiBpbnNlcnRpb25zXG4gICAgdmFyIG1pbkRlcHRoID0gTWF0aC5tYXgoYmVmb3JlRGVwdGgsIGFmdGVyRGVwdGgpO1xuICAgIHRoaXMucmF3SW5zZXJ0QWZ0ZXIobGVhdmVzLCBtaW5EZXB0aCk7XG4gICAgaWYgKGZpbmFsUG9pbnRlcikge1xuICAgICAgdGhpcy5yZXN0b3JlUG9pbnRlcihmaW5hbFBvaW50ZXIpO1xuICAgIH1cbiAgICB0aGlzLnZhbGlkYXRlU3RhdGUoKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBjdXJyZW50IG5vZGUgYW5kIGRlY3JlbWVudCB0aGUgcG9pbnRlciwgZGVsZXRpbmcgYW55IGFuY2VzdG9yXG4gICAqIGNodW5rIHRoYXQgYmVjb21lcyBlbXB0eSBhcyBhIHJlc3VsdFxuICAgKi9cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMucG9pbnRlclNpYmxpbmdzLnNwbGljZSh0aGlzLnBvaW50ZXJJbmRleC0tLCAxKTtcbiAgICB0aGlzLmNhY2hlZFBvaW50ZXJOb2RlID0gdW5kZWZpbmVkO1xuICAgIGlmICh0aGlzLnBvaW50ZXJTaWJsaW5ncy5sZW5ndGggPT09IDAgJiYgdGhpcy5wb2ludGVyQ2h1bmsudHlwZSA9PT0gJ2NodW5rJykge1xuICAgICAgdGhpcy5leGl0Q2h1bmsoKTtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZUNodW5rKCk7XG4gICAgfVxuICAgIHRoaXMudmFsaWRhdGVTdGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgdGhlIGN1cnJlbnQgY2h1bmsgYW5kIGFsbCBhbmNlc3RvciBjaHVua3MgdG8gdGhlIGxpc3Qgb2YgbW9kaWZpZWRcbiAgICogY2h1bmtzXG4gICAqL1xuICBpbnZhbGlkYXRlQ2h1bmsoKSB7XG4gICAgZm9yICh2YXIgYyA9IHRoaXMucG9pbnRlckNodW5rOyBjLnR5cGUgPT09ICdjaHVuayc7IGMgPSBjLnBhcmVudCkge1xuICAgICAgdGhpcy5yb290Lm1vZGlmaWVkQ2h1bmtzLmFkZChjKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHBvaW50ZXIgaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSB0cmVlXG4gICAqL1xuICBnZXQgYXRTdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludGVyQ2h1bmsudHlwZSA9PT0gJ3Jvb3QnICYmIHRoaXMucG9pbnRlckluZGV4ID09PSAtMTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNpYmxpbmdzIG9mIHRoZSBjdXJyZW50IG5vZGVcbiAgICovXG4gIGdldCBwb2ludGVyU2libGluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRlckNodW5rLmNoaWxkcmVuO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgbm9kZSAodW5jYWNoZWQpXG4gICAqXG4gICAqIElmIHRoZSBwb2ludGVyIGlzIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgdGhlIGRvY3VtZW50LCByZXR1cm5zIG51bGwuXG4gICAqXG4gICAqIFVzdWFsbHksIHRoZSBjdXJyZW50IG5vZGUgaXMgYSBjaHVuayBsZWFmLCBhbHRob3VnaCBpdCBjYW4gYmUgYSBjaHVua1xuICAgKiB3aGlsZSBpbnNlcnRpb25zIGFyZSBpbiBwcm9ncmVzcy5cbiAgICovXG4gIGdldFBvaW50ZXJOb2RlKCkge1xuICAgIGlmICh0aGlzLnJlYWNoZWRFbmQgfHwgdGhpcy5wb2ludGVySW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucG9pbnRlclNpYmxpbmdzW3RoaXMucG9pbnRlckluZGV4XTtcbiAgfVxuICAvKipcbiAgICogQ2FjaGVkIGdldHRlciBmb3IgdGhlIGN1cnJlbnQgbm9kZVxuICAgKi9cbiAgZ2V0IHBvaW50ZXJOb2RlKCkge1xuICAgIGlmICh0aGlzLmNhY2hlZFBvaW50ZXJOb2RlICE9PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLmNhY2hlZFBvaW50ZXJOb2RlO1xuICAgIHZhciBwb2ludGVyTm9kZSA9IHRoaXMuZ2V0UG9pbnRlck5vZGUoKTtcbiAgICB0aGlzLmNhY2hlZFBvaW50ZXJOb2RlID0gcG9pbnRlck5vZGU7XG4gICAgcmV0dXJuIHBvaW50ZXJOb2RlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHBhdGggb2YgYSBjaHVuayByZWxhdGl2ZSB0byB0aGUgcm9vdCwgcmV0dXJuaW5nIG51bGwgaWYgdGhlIGNodW5rXG4gICAqIGlzIG5vdCBjb25uZWN0ZWQgdG8gdGhlIHJvb3RcbiAgICovXG4gIGdldENodW5rUGF0aChjaHVuaykge1xuICAgIHZhciBwYXRoID0gW107XG4gICAgZm9yICh2YXIgYyA9IGNodW5rOyBjLnR5cGUgPT09ICdjaHVuayc7IGMgPSBjLnBhcmVudCkge1xuICAgICAgdmFyIGluZGV4ID0gYy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihjKTtcbiAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcGF0aC51bnNoaWZ0KGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgLyoqXG4gICAqIFNhdmUgdGhlIGN1cnJlbnQgcG9pbnRlciB0byBiZSByZXN0b3JlZCBsYXRlclxuICAgKi9cbiAgc2F2ZVBvaW50ZXIoKSB7XG4gICAgaWYgKHRoaXMuYXRTdGFydCkgcmV0dXJuICdzdGFydCc7XG4gICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICBpZiAoIXRoaXMucG9pbnRlck5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNhdmUgcG9pbnRlciB3aGVuIHBvaW50ZXJOb2RlIGlzIG51bGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNodW5rOiB0aGlzLnBvaW50ZXJDaHVuayxcbiAgICAgIG5vZGU6IHRoaXMucG9pbnRlck5vZGVcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXN0b3JlIHRoZSBwb2ludGVyIHRvIGEgcHJldmlvdXMgc3RhdGVcbiAgICovXG4gIHJlc3RvcmVQb2ludGVyKHNhdmVkUG9pbnRlcikge1xuICAgIGlmIChzYXZlZFBvaW50ZXIgPT09ICdzdGFydCcpIHtcbiAgICAgIHRoaXMucG9pbnRlckNodW5rID0gdGhpcy5yb290O1xuICAgICAgdGhpcy5wb2ludGVySW5kZXggPSAtMTtcbiAgICAgIHRoaXMucG9pbnRlckluZGV4U3RhY2sgPSBbXTtcbiAgICAgIHRoaXMucmVhY2hlZEVuZCA9IGZhbHNlO1xuICAgICAgdGhpcy5jYWNoZWRQb2ludGVyTm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gU2luY2Ugbm9kZXMgbWF5IGhhdmUgYmVlbiBpbnNlcnRlZCBvciByZW1vdmVkIHByaW9yIHRvIHRoZSBzYXZlZFxuICAgIC8vIHBvaW50ZXIgc2luY2UgaXQgd2FzIHNhdmVkLCB0aGUgaW5kZXggYW5kIGluZGV4IHN0YWNrIG11c3QgYmVcbiAgICAvLyByZWNvbXB1dGVkLiBUaGlzIGlzIHNsb3csIGJ1dCB0aGlzIGlzIGZpbmUgc2luY2UgcmVzdG9yaW5nIGEgcG9pbnRlciBpc1xuICAgIC8vIG5vdCBhIGZyZXF1ZW50IG9wZXJhdGlvbi5cbiAgICB2YXIge1xuICAgICAgY2h1bmssXG4gICAgICBub2RlXG4gICAgfSA9IHNhdmVkUG9pbnRlcjtcbiAgICB2YXIgaW5kZXggPSBjaHVuay5jaGlsZHJlbi5pbmRleE9mKG5vZGUpO1xuICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVzdG9yZSBwb2ludCBiZWNhdXNlIHNhdmVkIG5vZGUgaXMgbm8gbG9uZ2VyIGluIHNhdmVkIGNodW5rJyk7XG4gICAgfVxuICAgIHZhciBpbmRleFN0YWNrID0gdGhpcy5nZXRDaHVua1BhdGgoY2h1bmspO1xuICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgaWYgKCFpbmRleFN0YWNrKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZXN0b3JlIHBvaW50IGJlY2F1c2Ugc2F2ZWQgY2h1bmsgaXMgbm8gbG9uZ2VyIGNvbm5lY3RlZCB0byByb290Jyk7XG4gICAgfVxuICAgIHRoaXMucG9pbnRlckNodW5rID0gY2h1bms7XG4gICAgdGhpcy5wb2ludGVySW5kZXggPSBpbmRleDtcbiAgICB0aGlzLnBvaW50ZXJJbmRleFN0YWNrID0gaW5kZXhTdGFjaztcbiAgICB0aGlzLnJlYWNoZWRFbmQgPSBmYWxzZTtcbiAgICB0aGlzLmNhY2hlZFBvaW50ZXJOb2RlID0gbm9kZTtcbiAgICB0aGlzLnZhbGlkYXRlU3RhdGUoKTtcbiAgfVxuICAvKipcbiAgICogQXNzdW1pbmcgdGhlIGN1cnJlbnQgbm9kZSBpcyBhIGNodW5rLCBtb3ZlIHRoZSBwb2ludGVyIGludG8gdGhhdCBjaHVua1xuICAgKlxuICAgKiBAcGFyYW0gZW5kIElmIHRydWUsIHBsYWNlIHRoZSBwb2ludGVyIG9uIHRoZSBsYXN0IG5vZGUgb2YgdGhlIGNodW5rLlxuICAgKiBPdGhlcndpc2UsIHBsYWNlIHRoZSBwb2ludGVyIG9uIHRoZSBmaXJzdCBub2RlLlxuICAgKi9cbiAgZW50ZXJDaHVuayhlbmQpIHtcbiAgICB2YXIgX3RoaXMkcG9pbnRlck5vZGU7XG4gICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICBpZiAoKChfdGhpcyRwb2ludGVyTm9kZSA9IHRoaXMucG9pbnRlck5vZGUpID09PSBudWxsIHx8IF90aGlzJHBvaW50ZXJOb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRwb2ludGVyTm9kZS50eXBlKSAhPT0gJ2NodW5rJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZW50ZXIgbm9uLWNodW5rJyk7XG4gICAgfVxuICAgIHRoaXMucG9pbnRlckluZGV4U3RhY2sucHVzaCh0aGlzLnBvaW50ZXJJbmRleCk7XG4gICAgdGhpcy5wb2ludGVyQ2h1bmsgPSB0aGlzLnBvaW50ZXJOb2RlO1xuICAgIHRoaXMucG9pbnRlckluZGV4ID0gZW5kID8gdGhpcy5wb2ludGVyU2libGluZ3MubGVuZ3RoIC0gMSA6IDA7XG4gICAgdGhpcy5jYWNoZWRQb2ludGVyTm9kZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnZhbGlkYXRlU3RhdGUoKTtcbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgIGlmICh0aGlzLnBvaW50ZXJDaHVuay5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGVudGVyIGVtcHR5IGNodW5rJyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBc3N1bWluZyB0aGUgY3VycmVudCBub2RlIGlzIGEgY2h1bmssIG1vdmUgdGhlIHBvaW50ZXIgaW50byB0aGF0IGNodW5rXG4gICAqIHJlcGVhdGVkbHkgdW50aWwgdGhlIGN1cnJlbnQgbm9kZSBpcyBhIGxlYWZcbiAgICpcbiAgICogQHBhcmFtIGVuZCBJZiB0cnVlLCBwbGFjZSB0aGUgcG9pbnRlciBvbiB0aGUgbGFzdCBub2RlIG9mIHRoZSBjaHVuay5cbiAgICogT3RoZXJ3aXNlLCBwbGFjZSB0aGUgcG9pbnRlciBvbiB0aGUgZmlyc3Qgbm9kZS5cbiAgICovXG4gIGVudGVyQ2h1bmtVbnRpbExlYWYoZW5kKSB7XG4gICAgd2hpbGUgKCgoX3RoaXMkcG9pbnRlck5vZGUyID0gdGhpcy5wb2ludGVyTm9kZSkgPT09IG51bGwgfHwgX3RoaXMkcG9pbnRlck5vZGUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRwb2ludGVyTm9kZTIudHlwZSkgPT09ICdjaHVuaycpIHtcbiAgICAgIHZhciBfdGhpcyRwb2ludGVyTm9kZTI7XG4gICAgICB0aGlzLmVudGVyQ2h1bmsoZW5kKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE1vdmUgdGhlIHBvaW50ZXIgdG8gdGhlIHBhcmVudCBjaHVua1xuICAgKi9cbiAgZXhpdENodW5rKCkge1xuICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgaWYgKHRoaXMucG9pbnRlckNodW5rLnR5cGUgPT09ICdyb290Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZXhpdCByb290Jyk7XG4gICAgfVxuICAgIHZhciBwcmV2aW91c1BvaW50ZXJDaHVuayA9IHRoaXMucG9pbnRlckNodW5rO1xuICAgIHRoaXMucG9pbnRlckNodW5rID0gcHJldmlvdXNQb2ludGVyQ2h1bmsucGFyZW50O1xuICAgIHRoaXMucG9pbnRlckluZGV4ID0gdGhpcy5wb2ludGVySW5kZXhTdGFjay5wb3AoKTtcbiAgICB0aGlzLmNhY2hlZFBvaW50ZXJOb2RlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudmFsaWRhdGVTdGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgbGVhdmVzIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjdXJyZW50IG5vZGUsIGxlYXZpbmcgdGhlIHBvaW50ZXIgb25cbiAgICogdGhlIGxhc3QgaW5zZXJ0ZWQgbGVhZlxuICAgKlxuICAgKiBMZWF2ZXMgYXJlIGNodW5rZWQgYWNjb3JkaW5nIHRvIHRoZSBudW1iZXIgb2Ygbm9kZXMgYWxyZWFkeSBpbiB0aGUgcGFyZW50XG4gICAqIHBsdXMgdGhlIG51bWJlciBvZiBub2RlcyBiZWluZyBpbnNlcnRlZCwgb3IgdGhlIG1pbmltdW0gZGVwdGggaWYgbGFyZ2VyXG4gICAqL1xuICByYXdJbnNlcnRBZnRlcihsZWF2ZXMsIG1pbkRlcHRoKSB7XG4gICAgaWYgKGxlYXZlcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB2YXIgZ3JvdXBJbnRvQ2h1bmtzID0gKGxlYXZlcywgcGFyZW50LCBwZXJDaHVuaykgPT4ge1xuICAgICAgaWYgKHBlckNodW5rID09PSAxKSByZXR1cm4gbGVhdmVzO1xuICAgICAgdmFyIGNodW5rcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNodW5rU2l6ZTsgaSsrKSB7XG4gICAgICAgIHZhciBjaHVua05vZGVzID0gbGVhdmVzLnNsaWNlKGkgKiBwZXJDaHVuaywgKGkgKyAxKSAqIHBlckNodW5rKTtcbiAgICAgICAgaWYgKGNodW5rTm9kZXMubGVuZ3RoID09PSAwKSBicmVhaztcbiAgICAgICAgdmFyIGNodW5rID0ge1xuICAgICAgICAgIHR5cGU6ICdjaHVuaycsXG4gICAgICAgICAga2V5OiBuZXcgS2V5KCksXG4gICAgICAgICAgcGFyZW50LFxuICAgICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgICB9O1xuICAgICAgICBjaHVuay5jaGlsZHJlbiA9IGdyb3VwSW50b0NodW5rcyhjaHVua05vZGVzLCBjaHVuaywgcGVyQ2h1bmsgLyB0aGlzLmNodW5rU2l6ZSk7XG4gICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaHVua3M7XG4gICAgfTtcbiAgICAvLyBEZXRlcm1pbmUgdGhlIGNodW5raW5nIGRlcHRoIGJhc2VkIG9uIHRoZSBudW1iZXIgb2YgZXhpc3Rpbmcgbm9kZXMgaW5cbiAgICAvLyB0aGUgY2h1bmsgYW5kIHRoZSBudW1iZXIgb2Ygbm9kZXMgYmVpbmcgaW5zZXJ0ZWRcbiAgICB2YXIgbmV3VG90YWwgPSB0aGlzLnBvaW50ZXJTaWJsaW5ncy5sZW5ndGggKyBsZWF2ZXMubGVuZ3RoO1xuICAgIHZhciBkZXB0aEZvclRvdGFsID0gMDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5jaHVua1NpemU7IGkgPCBuZXdUb3RhbDsgaSAqPSB0aGlzLmNodW5rU2l6ZSkge1xuICAgICAgZGVwdGhGb3JUb3RhbCsrO1xuICAgIH1cbiAgICAvLyBBIGRlcHRoIG9mIDAgbWVhbnMgbm8gY2h1bmtpbmdcbiAgICB2YXIgZGVwdGggPSBNYXRoLm1heChkZXB0aEZvclRvdGFsLCBtaW5EZXB0aCk7XG4gICAgdmFyIHBlclRvcExldmVsQ2h1bmsgPSBNYXRoLnBvdyh0aGlzLmNodW5rU2l6ZSwgZGVwdGgpO1xuICAgIHZhciBjaHVua3MgPSBncm91cEludG9DaHVua3MobGVhdmVzLCB0aGlzLnBvaW50ZXJDaHVuaywgcGVyVG9wTGV2ZWxDaHVuayk7XG4gICAgdGhpcy5wb2ludGVyU2libGluZ3Muc3BsaWNlKHRoaXMucG9pbnRlckluZGV4ICsgMSwgMCwgLi4uY2h1bmtzKTtcbiAgICB0aGlzLnBvaW50ZXJJbmRleCArPSBjaHVua3MubGVuZ3RoO1xuICAgIHRoaXMuY2FjaGVkUG9pbnRlck5vZGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbnZhbGlkYXRlQ2h1bmsoKTtcbiAgICB0aGlzLnZhbGlkYXRlU3RhdGUoKTtcbiAgfVxuICAvKipcbiAgICogSWYgZGVidWcgbW9kZSBpcyBlbmFibGVkLCBlbnN1cmUgdGhhdCB0aGUgc3RhdGUgaXMgaW50ZXJuYWxseSBjb25zaXN0ZW50XG4gICAqL1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICB2YWxpZGF0ZVN0YXRlKCkge1xuICAgIGlmICghdGhpcy5kZWJ1ZykgcmV0dXJuO1xuICAgIHZhciB2YWxpZGF0ZURlc2NlbmRhbnQgPSBub2RlID0+IHtcbiAgICAgIGlmIChub2RlLnR5cGUgPT09ICdjaHVuaycpIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgfSA9IG5vZGU7XG4gICAgICAgIGlmICghcGFyZW50LmNoaWxkcmVuLmluY2x1ZGVzKG5vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVidWc6IENodW5rIFwiLmNvbmNhdChub2RlLmtleS5pZCwgXCIgaGFzIGFuIGluY29ycmVjdCBwYXJlbnQgcHJvcGVydHlcIikpO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2godmFsaWRhdGVEZXNjZW5kYW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucm9vdC5jaGlsZHJlbi5mb3JFYWNoKHZhbGlkYXRlRGVzY2VuZGFudCk7XG4gICAgaWYgKHRoaXMuY2FjaGVkUG9pbnRlck5vZGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmNhY2hlZFBvaW50ZXJOb2RlICE9PSB0aGlzLmdldFBvaW50ZXJOb2RlKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGVidWc6IFRoZSBjYWNoZWQgcG9pbnRlciBpcyBpbmNvcnJlY3QgYW5kIGhhcyBub3QgYmVlbiBpbnZhbGlkYXRlZCcpO1xuICAgIH1cbiAgICB2YXIgYWN0dWFsSW5kZXhTdGFjayA9IHRoaXMuZ2V0Q2h1bmtQYXRoKHRoaXMucG9pbnRlckNodW5rKTtcbiAgICBpZiAoIWFjdHVhbEluZGV4U3RhY2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGVidWc6IFRoZSBwb2ludGVyIGNodW5rIGlzIG5vdCBjb25uZWN0ZWQgdG8gdGhlIHJvb3QnKTtcbiAgICB9XG4gICAgaWYgKCFQYXRoLmVxdWFscyh0aGlzLnBvaW50ZXJJbmRleFN0YWNrLCBhY3R1YWxJbmRleFN0YWNrKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVidWc6IFRoZSBjYWNoZWQgaW5kZXggc3RhY2sgW1wiLmNvbmNhdCh0aGlzLnBvaW50ZXJJbmRleFN0YWNrLmpvaW4oJywgJyksIFwiXSBkb2VzIG5vdCBtYXRjaCB0aGUgcGF0aCBvZiB0aGUgcG9pbnRlciBjaHVuayBbXCIpLmNvbmNhdChhY3R1YWxJbmRleFN0YWNrLmpvaW4oJywgJyksIFwiXVwiKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVHJhdmVyc2UgYW4gYXJyYXkgb2YgY2hpbGRyZW4sIHByb3ZpZGluZyBoZWxwZXJzIHVzZWZ1bCBmb3IgcmVjb25jaWxpbmcgdGhlXG4gKiBjaGlsZHJlbiBhcnJheSB3aXRoIGEgY2h1bmsgdHJlZVxuICovXG5jbGFzcyBDaGlsZHJlbkhlbHBlciB7XG4gIGNvbnN0cnVjdG9yKGVkaXRvciwgY2hpbGRyZW4pIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJlZGl0b3JcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGlsZHJlblwiLCB2b2lkIDApO1xuICAgIC8qKlxuICAgICAqIFNwYXJzZSBhcnJheSBvZiBTbGF0ZSBub2RlIGtleXMsIGVhY2ggaW5kZXggY29ycmVzcG9uZGluZyB0byBhbiBpbmRleCBpblxuICAgICAqIHRoZSBjaGlsZHJlbiBhcnJheVxuICAgICAqXG4gICAgICogRmV0Y2hpbmcgdGhlIGtleSBmb3IgYSBTbGF0ZSBub2RlIGlzIGV4cGVuc2l2ZSwgc28gd2UgY2FjaGUgdGhlbSBoZXJlLlxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhY2hlZEtleXNcIiwgdm9pZCAwKTtcbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIG5leHQgbm9kZSB0byBiZSByZWFkIGluIHRoZSBjaGlsZHJlbiBhcnJheVxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBvaW50ZXJJbmRleFwiLCB2b2lkIDApO1xuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB0aGlzLmNhY2hlZEtleXMgPSBuZXcgQXJyYXkoY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICB0aGlzLnBvaW50ZXJJbmRleCA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBnaXZlbiBudW1iZXIgb2Ygbm9kZXMsIGFkdmFuY2luZyB0aGUgcG9pbnRlciBieSB0aGF0IGFtb3VudFxuICAgKi9cbiAgcmVhZChuKSB7XG4gICAgLy8gUEVSRjogSWYgb25seSBvbmUgY2hpbGQgd2FzIHJlcXVlc3RlZCAodGhlIG1vc3QgY29tbW9uIGNhc2UpLCB1c2UgYXJyYXlcbiAgICAvLyBpbmRleGluZyBpbnN0ZWFkIG9mIHNsaWNlXG4gICAgaWYgKG4gPT09IDEpIHtcbiAgICAgIHJldHVybiBbdGhpcy5jaGlsZHJlblt0aGlzLnBvaW50ZXJJbmRleCsrXV07XG4gICAgfVxuICAgIHZhciBzbGljZWRDaGlsZHJlbiA9IHRoaXMucmVtYWluaW5nKG4pO1xuICAgIHRoaXMucG9pbnRlckluZGV4ICs9IG47XG4gICAgcmV0dXJuIHNsaWNlZENoaWxkcmVuO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHJlbWFpbmluZyBjaGlsZHJlbiB3aXRob3V0IGFkdmFuY2luZyB0aGUgcG9pbnRlclxuICAgKlxuICAgKiBAcGFyYW0gW21heENoaWxkcmVuXSBMaW1pdCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHJldHVybmVkLlxuICAgKi9cbiAgcmVtYWluaW5nKG1heENoaWxkcmVuKSB7XG4gICAgaWYgKG1heENoaWxkcmVuID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLnNsaWNlKHRoaXMucG9pbnRlckluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uc2xpY2UodGhpcy5wb2ludGVySW5kZXgsIHRoaXMucG9pbnRlckluZGV4ICsgbWF4Q2hpbGRyZW4pO1xuICB9XG4gIC8qKlxuICAgKiBXaGV0aGVyIGFsbCBjaGlsZHJlbiBoYXZlIGJlZW4gcmVhZFxuICAgKi9cbiAgZ2V0IHJlYWNoZWRFbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRlckluZGV4ID49IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciBhIG5vZGUgd2l0aCBhIGdpdmVuIGtleSBhcHBlYXJzIGluIHRoZSB1bnJlYWQgcGFydCBvZiB0aGVcbiAgICogY2hpbGRyZW4gYXJyYXksIGFuZCByZXR1cm4gaXRzIGluZGV4IHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBvaW50ZXIgaWYgc29cbiAgICpcbiAgICogU2VhcmNoaW5nIGZvciB0aGUgbm9kZSBvYmplY3QgaXRzZWxmIHVzaW5nIGluZGV4T2YgaXMgbW9zdCBlZmZpY2llbnQsIGJ1dFxuICAgKiB3aWxsIGZhaWwgdG8gbG9jYXRlIG5vZGVzIHRoYXQgaGF2ZSBiZWVuIG1vZGlmaWVkLiBJbiB0aGlzIGNhc2UsIG5vZGVzXG4gICAqIHNob3VsZCBiZSBpZGVudGlmaWVkIGJ5IHRoZWlyIGtleXMgaW5zdGVhZC5cbiAgICpcbiAgICogU2VhcmNoaW5nIGFuIGFycmF5IG9mIGtleXMgdXNpbmcgaW5kZXhPZiBpcyB2ZXJ5IGluZWZmaWNpZW50IHNpbmNlIGZldGNoaW5nXG4gICAqIHRoZSBrZXlzIGZvciBhbGwgY2hpbGRyZW4gaW4gYWR2YW5jZSBpcyB2ZXJ5IHNsb3cuIEluc2VhZCwgaWYgdGhlIG5vZGVcbiAgICogc2VhcmNoIGZhaWxzIHRvIHJldHVybiBhIHZhbHVlLCBmZXRjaCB0aGUga2V5cyBvZiBlYWNoIHJlbWFpbmluZyBjaGlsZCBvbmVcbiAgICogYnkgb25lIGFuZCBjb21wYXJlIGl0IHRvIHRoZSBrbm93biBrZXkuXG4gICAqL1xuICBsb29rQWhlYWQobm9kZSwga2V5KSB7XG4gICAgdmFyIGVsZW1lbnRSZXN1bHQgPSB0aGlzLmNoaWxkcmVuLmluZGV4T2Yobm9kZSwgdGhpcy5wb2ludGVySW5kZXgpO1xuICAgIGlmIChlbGVtZW50UmVzdWx0ID4gLTEpIHJldHVybiBlbGVtZW50UmVzdWx0IC0gdGhpcy5wb2ludGVySW5kZXg7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMucG9pbnRlckluZGV4OyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNhbmRpZGF0ZU5vZGUgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgdmFyIGNhbmRpZGF0ZUtleSA9IHRoaXMuZmluZEtleShjYW5kaWRhdGVOb2RlLCBpKTtcbiAgICAgIGlmIChjYW5kaWRhdGVLZXkgPT09IGtleSkgcmV0dXJuIGkgLSB0aGlzLnBvaW50ZXJJbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IGFuIGFycmF5IG9mIFNsYXRlIG5vZGVzIHRvIGFuIGFycmF5IG9mIGNodW5rIGxlYXZlcywgZWFjaFxuICAgKiBjb250YWluaW5nIHRoZSBub2RlIGFuZCBpdHMga2V5XG4gICAqL1xuICB0b0NodW5rTGVhdmVzKG5vZGVzLCBzdGFydEluZGV4KSB7XG4gICAgcmV0dXJuIG5vZGVzLm1hcCgobm9kZSwgaSkgPT4gKHtcbiAgICAgIHR5cGU6ICdsZWFmJyxcbiAgICAgIG5vZGUsXG4gICAgICBrZXk6IHRoaXMuZmluZEtleShub2RlLCBzdGFydEluZGV4ICsgaSksXG4gICAgICBpbmRleDogc3RhcnRJbmRleCArIGlcbiAgICB9KSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUga2V5IGZvciBhIFNsYXRlIG5vZGUsIGNhY2hlZCB1c2luZyB0aGUgbm9kZSdzIGluZGV4XG4gICAqL1xuICBmaW5kS2V5KG5vZGUsIGluZGV4KSB7XG4gICAgdmFyIGNhY2hlZEtleSA9IHRoaXMuY2FjaGVkS2V5c1tpbmRleF07XG4gICAgaWYgKGNhY2hlZEtleSkgcmV0dXJuIGNhY2hlZEtleTtcbiAgICB2YXIga2V5ID0gUmVhY3RFZGl0b3IuZmluZEtleSh0aGlzLmVkaXRvciwgbm9kZSk7XG4gICAgdGhpcy5jYWNoZWRLZXlzW2luZGV4XSA9IGtleTtcbiAgICByZXR1cm4ga2V5O1xuICB9XG59XG5cbi8qKlxuICogVXBkYXRlIHRoZSBjaHVuayB0cmVlIHRvIG1hdGNoIHRoZSBjaGlsZHJlbiBhcnJheSwgaW5zZXJ0aW5nLCByZW1vdmluZyBhbmRcbiAqIHVwZGF0aW5nIGRpZmZlcmluZyBub2Rlc1xuICovXG52YXIgcmVjb25jaWxlQ2hpbGRyZW4gPSAoZWRpdG9yLCBfcmVmKSA9PiB7XG4gIHZhciB7XG4gICAgY2h1bmtUcmVlLFxuICAgIGNoaWxkcmVuLFxuICAgIGNodW5rU2l6ZSxcbiAgICByZXJlbmRlckNoaWxkcmVuID0gW10sXG4gICAgb25JbnNlcnQsXG4gICAgb25VcGRhdGUsXG4gICAgb25JbmRleENoYW5nZSxcbiAgICBkZWJ1Z1xuICB9ID0gX3JlZjtcbiAgY2h1bmtUcmVlLm1vZGlmaWVkQ2h1bmtzLmNsZWFyKCk7XG4gIHZhciBjaHVua1RyZWVIZWxwZXIgPSBuZXcgQ2h1bmtUcmVlSGVscGVyKGNodW5rVHJlZSwge1xuICAgIGNodW5rU2l6ZSxcbiAgICBkZWJ1Z1xuICB9KTtcbiAgdmFyIGNoaWxkcmVuSGVscGVyID0gbmV3IENoaWxkcmVuSGVscGVyKGVkaXRvciwgY2hpbGRyZW4pO1xuICB2YXIgdHJlZUxlYWY7XG4gIC8vIFJlYWQgbGVhdmVzIGZyb20gdGhlIHRyZWUgb25lIGJ5IG9uZSwgZWFjaCBvbmUgcmVwcmVzZW50aW5nIGEgc2luZ2xlIFNsYXRlXG4gIC8vIG5vZGUuIEVhY2ggbGVhZiBmcm9tIHRoZSB0cmVlIGlzIGNvbXBhcmVkIHRvIHRoZSBjdXJyZW50IG5vZGUgaW4gdGhlXG4gIC8vIGNoaWxkcmVuIGFycmF5IHRvIGRldGVybWluZSB3aGV0aGVyIG5vZGVzIGhhdmUgYmVlbiBpbnNlcnRlZCwgcmVtb3ZlZCBvclxuICAvLyB1cGRhdGVkLlxuICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAvLyBDaGVjayB3aGVyZSB0aGUgdHJlZSBub2RlIGFwcGVhcnMgaW4gdGhlIGNoaWxkcmVuIGFycmF5LiBJbiB0aGUgbW9zdFxuICAgIC8vIGNvbW1vbiBjYXNlICh3aGVyZSBubyBpbnNlcnRpb25zIG9yIHJlbW92YWxzIGhhdmUgb2NjdXJyZWQpLCB0aGlzIHdpbGwgYmVcbiAgICAvLyAwLiBJZiB0aGUgbm9kZSBoYXMgYmVlbiByZW1vdmVkLCB0aGlzIHdpbGwgYmUgLTEuIElmIG5ldyBub2RlcyBoYXZlIGJlZW5cbiAgICAvLyBpbnNlcnRlZCBiZWZvcmUgdGhlIG5vZGUsIG9yIGlmIHRoZSBub2RlIGhhcyBiZWVuIG1vdmVkIHRvIGEgbGF0ZXJcbiAgICAvLyBwb3NpdGlvbiBpbiB0aGUgc2FtZSBjaGlsZHJlbiBhcnJheSwgdGhpcyB3aWxsIGJlIGEgcG9zaXRpdmUgbnVtYmVyLlxuICAgIHZhciBsb29rQWhlYWQgPSBjaGlsZHJlbkhlbHBlci5sb29rQWhlYWQodHJlZUxlYWYubm9kZSwgdHJlZUxlYWYua2V5KTtcbiAgICAvLyBJZiB0aGUgbm9kZSB3YXMgbW92ZWQsIHdlIHdhbnQgdG8gcmVtb3ZlIGl0IGFuZCBpbnNlcnQgaXQgbGF0ZXIsIHJhdGhlclxuICAgIC8vIHRoZW4gcmUtaW5zZXJ0aW5nIGFsbCBpbnRlcm1lZGlhdGUgbm9kZXMgYmVmb3JlIGl0LlxuICAgIHZhciB3YXNNb3ZlZCA9IGxvb2tBaGVhZCA+IDAgJiYgY2h1bmtUcmVlLm1vdmVkTm9kZUtleXMuaGFzKHRyZWVMZWFmLmtleSk7XG4gICAgLy8gSWYgdGhlIHRyZWUgbGVhZiB3YXMgbW92ZWQgb3IgcmVtb3ZlZCwgcmVtb3ZlIGl0XG4gICAgaWYgKGxvb2tBaGVhZCA9PT0gLTEgfHwgd2FzTW92ZWQpIHtcbiAgICAgIGNodW5rVHJlZUhlbHBlci5yZW1vdmUoKTtcbiAgICAgIHJldHVybiAxOyAvLyBjb250aW51ZVxuICAgIH1cbiAgICAvLyBHZXQgdGhlIG1hdGNoaW5nIFNsYXRlIG5vZGUgYW5kIGFueSBub2RlcyB0aGF0IG1heSBoYXZlIGJlZW4gaW5zZXJ0ZWRcbiAgICAvLyBwcmlvciB0byBpdC4gSW5zZXJ0IHRoZXNlIGludG8gdGhlIGNodW5rIHRyZWUuXG4gICAgdmFyIGluc2VydGVkQ2hpbGRyZW5TdGFydEluZGV4ID0gY2hpbGRyZW5IZWxwZXIucG9pbnRlckluZGV4O1xuICAgIHZhciBpbnNlcnRlZENoaWxkcmVuID0gY2hpbGRyZW5IZWxwZXIucmVhZChsb29rQWhlYWQgKyAxKTtcbiAgICB2YXIgbWF0Y2hpbmdDaGlsZCA9IGluc2VydGVkQ2hpbGRyZW4ucG9wKCk7XG4gICAgaWYgKGluc2VydGVkQ2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB2YXIgX2xlYXZlc1RvSW5zZXJ0ID0gY2hpbGRyZW5IZWxwZXIudG9DaHVua0xlYXZlcyhpbnNlcnRlZENoaWxkcmVuLCBpbnNlcnRlZENoaWxkcmVuU3RhcnRJbmRleCk7XG4gICAgICBjaHVua1RyZWVIZWxwZXIuaW5zZXJ0QmVmb3JlKF9sZWF2ZXNUb0luc2VydCk7XG4gICAgICBpbnNlcnRlZENoaWxkcmVuLmZvckVhY2goKG5vZGUsIHJlbGF0aXZlSW5kZXgpID0+IHtcbiAgICAgICAgb25JbnNlcnQgPT09IG51bGwgfHwgb25JbnNlcnQgPT09IHZvaWQgMCB8fCBvbkluc2VydChub2RlLCBpbnNlcnRlZENoaWxkcmVuU3RhcnRJbmRleCArIHJlbGF0aXZlSW5kZXgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBtYXRjaGluZ0NoaWxkSW5kZXggPSBjaGlsZHJlbkhlbHBlci5wb2ludGVySW5kZXggLSAxO1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgY2h1bmsgdHJlZSBjb250YWlucyB0aGUgbW9zdCByZWNlbnQgdmVyc2lvbiBvZiB0aGUgU2xhdGVcbiAgICAvLyBub2RlXG4gICAgaWYgKHRyZWVMZWFmLm5vZGUgIT09IG1hdGNoaW5nQ2hpbGQpIHtcbiAgICAgIHRyZWVMZWFmLm5vZGUgPSBtYXRjaGluZ0NoaWxkO1xuICAgICAgY2h1bmtUcmVlSGVscGVyLmludmFsaWRhdGVDaHVuaygpO1xuICAgICAgb25VcGRhdGUgPT09IG51bGwgfHwgb25VcGRhdGUgPT09IHZvaWQgMCB8fCBvblVwZGF0ZShtYXRjaGluZ0NoaWxkLCBtYXRjaGluZ0NoaWxkSW5kZXgpO1xuICAgIH1cbiAgICAvLyBVcGRhdGUgdGhlIGluZGV4IGlmIGl0IGhhcyBjaGFuZ2VkXG4gICAgaWYgKHRyZWVMZWFmLmluZGV4ICE9PSBtYXRjaGluZ0NoaWxkSW5kZXgpIHtcbiAgICAgIHRyZWVMZWFmLmluZGV4ID0gbWF0Y2hpbmdDaGlsZEluZGV4O1xuICAgICAgb25JbmRleENoYW5nZSA9PT0gbnVsbCB8fCBvbkluZGV4Q2hhbmdlID09PSB2b2lkIDAgfHwgb25JbmRleENoYW5nZShtYXRjaGluZ0NoaWxkLCBtYXRjaGluZ0NoaWxkSW5kZXgpO1xuICAgIH1cbiAgICAvLyBNYW51YWxseSBpbnZhbGlkYXRlIGNodW5rcyBjb250YWluaW5nIHNwZWNpZmljIGNoaWxkcmVuIHRoYXQgd2Ugd2FudCB0b1xuICAgIC8vIHJlLXJlbmRlclxuICAgIGlmIChyZXJlbmRlckNoaWxkcmVuLmluY2x1ZGVzKG1hdGNoaW5nQ2hpbGRJbmRleCkpIHtcbiAgICAgIGNodW5rVHJlZUhlbHBlci5pbnZhbGlkYXRlQ2h1bmsoKTtcbiAgICB9XG4gIH07XG4gIHdoaWxlICh0cmVlTGVhZiA9IGNodW5rVHJlZUhlbHBlci5yZWFkTGVhZigpKSB7XG4gICAgaWYgKF9sb29wKCkpIGNvbnRpbnVlO1xuICB9XG4gIC8vIElmIHRoZXJlIGFyZSBzdGlsbCBTbGF0ZSBub2RlcyByZW1haW5pbmcgZnJvbSB0aGUgY2hpbGRyZW4gYXJyYXkgdGhhdCB3ZXJlXG4gIC8vIG5vdCBtYXRjaGVkIHRvIG5vZGVzIGluIHRoZSB0cmVlLCBpbnNlcnQgdGhlbSBhdCB0aGUgZW5kIG9mIHRoZSB0cmVlXG4gIGlmICghY2hpbGRyZW5IZWxwZXIucmVhY2hlZEVuZCkge1xuICAgIHZhciByZW1haW5pbmdDaGlsZHJlbiA9IGNoaWxkcmVuSGVscGVyLnJlbWFpbmluZygpO1xuICAgIHZhciBsZWF2ZXNUb0luc2VydCA9IGNoaWxkcmVuSGVscGVyLnRvQ2h1bmtMZWF2ZXMocmVtYWluaW5nQ2hpbGRyZW4sIGNoaWxkcmVuSGVscGVyLnBvaW50ZXJJbmRleCk7XG4gICAgLy8gTW92ZSB0aGUgcG9pbnRlciBiYWNrIHRvIHRoZSBmaW5hbCBsZWFmIGluIHRoZSB0cmVlLCBvciB0aGUgc3RhcnQgb2YgdGhlXG4gICAgLy8gdHJlZSBpZiB0aGUgdHJlZSBpcyBjdXJyZW50bHkgZW1wdHlcbiAgICBjaHVua1RyZWVIZWxwZXIucmV0dXJuVG9QcmV2aW91c0xlYWYoKTtcbiAgICBjaHVua1RyZWVIZWxwZXIuaW5zZXJ0QWZ0ZXIobGVhdmVzVG9JbnNlcnQpO1xuICAgIHJlbWFpbmluZ0NoaWxkcmVuLmZvckVhY2goKG5vZGUsIHJlbGF0aXZlSW5kZXgpID0+IHtcbiAgICAgIG9uSW5zZXJ0ID09PSBudWxsIHx8IG9uSW5zZXJ0ID09PSB2b2lkIDAgfHwgb25JbnNlcnQobm9kZSwgY2hpbGRyZW5IZWxwZXIucG9pbnRlckluZGV4ICsgcmVsYXRpdmVJbmRleCk7XG4gICAgfSk7XG4gIH1cbiAgY2h1bmtUcmVlLm1vdmVkTm9kZUtleXMuY2xlYXIoKTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkMShlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDEoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQxKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQxKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgS0VZX1RPX0NIVU5LX1RSRUUgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBHZXQgb3IgY3JlYXRlIHRoZSBjaHVuayB0cmVlIGZvciBhIFNsYXRlIG5vZGVcbiAqXG4gKiBJZiB0aGUgcmVjb25jaWxlIG9wdGlvbiBpcyBwcm92aWRlZCwgdGhlIGNodW5rIHRyZWUgd2lsbCBiZSB1cGRhdGVkIHRvXG4gKiBtYXRjaCB0aGUgY3VycmVudCBjaGlsZHJlbiBvZiB0aGUgbm9kZS4gVGhlIGNoaWxkcmVuIGFyZSBjaHVua2VkXG4gKiBhdXRvbWF0aWNhbGx5IHVzaW5nIHRoZSBnaXZlbiBjaHVuayBzaXplLlxuICovXG52YXIgZ2V0Q2h1bmtUcmVlRm9yTm9kZSA9IGZ1bmN0aW9uIGdldENodW5rVHJlZUZvck5vZGUoZWRpdG9yLCBub2RlKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIGtleSA9IFJlYWN0RWRpdG9yLmZpbmRLZXkoZWRpdG9yLCBub2RlKTtcbiAgdmFyIGNodW5rVHJlZSA9IEtFWV9UT19DSFVOS19UUkVFLmdldChrZXkpO1xuICBpZiAoIWNodW5rVHJlZSkge1xuICAgIGNodW5rVHJlZSA9IHtcbiAgICAgIHR5cGU6ICdyb290JyxcbiAgICAgIG1vdmVkTm9kZUtleXM6IG5ldyBTZXQoKSxcbiAgICAgIG1vZGlmaWVkQ2h1bmtzOiBuZXcgU2V0KCksXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9O1xuICAgIEtFWV9UT19DSFVOS19UUkVFLnNldChrZXksIGNodW5rVHJlZSk7XG4gIH1cbiAgaWYgKG9wdGlvbnMucmVjb25jaWxlKSB7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oZWRpdG9yLCBfb2JqZWN0U3ByZWFkJDEoe1xuICAgICAgY2h1bmtUcmVlLFxuICAgICAgY2hpbGRyZW46IG5vZGUuY2hpbGRyZW5cbiAgICB9LCBvcHRpb25zLnJlY29uY2lsZSkpO1xuICB9XG4gIHJldHVybiBjaHVua1RyZWU7XG59O1xuXG52YXIgZGVmYXVsdFJlbmRlckNodW5rID0gX3JlZiA9PiB7XG4gIHZhciB7XG4gICAgY2hpbGRyZW5cbiAgfSA9IF9yZWY7XG4gIHJldHVybiBjaGlsZHJlbjtcbn07XG52YXIgQ2h1bmtBbmNlc3RvciA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICByb290LFxuICAgIGFuY2VzdG9yLFxuICAgIHJlbmRlckVsZW1lbnQsXG4gICAgcmVuZGVyQ2h1bmsgPSBkZWZhdWx0UmVuZGVyQ2h1bmtcbiAgfSA9IHByb3BzO1xuICByZXR1cm4gYW5jZXN0b3IuY2hpbGRyZW4ubWFwKGNodW5rTm9kZSA9PiB7XG4gICAgaWYgKGNodW5rTm9kZS50eXBlID09PSAnY2h1bmsnKSB7XG4gICAgICB2YXIga2V5ID0gY2h1bmtOb2RlLmtleS5pZDtcbiAgICAgIHZhciByZW5kZXJlZENodW5rID0gcmVuZGVyQ2h1bmsoe1xuICAgICAgICBoaWdoZXN0OiBhbmNlc3RvciA9PT0gcm9vdCxcbiAgICAgICAgbG93ZXN0OiBjaHVua05vZGUuY2hpbGRyZW4uc29tZShjID0+IGMudHlwZSA9PT0gJ2xlYWYnKSxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICdkYXRhLXNsYXRlLWNodW5rJzogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTWVtb2l6ZWRDaHVuaywge1xuICAgICAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICAgICAgYW5jZXN0b3I6IGNodW5rTm9kZSxcbiAgICAgICAgICByZW5kZXJFbGVtZW50OiByZW5kZXJFbGVtZW50LFxuICAgICAgICAgIHJlbmRlckNodW5rOiByZW5kZXJDaHVua1xuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIHtcbiAgICAgICAga2V5OiBrZXlcbiAgICAgIH0sIHJlbmRlcmVkQ2h1bmspO1xuICAgIH1cbiAgICAvLyBPbmx5IGJsb2NrcyBjb250YWluaW5nIG5vIGlubGluZXMgYXJlIGNodW5rZWRcbiAgICB2YXIgZWxlbWVudCA9IGNodW5rTm9kZS5ub2RlO1xuICAgIHJldHVybiByZW5kZXJFbGVtZW50KGVsZW1lbnQsIGNodW5rTm9kZS5pbmRleCwgY2h1bmtOb2RlLmtleSk7XG4gIH0pO1xufTtcbnZhciBDaHVua1RyZWUgPSBDaHVua0FuY2VzdG9yO1xudmFyIE1lbW9pemVkQ2h1bmsgPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhDaHVua0FuY2VzdG9yLCAocHJldiwgbmV4dCkgPT4gcHJldi5yb290ID09PSBuZXh0LnJvb3QgJiYgcHJldi5yZW5kZXJFbGVtZW50ID09PSBuZXh0LnJlbmRlckVsZW1lbnQgJiYgcHJldi5yZW5kZXJDaHVuayA9PT0gbmV4dC5yZW5kZXJDaHVuayAmJiAhbmV4dC5yb290Lm1vZGlmaWVkQ2h1bmtzLmhhcyhuZXh0LmFuY2VzdG9yKSk7XG5cbnZhciBFbGVtZW50Q29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KG51bGwpO1xuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgZWxlbWVudC5cbiAqL1xudmFyIHVzZUVsZW1lbnQgPSAoKSA9PiB7XG4gIHZhciBjb250ZXh0ID0gdXNlQ29udGV4dChFbGVtZW50Q29udGV4dCk7XG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGB1c2VFbGVtZW50YCBob29rIG11c3QgYmUgdXNlZCBpbnNpZGUgYHJlbmRlckVsZW1lbnRgLicpO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufTtcbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGVsZW1lbnQsIG9yIHJldHVybiBudWxsIGlmIG5vdCBpbnNpZGUgYHJlbmRlckVsZW1lbnRgLlxuICovXG52YXIgdXNlRWxlbWVudElmID0gKCkgPT4gdXNlQ29udGV4dChFbGVtZW50Q29udGV4dCk7XG5cbi8qKlxuICogQ2hpbGRyZW4uXG4gKi9cbnZhciB1c2VDaGlsZHJlbiA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBkZWNvcmF0aW9ucyxcbiAgICBub2RlLFxuICAgIHJlbmRlckVsZW1lbnQsXG4gICAgcmVuZGVyQ2h1bmssXG4gICAgcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgcmVuZGVyVGV4dCxcbiAgICByZW5kZXJMZWFmXG4gIH0gPSBwcm9wcztcbiAgdmFyIGVkaXRvciA9IHVzZVNsYXRlU3RhdGljKCk7XG4gIElTX05PREVfTUFQX0RJUlRZLnNldChlZGl0b3IsIGZhbHNlKTtcbiAgdmFyIGlzRWRpdG9yID0gRWRpdG9yLmlzRWRpdG9yKG5vZGUpO1xuICB2YXIgaXNCbG9jayA9ICFpc0VkaXRvciAmJiBFbGVtZW50JDEuaXNFbGVtZW50KG5vZGUpICYmICFlZGl0b3IuaXNJbmxpbmUobm9kZSk7XG4gIHZhciBpc0xlYWZCbG9jayA9IGlzQmxvY2sgJiYgRWRpdG9yLmhhc0lubGluZXMoZWRpdG9yLCBub2RlKTtcbiAgdmFyIGNodW5rU2l6ZSA9IGlzTGVhZkJsb2NrID8gbnVsbCA6IGVkaXRvci5nZXRDaHVua1NpemUobm9kZSk7XG4gIHZhciBjaHVua2luZyA9ICEhY2h1bmtTaXplO1xuICB2YXIge1xuICAgIGRlY29yYXRpb25zQnlDaGlsZCxcbiAgICBjaGlsZHJlblRvUmVkZWNvcmF0ZVxuICB9ID0gdXNlRGVjb3JhdGlvbnNCeUNoaWxkKGVkaXRvciwgbm9kZSwgZGVjb3JhdGlvbnMpO1xuICAvLyBVcGRhdGUgdGhlIGluZGV4IGFuZCBwYXJlbnQgb2YgZWFjaCBjaGlsZC5cbiAgLy8gUEVSRjogSWYgY2h1bmtpbmcgaXMgZW5hYmxlZCwgdGhpcyBpcyBkb25lIHdoaWxlIHRyYXZlcnNpbmcgdGhlIGNodW5rIHRyZWVcbiAgLy8gaW5zdGVhZCB0byBlbGltaW5hdGUgdW5uZWNlc3Nhcnkgd2VhayBtYXAgb3BlcmF0aW9ucy5cbiAgaWYgKCFjaHVua2luZykge1xuICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaCgobiwgaSkgPT4ge1xuICAgICAgTk9ERV9UT19JTkRFWC5zZXQobiwgaSk7XG4gICAgICBOT0RFX1RPX1BBUkVOVC5zZXQobiwgbm9kZSk7XG4gICAgfSk7XG4gIH1cbiAgdmFyIHJlbmRlckVsZW1lbnRDb21wb25lbnQgPSB1c2VDYWxsYmFjaygobiwgaSwgY2FjaGVkS2V5KSA9PiB7XG4gICAgdmFyIGtleSA9IGNhY2hlZEtleSAhPT0gbnVsbCAmJiBjYWNoZWRLZXkgIT09IHZvaWQgMCA/IGNhY2hlZEtleSA6IFJlYWN0RWRpdG9yLmZpbmRLZXkoZWRpdG9yLCBuKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRWxlbWVudENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIGtleTogXCJwcm92aWRlci1cIi5jb25jYXQoa2V5LmlkKSxcbiAgICAgIHZhbHVlOiBuXG4gICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTWVtb2l6ZWRFbGVtZW50LCB7XG4gICAgICBkZWNvcmF0aW9uczogZGVjb3JhdGlvbnNCeUNoaWxkW2ldLFxuICAgICAgZWxlbWVudDogbixcbiAgICAgIGtleToga2V5LmlkLFxuICAgICAgcmVuZGVyRWxlbWVudDogcmVuZGVyRWxlbWVudCxcbiAgICAgIHJlbmRlckNodW5rOiByZW5kZXJDaHVuayxcbiAgICAgIHJlbmRlclBsYWNlaG9sZGVyOiByZW5kZXJQbGFjZWhvbGRlcixcbiAgICAgIHJlbmRlckxlYWY6IHJlbmRlckxlYWYsXG4gICAgICByZW5kZXJUZXh0OiByZW5kZXJUZXh0XG4gICAgfSkpO1xuICB9LCBbZWRpdG9yLCBkZWNvcmF0aW9uc0J5Q2hpbGQsIHJlbmRlckVsZW1lbnQsIHJlbmRlckNodW5rLCByZW5kZXJQbGFjZWhvbGRlciwgcmVuZGVyTGVhZiwgcmVuZGVyVGV4dF0pO1xuICB2YXIgcmVuZGVyVGV4dENvbXBvbmVudCA9IChuLCBpKSA9PiB7XG4gICAgdmFyIGtleSA9IFJlYWN0RWRpdG9yLmZpbmRLZXkoZWRpdG9yLCBuKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTWVtb2l6ZWRUZXh0LCB7XG4gICAgICBkZWNvcmF0aW9uczogZGVjb3JhdGlvbnNCeUNoaWxkW2ldLFxuICAgICAga2V5OiBrZXkuaWQsXG4gICAgICBpc0xhc3Q6IGkgPT09IG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMSxcbiAgICAgIHBhcmVudDogbm9kZSxcbiAgICAgIHJlbmRlclBsYWNlaG9sZGVyOiByZW5kZXJQbGFjZWhvbGRlcixcbiAgICAgIHJlbmRlckxlYWY6IHJlbmRlckxlYWYsXG4gICAgICByZW5kZXJUZXh0OiByZW5kZXJUZXh0LFxuICAgICAgdGV4dDogblxuICAgIH0pO1xuICB9O1xuICBpZiAoIWNodW5raW5nKSB7XG4gICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4ubWFwKChuLCBpKSA9PiBUZXh0JDEuaXNUZXh0KG4pID8gcmVuZGVyVGV4dENvbXBvbmVudChuLCBpKSA6IHJlbmRlckVsZW1lbnRDb21wb25lbnQobiwgaSkpO1xuICB9XG4gIHZhciBjaHVua1RyZWUgPSBnZXRDaHVua1RyZWVGb3JOb2RlKGVkaXRvciwgbm9kZSwge1xuICAgIHJlY29uY2lsZToge1xuICAgICAgY2h1bmtTaXplLFxuICAgICAgcmVyZW5kZXJDaGlsZHJlbjogY2hpbGRyZW5Ub1JlZGVjb3JhdGUsXG4gICAgICBvbkluc2VydDogKG4sIGkpID0+IHtcbiAgICAgICAgTk9ERV9UT19JTkRFWC5zZXQobiwgaSk7XG4gICAgICAgIE5PREVfVE9fUEFSRU5ULnNldChuLCBub2RlKTtcbiAgICAgIH0sXG4gICAgICBvblVwZGF0ZTogKG4sIGkpID0+IHtcbiAgICAgICAgTk9ERV9UT19JTkRFWC5zZXQobiwgaSk7XG4gICAgICAgIE5PREVfVE9fUEFSRU5ULnNldChuLCBub2RlKTtcbiAgICAgIH0sXG4gICAgICBvbkluZGV4Q2hhbmdlOiAobiwgaSkgPT4ge1xuICAgICAgICBOT0RFX1RPX0lOREVYLnNldChuLCBpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2h1bmtUcmVlLCB7XG4gICAgcm9vdDogY2h1bmtUcmVlLFxuICAgIGFuY2VzdG9yOiBjaHVua1RyZWUsXG4gICAgcmVuZGVyRWxlbWVudDogcmVuZGVyRWxlbWVudENvbXBvbmVudCxcbiAgICByZW5kZXJDaHVuazogcmVuZGVyQ2h1bmtcbiAgfSk7XG59O1xudmFyIHVzZURlY29yYXRpb25zQnlDaGlsZCA9IChlZGl0b3IsIG5vZGUsIGRlY29yYXRpb25zKSA9PiB7XG4gIHZhciBkZWNvcmF0aW9uc0J5Q2hpbGQgPSBzcGxpdERlY29yYXRpb25zQnlDaGlsZChlZGl0b3IsIG5vZGUsIGRlY29yYXRpb25zKTtcbiAgLy8gVGhlIHZhbHVlIHdlIHJldHVybiBpcyBhIG11dGFibGUgYXJyYXkgb2YgYERlY29yYXRlZFJhbmdlW11gIGFycmF5cy4gVGhpc1xuICAvLyBsZXRzIHVzIGF2b2lkIHBhc3NpbmcgYW4gaW1tdXRhYmxlIGFycmF5IG9mIGRlY29yYXRpb25zIGZvciBlYWNoIGNoaWxkIGludG9cbiAgLy8gYENodW5rVHJlZWAgdXNpbmcgcHJvcHMuIEVhY2ggYERlY29yYXRlZFJhbmdlW11gIGlzIG9ubHkgdXBkYXRlZCBpZiB0aGVcbiAgLy8gZGVjb3JhdGlvbnMgYXQgdGhhdCBpbmRleCBoYXZlIGNoYW5nZWQsIHdoaWNoIHNwZWVkcyB1cCB0aGUgZXF1YWxpdHkgY2hlY2tcbiAgLy8gZm9yIHRoZSBgZGVjb3JhdGlvbnNgIHByb3AgaW4gdGhlIG1lbW9pemVkIGBFbGVtZW50YCBhbmQgYFRleHRgIGNvbXBvbmVudHMuXG4gIHZhciBtdXRhYmxlRGVjb3JhdGlvbnNCeUNoaWxkID0gdXNlUmVmKGRlY29yYXRpb25zQnlDaGlsZCkuY3VycmVudDtcbiAgLy8gVHJhY2sgdGhlIGxpc3Qgb2YgY2hpbGQgaW5kaWNlcyB3aG9zZSBkZWNvcmF0aW9ucyBoYXZlIGNoYW5nZWQsIHNvIHRoYXQgd2VcbiAgLy8gY2FuIHRlbGwgdGhlIGNodW5rIHRyZWUgdG8gcmUtcmVuZGVyIHRoZXNlIGNoaWxkcmVuLlxuICB2YXIgY2hpbGRyZW5Ub1JlZGVjb3JhdGUgPSBbXTtcbiAgLy8gUmVzaXplIHRoZSBtdXRhYmxlIGFycmF5IHRvIG1hdGNoIHRoZSBsYXRlc3QgcmVzdWx0XG4gIG11dGFibGVEZWNvcmF0aW9uc0J5Q2hpbGQubGVuZ3RoID0gZGVjb3JhdGlvbnNCeUNoaWxkLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWNvcmF0aW9uc0J5Q2hpbGQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX211dGFibGVEZWNvcmF0aW9uc0J5O1xuICAgIHZhciBfZGVjb3JhdGlvbnMgPSBkZWNvcmF0aW9uc0J5Q2hpbGRbaV07XG4gICAgdmFyIHByZXZpb3VzRGVjb3JhdGlvbnMgPSAoX211dGFibGVEZWNvcmF0aW9uc0J5ID0gbXV0YWJsZURlY29yYXRpb25zQnlDaGlsZFtpXSkgIT09IG51bGwgJiYgX211dGFibGVEZWNvcmF0aW9uc0J5ICE9PSB2b2lkIDAgPyBfbXV0YWJsZURlY29yYXRpb25zQnkgOiBudWxsO1xuICAgIGlmICghaXNFbGVtZW50RGVjb3JhdGlvbnNFcXVhbChwcmV2aW91c0RlY29yYXRpb25zLCBfZGVjb3JhdGlvbnMpKSB7XG4gICAgICBtdXRhYmxlRGVjb3JhdGlvbnNCeUNoaWxkW2ldID0gX2RlY29yYXRpb25zO1xuICAgICAgY2hpbGRyZW5Ub1JlZGVjb3JhdGUucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkZWNvcmF0aW9uc0J5Q2hpbGQ6IG11dGFibGVEZWNvcmF0aW9uc0J5Q2hpbGQsXG4gICAgY2hpbGRyZW5Ub1JlZGVjb3JhdGVcbiAgfTtcbn07XG5cbi8qKlxuICogQSBSZWFjdCBjb250ZXh0IGZvciBzaGFyaW5nIHRoZSBgcmVhZE9ubHlgIHN0YXRlIG9mIHRoZSBlZGl0b3IuXG4gKi9cbnZhciBSZWFkT25seUNvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dChmYWxzZSk7XG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBgcmVhZE9ubHlgIHN0YXRlIG9mIHRoZSBlZGl0b3IuXG4gKi9cbnZhciB1c2VSZWFkT25seSA9ICgpID0+IHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoUmVhZE9ubHlDb250ZXh0KTtcbn07XG5cbi8qKlxuICogQSBSZWFjdCBjb250ZXh0IGZvciBzaGFyaW5nIHRoZSBlZGl0b3Igc2VsZWN0b3IgY29udGV4dCBpbiBhIHdheSB0byBjb250cm9sXG4gKiByZS1yZW5kZXJzLlxuICovXG52YXIgU2xhdGVTZWxlY3RvckNvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dCh7fSk7XG52YXIgcmVmRXF1YWxpdHkgPSAoYSwgYikgPT4gYSA9PT0gYjtcbi8qKlxuICogVXNlIHJlZHV4IHN0eWxlIHNlbGVjdG9ycyB0byBwcmV2ZW50IHJlLXJlbmRlcmluZyBvbiBldmVyeSBrZXlzdHJva2UuXG4gKlxuICogQmVhciBpbiBtaW5kIHJlLXJlbmRlcmluZyBjYW4gb25seSBwcmV2ZW50ZWQgaWYgdGhlIHJldHVybmVkIHZhbHVlIGlzIGEgdmFsdWVcbiAqIHR5cGUgb3IgZm9yIHJlZmVyZW5jZSB0eXBlcyAoZS5nLiBvYmplY3RzIGFuZCBhcnJheXMpIGFkZCBhIGN1c3RvbSBlcXVhbGl0eVxuICogZnVuY3Rpb24uXG4gKlxuICogSWYgYHNlbGVjdG9yYCBpcyBtZW1vaXplZCB1c2luZyBgdXNlQ2FsbGJhY2tgLCB0aGVuIGl0IHdpbGwgb25seSBiZSBjYWxsZWRcbiAqIHdoZW4gaXQgb3IgdGhlIGVkaXRvciBzdGF0ZSBjaGFuZ2VzLiBPdGhlcndpc2UsIGBzZWxlY3RvcmAgd2lsbCBiZSBjYWxsZWRcbiAqIGV2ZXJ5IHRpbWUgdGhlIGNvbXBvbmVudCByZW5kZXJzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBpc1NlbGVjdGlvbkFjdGl2ZSA9IHVzZVNsYXRlU2VsZWN0b3IoZWRpdG9yID0+IEJvb2xlYW4oZWRpdG9yLnNlbGVjdGlvbikpXG4gKi9cbmZ1bmN0aW9uIHVzZVNsYXRlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgdmFyIGVxdWFsaXR5Rm4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHJlZkVxdWFsaXR5O1xuICB2YXIge1xuICAgIGRlZmVycmVkXG4gIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIgY29udGV4dCA9IHVzZUNvbnRleHQoU2xhdGVTZWxlY3RvckNvbnRleHQpO1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYHVzZVNsYXRlU2VsZWN0b3JgIGhvb2sgbXVzdCBiZSB1c2VkIGluc2lkZSB0aGUgPFNsYXRlPiBjb21wb25lbnQncyBjb250ZXh0LlwiKTtcbiAgfVxuICB2YXIge1xuICAgIGFkZEV2ZW50TGlzdGVuZXJcbiAgfSA9IGNvbnRleHQ7XG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpO1xuICB2YXIgZ2VuZXJpY1NlbGVjdG9yID0gdXNlQ2FsbGJhY2soKCkgPT4gc2VsZWN0b3IoZWRpdG9yKSwgW2VkaXRvciwgc2VsZWN0b3JdKTtcbiAgdmFyIFtzZWxlY3RlZFN0YXRlLCB1cGRhdGVdID0gdXNlR2VuZXJpY1NlbGVjdG9yKGdlbmVyaWNTZWxlY3RvciwgZXF1YWxpdHlGbik7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHZhciB1bnN1YnNjcmliZSA9IGFkZEV2ZW50TGlzdGVuZXIodXBkYXRlLCB7XG4gICAgICBkZWZlcnJlZFxuICAgIH0pO1xuICAgIHVwZGF0ZSgpO1xuICAgIHJldHVybiB1bnN1YnNjcmliZTtcbiAgfSwgW2FkZEV2ZW50TGlzdGVuZXIsIHVwZGF0ZSwgZGVmZXJyZWRdKTtcbiAgcmV0dXJuIHNlbGVjdGVkU3RhdGU7XG59XG4vKipcbiAqIENyZWF0ZSBzZWxlY3RvciBjb250ZXh0IHdpdGggZWRpdG9yIHVwZGF0aW5nIG9uIGV2ZXJ5IGVkaXRvciBjaGFuZ2VcbiAqL1xuZnVuY3Rpb24gdXNlU2VsZWN0b3JDb250ZXh0KCkge1xuICB2YXIgZXZlbnRMaXN0ZW5lcnMgPSB1c2VSZWYobmV3IFNldCgpKTtcbiAgdmFyIGRlZmVycmVkRXZlbnRMaXN0ZW5lcnMgPSB1c2VSZWYobmV3IFNldCgpKTtcbiAgdmFyIG9uQ2hhbmdlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGV2ZW50TGlzdGVuZXJzLmN1cnJlbnQuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcigpKTtcbiAgfSwgW10pO1xuICB2YXIgZmx1c2hEZWZlcnJlZCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBkZWZlcnJlZEV2ZW50TGlzdGVuZXJzLmN1cnJlbnQuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcigpKTtcbiAgICBkZWZlcnJlZEV2ZW50TGlzdGVuZXJzLmN1cnJlbnQuY2xlYXIoKTtcbiAgfSwgW10pO1xuICB2YXIgYWRkRXZlbnRMaXN0ZW5lciA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChjYWxsYmFja1Byb3ApIHtcbiAgICB2YXIge1xuICAgICAgZGVmZXJyZWQgPSBmYWxzZVxuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBjYWxsYmFjayA9IGRlZmVycmVkID8gKCkgPT4gZGVmZXJyZWRFdmVudExpc3RlbmVycy5jdXJyZW50LmFkZChjYWxsYmFja1Byb3ApIDogY2FsbGJhY2tQcm9wO1xuICAgIGV2ZW50TGlzdGVuZXJzLmN1cnJlbnQuYWRkKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZXZlbnRMaXN0ZW5lcnMuY3VycmVudC5kZWxldGUoY2FsbGJhY2spO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgdmFyIHNlbGVjdG9yQ29udGV4dCA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBhZGRFdmVudExpc3RlbmVyLFxuICAgIGZsdXNoRGVmZXJyZWRcbiAgfSksIFthZGRFdmVudExpc3RlbmVyLCBmbHVzaERlZmVycmVkXSk7XG4gIHJldHVybiB7XG4gICAgc2VsZWN0b3JDb250ZXh0LFxuICAgIG9uQ2hhbmdlXG4gIH07XG59XG5mdW5jdGlvbiB1c2VGbHVzaERlZmVycmVkU2VsZWN0b3JzT25SZW5kZXIoKSB7XG4gIHZhciB7XG4gICAgZmx1c2hEZWZlcnJlZFxuICB9ID0gdXNlQ29udGV4dChTbGF0ZVNlbGVjdG9yQ29udGV4dCk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZmx1c2hEZWZlcnJlZCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGVkaXRvciBvYmplY3QgYW5kIHJlLXJlbmRlciB3aGVuZXZlciBpdCBjaGFuZ2VzLlxuICovXG52YXIgdXNlU2xhdGUgPSAoKSA9PiB7XG4gIHZhciB7XG4gICAgYWRkRXZlbnRMaXN0ZW5lclxuICB9ID0gdXNlQ29udGV4dChTbGF0ZVNlbGVjdG9yQ29udGV4dCk7XG4gIHZhciBbLCBmb3JjZVJlbmRlcl0gPSB1c2VSZWR1Y2VyKHMgPT4gcyArIDEsIDApO1xuICBpZiAoIWFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYHVzZVNsYXRlYCBob29rIG11c3QgYmUgdXNlZCBpbnNpZGUgdGhlIDxTbGF0ZT4gY29tcG9uZW50J3MgY29udGV4dC5cIik7XG4gIH1cbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiBhZGRFdmVudExpc3RlbmVyKGZvcmNlUmVuZGVyKSwgW2FkZEV2ZW50TGlzdGVuZXJdKTtcbiAgcmV0dXJuIHVzZVNsYXRlU3RhdGljKCk7XG59O1xudmFyIEVESVRPUl9UT19WID0gbmV3IFdlYWtNYXAoKTtcbnZhciBnZXRFZGl0b3JWZXJzaW9uUmVmID0gZWRpdG9yID0+IHtcbiAgdmFyIHYgPSBFRElUT1JfVE9fVi5nZXQoZWRpdG9yKTtcbiAgaWYgKHYpIHtcbiAgICByZXR1cm4gdjtcbiAgfVxuICB2ID0ge1xuICAgIGN1cnJlbnQ6IDBcbiAgfTtcbiAgRURJVE9SX1RPX1Yuc2V0KGVkaXRvciwgdik7XG4gIC8vIFJlZ2lzdGVyIHRoZSBgb25DaGFuZ2VgIGhhbmRsZXIgZXhhY3RseSBvbmNlIHBlciBlZGl0b3JcbiAgdmFyIHtcbiAgICBvbkNoYW5nZVxuICB9ID0gZWRpdG9yO1xuICBlZGl0b3Iub25DaGFuZ2UgPSBvcHRpb25zID0+IHtcbiAgICB2LmN1cnJlbnQrKztcbiAgICBvbkNoYW5nZShvcHRpb25zKTtcbiAgfTtcbiAgcmV0dXJuIHY7XG59O1xuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgZWRpdG9yIG9iamVjdCBhbmQgaXRzIHZlcnNpb24sIHdoaWNoIGluY3JlbWVudHMgb24gZXZlcnlcbiAqIGNoYW5nZS5cbiAqXG4gKiBAZGVwcmVjYXRlZCBUaGUgYHZgIGNvdW50ZXIgaXMgbm8gbG9uZ2VyIHVzZWQgZXhjZXB0IGZvciB0aGlzIGhvb2ssIGFuZCBtYXlcbiAqIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi5cbiAqL1xudmFyIHVzZVNsYXRlV2l0aFYgPSAoKSA9PiB7XG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZSgpO1xuICB2YXIgdlJlZiA9IHVzZU1lbW8oKCkgPT4gZ2V0RWRpdG9yVmVyc2lvblJlZihlZGl0b3IpLCBbZWRpdG9yXSk7XG4gIHJldHVybiB7XG4gICAgZWRpdG9yLFxuICAgIHY6IHZSZWYuY3VycmVudFxuICB9O1xufTtcblxuZnVuY3Rpb24gdXNlVHJhY2tVc2VySW5wdXQoKSB7XG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpO1xuICB2YXIgcmVjZWl2ZWRVc2VySW5wdXQgPSB1c2VSZWYoZmFsc2UpO1xuICB2YXIgYW5pbWF0aW9uRnJhbWVJZFJlZiA9IHVzZVJlZigwKTtcbiAgdmFyIG9uVXNlcklucHV0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChyZWNlaXZlZFVzZXJJbnB1dC5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlY2VpdmVkVXNlcklucHV0LmN1cnJlbnQgPSB0cnVlO1xuICAgIHZhciB3aW5kb3cgPSBSZWFjdEVkaXRvci5nZXRXaW5kb3coZWRpdG9yKTtcbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uRnJhbWVJZFJlZi5jdXJyZW50KTtcbiAgICBhbmltYXRpb25GcmFtZUlkUmVmLmN1cnJlbnQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHJlY2VpdmVkVXNlcklucHV0LmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9KTtcbiAgfSwgW2VkaXRvcl0pO1xuICB1c2VFZmZlY3QoKCkgPT4gKCkgPT4gY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uRnJhbWVJZFJlZi5jdXJyZW50KSwgW10pO1xuICByZXR1cm4ge1xuICAgIHJlY2VpdmVkVXNlcklucHV0LFxuICAgIG9uVXNlcklucHV0XG4gIH07XG59XG5cbnZhciBjcmVhdGVSZXN0b3JlRG9tTWFuYWdlciA9IChlZGl0b3IsIHJlY2VpdmVkVXNlcklucHV0KSA9PiB7XG4gIHZhciBidWZmZXJlZE11dGF0aW9ucyA9IFtdO1xuICB2YXIgY2xlYXIgPSAoKSA9PiB7XG4gICAgYnVmZmVyZWRNdXRhdGlvbnMgPSBbXTtcbiAgfTtcbiAgdmFyIHJlZ2lzdGVyTXV0YXRpb25zID0gbXV0YXRpb25zID0+IHtcbiAgICBpZiAoIXJlY2VpdmVkVXNlcklucHV0LmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRyYWNrZWRNdXRhdGlvbnMgPSBtdXRhdGlvbnMuZmlsdGVyKG11dGF0aW9uID0+IGlzVHJhY2tlZE11dGF0aW9uKGVkaXRvciwgbXV0YXRpb24sIG11dGF0aW9ucykpO1xuICAgIGJ1ZmZlcmVkTXV0YXRpb25zLnB1c2goLi4udHJhY2tlZE11dGF0aW9ucyk7XG4gIH07XG4gIGZ1bmN0aW9uIHJlc3RvcmVET00oKSB7XG4gICAgaWYgKGJ1ZmZlcmVkTXV0YXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIGJ1ZmZlcmVkTXV0YXRpb25zLnJldmVyc2UoKS5mb3JFYWNoKG11dGF0aW9uID0+IHtcbiAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdjaGFyYWN0ZXJEYXRhJykge1xuICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gcmVzdG9yZSB0aGUgRE9NIGZvciBjaGFyYWN0ZXJEYXRhIG11dGF0aW9uc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhpcyBpbnRlcnJ1cHRzIHRoZSBjb21wb3NpdGlvbi5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbXV0YXRpb24ucmVtb3ZlZE5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgbXV0YXRpb24udGFyZ2V0Lmluc2VydEJlZm9yZShub2RlLCBtdXRhdGlvbi5uZXh0U2libGluZyk7XG4gICAgICAgIH0pO1xuICAgICAgICBtdXRhdGlvbi5hZGRlZE5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgbXV0YXRpb24udGFyZ2V0LnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgLy8gQ2xlYXIgYnVmZmVyZWQgbXV0YXRpb25zIHRvIGVuc3VyZSB3ZSBkb24ndCB1bmRvIHRoZW0gdHdpY2VcbiAgICAgIGNsZWFyKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgcmVnaXN0ZXJNdXRhdGlvbnMsXG4gICAgcmVzdG9yZURPTSxcbiAgICBjbGVhclxuICB9O1xufTtcblxudmFyIE1VVEFUSU9OX09CU0VSVkVSX0NPTkZJRyA9IHtcbiAgc3VidHJlZTogdHJ1ZSxcbiAgY2hpbGRMaXN0OiB0cnVlLFxuICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICBjaGFyYWN0ZXJEYXRhT2xkVmFsdWU6IHRydWVcbn07XG4vLyBXZSBoYXZlIHRvIHVzZSBhIGNsYXNzIGNvbXBvbmVudCBoZXJlIHNpbmNlIHdlIHJlbHkgb24gYGdldFNuYXBzaG90QmVmb3JlVXBkYXRlYCB3aGljaCBoYXMgbm8gRkMgZXF1aXZhbGVudFxuLy8gdG8gcnVuIGNvZGUgc3luY2hyb25vdXNseSBpbW1lZGlhdGVseSBiZWZvcmUgcmVhY3QgY29tbWl0cyB0aGUgY29tcG9uZW50IHVwZGF0ZSB0byB0aGUgRE9NLlxuY2xhc3MgUmVzdG9yZURPTUNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udGV4dFwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYW5hZ2VyXCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm11dGF0aW9uT2JzZXJ2ZXJcIiwgbnVsbCk7XG4gIH1cbiAgb2JzZXJ2ZSgpIHtcbiAgICB2YXIgX3RoaXMkbXV0YXRpb25PYnNlcnZlO1xuICAgIHZhciB7XG4gICAgICBub2RlXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKCFub2RlLmN1cnJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGF0dGFjaCBNdXRhdGlvbk9ic2VydmVyLCBgbm9kZWAgaXMgdW5kZWZpbmVkJyk7XG4gICAgfVxuICAgIChfdGhpcyRtdXRhdGlvbk9ic2VydmUgPSB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIpID09PSBudWxsIHx8IF90aGlzJG11dGF0aW9uT2JzZXJ2ZSA9PT0gdm9pZCAwIHx8IF90aGlzJG11dGF0aW9uT2JzZXJ2ZS5vYnNlcnZlKG5vZGUuY3VycmVudCwgTVVUQVRJT05fT0JTRVJWRVJfQ09ORklHKTtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB2YXIge1xuICAgICAgcmVjZWl2ZWRVc2VySW5wdXRcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICB2YXIgZWRpdG9yID0gdGhpcy5jb250ZXh0O1xuICAgIHRoaXMubWFuYWdlciA9IGNyZWF0ZVJlc3RvcmVEb21NYW5hZ2VyKGVkaXRvciwgcmVjZWl2ZWRVc2VySW5wdXQpO1xuICAgIHRoaXMubXV0YXRpb25PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMubWFuYWdlci5yZWdpc3Rlck11dGF0aW9ucyk7XG4gICAgdGhpcy5vYnNlcnZlKCk7XG4gIH1cbiAgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSB7XG4gICAgdmFyIF90aGlzJG11dGF0aW9uT2JzZXJ2ZTIsIF90aGlzJG11dGF0aW9uT2JzZXJ2ZTMsIF90aGlzJG1hbmFnZXIyO1xuICAgIHZhciBwZW5kaW5nTXV0YXRpb25zID0gKF90aGlzJG11dGF0aW9uT2JzZXJ2ZTIgPSB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIpID09PSBudWxsIHx8IF90aGlzJG11dGF0aW9uT2JzZXJ2ZTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJG11dGF0aW9uT2JzZXJ2ZTIudGFrZVJlY29yZHMoKTtcbiAgICBpZiAocGVuZGluZ011dGF0aW9ucyAhPT0gbnVsbCAmJiBwZW5kaW5nTXV0YXRpb25zICE9PSB2b2lkIDAgJiYgcGVuZGluZ011dGF0aW9ucy5sZW5ndGgpIHtcbiAgICAgIHZhciBfdGhpcyRtYW5hZ2VyO1xuICAgICAgKF90aGlzJG1hbmFnZXIgPSB0aGlzLm1hbmFnZXIpID09PSBudWxsIHx8IF90aGlzJG1hbmFnZXIgPT09IHZvaWQgMCB8fCBfdGhpcyRtYW5hZ2VyLnJlZ2lzdGVyTXV0YXRpb25zKHBlbmRpbmdNdXRhdGlvbnMpO1xuICAgIH1cbiAgICAoX3RoaXMkbXV0YXRpb25PYnNlcnZlMyA9IHRoaXMubXV0YXRpb25PYnNlcnZlcikgPT09IG51bGwgfHwgX3RoaXMkbXV0YXRpb25PYnNlcnZlMyA9PT0gdm9pZCAwIHx8IF90aGlzJG11dGF0aW9uT2JzZXJ2ZTMuZGlzY29ubmVjdCgpO1xuICAgIChfdGhpcyRtYW5hZ2VyMiA9IHRoaXMubWFuYWdlcikgPT09IG51bGwgfHwgX3RoaXMkbWFuYWdlcjIgPT09IHZvaWQgMCB8fCBfdGhpcyRtYW5hZ2VyMi5yZXN0b3JlRE9NKCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIHZhciBfdGhpcyRtYW5hZ2VyMztcbiAgICAoX3RoaXMkbWFuYWdlcjMgPSB0aGlzLm1hbmFnZXIpID09PSBudWxsIHx8IF90aGlzJG1hbmFnZXIzID09PSB2b2lkIDAgfHwgX3RoaXMkbWFuYWdlcjMuY2xlYXIoKTtcbiAgICB0aGlzLm9ic2VydmUoKTtcbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB2YXIgX3RoaXMkbXV0YXRpb25PYnNlcnZlNDtcbiAgICAoX3RoaXMkbXV0YXRpb25PYnNlcnZlNCA9IHRoaXMubXV0YXRpb25PYnNlcnZlcikgPT09IG51bGwgfHwgX3RoaXMkbXV0YXRpb25PYnNlcnZlNCA9PT0gdm9pZCAwIHx8IF90aGlzJG11dGF0aW9uT2JzZXJ2ZTQuZGlzY29ubmVjdCgpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfVxufVxuX2RlZmluZVByb3BlcnR5KFJlc3RvcmVET01Db21wb25lbnQsIFwiY29udGV4dFR5cGVcIiwgRWRpdG9yQ29udGV4dCk7XG52YXIgUmVzdG9yZURPTSA9IElTX0FORFJPSUQgPyBSZXN0b3JlRE9NQ29tcG9uZW50IDogX3JlZiA9PiB7XG4gIHZhciB7XG4gICAgY2hpbGRyZW5cbiAgfSA9IF9yZWY7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xufTtcblxuLyoqXG4gKiBBIFJlYWN0IGNvbnRleHQgZm9yIHNoYXJpbmcgdGhlIGBjb21wb3NpbmdgIHN0YXRlIG9mIHRoZSBlZGl0b3IuXG4gKi9cbnZhciBDb21wb3NpbmdDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQoZmFsc2UpO1xuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgYGNvbXBvc2luZ2Agc3RhdGUgb2YgdGhlIGVkaXRvci5cbiAqL1xudmFyIHVzZUNvbXBvc2luZyA9ICgpID0+IHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoQ29tcG9zaW5nQ29udGV4dCk7XG59O1xuXG52YXIgX2V4Y2x1ZGVkJDEgPSBbXCJhdXRvRm9jdXNcIiwgXCJkZWNvcmF0ZVwiLCBcIm9uRE9NQmVmb3JlSW5wdXRcIiwgXCJwbGFjZWhvbGRlclwiLCBcInJlYWRPbmx5XCIsIFwicmVuZGVyRWxlbWVudFwiLCBcInJlbmRlckNodW5rXCIsIFwicmVuZGVyTGVhZlwiLCBcInJlbmRlclRleHRcIiwgXCJyZW5kZXJQbGFjZWhvbGRlclwiLCBcInNjcm9sbFNlbGVjdGlvbkludG9WaWV3XCIsIFwic3R5bGVcIiwgXCJhc1wiLCBcImRpc2FibGVEZWZhdWx0U3R5bGVzXCJdLFxuICBfZXhjbHVkZWQyID0gW1widGV4dFwiXTtcbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxudmFyIENoaWxkcmVuID0gcHJvcHMgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIHVzZUNoaWxkcmVuKHByb3BzKSk7XG4vKipcbiAqIEVkaXRhYmxlLlxuICovXG52YXIgRWRpdGFibGUgPSAvKiNfX1BVUkVfXyovZm9yd2FyZFJlZigocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICB2YXIgZGVmYXVsdFJlbmRlclBsYWNlaG9sZGVyID0gdXNlQ2FsbGJhY2socHJvcHMgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGVmYXVsdFBsYWNlaG9sZGVyLCBfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcykpLCBbXSk7XG4gIHZhciB7XG4gICAgICBhdXRvRm9jdXMsXG4gICAgICBkZWNvcmF0ZSA9IGRlZmF1bHREZWNvcmF0ZSxcbiAgICAgIG9uRE9NQmVmb3JlSW5wdXQ6IHByb3BzT25ET01CZWZvcmVJbnB1dCxcbiAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgcmVhZE9ubHkgPSBmYWxzZSxcbiAgICAgIHJlbmRlckVsZW1lbnQsXG4gICAgICByZW5kZXJDaHVuayxcbiAgICAgIHJlbmRlckxlYWYsXG4gICAgICByZW5kZXJUZXh0LFxuICAgICAgcmVuZGVyUGxhY2Vob2xkZXIgPSBkZWZhdWx0UmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgICBzY3JvbGxTZWxlY3Rpb25JbnRvVmlldyA9IGRlZmF1bHRTY3JvbGxTZWxlY3Rpb25JbnRvVmlldyxcbiAgICAgIHN0eWxlOiB1c2VyU3R5bGUgPSB7fSxcbiAgICAgIGFzOiBDb21wb25lbnQgPSAnZGl2JyxcbiAgICAgIGRpc2FibGVEZWZhdWx0U3R5bGVzID0gZmFsc2VcbiAgICB9ID0gcHJvcHMsXG4gICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgX2V4Y2x1ZGVkJDEpO1xuICB2YXIgZWRpdG9yID0gdXNlU2xhdGUoKTtcbiAgLy8gUmVyZW5kZXIgZWRpdG9yIHdoZW4gY29tcG9zaXRpb24gc3RhdHVzIGNoYW5nZWRcbiAgdmFyIFtpc0NvbXBvc2luZywgc2V0SXNDb21wb3NpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICB2YXIgcmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgZGVmZXJyZWRPcGVyYXRpb25zID0gdXNlUmVmKFtdKTtcbiAgdmFyIFtwbGFjZWhvbGRlckhlaWdodCwgc2V0UGxhY2Vob2xkZXJIZWlnaHRdID0gdXNlU3RhdGUoKTtcbiAgdmFyIHByb2Nlc3NpbmcgPSB1c2VSZWYoZmFsc2UpO1xuICB2YXIge1xuICAgIG9uVXNlcklucHV0LFxuICAgIHJlY2VpdmVkVXNlcklucHV0XG4gIH0gPSB1c2VUcmFja1VzZXJJbnB1dCgpO1xuICB2YXIgWywgZm9yY2VSZW5kZXJdID0gdXNlUmVkdWNlcihzID0+IHMgKyAxLCAwKTtcbiAgRURJVE9SX1RPX0ZPUkNFX1JFTkRFUi5zZXQoZWRpdG9yLCBmb3JjZVJlbmRlcik7XG4gIC8vIFVwZGF0ZSBpbnRlcm5hbCBzdGF0ZSBvbiBlYWNoIHJlbmRlci5cbiAgSVNfUkVBRF9PTkxZLnNldChlZGl0b3IsIHJlYWRPbmx5KTtcbiAgLy8gS2VlcCB0cmFjayBvZiBzb21lIHN0YXRlIGZvciB0aGUgZXZlbnQgaGFuZGxlciBsb2dpYy5cbiAgdmFyIHN0YXRlID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGlzRHJhZ2dpbmdJbnRlcm5hbGx5OiBmYWxzZSxcbiAgICBpc1VwZGF0aW5nU2VsZWN0aW9uOiBmYWxzZSxcbiAgICBsYXRlc3RFbGVtZW50OiBudWxsLFxuICAgIGhhc01hcmtQbGFjZWhvbGRlcjogZmFsc2VcbiAgfSksIFtdKTtcbiAgLy8gVGhlIGF1dG9Gb2N1cyBUZXh0YXJlYUhUTUxBdHRyaWJ1dGUgZG9lc24ndCBkbyBhbnl0aGluZyBvbiBhIGRpdiwgc28gaXRcbiAgLy8gbmVlZHMgdG8gYmUgbWFudWFsbHkgZm9jdXNlZC5cbiAgLy9cbiAgLy8gSWYgdGhpcyBzdG9wcyB3b3JraW5nIGluIEZpcmVmb3gsIG1ha2Ugc3VyZSBub3RoaW5nIGlzIGNhdXNpbmcgdGhpc1xuICAvLyBjb21wb25lbnQgdG8gcmUtcmVuZGVyIGR1cmluZyB0aGUgaW5pdGlhbCBtb3VudC4gSWYgdGhlIERPTSBzZWxlY3Rpb24gaXNcbiAgLy8gc2V0IGJ5IGB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0YCBiZWZvcmUgYG9uRE9NU2VsZWN0aW9uQ2hhbmdlYCB1cGRhdGVzXG4gIC8vIGBlZGl0b3Iuc2VsZWN0aW9uYCwgdGhlIERPTSBzZWxlY3Rpb24gY2FuIGJlIHJlbW92ZWQgYWNjaWRlbnRhbGx5LlxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChyZWYuY3VycmVudCAmJiBhdXRvRm9jdXMpIHtcbiAgICAgIHJlZi5jdXJyZW50LmZvY3VzKCk7XG4gICAgfVxuICB9LCBbYXV0b0ZvY3VzXSk7XG4gIC8qKlxuICAgKiBUaGUgQW5kcm9pZElucHV0TWFuYWdlciBvYmplY3QgaGFzIGEgY3ljbGljYWwgZGVwZW5kZW5jeSBvbiBvbkRPTVNlbGVjdGlvbkNoYW5nZVxuICAgKlxuICAgKiBJdCBpcyBkZWZpbmVkIGFzIGEgcmVmZXJlbmNlIHRvIHNpbXBsaWZ5IGhvb2sgZGVwZW5kZW5jaWVzIGFuZCBjbGFyaWZ5IHRoYXRcbiAgICogaXQgbmVlZHMgdG8gYmUgaW5pdGlhbGl6ZWQuXG4gICAqL1xuICB2YXIgYW5kcm9pZElucHV0TWFuYWdlclJlZiA9IHVzZVJlZigpO1xuICAvLyBMaXN0ZW4gb24gdGhlIG5hdGl2ZSBgc2VsZWN0aW9uY2hhbmdlYCBldmVudCB0byBiZSBhYmxlIHRvIHVwZGF0ZSBhbnkgdGltZVxuICAvLyB0aGUgc2VsZWN0aW9uIGNoYW5nZXMuIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBSZWFjdCdzIGBvblNlbGVjdGAgaXMgbGVha3lcbiAgLy8gYW5kIG5vbi1zdGFuZGFyZCBzbyBpdCBkb2Vzbid0IGZpcmUgdW50aWwgYWZ0ZXIgYSBzZWxlY3Rpb24gaGFzIGJlZW5cbiAgLy8gcmVsZWFzZWQuIFRoaXMgY2F1c2VzIGlzc3VlcyBpbiBzaXR1YXRpb25zIHdoZXJlIGFub3RoZXIgY2hhbmdlIGhhcHBlbnNcbiAgLy8gd2hpbGUgYSBzZWxlY3Rpb24gaXMgYmVpbmcgZHJhZ2dlZC5cbiAgdmFyIG9uRE9NU2VsZWN0aW9uQ2hhbmdlID0gdXNlTWVtbygoKSA9PiB0aHJvdHRsZSgoKSA9PiB7XG4gICAgaWYgKElTX05PREVfTUFQX0RJUlRZLmdldChlZGl0b3IpKSB7XG4gICAgICBvbkRPTVNlbGVjdGlvbkNoYW5nZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgIHZhciByb290ID0gZWwuZ2V0Um9vdE5vZGUoKTtcbiAgICBpZiAoIXByb2Nlc3NpbmcuY3VycmVudCAmJiBJU19XRUJLSVQgJiYgcm9vdCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcbiAgICAgIHByb2Nlc3NpbmcuY3VycmVudCA9IHRydWU7XG4gICAgICB2YXIgYWN0aXZlID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICBkb2N1bWVudC5leGVjQ29tbWFuZCgnaW5kZW50Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBUcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvcik7XG4gICAgICB9XG4gICAgICBwcm9jZXNzaW5nLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGFuZHJvaWRJbnB1dE1hbmFnZXIgPSBhbmRyb2lkSW5wdXRNYW5hZ2VyUmVmLmN1cnJlbnQ7XG4gICAgaWYgKChJU19BTkRST0lEIHx8ICFSZWFjdEVkaXRvci5pc0NvbXBvc2luZyhlZGl0b3IpKSAmJiAoIXN0YXRlLmlzVXBkYXRpbmdTZWxlY3Rpb24gfHwgYW5kcm9pZElucHV0TWFuYWdlciAhPT0gbnVsbCAmJiBhbmRyb2lkSW5wdXRNYW5hZ2VyICE9PSB2b2lkIDAgJiYgYW5kcm9pZElucHV0TWFuYWdlci5pc0ZsdXNoaW5nKCkpICYmICFzdGF0ZS5pc0RyYWdnaW5nSW50ZXJuYWxseSkge1xuICAgICAgdmFyIF9yb290ID0gUmVhY3RFZGl0b3IuZmluZERvY3VtZW50T3JTaGFkb3dSb290KGVkaXRvcik7XG4gICAgICB2YXIge1xuICAgICAgICBhY3RpdmVFbGVtZW50XG4gICAgICB9ID0gX3Jvb3Q7XG4gICAgICB2YXIgX2VsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICAgIHZhciBkb21TZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24oX3Jvb3QpO1xuICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQgPT09IF9lbCkge1xuICAgICAgICBzdGF0ZS5sYXRlc3RFbGVtZW50ID0gYWN0aXZlRWxlbWVudDtcbiAgICAgICAgSVNfRk9DVVNFRC5zZXQoZWRpdG9yLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIElTX0ZPQ1VTRUQuZGVsZXRlKGVkaXRvcik7XG4gICAgICB9XG4gICAgICBpZiAoIWRvbVNlbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gVHJhbnNmb3Jtcy5kZXNlbGVjdChlZGl0b3IpO1xuICAgICAgfVxuICAgICAgdmFyIHtcbiAgICAgICAgYW5jaG9yTm9kZSxcbiAgICAgICAgZm9jdXNOb2RlXG4gICAgICB9ID0gZG9tU2VsZWN0aW9uO1xuICAgICAgdmFyIGFuY2hvck5vZGVTZWxlY3RhYmxlID0gUmVhY3RFZGl0b3IuaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCBhbmNob3JOb2RlKSB8fCBSZWFjdEVkaXRvci5pc1RhcmdldEluc2lkZU5vblJlYWRvbmx5Vm9pZChlZGl0b3IsIGFuY2hvck5vZGUpO1xuICAgICAgdmFyIGZvY3VzTm9kZUluRWRpdG9yID0gUmVhY3RFZGl0b3IuaGFzVGFyZ2V0KGVkaXRvciwgZm9jdXNOb2RlKTtcbiAgICAgIGlmIChhbmNob3JOb2RlU2VsZWN0YWJsZSAmJiBmb2N1c05vZGVJbkVkaXRvcikge1xuICAgICAgICB2YXIgcmFuZ2UgPSBSZWFjdEVkaXRvci50b1NsYXRlUmFuZ2UoZWRpdG9yLCBkb21TZWxlY3Rpb24sIHtcbiAgICAgICAgICBleGFjdE1hdGNoOiBmYWxzZSxcbiAgICAgICAgICBzdXBwcmVzc1Rocm93OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICBpZiAoIVJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikgJiYgIShhbmRyb2lkSW5wdXRNYW5hZ2VyICE9PSBudWxsICYmIGFuZHJvaWRJbnB1dE1hbmFnZXIgIT09IHZvaWQgMCAmJiBhbmRyb2lkSW5wdXRNYW5hZ2VyLmhhc1BlbmRpbmdDaGFuZ2VzKCkpICYmICEoYW5kcm9pZElucHV0TWFuYWdlciAhPT0gbnVsbCAmJiBhbmRyb2lkSW5wdXRNYW5hZ2VyICE9PSB2b2lkIDAgJiYgYW5kcm9pZElucHV0TWFuYWdlci5pc0ZsdXNoaW5nKCkpKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHJhbmdlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5kcm9pZElucHV0TWFuYWdlciA9PT0gbnVsbCB8fCBhbmRyb2lkSW5wdXRNYW5hZ2VyID09PSB2b2lkIDAgfHwgYW5kcm9pZElucHV0TWFuYWdlci5oYW5kbGVVc2VyU2VsZWN0KHJhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIERlc2VsZWN0IHRoZSBlZGl0b3IgaWYgdGhlIGRvbSBzZWxlY3Rpb24gaXMgbm90IHNlbGVjdGFibGUgaW4gcmVhZG9ubHkgbW9kZVxuICAgICAgaWYgKHJlYWRPbmx5ICYmICghYW5jaG9yTm9kZVNlbGVjdGFibGUgfHwgIWZvY3VzTm9kZUluRWRpdG9yKSkge1xuICAgICAgICBUcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvcik7XG4gICAgICB9XG4gICAgfVxuICB9LCAxMDApLCBbZWRpdG9yLCByZWFkT25seSwgc3RhdGVdKTtcbiAgdmFyIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UgPSB1c2VNZW1vKCgpID0+IGRlYm91bmNlKG9uRE9NU2VsZWN0aW9uQ2hhbmdlLCAwKSwgW29uRE9NU2VsZWN0aW9uQ2hhbmdlXSk7XG4gIGFuZHJvaWRJbnB1dE1hbmFnZXJSZWYuY3VycmVudCA9IHVzZUFuZHJvaWRJbnB1dE1hbmFnZXIoe1xuICAgIG5vZGU6IHJlZixcbiAgICBvbkRPTVNlbGVjdGlvbkNoYW5nZSxcbiAgICBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlXG4gIH0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICB2YXIgX2FuZHJvaWRJbnB1dE1hbmFnZXJSLCBfYW5kcm9pZElucHV0TWFuYWdlclIyO1xuICAgIC8vIFVwZGF0ZSBlbGVtZW50LXJlbGF0ZWQgd2VhayBtYXBzIHdpdGggdGhlIERPTSBlbGVtZW50IHJlZi5cbiAgICB2YXIgd2luZG93O1xuICAgIGlmIChyZWYuY3VycmVudCAmJiAod2luZG93ID0gZ2V0RGVmYXVsdFZpZXcocmVmLmN1cnJlbnQpKSkge1xuICAgICAgRURJVE9SX1RPX1dJTkRPVy5zZXQoZWRpdG9yLCB3aW5kb3cpO1xuICAgICAgRURJVE9SX1RPX0VMRU1FTlQuc2V0KGVkaXRvciwgcmVmLmN1cnJlbnQpO1xuICAgICAgTk9ERV9UT19FTEVNRU5ULnNldChlZGl0b3IsIHJlZi5jdXJyZW50KTtcbiAgICAgIEVMRU1FTlRfVE9fTk9ERS5zZXQocmVmLmN1cnJlbnQsIGVkaXRvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIE5PREVfVE9fRUxFTUVOVC5kZWxldGUoZWRpdG9yKTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBET00gc2VsZWN0aW9uIHN0YXRlIGlzIGluIHN5bmMuXG4gICAgdmFyIHtcbiAgICAgIHNlbGVjdGlvblxuICAgIH0gPSBlZGl0b3I7XG4gICAgdmFyIHJvb3QgPSBSZWFjdEVkaXRvci5maW5kRG9jdW1lbnRPclNoYWRvd1Jvb3QoZWRpdG9yKTtcbiAgICB2YXIgZG9tU2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKHJvb3QpO1xuICAgIGlmICghZG9tU2VsZWN0aW9uIHx8ICFSZWFjdEVkaXRvci5pc0ZvY3VzZWQoZWRpdG9yKSB8fCAoX2FuZHJvaWRJbnB1dE1hbmFnZXJSID0gYW5kcm9pZElucHV0TWFuYWdlclJlZi5jdXJyZW50KSAhPT0gbnVsbCAmJiBfYW5kcm9pZElucHV0TWFuYWdlclIgIT09IHZvaWQgMCAmJiBfYW5kcm9pZElucHV0TWFuYWdlclIuaGFzUGVuZGluZ0FjdGlvbigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzZXREb21TZWxlY3Rpb24gPSBmb3JjZUNoYW5nZSA9PiB7XG4gICAgICB2YXIgaGFzRG9tU2VsZWN0aW9uID0gZG9tU2VsZWN0aW9uLnR5cGUgIT09ICdOb25lJztcbiAgICAgIC8vIElmIHRoZSBET00gc2VsZWN0aW9uIGlzIHByb3Blcmx5IHVuc2V0LCB3ZSdyZSBkb25lLlxuICAgICAgaWYgKCFzZWxlY3Rpb24gJiYgIWhhc0RvbVNlbGVjdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBHZXQgYW5jaG9yTm9kZSBhbmQgZm9jdXNOb2RlXG4gICAgICB2YXIgZm9jdXNOb2RlID0gZG9tU2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgICAgIHZhciBhbmNob3JOb2RlO1xuICAgICAgLy8gQ09NUEFUOiBJbiBmaXJlZm94IHRoZSBub3JtYWwgc2VsZWN0aW9uIHdheSBkb2VzIG5vdCB3b3JrXG4gICAgICAvLyAoaHR0cHM6Ly9naXRodWIuY29tL2lhbnN0b3JtdGF5bG9yL3NsYXRlL3B1bGwvNTQ4NiNpc3N1ZS0xODIwNzIwMjIzKVxuICAgICAgaWYgKElTX0ZJUkVGT1ggJiYgZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQgPiAxKSB7XG4gICAgICAgIHZhciBmaXJzdFJhbmdlID0gZG9tU2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgICAgIHZhciBsYXN0UmFuZ2UgPSBkb21TZWxlY3Rpb24uZ2V0UmFuZ2VBdChkb21TZWxlY3Rpb24ucmFuZ2VDb3VudCAtIDEpO1xuICAgICAgICAvLyBSaWdodCB0byBsZWZ0XG4gICAgICAgIGlmIChmaXJzdFJhbmdlLnN0YXJ0Q29udGFpbmVyID09PSBmb2N1c05vZGUpIHtcbiAgICAgICAgICBhbmNob3JOb2RlID0gbGFzdFJhbmdlLmVuZENvbnRhaW5lcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBMZWZ0IHRvIHJpZ2h0XG4gICAgICAgICAgYW5jaG9yTm9kZSA9IGZpcnN0UmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFuY2hvck5vZGUgPSBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZTtcbiAgICAgIH1cbiAgICAgIC8vIHZlcmlmeSB0aGF0IHRoZSBkb20gc2VsZWN0aW9uIGlzIGluIHRoZSBlZGl0b3JcbiAgICAgIHZhciBlZGl0b3JFbGVtZW50ID0gRURJVE9SX1RPX0VMRU1FTlQuZ2V0KGVkaXRvcik7XG4gICAgICB2YXIgaGFzRG9tU2VsZWN0aW9uSW5FZGl0b3IgPSBmYWxzZTtcbiAgICAgIGlmIChlZGl0b3JFbGVtZW50LmNvbnRhaW5zKGFuY2hvck5vZGUpICYmIGVkaXRvckVsZW1lbnQuY29udGFpbnMoZm9jdXNOb2RlKSkge1xuICAgICAgICBoYXNEb21TZWxlY3Rpb25JbkVkaXRvciA9IHRydWU7XG4gICAgICB9XG4gICAgICAvLyBJZiB0aGUgRE9NIHNlbGVjdGlvbiBpcyBpbiB0aGUgZWRpdG9yIGFuZCB0aGUgZWRpdG9yIHNlbGVjdGlvbiBpcyBhbHJlYWR5IGNvcnJlY3QsIHdlJ3JlIGRvbmUuXG4gICAgICBpZiAoaGFzRG9tU2VsZWN0aW9uICYmIGhhc0RvbVNlbGVjdGlvbkluRWRpdG9yICYmIHNlbGVjdGlvbiAmJiAhZm9yY2VDaGFuZ2UpIHtcbiAgICAgICAgdmFyIHNsYXRlUmFuZ2UgPSBSZWFjdEVkaXRvci50b1NsYXRlUmFuZ2UoZWRpdG9yLCBkb21TZWxlY3Rpb24sIHtcbiAgICAgICAgICBleGFjdE1hdGNoOiB0cnVlLFxuICAgICAgICAgIC8vIGRvbVNlbGVjdGlvbiBpcyBub3QgbmVjZXNzYXJpbHkgYSB2YWxpZCBTbGF0ZSByYW5nZVxuICAgICAgICAgIC8vIChlLmcuIHdoZW4gY2xpY2tpbmcgb24gY29udGVudEVkaXRhYmxlOmZhbHNlIGVsZW1lbnQpXG4gICAgICAgICAgc3VwcHJlc3NUaHJvdzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNsYXRlUmFuZ2UgJiYgUmFuZ2UuZXF1YWxzKHNsYXRlUmFuZ2UsIHNlbGVjdGlvbikpIHtcbiAgICAgICAgICB2YXIgX2FuY2hvck5vZGU7XG4gICAgICAgICAgaWYgKCFzdGF0ZS5oYXNNYXJrUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRW5zdXJlIHNlbGVjdGlvbiBpcyBpbnNpZGUgdGhlIG1hcmsgcGxhY2Vob2xkZXJcbiAgICAgICAgICBpZiAoKF9hbmNob3JOb2RlID0gYW5jaG9yTm9kZSkgIT09IG51bGwgJiYgX2FuY2hvck5vZGUgIT09IHZvaWQgMCAmJiAoX2FuY2hvck5vZGUgPSBfYW5jaG9yTm9kZS5wYXJlbnRFbGVtZW50KSAhPT0gbnVsbCAmJiBfYW5jaG9yTm9kZSAhPT0gdm9pZCAwICYmIF9hbmNob3JOb2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS1tYXJrLXBsYWNlaG9sZGVyJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHdoZW4gPEVkaXRhYmxlLz4gaXMgYmVpbmcgY29udHJvbGxlZCB0aHJvdWdoIGV4dGVybmFsIHZhbHVlXG4gICAgICAvLyB0aGVuIGl0cyBjaGlsZHJlbiBtaWdodCBqdXN0IGNoYW5nZSAtIERPTSByZXNwb25kcyB0byBpdCBvbiBpdHMgb3duXG4gICAgICAvLyBidXQgU2xhdGUncyB2YWx1ZSBpcyBub3QgYmVpbmcgdXBkYXRlZCB0aHJvdWdoIGFueSBvcGVyYXRpb25cbiAgICAgIC8vIGFuZCB0aHVzIGl0IGRvZXNuJ3QgdHJhbnNmb3JtIHNlbGVjdGlvbiBvbiBpdHMgb3duXG4gICAgICBpZiAoc2VsZWN0aW9uICYmICFSZWFjdEVkaXRvci5oYXNSYW5nZShlZGl0b3IsIHNlbGVjdGlvbikpIHtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbiA9IFJlYWN0RWRpdG9yLnRvU2xhdGVSYW5nZShlZGl0b3IsIGRvbVNlbGVjdGlvbiwge1xuICAgICAgICAgIGV4YWN0TWF0Y2g6IGZhbHNlLFxuICAgICAgICAgIHN1cHByZXNzVGhyb3c6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIE90aGVyd2lzZSB0aGUgRE9NIHNlbGVjdGlvbiBpcyBvdXQgb2Ygc3luYywgc28gdXBkYXRlIGl0LlxuICAgICAgc3RhdGUuaXNVcGRhdGluZ1NlbGVjdGlvbiA9IHRydWU7XG4gICAgICB2YXIgbmV3RG9tUmFuZ2UgPSBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3RG9tUmFuZ2UgPSBzZWxlY3Rpb24gJiYgUmVhY3RFZGl0b3IudG9ET01SYW5nZShlZGl0b3IsIHNlbGVjdGlvbik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIElnbm9yZSwgZG9tIGFuZCBzdGF0ZSBtaWdodCBiZSBvdXQgb2Ygc3luY1xuICAgICAgfVxuICAgICAgaWYgKG5ld0RvbVJhbmdlKSB7XG4gICAgICAgIGlmIChSZWFjdEVkaXRvci5pc0NvbXBvc2luZyhlZGl0b3IpICYmICFJU19BTkRST0lEKSB7XG4gICAgICAgICAgZG9tU2VsZWN0aW9uLmNvbGxhcHNlVG9FbmQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICBkb21TZWxlY3Rpb24uc2V0QmFzZUFuZEV4dGVudChuZXdEb21SYW5nZS5lbmRDb250YWluZXIsIG5ld0RvbVJhbmdlLmVuZE9mZnNldCwgbmV3RG9tUmFuZ2Uuc3RhcnRDb250YWluZXIsIG5ld0RvbVJhbmdlLnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb21TZWxlY3Rpb24uc2V0QmFzZUFuZEV4dGVudChuZXdEb21SYW5nZS5zdGFydENvbnRhaW5lciwgbmV3RG9tUmFuZ2Uuc3RhcnRPZmZzZXQsIG5ld0RvbVJhbmdlLmVuZENvbnRhaW5lciwgbmV3RG9tUmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBzY3JvbGxTZWxlY3Rpb25JbnRvVmlldyhlZGl0b3IsIG5ld0RvbVJhbmdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdEb21SYW5nZTtcbiAgICB9O1xuICAgIC8vIEluIGZpcmVmb3ggaWYgdGhlcmUgaXMgbW9yZSB0aGVuIDEgcmFuZ2UgYW5kIHdlIGNhbGwgc2V0RG9tU2VsZWN0aW9uIHdlIHJlbW92ZSB0aGUgYWJpbGl0eSB0byBzZWxlY3QgbW9yZSBjZWxscyBpbiBhIHRhYmxlXG4gICAgaWYgKGRvbVNlbGVjdGlvbi5yYW5nZUNvdW50IDw9IDEpIHtcbiAgICAgIHNldERvbVNlbGVjdGlvbigpO1xuICAgIH1cbiAgICB2YXIgZW5zdXJlU2VsZWN0aW9uID0gKChfYW5kcm9pZElucHV0TWFuYWdlclIyID0gYW5kcm9pZElucHV0TWFuYWdlclJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYW5kcm9pZElucHV0TWFuYWdlclIyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYW5kcm9pZElucHV0TWFuYWdlclIyLmlzRmx1c2hpbmcoKSkgPT09ICdhY3Rpb24nO1xuICAgIGlmICghSVNfQU5EUk9JRCB8fCAhZW5zdXJlU2VsZWN0aW9uKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc3RhdGUuaXNVcGRhdGluZ1NlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0SWQgPSBudWxsO1xuICAgIHZhciBhbmltYXRpb25GcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGlmIChlbnN1cmVTZWxlY3Rpb24pIHtcbiAgICAgICAgdmFyIGVuc3VyZURvbVNlbGVjdGlvbiA9IGZvcmNlQ2hhbmdlID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICAgICAgICAgIGVsLmZvY3VzKCk7XG4gICAgICAgICAgICBzZXREb21TZWxlY3Rpb24oZm9yY2VDaGFuZ2UpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSwgZG9tIGFuZCBzdGF0ZSBtaWdodCBiZSBvdXQgb2Ygc3luY1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ29tcGF0OiBBbmRyb2lkIElNRXMgdHJ5IHRvIGZvcmNlIHRoZWlyIHNlbGVjdGlvbiBieSBtYW51YWxseSByZS1hcHBseWluZyBpdCBldmVuIGFmdGVyIHdlIHNldCBpdC5cbiAgICAgICAgLy8gVGhpcyBlc3NlbnRpYWxseSB3b3VsZCBtYWtlIHNldHRpbmcgdGhlIHNsYXRlIHNlbGVjdGlvbiBkdXJpbmcgYW4gdXBkYXRlIG1lYW5pbmdsZXNzLCBzbyB3ZSBmb3JjZSBpdFxuICAgICAgICAvLyBhZ2FpbiBoZXJlLiBXZSBjYW4ndCBvbmx5IGRvIGl0IGluIHRoZSBzZXRUaW1lb3V0IGFmdGVyIHRoZSBhbmltYXRpb24gZnJhbWUgc2luY2UgdGhhdCB3b3VsZCBjYXVzZSBhXG4gICAgICAgIC8vIHZpc2libGUgZmxpY2tlci5cbiAgICAgICAgZW5zdXJlRG9tU2VsZWN0aW9uKCk7XG4gICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIC8vIENPTVBBVDogV2hpbGUgc2V0dGluZyB0aGUgc2VsZWN0aW9uIGluIGFuIGFuaW1hdGlvbiBmcmFtZSB2aXN1YWxseSBjb3JyZWN0bHkgc2V0cyB0aGUgc2VsZWN0aW9uLFxuICAgICAgICAgIC8vIGl0IGRvZXNuJ3QgdXBkYXRlIEdCb2FyZHMgc3BlbGxjaGVja2VyIHN0YXRlLiBXZSBoYXZlIHRvIG1hbnVhbGx5IHRyaWdnZXIgYSBzZWxlY3Rpb24gY2hhbmdlIGFmdGVyXG4gICAgICAgICAgLy8gdGhlIGFuaW1hdGlvbiBmcmFtZSB0byBlbnN1cmUgaXQgZGlzcGxheXMgdGhlIGNvcnJlY3Qgc3RhdGUuXG4gICAgICAgICAgZW5zdXJlRG9tU2VsZWN0aW9uKHRydWUpO1xuICAgICAgICAgIHN0YXRlLmlzVXBkYXRpbmdTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lSWQpO1xuICAgICAgaWYgKHRpbWVvdXRJZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgLy8gTGlzdGVuIG9uIHRoZSBuYXRpdmUgYGJlZm9yZWlucHV0YCBldmVudCB0byBnZXQgcmVhbCBcIkxldmVsIDJcIiBldmVudHMuIFRoaXNcbiAgLy8gaXMgcmVxdWlyZWQgYmVjYXVzZSBSZWFjdCdzIGBiZWZvcmVpbnB1dGAgaXMgZmFrZSBhbmQgbmV2ZXIgcmVhbGx5IGF0dGFjaGVzXG4gIC8vIHRvIHRoZSByZWFsIGV2ZW50IHNhZGx5LiAoMjAxOS8xMS8wMSlcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMTIxMVxuICB2YXIgb25ET01CZWZvcmVJbnB1dCA9IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICBoYW5kbGVOYXRpdmVIaXN0b3J5RXZlbnRzKGVkaXRvciwgZXZlbnQpO1xuICAgIHZhciBlbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgdmFyIHJvb3QgPSBlbC5nZXRSb290Tm9kZSgpO1xuICAgIGlmIChwcm9jZXNzaW5nICE9PSBudWxsICYmIHByb2Nlc3NpbmcgIT09IHZvaWQgMCAmJiBwcm9jZXNzaW5nLmN1cnJlbnQgJiYgSVNfV0VCS0lUICYmIHJvb3QgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgICB2YXIgcmFuZ2VzID0gZXZlbnQuZ2V0VGFyZ2V0UmFuZ2VzKCk7XG4gICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbMF07XG4gICAgICB2YXIgbmV3UmFuZ2UgPSBuZXcgd2luZG93LlJhbmdlKCk7XG4gICAgICBuZXdSYW5nZS5zZXRTdGFydChyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQpO1xuICAgICAgbmV3UmFuZ2Uuc2V0RW5kKHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICAgIC8vIFRyYW5zbGF0ZSB0aGUgRE9NIFJhbmdlIGludG8gYSBTbGF0ZSBSYW5nZVxuICAgICAgdmFyIHNsYXRlUmFuZ2UgPSBSZWFjdEVkaXRvci50b1NsYXRlUmFuZ2UoZWRpdG9yLCBuZXdSYW5nZSwge1xuICAgICAgICBleGFjdE1hdGNoOiBmYWxzZSxcbiAgICAgICAgc3VwcHJlc3NUaHJvdzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzbGF0ZVJhbmdlKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb25Vc2VySW5wdXQoKTtcbiAgICBpZiAoIXJlYWRPbmx5ICYmIFJlYWN0RWRpdG9yLmhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNET01FdmVudEhhbmRsZWQoZXZlbnQsIHByb3BzT25ET01CZWZvcmVJbnB1dCkpIHtcbiAgICAgIHZhciBfRURJVE9SX1RPX1VTRVJfU0VMRUM7XG4gICAgICAvLyBDT01QQVQ6IEJlZm9yZUlucHV0IGV2ZW50cyBhcmVuJ3QgY2FuY2VsYWJsZSBvbiBhbmRyb2lkLCBzbyB3ZSBoYXZlIHRvIGhhbmRsZSB0aGVtIGRpZmZlcmVudGx5IHVzaW5nIHRoZSBhbmRyb2lkIGlucHV0IG1hbmFnZXIuXG4gICAgICBpZiAoYW5kcm9pZElucHV0TWFuYWdlclJlZi5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybiBhbmRyb2lkSW5wdXRNYW5hZ2VyUmVmLmN1cnJlbnQuaGFuZGxlRE9NQmVmb3JlSW5wdXQoZXZlbnQpO1xuICAgICAgfVxuICAgICAgLy8gU29tZSBJTUVzL0Nocm9tZSBleHRlbnNpb25zIGxpa2UgZS5nLiBHcmFtbWFybHkgc2V0IHRoZSBzZWxlY3Rpb24gaW1tZWRpYXRlbHkgYmVmb3JlXG4gICAgICAvLyB0cmlnZ2VyaW5nIGEgYGJlZm9yZWlucHV0YCBleHBlY3RpbmcgdGhlIGNoYW5nZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBpbW1lZGlhdGVseSBiZWZvcmVcbiAgICAgIC8vIHNldCBzZWxlY3Rpb24uXG4gICAgICBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlLmZsdXNoKCk7XG4gICAgICBvbkRPTVNlbGVjdGlvbkNoYW5nZS5mbHVzaCgpO1xuICAgICAgdmFyIHtcbiAgICAgICAgc2VsZWN0aW9uXG4gICAgICB9ID0gZWRpdG9yO1xuICAgICAgdmFyIHtcbiAgICAgICAgaW5wdXRUeXBlOiB0eXBlXG4gICAgICB9ID0gZXZlbnQ7XG4gICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGFUcmFuc2ZlciB8fCBldmVudC5kYXRhIHx8IHVuZGVmaW5lZDtcbiAgICAgIHZhciBpc0NvbXBvc2l0aW9uQ2hhbmdlID0gdHlwZSA9PT0gJ2luc2VydENvbXBvc2l0aW9uVGV4dCcgfHwgdHlwZSA9PT0gJ2RlbGV0ZUNvbXBvc2l0aW9uVGV4dCc7XG4gICAgICAvLyBDT01QQVQ6IHVzZSBjb21wb3NpdGlvbiBjaGFuZ2UgZXZlbnRzIGFzIGEgaGludCB0byB3aGVyZSB3ZSBzaG91bGQgaW5zZXJ0XG4gICAgICAvLyBjb21wb3NpdGlvbiB0ZXh0IGlmIHdlIGFyZW4ndCBjb21wb3NpbmcgdG8gd29yayBhcm91bmQgaHR0cHM6Ly9naXRodWIuY29tL2lhbnN0b3JtdGF5bG9yL3NsYXRlL2lzc3Vlcy81MDM4XG4gICAgICBpZiAoaXNDb21wb3NpdGlvbkNoYW5nZSAmJiBSZWFjdEVkaXRvci5pc0NvbXBvc2luZyhlZGl0b3IpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBuYXRpdmUgPSBmYWxzZTtcbiAgICAgIGlmICh0eXBlID09PSAnaW5zZXJ0VGV4dCcgJiYgc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikgJiZcbiAgICAgIC8vIE9ubHkgdXNlIG5hdGl2ZSBjaGFyYWN0ZXIgaW5zZXJ0aW9uIGZvciBzaW5nbGUgY2hhcmFjdGVycyBhLXogb3Igc3BhY2UgZm9yIG5vdy5cbiAgICAgIC8vIExvbmctcHJlc3MgZXZlbnRzIChob2xkIGEgKyBwcmVzcyA0ID0gw6QpIHRvIGNob29zZSBhIHNwZWNpYWwgY2hhcmFjdGVyIG90aGVyd2lzZVxuICAgICAgLy8gY2F1c2VzIGR1cGxpY2F0ZSBpbnNlcnRzLlxuICAgICAgZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhLmxlbmd0aCA9PT0gMSAmJiAvW2EteiBdL2kudGVzdChldmVudC5kYXRhKSAmJlxuICAgICAgLy8gQ2hyb21lIGhhcyBpc3N1ZXMgY29ycmVjdGx5IGVkaXRpbmcgdGhlIHN0YXJ0IG9mIG5vZGVzOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMjQ5NDA1XG4gICAgICAvLyBXaGVuIHRoZXJlIGlzIGFuIGlubGluZSBlbGVtZW50LCBlLmcuIGEgbGluaywgYW5kIHlvdSBzZWxlY3RcbiAgICAgIC8vIHJpZ2h0IGFmdGVyIGl0ICh0aGUgc3RhcnQgb2YgdGhlIG5leHQgbm9kZSkuXG4gICAgICBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldCAhPT0gMCkge1xuICAgICAgICBuYXRpdmUgPSB0cnVlO1xuICAgICAgICAvLyBTa2lwIG5hdGl2ZSBpZiB0aGVyZSBhcmUgbWFya3MsIGFzXG4gICAgICAgIC8vIGBpbnNlcnRUZXh0YCB3aWxsIGluc2VydCBhIG5vZGUsIG5vdCBqdXN0IHRleHQuXG4gICAgICAgIGlmIChlZGl0b3IubWFya3MpIHtcbiAgICAgICAgICBuYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgTk9ERV9NQVAgaXMgZGlydHksIHdlIGNhbid0IHRydXN0IHRoZSBzZWxlY3Rpb24gYW5jaG9yIChlZyBSZWFjdEVkaXRvci50b0RPTVBvaW50KVxuICAgICAgICBpZiAoIUlTX05PREVfTUFQX0RJUlRZLmdldChlZGl0b3IpKSB7XG4gICAgICAgICAgdmFyIF9ub2RlJHBhcmVudEVsZW1lbnQsIF93aW5kb3ckZ2V0Q29tcHV0ZWRTdDtcbiAgICAgICAgICAvLyBDaHJvbWUgYWxzbyBoYXMgaXNzdWVzIGNvcnJlY3RseSBlZGl0aW5nIHRoZSBlbmQgb2YgYW5jaG9yIGVsZW1lbnRzOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMjU5MTAwXG4gICAgICAgICAgLy8gVGhlcmVmb3JlIHdlIGRvbid0IGFsbG93IG5hdGl2ZSBldmVudHMgdG8gaW5zZXJ0IHRleHQgYXQgdGhlIGVuZCBvZiBhbmNob3Igbm9kZXMuXG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIGFuY2hvclxuICAgICAgICAgIH0gPSBzZWxlY3Rpb247XG4gICAgICAgICAgdmFyIFtub2RlLCBvZmZzZXRdID0gUmVhY3RFZGl0b3IudG9ET01Qb2ludChlZGl0b3IsIGFuY2hvcik7XG4gICAgICAgICAgdmFyIGFuY2hvck5vZGUgPSAoX25vZGUkcGFyZW50RWxlbWVudCA9IG5vZGUucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgX25vZGUkcGFyZW50RWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkcGFyZW50RWxlbWVudC5jbG9zZXN0KCdhJyk7XG4gICAgICAgICAgdmFyIF93aW5kb3cgPSBSZWFjdEVkaXRvci5nZXRXaW5kb3coZWRpdG9yKTtcbiAgICAgICAgICBpZiAobmF0aXZlICYmIGFuY2hvck5vZGUgJiYgUmVhY3RFZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIGFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgX2xhc3RUZXh0JHRleHRDb250ZW50O1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgbGFzdCB0ZXh0IG5vZGUgaW5zaWRlIHRoZSBhbmNob3IuXG4gICAgICAgICAgICB2YXIgbGFzdFRleHQgPSBfd2luZG93ID09PSBudWxsIHx8IF93aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF93aW5kb3cuZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihhbmNob3JOb2RlLCBOb2RlRmlsdGVyLlNIT1dfVEVYVCkubGFzdENoaWxkKCk7XG4gICAgICAgICAgICBpZiAobGFzdFRleHQgPT09IG5vZGUgJiYgKChfbGFzdFRleHQkdGV4dENvbnRlbnQgPSBsYXN0VGV4dC50ZXh0Q29udGVudCkgPT09IG51bGwgfHwgX2xhc3RUZXh0JHRleHRDb250ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbGFzdFRleHQkdGV4dENvbnRlbnQubGVuZ3RoKSA9PT0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgIG5hdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDaHJvbWUgaGFzIGlzc3VlcyB3aXRoIHRoZSBwcmVzZW5jZSBvZiB0YWIgY2hhcmFjdGVycyBpbnNpZGUgZWxlbWVudHMgd2l0aCB3aGl0ZVNwYWNlID0gJ3ByZSdcbiAgICAgICAgICAvLyBjYXVzaW5nIGFibm9ybWFsIGluc2VydCBiZWhhdmlvcjogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTIxOTEzOVxuICAgICAgICAgIGlmIChuYXRpdmUgJiYgbm9kZS5wYXJlbnRFbGVtZW50ICYmIChfd2luZG93ID09PSBudWxsIHx8IF93aW5kb3cgPT09IHZvaWQgMCB8fCAoX3dpbmRvdyRnZXRDb21wdXRlZFN0ID0gX3dpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUucGFyZW50RWxlbWVudCkpID09PSBudWxsIHx8IF93aW5kb3ckZ2V0Q29tcHV0ZWRTdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3dpbmRvdyRnZXRDb21wdXRlZFN0LndoaXRlU3BhY2UpID09PSAncHJlJykge1xuICAgICAgICAgICAgdmFyIGJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgICBhdDogYW5jaG9yLnBhdGgsXG4gICAgICAgICAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQkMS5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoYmxvY2sgJiYgTm9kZS5zdHJpbmcoYmxvY2tbMF0pLmluY2x1ZGVzKCdcXHQnKSkge1xuICAgICAgICAgICAgICBuYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENPTVBBVDogRm9yIHRoZSBkZWxldGluZyBmb3J3YXJkL2JhY2t3YXJkIGlucHV0IHR5cGVzIHdlIGRvbid0IHdhbnRcbiAgICAgIC8vIHRvIGNoYW5nZSB0aGUgc2VsZWN0aW9uIGJlY2F1c2UgaXQgaXMgdGhlIHJhbmdlIHRoYXQgd2lsbCBiZSBkZWxldGVkLFxuICAgICAgLy8gYW5kIHRob3NlIGNvbW1hbmRzIGRldGVybWluZSB0aGF0IGZvciB0aGVtc2VsdmVzLlxuICAgICAgLy8gSWYgdGhlIE5PREVfTUFQIGlzIGRpcnR5LCB3ZSBjYW4ndCB0cnVzdCB0aGUgc2VsZWN0aW9uIGFuY2hvciAoZWcgUmVhY3RFZGl0b3IudG9ET01Qb2ludCB2aWEgUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKVxuICAgICAgaWYgKCghdHlwZS5zdGFydHNXaXRoKCdkZWxldGUnKSB8fCB0eXBlLnN0YXJ0c1dpdGgoJ2RlbGV0ZUJ5JykpICYmICFJU19OT0RFX01BUF9ESVJUWS5nZXQoZWRpdG9yKSkge1xuICAgICAgICB2YXIgW3RhcmdldFJhbmdlXSA9IGV2ZW50LmdldFRhcmdldFJhbmdlcygpO1xuICAgICAgICBpZiAodGFyZ2V0UmFuZ2UpIHtcbiAgICAgICAgICB2YXIgX3JhbmdlID0gUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgdGFyZ2V0UmFuZ2UsIHtcbiAgICAgICAgICAgIGV4YWN0TWF0Y2g6IGZhbHNlLFxuICAgICAgICAgICAgc3VwcHJlc3NUaHJvdzogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIXNlbGVjdGlvbiB8fCAhUmFuZ2UuZXF1YWxzKHNlbGVjdGlvbiwgX3JhbmdlKSkge1xuICAgICAgICAgICAgbmF0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uUmVmID0gIWlzQ29tcG9zaXRpb25DaGFuZ2UgJiYgZWRpdG9yLnNlbGVjdGlvbiAmJiBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgX3JhbmdlKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb25SZWYpIHtcbiAgICAgICAgICAgICAgRURJVE9SX1RPX1VTRVJfU0VMRUNUSU9OLnNldChlZGl0b3IsIHNlbGVjdGlvblJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NpdGlvbiBjaGFuZ2UgdHlwZXMgb2NjdXIgd2hpbGUgYSB1c2VyIGlzIGNvbXBvc2luZyB0ZXh0IGFuZCBjYW4ndCBiZVxuICAgICAgLy8gY2FuY2VsbGVkLiBMZXQgdGhlbSB0aHJvdWdoIGFuZCB3YWl0IGZvciB0aGUgY29tcG9zaXRpb24gdG8gZW5kLlxuICAgICAgaWYgKGlzQ29tcG9zaXRpb25DaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFuYXRpdmUpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIC8vIENPTVBBVDogSWYgdGhlIHNlbGVjdGlvbiBpcyBleHBhbmRlZCwgZXZlbiBpZiB0aGUgY29tbWFuZCBzZWVtcyBsaWtlXG4gICAgICAvLyBhIGRlbGV0ZSBmb3J3YXJkL2JhY2t3YXJkIGNvbW1hbmQgaXQgc2hvdWxkIGRlbGV0ZSB0aGUgc2VsZWN0aW9uLlxuICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikgJiYgdHlwZS5zdGFydHNXaXRoKCdkZWxldGUnKSkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gdHlwZS5lbmRzV2l0aCgnQmFja3dhcmQnKSA/ICdiYWNrd2FyZCcgOiAnZm9yd2FyZCc7XG4gICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IsIHtcbiAgICAgICAgICBkaXJlY3Rpb25cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdkZWxldGVCeUNvbXBvc2l0aW9uJzpcbiAgICAgICAgY2FzZSAnZGVsZXRlQnlDdXQnOlxuICAgICAgICBjYXNlICdkZWxldGVCeURyYWcnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdkZWxldGVDb250ZW50JzpcbiAgICAgICAgY2FzZSAnZGVsZXRlQ29udGVudEZvcndhcmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2RlbGV0ZUNvbnRlbnRCYWNrd2FyZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2RlbGV0ZUVudGlyZVNvZnRMaW5lJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnZGVsZXRlSGFyZExpbmVCYWNrd2FyZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnYmxvY2snXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnZGVsZXRlU29mdExpbmVCYWNrd2FyZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdkZWxldGVIYXJkTGluZUZvcndhcmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnYmxvY2snXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnZGVsZXRlU29mdExpbmVGb3J3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnZGVsZXRlV29yZEJhY2t3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICd3b3JkJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2RlbGV0ZVdvcmRGb3J3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ3dvcmQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnaW5zZXJ0TGluZUJyZWFrJzpcbiAgICAgICAgICBFZGl0b3IuaW5zZXJ0U29mdEJyZWFrKGVkaXRvcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2luc2VydFBhcmFncmFwaCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmluc2VydEJyZWFrKGVkaXRvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2luc2VydEZyb21Db21wb3NpdGlvbic6XG4gICAgICAgIGNhc2UgJ2luc2VydEZyb21Ecm9wJzpcbiAgICAgICAgY2FzZSAnaW5zZXJ0RnJvbVBhc3RlJzpcbiAgICAgICAgY2FzZSAnaW5zZXJ0RnJvbVlhbmsnOlxuICAgICAgICBjYXNlICdpbnNlcnRSZXBsYWNlbWVudFRleHQnOlxuICAgICAgICBjYXNlICdpbnNlcnRUZXh0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2luc2VydEZyb21Db21wb3NpdGlvbicpIHtcbiAgICAgICAgICAgICAgLy8gQ09NUEFUOiBpbiBTYWZhcmksIGBjb21wb3NpdGlvbmVuZGAgaXMgZGlzcGF0Y2hlZCBhZnRlciB0aGVcbiAgICAgICAgICAgICAgLy8gYGJlZm9yZWlucHV0YCBmb3IgXCJpbnNlcnRGcm9tQ29tcG9zaXRpb25cIi4gQnV0IGlmIHdlIHdhaXQgZm9yIGl0XG4gICAgICAgICAgICAgIC8vIHRoZW4gd2Ugd2lsbCBhYm9ydCBiZWNhdXNlIHdlJ3JlIHN0aWxsIGNvbXBvc2luZyBhbmQgdGhlIHNlbGVjdGlvblxuICAgICAgICAgICAgICAvLyB3b24ndCBiZSB1cGRhdGVkIHByb3Blcmx5LlxuICAgICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaW5wdXQtZXZlbnRzLTIvXG4gICAgICAgICAgICAgIGlmIChSZWFjdEVkaXRvci5pc0NvbXBvc2luZyhlZGl0b3IpKSB7XG4gICAgICAgICAgICAgICAgc2V0SXNDb21wb3NpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgIElTX0NPTVBPU0lORy5zZXQoZWRpdG9yLCBmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVzZSBhIHdlYWsgY29tcGFyaXNvbiBpbnN0ZWFkIG9mICdpbnN0YW5jZW9mJyB0byBhbGxvd1xuICAgICAgICAgICAgLy8gcHJvZ3JhbW1hdGljIGFjY2VzcyBvZiBwYXN0ZSBldmVudHMgY29taW5nIGZyb20gZXh0ZXJuYWwgd2luZG93c1xuICAgICAgICAgICAgLy8gbGlrZSBjeXByZXNzIHdoZXJlIGN5LndpbmRvdyBkb2VzIG5vdCB3b3JrIHJlYWxpYmx5XG4gICAgICAgICAgICBpZiAoKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5jb25zdHJ1Y3Rvci5uYW1lKSA9PT0gJ0RhdGFUcmFuc2ZlcicpIHtcbiAgICAgICAgICAgICAgUmVhY3RFZGl0b3IuaW5zZXJ0RGF0YShlZGl0b3IsIGRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgLy8gT25seSBpbnNlcnRUZXh0IG9wZXJhdGlvbnMgdXNlIHRoZSBuYXRpdmUgZnVuY3Rpb25hbGl0eSwgZm9yIG5vdy5cbiAgICAgICAgICAgICAgLy8gUG90ZW50aWFsbHkgZXhwYW5kIHRvIHNpbmdsZSBjaGFyYWN0ZXIgZGVsZXRlcywgYXMgd2VsbC5cbiAgICAgICAgICAgICAgaWYgKG5hdGl2ZSkge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkT3BlcmF0aW9ucy5jdXJyZW50LnB1c2goKCkgPT4gRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBkYXRhKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBkYXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gUmVzdG9yZSB0aGUgYWN0dWFsIHVzZXIgc2VjdGlvbiBpZiBub3RoaW5nIG1hbnVhbGx5IHNldCBpdC5cbiAgICAgIHZhciB0b1Jlc3RvcmUgPSAoX0VESVRPUl9UT19VU0VSX1NFTEVDID0gRURJVE9SX1RPX1VTRVJfU0VMRUNUSU9OLmdldChlZGl0b3IpKSA9PT0gbnVsbCB8fCBfRURJVE9SX1RPX1VTRVJfU0VMRUMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9FRElUT1JfVE9fVVNFUl9TRUxFQy51bnJlZigpO1xuICAgICAgRURJVE9SX1RPX1VTRVJfU0VMRUNUSU9OLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgaWYgKHRvUmVzdG9yZSAmJiAoIWVkaXRvci5zZWxlY3Rpb24gfHwgIVJhbmdlLmVxdWFscyhlZGl0b3Iuc2VsZWN0aW9uLCB0b1Jlc3RvcmUpKSkge1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHRvUmVzdG9yZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbZWRpdG9yLCBvbkRPTVNlbGVjdGlvbkNoYW5nZSwgb25Vc2VySW5wdXQsIHByb3BzT25ET01CZWZvcmVJbnB1dCwgcmVhZE9ubHksIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2VdKTtcbiAgdmFyIGNhbGxiYWNrUmVmID0gdXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgb25ET01TZWxlY3Rpb25DaGFuZ2UuY2FuY2VsKCk7XG4gICAgICBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlLmNhbmNlbCgpO1xuICAgICAgRURJVE9SX1RPX0VMRU1FTlQuZGVsZXRlKGVkaXRvcik7XG4gICAgICBOT0RFX1RPX0VMRU1FTlQuZGVsZXRlKGVkaXRvcik7XG4gICAgICBpZiAocmVmLmN1cnJlbnQgJiYgSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgVGhlIGBiZWZvcmVpbnB1dGAgZXZlbnQgaXNuJ3QgcmVjb2duaXplZC5cbiAgICAgICAgcmVmLmN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmVmb3JlaW5wdXQnLCBvbkRPTUJlZm9yZUlucHV0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXR0YWNoIGEgbmF0aXZlIERPTSBldmVudCBoYW5kbGVyIGZvciBgYmVmb3JlaW5wdXRgIGV2ZW50cywgYmVjYXVzZSBSZWFjdCdzXG4gICAgICAvLyBidWlsdC1pbiBgb25CZWZvcmVJbnB1dGAgaXMgYWN0dWFsbHkgYSBsZWFreSBwb2x5ZmlsbCB0aGF0IGRvZXNuJ3QgZXhwb3NlXG4gICAgICAvLyByZWFsIGBiZWZvcmVpbnB1dGAgZXZlbnRzIHNhZGx5Li4uICgyMDE5LzExLzA0KVxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMTIxMVxuICAgICAgaWYgKEhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlIFRoZSBgYmVmb3JlaW5wdXRgIGV2ZW50IGlzbid0IHJlY29nbml6ZWQuXG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JlaW5wdXQnLCBvbkRPTUJlZm9yZUlucHV0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVmLmN1cnJlbnQgPSBub2RlO1xuICAgIGlmICh0eXBlb2YgZm9yd2FyZGVkUmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmb3J3YXJkZWRSZWYobm9kZSk7XG4gICAgfSBlbHNlIGlmIChmb3J3YXJkZWRSZWYpIHtcbiAgICAgIGZvcndhcmRlZFJlZi5jdXJyZW50ID0gbm9kZTtcbiAgICB9XG4gIH0sIFtvbkRPTVNlbGVjdGlvbkNoYW5nZSwgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZSwgZWRpdG9yLCBvbkRPTUJlZm9yZUlucHV0LCBmb3J3YXJkZWRSZWZdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgdmFyIHdpbmRvdyA9IFJlYWN0RWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpO1xuICAgIC8vIENPTVBBVDogSW4gQ2hyb21lLCBgc2VsZWN0aW9uY2hhbmdlYCBldmVudHMgY2FuIGZpcmUgd2hlbiA8aW5wdXQ+IGFuZFxuICAgIC8vIDx0ZXh0YXJlYT4gZWxlbWVudHMgYXJlIGFwcGVuZGVkIHRvIHRoZSBET00sIGNhdXNpbmdcbiAgICAvLyBgZWRpdG9yLnNlbGVjdGlvbmAgdG8gYmUgb3ZlcndyaXR0ZW4gaW4gc29tZSBjaXJjdW1zdGFuY2VzLlxuICAgIC8vICgyMDI1LzAxLzE2KSBodHRwczovL2lzc3Vlcy5jaHJvbWl1bS5vcmcvaXNzdWVzLzM4OTM2ODQxMlxuICAgIHZhciBvblNlbGVjdGlvbkNoYW5nZSA9IF9yZWYgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgdGFyZ2V0XG4gICAgICB9ID0gX3JlZjtcbiAgICAgIHZhciB0YXJnZXRFbGVtZW50ID0gdGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgPyB0YXJnZXQgOiBudWxsO1xuICAgICAgdmFyIHRhcmdldFRhZ05hbWUgPSB0YXJnZXRFbGVtZW50ID09PSBudWxsIHx8IHRhcmdldEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhcmdldEVsZW1lbnQudGFnTmFtZTtcbiAgICAgIGlmICh0YXJnZXRUYWdOYW1lID09PSAnSU5QVVQnIHx8IHRhcmdldFRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZSgpO1xuICAgIH07XG4gICAgLy8gQXR0YWNoIGEgbmF0aXZlIERPTSBldmVudCBoYW5kbGVyIGZvciBgc2VsZWN0aW9uY2hhbmdlYCwgYmVjYXVzZSBSZWFjdCdzXG4gICAgLy8gYnVpbHQtaW4gYG9uU2VsZWN0YCBoYW5kbGVyIGRvZXNuJ3QgZmlyZSBmb3IgYWxsIHNlbGVjdGlvbiBjaGFuZ2VzLiBJdCdzXG4gICAgLy8gYSBsZWFreSBwb2x5ZmlsbCB0aGF0IG9ubHkgZmlyZXMgb24ga2V5cHJlc3NlcyBvciBjbGlja3MuIEluc3RlYWQsIHdlXG4gICAgLy8gd2FudCB0byBmaXJlIGZvciBhbnkgY2hhbmdlIHRvIHRoZSBzZWxlY3Rpb24gaW5zaWRlIHRoZSBlZGl0b3IuXG4gICAgLy8gKDIwMTkvMTEvMDQpIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNTc4NVxuICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBvblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgLy8gTGlzdGVuIGZvciBkcmFnZW5kIGFuZCBkcm9wIGdsb2JhbGx5LiBJbiBGaXJlZm94LCBpZiBhIGRyb3AgaGFuZGxlclxuICAgIC8vIGluaXRpYXRlcyBhbiBvcGVyYXRpb24gdGhhdCBjYXVzZXMgdGhlIG9yaWdpbmFsbHkgZHJhZ2dlZCBlbGVtZW50IHRvXG4gICAgLy8gdW5tb3VudCwgdGhhdCBlbGVtZW50IHdpbGwgbm90IGVtaXQgYSBkcmFnZW5kIGV2ZW50LiAoMjAyNC8wNi8yMSlcbiAgICB2YXIgc3RvcHBlZERyYWdnaW5nID0gKCkgPT4ge1xuICAgICAgc3RhdGUuaXNEcmFnZ2luZ0ludGVybmFsbHkgPSBmYWxzZTtcbiAgICB9O1xuICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgc3RvcHBlZERyYWdnaW5nKTtcbiAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsIHN0b3BwZWREcmFnZ2luZyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBvblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ2VuZCcsIHN0b3BwZWREcmFnZ2luZyk7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJvcCcsIHN0b3BwZWREcmFnZ2luZyk7XG4gICAgfTtcbiAgfSwgW3NjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UsIHN0YXRlXSk7XG4gIHZhciBkZWNvcmF0aW9ucyA9IGRlY29yYXRlKFtlZGl0b3IsIFtdXSk7XG4gIHZhciBkZWNvcmF0ZUNvbnRleHQgPSB1c2VEZWNvcmF0ZUNvbnRleHQoZGVjb3JhdGUpO1xuICB2YXIgc2hvd1BsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXIgJiYgZWRpdG9yLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5mcm9tKE5vZGUudGV4dHMoZWRpdG9yKSkubGVuZ3RoID09PSAxICYmIE5vZGUuc3RyaW5nKGVkaXRvcikgPT09ICcnICYmICFpc0NvbXBvc2luZztcbiAgdmFyIHBsYWNlSG9sZGVyUmVzaXplSGFuZGxlciA9IHVzZUNhbGxiYWNrKHBsYWNlaG9sZGVyRWwgPT4ge1xuICAgIGlmIChwbGFjZWhvbGRlckVsICYmIHNob3dQbGFjZWhvbGRlcikge1xuICAgICAgdmFyIF9wbGFjZWhvbGRlckVsJGdldEJvdTtcbiAgICAgIHNldFBsYWNlaG9sZGVySGVpZ2h0KChfcGxhY2Vob2xkZXJFbCRnZXRCb3UgPSBwbGFjZWhvbGRlckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSA9PT0gbnVsbCB8fCBfcGxhY2Vob2xkZXJFbCRnZXRCb3UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wbGFjZWhvbGRlckVsJGdldEJvdS5oZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRQbGFjZWhvbGRlckhlaWdodCh1bmRlZmluZWQpO1xuICAgIH1cbiAgfSwgW3Nob3dQbGFjZWhvbGRlcl0pO1xuICBpZiAoc2hvd1BsYWNlaG9sZGVyKSB7XG4gICAgdmFyIHN0YXJ0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgW10pO1xuICAgIGRlY29yYXRpb25zLnB1c2goe1xuICAgICAgW1BMQUNFSE9MREVSX1NZTUJPTF06IHRydWUsXG4gICAgICBwbGFjZWhvbGRlcixcbiAgICAgIG9uUGxhY2Vob2xkZXJSZXNpemU6IHBsYWNlSG9sZGVyUmVzaXplSGFuZGxlcixcbiAgICAgIGFuY2hvcjogc3RhcnQsXG4gICAgICBmb2N1czogc3RhcnRcbiAgICB9KTtcbiAgfVxuICB2YXIge1xuICAgIG1hcmtzXG4gIH0gPSBlZGl0b3I7XG4gIHN0YXRlLmhhc01hcmtQbGFjZWhvbGRlciA9IGZhbHNlO1xuICBpZiAoZWRpdG9yLnNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChlZGl0b3Iuc2VsZWN0aW9uKSAmJiBtYXJrcykge1xuICAgIHZhciB7XG4gICAgICBhbmNob3JcbiAgICB9ID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICB2YXIgbGVhZiA9IE5vZGUubGVhZihlZGl0b3IsIGFuY2hvci5wYXRoKTtcbiAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhsZWFmLCBfZXhjbHVkZWQyKTtcbiAgICAvLyBXaGlsZSBtYXJrcyBpc24ndCBhICdjb21wbGV0ZScgdGV4dCwgd2UgY2FuIHN0aWxsIHVzZSBsb29zZSBUZXh0LmVxdWFsc1xuICAgIC8vIGhlcmUgd2hpY2ggb25seSBjb21wYXJlcyBtYXJrcyBhbnl3YXkuXG4gICAgaWYgKCFUZXh0JDEuZXF1YWxzKGxlYWYsIG1hcmtzLCB7XG4gICAgICBsb29zZTogdHJ1ZVxuICAgIH0pKSB7XG4gICAgICBzdGF0ZS5oYXNNYXJrUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgdmFyIHVuc2V0ID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5rZXlzKHJlc3QpLm1hcChtYXJrID0+IFttYXJrLCBudWxsXSkpO1xuICAgICAgZGVjb3JhdGlvbnMucHVzaChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICAgIFtNQVJLX1BMQUNFSE9MREVSX1NZTUJPTF06IHRydWVcbiAgICAgIH0sIHVuc2V0KSwgbWFya3MpLCB7fSwge1xuICAgICAgICBhbmNob3IsXG4gICAgICAgIGZvY3VzOiBhbmNob3JcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1cbiAgLy8gVXBkYXRlIEVESVRPUl9UT19NQVJLX1BMQUNFSE9MREVSX01BUktTIGluIHNldFRpbWVvdXQgdXNlRWZmZWN0IHRvIGVuc3VyZSB3ZSBkb24ndCBzZXQgaXRcbiAgLy8gYmVmb3JlIHdlIHJlY2VpdmUgdGhlIGNvbXBvc2l0aW9uIGVuZCBldmVudC5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfSA9IGVkaXRvcjtcbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBhbmNob3I6IF9hbmNob3JcbiAgICAgICAgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgdmFyIF90ZXh0ID0gTm9kZS5sZWFmKGVkaXRvciwgX2FuY2hvci5wYXRoKTtcbiAgICAgICAgLy8gV2hpbGUgbWFya3MgaXNuJ3QgYSAnY29tcGxldGUnIHRleHQsIHdlIGNhbiBzdGlsbCB1c2UgbG9vc2UgVGV4dC5lcXVhbHNcbiAgICAgICAgLy8gaGVyZSB3aGljaCBvbmx5IGNvbXBhcmVzIG1hcmtzIGFueXdheS5cbiAgICAgICAgaWYgKG1hcmtzICYmICFUZXh0JDEuZXF1YWxzKF90ZXh0LCBtYXJrcywge1xuICAgICAgICAgIGxvb3NlOiB0cnVlXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLnNldChlZGl0b3IsIG1hcmtzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5kZWxldGUoZWRpdG9yKTtcbiAgICB9KTtcbiAgfSk7XG4gIHVzZUZsdXNoRGVmZXJyZWRTZWxlY3RvcnNPblJlbmRlcigpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhZE9ubHlDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHJlYWRPbmx5XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvc2luZ0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogaXNDb21wb3NpbmdcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGVjb3JhdGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGRlY29yYXRlQ29udGV4dFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZXN0b3JlRE9NLCB7XG4gICAgbm9kZTogcmVmLFxuICAgIHJlY2VpdmVkVXNlcklucHV0OiByZWNlaXZlZFVzZXJJbnB1dFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgcm9sZTogcmVhZE9ubHkgPyB1bmRlZmluZWQgOiAndGV4dGJveCcsXG4gICAgXCJhcmlhLW11bHRpbGluZVwiOiByZWFkT25seSA/IHVuZGVmaW5lZCA6IHRydWVcbiAgfSwgYXR0cmlidXRlcyksIHt9LCB7XG4gICAgLy8gQ09NUEFUOiBDZXJ0YWluIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIGBiZWZvcmVpbnB1dGAgZXZlbnQsIHNvIHdlJ2RcbiAgICAvLyBoYXZlIHRvIHVzZSBoYWNrcyB0byBtYWtlIHRoZXNlIHJlcGxhY2VtZW50LWJhc2VkIGZlYXR1cmVzIHdvcmsuXG4gICAgLy8gRm9yIFNTUiBzaXR1YXRpb25zIEhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCBpcyBmYWxzZSBhbmQgcmVzdWx0cyBpbiBwcm9wXG4gICAgLy8gbWlzbWF0Y2ggd2FybmluZyBhcHAgbW92ZXMgdG8gYnJvd3Nlci4gUGFzcy10aHJvdWdoIGNvbnN1bWVyIHByb3BzIHdoZW5cbiAgICAvLyBub3QgQ0FOX1VTRV9ET00gKFNTUikgYW5kIGRlZmF1bHQgdG8gZmFsc3kgdmFsdWVcbiAgICBzcGVsbENoZWNrOiBIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQgfHwgIUNBTl9VU0VfRE9NID8gYXR0cmlidXRlcy5zcGVsbENoZWNrIDogZmFsc2UsXG4gICAgYXV0b0NvcnJlY3Q6IEhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCB8fCAhQ0FOX1VTRV9ET00gPyBhdHRyaWJ1dGVzLmF1dG9Db3JyZWN0IDogJ2ZhbHNlJyxcbiAgICBhdXRvQ2FwaXRhbGl6ZTogSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUIHx8ICFDQU5fVVNFX0RPTSA/IGF0dHJpYnV0ZXMuYXV0b0NhcGl0YWxpemUgOiAnZmFsc2UnLFxuICAgIFwiZGF0YS1zbGF0ZS1lZGl0b3JcIjogdHJ1ZSxcbiAgICBcImRhdGEtc2xhdGUtbm9kZVwiOiBcInZhbHVlXCIsXG4gICAgLy8gZXhwbGljaXRseSBzZXQgdGhpc1xuICAgIGNvbnRlbnRFZGl0YWJsZTogIXJlYWRPbmx5LFxuICAgIC8vIGluIHNvbWUgY2FzZXMsIGEgZGVjb3JhdGlvbiBuZWVkcyBhY2Nlc3MgdG8gdGhlIHJhbmdlIC8gc2VsZWN0aW9uIHRvIGRlY29yYXRlIGEgdGV4dCBub2RlLFxuICAgIC8vIHRoZW4geW91IHdpbGwgc2VsZWN0IHRoZSB3aG9sZSB0ZXh0IG5vZGUgd2hlbiB5b3Ugc2VsZWN0IHBhcnQgdGhlIG9mIHRleHRcbiAgICAvLyB0aGlzIG1hZ2ljIHpJbmRleD1cIi0xXCIgd2lsbCBmaXggaXRcbiAgICB6aW5kZXg6IC0xLFxuICAgIHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZzogdHJ1ZSxcbiAgICByZWY6IGNhbGxiYWNrUmVmLFxuICAgIHN0eWxlOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRpc2FibGVEZWZhdWx0U3R5bGVzID8ge30gOiBfb2JqZWN0U3ByZWFkKHtcbiAgICAgIC8vIEFsbG93IHBvc2l0aW9uaW5nIHJlbGF0aXZlIHRvIHRoZSBlZGl0YWJsZSBlbGVtZW50LlxuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAvLyBQcmVzZXJ2ZSBhZGphY2VudCB3aGl0ZXNwYWNlIGFuZCBuZXcgbGluZXMuXG4gICAgICB3aGl0ZVNwYWNlOiAncHJlLXdyYXAnLFxuICAgICAgLy8gQWxsb3cgd29yZHMgdG8gYnJlYWsgaWYgdGhleSBhcmUgdG9vIGxvbmcuXG4gICAgICB3b3JkV3JhcDogJ2JyZWFrLXdvcmQnXG4gICAgfSwgcGxhY2Vob2xkZXJIZWlnaHQgPyB7XG4gICAgICBtaW5IZWlnaHQ6IHBsYWNlaG9sZGVySGVpZ2h0XG4gICAgfSA6IHt9KSksIHVzZXJTdHlsZSksXG4gICAgb25CZWZvcmVJbnB1dDogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgLy8gQ09NUEFUOiBDZXJ0YWluIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIGBiZWZvcmVpbnB1dGAgZXZlbnQsIHNvIHdlXG4gICAgICAvLyBmYWxsIGJhY2sgdG8gUmVhY3QncyBsZWFreSBwb2x5ZmlsbCBpbnN0ZWFkIGp1c3QgZm9yIGl0LiBJdFxuICAgICAgLy8gb25seSB3b3JrcyBmb3IgdGhlIGBpbnNlcnRUZXh0YCBpbnB1dCB0eXBlLlxuICAgICAgaWYgKCFIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQgJiYgIXJlYWRPbmx5ICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkJlZm9yZUlucHV0KSAmJiBSZWFjdEVkaXRvci5oYXNTZWxlY3RhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAoIVJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikpIHtcbiAgICAgICAgICB2YXIgX3RleHQyID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICBFZGl0b3IuaW5zZXJ0VGV4dChlZGl0b3IsIF90ZXh0Mik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbYXR0cmlidXRlcy5vbkJlZm9yZUlucHV0LCBlZGl0b3IsIHJlYWRPbmx5XSksXG4gICAgb25JbnB1dDogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKGlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uSW5wdXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChhbmRyb2lkSW5wdXRNYW5hZ2VyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgYW5kcm9pZElucHV0TWFuYWdlclJlZi5jdXJyZW50LmhhbmRsZUlucHV0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIEZsdXNoIG5hdGl2ZSBvcGVyYXRpb25zLCBhcyBuYXRpdmUgZXZlbnRzIHdpbGwgaGF2ZSBwcm9wb2dhdGVkXG4gICAgICAvLyBhbmQgd2UgY2FuIGNvcnJlY3RseSBjb21wYXJlIERPTSB0ZXh0IHZhbHVlcyBpbiBjb21wb25lbnRzXG4gICAgICAvLyB0byBzdG9wIHJlbmRlcmluZywgc28gdGhhdCBicm93c2VyIGZ1bmN0aW9ucyBsaWtlIGF1dG9jb3JyZWN0XG4gICAgICAvLyBhbmQgc3BlbGxjaGVjayB3b3JrIGFzIGV4cGVjdGVkLlxuICAgICAgZm9yICh2YXIgb3Agb2YgZGVmZXJyZWRPcGVyYXRpb25zLmN1cnJlbnQpIHtcbiAgICAgICAgb3AoKTtcbiAgICAgIH1cbiAgICAgIGRlZmVycmVkT3BlcmF0aW9ucy5jdXJyZW50ID0gW107XG4gICAgICAvLyBDT01QQVQ6IFNpbmNlIGBiZWZvcmVpbnB1dGAgZG9lc24ndCBmdWxseSBgcHJldmVudERlZmF1bHRgLFxuICAgICAgLy8gdGhlcmUncyBhIGNoYW5jZSB0aGF0IGNvbnRlbnQgbWlnaHQgYmUgcGxhY2VkIGluIHRoZSBicm93c2VyJ3MgdW5kbyBzdGFjay5cbiAgICAgIC8vIFRoaXMgbWVhbnMgdW5kbyBjYW4gYmUgdHJpZ2dlcmVkIGV2ZW4gd2hlbiB0aGUgZGl2IGlzIG5vdCBmb2N1c2VkLFxuICAgICAgLy8gYW5kIGl0IG9ubHkgdHJpZ2dlcnMgdGhlIGlucHV0IGV2ZW50IGZvciB0aGUgbm9kZS4gKDIwMjQvMTAvMDkpXG4gICAgICBpZiAoIVJlYWN0RWRpdG9yLmlzRm9jdXNlZChlZGl0b3IpKSB7XG4gICAgICAgIGhhbmRsZU5hdGl2ZUhpc3RvcnlFdmVudHMoZWRpdG9yLCBldmVudC5uYXRpdmVFdmVudCk7XG4gICAgICB9XG4gICAgfSwgW2F0dHJpYnV0ZXMub25JbnB1dCwgZWRpdG9yXSksXG4gICAgb25CbHVyOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAocmVhZE9ubHkgfHwgc3RhdGUuaXNVcGRhdGluZ1NlbGVjdGlvbiB8fCAhUmVhY3RFZGl0b3IuaGFzU2VsZWN0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgfHwgaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25CbHVyKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBDT01QQVQ6IElmIHRoZSBjdXJyZW50IGBhY3RpdmVFbGVtZW50YCBpcyBzdGlsbCB0aGUgcHJldmlvdXNcbiAgICAgIC8vIG9uZSwgdGhpcyBpcyBkdWUgdG8gdGhlIHdpbmRvdyBiZWluZyBibHVycmVkIHdoZW4gdGhlIHRhYlxuICAgICAgLy8gaXRzZWxmIGJlY29tZXMgdW5mb2N1c2VkLCBzbyB3ZSB3YW50IHRvIGFib3J0IGVhcmx5IHRvIGFsbG93IHRvXG4gICAgICAvLyBlZGl0b3IgdG8gc3RheSBmb2N1c2VkIHdoZW4gdGhlIHRhYiBiZWNvbWVzIGZvY3VzZWQgYWdhaW4uXG4gICAgICB2YXIgcm9vdCA9IFJlYWN0RWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChlZGl0b3IpO1xuICAgICAgaWYgKHN0YXRlLmxhdGVzdEVsZW1lbnQgPT09IHJvb3QuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIge1xuICAgICAgICByZWxhdGVkVGFyZ2V0XG4gICAgICB9ID0gZXZlbnQ7XG4gICAgICB2YXIgZWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgICAgLy8gQ09NUEFUOiBUaGUgZXZlbnQgc2hvdWxkIGJlIGlnbm9yZWQgaWYgdGhlIGZvY3VzIGlzIHJldHVybmluZ1xuICAgICAgLy8gdG8gdGhlIGVkaXRvciBmcm9tIGFuIGVtYmVkZGVkIGVkaXRhYmxlIGVsZW1lbnQgKGVnLiBhbiA8aW5wdXQ+XG4gICAgICAvLyBlbGVtZW50IGluc2lkZSBhIHZvaWQgbm9kZSkuXG4gICAgICBpZiAocmVsYXRlZFRhcmdldCA9PT0gZWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gQ09NUEFUOiBUaGUgZXZlbnQgc2hvdWxkIGJlIGlnbm9yZWQgaWYgdGhlIGZvY3VzIGlzIG1vdmluZyBmcm9tXG4gICAgICAvLyB0aGUgZWRpdG9yIHRvIGluc2lkZSBhIHZvaWQgbm9kZSdzIHNwYWNlciBlbGVtZW50LlxuICAgICAgaWYgKGlzRE9NRWxlbWVudChyZWxhdGVkVGFyZ2V0KSAmJiByZWxhdGVkVGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS1zcGFjZXInKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBDT01QQVQ6IFRoZSBldmVudCBzaG91bGQgYmUgaWdub3JlZCBpZiB0aGUgZm9jdXMgaXMgbW92aW5nIHRvIGFcbiAgICAgIC8vIG5vbi0gZWRpdGFibGUgc2VjdGlvbiBvZiBhbiBlbGVtZW50IHRoYXQgaXNuJ3QgYSB2b2lkIG5vZGUgKGVnLlxuICAgICAgLy8gYSBsaXN0IGl0ZW0gb2YgdGhlIGNoZWNrIGxpc3QgZXhhbXBsZSkuXG4gICAgICBpZiAocmVsYXRlZFRhcmdldCAhPSBudWxsICYmIGlzRE9NTm9kZShyZWxhdGVkVGFyZ2V0KSAmJiBSZWFjdEVkaXRvci5oYXNET01Ob2RlKGVkaXRvciwgcmVsYXRlZFRhcmdldCkpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBSZWFjdEVkaXRvci50b1NsYXRlTm9kZShlZGl0b3IsIHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICBpZiAoRWxlbWVudCQxLmlzRWxlbWVudChub2RlKSAmJiAhZWRpdG9yLmlzVm9pZChub2RlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ09NUEFUOiBTYWZhcmkgZG9lc24ndCBhbHdheXMgcmVtb3ZlIHRoZSBzZWxlY3Rpb24gZXZlbiBpZiB0aGUgY29udGVudC1cbiAgICAgIC8vIGVkaXRhYmxlIGVsZW1lbnQgbm8gbG9uZ2VyIGhhcyBmb2N1cy4gUmVmZXIgdG86XG4gICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMjM1MzI0Ny9mb3JjZS1jb250ZW50ZWRpdGFibGUtZGl2LXRvLXN0b3AtYWNjZXB0aW5nLWlucHV0LWFmdGVyLWl0LWxvc2VzLWZvY3VzLXVuZGVyLXdlYlxuICAgICAgaWYgKElTX1dFQktJVCkge1xuICAgICAgICB2YXIgZG9tU2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKHJvb3QpO1xuICAgICAgICBkb21TZWxlY3Rpb24gPT09IG51bGwgfHwgZG9tU2VsZWN0aW9uID09PSB2b2lkIDAgfHwgZG9tU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgfVxuICAgICAgSVNfRk9DVVNFRC5kZWxldGUoZWRpdG9yKTtcbiAgICB9LCBbcmVhZE9ubHksIHN0YXRlLmlzVXBkYXRpbmdTZWxlY3Rpb24sIHN0YXRlLmxhdGVzdEVsZW1lbnQsIGVkaXRvciwgYXR0cmlidXRlcy5vbkJsdXJdKSxcbiAgICBvbkNsaWNrOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoUmVhY3RFZGl0b3IuaGFzVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25DbGljaykgJiYgaXNET01Ob2RlKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBSZWFjdEVkaXRvci50b1NsYXRlTm9kZShlZGl0b3IsIGV2ZW50LnRhcmdldCk7XG4gICAgICAgIHZhciBwYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBub2RlKTtcbiAgICAgICAgLy8gQXQgdGhpcyB0aW1lLCB0aGUgU2xhdGUgZG9jdW1lbnQgbWF5IGJlIGFyYml0cmFyaWx5IGRpZmZlcmVudCxcbiAgICAgICAgLy8gYmVjYXVzZSBvbkNsaWNrIGhhbmRsZXJzIGNhbiBjaGFuZ2UgdGhlIGRvY3VtZW50IGJlZm9yZSB3ZSBnZXQgaGVyZS5cbiAgICAgICAgLy8gVGhlcmVmb3JlIHdlIG11c3QgY2hlY2sgdGhhdCB0aGlzIHBhdGggYWN0dWFsbHkgZXhpc3RzLFxuICAgICAgICAvLyBhbmQgdGhhdCBpdCBzdGlsbCByZWZlcnMgdG8gdGhlIHNhbWUgbm9kZS5cbiAgICAgICAgaWYgKCFFZGl0b3IuaGFzUGF0aChlZGl0b3IsIHBhdGgpIHx8IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCkgIT09IG5vZGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmRldGFpbCA9PT0gVFJJUExFX0NMSUNLICYmIHBhdGgubGVuZ3RoID49IDEpIHtcbiAgICAgICAgICB2YXIgYmxvY2tQYXRoID0gcGF0aDtcbiAgICAgICAgICBpZiAoIShFbGVtZW50JDEuaXNFbGVtZW50KG5vZGUpICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbm9kZSkpKSB7XG4gICAgICAgICAgICB2YXIgX2Jsb2NrJDtcbiAgICAgICAgICAgIHZhciBibG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudCQxLmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pLFxuICAgICAgICAgICAgICBhdDogcGF0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBibG9ja1BhdGggPSAoX2Jsb2NrJCA9IGJsb2NrID09PSBudWxsIHx8IGJsb2NrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBibG9ja1sxXSkgIT09IG51bGwgJiYgX2Jsb2NrJCAhPT0gdm9pZCAwID8gX2Jsb2NrJCA6IHBhdGguc2xpY2UoMCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGJsb2NrUGF0aCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCByYW5nZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWFkT25seSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX3N0YXJ0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgcGF0aCk7XG4gICAgICAgIHZhciBlbmQgPSBFZGl0b3IuZW5kKGVkaXRvciwgcGF0aCk7XG4gICAgICAgIHZhciBzdGFydFZvaWQgPSBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgICBhdDogX3N0YXJ0XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZW5kVm9pZCA9IEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBlbmRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdGFydFZvaWQgJiYgZW5kVm9pZCAmJiBQYXRoLmVxdWFscyhzdGFydFZvaWRbMV0sIGVuZFZvaWRbMV0pKSB7XG4gICAgICAgICAgdmFyIF9yYW5nZTIgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBfc3RhcnQpO1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgX3JhbmdlMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbZWRpdG9yLCBhdHRyaWJ1dGVzLm9uQ2xpY2ssIHJlYWRPbmx5XSksXG4gICAgb25Db21wb3NpdGlvbkVuZDogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKFJlYWN0RWRpdG9yLmhhc1NlbGVjdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpKSB7XG4gICAgICAgIHZhciBfYW5kcm9pZElucHV0TWFuYWdlclIzO1xuICAgICAgICBpZiAoUmVhY3RFZGl0b3IuaXNDb21wb3NpbmcoZWRpdG9yKSkge1xuICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgc2V0SXNDb21wb3NpbmcoZmFsc2UpO1xuICAgICAgICAgICAgSVNfQ09NUE9TSU5HLnNldChlZGl0b3IsIGZhbHNlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAoX2FuZHJvaWRJbnB1dE1hbmFnZXJSMyA9IGFuZHJvaWRJbnB1dE1hbmFnZXJSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2FuZHJvaWRJbnB1dE1hbmFnZXJSMyA9PT0gdm9pZCAwIHx8IF9hbmRyb2lkSW5wdXRNYW5hZ2VyUjMuaGFuZGxlQ29tcG9zaXRpb25FbmQoZXZlbnQpO1xuICAgICAgICBpZiAoaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25Db21wb3NpdGlvbkVuZCkgfHwgSVNfQU5EUk9JRCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDT01QQVQ6IEluIENocm9tZSwgYGJlZm9yZWlucHV0YCBldmVudHMgZm9yIGNvbXBvc2l0aW9uc1xuICAgICAgICAvLyBhcmVuJ3QgY29ycmVjdCBhbmQgbmV2ZXIgZmlyZSB0aGUgXCJpbnNlcnRGcm9tQ29tcG9zaXRpb25cIlxuICAgICAgICAvLyB0eXBlIHRoYXQgd2UgbmVlZC4gU28gaW5zdGVhZCwgaW5zZXJ0IHdoZW5ldmVyIGEgY29tcG9zaXRpb25cbiAgICAgICAgLy8gZW5kcyBzaW5jZSBpdCB3aWxsIGFscmVhZHkgaGF2ZSBiZWVuIGNvbW1pdHRlZCB0byB0aGUgRE9NLlxuICAgICAgICBpZiAoIUlTX1dFQktJVCAmJiAhSVNfRklSRUZPWF9MRUdBQ1kgJiYgIUlTX0lPUyAmJiAhSVNfV0VDSEFUQlJPV1NFUiAmJiAhSVNfVUNfTU9CSUxFICYmIGV2ZW50LmRhdGEpIHtcbiAgICAgICAgICB2YXIgcGxhY2Vob2xkZXJNYXJrcyA9IEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5nZXQoZWRpdG9yKTtcbiAgICAgICAgICBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1MuZGVsZXRlKGVkaXRvcik7XG4gICAgICAgICAgLy8gRW5zdXJlIHdlIGluc2VydCB0ZXh0IHdpdGggdGhlIG1hcmtzIHRoZSB1c2VyIHdhcyBhY3R1YWxseSBzZWVpbmdcbiAgICAgICAgICBpZiAocGxhY2Vob2xkZXJNYXJrcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBFRElUT1JfVE9fVVNFUl9NQVJLUy5zZXQoZWRpdG9yLCBlZGl0b3IubWFya3MpO1xuICAgICAgICAgICAgZWRpdG9yLm1hcmtzID0gcGxhY2Vob2xkZXJNYXJrcztcbiAgICAgICAgICB9XG4gICAgICAgICAgRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBldmVudC5kYXRhKTtcbiAgICAgICAgICB2YXIgdXNlck1hcmtzID0gRURJVE9SX1RPX1VTRVJfTUFSS1MuZ2V0KGVkaXRvcik7XG4gICAgICAgICAgRURJVE9SX1RPX1VTRVJfTUFSS1MuZGVsZXRlKGVkaXRvcik7XG4gICAgICAgICAgaWYgKHVzZXJNYXJrcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlZGl0b3IubWFya3MgPSB1c2VyTWFya3M7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW2F0dHJpYnV0ZXMub25Db21wb3NpdGlvbkVuZCwgZWRpdG9yXSksXG4gICAgb25Db21wb3NpdGlvblVwZGF0ZTogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKFJlYWN0RWRpdG9yLmhhc1NlbGVjdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkNvbXBvc2l0aW9uVXBkYXRlKSkge1xuICAgICAgICBpZiAoIVJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikpIHtcbiAgICAgICAgICBzZXRJc0NvbXBvc2luZyh0cnVlKTtcbiAgICAgICAgICBJU19DT01QT1NJTkcuc2V0KGVkaXRvciwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbYXR0cmlidXRlcy5vbkNvbXBvc2l0aW9uVXBkYXRlLCBlZGl0b3JdKSxcbiAgICBvbkNvbXBvc2l0aW9uU3RhcnQ6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmIChSZWFjdEVkaXRvci5oYXNTZWxlY3RhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICB2YXIgX2FuZHJvaWRJbnB1dE1hbmFnZXJSNDtcbiAgICAgICAgKF9hbmRyb2lkSW5wdXRNYW5hZ2VyUjQgPSBhbmRyb2lkSW5wdXRNYW5hZ2VyUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hbmRyb2lkSW5wdXRNYW5hZ2VyUjQgPT09IHZvaWQgMCB8fCBfYW5kcm9pZElucHV0TWFuYWdlclI0LmhhbmRsZUNvbXBvc2l0aW9uU3RhcnQoZXZlbnQpO1xuICAgICAgICBpZiAoaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25Db21wb3NpdGlvblN0YXJ0KSB8fCBJU19BTkRST0lEKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldElzQ29tcG9zaW5nKHRydWUpO1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHNlbGVjdGlvblxuICAgICAgICB9ID0gZWRpdG9yO1xuICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFthdHRyaWJ1dGVzLm9uQ29tcG9zaXRpb25TdGFydCwgZWRpdG9yXSksXG4gICAgb25Db3B5OiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoUmVhY3RFZGl0b3IuaGFzU2VsZWN0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uQ29weSkgJiYgIWlzRE9NRXZlbnRUYXJnZXRJbnB1dChldmVudCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgUmVhY3RFZGl0b3Iuc2V0RnJhZ21lbnREYXRhKGVkaXRvciwgZXZlbnQuY2xpcGJvYXJkRGF0YSwgJ2NvcHknKTtcbiAgICAgIH1cbiAgICB9LCBbYXR0cmlidXRlcy5vbkNvcHksIGVkaXRvcl0pLFxuICAgIG9uQ3V0OiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoIXJlYWRPbmx5ICYmIFJlYWN0RWRpdG9yLmhhc1NlbGVjdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkN1dCkgJiYgIWlzRE9NRXZlbnRUYXJnZXRJbnB1dChldmVudCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgUmVhY3RFZGl0b3Iuc2V0RnJhZ21lbnREYXRhKGVkaXRvciwgZXZlbnQuY2xpcGJvYXJkRGF0YSwgJ2N1dCcpO1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHNlbGVjdGlvblxuICAgICAgICB9ID0gZWRpdG9yO1xuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgaWYgKFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBzZWxlY3Rpb24uYW5jaG9yLnBhdGgpO1xuICAgICAgICAgICAgaWYgKEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSkge1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtyZWFkT25seSwgZWRpdG9yLCBhdHRyaWJ1dGVzLm9uQ3V0XSksXG4gICAgb25EcmFnT3ZlcjogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKFJlYWN0RWRpdG9yLmhhc1RhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uRHJhZ092ZXIpKSB7XG4gICAgICAgIC8vIE9ubHkgd2hlbiB0aGUgdGFyZ2V0IGlzIHZvaWQsIGNhbGwgYHByZXZlbnREZWZhdWx0YCB0byBzaWduYWxcbiAgICAgICAgLy8gdGhhdCBkcm9wcyBhcmUgYWxsb3dlZC4gRWRpdGFibGUgY29udGVudCBpcyBkcm9wcGFibGUgYnlcbiAgICAgICAgLy8gZGVmYXVsdCwgYW5kIGNhbGxpbmcgYHByZXZlbnREZWZhdWx0YCBoaWRlcyB0aGUgY3Vyc29yLlxuICAgICAgICB2YXIgbm9kZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgaWYgKEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFthdHRyaWJ1dGVzLm9uRHJhZ092ZXIsIGVkaXRvcl0pLFxuICAgIG9uRHJhZ1N0YXJ0OiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoIXJlYWRPbmx5ICYmIFJlYWN0RWRpdG9yLmhhc1RhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uRHJhZ1N0YXJ0KSkge1xuICAgICAgICB2YXIgbm9kZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgdmFyIHBhdGggPSBSZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIG5vZGUpO1xuICAgICAgICB2YXIgdm9pZE1hdGNoID0gRWxlbWVudCQxLmlzRWxlbWVudChub2RlKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkgfHwgRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIHN0YXJ0aW5nIGEgZHJhZyBvbiBhIHZvaWQgbm9kZSwgbWFrZSBzdXJlIGl0IGlzIHNlbGVjdGVkXG4gICAgICAgIC8vIHNvIHRoYXQgaXQgc2hvd3MgdXAgaW4gdGhlIHNlbGVjdGlvbidzIGZyYWdtZW50LlxuICAgICAgICBpZiAodm9pZE1hdGNoKSB7XG4gICAgICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgcGF0aCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCByYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuaXNEcmFnZ2luZ0ludGVybmFsbHkgPSB0cnVlO1xuICAgICAgICBSZWFjdEVkaXRvci5zZXRGcmFnbWVudERhdGEoZWRpdG9yLCBldmVudC5kYXRhVHJhbnNmZXIsICdkcmFnJyk7XG4gICAgICB9XG4gICAgfSwgW3JlYWRPbmx5LCBlZGl0b3IsIGF0dHJpYnV0ZXMub25EcmFnU3RhcnQsIHN0YXRlXSksXG4gICAgb25Ecm9wOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoIXJlYWRPbmx5ICYmIFJlYWN0RWRpdG9yLmhhc1RhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uRHJvcCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy8gS2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgZHJhZ2dlZCByYW5nZSBiZWZvcmUgdXBkYXRpbmcgc2VsZWN0aW9uXG4gICAgICAgIHZhciBkcmFnZ2VkUmFuZ2UgPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgICAvLyBGaW5kIHRoZSByYW5nZSB3aGVyZSB0aGUgZHJvcCBoYXBwZW5lZFxuICAgICAgICB2YXIgcmFuZ2UgPSBSZWFjdEVkaXRvci5maW5kRXZlbnRSYW5nZShlZGl0b3IsIGV2ZW50KTtcbiAgICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhVHJhbnNmZXI7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcmFuZ2UpO1xuICAgICAgICBpZiAoc3RhdGUuaXNEcmFnZ2luZ0ludGVybmFsbHkpIHtcbiAgICAgICAgICBpZiAoZHJhZ2dlZFJhbmdlICYmICFSYW5nZS5lcXVhbHMoZHJhZ2dlZFJhbmdlLCByYW5nZSkgJiYgIUVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGF0OiBkcmFnZ2VkUmFuZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBSZWFjdEVkaXRvci5pbnNlcnREYXRhKGVkaXRvciwgZGF0YSk7XG4gICAgICAgIC8vIFdoZW4gZHJhZ2dpbmcgZnJvbSBhbm90aGVyIHNvdXJjZSBpbnRvIHRoZSBlZGl0b3IsIGl0J3MgcG9zc2libGVcbiAgICAgICAgLy8gdGhhdCB0aGUgY3VycmVudCBlZGl0b3IgZG9lcyBub3QgaGF2ZSBmb2N1cy5cbiAgICAgICAgaWYgKCFSZWFjdEVkaXRvci5pc0ZvY3VzZWQoZWRpdG9yKSkge1xuICAgICAgICAgIFJlYWN0RWRpdG9yLmZvY3VzKGVkaXRvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbcmVhZE9ubHksIGVkaXRvciwgYXR0cmlidXRlcy5vbkRyb3AsIHN0YXRlXSksXG4gICAgb25EcmFnRW5kOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoIXJlYWRPbmx5ICYmIHN0YXRlLmlzRHJhZ2dpbmdJbnRlcm5hbGx5ICYmIGF0dHJpYnV0ZXMub25EcmFnRW5kICYmIFJlYWN0RWRpdG9yLmhhc1RhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgYXR0cmlidXRlcy5vbkRyYWdFbmQoZXZlbnQpO1xuICAgICAgfVxuICAgIH0sIFtyZWFkT25seSwgc3RhdGUsIGF0dHJpYnV0ZXMsIGVkaXRvcl0pLFxuICAgIG9uRm9jdXM6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmICghcmVhZE9ubHkgJiYgIXN0YXRlLmlzVXBkYXRpbmdTZWxlY3Rpb24gJiYgUmVhY3RFZGl0b3IuaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkZvY3VzKSkge1xuICAgICAgICB2YXIgZWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgICAgICB2YXIgcm9vdCA9IFJlYWN0RWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChlZGl0b3IpO1xuICAgICAgICBzdGF0ZS5sYXRlc3RFbGVtZW50ID0gcm9vdC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAvLyBDT01QQVQ6IElmIHRoZSBlZGl0b3IgaGFzIG5lc3RlZCBlZGl0YWJsZSBlbGVtZW50cywgdGhlIGZvY3VzXG4gICAgICAgIC8vIGNhbiBnbyB0byB0aGVtLiBJbiBGaXJlZm94LCB0aGlzIG11c3QgYmUgcHJldmVudGVkIGJlY2F1c2UgaXRcbiAgICAgICAgLy8gcmVzdWx0cyBpbiBpc3N1ZXMgd2l0aCBrZXlib2FyZCBuYXZpZ2F0aW9uLiAoMjAxNy8wMy8zMClcbiAgICAgICAgaWYgKElTX0ZJUkVGT1ggJiYgZXZlbnQudGFyZ2V0ICE9PSBlbCkge1xuICAgICAgICAgIGVsLmZvY3VzKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIElTX0ZPQ1VTRUQuc2V0KGVkaXRvciwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSwgW3JlYWRPbmx5LCBzdGF0ZSwgZWRpdG9yLCBhdHRyaWJ1dGVzLm9uRm9jdXNdKSxcbiAgICBvbktleURvd246IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmICghcmVhZE9ubHkgJiYgUmVhY3RFZGl0b3IuaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpKSB7XG4gICAgICAgIHZhciBfYW5kcm9pZElucHV0TWFuYWdlclI1O1xuICAgICAgICAoX2FuZHJvaWRJbnB1dE1hbmFnZXJSNSA9IGFuZHJvaWRJbnB1dE1hbmFnZXJSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2FuZHJvaWRJbnB1dE1hbmFnZXJSNSA9PT0gdm9pZCAwIHx8IF9hbmRyb2lkSW5wdXRNYW5hZ2VyUjUuaGFuZGxlS2V5RG93bihldmVudCk7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgbmF0aXZlRXZlbnRcbiAgICAgICAgfSA9IGV2ZW50O1xuICAgICAgICAvLyBDT01QQVQ6IFRoZSBjb21wb3NpdGlvbiBlbmQgZXZlbnQgaXNuJ3QgZmlyZWQgcmVsaWFibHkgaW4gYWxsIGJyb3dzZXJzLFxuICAgICAgICAvLyBzbyB3ZSBzb21ldGltZXMgbWlnaHQgZW5kIHVwIHN0dWNrIGluIGEgY29tcG9zaXRpb24gc3RhdGUgZXZlbiB0aG91Z2ggd2VcbiAgICAgICAgLy8gYXJlbid0IGNvbXBvc2luZyBhbnkgbW9yZS5cbiAgICAgICAgaWYgKFJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikgJiYgbmF0aXZlRXZlbnQuaXNDb21wb3NpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgSVNfQ09NUE9TSU5HLnNldChlZGl0b3IsIGZhbHNlKTtcbiAgICAgICAgICBzZXRJc0NvbXBvc2luZyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uS2V5RG93bikgfHwgUmVhY3RFZGl0b3IuaXNDb21wb3NpbmcoZWRpdG9yKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIge1xuICAgICAgICAgIHNlbGVjdGlvblxuICAgICAgICB9ID0gZWRpdG9yO1xuICAgICAgICB2YXIgZWxlbWVudCA9IGVkaXRvci5jaGlsZHJlbltzZWxlY3Rpb24gIT09IG51bGwgPyBzZWxlY3Rpb24uZm9jdXMucGF0aFswXSA6IDBdO1xuICAgICAgICB2YXIgaXNSVEwgPSBnZXREaXJlY3Rpb24oTm9kZS5zdHJpbmcoZWxlbWVudCkpID09PSAncnRsJztcbiAgICAgICAgLy8gQ09NUEFUOiBTaW5jZSB3ZSBwcmV2ZW50IHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9uXG4gICAgICAgIC8vIGBiZWZvcmVpbnB1dGAgZXZlbnRzLCB0aGUgYnJvd3NlciBkb2Vzbid0IHRoaW5rIHRoZXJlJ3MgZXZlclxuICAgICAgICAvLyBhbnkgaGlzdG9yeSBzdGFjayB0byB1bmRvIG9yIHJlZG8sIHNvIHdlIGhhdmUgdG8gbWFuYWdlIHRoZXNlXG4gICAgICAgIC8vIGhvdGtleXMgb3Vyc2VsdmVzLiAoMjAxOS8xMS8wNilcbiAgICAgICAgaWYgKEhvdGtleXMuaXNSZWRvKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdmFyIG1heWJlSGlzdG9yeUVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgICBpZiAodHlwZW9mIG1heWJlSGlzdG9yeUVkaXRvci5yZWRvID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZUhpc3RvcnlFZGl0b3IucmVkbygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEhvdGtleXMuaXNVbmRvKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdmFyIF9tYXliZUhpc3RvcnlFZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgICAgaWYgKHR5cGVvZiBfbWF5YmVIaXN0b3J5RWRpdG9yLnVuZG8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIF9tYXliZUhpc3RvcnlFZGl0b3IudW5kbygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ09NUEFUOiBDZXJ0YWluIGJyb3dzZXJzIGRvbid0IGhhbmRsZSB0aGUgc2VsZWN0aW9uIHVwZGF0ZXNcbiAgICAgICAgLy8gcHJvcGVybHkuIEluIENocm9tZSwgdGhlIHNlbGVjdGlvbiBpc24ndCBwcm9wZXJseSBleHRlbmRlZC5cbiAgICAgICAgLy8gQW5kIGluIEZpcmVmb3gsIHRoZSBzZWxlY3Rpb24gaXNuJ3QgcHJvcGVybHkgY29sbGFwc2VkLlxuICAgICAgICAvLyAoMjAxNy8xMC8xNylcbiAgICAgICAgaWYgKEhvdGtleXMuaXNNb3ZlTGluZUJhY2t3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ2xpbmUnLFxuICAgICAgICAgICAgcmV2ZXJzZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSG90a2V5cy5pc01vdmVMaW5lRm9yd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSG90a2V5cy5pc0V4dGVuZExpbmVCYWNrd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdsaW5lJyxcbiAgICAgICAgICAgIGVkZ2U6ICdmb2N1cycsXG4gICAgICAgICAgICByZXZlcnNlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChIb3RrZXlzLmlzRXh0ZW5kTGluZUZvcndhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnbGluZScsXG4gICAgICAgICAgICBlZGdlOiAnZm9jdXMnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENPTVBBVDogSWYgYSB2b2lkIG5vZGUgaXMgc2VsZWN0ZWQsIG9yIGEgemVyby13aWR0aCB0ZXh0IG5vZGVcbiAgICAgICAgLy8gYWRqYWNlbnQgdG8gYW4gaW5saW5lIGlzIHNlbGVjdGVkLCB3ZSBuZWVkIHRvIGhhbmRsZSB0aGVzZVxuICAgICAgICAvLyBob3RrZXlzIG1hbnVhbGx5IGJlY2F1c2UgYnJvd3NlcnMgd29uJ3QgYmUgYWJsZSB0byBza2lwIG92ZXJcbiAgICAgICAgLy8gdGhlIHZvaWQgbm9kZSB3aXRoIHRoZSB6ZXJvLXdpZHRoIHNwYWNlIG5vdCBiZWluZyBhbiBlbXB0eVxuICAgICAgICAvLyBzdHJpbmcuXG4gICAgICAgIGlmIChIb3RrZXlzLmlzTW92ZUJhY2t3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHJldmVyc2U6ICFpc1JUTFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuY29sbGFwc2UoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGVkZ2U6IGlzUlRMID8gJ2VuZCcgOiAnc3RhcnQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChIb3RrZXlzLmlzTW92ZUZvcndhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgcmV2ZXJzZTogaXNSVExcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmNvbGxhcHNlKGVkaXRvciwge1xuICAgICAgICAgICAgICBlZGdlOiBpc1JUTCA/ICdzdGFydCcgOiAnZW5kJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSG90a2V5cy5pc01vdmVXb3JkQmFja3dhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5jb2xsYXBzZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgZWRnZTogJ2ZvY3VzJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICd3b3JkJyxcbiAgICAgICAgICAgIHJldmVyc2U6ICFpc1JUTFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSG90a2V5cy5pc01vdmVXb3JkRm9yd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmNvbGxhcHNlKGVkaXRvciwge1xuICAgICAgICAgICAgICBlZGdlOiAnZm9jdXMnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ3dvcmQnLFxuICAgICAgICAgICAgcmV2ZXJzZTogaXNSVExcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ09NUEFUOiBDZXJ0YWluIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIGBiZWZvcmVpbnB1dGAgZXZlbnQsIHNvIHdlXG4gICAgICAgIC8vIGZhbGwgYmFjayB0byBndWVzc2luZyBhdCB0aGUgaW5wdXQgaW50ZW50aW9uIGZvciBob3RrZXlzLlxuICAgICAgICAvLyBDT01QQVQ6IEluIGlPUywgc29tZSBvZiB0aGVzZSBob3RrZXlzIGFyZSBoYW5kbGVkIGluIHRoZVxuICAgICAgICBpZiAoIUhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCkge1xuICAgICAgICAgIC8vIFdlIGRvbid0IGhhdmUgYSBjb3JlIGJlaGF2aW9yIGZvciB0aGVzZSwgYnV0IHRoZXkgY2hhbmdlIHRoZVxuICAgICAgICAgIC8vIERPTSBpZiB3ZSBkb24ndCBwcmV2ZW50IHRoZW0sIHNvIHdlIGhhdmUgdG8uXG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNCb2xkKG5hdGl2ZUV2ZW50KSB8fCBIb3RrZXlzLmlzSXRhbGljKG5hdGl2ZUV2ZW50KSB8fCBIb3RrZXlzLmlzVHJhbnNwb3NlQ2hhcmFjdGVyKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNTb2Z0QnJlYWsobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgRWRpdG9yLmluc2VydFNvZnRCcmVhayhlZGl0b3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc1NwbGl0QmxvY2sobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgRWRpdG9yLmluc2VydEJyZWFrKGVkaXRvcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzRGVsZXRlQmFja3dhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2JhY2t3YXJkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc0RlbGV0ZUZvcndhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2ZvcndhcmQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNEZWxldGVMaW5lQmFja3dhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2JhY2t3YXJkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzRGVsZXRlTGluZUZvcndhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2ZvcndhcmQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc0RlbGV0ZVdvcmRCYWNrd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnYmFja3dhcmQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIHVuaXQ6ICd3b3JkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNEZWxldGVXb3JkRm9yd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnZm9yd2FyZCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICB1bml0OiAnd29yZCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChJU19DSFJPTUUgfHwgSVNfV0VCS0lUKSB7XG4gICAgICAgICAgICAvLyBDT01QQVQ6IENocm9tZSBhbmQgU2FmYXJpIHN1cHBvcnQgYGJlZm9yZWlucHV0YCBldmVudCBidXQgZG8gbm90IGZpcmVcbiAgICAgICAgICAgIC8vIGFuIGV2ZW50IHdoZW4gZGVsZXRpbmcgYmFja3dhcmRzIGluIGEgc2VsZWN0ZWQgdm9pZCBpbmxpbmUgbm9kZVxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiAoSG90a2V5cy5pc0RlbGV0ZUJhY2t3YXJkKG5hdGl2ZUV2ZW50KSB8fCBIb3RrZXlzLmlzRGVsZXRlRm9yd2FyZChuYXRpdmVFdmVudCkpICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBzZWxlY3Rpb24uYW5jaG9yLnBhdGgpO1xuICAgICAgICAgICAgICBpZiAoRWxlbWVudCQxLmlzRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIGN1cnJlbnROb2RlKSAmJiAoRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgY3VycmVudE5vZGUpIHx8IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgY3VycmVudE5vZGUpKSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgdW5pdDogJ2Jsb2NrJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtyZWFkT25seSwgZWRpdG9yLCBhdHRyaWJ1dGVzLm9uS2V5RG93bl0pLFxuICAgIG9uUGFzdGU6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmICghcmVhZE9ubHkgJiYgUmVhY3RFZGl0b3IuaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vblBhc3RlKSkge1xuICAgICAgICAvLyBDT01QQVQ6IENlcnRhaW4gYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgYGJlZm9yZWlucHV0YCBldmVudCwgc28gd2VcbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIFJlYWN0J3MgYG9uUGFzdGVgIGhlcmUgaW5zdGVhZC5cbiAgICAgICAgLy8gQ09NUEFUOiBGaXJlZm94LCBDaHJvbWUgYW5kIFNhZmFyaSBkb24ndCBlbWl0IGBiZWZvcmVpbnB1dGAgZXZlbnRzXG4gICAgICAgIC8vIHdoZW4gXCJwYXN0ZSB3aXRob3V0IGZvcm1hdHRpbmdcIiBpcyB1c2VkLCBzbyBmYWxsYmFjay4gKDIwMjAvMDIvMjApXG4gICAgICAgIC8vIENPTVBBVDogU2FmYXJpIElucHV0RXZlbnRzIGdlbmVyYXRlZCBieSBwYXN0aW5nIHdvbid0IGluY2x1ZGVcbiAgICAgICAgLy8gYXBwbGljYXRpb24veC1zbGF0ZS1mcmFnbWVudCBpdGVtcywgc28gdXNlIHRoZVxuICAgICAgICAvLyBDbGlwYm9hcmRFdmVudCBoZXJlLiAoMjAyMy8wMy8xNSlcbiAgICAgICAgaWYgKCFIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQgfHwgaXNQbGFpblRleHRPbmx5UGFzdGUoZXZlbnQubmF0aXZlRXZlbnQpIHx8IElTX1dFQktJVCkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgUmVhY3RFZGl0b3IuaW5zZXJ0RGF0YShlZGl0b3IsIGV2ZW50LmNsaXBib2FyZERhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW3JlYWRPbmx5LCBlZGl0b3IsIGF0dHJpYnV0ZXMub25QYXN0ZV0pXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDaGlsZHJlbiwge1xuICAgIGRlY29yYXRpb25zOiBkZWNvcmF0aW9ucyxcbiAgICBub2RlOiBlZGl0b3IsXG4gICAgcmVuZGVyRWxlbWVudDogcmVuZGVyRWxlbWVudCxcbiAgICByZW5kZXJDaHVuazogcmVuZGVyQ2h1bmssXG4gICAgcmVuZGVyUGxhY2Vob2xkZXI6IHJlbmRlclBsYWNlaG9sZGVyLFxuICAgIHJlbmRlckxlYWY6IHJlbmRlckxlYWYsXG4gICAgcmVuZGVyVGV4dDogcmVuZGVyVGV4dFxuICB9KSkpKSkpO1xufSk7XG4vKipcbiAqIFRoZSBkZWZhdWx0IHBsYWNlaG9sZGVyIGVsZW1lbnRcbiAqL1xudmFyIERlZmF1bHRQbGFjZWhvbGRlciA9IF9yZWYyID0+IHtcbiAgdmFyIHtcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGNoaWxkcmVuXG4gIH0gPSBfcmVmMjtcbiAgcmV0dXJuIChcbiAgICAvKiNfX1BVUkVfXyovXG4gICAgLy8gQ09NUEFUOiBBcnRpZmljaWFsbHkgYWRkIGEgbGluZS1icmVhayB0byB0aGUgZW5kIG9uIHRoZSBwbGFjZWhvbGRlciBlbGVtZW50XG4gICAgLy8gdG8gcHJldmVudCBBbmRyb2lkIElNRXMgdG8gcGljayB1cCBpdHMgY29udGVudCBpbiBhdXRvY29ycmVjdCBhbmQgdG8gYXV0by1jYXBpdGFsaXplIHRoZSBmaXJzdCBsZXR0ZXJcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBfb2JqZWN0U3ByZWFkKHt9LCBhdHRyaWJ1dGVzKSwgY2hpbGRyZW4sIElTX0FORFJPSUQgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJiclwiLCBudWxsKSlcbiAgKTtcbn07XG4vKipcbiAqIEEgZGVmYXVsdCBtZW1vaXplZCBkZWNvcmF0ZSBmdW5jdGlvbi5cbiAqL1xudmFyIGRlZmF1bHREZWNvcmF0ZSA9ICgpID0+IFtdO1xuLyoqXG4gKiBBIGRlZmF1bHQgaW1wbGVtZW50IHRvIHNjcm9sbCBkb20gcmFuZ2UgaW50byB2aWV3LlxuICovXG52YXIgZGVmYXVsdFNjcm9sbFNlbGVjdGlvbkludG9WaWV3ID0gKGVkaXRvciwgZG9tUmFuZ2UpID0+IHtcbiAgLy8gVGhpcyB3YXMgYWZmZWN0aW5nIHRoZSBzZWxlY3Rpb24gb2YgbXVsdGlwbGUgYmxvY2tzIGFuZCBkcmFnZ2luZyBiZWhhdmlvcixcbiAgLy8gc28gZW5hYmxlZCBvbmx5IGlmIHRoZSBzZWxlY3Rpb24gaGFzIGJlZW4gY29sbGFwc2VkLlxuICBpZiAoZG9tUmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmICghZWRpdG9yLnNlbGVjdGlvbiB8fCBlZGl0b3Iuc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pKSkge1xuICAgIHZhciBsZWFmRWwgPSBkb21SYW5nZS5zdGFydENvbnRhaW5lci5wYXJlbnRFbGVtZW50O1xuICAgIC8vIENPTVBBVDogSW4gQ2hyb21lLCBkb21SYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBjYW4gcmV0dXJuIHplcm8gZGltZW5zaW9ucyBmb3IgdmFsaWQgcmFuZ2VzIChlLmcuIGxpbmUgYnJlYWtzKS5cbiAgICAvLyBXaGVuIHRoaXMgaGFwcGVucywgZG8gbm90IHNjcm9sbCBsaWtlIG1vc3QgZWRpdG9ycyBkby5cbiAgICB2YXIgZG9tUmVjdCA9IGRvbVJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBpc1plcm9EaW1lbnNpb25SZWN0ID0gZG9tUmVjdC53aWR0aCA9PT0gMCAmJiBkb21SZWN0LmhlaWdodCA9PT0gMCAmJiBkb21SZWN0LnggPT09IDAgJiYgZG9tUmVjdC55ID09PSAwO1xuICAgIGlmIChpc1plcm9EaW1lbnNpb25SZWN0KSB7XG4gICAgICB2YXIgbGVhZlJlY3QgPSBsZWFmRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgbGVhZkhhc0RpbWVuc2lvbnMgPSBsZWFmUmVjdC53aWR0aCA+IDAgfHwgbGVhZlJlY3QuaGVpZ2h0ID4gMDtcbiAgICAgIGlmIChsZWFmSGFzRGltZW5zaW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIC8vIERlZmF1bHQgYmVoYXZpb3I6IHVzZSBkb21SYW5nZSdzIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICAgIGxlYWZFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPSBkb21SYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QuYmluZChkb21SYW5nZSk7XG4gICAgc2Nyb2xsSW50b1ZpZXcobGVhZkVsLCB7XG4gICAgICBzY3JvbGxNb2RlOiAnaWYtbmVlZGVkJ1xuICAgIH0pO1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgYW4gdW5vcnRob2RveCBkZWxldGUgRDpcbiAgICBkZWxldGUgbGVhZkVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdDtcbiAgfVxufTtcbi8qKlxuICogQ2hlY2sgaWYgYW4gZXZlbnQgaXMgb3ZlcnJpZGVkIGJ5IGEgaGFuZGxlci5cbiAqL1xudmFyIGlzRXZlbnRIYW5kbGVkID0gKGV2ZW50LCBoYW5kbGVyKSA9PiB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgY3VzdG9tIGV2ZW50IGhhbmRsZXIgbWF5IHJldHVybiBhIGJvb2xlYW4gdG8gc3BlY2lmeSB3aGV0aGVyIHRoZSBldmVudFxuICAvLyBzaGFsbCBiZSB0cmVhdGVkIGFzIGJlaW5nIGhhbmRsZWQgb3Igbm90LlxuICB2YXIgc2hvdWxkVHJlYXRFdmVudEFzSGFuZGxlZCA9IGhhbmRsZXIoZXZlbnQpO1xuICBpZiAoc2hvdWxkVHJlYXRFdmVudEFzSGFuZGxlZCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHNob3VsZFRyZWF0RXZlbnRBc0hhbmRsZWQ7XG4gIH1cbiAgcmV0dXJuIGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8IGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCk7XG59O1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZXZlbnQncyB0YXJnZXQgaXMgYW4gaW5wdXQgZWxlbWVudFxuICovXG52YXIgaXNET01FdmVudFRhcmdldElucHV0ID0gZXZlbnQgPT4ge1xuICByZXR1cm4gaXNET01Ob2RlKGV2ZW50LnRhcmdldCkgJiYgKGV2ZW50LnRhcmdldCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgfHwgZXZlbnQudGFyZ2V0IGluc3RhbmNlb2YgSFRNTFRleHRBcmVhRWxlbWVudCk7XG59O1xuLyoqXG4gKiBDaGVjayBpZiBhIERPTSBldmVudCBpcyBvdmVycmlkZWQgYnkgYSBoYW5kbGVyLlxuICovXG52YXIgaXNET01FdmVudEhhbmRsZWQgPSAoZXZlbnQsIGhhbmRsZXIpID0+IHtcbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSBjdXN0b20gZXZlbnQgaGFuZGxlciBtYXkgcmV0dXJuIGEgYm9vbGVhbiB0byBzcGVjaWZ5IHdoZXRoZXIgdGhlIGV2ZW50XG4gIC8vIHNoYWxsIGJlIHRyZWF0ZWQgYXMgYmVpbmcgaGFuZGxlZCBvciBub3QuXG4gIHZhciBzaG91bGRUcmVhdEV2ZW50QXNIYW5kbGVkID0gaGFuZGxlcihldmVudCk7XG4gIGlmIChzaG91bGRUcmVhdEV2ZW50QXNIYW5kbGVkICE9IG51bGwpIHtcbiAgICByZXR1cm4gc2hvdWxkVHJlYXRFdmVudEFzSGFuZGxlZDtcbiAgfVxuICByZXR1cm4gZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcbn07XG52YXIgaGFuZGxlTmF0aXZlSGlzdG9yeUV2ZW50cyA9IChlZGl0b3IsIGV2ZW50KSA9PiB7XG4gIHZhciBtYXliZUhpc3RvcnlFZGl0b3IgPSBlZGl0b3I7XG4gIGlmIChldmVudC5pbnB1dFR5cGUgPT09ICdoaXN0b3J5VW5kbycgJiYgdHlwZW9mIG1heWJlSGlzdG9yeUVkaXRvci51bmRvID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbWF5YmVIaXN0b3J5RWRpdG9yLnVuZG8oKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGV2ZW50LmlucHV0VHlwZSA9PT0gJ2hpc3RvcnlSZWRvJyAmJiB0eXBlb2YgbWF5YmVIaXN0b3J5RWRpdG9yLnJlZG8gPT09ICdmdW5jdGlvbicpIHtcbiAgICBtYXliZUhpc3RvcnlFZGl0b3IucmVkbygpO1xuICAgIHJldHVybjtcbiAgfVxufTtcblxuLyoqXG4gKiBBIFJlYWN0IGNvbnRleHQgZm9yIHNoYXJpbmcgdGhlIGBmb2N1c2VkYCBzdGF0ZSBvZiB0aGUgZWRpdG9yLlxuICovXG52YXIgRm9jdXNlZENvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dChmYWxzZSk7XG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBgZm9jdXNlZGAgc3RhdGUgb2YgdGhlIGVkaXRvci5cbiAqL1xudmFyIHVzZUZvY3VzZWQgPSAoKSA9PiB7XG4gIHJldHVybiB1c2VDb250ZXh0KEZvY3VzZWRDb250ZXh0KTtcbn07XG5cbnZhciBSRUFDVF9NQUpPUl9WRVJTSU9OID0gcGFyc2VJbnQoUmVhY3QudmVyc2lvbi5zcGxpdCgnLicpWzBdLCAxMCk7XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJlZGl0b3JcIiwgXCJjaGlsZHJlblwiLCBcIm9uQ2hhbmdlXCIsIFwib25TZWxlY3Rpb25DaGFuZ2VcIiwgXCJvblZhbHVlQ2hhbmdlXCIsIFwiaW5pdGlhbFZhbHVlXCJdO1xuLyoqXG4gKiBBIHdyYXBwZXIgYXJvdW5kIHRoZSBwcm92aWRlciB0byBoYW5kbGUgYG9uQ2hhbmdlYCBldmVudHMsIGJlY2F1c2UgdGhlIGVkaXRvclxuICogaXMgYSBtdXRhYmxlIHNpbmdsZXRvbiBzbyBpdCB3b24ndCBldmVyIHJlZ2lzdGVyIGFzIFwiY2hhbmdlZFwiIG90aGVyd2lzZS5cbiAqL1xudmFyIFNsYXRlID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgICAgZWRpdG9yLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBvbkNoYW5nZSxcbiAgICAgIG9uU2VsZWN0aW9uQ2hhbmdlLFxuICAgICAgb25WYWx1ZUNoYW5nZSxcbiAgICAgIGluaXRpYWxWYWx1ZVxuICAgIH0gPSBwcm9wcyxcbiAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBfZXhjbHVkZWQpO1xuICAvLyBSdW4gb25jZSBvbiBmaXJzdCBtb3VudCwgYnV0IGJlZm9yZSBgdXNlRWZmZWN0YCBvciByZW5kZXJcbiAgUmVhY3QudXNlU3RhdGUoKCkgPT4ge1xuICAgIGlmICghTm9kZS5pc05vZGVMaXN0KGluaXRpYWxWYWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIltTbGF0ZV0gaW5pdGlhbFZhbHVlIGlzIGludmFsaWQhIEV4cGVjdGVkIGEgbGlzdCBvZiBlbGVtZW50cyBidXQgZ290OiBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KGluaXRpYWxWYWx1ZSkpKTtcbiAgICB9XG4gICAgaWYgKCFFZGl0b3IuaXNFZGl0b3IoZWRpdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW1NsYXRlXSBlZGl0b3IgaXMgaW52YWxpZCEgWW91IHBhc3NlZDogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShlZGl0b3IpKSk7XG4gICAgfVxuICAgIGVkaXRvci5jaGlsZHJlbiA9IGluaXRpYWxWYWx1ZTtcbiAgICBPYmplY3QuYXNzaWduKGVkaXRvciwgcmVzdCk7XG4gIH0pO1xuICB2YXIge1xuICAgIHNlbGVjdG9yQ29udGV4dCxcbiAgICBvbkNoYW5nZTogaGFuZGxlU2VsZWN0b3JDaGFuZ2VcbiAgfSA9IHVzZVNlbGVjdG9yQ29udGV4dCgpO1xuICB2YXIgb25Db250ZXh0Q2hhbmdlID0gdXNlQ2FsbGJhY2sob3B0aW9ucyA9PiB7XG4gICAgdmFyIF9vcHRpb25zJG9wZXJhdGlvbjtcbiAgICBpZiAob25DaGFuZ2UpIHtcbiAgICAgIG9uQ2hhbmdlKGVkaXRvci5jaGlsZHJlbik7XG4gICAgfVxuICAgIHN3aXRjaCAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgfHwgKF9vcHRpb25zJG9wZXJhdGlvbiA9IG9wdGlvbnMub3BlcmF0aW9uKSA9PT0gbnVsbCB8fCBfb3B0aW9ucyRvcGVyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRpb25zJG9wZXJhdGlvbi50eXBlKSB7XG4gICAgICBjYXNlICdzZXRfc2VsZWN0aW9uJzpcbiAgICAgICAgb25TZWxlY3Rpb25DaGFuZ2UgPT09IG51bGwgfHwgb25TZWxlY3Rpb25DaGFuZ2UgPT09IHZvaWQgMCB8fCBvblNlbGVjdGlvbkNoYW5nZShlZGl0b3Iuc2VsZWN0aW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBvblZhbHVlQ2hhbmdlID09PSBudWxsIHx8IG9uVmFsdWVDaGFuZ2UgPT09IHZvaWQgMCB8fCBvblZhbHVlQ2hhbmdlKGVkaXRvci5jaGlsZHJlbik7XG4gICAgfVxuICAgIGhhbmRsZVNlbGVjdG9yQ2hhbmdlKCk7XG4gIH0sIFtlZGl0b3IsIGhhbmRsZVNlbGVjdG9yQ2hhbmdlLCBvbkNoYW5nZSwgb25TZWxlY3Rpb25DaGFuZ2UsIG9uVmFsdWVDaGFuZ2VdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBFRElUT1JfVE9fT05fQ0hBTkdFLnNldChlZGl0b3IsIG9uQ29udGV4dENoYW5nZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIEVESVRPUl9UT19PTl9DSEFOR0Uuc2V0KGVkaXRvciwgKCkgPT4ge30pO1xuICAgIH07XG4gIH0sIFtlZGl0b3IsIG9uQ29udGV4dENoYW5nZV0pO1xuICB2YXIgW2lzRm9jdXNlZCwgc2V0SXNGb2N1c2VkXSA9IHVzZVN0YXRlKFJlYWN0RWRpdG9yLmlzRm9jdXNlZChlZGl0b3IpKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRJc0ZvY3VzZWQoUmVhY3RFZGl0b3IuaXNGb2N1c2VkKGVkaXRvcikpO1xuICB9LCBbZWRpdG9yXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHZhciBmbiA9ICgpID0+IHNldElzRm9jdXNlZChSZWFjdEVkaXRvci5pc0ZvY3VzZWQoZWRpdG9yKSk7XG4gICAgaWYgKFJFQUNUX01BSk9SX1ZFUlNJT04gPj0gMTcpIHtcbiAgICAgIC8vIEluIFJlYWN0ID49IDE3IG9uRm9jdXMgYW5kIG9uQmx1ciBsaXN0ZW4gdG8gdGhlIGZvY3VzaW4gYW5kIGZvY3Vzb3V0IGV2ZW50cyBkdXJpbmcgdGhlIGJ1YmJsaW5nIHBoYXNlLlxuICAgICAgLy8gVGhlcmVmb3JlIGluIG9yZGVyIGZvciA8RWRpdGFibGUgLz4ncyBoYW5kbGVycyB0byBydW4gZmlyc3QsIHdoaWNoIGlzIG5lY2Vzc2FyeSBmb3IgUmVhY3RFZGl0b3IuaXNGb2N1c2VkKGVkaXRvcilcbiAgICAgIC8vIHRvIHJldHVybiB0aGUgY29ycmVjdCB2YWx1ZSwgd2UgaGF2ZSB0byBsaXN0ZW4gdG8gdGhlIGZvY3VzaW4gYW5kIGZvY3Vzb3V0IGV2ZW50cyB3aXRob3V0IHVzZUNhcHR1cmUgaGVyZS5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBmbik7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIGZuKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBmbik7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgZm4pO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBmbiwgdHJ1ZSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZm4sIHRydWUpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBmbiwgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmbiwgdHJ1ZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoU2xhdGVTZWxlY3RvckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc2VsZWN0b3JDb250ZXh0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVkaXRvckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogZWRpdG9yXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvY3VzZWRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGlzRm9jdXNlZFxuICB9LCBjaGlsZHJlbikpKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGVkaXRvciBvYmplY3QgZnJvbSB0aGUgUmVhY3QgY29udGV4dC5cbiAqIEBkZXByZWNhdGVkIFVzZSB1c2VTbGF0ZVN0YXRpYyBpbnN0ZWFkLlxuICovXG52YXIgdXNlRWRpdG9yID0gKCkgPT4ge1xuICB2YXIgZWRpdG9yID0gdXNlQ29udGV4dChFZGl0b3JDb250ZXh0KTtcbiAgaWYgKCFlZGl0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYHVzZUVkaXRvcmAgaG9vayBtdXN0IGJlIHVzZWQgaW5zaWRlIHRoZSA8U2xhdGU+IGNvbXBvbmVudCdzIGNvbnRleHQuXCIpO1xuICB9XG4gIHJldHVybiBlZGl0b3I7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBgc2VsZWN0ZWRgIHN0YXRlIG9mIGFuIGVsZW1lbnQuXG4gKi9cbnZhciB1c2VTZWxlY3RlZCA9ICgpID0+IHtcbiAgdmFyIGVsZW1lbnQgPSB1c2VFbGVtZW50SWYoKTtcbiAgLy8gQnJlYWtpbmcgdGhlIHJ1bGVzIG9mIGhvb2tzIGlzIGZpbmUgaGVyZSBzaW5jZSBgIWVsZW1lbnRgIHdpbGwgcmVtYWluIHRydWVcbiAgLy8gb3IgZmFsc2UgZm9yIHRoZSBlbnRpcmUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudCB0aGlzIGhvb2sgaXMgY2FsbGVkIGZyb20uXG4gIC8vIFRPRE86IERlY2lkZSBpZiB3ZSB3YW50IHRvIHRocm93IGFuIGVycm9yIGluc3RlYWQgd2hlbiBjYWxsaW5nXG4gIC8vIGB1c2VTZWxlY3RlZGAgb3V0c2lkZSBvZiBhbiBlbGVtZW50IChwb3RlbnRpYWxseSBhIGJyZWFraW5nIGNoYW5nZSkuXG4gIGlmICghZWxlbWVudCkgcmV0dXJuIGZhbHNlO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgdmFyIHNlbGVjdG9yID0gdXNlQ2FsbGJhY2soZWRpdG9yID0+IHtcbiAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pIHJldHVybiBmYWxzZTtcbiAgICB2YXIgcGF0aCA9IFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgZWxlbWVudCk7XG4gICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgcGF0aCk7XG4gICAgcmV0dXJuICEhUmFuZ2UuaW50ZXJzZWN0aW9uKHJhbmdlLCBlZGl0b3Iuc2VsZWN0aW9uKTtcbiAgfSwgW2VsZW1lbnRdKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gIHJldHVybiB1c2VTbGF0ZVNlbGVjdG9yKHNlbGVjdG9yLCB1bmRlZmluZWQsIHtcbiAgICAvLyBEZWZlciB0aGUgc2VsZWN0b3IgdW50aWwgYWZ0ZXIgYEVkaXRhYmxlYCBoYXMgcmVuZGVyZWQgc28gdGhhdCB0aGUgcGF0aFxuICAgIC8vIHdpbGwgYmUgYWNjdXJhdGUuXG4gICAgZGVmZXJyZWQ6IHRydWVcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBzbGF0ZSBzZWxlY3Rpb24uXG4gKiBPbmx5IHRyaWdnZXJzIGEgcmVyZW5kZXIgd2hlbiB0aGUgc2VsZWN0aW9uIGFjdHVhbGx5IGNoYW5nZXNcbiAqL1xudmFyIHVzZVNsYXRlU2VsZWN0aW9uID0gKCkgPT4ge1xuICByZXR1cm4gdXNlU2xhdGVTZWxlY3RvcihlZGl0b3IgPT4gZWRpdG9yLnNlbGVjdGlvbiwgaXNTZWxlY3Rpb25FcXVhbCk7XG59O1xudmFyIGlzU2VsZWN0aW9uRXF1YWwgPSAoYSwgYikgPT4ge1xuICBpZiAoIWEgJiYgIWIpIHJldHVybiB0cnVlO1xuICBpZiAoIWEgfHwgIWIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFJhbmdlLmVxdWFscyhhLCBiKTtcbn07XG5cbi8qKlxuICogYHdpdGhSZWFjdGAgYWRkcyBSZWFjdCBhbmQgRE9NIHNwZWNpZmljIGJlaGF2aW9ycyB0byB0aGUgZWRpdG9yLlxuICpcbiAqIElmIHlvdSBhcmUgdXNpbmcgVHlwZVNjcmlwdCwgeW91IG11c3QgZXh0ZW5kIFNsYXRlJ3MgQ3VzdG9tVHlwZXMgdG8gdXNlXG4gKiB0aGlzIHBsdWdpbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9kb2NzLnNsYXRlanMub3JnL2NvbmNlcHRzLzExLXR5cGVzY3JpcHQgdG8gbGVhcm4gaG93LlxuICovXG52YXIgd2l0aFJlYWN0ID0gZnVuY3Rpb24gd2l0aFJlYWN0KGVkaXRvcikge1xuICB2YXIgY2xpcGJvYXJkRm9ybWF0S2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAneC1zbGF0ZS1mcmFnbWVudCc7XG4gIHZhciBlID0gZWRpdG9yO1xuICBlID0gd2l0aERPTShlLCBjbGlwYm9hcmRGb3JtYXRLZXkpO1xuICB2YXIge1xuICAgIG9uQ2hhbmdlLFxuICAgIGFwcGx5LFxuICAgIGluc2VydFRleHRcbiAgfSA9IGU7XG4gIGUuZ2V0Q2h1bmtTaXplID0gKCkgPT4gbnVsbDtcbiAgaWYgKElTX0FORFJPSUQpIHtcbiAgICBlLmluc2VydFRleHQgPSAodGV4dCwgb3B0aW9ucykgPT4ge1xuICAgICAgLy8gQ09NUEFUOiBBbmRyb2lkIGRldmljZXMsIHNwZWNpZmljYWxseSBTYW1zdW5nIGRldmljZXMsIGV4cGVyaWVuY2UgY3Vyc29yIGp1bXBpbmcuXG4gICAgICAvLyBUaGlzIGlzc3VlIG9jY3VycyB3aGVuIHRoZSDigaBpbnNlcnRUZXh0IGZ1bmN0aW9uIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciB0eXBpbmcuXG4gICAgICAvLyBUaGUgcHJvYmxlbSBhcmlzZXMgYmVjYXVzZSB0eXBpbmcgc2NoZWR1bGVzIGEgc2VsZWN0aW9uIGNoYW5nZS5cbiAgICAgIC8vIEhvd2V2ZXIsIHRoaXMgc2VsZWN0aW9uIGNoYW5nZSBpcyBvbmx5IGV4ZWN1dGVkIGFmdGVyIHRoZSDigaBpbnNlcnRUZXh0IGZ1bmN0aW9uLlxuICAgICAgLy8gQXMgYSByZXN1bHQsIHRoZSBhbHJlYWR5IG9ic29sZXRlIHNlbGVjdGlvbiBpcyBhcHBsaWVkLCBsZWFkaW5nIHRvIGluY29ycmVjdFxuICAgICAgLy8gZmluYWwgY3Vyc29yIHBvc2l0aW9uLlxuICAgICAgRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLmRlbGV0ZShlKTtcbiAgICAgIHJldHVybiBpbnNlcnRUZXh0KHRleHQsIG9wdGlvbnMpO1xuICAgIH07XG4gIH1cbiAgZS5vbkNoYW5nZSA9IG9wdGlvbnMgPT4ge1xuICAgIC8vIENPTVBBVDogUmVhY3QgPCAxOCBkb2Vzbid0IGJhdGNoIGBzZXRTdGF0ZWAgaG9vayBjYWxscywgd2hpY2ggbWVhbnNcbiAgICAvLyB0aGF0IHRoZSBjaGlsZHJlbiBhbmQgc2VsZWN0aW9uIGNhbiBnZXQgb3V0IG9mIHN5bmMgZm9yIG9uZSByZW5kZXJcbiAgICAvLyBwYXNzLiBTbyB3ZSBoYXZlIHRvIHVzZSB0aGlzIHVuc3RhYmxlIEFQSSB0byBlbnN1cmUgaXQgYmF0Y2hlcyB0aGVtLlxuICAgIC8vICgyMDE5LzEyLzAzKVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTQyNTkjaXNzdWVjb21tZW50LTQzOTcwMjM2N1xuICAgIHZhciBtYXliZUJhdGNoVXBkYXRlcyA9IFJFQUNUX01BSk9SX1ZFUlNJT04gPCAxOCA/IFJlYWN0RE9NLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIDogY2FsbGJhY2sgPT4gY2FsbGJhY2soKTtcbiAgICBtYXliZUJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICBvbkNoYW5nZShvcHRpb25zKTtcbiAgICB9KTtcbiAgfTtcbiAgLy8gT24gbW92ZV9ub2RlLCBpZiB0aGUgY2h1bmtpbmcgb3B0aW1pemF0aW9uIGlzIGVuYWJsZWQgZm9yIHRoZSBwYXJlbnQgb2YgdGhlXG4gIC8vIG5vZGUgYmVpbmcgbW92ZWQsIGFkZCB0aGUgbW92ZWQgbm9kZSB0byB0aGUgbW92ZWROb2RlS2V5cyBzZXQgb2YgdGhlXG4gIC8vIHBhcmVudCdzIGNodW5rIHRyZWUuXG4gIGUuYXBwbHkgPSBvcGVyYXRpb24gPT4ge1xuICAgIGlmIChvcGVyYXRpb24udHlwZSA9PT0gJ21vdmVfbm9kZScpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBOb2RlLnBhcmVudChlLCBvcGVyYXRpb24ucGF0aCk7XG4gICAgICB2YXIgY2h1bmtpbmcgPSAhIWUuZ2V0Q2h1bmtTaXplKHBhcmVudCk7XG4gICAgICBpZiAoY2h1bmtpbmcpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBOb2RlLmdldChlLCBvcGVyYXRpb24ucGF0aCk7XG4gICAgICAgIHZhciBjaHVua1RyZWUgPSBnZXRDaHVua1RyZWVGb3JOb2RlKGUsIHBhcmVudCk7XG4gICAgICAgIHZhciBrZXkgPSBSZWFjdEVkaXRvci5maW5kS2V5KGUsIG5vZGUpO1xuICAgICAgICBjaHVua1RyZWUubW92ZWROb2RlS2V5cy5hZGQoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXBwbHkob3BlcmF0aW9uKTtcbiAgfTtcbiAgcmV0dXJuIGU7XG59O1xuXG5leHBvcnQgeyBEZWZhdWx0RWxlbWVudCwgRGVmYXVsdExlYWYsIERlZmF1bHRQbGFjZWhvbGRlciwgRGVmYXVsdFRleHQsIEVkaXRhYmxlLCBSZWFjdEVkaXRvciwgU2xhdGUsIGRlZmF1bHRTY3JvbGxTZWxlY3Rpb25JbnRvVmlldywgdXNlQ29tcG9zaW5nLCB1c2VFZGl0b3IsIHVzZUVsZW1lbnQsIHVzZUVsZW1lbnRJZiwgdXNlRm9jdXNlZCwgdXNlUmVhZE9ubHksIHVzZVNlbGVjdGVkLCB1c2VTbGF0ZSwgdXNlU2xhdGVTZWxlY3Rpb24sIHVzZVNsYXRlU2VsZWN0b3IsIHVzZVNsYXRlU3RhdGljLCB1c2VTbGF0ZVdpdGhWLCB3aXRoUmVhY3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@portabletext/editor/node_modules/slate-react/dist/index.es.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@portabletext/keyboard-shortcuts/dist/index.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@portabletext/keyboard-shortcuts/dist/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blockquote: () => (/* binding */ blockquote),\n/* harmony export */   bold: () => (/* binding */ bold),\n/* harmony export */   code: () => (/* binding */ code),\n/* harmony export */   createKeyboardShortcut: () => (/* binding */ createKeyboardShortcut),\n/* harmony export */   h1: () => (/* binding */ h1),\n/* harmony export */   h2: () => (/* binding */ h2),\n/* harmony export */   h3: () => (/* binding */ h3),\n/* harmony export */   h4: () => (/* binding */ h4),\n/* harmony export */   h5: () => (/* binding */ h5),\n/* harmony export */   h6: () => (/* binding */ h6),\n/* harmony export */   italic: () => (/* binding */ italic),\n/* harmony export */   link: () => (/* binding */ link),\n/* harmony export */   normal: () => (/* binding */ normal),\n/* harmony export */   redo: () => (/* binding */ redo),\n/* harmony export */   strikeThrough: () => (/* binding */ strikeThrough),\n/* harmony export */   underline: () => (/* binding */ underline),\n/* harmony export */   undo: () => (/* binding */ undo)\n/* harmony export */ });\nconst IS_APPLE = typeof window < \"u\" && /Mac|iPod|iPhone|iPad/.test(window.navigator.userAgent);\nfunction isKeyboardShortcut(definition, event) {\n  return isCorrectModifiers(definition, event) ? definition.code !== void 0 && definition.code.toLowerCase() === event.code.toLowerCase() ? !0 : definition.key !== void 0 && definition.key.toLowerCase() === event.key.toLowerCase() : !1;\n}\nfunction isCorrectModifiers(definition, event) {\n  return (definition.ctrl === event.ctrlKey || definition.ctrl === void 0) && (definition.meta === event.metaKey || definition.meta === void 0) && (definition.shift === event.shiftKey || definition.shift === void 0) && (definition.alt === event.altKey || definition.alt === void 0);\n}\nfunction createKeyboardShortcut(definition) {\n  if (IS_APPLE) {\n    const appleDefinition = definition.apple ?? definition.default, firstDefinition2 = appleDefinition.at(0);\n    return {\n      guard: (event) => appleDefinition.some((definition2) => isKeyboardShortcut(definition2, event)),\n      keys: [...firstDefinition2?.meta ? [\"\\u2318\"] : [], ...firstDefinition2?.ctrl ? [\"Ctrl\"] : [], ...firstDefinition2?.alt ? [\"Option\"] : [], ...firstDefinition2?.shift ? [\"Shift\"] : [], ...firstDefinition2?.key !== void 0 ? [firstDefinition2.key] : firstDefinition2?.code !== void 0 ? [firstDefinition2.code] : []]\n    };\n  }\n  const firstDefinition = definition.default.at(0);\n  return {\n    guard: (event) => definition.default.some((definition2) => isKeyboardShortcut(definition2, event)),\n    keys: [...firstDefinition?.meta ? [\"Meta\"] : [], ...firstDefinition?.ctrl ? [\"Ctrl\"] : [], ...firstDefinition?.alt ? [\"Alt\"] : [], ...firstDefinition?.shift ? [\"Shift\"] : [], ...firstDefinition?.key !== void 0 ? [firstDefinition.key] : firstDefinition?.code !== void 0 ? [firstDefinition.code] : []]\n  };\n}\nconst bold = createKeyboardShortcut({\n  default: [{\n    key: \"B\",\n    alt: !1,\n    ctrl: !0,\n    meta: !1,\n    shift: !1\n  }],\n  apple: [{\n    key: \"B\",\n    alt: !1,\n    ctrl: !1,\n    meta: !0,\n    shift: !1\n  }]\n}), italic = createKeyboardShortcut({\n  default: [{\n    key: \"I\",\n    alt: !1,\n    ctrl: !0,\n    meta: !1,\n    shift: !1\n  }],\n  apple: [{\n    key: \"I\",\n    alt: !1,\n    ctrl: !1,\n    meta: !0,\n    shift: !1\n  }]\n}), code = createKeyboardShortcut({\n  default: [{\n    key: \"'\",\n    alt: !1,\n    ctrl: !0,\n    meta: !1,\n    shift: !1\n  }],\n  apple: [{\n    key: \"'\",\n    alt: !1,\n    ctrl: !1,\n    meta: !0,\n    shift: !1\n  }]\n}), underline = createKeyboardShortcut({\n  default: [{\n    key: \"U\",\n    alt: !1,\n    ctrl: !0,\n    meta: !1,\n    shift: !1\n  }],\n  apple: [{\n    key: \"U\",\n    alt: !1,\n    ctrl: !1,\n    meta: !0,\n    shift: !1\n  }]\n}), strikeThrough = createKeyboardShortcut({\n  default: [{\n    key: \"X\",\n    alt: !1,\n    ctrl: !0,\n    meta: !1,\n    shift: !0\n  }],\n  apple: [{\n    key: \"X\",\n    alt: !1,\n    ctrl: !1,\n    meta: !0,\n    shift: !0\n  }]\n}), link = createKeyboardShortcut({\n  default: [{\n    key: \"K\",\n    alt: !1,\n    ctrl: !0,\n    meta: !1,\n    shift: !1\n  }],\n  apple: [{\n    key: \"K\",\n    alt: !1,\n    ctrl: !1,\n    meta: !0,\n    shift: !1\n  }]\n}), normal = createKeyboardShortcut({\n  default: [{\n    key: \"0\",\n    code: \"Digit0\",\n    alt: !0,\n    ctrl: !0,\n    meta: !1,\n    shift: !1\n  }, {\n    key: \"0\",\n    code: \"Numpad0\",\n    alt: !0,\n    ctrl: !0,\n    meta: !1,\n    shift: !1\n  }],\n  apple: [{\n    key: \"0\",\n    code: \"Digit0\",\n    alt: !0,\n    ctrl: !1,\n    meta: !0,\n    shift: !1\n  }, {\n    key: \"0\",\n    code: \"Numpad0\",\n    alt: !0,\n    ctrl: !1,\n    meta: !0,\n    shift: !1\n  }]\n}), h1 = createKeyboardShortcut({\n  default: [{\n    key: \"1\",\n    code: \"Digit1\",\n    alt: !0,\n    ctrl: !0,\n    meta: !1,\n    shift: !1\n  }, {\n    key: \"1\",\n    code: \"Numpad1\",\n    alt: !0,\n    ctrl: !0,\n    meta: !1,\n    shift: !1\n  }],\n  apple: [{\n    key: \"1\",\n    code: \"Digit1\",\n    alt: !0,\n    ctrl: !1,\n    meta: !0,\n    shift: !1\n  }, {\n    key: \"1\",\n    code: \"Numpad1\",\n    alt: !0,\n    ctrl: !1,\n    meta: !0,\n    shift: !1\n  }]\n}), h2 = createKeyboardShortcut({\n  default: [{\n    key: \"2\",\n    code: \"Digit2\",\n    alt: !0,\n    ctrl: !0,\n    meta: !1,\n    shift: !1\n  }, {\n    key: \"2\",\n    code: \"Numpad2\",\n    alt: !0,\n    ctrl: !0,\n    meta: !1,\n    shift: !1\n  }],\n  apple: [{\n    key: \"2\",\n    code: \"Digit2\",\n    alt: !0,\n    ctrl: !1,\n    meta: !0,\n    shift: !1\n  }, {\n    key: \"2\",\n    code: \"Numpad2\",\n    alt: !0,\n    ctrl: !1,\n    meta: !0,\n    shift: !1\n  }]\n}), h3 = createKeyboardShortcut({\n  default: [{\n    key: \"3\",\n    code: \"Digit3\",\n    alt: !0,\n    ctrl: !0,\n    meta: !1,\n    shift: !1\n  }, {\n    key: \"3\",\n    code: \"Numpad3\",\n    alt: !0,\n    ctrl: !0,\n    meta: !1,\n    shift: !1\n  }],\n  apple: [{\n    key: \"3\",\n    code: \"Digit3\",\n    alt: !0,\n    ctrl: !1,\n    meta: !0,\n    shift: !1\n  }, {\n    key: \"3\",\n    code: \"Numpad3\",\n    alt: !0,\n    ctrl: !1,\n    meta: !0,\n    shift: !1\n  }]\n}), h4 = createKeyboardShortcut({\n  default: [{\n    key: \"4\",\n    code: \"Digit4\",\n    alt: !0,\n    ctrl: !0,\n    meta: !1,\n    shift: !1\n  }, {\n    key: \"4\",\n    code: \"Numpad4\",\n    alt: !0,\n    ctrl: !0,\n    meta: !1,\n    shift: !1\n  }],\n  apple: [{\n    key: \"4\",\n    code: \"Digit4\",\n    alt: !0,\n    ctrl: !1,\n    meta: !0,\n    shift: !1\n  }, {\n    key: \"4\",\n    code: \"Numpad4\",\n    alt: !0,\n    ctrl: !1,\n    meta: !0,\n    shift: !1\n  }]\n}), h5 = createKeyboardShortcut({\n  default: [{\n    key: \"5\",\n    code: \"Digit5\",\n    alt: !0,\n    ctrl: !0,\n    meta: !1,\n    shift: !1\n  }, {\n    key: \"5\",\n    code: \"Numpad5\",\n    alt: !0,\n    ctrl: !0,\n    meta: !1,\n    shift: !1\n  }],\n  apple: [{\n    key: \"5\",\n    code: \"Digit5\",\n    alt: !0,\n    ctrl: !1,\n    meta: !0,\n    shift: !1\n  }, {\n    key: \"5\",\n    code: \"Numpad5\",\n    alt: !0,\n    ctrl: !1,\n    meta: !0,\n    shift: !1\n  }]\n}), h6 = createKeyboardShortcut({\n  default: [{\n    key: \"6\",\n    code: \"Digit6\",\n    alt: !0,\n    ctrl: !0,\n    meta: !1,\n    shift: !1\n  }, {\n    key: \"6\",\n    code: \"Numpad6\",\n    alt: !0,\n    ctrl: !0,\n    meta: !1,\n    shift: !1\n  }],\n  apple: [{\n    key: \"6\",\n    code: \"Digit6\",\n    alt: !0,\n    ctrl: !1,\n    meta: !0,\n    shift: !1\n  }, {\n    key: \"6\",\n    code: \"Numpad6\",\n    alt: !0,\n    ctrl: !1,\n    meta: !0,\n    shift: !1\n  }]\n}), blockquote = createKeyboardShortcut({\n  default: [{\n    key: \"Q\",\n    alt: !1,\n    ctrl: !0,\n    meta: !1,\n    shift: !0\n  }]\n}), undo = createKeyboardShortcut({\n  default: [{\n    key: \"Z\",\n    alt: !1,\n    ctrl: !0,\n    meta: !1,\n    shift: !1\n  }],\n  apple: [{\n    key: \"Z\",\n    alt: !1,\n    ctrl: !1,\n    meta: !0,\n    shift: !1\n  }]\n}), redo = createKeyboardShortcut({\n  default: [{\n    key: \"Y\",\n    alt: !1,\n    ctrl: !0,\n    meta: !1,\n    shift: !1\n  }, {\n    key: \"Z\",\n    alt: !1,\n    ctrl: !0,\n    meta: !1,\n    shift: !0\n  }],\n  apple: [{\n    key: \"Z\",\n    alt: !1,\n    ctrl: !1,\n    meta: !0,\n    shift: !0\n  }]\n});\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQva2V5Ym9hcmQtc2hvcnRjdXRzL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFtQkM7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL0dhbG9jay9DUy9iZWhvbWUtc2l0ZS9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9rZXlib2FyZC1zaG9ydGN1dHMvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBJU19BUFBMRSA9IHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiAvTWFjfGlQb2R8aVBob25lfGlQYWQvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xuZnVuY3Rpb24gaXNLZXlib2FyZFNob3J0Y3V0KGRlZmluaXRpb24sIGV2ZW50KSB7XG4gIHJldHVybiBpc0NvcnJlY3RNb2RpZmllcnMoZGVmaW5pdGlvbiwgZXZlbnQpID8gZGVmaW5pdGlvbi5jb2RlICE9PSB2b2lkIDAgJiYgZGVmaW5pdGlvbi5jb2RlLnRvTG93ZXJDYXNlKCkgPT09IGV2ZW50LmNvZGUudG9Mb3dlckNhc2UoKSA/ICEwIDogZGVmaW5pdGlvbi5rZXkgIT09IHZvaWQgMCAmJiBkZWZpbml0aW9uLmtleS50b0xvd2VyQ2FzZSgpID09PSBldmVudC5rZXkudG9Mb3dlckNhc2UoKSA6ICExO1xufVxuZnVuY3Rpb24gaXNDb3JyZWN0TW9kaWZpZXJzKGRlZmluaXRpb24sIGV2ZW50KSB7XG4gIHJldHVybiAoZGVmaW5pdGlvbi5jdHJsID09PSBldmVudC5jdHJsS2V5IHx8IGRlZmluaXRpb24uY3RybCA9PT0gdm9pZCAwKSAmJiAoZGVmaW5pdGlvbi5tZXRhID09PSBldmVudC5tZXRhS2V5IHx8IGRlZmluaXRpb24ubWV0YSA9PT0gdm9pZCAwKSAmJiAoZGVmaW5pdGlvbi5zaGlmdCA9PT0gZXZlbnQuc2hpZnRLZXkgfHwgZGVmaW5pdGlvbi5zaGlmdCA9PT0gdm9pZCAwKSAmJiAoZGVmaW5pdGlvbi5hbHQgPT09IGV2ZW50LmFsdEtleSB8fCBkZWZpbml0aW9uLmFsdCA9PT0gdm9pZCAwKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUtleWJvYXJkU2hvcnRjdXQoZGVmaW5pdGlvbikge1xuICBpZiAoSVNfQVBQTEUpIHtcbiAgICBjb25zdCBhcHBsZURlZmluaXRpb24gPSBkZWZpbml0aW9uLmFwcGxlID8/IGRlZmluaXRpb24uZGVmYXVsdCwgZmlyc3REZWZpbml0aW9uMiA9IGFwcGxlRGVmaW5pdGlvbi5hdCgwKTtcbiAgICByZXR1cm4ge1xuICAgICAgZ3VhcmQ6IChldmVudCkgPT4gYXBwbGVEZWZpbml0aW9uLnNvbWUoKGRlZmluaXRpb24yKSA9PiBpc0tleWJvYXJkU2hvcnRjdXQoZGVmaW5pdGlvbjIsIGV2ZW50KSksXG4gICAgICBrZXlzOiBbLi4uZmlyc3REZWZpbml0aW9uMj8ubWV0YSA/IFtcIlxcdTIzMThcIl0gOiBbXSwgLi4uZmlyc3REZWZpbml0aW9uMj8uY3RybCA/IFtcIkN0cmxcIl0gOiBbXSwgLi4uZmlyc3REZWZpbml0aW9uMj8uYWx0ID8gW1wiT3B0aW9uXCJdIDogW10sIC4uLmZpcnN0RGVmaW5pdGlvbjI/LnNoaWZ0ID8gW1wiU2hpZnRcIl0gOiBbXSwgLi4uZmlyc3REZWZpbml0aW9uMj8ua2V5ICE9PSB2b2lkIDAgPyBbZmlyc3REZWZpbml0aW9uMi5rZXldIDogZmlyc3REZWZpbml0aW9uMj8uY29kZSAhPT0gdm9pZCAwID8gW2ZpcnN0RGVmaW5pdGlvbjIuY29kZV0gOiBbXV1cbiAgICB9O1xuICB9XG4gIGNvbnN0IGZpcnN0RGVmaW5pdGlvbiA9IGRlZmluaXRpb24uZGVmYXVsdC5hdCgwKTtcbiAgcmV0dXJuIHtcbiAgICBndWFyZDogKGV2ZW50KSA9PiBkZWZpbml0aW9uLmRlZmF1bHQuc29tZSgoZGVmaW5pdGlvbjIpID0+IGlzS2V5Ym9hcmRTaG9ydGN1dChkZWZpbml0aW9uMiwgZXZlbnQpKSxcbiAgICBrZXlzOiBbLi4uZmlyc3REZWZpbml0aW9uPy5tZXRhID8gW1wiTWV0YVwiXSA6IFtdLCAuLi5maXJzdERlZmluaXRpb24/LmN0cmwgPyBbXCJDdHJsXCJdIDogW10sIC4uLmZpcnN0RGVmaW5pdGlvbj8uYWx0ID8gW1wiQWx0XCJdIDogW10sIC4uLmZpcnN0RGVmaW5pdGlvbj8uc2hpZnQgPyBbXCJTaGlmdFwiXSA6IFtdLCAuLi5maXJzdERlZmluaXRpb24/LmtleSAhPT0gdm9pZCAwID8gW2ZpcnN0RGVmaW5pdGlvbi5rZXldIDogZmlyc3REZWZpbml0aW9uPy5jb2RlICE9PSB2b2lkIDAgPyBbZmlyc3REZWZpbml0aW9uLmNvZGVdIDogW11dXG4gIH07XG59XG5jb25zdCBib2xkID0gY3JlYXRlS2V5Ym9hcmRTaG9ydGN1dCh7XG4gIGRlZmF1bHQ6IFt7XG4gICAga2V5OiBcIkJcIixcbiAgICBhbHQ6ICExLFxuICAgIGN0cmw6ICEwLFxuICAgIG1ldGE6ICExLFxuICAgIHNoaWZ0OiAhMVxuICB9XSxcbiAgYXBwbGU6IFt7XG4gICAga2V5OiBcIkJcIixcbiAgICBhbHQ6ICExLFxuICAgIGN0cmw6ICExLFxuICAgIG1ldGE6ICEwLFxuICAgIHNoaWZ0OiAhMVxuICB9XVxufSksIGl0YWxpYyA9IGNyZWF0ZUtleWJvYXJkU2hvcnRjdXQoe1xuICBkZWZhdWx0OiBbe1xuICAgIGtleTogXCJJXCIsXG4gICAgYWx0OiAhMSxcbiAgICBjdHJsOiAhMCxcbiAgICBtZXRhOiAhMSxcbiAgICBzaGlmdDogITFcbiAgfV0sXG4gIGFwcGxlOiBbe1xuICAgIGtleTogXCJJXCIsXG4gICAgYWx0OiAhMSxcbiAgICBjdHJsOiAhMSxcbiAgICBtZXRhOiAhMCxcbiAgICBzaGlmdDogITFcbiAgfV1cbn0pLCBjb2RlID0gY3JlYXRlS2V5Ym9hcmRTaG9ydGN1dCh7XG4gIGRlZmF1bHQ6IFt7XG4gICAga2V5OiBcIidcIixcbiAgICBhbHQ6ICExLFxuICAgIGN0cmw6ICEwLFxuICAgIG1ldGE6ICExLFxuICAgIHNoaWZ0OiAhMVxuICB9XSxcbiAgYXBwbGU6IFt7XG4gICAga2V5OiBcIidcIixcbiAgICBhbHQ6ICExLFxuICAgIGN0cmw6ICExLFxuICAgIG1ldGE6ICEwLFxuICAgIHNoaWZ0OiAhMVxuICB9XVxufSksIHVuZGVybGluZSA9IGNyZWF0ZUtleWJvYXJkU2hvcnRjdXQoe1xuICBkZWZhdWx0OiBbe1xuICAgIGtleTogXCJVXCIsXG4gICAgYWx0OiAhMSxcbiAgICBjdHJsOiAhMCxcbiAgICBtZXRhOiAhMSxcbiAgICBzaGlmdDogITFcbiAgfV0sXG4gIGFwcGxlOiBbe1xuICAgIGtleTogXCJVXCIsXG4gICAgYWx0OiAhMSxcbiAgICBjdHJsOiAhMSxcbiAgICBtZXRhOiAhMCxcbiAgICBzaGlmdDogITFcbiAgfV1cbn0pLCBzdHJpa2VUaHJvdWdoID0gY3JlYXRlS2V5Ym9hcmRTaG9ydGN1dCh7XG4gIGRlZmF1bHQ6IFt7XG4gICAga2V5OiBcIlhcIixcbiAgICBhbHQ6ICExLFxuICAgIGN0cmw6ICEwLFxuICAgIG1ldGE6ICExLFxuICAgIHNoaWZ0OiAhMFxuICB9XSxcbiAgYXBwbGU6IFt7XG4gICAga2V5OiBcIlhcIixcbiAgICBhbHQ6ICExLFxuICAgIGN0cmw6ICExLFxuICAgIG1ldGE6ICEwLFxuICAgIHNoaWZ0OiAhMFxuICB9XVxufSksIGxpbmsgPSBjcmVhdGVLZXlib2FyZFNob3J0Y3V0KHtcbiAgZGVmYXVsdDogW3tcbiAgICBrZXk6IFwiS1wiLFxuICAgIGFsdDogITEsXG4gICAgY3RybDogITAsXG4gICAgbWV0YTogITEsXG4gICAgc2hpZnQ6ICExXG4gIH1dLFxuICBhcHBsZTogW3tcbiAgICBrZXk6IFwiS1wiLFxuICAgIGFsdDogITEsXG4gICAgY3RybDogITEsXG4gICAgbWV0YTogITAsXG4gICAgc2hpZnQ6ICExXG4gIH1dXG59KSwgbm9ybWFsID0gY3JlYXRlS2V5Ym9hcmRTaG9ydGN1dCh7XG4gIGRlZmF1bHQ6IFt7XG4gICAga2V5OiBcIjBcIixcbiAgICBjb2RlOiBcIkRpZ2l0MFwiLFxuICAgIGFsdDogITAsXG4gICAgY3RybDogITAsXG4gICAgbWV0YTogITEsXG4gICAgc2hpZnQ6ICExXG4gIH0sIHtcbiAgICBrZXk6IFwiMFwiLFxuICAgIGNvZGU6IFwiTnVtcGFkMFwiLFxuICAgIGFsdDogITAsXG4gICAgY3RybDogITAsXG4gICAgbWV0YTogITEsXG4gICAgc2hpZnQ6ICExXG4gIH1dLFxuICBhcHBsZTogW3tcbiAgICBrZXk6IFwiMFwiLFxuICAgIGNvZGU6IFwiRGlnaXQwXCIsXG4gICAgYWx0OiAhMCxcbiAgICBjdHJsOiAhMSxcbiAgICBtZXRhOiAhMCxcbiAgICBzaGlmdDogITFcbiAgfSwge1xuICAgIGtleTogXCIwXCIsXG4gICAgY29kZTogXCJOdW1wYWQwXCIsXG4gICAgYWx0OiAhMCxcbiAgICBjdHJsOiAhMSxcbiAgICBtZXRhOiAhMCxcbiAgICBzaGlmdDogITFcbiAgfV1cbn0pLCBoMSA9IGNyZWF0ZUtleWJvYXJkU2hvcnRjdXQoe1xuICBkZWZhdWx0OiBbe1xuICAgIGtleTogXCIxXCIsXG4gICAgY29kZTogXCJEaWdpdDFcIixcbiAgICBhbHQ6ICEwLFxuICAgIGN0cmw6ICEwLFxuICAgIG1ldGE6ICExLFxuICAgIHNoaWZ0OiAhMVxuICB9LCB7XG4gICAga2V5OiBcIjFcIixcbiAgICBjb2RlOiBcIk51bXBhZDFcIixcbiAgICBhbHQ6ICEwLFxuICAgIGN0cmw6ICEwLFxuICAgIG1ldGE6ICExLFxuICAgIHNoaWZ0OiAhMVxuICB9XSxcbiAgYXBwbGU6IFt7XG4gICAga2V5OiBcIjFcIixcbiAgICBjb2RlOiBcIkRpZ2l0MVwiLFxuICAgIGFsdDogITAsXG4gICAgY3RybDogITEsXG4gICAgbWV0YTogITAsXG4gICAgc2hpZnQ6ICExXG4gIH0sIHtcbiAgICBrZXk6IFwiMVwiLFxuICAgIGNvZGU6IFwiTnVtcGFkMVwiLFxuICAgIGFsdDogITAsXG4gICAgY3RybDogITEsXG4gICAgbWV0YTogITAsXG4gICAgc2hpZnQ6ICExXG4gIH1dXG59KSwgaDIgPSBjcmVhdGVLZXlib2FyZFNob3J0Y3V0KHtcbiAgZGVmYXVsdDogW3tcbiAgICBrZXk6IFwiMlwiLFxuICAgIGNvZGU6IFwiRGlnaXQyXCIsXG4gICAgYWx0OiAhMCxcbiAgICBjdHJsOiAhMCxcbiAgICBtZXRhOiAhMSxcbiAgICBzaGlmdDogITFcbiAgfSwge1xuICAgIGtleTogXCIyXCIsXG4gICAgY29kZTogXCJOdW1wYWQyXCIsXG4gICAgYWx0OiAhMCxcbiAgICBjdHJsOiAhMCxcbiAgICBtZXRhOiAhMSxcbiAgICBzaGlmdDogITFcbiAgfV0sXG4gIGFwcGxlOiBbe1xuICAgIGtleTogXCIyXCIsXG4gICAgY29kZTogXCJEaWdpdDJcIixcbiAgICBhbHQ6ICEwLFxuICAgIGN0cmw6ICExLFxuICAgIG1ldGE6ICEwLFxuICAgIHNoaWZ0OiAhMVxuICB9LCB7XG4gICAga2V5OiBcIjJcIixcbiAgICBjb2RlOiBcIk51bXBhZDJcIixcbiAgICBhbHQ6ICEwLFxuICAgIGN0cmw6ICExLFxuICAgIG1ldGE6ICEwLFxuICAgIHNoaWZ0OiAhMVxuICB9XVxufSksIGgzID0gY3JlYXRlS2V5Ym9hcmRTaG9ydGN1dCh7XG4gIGRlZmF1bHQ6IFt7XG4gICAga2V5OiBcIjNcIixcbiAgICBjb2RlOiBcIkRpZ2l0M1wiLFxuICAgIGFsdDogITAsXG4gICAgY3RybDogITAsXG4gICAgbWV0YTogITEsXG4gICAgc2hpZnQ6ICExXG4gIH0sIHtcbiAgICBrZXk6IFwiM1wiLFxuICAgIGNvZGU6IFwiTnVtcGFkM1wiLFxuICAgIGFsdDogITAsXG4gICAgY3RybDogITAsXG4gICAgbWV0YTogITEsXG4gICAgc2hpZnQ6ICExXG4gIH1dLFxuICBhcHBsZTogW3tcbiAgICBrZXk6IFwiM1wiLFxuICAgIGNvZGU6IFwiRGlnaXQzXCIsXG4gICAgYWx0OiAhMCxcbiAgICBjdHJsOiAhMSxcbiAgICBtZXRhOiAhMCxcbiAgICBzaGlmdDogITFcbiAgfSwge1xuICAgIGtleTogXCIzXCIsXG4gICAgY29kZTogXCJOdW1wYWQzXCIsXG4gICAgYWx0OiAhMCxcbiAgICBjdHJsOiAhMSxcbiAgICBtZXRhOiAhMCxcbiAgICBzaGlmdDogITFcbiAgfV1cbn0pLCBoNCA9IGNyZWF0ZUtleWJvYXJkU2hvcnRjdXQoe1xuICBkZWZhdWx0OiBbe1xuICAgIGtleTogXCI0XCIsXG4gICAgY29kZTogXCJEaWdpdDRcIixcbiAgICBhbHQ6ICEwLFxuICAgIGN0cmw6ICEwLFxuICAgIG1ldGE6ICExLFxuICAgIHNoaWZ0OiAhMVxuICB9LCB7XG4gICAga2V5OiBcIjRcIixcbiAgICBjb2RlOiBcIk51bXBhZDRcIixcbiAgICBhbHQ6ICEwLFxuICAgIGN0cmw6ICEwLFxuICAgIG1ldGE6ICExLFxuICAgIHNoaWZ0OiAhMVxuICB9XSxcbiAgYXBwbGU6IFt7XG4gICAga2V5OiBcIjRcIixcbiAgICBjb2RlOiBcIkRpZ2l0NFwiLFxuICAgIGFsdDogITAsXG4gICAgY3RybDogITEsXG4gICAgbWV0YTogITAsXG4gICAgc2hpZnQ6ICExXG4gIH0sIHtcbiAgICBrZXk6IFwiNFwiLFxuICAgIGNvZGU6IFwiTnVtcGFkNFwiLFxuICAgIGFsdDogITAsXG4gICAgY3RybDogITEsXG4gICAgbWV0YTogITAsXG4gICAgc2hpZnQ6ICExXG4gIH1dXG59KSwgaDUgPSBjcmVhdGVLZXlib2FyZFNob3J0Y3V0KHtcbiAgZGVmYXVsdDogW3tcbiAgICBrZXk6IFwiNVwiLFxuICAgIGNvZGU6IFwiRGlnaXQ1XCIsXG4gICAgYWx0OiAhMCxcbiAgICBjdHJsOiAhMCxcbiAgICBtZXRhOiAhMSxcbiAgICBzaGlmdDogITFcbiAgfSwge1xuICAgIGtleTogXCI1XCIsXG4gICAgY29kZTogXCJOdW1wYWQ1XCIsXG4gICAgYWx0OiAhMCxcbiAgICBjdHJsOiAhMCxcbiAgICBtZXRhOiAhMSxcbiAgICBzaGlmdDogITFcbiAgfV0sXG4gIGFwcGxlOiBbe1xuICAgIGtleTogXCI1XCIsXG4gICAgY29kZTogXCJEaWdpdDVcIixcbiAgICBhbHQ6ICEwLFxuICAgIGN0cmw6ICExLFxuICAgIG1ldGE6ICEwLFxuICAgIHNoaWZ0OiAhMVxuICB9LCB7XG4gICAga2V5OiBcIjVcIixcbiAgICBjb2RlOiBcIk51bXBhZDVcIixcbiAgICBhbHQ6ICEwLFxuICAgIGN0cmw6ICExLFxuICAgIG1ldGE6ICEwLFxuICAgIHNoaWZ0OiAhMVxuICB9XVxufSksIGg2ID0gY3JlYXRlS2V5Ym9hcmRTaG9ydGN1dCh7XG4gIGRlZmF1bHQ6IFt7XG4gICAga2V5OiBcIjZcIixcbiAgICBjb2RlOiBcIkRpZ2l0NlwiLFxuICAgIGFsdDogITAsXG4gICAgY3RybDogITAsXG4gICAgbWV0YTogITEsXG4gICAgc2hpZnQ6ICExXG4gIH0sIHtcbiAgICBrZXk6IFwiNlwiLFxuICAgIGNvZGU6IFwiTnVtcGFkNlwiLFxuICAgIGFsdDogITAsXG4gICAgY3RybDogITAsXG4gICAgbWV0YTogITEsXG4gICAgc2hpZnQ6ICExXG4gIH1dLFxuICBhcHBsZTogW3tcbiAgICBrZXk6IFwiNlwiLFxuICAgIGNvZGU6IFwiRGlnaXQ2XCIsXG4gICAgYWx0OiAhMCxcbiAgICBjdHJsOiAhMSxcbiAgICBtZXRhOiAhMCxcbiAgICBzaGlmdDogITFcbiAgfSwge1xuICAgIGtleTogXCI2XCIsXG4gICAgY29kZTogXCJOdW1wYWQ2XCIsXG4gICAgYWx0OiAhMCxcbiAgICBjdHJsOiAhMSxcbiAgICBtZXRhOiAhMCxcbiAgICBzaGlmdDogITFcbiAgfV1cbn0pLCBibG9ja3F1b3RlID0gY3JlYXRlS2V5Ym9hcmRTaG9ydGN1dCh7XG4gIGRlZmF1bHQ6IFt7XG4gICAga2V5OiBcIlFcIixcbiAgICBhbHQ6ICExLFxuICAgIGN0cmw6ICEwLFxuICAgIG1ldGE6ICExLFxuICAgIHNoaWZ0OiAhMFxuICB9XVxufSksIHVuZG8gPSBjcmVhdGVLZXlib2FyZFNob3J0Y3V0KHtcbiAgZGVmYXVsdDogW3tcbiAgICBrZXk6IFwiWlwiLFxuICAgIGFsdDogITEsXG4gICAgY3RybDogITAsXG4gICAgbWV0YTogITEsXG4gICAgc2hpZnQ6ICExXG4gIH1dLFxuICBhcHBsZTogW3tcbiAgICBrZXk6IFwiWlwiLFxuICAgIGFsdDogITEsXG4gICAgY3RybDogITEsXG4gICAgbWV0YTogITAsXG4gICAgc2hpZnQ6ICExXG4gIH1dXG59KSwgcmVkbyA9IGNyZWF0ZUtleWJvYXJkU2hvcnRjdXQoe1xuICBkZWZhdWx0OiBbe1xuICAgIGtleTogXCJZXCIsXG4gICAgYWx0OiAhMSxcbiAgICBjdHJsOiAhMCxcbiAgICBtZXRhOiAhMSxcbiAgICBzaGlmdDogITFcbiAgfSwge1xuICAgIGtleTogXCJaXCIsXG4gICAgYWx0OiAhMSxcbiAgICBjdHJsOiAhMCxcbiAgICBtZXRhOiAhMSxcbiAgICBzaGlmdDogITBcbiAgfV0sXG4gIGFwcGxlOiBbe1xuICAgIGtleTogXCJaXCIsXG4gICAgYWx0OiAhMSxcbiAgICBjdHJsOiAhMSxcbiAgICBtZXRhOiAhMCxcbiAgICBzaGlmdDogITBcbiAgfV1cbn0pO1xuZXhwb3J0IHtcbiAgYmxvY2txdW90ZSxcbiAgYm9sZCxcbiAgY29kZSxcbiAgY3JlYXRlS2V5Ym9hcmRTaG9ydGN1dCxcbiAgaDEsXG4gIGgyLFxuICBoMyxcbiAgaDQsXG4gIGg1LFxuICBoNixcbiAgaXRhbGljLFxuICBsaW5rLFxuICBub3JtYWwsXG4gIHJlZG8sXG4gIHN0cmlrZVRocm91Z2gsXG4gIHVuZGVybGluZSxcbiAgdW5kb1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@portabletext/keyboard-shortcuts/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@portabletext/patches/dist/index.js":
/*!***********************************************************!*\
  !*** ../node_modules/@portabletext/patches/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyAll: () => (/* binding */ applyAll),\n/* harmony export */   diffMatchPatch: () => (/* binding */ diffMatchPatch),\n/* harmony export */   insert: () => (/* binding */ insert),\n/* harmony export */   prefixPath: () => (/* binding */ prefixPath),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   setIfMissing: () => (/* binding */ setIfMissing),\n/* harmony export */   unset: () => (/* binding */ unset)\n/* harmony export */ });\n/* harmony import */ var lodash_findIndex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/findIndex.js */ \"(ssr)/../node_modules/lodash/findIndex.js\");\n/* harmony import */ var lodash_clone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/clone.js */ \"(ssr)/../node_modules/lodash/clone.js\");\n/* harmony import */ var lodash_omit_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/omit.js */ \"(ssr)/../node_modules/lodash/omit.js\");\n/* harmony import */ var _sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sanity/diff-match-patch */ \"(ssr)/../node_modules/@sanity/diff-match-patch/dist/index.js\");\n\n\n\n\nconst BEFORE = \"before\", AFTER = \"after\";\nfunction insert$1(array, position, index, ...args) {\n  if (position !== BEFORE && position !== AFTER)\n    throw new Error(\n      `Invalid position \"${position}\", must be either ${BEFORE} or ${AFTER}`\n    );\n  const items = flatten(...args);\n  if (array.length === 0)\n    return items;\n  const len = array.length, idx = Math.abs((len + index) % len) % len, normalizedIdx = position === \"after\" ? idx + 1 : idx, copy = array.slice();\n  return copy.splice(normalizedIdx, 0, ...flatten(items)), copy;\n}\nfunction flatten(...values) {\n  return values.reduce((prev, item) => prev.concat(item), []);\n}\nfunction findTargetIndex(array, pathSegment) {\n  if (typeof pathSegment == \"number\")\n    return pathSegment;\n  const index = lodash_findIndex_js__WEBPACK_IMPORTED_MODULE_0__(array, pathSegment);\n  return index === -1 ? !1 : index;\n}\nfunction applyPatchToArray(value, patch) {\n  const nextValue = value.slice();\n  if (patch.path.length === 0) {\n    if (patch.type === \"setIfMissing\") {\n      if (!Array.isArray(patch.value))\n        throw new Error(\"Cannot set value of an array to a non-array\");\n      return value === void 0 ? patch.value : value;\n    }\n    if (patch.type === \"set\") {\n      if (!Array.isArray(patch.value))\n        throw new Error(\"Cannot set value of an array to a non-array\");\n      return patch.value;\n    }\n    if (patch.type === \"unset\")\n      return;\n    throw new Error(`Invalid array operation: ${patch.type}`);\n  }\n  const [head, ...tail] = patch.path, index = findTargetIndex(value, head);\n  if (index === !1)\n    return nextValue;\n  if (tail.length === 0) {\n    if (patch.type === \"insert\") {\n      const { position, items } = patch;\n      return insert$1(value, position, index, items);\n    } else if (patch.type === \"unset\") {\n      if (typeof index != \"number\")\n        throw new Error(\n          `Expected array index to be a number, instead got \"${index}\"`\n        );\n      return nextValue.splice(index, 1), nextValue;\n    }\n  }\n  return nextValue[index] = applyPatch(nextValue[index], {\n    ...patch,\n    path: tail\n  }), nextValue;\n}\nfunction applyPatchToNumber(value, patch) {\n  if (patch.path.length > 0)\n    throw new Error(\n      `Cannot apply deep operations on primitive values. Received patch with type \"${patch.type}\" and path \"${patch.path.map((path) => JSON.stringify(path)).join(\".\")} that targeted the value \"${JSON.stringify(value)}\"`\n    );\n  if (patch.type === \"set\")\n    return patch.value;\n  if (patch.type === \"setIfMissing\")\n    return value === void 0 ? patch.value : value;\n  if (patch.type !== \"unset\") {\n    if (patch.type === \"inc\") {\n      if (typeof patch.value != \"number\")\n        throw new Error(\"Cannot increment with a non-number\");\n      return value + patch.value;\n    }\n    if (patch.type === \"dec\") {\n      if (typeof patch.value != \"number\")\n        throw new Error(\"Cannot decrement with a non-number\");\n      return value - patch.value;\n    }\n    throw new Error(\n      `Received patch of unsupported type: \"${JSON.stringify(\n        patch.type\n      )}\" for number. This is most likely a bug.`\n    );\n  }\n}\nfunction applyPatchToObject(value, patch) {\n  const nextValue = lodash_clone_js__WEBPACK_IMPORTED_MODULE_1__(value);\n  if (patch.path.length === 0) {\n    if (patch.type === \"set\") {\n      if (typeof patch.value == \"object\" && patch.value !== null && !Array.isArray(patch.value))\n        return patch.value;\n      throw new Error(\"Cannot set value of an object to a non-object\");\n    }\n    if (patch.type === \"unset\")\n      return;\n    throw new Error(`Invalid object operation: ${patch.type}`);\n  }\n  const [head, ...tail] = patch.path;\n  if (typeof head != \"string\")\n    throw new Error(`Expected field name to be a string, instead got: ${head}`);\n  return tail.length === 0 && patch.type === \"unset\" ? lodash_omit_js__WEBPACK_IMPORTED_MODULE_2__(nextValue, head) : (!(head in nextValue) && tail.length > 0 || (nextValue[head] = applyPatch(nextValue[head], {\n    ...patch,\n    path: tail\n  })), nextValue);\n}\nfunction applyPatchToUnknown(value, patch) {\n  if (patch.path.length > 0)\n    throw new Error(\n      `Cannot apply deep operations on primitive values. Received patch with type \"${patch.type}\" and path \"${patch.path.map((path) => JSON.stringify(path)).join(\".\")} that targeted the value \"${JSON.stringify(value)}\"`\n    );\n  if (patch.type === \"set\")\n    return patch.value;\n  if (patch.type === \"setIfMissing\")\n    return value === void 0 ? patch.value : value;\n  if (patch.type !== \"unset\")\n    throw new Error(\n      `Received patch of unsupported type: \"${JSON.stringify(\n        patch.type\n      )}\" for primitives. This is most likely a bug.`\n    );\n}\nfunction applyPatchToString(value, patch) {\n  if (patch.path.length > 0)\n    throw new Error(\n      `Cannot apply deep operations on string values. Received patch with type \"${patch.type}\" and path \"${patch.path.join(\".\")} that targeted the value \"${JSON.stringify(value)}\"`\n    );\n  if (patch.type === \"diffMatchPatch\") {\n    const [result] = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_3__.applyPatches)((0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_3__.parsePatch)(patch.value), value, {\n      allowExceedingIndices: !0\n    });\n    return result;\n  }\n  if (patch.type === \"setIfMissing\")\n    return value === void 0 ? patch.value : value;\n  if (patch.type === \"set\")\n    return patch.value;\n  if (patch.type !== \"unset\")\n    throw new Error(\n      `Received patch of unsupported type: \"${JSON.stringify(\n        patch.type\n      )}\" for string. This is most likely a bug.`\n    );\n}\nfunction applyAll(value, patches) {\n  return patches.reduce(applyPatch, value);\n}\nfunction applyPatch(value, patch) {\n  return Array.isArray(value) ? applyPatchToArray(value, patch) : typeof value == \"string\" ? applyPatchToString(value, patch) : isObject(value) ? applyPatchToObject(value, patch) : typeof value == \"number\" ? applyPatchToNumber(value, patch) : applyPatchToUnknown(value, patch);\n}\nfunction isObject(value) {\n  return typeof value == \"object\" && value !== null && !Array.isArray(value);\n}\nfunction setIfMissing(value, path = []) {\n  return {\n    type: \"setIfMissing\",\n    path,\n    value\n  };\n}\nfunction diffMatchPatch(currentValue, nextValue, path = []) {\n  const patches = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_3__.makePatches)(currentValue, nextValue), patch = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_3__.stringifyPatches)(patches);\n  return { type: \"diffMatchPatch\", path, value: patch };\n}\nfunction insert(items, position, path = []) {\n  return {\n    type: \"insert\",\n    path,\n    position,\n    items\n  };\n}\nfunction set(value, path = []) {\n  return { type: \"set\", path, value };\n}\nfunction unset(path = []) {\n  return { type: \"unset\", path };\n}\nfunction prefixPath(patch, segment) {\n  return {\n    ...patch,\n    path: [segment, ...patch.path]\n  };\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvcGF0Y2hlcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQTRDO0FBQ1I7QUFDRjtBQUNpRTtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTLG9CQUFvQixRQUFRLEtBQUssTUFBTTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnREFBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLCtEQUErRCxNQUFNO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLFdBQVcsY0FBYywwREFBMEQsMkJBQTJCLHNCQUFzQjtBQUN6TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRDQUFLO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsV0FBVztBQUM1RDtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsS0FBSztBQUM3RSx1REFBdUQsMkNBQUk7QUFDM0Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixXQUFXLGNBQWMsMERBQTBELDJCQUEyQixzQkFBc0I7QUFDek47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixXQUFXLGNBQWMsc0JBQXNCLDJCQUEyQixzQkFBc0I7QUFDbEw7QUFDQTtBQUNBLHFCQUFxQixzRUFBWSxDQUFDLG9FQUFVO0FBQzVDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUVBQVcsbUNBQW1DLDBFQUFnQjtBQUNoRixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9HYWxvY2svQ1MvYmVob21lLXNpdGUvbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvcGF0Y2hlcy9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmaW5kSW5kZXggZnJvbSBcImxvZGFzaC9maW5kSW5kZXguanNcIjtcbmltcG9ydCBjbG9uZSBmcm9tIFwibG9kYXNoL2Nsb25lLmpzXCI7XG5pbXBvcnQgb21pdCBmcm9tIFwibG9kYXNoL29taXQuanNcIjtcbmltcG9ydCB7IGFwcGx5UGF0Y2hlcywgcGFyc2VQYXRjaCwgbWFrZVBhdGNoZXMsIHN0cmluZ2lmeVBhdGNoZXMgfSBmcm9tIFwiQHNhbml0eS9kaWZmLW1hdGNoLXBhdGNoXCI7XG5jb25zdCBCRUZPUkUgPSBcImJlZm9yZVwiLCBBRlRFUiA9IFwiYWZ0ZXJcIjtcbmZ1bmN0aW9uIGluc2VydCQxKGFycmF5LCBwb3NpdGlvbiwgaW5kZXgsIC4uLmFyZ3MpIHtcbiAgaWYgKHBvc2l0aW9uICE9PSBCRUZPUkUgJiYgcG9zaXRpb24gIT09IEFGVEVSKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIHBvc2l0aW9uIFwiJHtwb3NpdGlvbn1cIiwgbXVzdCBiZSBlaXRoZXIgJHtCRUZPUkV9IG9yICR7QUZURVJ9YFxuICAgICk7XG4gIGNvbnN0IGl0ZW1zID0gZmxhdHRlbiguLi5hcmdzKTtcbiAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gaXRlbXM7XG4gIGNvbnN0IGxlbiA9IGFycmF5Lmxlbmd0aCwgaWR4ID0gTWF0aC5hYnMoKGxlbiArIGluZGV4KSAlIGxlbikgJSBsZW4sIG5vcm1hbGl6ZWRJZHggPSBwb3NpdGlvbiA9PT0gXCJhZnRlclwiID8gaWR4ICsgMSA6IGlkeCwgY29weSA9IGFycmF5LnNsaWNlKCk7XG4gIHJldHVybiBjb3B5LnNwbGljZShub3JtYWxpemVkSWR4LCAwLCAuLi5mbGF0dGVuKGl0ZW1zKSksIGNvcHk7XG59XG5mdW5jdGlvbiBmbGF0dGVuKC4uLnZhbHVlcykge1xuICByZXR1cm4gdmFsdWVzLnJlZHVjZSgocHJldiwgaXRlbSkgPT4gcHJldi5jb25jYXQoaXRlbSksIFtdKTtcbn1cbmZ1bmN0aW9uIGZpbmRUYXJnZXRJbmRleChhcnJheSwgcGF0aFNlZ21lbnQpIHtcbiAgaWYgKHR5cGVvZiBwYXRoU2VnbWVudCA9PSBcIm51bWJlclwiKVxuICAgIHJldHVybiBwYXRoU2VnbWVudDtcbiAgY29uc3QgaW5kZXggPSBmaW5kSW5kZXgoYXJyYXksIHBhdGhTZWdtZW50KTtcbiAgcmV0dXJuIGluZGV4ID09PSAtMSA/ICExIDogaW5kZXg7XG59XG5mdW5jdGlvbiBhcHBseVBhdGNoVG9BcnJheSh2YWx1ZSwgcGF0Y2gpIHtcbiAgY29uc3QgbmV4dFZhbHVlID0gdmFsdWUuc2xpY2UoKTtcbiAgaWYgKHBhdGNoLnBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKHBhdGNoLnR5cGUgPT09IFwic2V0SWZNaXNzaW5nXCIpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXRjaC52YWx1ZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgdmFsdWUgb2YgYW4gYXJyYXkgdG8gYSBub24tYXJyYXlcIik7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCA/IHBhdGNoLnZhbHVlIDogdmFsdWU7XG4gICAgfVxuICAgIGlmIChwYXRjaC50eXBlID09PSBcInNldFwiKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGF0Y2gudmFsdWUpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHZhbHVlIG9mIGFuIGFycmF5IHRvIGEgbm9uLWFycmF5XCIpO1xuICAgICAgcmV0dXJuIHBhdGNoLnZhbHVlO1xuICAgIH1cbiAgICBpZiAocGF0Y2gudHlwZSA9PT0gXCJ1bnNldFwiKVxuICAgICAgcmV0dXJuO1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhcnJheSBvcGVyYXRpb246ICR7cGF0Y2gudHlwZX1gKTtcbiAgfVxuICBjb25zdCBbaGVhZCwgLi4udGFpbF0gPSBwYXRjaC5wYXRoLCBpbmRleCA9IGZpbmRUYXJnZXRJbmRleCh2YWx1ZSwgaGVhZCk7XG4gIGlmIChpbmRleCA9PT0gITEpXG4gICAgcmV0dXJuIG5leHRWYWx1ZTtcbiAgaWYgKHRhaWwubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKHBhdGNoLnR5cGUgPT09IFwiaW5zZXJ0XCIpIHtcbiAgICAgIGNvbnN0IHsgcG9zaXRpb24sIGl0ZW1zIH0gPSBwYXRjaDtcbiAgICAgIHJldHVybiBpbnNlcnQkMSh2YWx1ZSwgcG9zaXRpb24sIGluZGV4LCBpdGVtcyk7XG4gICAgfSBlbHNlIGlmIChwYXRjaC50eXBlID09PSBcInVuc2V0XCIpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5kZXggIT0gXCJudW1iZXJcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBFeHBlY3RlZCBhcnJheSBpbmRleCB0byBiZSBhIG51bWJlciwgaW5zdGVhZCBnb3QgXCIke2luZGV4fVwiYFxuICAgICAgICApO1xuICAgICAgcmV0dXJuIG5leHRWYWx1ZS5zcGxpY2UoaW5kZXgsIDEpLCBuZXh0VmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXh0VmFsdWVbaW5kZXhdID0gYXBwbHlQYXRjaChuZXh0VmFsdWVbaW5kZXhdLCB7XG4gICAgLi4ucGF0Y2gsXG4gICAgcGF0aDogdGFpbFxuICB9KSwgbmV4dFZhbHVlO1xufVxuZnVuY3Rpb24gYXBwbHlQYXRjaFRvTnVtYmVyKHZhbHVlLCBwYXRjaCkge1xuICBpZiAocGF0Y2gucGF0aC5sZW5ndGggPiAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDYW5ub3QgYXBwbHkgZGVlcCBvcGVyYXRpb25zIG9uIHByaW1pdGl2ZSB2YWx1ZXMuIFJlY2VpdmVkIHBhdGNoIHdpdGggdHlwZSBcIiR7cGF0Y2gudHlwZX1cIiBhbmQgcGF0aCBcIiR7cGF0Y2gucGF0aC5tYXAoKHBhdGgpID0+IEpTT04uc3RyaW5naWZ5KHBhdGgpKS5qb2luKFwiLlwiKX0gdGhhdCB0YXJnZXRlZCB0aGUgdmFsdWUgXCIke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1cImBcbiAgICApO1xuICBpZiAocGF0Y2gudHlwZSA9PT0gXCJzZXRcIilcbiAgICByZXR1cm4gcGF0Y2gudmFsdWU7XG4gIGlmIChwYXRjaC50eXBlID09PSBcInNldElmTWlzc2luZ1wiKVxuICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8gcGF0Y2gudmFsdWUgOiB2YWx1ZTtcbiAgaWYgKHBhdGNoLnR5cGUgIT09IFwidW5zZXRcIikge1xuICAgIGlmIChwYXRjaC50eXBlID09PSBcImluY1wiKSB7XG4gICAgICBpZiAodHlwZW9mIHBhdGNoLnZhbHVlICE9IFwibnVtYmVyXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBpbmNyZW1lbnQgd2l0aCBhIG5vbi1udW1iZXJcIik7XG4gICAgICByZXR1cm4gdmFsdWUgKyBwYXRjaC52YWx1ZTtcbiAgICB9XG4gICAgaWYgKHBhdGNoLnR5cGUgPT09IFwiZGVjXCIpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF0Y2gudmFsdWUgIT0gXCJudW1iZXJcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGRlY3JlbWVudCB3aXRoIGEgbm9uLW51bWJlclwiKTtcbiAgICAgIHJldHVybiB2YWx1ZSAtIHBhdGNoLnZhbHVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgUmVjZWl2ZWQgcGF0Y2ggb2YgdW5zdXBwb3J0ZWQgdHlwZTogXCIke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICBwYXRjaC50eXBlXG4gICAgICApfVwiIGZvciBudW1iZXIuIFRoaXMgaXMgbW9zdCBsaWtlbHkgYSBidWcuYFxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFwcGx5UGF0Y2hUb09iamVjdCh2YWx1ZSwgcGF0Y2gpIHtcbiAgY29uc3QgbmV4dFZhbHVlID0gY2xvbmUodmFsdWUpO1xuICBpZiAocGF0Y2gucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICBpZiAocGF0Y2gudHlwZSA9PT0gXCJzZXRcIikge1xuICAgICAgaWYgKHR5cGVvZiBwYXRjaC52YWx1ZSA9PSBcIm9iamVjdFwiICYmIHBhdGNoLnZhbHVlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHBhdGNoLnZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHBhdGNoLnZhbHVlO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCB2YWx1ZSBvZiBhbiBvYmplY3QgdG8gYSBub24tb2JqZWN0XCIpO1xuICAgIH1cbiAgICBpZiAocGF0Y2gudHlwZSA9PT0gXCJ1bnNldFwiKVxuICAgICAgcmV0dXJuO1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBvYmplY3Qgb3BlcmF0aW9uOiAke3BhdGNoLnR5cGV9YCk7XG4gIH1cbiAgY29uc3QgW2hlYWQsIC4uLnRhaWxdID0gcGF0Y2gucGF0aDtcbiAgaWYgKHR5cGVvZiBoZWFkICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBmaWVsZCBuYW1lIHRvIGJlIGEgc3RyaW5nLCBpbnN0ZWFkIGdvdDogJHtoZWFkfWApO1xuICByZXR1cm4gdGFpbC5sZW5ndGggPT09IDAgJiYgcGF0Y2gudHlwZSA9PT0gXCJ1bnNldFwiID8gb21pdChuZXh0VmFsdWUsIGhlYWQpIDogKCEoaGVhZCBpbiBuZXh0VmFsdWUpICYmIHRhaWwubGVuZ3RoID4gMCB8fCAobmV4dFZhbHVlW2hlYWRdID0gYXBwbHlQYXRjaChuZXh0VmFsdWVbaGVhZF0sIHtcbiAgICAuLi5wYXRjaCxcbiAgICBwYXRoOiB0YWlsXG4gIH0pKSwgbmV4dFZhbHVlKTtcbn1cbmZ1bmN0aW9uIGFwcGx5UGF0Y2hUb1Vua25vd24odmFsdWUsIHBhdGNoKSB7XG4gIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA+IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbm5vdCBhcHBseSBkZWVwIG9wZXJhdGlvbnMgb24gcHJpbWl0aXZlIHZhbHVlcy4gUmVjZWl2ZWQgcGF0Y2ggd2l0aCB0eXBlIFwiJHtwYXRjaC50eXBlfVwiIGFuZCBwYXRoIFwiJHtwYXRjaC5wYXRoLm1hcCgocGF0aCkgPT4gSlNPTi5zdHJpbmdpZnkocGF0aCkpLmpvaW4oXCIuXCIpfSB0aGF0IHRhcmdldGVkIHRoZSB2YWx1ZSBcIiR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfVwiYFxuICAgICk7XG4gIGlmIChwYXRjaC50eXBlID09PSBcInNldFwiKVxuICAgIHJldHVybiBwYXRjaC52YWx1ZTtcbiAgaWYgKHBhdGNoLnR5cGUgPT09IFwic2V0SWZNaXNzaW5nXCIpXG4gICAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyBwYXRjaC52YWx1ZSA6IHZhbHVlO1xuICBpZiAocGF0Y2gudHlwZSAhPT0gXCJ1bnNldFwiKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBSZWNlaXZlZCBwYXRjaCBvZiB1bnN1cHBvcnRlZCB0eXBlOiBcIiR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIHBhdGNoLnR5cGVcbiAgICAgICl9XCIgZm9yIHByaW1pdGl2ZXMuIFRoaXMgaXMgbW9zdCBsaWtlbHkgYSBidWcuYFxuICAgICk7XG59XG5mdW5jdGlvbiBhcHBseVBhdGNoVG9TdHJpbmcodmFsdWUsIHBhdGNoKSB7XG4gIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA+IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbm5vdCBhcHBseSBkZWVwIG9wZXJhdGlvbnMgb24gc3RyaW5nIHZhbHVlcy4gUmVjZWl2ZWQgcGF0Y2ggd2l0aCB0eXBlIFwiJHtwYXRjaC50eXBlfVwiIGFuZCBwYXRoIFwiJHtwYXRjaC5wYXRoLmpvaW4oXCIuXCIpfSB0aGF0IHRhcmdldGVkIHRoZSB2YWx1ZSBcIiR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfVwiYFxuICAgICk7XG4gIGlmIChwYXRjaC50eXBlID09PSBcImRpZmZNYXRjaFBhdGNoXCIpIHtcbiAgICBjb25zdCBbcmVzdWx0XSA9IGFwcGx5UGF0Y2hlcyhwYXJzZVBhdGNoKHBhdGNoLnZhbHVlKSwgdmFsdWUsIHtcbiAgICAgIGFsbG93RXhjZWVkaW5nSW5kaWNlczogITBcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmIChwYXRjaC50eXBlID09PSBcInNldElmTWlzc2luZ1wiKVxuICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8gcGF0Y2gudmFsdWUgOiB2YWx1ZTtcbiAgaWYgKHBhdGNoLnR5cGUgPT09IFwic2V0XCIpXG4gICAgcmV0dXJuIHBhdGNoLnZhbHVlO1xuICBpZiAocGF0Y2gudHlwZSAhPT0gXCJ1bnNldFwiKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBSZWNlaXZlZCBwYXRjaCBvZiB1bnN1cHBvcnRlZCB0eXBlOiBcIiR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIHBhdGNoLnR5cGVcbiAgICAgICl9XCIgZm9yIHN0cmluZy4gVGhpcyBpcyBtb3N0IGxpa2VseSBhIGJ1Zy5gXG4gICAgKTtcbn1cbmZ1bmN0aW9uIGFwcGx5QWxsKHZhbHVlLCBwYXRjaGVzKSB7XG4gIHJldHVybiBwYXRjaGVzLnJlZHVjZShhcHBseVBhdGNoLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBhcHBseVBhdGNoKHZhbHVlLCBwYXRjaCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBhcHBseVBhdGNoVG9BcnJheSh2YWx1ZSwgcGF0Y2gpIDogdHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIgPyBhcHBseVBhdGNoVG9TdHJpbmcodmFsdWUsIHBhdGNoKSA6IGlzT2JqZWN0KHZhbHVlKSA/IGFwcGx5UGF0Y2hUb09iamVjdCh2YWx1ZSwgcGF0Y2gpIDogdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgPyBhcHBseVBhdGNoVG9OdW1iZXIodmFsdWUsIHBhdGNoKSA6IGFwcGx5UGF0Y2hUb1Vua25vd24odmFsdWUsIHBhdGNoKTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBzZXRJZk1pc3NpbmcodmFsdWUsIHBhdGggPSBbXSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic2V0SWZNaXNzaW5nXCIsXG4gICAgcGF0aCxcbiAgICB2YWx1ZVxuICB9O1xufVxuZnVuY3Rpb24gZGlmZk1hdGNoUGF0Y2goY3VycmVudFZhbHVlLCBuZXh0VmFsdWUsIHBhdGggPSBbXSkge1xuICBjb25zdCBwYXRjaGVzID0gbWFrZVBhdGNoZXMoY3VycmVudFZhbHVlLCBuZXh0VmFsdWUpLCBwYXRjaCA9IHN0cmluZ2lmeVBhdGNoZXMocGF0Y2hlcyk7XG4gIHJldHVybiB7IHR5cGU6IFwiZGlmZk1hdGNoUGF0Y2hcIiwgcGF0aCwgdmFsdWU6IHBhdGNoIH07XG59XG5mdW5jdGlvbiBpbnNlcnQoaXRlbXMsIHBvc2l0aW9uLCBwYXRoID0gW10pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImluc2VydFwiLFxuICAgIHBhdGgsXG4gICAgcG9zaXRpb24sXG4gICAgaXRlbXNcbiAgfTtcbn1cbmZ1bmN0aW9uIHNldCh2YWx1ZSwgcGF0aCA9IFtdKSB7XG4gIHJldHVybiB7IHR5cGU6IFwic2V0XCIsIHBhdGgsIHZhbHVlIH07XG59XG5mdW5jdGlvbiB1bnNldChwYXRoID0gW10pIHtcbiAgcmV0dXJuIHsgdHlwZTogXCJ1bnNldFwiLCBwYXRoIH07XG59XG5mdW5jdGlvbiBwcmVmaXhQYXRoKHBhdGNoLCBzZWdtZW50KSB7XG4gIHJldHVybiB7XG4gICAgLi4ucGF0Y2gsXG4gICAgcGF0aDogW3NlZ21lbnQsIC4uLnBhdGNoLnBhdGhdXG4gIH07XG59XG5leHBvcnQge1xuICBhcHBseUFsbCxcbiAgZGlmZk1hdGNoUGF0Y2gsXG4gIGluc2VydCxcbiAgcHJlZml4UGF0aCxcbiAgc2V0LFxuICBzZXRJZk1pc3NpbmcsXG4gIHVuc2V0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@portabletext/patches/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@portabletext/react/dist/index.js":
/*!*********************************************************!*\
  !*** ../node_modules/@portabletext/react/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PortableText: () => (/* binding */ PortableText),\n/* harmony export */   defaultComponents: () => (/* binding */ defaultComponents),\n/* harmony export */   mergeComponents: () => (/* binding */ mergeComponents),\n/* harmony export */   toPlainText: () => (/* reexport safe */ _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.toPlainText)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/../node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @portabletext/toolkit */ \"(ssr)/../node_modules/@portabletext/toolkit/dist/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/../node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n\nconst defaultLists = {\n  number: ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ol\", { children }),\n  bullet: ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ul\", { children })\n}, DefaultListItem = ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", { children }), link = ({ children, value }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", { href: value == null ? void 0 : value.href, children }), underlineStyle = { textDecoration: \"underline\" }, defaultMarks = {\n  em: ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"em\", { children }),\n  strong: ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"strong\", { children }),\n  code: ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"code\", { children }),\n  underline: ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { style: underlineStyle, children }),\n  \"strike-through\": ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"del\", { children }),\n  link\n}, getTemplate = (type, prop) => `[@portabletext/react] Unknown ${type}, specify a component for it in the \\`components.${prop}\\` prop`, unknownTypeWarning = (typeName) => getTemplate(`block type \"${typeName}\"`, \"types\"), unknownMarkWarning = (markType) => getTemplate(`mark type \"${markType}\"`, \"marks\"), unknownBlockStyleWarning = (blockStyle) => getTemplate(`block style \"${blockStyle}\"`, \"block\"), unknownListStyleWarning = (listStyle) => getTemplate(`list style \"${listStyle}\"`, \"list\"), unknownListItemStyleWarning = (listStyle) => getTemplate(`list item style \"${listStyle}\"`, \"listItem\");\nfunction printWarning(message) {\n  console.warn(message);\n}\nconst hidden = { display: \"none\" }, DefaultUnknownType = ({\n  value,\n  isInline\n}) => {\n  const warning = unknownTypeWarning(value._type);\n  return isInline ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { style: hidden, children: warning }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { style: hidden, children: warning });\n}, DefaultUnknownMark = ({\n  markType,\n  children\n}) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { className: `unknown__pt__mark__${markType}`, children }), DefaultUnknownBlockStyle = ({\n  children\n}) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", { children }), DefaultUnknownList = ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ul\", { children }), DefaultUnknownListItem = ({\n  children\n}) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", { children }), DefaultHardBreak = () => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"br\", {}), defaultBlockStyles = {\n  normal: ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", { children }),\n  blockquote: ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"blockquote\", { children }),\n  h1: ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h1\", { children }),\n  h2: ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h2\", { children }),\n  h3: ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", { children }),\n  h4: ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h4\", { children }),\n  h5: ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h5\", { children }),\n  h6: ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h6\", { children })\n}, defaultComponents = {\n  types: {},\n  block: defaultBlockStyles,\n  marks: defaultMarks,\n  list: defaultLists,\n  listItem: DefaultListItem,\n  hardBreak: DefaultHardBreak,\n  unknownType: DefaultUnknownType,\n  unknownMark: DefaultUnknownMark,\n  unknownList: DefaultUnknownList,\n  unknownListItem: DefaultUnknownListItem,\n  unknownBlockStyle: DefaultUnknownBlockStyle\n};\nfunction mergeComponents(parent, overrides) {\n  const { block, list, listItem, marks, types, ...rest } = overrides;\n  return {\n    ...parent,\n    block: mergeDeeply(parent, overrides, \"block\"),\n    list: mergeDeeply(parent, overrides, \"list\"),\n    listItem: mergeDeeply(parent, overrides, \"listItem\"),\n    marks: mergeDeeply(parent, overrides, \"marks\"),\n    types: mergeDeeply(parent, overrides, \"types\"),\n    ...rest\n  };\n}\nfunction mergeDeeply(parent, overrides, key) {\n  const override = overrides[key], parentVal = parent[key];\n  return typeof override == \"function\" || override && typeof parentVal == \"function\" ? override : override ? { ...parentVal, ...override } : parentVal;\n}\nfunction PortableText({\n  value: input,\n  components: componentOverrides,\n  listNestingMode,\n  onMissingComponent: missingComponentHandler = printWarning\n}) {\n  const handleMissingComponent = missingComponentHandler || noop, blocks = Array.isArray(input) ? input : [input], nested = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.nestLists)(blocks, listNestingMode || _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.LIST_NEST_MODE_HTML), components = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => componentOverrides ? mergeComponents(defaultComponents, componentOverrides) : defaultComponents, [componentOverrides]), renderNode = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(\n    () => getNodeRenderer(components, handleMissingComponent),\n    [components, handleMissingComponent]\n  ), rendered = nested.map(\n    (node, index) => renderNode({ node, index, isInline: !1, renderNode })\n  );\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: rendered });\n}\nconst getNodeRenderer = (components, handleMissingComponent) => {\n  function renderNode(options) {\n    const { node, index, isInline } = options, key = node._key || `node-${index}`;\n    return (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitList)(node) ? renderList(node, index, key) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextListItemBlock)(node) ? renderListItem(node, index, key) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitSpan)(node) ? renderSpan(node, index, key) : hasCustomComponentForNode(node) ? renderCustomBlock(node, index, key, isInline) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextBlock)(node) ? renderBlock(node, index, key, isInline) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitTextNode)(node) ? renderText(node, key) : renderUnknownType(node, index, key, isInline);\n  }\n  function hasCustomComponentForNode(node) {\n    return node._type in components.types;\n  }\n  function renderListItem(node, index, key) {\n    const tree = serializeBlock({ node, index, isInline: !1, renderNode }), renderer = components.listItem, Li = (typeof renderer == \"function\" ? renderer : renderer[node.listItem]) || components.unknownListItem;\n    if (Li === components.unknownListItem) {\n      const style = node.listItem || \"bullet\";\n      handleMissingComponent(unknownListItemStyleWarning(style), {\n        type: style,\n        nodeType: \"listItemStyle\"\n      });\n    }\n    let children = tree.children;\n    if (node.style && node.style !== \"normal\") {\n      const { listItem, ...blockNode } = node;\n      children = renderNode({ node: blockNode, index, isInline: !1 });\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Li, { value: node, index, isInline: !1, renderNode, children }, key);\n  }\n  function renderList(node, index, key) {\n    const children = node.children.map(\n      (child, childIndex) => renderNode({\n        node: child._key ? child : { ...child, _key: `li-${index}-${childIndex}` },\n        index: childIndex,\n        isInline: !1\n      })\n    ), component = components.list, List = (typeof component == \"function\" ? component : component[node.listItem]) || components.unknownList;\n    if (List === components.unknownList) {\n      const style = node.listItem || \"bullet\";\n      handleMissingComponent(unknownListStyleWarning(style), { nodeType: \"listStyle\", type: style });\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(List, { value: node, index, isInline: !1, renderNode, children }, key);\n  }\n  function renderSpan(node, _index, key) {\n    const { markDef, markType, markKey } = node, Span = components.marks[markType] || components.unknownMark, children = node.children.map(\n      (child, childIndex) => renderNode({ node: child, index: childIndex, isInline: !0 })\n    );\n    return Span === components.unknownMark && handleMissingComponent(unknownMarkWarning(markType), { nodeType: \"mark\", type: markType }), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n      Span,\n      {\n        text: (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.spanToPlainText)(node),\n        value: markDef,\n        markType,\n        markKey,\n        renderNode,\n        children\n      },\n      key\n    );\n  }\n  function renderBlock(node, index, key, isInline) {\n    const { _key, ...props } = serializeBlock({ node, index, isInline, renderNode }), style = props.node.style || \"normal\", Block = (typeof components.block == \"function\" ? components.block : components.block[style]) || components.unknownBlockStyle;\n    return Block === components.unknownBlockStyle && handleMissingComponent(unknownBlockStyleWarning(style), {\n      nodeType: \"blockStyle\",\n      type: style\n    }), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Block, { ...props, value: props.node, renderNode }, key);\n  }\n  function renderText(node, key) {\n    if (node.text === `\n`) {\n      const HardBreak = components.hardBreak;\n      return HardBreak ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(HardBreak, {}, key) : `\n`;\n    }\n    return node.text;\n  }\n  function renderUnknownType(node, index, key, isInline) {\n    const nodeOptions = {\n      value: node,\n      isInline,\n      index,\n      renderNode\n    };\n    handleMissingComponent(unknownTypeWarning(node._type), { nodeType: \"block\", type: node._type });\n    const UnknownType = components.unknownType;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UnknownType, { ...nodeOptions }, key);\n  }\n  function renderCustomBlock(node, index, key, isInline) {\n    const nodeOptions = {\n      value: node,\n      isInline,\n      index,\n      renderNode\n    }, Node = components.types[node._type];\n    return Node ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Node, { ...nodeOptions }, key) : null;\n  }\n  return renderNode;\n};\nfunction serializeBlock(options) {\n  const { node, index, isInline, renderNode } = options, children = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.buildMarksTree)(node).map(\n    (child, i) => renderNode({ node: child, isInline: !0, index: i, renderNode })\n  );\n  return {\n    _key: node._key || `block-${index}`,\n    children,\n    index,\n    isInline,\n    node\n  };\n}\nfunction noop() {\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvcmVhY3QvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWtEO0FBQzZMO0FBQzNMO0FBQ3BCO0FBQ2hDO0FBQ0EsYUFBYSxVQUFVLHFCQUFxQixzREFBRyxTQUFTLFVBQVU7QUFDbEUsYUFBYSxVQUFVLHFCQUFxQixzREFBRyxTQUFTLFVBQVU7QUFDbEUsQ0FBQyx1QkFBdUIsVUFBVSxxQkFBcUIsc0RBQUcsU0FBUyxVQUFVLGFBQWEsaUJBQWlCLHFCQUFxQixzREFBRyxRQUFRLHFEQUFxRCxzQkFBc0IsNkJBQTZCO0FBQ25QLFNBQVMsVUFBVSxxQkFBcUIsc0RBQUcsU0FBUyxVQUFVO0FBQzlELGFBQWEsVUFBVSxxQkFBcUIsc0RBQUcsYUFBYSxVQUFVO0FBQ3RFLFdBQVcsVUFBVSxxQkFBcUIsc0RBQUcsV0FBVyxVQUFVO0FBQ2xFLGdCQUFnQixVQUFVLHFCQUFxQixzREFBRyxXQUFXLGlDQUFpQztBQUM5Rix1QkFBdUIsVUFBVSxxQkFBcUIsc0RBQUcsVUFBVSxVQUFVO0FBQzdFO0FBQ0EsQ0FBQyxpRUFBaUUsS0FBSyxtREFBbUQsS0FBSyx3RUFBd0UsU0FBUywyRUFBMkUsU0FBUyxxRkFBcUYsV0FBVyxrRkFBa0YsVUFBVSwwRkFBMEYsVUFBVTtBQUNwa0I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esb0NBQW9DLHNEQUFHLFdBQVcsa0NBQWtDLG9CQUFvQixzREFBRyxVQUFVLGtDQUFrQztBQUN2SixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUMscUJBQXFCLHNEQUFHLFdBQVcsaUNBQWlDLFNBQVMsYUFBYTtBQUMzRjtBQUNBLENBQUMscUJBQXFCLHNEQUFHLFFBQVEsVUFBVSwyQkFBMkIsVUFBVSxxQkFBcUIsc0RBQUcsU0FBUyxVQUFVO0FBQzNIO0FBQ0EsQ0FBQyxxQkFBcUIsc0RBQUcsU0FBUyxVQUFV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Uy9iZWhvbWUtc2l0ZS9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9yZWFjdC9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeCwgRnJhZ21lbnQgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7IG5lc3RMaXN0cywgTElTVF9ORVNUX01PREVfSFRNTCwgaXNQb3J0YWJsZVRleHRUb29sa2l0TGlzdCwgaXNQb3J0YWJsZVRleHRMaXN0SXRlbUJsb2NrLCBpc1BvcnRhYmxlVGV4dFRvb2xraXRTcGFuLCBpc1BvcnRhYmxlVGV4dEJsb2NrLCBpc1BvcnRhYmxlVGV4dFRvb2xraXRUZXh0Tm9kZSwgc3BhblRvUGxhaW5UZXh0LCBidWlsZE1hcmtzVHJlZSB9IGZyb20gXCJAcG9ydGFibGV0ZXh0L3Rvb2xraXRcIjtcbmltcG9ydCB7IHRvUGxhaW5UZXh0IH0gZnJvbSBcIkBwb3J0YWJsZXRleHQvdG9vbGtpdFwiO1xuaW1wb3J0IHsgdXNlTWVtbyB9IGZyb20gXCJyZWFjdFwiO1xuY29uc3QgZGVmYXVsdExpc3RzID0ge1xuICBudW1iZXI6ICh7IGNoaWxkcmVuIH0pID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJvbFwiLCB7IGNoaWxkcmVuIH0pLFxuICBidWxsZXQ6ICh7IGNoaWxkcmVuIH0pID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJ1bFwiLCB7IGNoaWxkcmVuIH0pXG59LCBEZWZhdWx0TGlzdEl0ZW0gPSAoeyBjaGlsZHJlbiB9KSA9PiAvKiBAX19QVVJFX18gKi8ganN4KFwibGlcIiwgeyBjaGlsZHJlbiB9KSwgbGluayA9ICh7IGNoaWxkcmVuLCB2YWx1ZSB9KSA9PiAvKiBAX19QVVJFX18gKi8ganN4KFwiYVwiLCB7IGhyZWY6IHZhbHVlID09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZS5ocmVmLCBjaGlsZHJlbiB9KSwgdW5kZXJsaW5lU3R5bGUgPSB7IHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiIH0sIGRlZmF1bHRNYXJrcyA9IHtcbiAgZW06ICh7IGNoaWxkcmVuIH0pID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJlbVwiLCB7IGNoaWxkcmVuIH0pLFxuICBzdHJvbmc6ICh7IGNoaWxkcmVuIH0pID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzdHJvbmdcIiwgeyBjaGlsZHJlbiB9KSxcbiAgY29kZTogKHsgY2hpbGRyZW4gfSkgPT4gLyogQF9fUFVSRV9fICovIGpzeChcImNvZGVcIiwgeyBjaGlsZHJlbiB9KSxcbiAgdW5kZXJsaW5lOiAoeyBjaGlsZHJlbiB9KSA9PiAvKiBAX19QVVJFX18gKi8ganN4KFwic3BhblwiLCB7IHN0eWxlOiB1bmRlcmxpbmVTdHlsZSwgY2hpbGRyZW4gfSksXG4gIFwic3RyaWtlLXRocm91Z2hcIjogKHsgY2hpbGRyZW4gfSkgPT4gLyogQF9fUFVSRV9fICovIGpzeChcImRlbFwiLCB7IGNoaWxkcmVuIH0pLFxuICBsaW5rXG59LCBnZXRUZW1wbGF0ZSA9ICh0eXBlLCBwcm9wKSA9PiBgW0Bwb3J0YWJsZXRleHQvcmVhY3RdIFVua25vd24gJHt0eXBlfSwgc3BlY2lmeSBhIGNvbXBvbmVudCBmb3IgaXQgaW4gdGhlIFxcYGNvbXBvbmVudHMuJHtwcm9wfVxcYCBwcm9wYCwgdW5rbm93blR5cGVXYXJuaW5nID0gKHR5cGVOYW1lKSA9PiBnZXRUZW1wbGF0ZShgYmxvY2sgdHlwZSBcIiR7dHlwZU5hbWV9XCJgLCBcInR5cGVzXCIpLCB1bmtub3duTWFya1dhcm5pbmcgPSAobWFya1R5cGUpID0+IGdldFRlbXBsYXRlKGBtYXJrIHR5cGUgXCIke21hcmtUeXBlfVwiYCwgXCJtYXJrc1wiKSwgdW5rbm93bkJsb2NrU3R5bGVXYXJuaW5nID0gKGJsb2NrU3R5bGUpID0+IGdldFRlbXBsYXRlKGBibG9jayBzdHlsZSBcIiR7YmxvY2tTdHlsZX1cImAsIFwiYmxvY2tcIiksIHVua25vd25MaXN0U3R5bGVXYXJuaW5nID0gKGxpc3RTdHlsZSkgPT4gZ2V0VGVtcGxhdGUoYGxpc3Qgc3R5bGUgXCIke2xpc3RTdHlsZX1cImAsIFwibGlzdFwiKSwgdW5rbm93bkxpc3RJdGVtU3R5bGVXYXJuaW5nID0gKGxpc3RTdHlsZSkgPT4gZ2V0VGVtcGxhdGUoYGxpc3QgaXRlbSBzdHlsZSBcIiR7bGlzdFN0eWxlfVwiYCwgXCJsaXN0SXRlbVwiKTtcbmZ1bmN0aW9uIHByaW50V2FybmluZyhtZXNzYWdlKSB7XG4gIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbn1cbmNvbnN0IGhpZGRlbiA9IHsgZGlzcGxheTogXCJub25lXCIgfSwgRGVmYXVsdFVua25vd25UeXBlID0gKHtcbiAgdmFsdWUsXG4gIGlzSW5saW5lXG59KSA9PiB7XG4gIGNvbnN0IHdhcm5pbmcgPSB1bmtub3duVHlwZVdhcm5pbmcodmFsdWUuX3R5cGUpO1xuICByZXR1cm4gaXNJbmxpbmUgPyAvKiBAX19QVVJFX18gKi8ganN4KFwic3BhblwiLCB7IHN0eWxlOiBoaWRkZW4sIGNoaWxkcmVuOiB3YXJuaW5nIH0pIDogLyogQF9fUFVSRV9fICovIGpzeChcImRpdlwiLCB7IHN0eWxlOiBoaWRkZW4sIGNoaWxkcmVuOiB3YXJuaW5nIH0pO1xufSwgRGVmYXVsdFVua25vd25NYXJrID0gKHtcbiAgbWFya1R5cGUsXG4gIGNoaWxkcmVuXG59KSA9PiAvKiBAX19QVVJFX18gKi8ganN4KFwic3BhblwiLCB7IGNsYXNzTmFtZTogYHVua25vd25fX3B0X19tYXJrX18ke21hcmtUeXBlfWAsIGNoaWxkcmVuIH0pLCBEZWZhdWx0VW5rbm93bkJsb2NrU3R5bGUgPSAoe1xuICBjaGlsZHJlblxufSkgPT4gLyogQF9fUFVSRV9fICovIGpzeChcInBcIiwgeyBjaGlsZHJlbiB9KSwgRGVmYXVsdFVua25vd25MaXN0ID0gKHsgY2hpbGRyZW4gfSkgPT4gLyogQF9fUFVSRV9fICovIGpzeChcInVsXCIsIHsgY2hpbGRyZW4gfSksIERlZmF1bHRVbmtub3duTGlzdEl0ZW0gPSAoe1xuICBjaGlsZHJlblxufSkgPT4gLyogQF9fUFVSRV9fICovIGpzeChcImxpXCIsIHsgY2hpbGRyZW4gfSksIERlZmF1bHRIYXJkQnJlYWsgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8ganN4KFwiYnJcIiwge30pLCBkZWZhdWx0QmxvY2tTdHlsZXMgPSB7XG4gIG5vcm1hbDogKHsgY2hpbGRyZW4gfSkgPT4gLyogQF9fUFVSRV9fICovIGpzeChcInBcIiwgeyBjaGlsZHJlbiB9KSxcbiAgYmxvY2txdW90ZTogKHsgY2hpbGRyZW4gfSkgPT4gLyogQF9fUFVSRV9fICovIGpzeChcImJsb2NrcXVvdGVcIiwgeyBjaGlsZHJlbiB9KSxcbiAgaDE6ICh7IGNoaWxkcmVuIH0pID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJoMVwiLCB7IGNoaWxkcmVuIH0pLFxuICBoMjogKHsgY2hpbGRyZW4gfSkgPT4gLyogQF9fUFVSRV9fICovIGpzeChcImgyXCIsIHsgY2hpbGRyZW4gfSksXG4gIGgzOiAoeyBjaGlsZHJlbiB9KSA9PiAvKiBAX19QVVJFX18gKi8ganN4KFwiaDNcIiwgeyBjaGlsZHJlbiB9KSxcbiAgaDQ6ICh7IGNoaWxkcmVuIH0pID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJoNFwiLCB7IGNoaWxkcmVuIH0pLFxuICBoNTogKHsgY2hpbGRyZW4gfSkgPT4gLyogQF9fUFVSRV9fICovIGpzeChcImg1XCIsIHsgY2hpbGRyZW4gfSksXG4gIGg2OiAoeyBjaGlsZHJlbiB9KSA9PiAvKiBAX19QVVJFX18gKi8ganN4KFwiaDZcIiwgeyBjaGlsZHJlbiB9KVxufSwgZGVmYXVsdENvbXBvbmVudHMgPSB7XG4gIHR5cGVzOiB7fSxcbiAgYmxvY2s6IGRlZmF1bHRCbG9ja1N0eWxlcyxcbiAgbWFya3M6IGRlZmF1bHRNYXJrcyxcbiAgbGlzdDogZGVmYXVsdExpc3RzLFxuICBsaXN0SXRlbTogRGVmYXVsdExpc3RJdGVtLFxuICBoYXJkQnJlYWs6IERlZmF1bHRIYXJkQnJlYWssXG4gIHVua25vd25UeXBlOiBEZWZhdWx0VW5rbm93blR5cGUsXG4gIHVua25vd25NYXJrOiBEZWZhdWx0VW5rbm93bk1hcmssXG4gIHVua25vd25MaXN0OiBEZWZhdWx0VW5rbm93bkxpc3QsXG4gIHVua25vd25MaXN0SXRlbTogRGVmYXVsdFVua25vd25MaXN0SXRlbSxcbiAgdW5rbm93bkJsb2NrU3R5bGU6IERlZmF1bHRVbmtub3duQmxvY2tTdHlsZVxufTtcbmZ1bmN0aW9uIG1lcmdlQ29tcG9uZW50cyhwYXJlbnQsIG92ZXJyaWRlcykge1xuICBjb25zdCB7IGJsb2NrLCBsaXN0LCBsaXN0SXRlbSwgbWFya3MsIHR5cGVzLCAuLi5yZXN0IH0gPSBvdmVycmlkZXM7XG4gIHJldHVybiB7XG4gICAgLi4ucGFyZW50LFxuICAgIGJsb2NrOiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywgXCJibG9ja1wiKSxcbiAgICBsaXN0OiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywgXCJsaXN0XCIpLFxuICAgIGxpc3RJdGVtOiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywgXCJsaXN0SXRlbVwiKSxcbiAgICBtYXJrczogbWVyZ2VEZWVwbHkocGFyZW50LCBvdmVycmlkZXMsIFwibWFya3NcIiksXG4gICAgdHlwZXM6IG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBcInR5cGVzXCIpLFxuICAgIC4uLnJlc3RcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBrZXkpIHtcbiAgY29uc3Qgb3ZlcnJpZGUgPSBvdmVycmlkZXNba2V5XSwgcGFyZW50VmFsID0gcGFyZW50W2tleV07XG4gIHJldHVybiB0eXBlb2Ygb3ZlcnJpZGUgPT0gXCJmdW5jdGlvblwiIHx8IG92ZXJyaWRlICYmIHR5cGVvZiBwYXJlbnRWYWwgPT0gXCJmdW5jdGlvblwiID8gb3ZlcnJpZGUgOiBvdmVycmlkZSA/IHsgLi4ucGFyZW50VmFsLCAuLi5vdmVycmlkZSB9IDogcGFyZW50VmFsO1xufVxuZnVuY3Rpb24gUG9ydGFibGVUZXh0KHtcbiAgdmFsdWU6IGlucHV0LFxuICBjb21wb25lbnRzOiBjb21wb25lbnRPdmVycmlkZXMsXG4gIGxpc3ROZXN0aW5nTW9kZSxcbiAgb25NaXNzaW5nQ29tcG9uZW50OiBtaXNzaW5nQ29tcG9uZW50SGFuZGxlciA9IHByaW50V2FybmluZ1xufSkge1xuICBjb25zdCBoYW5kbGVNaXNzaW5nQ29tcG9uZW50ID0gbWlzc2luZ0NvbXBvbmVudEhhbmRsZXIgfHwgbm9vcCwgYmxvY2tzID0gQXJyYXkuaXNBcnJheShpbnB1dCkgPyBpbnB1dCA6IFtpbnB1dF0sIG5lc3RlZCA9IG5lc3RMaXN0cyhibG9ja3MsIGxpc3ROZXN0aW5nTW9kZSB8fCBMSVNUX05FU1RfTU9ERV9IVE1MKSwgY29tcG9uZW50cyA9IHVzZU1lbW8oKCkgPT4gY29tcG9uZW50T3ZlcnJpZGVzID8gbWVyZ2VDb21wb25lbnRzKGRlZmF1bHRDb21wb25lbnRzLCBjb21wb25lbnRPdmVycmlkZXMpIDogZGVmYXVsdENvbXBvbmVudHMsIFtjb21wb25lbnRPdmVycmlkZXNdKSwgcmVuZGVyTm9kZSA9IHVzZU1lbW8oXG4gICAgKCkgPT4gZ2V0Tm9kZVJlbmRlcmVyKGNvbXBvbmVudHMsIGhhbmRsZU1pc3NpbmdDb21wb25lbnQpLFxuICAgIFtjb21wb25lbnRzLCBoYW5kbGVNaXNzaW5nQ29tcG9uZW50XVxuICApLCByZW5kZXJlZCA9IG5lc3RlZC5tYXAoXG4gICAgKG5vZGUsIGluZGV4KSA9PiByZW5kZXJOb2RlKHsgbm9kZSwgaW5kZXgsIGlzSW5saW5lOiAhMSwgcmVuZGVyTm9kZSB9KVxuICApO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChGcmFnbWVudCwgeyBjaGlsZHJlbjogcmVuZGVyZWQgfSk7XG59XG5jb25zdCBnZXROb2RlUmVuZGVyZXIgPSAoY29tcG9uZW50cywgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCkgPT4ge1xuICBmdW5jdGlvbiByZW5kZXJOb2RlKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IG5vZGUsIGluZGV4LCBpc0lubGluZSB9ID0gb3B0aW9ucywga2V5ID0gbm9kZS5fa2V5IHx8IGBub2RlLSR7aW5kZXh9YDtcbiAgICByZXR1cm4gaXNQb3J0YWJsZVRleHRUb29sa2l0TGlzdChub2RlKSA/IHJlbmRlckxpc3Qobm9kZSwgaW5kZXgsIGtleSkgOiBpc1BvcnRhYmxlVGV4dExpc3RJdGVtQmxvY2sobm9kZSkgPyByZW5kZXJMaXN0SXRlbShub2RlLCBpbmRleCwga2V5KSA6IGlzUG9ydGFibGVUZXh0VG9vbGtpdFNwYW4obm9kZSkgPyByZW5kZXJTcGFuKG5vZGUsIGluZGV4LCBrZXkpIDogaGFzQ3VzdG9tQ29tcG9uZW50Rm9yTm9kZShub2RlKSA/IHJlbmRlckN1c3RvbUJsb2NrKG5vZGUsIGluZGV4LCBrZXksIGlzSW5saW5lKSA6IGlzUG9ydGFibGVUZXh0QmxvY2sobm9kZSkgPyByZW5kZXJCbG9jayhub2RlLCBpbmRleCwga2V5LCBpc0lubGluZSkgOiBpc1BvcnRhYmxlVGV4dFRvb2xraXRUZXh0Tm9kZShub2RlKSA/IHJlbmRlclRleHQobm9kZSwga2V5KSA6IHJlbmRlclVua25vd25UeXBlKG5vZGUsIGluZGV4LCBrZXksIGlzSW5saW5lKTtcbiAgfVxuICBmdW5jdGlvbiBoYXNDdXN0b21Db21wb25lbnRGb3JOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5fdHlwZSBpbiBjb21wb25lbnRzLnR5cGVzO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlckxpc3RJdGVtKG5vZGUsIGluZGV4LCBrZXkpIHtcbiAgICBjb25zdCB0cmVlID0gc2VyaWFsaXplQmxvY2soeyBub2RlLCBpbmRleCwgaXNJbmxpbmU6ICExLCByZW5kZXJOb2RlIH0pLCByZW5kZXJlciA9IGNvbXBvbmVudHMubGlzdEl0ZW0sIExpID0gKHR5cGVvZiByZW5kZXJlciA9PSBcImZ1bmN0aW9uXCIgPyByZW5kZXJlciA6IHJlbmRlcmVyW25vZGUubGlzdEl0ZW1dKSB8fCBjb21wb25lbnRzLnVua25vd25MaXN0SXRlbTtcbiAgICBpZiAoTGkgPT09IGNvbXBvbmVudHMudW5rbm93bkxpc3RJdGVtKSB7XG4gICAgICBjb25zdCBzdHlsZSA9IG5vZGUubGlzdEl0ZW0gfHwgXCJidWxsZXRcIjtcbiAgICAgIGhhbmRsZU1pc3NpbmdDb21wb25lbnQodW5rbm93bkxpc3RJdGVtU3R5bGVXYXJuaW5nKHN0eWxlKSwge1xuICAgICAgICB0eXBlOiBzdHlsZSxcbiAgICAgICAgbm9kZVR5cGU6IFwibGlzdEl0ZW1TdHlsZVwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IGNoaWxkcmVuID0gdHJlZS5jaGlsZHJlbjtcbiAgICBpZiAobm9kZS5zdHlsZSAmJiBub2RlLnN0eWxlICE9PSBcIm5vcm1hbFwiKSB7XG4gICAgICBjb25zdCB7IGxpc3RJdGVtLCAuLi5ibG9ja05vZGUgfSA9IG5vZGU7XG4gICAgICBjaGlsZHJlbiA9IHJlbmRlck5vZGUoeyBub2RlOiBibG9ja05vZGUsIGluZGV4LCBpc0lubGluZTogITEgfSk7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KExpLCB7IHZhbHVlOiBub2RlLCBpbmRleCwgaXNJbmxpbmU6ICExLCByZW5kZXJOb2RlLCBjaGlsZHJlbiB9LCBrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlckxpc3Qobm9kZSwgaW5kZXgsIGtleSkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbi5tYXAoXG4gICAgICAoY2hpbGQsIGNoaWxkSW5kZXgpID0+IHJlbmRlck5vZGUoe1xuICAgICAgICBub2RlOiBjaGlsZC5fa2V5ID8gY2hpbGQgOiB7IC4uLmNoaWxkLCBfa2V5OiBgbGktJHtpbmRleH0tJHtjaGlsZEluZGV4fWAgfSxcbiAgICAgICAgaW5kZXg6IGNoaWxkSW5kZXgsXG4gICAgICAgIGlzSW5saW5lOiAhMVxuICAgICAgfSlcbiAgICApLCBjb21wb25lbnQgPSBjb21wb25lbnRzLmxpc3QsIExpc3QgPSAodHlwZW9mIGNvbXBvbmVudCA9PSBcImZ1bmN0aW9uXCIgPyBjb21wb25lbnQgOiBjb21wb25lbnRbbm9kZS5saXN0SXRlbV0pIHx8IGNvbXBvbmVudHMudW5rbm93bkxpc3Q7XG4gICAgaWYgKExpc3QgPT09IGNvbXBvbmVudHMudW5rbm93bkxpc3QpIHtcbiAgICAgIGNvbnN0IHN0eWxlID0gbm9kZS5saXN0SXRlbSB8fCBcImJ1bGxldFwiO1xuICAgICAgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCh1bmtub3duTGlzdFN0eWxlV2FybmluZyhzdHlsZSksIHsgbm9kZVR5cGU6IFwibGlzdFN0eWxlXCIsIHR5cGU6IHN0eWxlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChMaXN0LCB7IHZhbHVlOiBub2RlLCBpbmRleCwgaXNJbmxpbmU6ICExLCByZW5kZXJOb2RlLCBjaGlsZHJlbiB9LCBrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlclNwYW4obm9kZSwgX2luZGV4LCBrZXkpIHtcbiAgICBjb25zdCB7IG1hcmtEZWYsIG1hcmtUeXBlLCBtYXJrS2V5IH0gPSBub2RlLCBTcGFuID0gY29tcG9uZW50cy5tYXJrc1ttYXJrVHlwZV0gfHwgY29tcG9uZW50cy51bmtub3duTWFyaywgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLm1hcChcbiAgICAgIChjaGlsZCwgY2hpbGRJbmRleCkgPT4gcmVuZGVyTm9kZSh7IG5vZGU6IGNoaWxkLCBpbmRleDogY2hpbGRJbmRleCwgaXNJbmxpbmU6ICEwIH0pXG4gICAgKTtcbiAgICByZXR1cm4gU3BhbiA9PT0gY29tcG9uZW50cy51bmtub3duTWFyayAmJiBoYW5kbGVNaXNzaW5nQ29tcG9uZW50KHVua25vd25NYXJrV2FybmluZyhtYXJrVHlwZSksIHsgbm9kZVR5cGU6IFwibWFya1wiLCB0eXBlOiBtYXJrVHlwZSB9KSwgLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgIFNwYW4sXG4gICAgICB7XG4gICAgICAgIHRleHQ6IHNwYW5Ub1BsYWluVGV4dChub2RlKSxcbiAgICAgICAgdmFsdWU6IG1hcmtEZWYsXG4gICAgICAgIG1hcmtUeXBlLFxuICAgICAgICBtYXJrS2V5LFxuICAgICAgICByZW5kZXJOb2RlLFxuICAgICAgICBjaGlsZHJlblxuICAgICAgfSxcbiAgICAgIGtleVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyQmxvY2sobm9kZSwgaW5kZXgsIGtleSwgaXNJbmxpbmUpIHtcbiAgICBjb25zdCB7IF9rZXksIC4uLnByb3BzIH0gPSBzZXJpYWxpemVCbG9jayh7IG5vZGUsIGluZGV4LCBpc0lubGluZSwgcmVuZGVyTm9kZSB9KSwgc3R5bGUgPSBwcm9wcy5ub2RlLnN0eWxlIHx8IFwibm9ybWFsXCIsIEJsb2NrID0gKHR5cGVvZiBjb21wb25lbnRzLmJsb2NrID09IFwiZnVuY3Rpb25cIiA/IGNvbXBvbmVudHMuYmxvY2sgOiBjb21wb25lbnRzLmJsb2NrW3N0eWxlXSkgfHwgY29tcG9uZW50cy51bmtub3duQmxvY2tTdHlsZTtcbiAgICByZXR1cm4gQmxvY2sgPT09IGNvbXBvbmVudHMudW5rbm93bkJsb2NrU3R5bGUgJiYgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCh1bmtub3duQmxvY2tTdHlsZVdhcm5pbmcoc3R5bGUpLCB7XG4gICAgICBub2RlVHlwZTogXCJibG9ja1N0eWxlXCIsXG4gICAgICB0eXBlOiBzdHlsZVxuICAgIH0pLCAvKiBAX19QVVJFX18gKi8ganN4KEJsb2NrLCB7IC4uLnByb3BzLCB2YWx1ZTogcHJvcHMubm9kZSwgcmVuZGVyTm9kZSB9LCBrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlclRleHQobm9kZSwga2V5KSB7XG4gICAgaWYgKG5vZGUudGV4dCA9PT0gYFxuYCkge1xuICAgICAgY29uc3QgSGFyZEJyZWFrID0gY29tcG9uZW50cy5oYXJkQnJlYWs7XG4gICAgICByZXR1cm4gSGFyZEJyZWFrID8gLyogQF9fUFVSRV9fICovIGpzeChIYXJkQnJlYWssIHt9LCBrZXkpIDogYFxuYDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUudGV4dDtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJVbmtub3duVHlwZShub2RlLCBpbmRleCwga2V5LCBpc0lubGluZSkge1xuICAgIGNvbnN0IG5vZGVPcHRpb25zID0ge1xuICAgICAgdmFsdWU6IG5vZGUsXG4gICAgICBpc0lubGluZSxcbiAgICAgIGluZGV4LFxuICAgICAgcmVuZGVyTm9kZVxuICAgIH07XG4gICAgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCh1bmtub3duVHlwZVdhcm5pbmcobm9kZS5fdHlwZSksIHsgbm9kZVR5cGU6IFwiYmxvY2tcIiwgdHlwZTogbm9kZS5fdHlwZSB9KTtcbiAgICBjb25zdCBVbmtub3duVHlwZSA9IGNvbXBvbmVudHMudW5rbm93blR5cGU7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goVW5rbm93blR5cGUsIHsgLi4ubm9kZU9wdGlvbnMgfSwga2V5KTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJDdXN0b21CbG9jayhub2RlLCBpbmRleCwga2V5LCBpc0lubGluZSkge1xuICAgIGNvbnN0IG5vZGVPcHRpb25zID0ge1xuICAgICAgdmFsdWU6IG5vZGUsXG4gICAgICBpc0lubGluZSxcbiAgICAgIGluZGV4LFxuICAgICAgcmVuZGVyTm9kZVxuICAgIH0sIE5vZGUgPSBjb21wb25lbnRzLnR5cGVzW25vZGUuX3R5cGVdO1xuICAgIHJldHVybiBOb2RlID8gLyogQF9fUFVSRV9fICovIGpzeChOb2RlLCB7IC4uLm5vZGVPcHRpb25zIH0sIGtleSkgOiBudWxsO1xuICB9XG4gIHJldHVybiByZW5kZXJOb2RlO1xufTtcbmZ1bmN0aW9uIHNlcmlhbGl6ZUJsb2NrKG9wdGlvbnMpIHtcbiAgY29uc3QgeyBub2RlLCBpbmRleCwgaXNJbmxpbmUsIHJlbmRlck5vZGUgfSA9IG9wdGlvbnMsIGNoaWxkcmVuID0gYnVpbGRNYXJrc1RyZWUobm9kZSkubWFwKFxuICAgIChjaGlsZCwgaSkgPT4gcmVuZGVyTm9kZSh7IG5vZGU6IGNoaWxkLCBpc0lubGluZTogITAsIGluZGV4OiBpLCByZW5kZXJOb2RlIH0pXG4gICk7XG4gIHJldHVybiB7XG4gICAgX2tleTogbm9kZS5fa2V5IHx8IGBibG9jay0ke2luZGV4fWAsXG4gICAgY2hpbGRyZW4sXG4gICAgaW5kZXgsXG4gICAgaXNJbmxpbmUsXG4gICAgbm9kZVxuICB9O1xufVxuZnVuY3Rpb24gbm9vcCgpIHtcbn1cbmV4cG9ydCB7XG4gIFBvcnRhYmxlVGV4dCxcbiAgZGVmYXVsdENvbXBvbmVudHMsXG4gIG1lcmdlQ29tcG9uZW50cyxcbiAgdG9QbGFpblRleHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@portabletext/react/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@portabletext/sanity-bridge/dist/index.js":
/*!*****************************************************************!*\
  !*** ../node_modules/@portabletext/sanity-bridge/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compileSchemaDefinitionToPortableTextMemberSchemaTypes: () => (/* binding */ compileSchemaDefinitionToPortableTextMemberSchemaTypes),\n/* harmony export */   createPortableTextMemberSchemaTypes: () => (/* binding */ createPortableTextMemberSchemaTypes),\n/* harmony export */   portableTextMemberSchemaTypesToSchema: () => (/* binding */ portableTextMemberSchemaTypesToSchema),\n/* harmony export */   sanitySchemaToPortableTextSchema: () => (/* binding */ sanitySchemaToPortableTextSchema)\n/* harmony export */ });\n/* harmony import */ var _sanity_schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sanity/schema */ \"(ssr)/../node_modules/@sanity/schema/lib/index.mjs\");\n/* harmony import */ var _sanity_schema_internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sanity/schema/_internal */ \"(ssr)/../node_modules/@sanity/schema/lib/_internal.mjs\");\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/../node_modules/@sanity/types/lib/index.mjs\");\n/* harmony import */ var lodash_startcase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash.startcase */ \"(ssr)/../node_modules/lodash.startcase/index.js\");\n/* harmony import */ var get_random_values_esm__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! get-random-values-esm */ \"(ssr)/../node_modules/get-random-values-esm/index.mjs\");\n\n\n\n\n\nfunction createPortableTextMemberSchemaTypes(portableTextType) {\n  if (!portableTextType)\n    throw new Error(\"Parameter 'portabletextType' missing (required)\");\n  const blockType = portableTextType.of?.find(findBlockType);\n  if (!blockType)\n    throw new Error(\"Block type is not defined in this schema (required)\");\n  const childrenField = blockType.fields?.find(\n    (field) => field.name === \"children\"\n  );\n  if (!childrenField)\n    throw new Error(\"Children field for block type found in schema (required)\");\n  const ofType = childrenField.type.of;\n  if (!ofType)\n    throw new Error(\n      \"Valid types for block children not found in schema (required)\"\n    );\n  const spanType = ofType.find((memberType) => memberType.name === \"span\");\n  if (!spanType)\n    throw new Error(\"Span type not found in schema (required)\");\n  const inlineObjectTypes = ofType.filter(\n    (memberType) => memberType.name !== \"span\"\n  ) || [], blockObjectTypes = portableTextType.of?.filter(\n    (field) => field.name !== blockType.name\n  ) || [];\n  return {\n    styles: resolveEnabledStyles(blockType),\n    decorators: resolveEnabledDecorators(spanType),\n    lists: resolveEnabledListItems(blockType),\n    block: blockType,\n    span: spanType,\n    portableText: portableTextType,\n    inlineObjects: inlineObjectTypes,\n    blockObjects: blockObjectTypes,\n    annotations: spanType.annotations\n  };\n}\nfunction resolveEnabledStyles(blockType) {\n  const styleField = blockType.fields?.find(\n    (btField) => btField.name === \"style\"\n  );\n  if (!styleField)\n    throw new Error(\n      \"A field with name 'style' is not defined in the block type (required).\"\n    );\n  const textStyles = styleField.type.options?.list && styleField.type.options.list?.filter(\n    (style) => style.value\n  );\n  if (!textStyles || textStyles.length === 0)\n    throw new Error(\n      \"The style fields need at least one style defined. I.e: {title: 'Normal', value: 'normal'}.\"\n    );\n  return textStyles;\n}\nfunction resolveEnabledDecorators(spanType) {\n  return spanType.decorators;\n}\nfunction resolveEnabledListItems(blockType) {\n  const listField = blockType.fields?.find(\n    (btField) => btField.name === \"listItem\"\n  );\n  if (!listField)\n    throw new Error(\n      \"A field with name 'listItem' is not defined in the block type (required).\"\n    );\n  const listItems = listField.type.options?.list && listField.type.options.list.filter((list) => list.value);\n  if (!listItems)\n    throw new Error(\"The list field need at least to be an empty array\");\n  return listItems;\n}\nfunction findBlockType(type) {\n  return type.type ? findBlockType(type.type) : type.name === \"block\" ? type : null;\n}\nfunction portableTextMemberSchemaTypesToSchema(schema) {\n  return {\n    annotations: schema.annotations.map((annotation) => ({\n      name: annotation.name,\n      fields: annotation.fields.map((field) => ({\n        name: field.name,\n        type: field.type.jsonType,\n        title: field.type.title\n      })),\n      title: annotation.title\n    })),\n    block: {\n      name: schema.block.name\n    },\n    blockObjects: schema.blockObjects.map((blockObject) => ({\n      name: blockObject.name,\n      fields: blockObject.fields.map((field) => ({\n        name: field.name,\n        type: field.type.jsonType,\n        title: field.type.title\n      })),\n      title: blockObject.title\n    })),\n    decorators: schema.decorators.map((decorator) => ({\n      name: decorator.value,\n      title: decorator.title,\n      value: decorator.value\n    })),\n    inlineObjects: schema.inlineObjects.map((inlineObject) => ({\n      name: inlineObject.name,\n      fields: inlineObject.fields.map((field) => ({\n        name: field.name,\n        type: field.type.jsonType,\n        title: field.type.title\n      })),\n      title: inlineObject.title\n    })),\n    span: {\n      name: schema.span.name\n    },\n    styles: schema.styles.map((style) => ({\n      name: style.value,\n      title: style.title,\n      value: style.value\n    })),\n    lists: schema.lists.map((list) => ({\n      name: list.value,\n      title: list.title,\n      value: list.value\n    }))\n  };\n}\nfunction sanitySchemaToPortableTextSchema(sanitySchema) {\n  const portableTextMemberSchemaTypes = createPortableTextMemberSchemaTypes(\n    sanitySchema.hasOwnProperty(\"jsonType\") ? sanitySchema : compileType(sanitySchema)\n  );\n  return portableTextMemberSchemaTypesToSchema(portableTextMemberSchemaTypes);\n}\nfunction compileType(rawType) {\n  return _sanity_schema__WEBPACK_IMPORTED_MODULE_1__.Schema.compile({\n    name: \"blockTypeSchema\",\n    types: [rawType, ..._sanity_schema_internal__WEBPACK_IMPORTED_MODULE_2__.builtinTypes]\n  }).get(rawType.name);\n}\nconst keyGenerator = () => randomKey(12), getByteHexTable = /* @__PURE__ */ (() => {\n  let table;\n  return () => {\n    if (table)\n      return table;\n    table = [];\n    for (let i = 0; i < 256; ++i)\n      table[i] = (i + 256).toString(16).slice(1);\n    return table;\n  };\n})();\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length);\n  return (0,get_random_values_esm__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(rnds8), rnds8;\n}\nfunction randomKey(length) {\n  const table = getByteHexTable();\n  return whatwgRNG(length).reduce((str, n) => str + table[n], \"\").slice(0, length);\n}\nconst temporaryImageBlockObjectName = `tmp-${keyGenerator()}-image`, temporaryUrlBlockObjectName = `tmp-${keyGenerator()}-url`, temporaryImageInlineObjectName = `tmp-${keyGenerator()}-image`, temporaryUrlInlineObjectName = `tmp-${keyGenerator()}-url`, temporaryBlockObjectNames = {\n  image: temporaryImageBlockObjectName,\n  url: temporaryUrlBlockObjectName\n}, temporaryInlineObjectNames = {\n  image: temporaryImageInlineObjectName,\n  url: temporaryUrlInlineObjectName\n}, blockObjectNames = {\n  [temporaryImageBlockObjectName]: \"image\",\n  [temporaryUrlBlockObjectName]: \"url\"\n}, inlineObjectNames = {\n  [temporaryImageInlineObjectName]: \"image\",\n  [temporaryUrlInlineObjectName]: \"url\"\n}, defaultObjectTitles = {\n  image: \"Image\",\n  url: \"URL\"\n};\nfunction compileSchemaDefinitionToPortableTextMemberSchemaTypes(definition) {\n  const blockObjects = definition?.blockObjects?.map(\n    (blockObject) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_4__.defineType)({\n      type: \"object\",\n      // Very naive way to work around `SanitySchema.compile` adding default\n      // fields to objects with certain names.\n      name: temporaryBlockObjectNames[blockObject.name] ?? blockObject.name,\n      title: blockObject.title === void 0 ? (\n        // This avoids the default title which is a title case of the object name\n        defaultObjectTitles[blockObject.name]\n      ) : blockObject.title,\n      fields: blockObject.fields?.map((field) => ({\n        name: field.name,\n        type: field.type,\n        title: field.title ?? lodash_startcase__WEBPACK_IMPORTED_MODULE_0__(field.name)\n      })) ?? []\n    })\n  ) ?? [], inlineObjects = definition?.inlineObjects?.map(\n    (inlineObject) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_4__.defineType)({\n      type: \"object\",\n      // Very naive way to work around `SanitySchema.compile` adding default\n      // fields to objects with certain names.\n      name: temporaryInlineObjectNames[inlineObject.name] ?? inlineObject.name,\n      title: inlineObject.title === void 0 ? (\n        // This avoids the default title which is a title case of the object name\n        defaultObjectTitles[inlineObject.name]\n      ) : inlineObject.title,\n      fields: inlineObject.fields?.map((field) => ({\n        name: field.name,\n        type: field.type,\n        title: field.title ?? lodash_startcase__WEBPACK_IMPORTED_MODULE_0__(field.name)\n      })) ?? []\n    })\n  ) ?? [], portableTextSchema = (0,_sanity_types__WEBPACK_IMPORTED_MODULE_4__.defineField)({\n    type: \"array\",\n    name: \"portable-text\",\n    of: [\n      ...blockObjects.map((blockObject) => ({ type: blockObject.name })),\n      {\n        type: \"block\",\n        name: \"block\",\n        of: inlineObjects.map((inlineObject) => ({ type: inlineObject.name })),\n        marks: {\n          decorators: definition?.decorators?.map((decorator) => ({\n            title: decorator.title ?? lodash_startcase__WEBPACK_IMPORTED_MODULE_0__(decorator.name),\n            value: decorator.name\n          })) ?? [],\n          annotations: definition?.annotations?.map((annotation) => ({\n            name: annotation.name,\n            type: \"object\",\n            title: annotation.title,\n            fields: annotation.fields?.map((field) => ({\n              name: field.name,\n              title: field.title ?? lodash_startcase__WEBPACK_IMPORTED_MODULE_0__(field.name),\n              type: field.type\n            })) ?? []\n          })) ?? []\n        },\n        lists: definition?.lists?.map((list) => ({\n          value: list.name,\n          title: list.title ?? lodash_startcase__WEBPACK_IMPORTED_MODULE_0__(list.name)\n        })) ?? [],\n        styles: definition?.styles?.map((style) => ({\n          value: style.name,\n          title: style.title ?? lodash_startcase__WEBPACK_IMPORTED_MODULE_0__(style.name)\n        })) ?? []\n      }\n    ]\n  }), schema = _sanity_schema__WEBPACK_IMPORTED_MODULE_1__.Schema.compile({\n    types: [portableTextSchema, ...blockObjects, ...inlineObjects]\n  }).get(\"portable-text\"), pteSchema = createPortableTextMemberSchemaTypes(schema);\n  return {\n    ...pteSchema,\n    portableText: {\n      ...pteSchema.portableText,\n      of: pteSchema.portableText.of.map((schemaType) => {\n        if (!(0,_sanity_types__WEBPACK_IMPORTED_MODULE_4__.isObjectSchemaType)(schemaType))\n          return schemaType;\n        const nameMapping = blockObjectNames[schemaType.name];\n        schemaType.name = nameMapping ?? schemaType.name;\n        for (const field of schemaType.fields)\n          if (!(field.name !== \"children\" || !(0,_sanity_types__WEBPACK_IMPORTED_MODULE_4__.isArraySchemaType)(field.type)))\n            for (const ofSchemaType of field.type.of) {\n              const nameMapping2 = inlineObjectNames[ofSchemaType.name];\n              nameMapping2 && (ofSchemaType.name = nameMapping2);\n            }\n        return schemaType;\n      })\n    },\n    blockObjects: pteSchema.blockObjects.map(\n      (blockObject) => blockObjectNames[blockObject.name] !== void 0 ? {\n        ...blockObject,\n        name: blockObjectNames[blockObject.name],\n        type: {\n          ...blockObject.type,\n          name: blockObjectNames[blockObject.name]\n        }\n      } : blockObject\n    ),\n    inlineObjects: pteSchema.inlineObjects.map(\n      (inlineObject) => inlineObjectNames[inlineObject.name] !== void 0 ? {\n        ...inlineObject,\n        name: inlineObjectNames[inlineObject.name]\n      } : inlineObject\n    )\n  };\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvc2FuaXR5LWJyaWRnZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF3QztBQUNnQjtBQUN1QztBQUN0RDtBQUNXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGlDQUFpQztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxrREFBTTtBQUNmO0FBQ0Esd0JBQXdCLGlFQUFZO0FBQ3BDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsU0FBUyxpRUFBZTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGVBQWUsOENBQThDLGVBQWUsK0NBQStDLGVBQWUsK0NBQStDLGVBQWU7QUFDclA7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlEQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkNBQVM7QUFDdkMsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLHNCQUFzQix5REFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDZDQUFTO0FBQ3ZDLE9BQU87QUFDUCxLQUFLO0FBQ0wsZ0NBQWdDLDBEQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3QkFBd0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHlCQUF5QjtBQUM1RTtBQUNBO0FBQ0Esc0NBQXNDLDZDQUFTO0FBQy9DO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw2Q0FBUztBQUM3QztBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSwrQkFBK0IsNkNBQVM7QUFDeEMsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQ0FBZ0MsNkNBQVM7QUFDekMsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHLFlBQVksa0RBQU07QUFDckI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUVBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGdFQUFpQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBTUU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL0dhbG9jay9DUy9iZWhvbWUtc2l0ZS9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9zYW5pdHktYnJpZGdlL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2NoZW1hIH0gZnJvbSBcIkBzYW5pdHkvc2NoZW1hXCI7XG5pbXBvcnQgeyBidWlsdGluVHlwZXMgfSBmcm9tIFwiQHNhbml0eS9zY2hlbWEvX2ludGVybmFsXCI7XG5pbXBvcnQgeyBkZWZpbmVUeXBlLCBkZWZpbmVGaWVsZCwgaXNPYmplY3RTY2hlbWFUeXBlLCBpc0FycmF5U2NoZW1hVHlwZSB9IGZyb20gXCJAc2FuaXR5L3R5cGVzXCI7XG5pbXBvcnQgc3RhcnRDYXNlIGZyb20gXCJsb2Rhc2guc3RhcnRjYXNlXCI7XG5pbXBvcnQgZ2V0UmFuZG9tVmFsdWVzIGZyb20gXCJnZXQtcmFuZG9tLXZhbHVlcy1lc21cIjtcbmZ1bmN0aW9uIGNyZWF0ZVBvcnRhYmxlVGV4dE1lbWJlclNjaGVtYVR5cGVzKHBvcnRhYmxlVGV4dFR5cGUpIHtcbiAgaWYgKCFwb3J0YWJsZVRleHRUeXBlKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciAncG9ydGFibGV0ZXh0VHlwZScgbWlzc2luZyAocmVxdWlyZWQpXCIpO1xuICBjb25zdCBibG9ja1R5cGUgPSBwb3J0YWJsZVRleHRUeXBlLm9mPy5maW5kKGZpbmRCbG9ja1R5cGUpO1xuICBpZiAoIWJsb2NrVHlwZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCbG9jayB0eXBlIGlzIG5vdCBkZWZpbmVkIGluIHRoaXMgc2NoZW1hIChyZXF1aXJlZClcIik7XG4gIGNvbnN0IGNoaWxkcmVuRmllbGQgPSBibG9ja1R5cGUuZmllbGRzPy5maW5kKFxuICAgIChmaWVsZCkgPT4gZmllbGQubmFtZSA9PT0gXCJjaGlsZHJlblwiXG4gICk7XG4gIGlmICghY2hpbGRyZW5GaWVsZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZHJlbiBmaWVsZCBmb3IgYmxvY2sgdHlwZSBmb3VuZCBpbiBzY2hlbWEgKHJlcXVpcmVkKVwiKTtcbiAgY29uc3Qgb2ZUeXBlID0gY2hpbGRyZW5GaWVsZC50eXBlLm9mO1xuICBpZiAoIW9mVHlwZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlZhbGlkIHR5cGVzIGZvciBibG9jayBjaGlsZHJlbiBub3QgZm91bmQgaW4gc2NoZW1hIChyZXF1aXJlZClcIlxuICAgICk7XG4gIGNvbnN0IHNwYW5UeXBlID0gb2ZUeXBlLmZpbmQoKG1lbWJlclR5cGUpID0+IG1lbWJlclR5cGUubmFtZSA9PT0gXCJzcGFuXCIpO1xuICBpZiAoIXNwYW5UeXBlKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlNwYW4gdHlwZSBub3QgZm91bmQgaW4gc2NoZW1hIChyZXF1aXJlZClcIik7XG4gIGNvbnN0IGlubGluZU9iamVjdFR5cGVzID0gb2ZUeXBlLmZpbHRlcihcbiAgICAobWVtYmVyVHlwZSkgPT4gbWVtYmVyVHlwZS5uYW1lICE9PSBcInNwYW5cIlxuICApIHx8IFtdLCBibG9ja09iamVjdFR5cGVzID0gcG9ydGFibGVUZXh0VHlwZS5vZj8uZmlsdGVyKFxuICAgIChmaWVsZCkgPT4gZmllbGQubmFtZSAhPT0gYmxvY2tUeXBlLm5hbWVcbiAgKSB8fCBbXTtcbiAgcmV0dXJuIHtcbiAgICBzdHlsZXM6IHJlc29sdmVFbmFibGVkU3R5bGVzKGJsb2NrVHlwZSksXG4gICAgZGVjb3JhdG9yczogcmVzb2x2ZUVuYWJsZWREZWNvcmF0b3JzKHNwYW5UeXBlKSxcbiAgICBsaXN0czogcmVzb2x2ZUVuYWJsZWRMaXN0SXRlbXMoYmxvY2tUeXBlKSxcbiAgICBibG9jazogYmxvY2tUeXBlLFxuICAgIHNwYW46IHNwYW5UeXBlLFxuICAgIHBvcnRhYmxlVGV4dDogcG9ydGFibGVUZXh0VHlwZSxcbiAgICBpbmxpbmVPYmplY3RzOiBpbmxpbmVPYmplY3RUeXBlcyxcbiAgICBibG9ja09iamVjdHM6IGJsb2NrT2JqZWN0VHlwZXMsXG4gICAgYW5ub3RhdGlvbnM6IHNwYW5UeXBlLmFubm90YXRpb25zXG4gIH07XG59XG5mdW5jdGlvbiByZXNvbHZlRW5hYmxlZFN0eWxlcyhibG9ja1R5cGUpIHtcbiAgY29uc3Qgc3R5bGVGaWVsZCA9IGJsb2NrVHlwZS5maWVsZHM/LmZpbmQoXG4gICAgKGJ0RmllbGQpID0+IGJ0RmllbGQubmFtZSA9PT0gXCJzdHlsZVwiXG4gICk7XG4gIGlmICghc3R5bGVGaWVsZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkEgZmllbGQgd2l0aCBuYW1lICdzdHlsZScgaXMgbm90IGRlZmluZWQgaW4gdGhlIGJsb2NrIHR5cGUgKHJlcXVpcmVkKS5cIlxuICAgICk7XG4gIGNvbnN0IHRleHRTdHlsZXMgPSBzdHlsZUZpZWxkLnR5cGUub3B0aW9ucz8ubGlzdCAmJiBzdHlsZUZpZWxkLnR5cGUub3B0aW9ucy5saXN0Py5maWx0ZXIoXG4gICAgKHN0eWxlKSA9PiBzdHlsZS52YWx1ZVxuICApO1xuICBpZiAoIXRleHRTdHlsZXMgfHwgdGV4dFN0eWxlcy5sZW5ndGggPT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJUaGUgc3R5bGUgZmllbGRzIG5lZWQgYXQgbGVhc3Qgb25lIHN0eWxlIGRlZmluZWQuIEkuZToge3RpdGxlOiAnTm9ybWFsJywgdmFsdWU6ICdub3JtYWwnfS5cIlxuICAgICk7XG4gIHJldHVybiB0ZXh0U3R5bGVzO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUVuYWJsZWREZWNvcmF0b3JzKHNwYW5UeXBlKSB7XG4gIHJldHVybiBzcGFuVHlwZS5kZWNvcmF0b3JzO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUVuYWJsZWRMaXN0SXRlbXMoYmxvY2tUeXBlKSB7XG4gIGNvbnN0IGxpc3RGaWVsZCA9IGJsb2NrVHlwZS5maWVsZHM/LmZpbmQoXG4gICAgKGJ0RmllbGQpID0+IGJ0RmllbGQubmFtZSA9PT0gXCJsaXN0SXRlbVwiXG4gICk7XG4gIGlmICghbGlzdEZpZWxkKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiQSBmaWVsZCB3aXRoIG5hbWUgJ2xpc3RJdGVtJyBpcyBub3QgZGVmaW5lZCBpbiB0aGUgYmxvY2sgdHlwZSAocmVxdWlyZWQpLlwiXG4gICAgKTtcbiAgY29uc3QgbGlzdEl0ZW1zID0gbGlzdEZpZWxkLnR5cGUub3B0aW9ucz8ubGlzdCAmJiBsaXN0RmllbGQudHlwZS5vcHRpb25zLmxpc3QuZmlsdGVyKChsaXN0KSA9PiBsaXN0LnZhbHVlKTtcbiAgaWYgKCFsaXN0SXRlbXMpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGxpc3QgZmllbGQgbmVlZCBhdCBsZWFzdCB0byBiZSBhbiBlbXB0eSBhcnJheVwiKTtcbiAgcmV0dXJuIGxpc3RJdGVtcztcbn1cbmZ1bmN0aW9uIGZpbmRCbG9ja1R5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZS50eXBlID8gZmluZEJsb2NrVHlwZSh0eXBlLnR5cGUpIDogdHlwZS5uYW1lID09PSBcImJsb2NrXCIgPyB0eXBlIDogbnVsbDtcbn1cbmZ1bmN0aW9uIHBvcnRhYmxlVGV4dE1lbWJlclNjaGVtYVR5cGVzVG9TY2hlbWEoc2NoZW1hKSB7XG4gIHJldHVybiB7XG4gICAgYW5ub3RhdGlvbnM6IHNjaGVtYS5hbm5vdGF0aW9ucy5tYXAoKGFubm90YXRpb24pID0+ICh7XG4gICAgICBuYW1lOiBhbm5vdGF0aW9uLm5hbWUsXG4gICAgICBmaWVsZHM6IGFubm90YXRpb24uZmllbGRzLm1hcCgoZmllbGQpID0+ICh7XG4gICAgICAgIG5hbWU6IGZpZWxkLm5hbWUsXG4gICAgICAgIHR5cGU6IGZpZWxkLnR5cGUuanNvblR5cGUsXG4gICAgICAgIHRpdGxlOiBmaWVsZC50eXBlLnRpdGxlXG4gICAgICB9KSksXG4gICAgICB0aXRsZTogYW5ub3RhdGlvbi50aXRsZVxuICAgIH0pKSxcbiAgICBibG9jazoge1xuICAgICAgbmFtZTogc2NoZW1hLmJsb2NrLm5hbWVcbiAgICB9LFxuICAgIGJsb2NrT2JqZWN0czogc2NoZW1hLmJsb2NrT2JqZWN0cy5tYXAoKGJsb2NrT2JqZWN0KSA9PiAoe1xuICAgICAgbmFtZTogYmxvY2tPYmplY3QubmFtZSxcbiAgICAgIGZpZWxkczogYmxvY2tPYmplY3QuZmllbGRzLm1hcCgoZmllbGQpID0+ICh7XG4gICAgICAgIG5hbWU6IGZpZWxkLm5hbWUsXG4gICAgICAgIHR5cGU6IGZpZWxkLnR5cGUuanNvblR5cGUsXG4gICAgICAgIHRpdGxlOiBmaWVsZC50eXBlLnRpdGxlXG4gICAgICB9KSksXG4gICAgICB0aXRsZTogYmxvY2tPYmplY3QudGl0bGVcbiAgICB9KSksXG4gICAgZGVjb3JhdG9yczogc2NoZW1hLmRlY29yYXRvcnMubWFwKChkZWNvcmF0b3IpID0+ICh7XG4gICAgICBuYW1lOiBkZWNvcmF0b3IudmFsdWUsXG4gICAgICB0aXRsZTogZGVjb3JhdG9yLnRpdGxlLFxuICAgICAgdmFsdWU6IGRlY29yYXRvci52YWx1ZVxuICAgIH0pKSxcbiAgICBpbmxpbmVPYmplY3RzOiBzY2hlbWEuaW5saW5lT2JqZWN0cy5tYXAoKGlubGluZU9iamVjdCkgPT4gKHtcbiAgICAgIG5hbWU6IGlubGluZU9iamVjdC5uYW1lLFxuICAgICAgZmllbGRzOiBpbmxpbmVPYmplY3QuZmllbGRzLm1hcCgoZmllbGQpID0+ICh7XG4gICAgICAgIG5hbWU6IGZpZWxkLm5hbWUsXG4gICAgICAgIHR5cGU6IGZpZWxkLnR5cGUuanNvblR5cGUsXG4gICAgICAgIHRpdGxlOiBmaWVsZC50eXBlLnRpdGxlXG4gICAgICB9KSksXG4gICAgICB0aXRsZTogaW5saW5lT2JqZWN0LnRpdGxlXG4gICAgfSkpLFxuICAgIHNwYW46IHtcbiAgICAgIG5hbWU6IHNjaGVtYS5zcGFuLm5hbWVcbiAgICB9LFxuICAgIHN0eWxlczogc2NoZW1hLnN0eWxlcy5tYXAoKHN0eWxlKSA9PiAoe1xuICAgICAgbmFtZTogc3R5bGUudmFsdWUsXG4gICAgICB0aXRsZTogc3R5bGUudGl0bGUsXG4gICAgICB2YWx1ZTogc3R5bGUudmFsdWVcbiAgICB9KSksXG4gICAgbGlzdHM6IHNjaGVtYS5saXN0cy5tYXAoKGxpc3QpID0+ICh7XG4gICAgICBuYW1lOiBsaXN0LnZhbHVlLFxuICAgICAgdGl0bGU6IGxpc3QudGl0bGUsXG4gICAgICB2YWx1ZTogbGlzdC52YWx1ZVxuICAgIH0pKVxuICB9O1xufVxuZnVuY3Rpb24gc2FuaXR5U2NoZW1hVG9Qb3J0YWJsZVRleHRTY2hlbWEoc2FuaXR5U2NoZW1hKSB7XG4gIGNvbnN0IHBvcnRhYmxlVGV4dE1lbWJlclNjaGVtYVR5cGVzID0gY3JlYXRlUG9ydGFibGVUZXh0TWVtYmVyU2NoZW1hVHlwZXMoXG4gICAgc2FuaXR5U2NoZW1hLmhhc093blByb3BlcnR5KFwianNvblR5cGVcIikgPyBzYW5pdHlTY2hlbWEgOiBjb21waWxlVHlwZShzYW5pdHlTY2hlbWEpXG4gICk7XG4gIHJldHVybiBwb3J0YWJsZVRleHRNZW1iZXJTY2hlbWFUeXBlc1RvU2NoZW1hKHBvcnRhYmxlVGV4dE1lbWJlclNjaGVtYVR5cGVzKTtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVUeXBlKHJhd1R5cGUpIHtcbiAgcmV0dXJuIFNjaGVtYS5jb21waWxlKHtcbiAgICBuYW1lOiBcImJsb2NrVHlwZVNjaGVtYVwiLFxuICAgIHR5cGVzOiBbcmF3VHlwZSwgLi4uYnVpbHRpblR5cGVzXVxuICB9KS5nZXQocmF3VHlwZS5uYW1lKTtcbn1cbmNvbnN0IGtleUdlbmVyYXRvciA9ICgpID0+IHJhbmRvbUtleSgxMiksIGdldEJ5dGVIZXhUYWJsZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICBsZXQgdGFibGU7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaWYgKHRhYmxlKVxuICAgICAgcmV0dXJuIHRhYmxlO1xuICAgIHRhYmxlID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7ICsraSlcbiAgICAgIHRhYmxlW2ldID0gKGkgKyAyNTYpLnRvU3RyaW5nKDE2KS5zbGljZSgxKTtcbiAgICByZXR1cm4gdGFibGU7XG4gIH07XG59KSgpO1xuZnVuY3Rpb24gd2hhdHdnUk5HKGxlbmd0aCA9IDE2KSB7XG4gIGNvbnN0IHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgcmV0dXJuIGdldFJhbmRvbVZhbHVlcyhybmRzOCksIHJuZHM4O1xufVxuZnVuY3Rpb24gcmFuZG9tS2V5KGxlbmd0aCkge1xuICBjb25zdCB0YWJsZSA9IGdldEJ5dGVIZXhUYWJsZSgpO1xuICByZXR1cm4gd2hhdHdnUk5HKGxlbmd0aCkucmVkdWNlKChzdHIsIG4pID0+IHN0ciArIHRhYmxlW25dLCBcIlwiKS5zbGljZSgwLCBsZW5ndGgpO1xufVxuY29uc3QgdGVtcG9yYXJ5SW1hZ2VCbG9ja09iamVjdE5hbWUgPSBgdG1wLSR7a2V5R2VuZXJhdG9yKCl9LWltYWdlYCwgdGVtcG9yYXJ5VXJsQmxvY2tPYmplY3ROYW1lID0gYHRtcC0ke2tleUdlbmVyYXRvcigpfS11cmxgLCB0ZW1wb3JhcnlJbWFnZUlubGluZU9iamVjdE5hbWUgPSBgdG1wLSR7a2V5R2VuZXJhdG9yKCl9LWltYWdlYCwgdGVtcG9yYXJ5VXJsSW5saW5lT2JqZWN0TmFtZSA9IGB0bXAtJHtrZXlHZW5lcmF0b3IoKX0tdXJsYCwgdGVtcG9yYXJ5QmxvY2tPYmplY3ROYW1lcyA9IHtcbiAgaW1hZ2U6IHRlbXBvcmFyeUltYWdlQmxvY2tPYmplY3ROYW1lLFxuICB1cmw6IHRlbXBvcmFyeVVybEJsb2NrT2JqZWN0TmFtZVxufSwgdGVtcG9yYXJ5SW5saW5lT2JqZWN0TmFtZXMgPSB7XG4gIGltYWdlOiB0ZW1wb3JhcnlJbWFnZUlubGluZU9iamVjdE5hbWUsXG4gIHVybDogdGVtcG9yYXJ5VXJsSW5saW5lT2JqZWN0TmFtZVxufSwgYmxvY2tPYmplY3ROYW1lcyA9IHtcbiAgW3RlbXBvcmFyeUltYWdlQmxvY2tPYmplY3ROYW1lXTogXCJpbWFnZVwiLFxuICBbdGVtcG9yYXJ5VXJsQmxvY2tPYmplY3ROYW1lXTogXCJ1cmxcIlxufSwgaW5saW5lT2JqZWN0TmFtZXMgPSB7XG4gIFt0ZW1wb3JhcnlJbWFnZUlubGluZU9iamVjdE5hbWVdOiBcImltYWdlXCIsXG4gIFt0ZW1wb3JhcnlVcmxJbmxpbmVPYmplY3ROYW1lXTogXCJ1cmxcIlxufSwgZGVmYXVsdE9iamVjdFRpdGxlcyA9IHtcbiAgaW1hZ2U6IFwiSW1hZ2VcIixcbiAgdXJsOiBcIlVSTFwiXG59O1xuZnVuY3Rpb24gY29tcGlsZVNjaGVtYURlZmluaXRpb25Ub1BvcnRhYmxlVGV4dE1lbWJlclNjaGVtYVR5cGVzKGRlZmluaXRpb24pIHtcbiAgY29uc3QgYmxvY2tPYmplY3RzID0gZGVmaW5pdGlvbj8uYmxvY2tPYmplY3RzPy5tYXAoXG4gICAgKGJsb2NrT2JqZWN0KSA9PiBkZWZpbmVUeXBlKHtcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAvLyBWZXJ5IG5haXZlIHdheSB0byB3b3JrIGFyb3VuZCBgU2FuaXR5U2NoZW1hLmNvbXBpbGVgIGFkZGluZyBkZWZhdWx0XG4gICAgICAvLyBmaWVsZHMgdG8gb2JqZWN0cyB3aXRoIGNlcnRhaW4gbmFtZXMuXG4gICAgICBuYW1lOiB0ZW1wb3JhcnlCbG9ja09iamVjdE5hbWVzW2Jsb2NrT2JqZWN0Lm5hbWVdID8/IGJsb2NrT2JqZWN0Lm5hbWUsXG4gICAgICB0aXRsZTogYmxvY2tPYmplY3QudGl0bGUgPT09IHZvaWQgMCA/IChcbiAgICAgICAgLy8gVGhpcyBhdm9pZHMgdGhlIGRlZmF1bHQgdGl0bGUgd2hpY2ggaXMgYSB0aXRsZSBjYXNlIG9mIHRoZSBvYmplY3QgbmFtZVxuICAgICAgICBkZWZhdWx0T2JqZWN0VGl0bGVzW2Jsb2NrT2JqZWN0Lm5hbWVdXG4gICAgICApIDogYmxvY2tPYmplY3QudGl0bGUsXG4gICAgICBmaWVsZHM6IGJsb2NrT2JqZWN0LmZpZWxkcz8ubWFwKChmaWVsZCkgPT4gKHtcbiAgICAgICAgbmFtZTogZmllbGQubmFtZSxcbiAgICAgICAgdHlwZTogZmllbGQudHlwZSxcbiAgICAgICAgdGl0bGU6IGZpZWxkLnRpdGxlID8/IHN0YXJ0Q2FzZShmaWVsZC5uYW1lKVxuICAgICAgfSkpID8/IFtdXG4gICAgfSlcbiAgKSA/PyBbXSwgaW5saW5lT2JqZWN0cyA9IGRlZmluaXRpb24/LmlubGluZU9iamVjdHM/Lm1hcChcbiAgICAoaW5saW5lT2JqZWN0KSA9PiBkZWZpbmVUeXBlKHtcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAvLyBWZXJ5IG5haXZlIHdheSB0byB3b3JrIGFyb3VuZCBgU2FuaXR5U2NoZW1hLmNvbXBpbGVgIGFkZGluZyBkZWZhdWx0XG4gICAgICAvLyBmaWVsZHMgdG8gb2JqZWN0cyB3aXRoIGNlcnRhaW4gbmFtZXMuXG4gICAgICBuYW1lOiB0ZW1wb3JhcnlJbmxpbmVPYmplY3ROYW1lc1tpbmxpbmVPYmplY3QubmFtZV0gPz8gaW5saW5lT2JqZWN0Lm5hbWUsXG4gICAgICB0aXRsZTogaW5saW5lT2JqZWN0LnRpdGxlID09PSB2b2lkIDAgPyAoXG4gICAgICAgIC8vIFRoaXMgYXZvaWRzIHRoZSBkZWZhdWx0IHRpdGxlIHdoaWNoIGlzIGEgdGl0bGUgY2FzZSBvZiB0aGUgb2JqZWN0IG5hbWVcbiAgICAgICAgZGVmYXVsdE9iamVjdFRpdGxlc1tpbmxpbmVPYmplY3QubmFtZV1cbiAgICAgICkgOiBpbmxpbmVPYmplY3QudGl0bGUsXG4gICAgICBmaWVsZHM6IGlubGluZU9iamVjdC5maWVsZHM/Lm1hcCgoZmllbGQpID0+ICh7XG4gICAgICAgIG5hbWU6IGZpZWxkLm5hbWUsXG4gICAgICAgIHR5cGU6IGZpZWxkLnR5cGUsXG4gICAgICAgIHRpdGxlOiBmaWVsZC50aXRsZSA/PyBzdGFydENhc2UoZmllbGQubmFtZSlcbiAgICAgIH0pKSA/PyBbXVxuICAgIH0pXG4gICkgPz8gW10sIHBvcnRhYmxlVGV4dFNjaGVtYSA9IGRlZmluZUZpZWxkKHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgbmFtZTogXCJwb3J0YWJsZS10ZXh0XCIsXG4gICAgb2Y6IFtcbiAgICAgIC4uLmJsb2NrT2JqZWN0cy5tYXAoKGJsb2NrT2JqZWN0KSA9PiAoeyB0eXBlOiBibG9ja09iamVjdC5uYW1lIH0pKSxcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJibG9ja1wiLFxuICAgICAgICBuYW1lOiBcImJsb2NrXCIsXG4gICAgICAgIG9mOiBpbmxpbmVPYmplY3RzLm1hcCgoaW5saW5lT2JqZWN0KSA9PiAoeyB0eXBlOiBpbmxpbmVPYmplY3QubmFtZSB9KSksXG4gICAgICAgIG1hcmtzOiB7XG4gICAgICAgICAgZGVjb3JhdG9yczogZGVmaW5pdGlvbj8uZGVjb3JhdG9ycz8ubWFwKChkZWNvcmF0b3IpID0+ICh7XG4gICAgICAgICAgICB0aXRsZTogZGVjb3JhdG9yLnRpdGxlID8/IHN0YXJ0Q2FzZShkZWNvcmF0b3IubmFtZSksXG4gICAgICAgICAgICB2YWx1ZTogZGVjb3JhdG9yLm5hbWVcbiAgICAgICAgICB9KSkgPz8gW10sXG4gICAgICAgICAgYW5ub3RhdGlvbnM6IGRlZmluaXRpb24/LmFubm90YXRpb25zPy5tYXAoKGFubm90YXRpb24pID0+ICh7XG4gICAgICAgICAgICBuYW1lOiBhbm5vdGF0aW9uLm5hbWUsXG4gICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgdGl0bGU6IGFubm90YXRpb24udGl0bGUsXG4gICAgICAgICAgICBmaWVsZHM6IGFubm90YXRpb24uZmllbGRzPy5tYXAoKGZpZWxkKSA9PiAoe1xuICAgICAgICAgICAgICBuYW1lOiBmaWVsZC5uYW1lLFxuICAgICAgICAgICAgICB0aXRsZTogZmllbGQudGl0bGUgPz8gc3RhcnRDYXNlKGZpZWxkLm5hbWUpLFxuICAgICAgICAgICAgICB0eXBlOiBmaWVsZC50eXBlXG4gICAgICAgICAgICB9KSkgPz8gW11cbiAgICAgICAgICB9KSkgPz8gW11cbiAgICAgICAgfSxcbiAgICAgICAgbGlzdHM6IGRlZmluaXRpb24/Lmxpc3RzPy5tYXAoKGxpc3QpID0+ICh7XG4gICAgICAgICAgdmFsdWU6IGxpc3QubmFtZSxcbiAgICAgICAgICB0aXRsZTogbGlzdC50aXRsZSA/PyBzdGFydENhc2UobGlzdC5uYW1lKVxuICAgICAgICB9KSkgPz8gW10sXG4gICAgICAgIHN0eWxlczogZGVmaW5pdGlvbj8uc3R5bGVzPy5tYXAoKHN0eWxlKSA9PiAoe1xuICAgICAgICAgIHZhbHVlOiBzdHlsZS5uYW1lLFxuICAgICAgICAgIHRpdGxlOiBzdHlsZS50aXRsZSA/PyBzdGFydENhc2Uoc3R5bGUubmFtZSlcbiAgICAgICAgfSkpID8/IFtdXG4gICAgICB9XG4gICAgXVxuICB9KSwgc2NoZW1hID0gU2NoZW1hLmNvbXBpbGUoe1xuICAgIHR5cGVzOiBbcG9ydGFibGVUZXh0U2NoZW1hLCAuLi5ibG9ja09iamVjdHMsIC4uLmlubGluZU9iamVjdHNdXG4gIH0pLmdldChcInBvcnRhYmxlLXRleHRcIiksIHB0ZVNjaGVtYSA9IGNyZWF0ZVBvcnRhYmxlVGV4dE1lbWJlclNjaGVtYVR5cGVzKHNjaGVtYSk7XG4gIHJldHVybiB7XG4gICAgLi4ucHRlU2NoZW1hLFxuICAgIHBvcnRhYmxlVGV4dDoge1xuICAgICAgLi4ucHRlU2NoZW1hLnBvcnRhYmxlVGV4dCxcbiAgICAgIG9mOiBwdGVTY2hlbWEucG9ydGFibGVUZXh0Lm9mLm1hcCgoc2NoZW1hVHlwZSkgPT4ge1xuICAgICAgICBpZiAoIWlzT2JqZWN0U2NoZW1hVHlwZShzY2hlbWFUeXBlKSlcbiAgICAgICAgICByZXR1cm4gc2NoZW1hVHlwZTtcbiAgICAgICAgY29uc3QgbmFtZU1hcHBpbmcgPSBibG9ja09iamVjdE5hbWVzW3NjaGVtYVR5cGUubmFtZV07XG4gICAgICAgIHNjaGVtYVR5cGUubmFtZSA9IG5hbWVNYXBwaW5nID8/IHNjaGVtYVR5cGUubmFtZTtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBzY2hlbWFUeXBlLmZpZWxkcylcbiAgICAgICAgICBpZiAoIShmaWVsZC5uYW1lICE9PSBcImNoaWxkcmVuXCIgfHwgIWlzQXJyYXlTY2hlbWFUeXBlKGZpZWxkLnR5cGUpKSlcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb2ZTY2hlbWFUeXBlIG9mIGZpZWxkLnR5cGUub2YpIHtcbiAgICAgICAgICAgICAgY29uc3QgbmFtZU1hcHBpbmcyID0gaW5saW5lT2JqZWN0TmFtZXNbb2ZTY2hlbWFUeXBlLm5hbWVdO1xuICAgICAgICAgICAgICBuYW1lTWFwcGluZzIgJiYgKG9mU2NoZW1hVHlwZS5uYW1lID0gbmFtZU1hcHBpbmcyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjaGVtYVR5cGU7XG4gICAgICB9KVxuICAgIH0sXG4gICAgYmxvY2tPYmplY3RzOiBwdGVTY2hlbWEuYmxvY2tPYmplY3RzLm1hcChcbiAgICAgIChibG9ja09iamVjdCkgPT4gYmxvY2tPYmplY3ROYW1lc1tibG9ja09iamVjdC5uYW1lXSAhPT0gdm9pZCAwID8ge1xuICAgICAgICAuLi5ibG9ja09iamVjdCxcbiAgICAgICAgbmFtZTogYmxvY2tPYmplY3ROYW1lc1tibG9ja09iamVjdC5uYW1lXSxcbiAgICAgICAgdHlwZToge1xuICAgICAgICAgIC4uLmJsb2NrT2JqZWN0LnR5cGUsXG4gICAgICAgICAgbmFtZTogYmxvY2tPYmplY3ROYW1lc1tibG9ja09iamVjdC5uYW1lXVxuICAgICAgICB9XG4gICAgICB9IDogYmxvY2tPYmplY3RcbiAgICApLFxuICAgIGlubGluZU9iamVjdHM6IHB0ZVNjaGVtYS5pbmxpbmVPYmplY3RzLm1hcChcbiAgICAgIChpbmxpbmVPYmplY3QpID0+IGlubGluZU9iamVjdE5hbWVzW2lubGluZU9iamVjdC5uYW1lXSAhPT0gdm9pZCAwID8ge1xuICAgICAgICAuLi5pbmxpbmVPYmplY3QsXG4gICAgICAgIG5hbWU6IGlubGluZU9iamVjdE5hbWVzW2lubGluZU9iamVjdC5uYW1lXVxuICAgICAgfSA6IGlubGluZU9iamVjdFxuICAgIClcbiAgfTtcbn1cbmV4cG9ydCB7XG4gIGNvbXBpbGVTY2hlbWFEZWZpbml0aW9uVG9Qb3J0YWJsZVRleHRNZW1iZXJTY2hlbWFUeXBlcyxcbiAgY3JlYXRlUG9ydGFibGVUZXh0TWVtYmVyU2NoZW1hVHlwZXMsXG4gIHBvcnRhYmxlVGV4dE1lbWJlclNjaGVtYVR5cGVzVG9TY2hlbWEsXG4gIHNhbml0eVNjaGVtYVRvUG9ydGFibGVUZXh0U2NoZW1hXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@portabletext/sanity-bridge/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@portabletext/schema/dist/index.js":
/*!**********************************************************!*\
  !*** ../node_modules/@portabletext/schema/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compileSchema: () => (/* binding */ compileSchema),\n/* harmony export */   defineSchema: () => (/* binding */ defineSchema),\n/* harmony export */   isSpan: () => (/* binding */ isSpan),\n/* harmony export */   isTextBlock: () => (/* binding */ isTextBlock),\n/* harmony export */   isTypedObject: () => (/* binding */ isTypedObject)\n/* harmony export */ });\nfunction compileSchema(definition) {\n  const styles = (definition.styles ?? []).map((style) => ({\n    ...style,\n    value: style.name\n  })), blockFields = [];\n  if (definition.block?.fields)\n    for (const field of definition.block.fields) {\n      if (field.name === \"_type\" || field.name === \"_key\" || field.name === \"children\" || field.name === \"markDefs\" || field.name === \"style\" || field.name === \"listItem\" || field.name === \"level\") {\n        console.warn(\n          `\"${field.name}\" is a reserved field name on Portable Text blocks`\n        );\n        continue;\n      }\n      blockFields.push(field);\n    }\n  return {\n    block: {\n      name: definition.block?.name ?? \"block\",\n      ...blockFields.length > 0 ? { fields: blockFields } : {}\n    },\n    span: {\n      name: \"span\"\n    },\n    styles: styles.some((style) => style.value === \"normal\") ? styles : [{ value: \"normal\", name: \"normal\", title: \"Normal\" }, ...styles],\n    lists: (definition.lists ?? []).map((list) => ({\n      ...list,\n      value: list.name\n    })),\n    decorators: (definition.decorators ?? []).map((decorator) => ({\n      ...decorator,\n      value: decorator.name\n    })),\n    annotations: (definition.annotations ?? []).map((annotation) => ({\n      ...annotation,\n      fields: annotation.fields ?? []\n    })),\n    blockObjects: (definition.blockObjects ?? []).map((blockObject) => ({\n      ...blockObject,\n      fields: blockObject.fields ?? []\n    })),\n    inlineObjects: (definition.inlineObjects ?? []).map((inlineObject) => ({\n      ...inlineObject,\n      fields: inlineObject.fields ?? []\n    }))\n  };\n}\nfunction defineSchema(definition) {\n  return definition;\n}\nfunction isTypedObject(object) {\n  return isRecord(object) && typeof object._type == \"string\";\n}\nfunction isRecord(value) {\n  return !!value && (typeof value == \"object\" || typeof value == \"function\");\n}\nfunction isTextBlock(context, block) {\n  return !(!isTypedObject(block) || block._type !== context.schema.block.name || !Array.isArray(block.children));\n}\nfunction isSpan(context, child) {\n  return !(!isTypedObject(child) || child._type !== context.schema.span.name || typeof child.text != \"string\");\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvc2NoZW1hL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHNCQUFzQjtBQUMxRCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCwyRUFBMkUsa0RBQWtEO0FBQzdIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9FO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9HYWxvY2svQ1MvYmVob21lLXNpdGUvbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvc2NoZW1hL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gY29tcGlsZVNjaGVtYShkZWZpbml0aW9uKSB7XG4gIGNvbnN0IHN0eWxlcyA9IChkZWZpbml0aW9uLnN0eWxlcyA/PyBbXSkubWFwKChzdHlsZSkgPT4gKHtcbiAgICAuLi5zdHlsZSxcbiAgICB2YWx1ZTogc3R5bGUubmFtZVxuICB9KSksIGJsb2NrRmllbGRzID0gW107XG4gIGlmIChkZWZpbml0aW9uLmJsb2NrPy5maWVsZHMpXG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBkZWZpbml0aW9uLmJsb2NrLmZpZWxkcykge1xuICAgICAgaWYgKGZpZWxkLm5hbWUgPT09IFwiX3R5cGVcIiB8fCBmaWVsZC5uYW1lID09PSBcIl9rZXlcIiB8fCBmaWVsZC5uYW1lID09PSBcImNoaWxkcmVuXCIgfHwgZmllbGQubmFtZSA9PT0gXCJtYXJrRGVmc1wiIHx8IGZpZWxkLm5hbWUgPT09IFwic3R5bGVcIiB8fCBmaWVsZC5uYW1lID09PSBcImxpc3RJdGVtXCIgfHwgZmllbGQubmFtZSA9PT0gXCJsZXZlbFwiKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgXCIke2ZpZWxkLm5hbWV9XCIgaXMgYSByZXNlcnZlZCBmaWVsZCBuYW1lIG9uIFBvcnRhYmxlIFRleHQgYmxvY2tzYFxuICAgICAgICApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJsb2NrRmllbGRzLnB1c2goZmllbGQpO1xuICAgIH1cbiAgcmV0dXJuIHtcbiAgICBibG9jazoge1xuICAgICAgbmFtZTogZGVmaW5pdGlvbi5ibG9jaz8ubmFtZSA/PyBcImJsb2NrXCIsXG4gICAgICAuLi5ibG9ja0ZpZWxkcy5sZW5ndGggPiAwID8geyBmaWVsZHM6IGJsb2NrRmllbGRzIH0gOiB7fVxuICAgIH0sXG4gICAgc3Bhbjoge1xuICAgICAgbmFtZTogXCJzcGFuXCJcbiAgICB9LFxuICAgIHN0eWxlczogc3R5bGVzLnNvbWUoKHN0eWxlKSA9PiBzdHlsZS52YWx1ZSA9PT0gXCJub3JtYWxcIikgPyBzdHlsZXMgOiBbeyB2YWx1ZTogXCJub3JtYWxcIiwgbmFtZTogXCJub3JtYWxcIiwgdGl0bGU6IFwiTm9ybWFsXCIgfSwgLi4uc3R5bGVzXSxcbiAgICBsaXN0czogKGRlZmluaXRpb24ubGlzdHMgPz8gW10pLm1hcCgobGlzdCkgPT4gKHtcbiAgICAgIC4uLmxpc3QsXG4gICAgICB2YWx1ZTogbGlzdC5uYW1lXG4gICAgfSkpLFxuICAgIGRlY29yYXRvcnM6IChkZWZpbml0aW9uLmRlY29yYXRvcnMgPz8gW10pLm1hcCgoZGVjb3JhdG9yKSA9PiAoe1xuICAgICAgLi4uZGVjb3JhdG9yLFxuICAgICAgdmFsdWU6IGRlY29yYXRvci5uYW1lXG4gICAgfSkpLFxuICAgIGFubm90YXRpb25zOiAoZGVmaW5pdGlvbi5hbm5vdGF0aW9ucyA/PyBbXSkubWFwKChhbm5vdGF0aW9uKSA9PiAoe1xuICAgICAgLi4uYW5ub3RhdGlvbixcbiAgICAgIGZpZWxkczogYW5ub3RhdGlvbi5maWVsZHMgPz8gW11cbiAgICB9KSksXG4gICAgYmxvY2tPYmplY3RzOiAoZGVmaW5pdGlvbi5ibG9ja09iamVjdHMgPz8gW10pLm1hcCgoYmxvY2tPYmplY3QpID0+ICh7XG4gICAgICAuLi5ibG9ja09iamVjdCxcbiAgICAgIGZpZWxkczogYmxvY2tPYmplY3QuZmllbGRzID8/IFtdXG4gICAgfSkpLFxuICAgIGlubGluZU9iamVjdHM6IChkZWZpbml0aW9uLmlubGluZU9iamVjdHMgPz8gW10pLm1hcCgoaW5saW5lT2JqZWN0KSA9PiAoe1xuICAgICAgLi4uaW5saW5lT2JqZWN0LFxuICAgICAgZmllbGRzOiBpbmxpbmVPYmplY3QuZmllbGRzID8/IFtdXG4gICAgfSkpXG4gIH07XG59XG5mdW5jdGlvbiBkZWZpbmVTY2hlbWEoZGVmaW5pdGlvbikge1xuICByZXR1cm4gZGVmaW5pdGlvbjtcbn1cbmZ1bmN0aW9uIGlzVHlwZWRPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiBpc1JlY29yZChvYmplY3QpICYmIHR5cGVvZiBvYmplY3QuX3R5cGUgPT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGlzUmVjb3JkKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGlzVGV4dEJsb2NrKGNvbnRleHQsIGJsb2NrKSB7XG4gIHJldHVybiAhKCFpc1R5cGVkT2JqZWN0KGJsb2NrKSB8fCBibG9jay5fdHlwZSAhPT0gY29udGV4dC5zY2hlbWEuYmxvY2submFtZSB8fCAhQXJyYXkuaXNBcnJheShibG9jay5jaGlsZHJlbikpO1xufVxuZnVuY3Rpb24gaXNTcGFuKGNvbnRleHQsIGNoaWxkKSB7XG4gIHJldHVybiAhKCFpc1R5cGVkT2JqZWN0KGNoaWxkKSB8fCBjaGlsZC5fdHlwZSAhPT0gY29udGV4dC5zY2hlbWEuc3Bhbi5uYW1lIHx8IHR5cGVvZiBjaGlsZC50ZXh0ICE9IFwic3RyaW5nXCIpO1xufVxuZXhwb3J0IHtcbiAgY29tcGlsZVNjaGVtYSxcbiAgZGVmaW5lU2NoZW1hLFxuICBpc1NwYW4sXG4gIGlzVGV4dEJsb2NrLFxuICBpc1R5cGVkT2JqZWN0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@portabletext/schema/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@portabletext/to-html/dist/pt-to-html.mjs":
/*!*****************************************************************!*\
  !*** ../node_modules/@portabletext/to-html/dist/pt-to-html.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultComponents: () => (/* binding */ defaultComponents),\n/* harmony export */   escapeHTML: () => (/* binding */ escapeHTML),\n/* harmony export */   mergeComponents: () => (/* binding */ mergeComponents),\n/* harmony export */   toHTML: () => (/* binding */ toHTML),\n/* harmony export */   uriLooksSafe: () => (/* binding */ uriLooksSafe)\n/* harmony export */ });\n/* harmony import */ var _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @portabletext/toolkit */ \"(ssr)/../node_modules/@portabletext/toolkit/dist/index.js\");\n\nconst allowedProtocols = [\"http\", \"https\", \"mailto\", \"tel\"], charMap = {\n  \"&\": \"amp\",\n  \"<\": \"lt\",\n  \">\": \"gt\",\n  '\"': \"quot\",\n  \"'\": \"#x27\"\n};\nfunction escapeHTML(str) {\n  return replaceMultipleSpaces(str.replace(/[&<>\"']/g, (s) => `&${charMap[s]};`));\n}\nfunction replaceMultipleSpaces(str) {\n  return str.replace(/ {2,}/g, (match) => `${\"&nbsp;\".repeat(match.length - 1)} `);\n}\nfunction uriLooksSafe(uri) {\n  const url = (uri || \"\").trim(), first = url.charAt(0);\n  if (first === \"#\" || first === \"/\")\n    return !0;\n  const colonIndex = url.indexOf(\":\");\n  if (colonIndex === -1)\n    return !0;\n  const proto = url.slice(0, colonIndex).toLowerCase();\n  if (allowedProtocols.indexOf(proto) !== -1)\n    return !0;\n  const queryIndex = url.indexOf(\"?\");\n  if (queryIndex !== -1 && colonIndex > queryIndex)\n    return !0;\n  const hashIndex = url.indexOf(\"#\");\n  return hashIndex !== -1 && colonIndex > hashIndex;\n}\nconst defaultLists = {\n  number: ({ children }) => `<ol>${children}</ol>`,\n  bullet: ({ children }) => `<ul>${children}</ul>`\n}, DefaultListItem = ({ children }) => `<li>${children}</li>`, link = ({ children, value }) => {\n  const href = (value == null ? void 0 : value.href) || \"\";\n  return uriLooksSafe(href) ? `<a href=\"${escapeHTML(href)}\">${children}</a>` : children;\n}, defaultMarks = {\n  em: ({ children }) => `<em>${children}</em>`,\n  strong: ({ children }) => `<strong>${children}</strong>`,\n  code: ({ children }) => `<code>${children}</code>`,\n  underline: ({ children }) => `<span style=\"text-decoration:underline\">${children}</span>`,\n  \"strike-through\": ({ children }) => `<del>${children}</del>`,\n  link\n}, getTemplate = (type, prop) => `Unknown ${type}, specify a component for it in the \\`components.${prop}\\` option`, unknownTypeWarning = (typeName) => getTemplate(`block type \"${typeName}\"`, \"types\"), unknownMarkWarning = (markType) => getTemplate(`mark type \"${markType}\"`, \"marks\"), unknownBlockStyleWarning = (blockStyle) => getTemplate(`block style \"${blockStyle}\"`, \"block\"), unknownListStyleWarning = (listStyle) => getTemplate(`list style \"${listStyle}\"`, \"list\"), unknownListItemStyleWarning = (listStyle) => getTemplate(`list item style \"${listStyle}\"`, \"listItem\");\nfunction printWarning(message) {\n  console.warn(message);\n}\nconst DefaultUnknownType = ({\n  value,\n  isInline\n}) => {\n  const warning = unknownTypeWarning(value._type);\n  return isInline ? `<span style=\"display:none\">${warning}</span>` : `<div style=\"display:none\">${warning}</div>`;\n}, DefaultUnknownMark = ({\n  markType,\n  children\n}) => `<span class=\"unknown__pt__mark__${markType}\">${children}</span>`, DefaultUnknownBlockStyle = ({\n  children\n}) => `<p>${children}</p>`, DefaultUnknownList = ({ children }) => `<ul>${children}</ul>`, DefaultUnknownListItem = ({\n  children\n}) => `<li>${children}</li>`, DefaultHardBreak = () => \"<br/>\", defaultPortableTextBlockStyles = {\n  normal: ({ children }) => `<p>${children}</p>`,\n  blockquote: ({ children }) => `<blockquote>${children}</blockquote>`,\n  h1: ({ children }) => `<h1>${children}</h1>`,\n  h2: ({ children }) => `<h2>${children}</h2>`,\n  h3: ({ children }) => `<h3>${children}</h3>`,\n  h4: ({ children }) => `<h4>${children}</h4>`,\n  h5: ({ children }) => `<h5>${children}</h5>`,\n  h6: ({ children }) => `<h6>${children}</h6>`\n}, defaultComponents = {\n  types: {},\n  block: defaultPortableTextBlockStyles,\n  marks: defaultMarks,\n  list: defaultLists,\n  listItem: DefaultListItem,\n  hardBreak: DefaultHardBreak,\n  escapeHTML,\n  unknownType: DefaultUnknownType,\n  unknownMark: DefaultUnknownMark,\n  unknownList: DefaultUnknownList,\n  unknownListItem: DefaultUnknownListItem,\n  unknownBlockStyle: DefaultUnknownBlockStyle\n};\nfunction mergeComponents(parent, overrides) {\n  const { block, list, listItem, marks, types, ...rest } = overrides;\n  return {\n    ...parent,\n    block: mergeDeeply(parent, overrides, \"block\"),\n    list: mergeDeeply(parent, overrides, \"list\"),\n    listItem: mergeDeeply(parent, overrides, \"listItem\"),\n    marks: mergeDeeply(parent, overrides, \"marks\"),\n    types: mergeDeeply(parent, overrides, \"types\"),\n    ...rest\n  };\n}\nfunction mergeDeeply(parent, overrides, key) {\n  const override = overrides[key], parentVal = parent[key];\n  return typeof override == \"function\" || override && typeof parentVal == \"function\" ? override : override ? { ...parentVal, ...override } : parentVal;\n}\nfunction toHTML(value, options = {}) {\n  const {\n    components: componentOverrides,\n    onMissingComponent: missingComponentHandler = printWarning\n  } = options, handleMissingComponent = missingComponentHandler || noop, blocks = Array.isArray(value) ? value : [value], nested = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.nestLists)(blocks, \"html\"), components = componentOverrides ? mergeComponents(defaultComponents, componentOverrides) : defaultComponents, renderNode = getNodeRenderer(components, handleMissingComponent);\n  return nested.map(\n    (node, index) => renderNode({ node, index, isInline: !1, renderNode })\n  ).join(\"\");\n}\nconst getNodeRenderer = (components, handleMissingComponent) => {\n  function renderNode(options) {\n    const { node, index, isInline } = options;\n    return (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPortableTextToolkitList)(node) ? renderList(node, index) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPortableTextListItemBlock)(node) ? renderListItem(node, index) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPortableTextToolkitSpan)(node) ? renderSpan(node) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPortableTextBlock)(node) ? renderBlock(node, index, isInline) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPortableTextToolkitTextNode)(node) ? renderText(node) : renderCustomBlock(node, index, isInline);\n  }\n  function renderListItem(node, index) {\n    const tree = serializeBlock({ node, index, isInline: !1, renderNode }), renderer = components.listItem, itemHandler = (typeof renderer == \"function\" ? renderer : renderer[node.listItem]) || components.unknownListItem;\n    if (itemHandler === components.unknownListItem) {\n      const style = node.listItem || \"bullet\";\n      handleMissingComponent(unknownListItemStyleWarning(style), {\n        type: style,\n        nodeType: \"listItemStyle\"\n      });\n    }\n    let children = tree.children;\n    if (node.style && node.style !== \"normal\") {\n      const { listItem, ...blockNode } = node;\n      children = renderNode({ node: blockNode, index, isInline: !1 });\n    }\n    return itemHandler({ value: node, index, isInline: !1, renderNode, children });\n  }\n  function renderList(node, index) {\n    const children = node.children.map(\n      (child, childIndex) => renderNode({\n        node: child._key ? child : { ...child, _key: `li-${index}-${childIndex}` },\n        index: childIndex,\n        isInline: !1\n      })\n    ), component = components.list, list = (typeof component == \"function\" ? component : component[node.listItem]) || components.unknownList;\n    if (list === components.unknownList) {\n      const style = node.listItem || \"bullet\";\n      handleMissingComponent(unknownListStyleWarning(style), { nodeType: \"listStyle\", type: style });\n    }\n    return list({ value: node, index, isInline: !1, renderNode, children: children.join(\"\") });\n  }\n  function renderSpan(node) {\n    const { markDef, markType, markKey } = node, span = components.marks[markType] || components.unknownMark, children = node.children.map(\n      (child, childIndex) => renderNode({ node: child, index: childIndex, isInline: !0 })\n    );\n    return span === components.unknownMark && handleMissingComponent(unknownMarkWarning(markType), { nodeType: \"mark\", type: markType }), span({\n      text: (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.spanToPlainText)(node),\n      value: markDef,\n      markType,\n      markKey,\n      renderNode,\n      children: children.join(\"\")\n    });\n  }\n  function renderBlock(node, index, isInline) {\n    const { _key, ...props } = serializeBlock({ node, index, isInline, renderNode }), style = props.node.style || \"normal\", block = (typeof components.block == \"function\" ? components.block : components.block[style]) || components.unknownBlockStyle;\n    return block === components.unknownBlockStyle && handleMissingComponent(unknownBlockStyleWarning(style), {\n      nodeType: \"blockStyle\",\n      type: style\n    }), block({ ...props, value: props.node, renderNode });\n  }\n  function renderText(node) {\n    if (node.text === `\n`) {\n      const hardBreak = components.hardBreak;\n      return hardBreak ? hardBreak() : `\n`;\n    }\n    return components.escapeHTML(node.text);\n  }\n  function renderCustomBlock(value, index, isInline) {\n    const node = components.types[value._type];\n    return node || handleMissingComponent(unknownTypeWarning(value._type), {\n      nodeType: \"block\",\n      type: value._type\n    }), (node || components.unknownType)({\n      value,\n      isInline,\n      index,\n      renderNode\n    });\n  }\n  return renderNode;\n};\nfunction serializeBlock(options) {\n  const { node, index, isInline, renderNode } = options, children = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.buildMarksTree)(node).map(\n    (child, i) => renderNode({ node: child, isInline: !0, index: i, renderNode })\n  );\n  return {\n    _key: node._key || `block-${index}`,\n    children: children.join(\"\"),\n    index,\n    isInline,\n    node\n  };\n}\nfunction noop() {\n}\n\n//# sourceMappingURL=pt-to-html.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvdG8taHRtbC9kaXN0L3B0LXRvLWh0bWwubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUEwTjtBQUMxTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFlBQVk7QUFDOUU7QUFDQTtBQUNBLHdCQUF3QixHQUFHLGtCQUFrQixPQUFPLDRCQUE0QjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVUsWUFBWSxTQUFTO0FBQzVDLGFBQWEsVUFBVSxZQUFZLFNBQVM7QUFDNUMsQ0FBQyx1QkFBdUIsVUFBVSxZQUFZLFNBQVMsa0JBQWtCLGlCQUFpQjtBQUMxRjtBQUNBLDBDQUEwQyxpQkFBaUIsSUFBSSxTQUFTO0FBQ3hFLENBQUM7QUFDRCxTQUFTLFVBQVUsWUFBWSxTQUFTO0FBQ3hDLGFBQWEsVUFBVSxnQkFBZ0IsU0FBUztBQUNoRCxXQUFXLFVBQVUsY0FBYyxTQUFTO0FBQzVDLGdCQUFnQixVQUFVLGdEQUFnRCxTQUFTO0FBQ25GLHVCQUF1QixVQUFVLGFBQWEsU0FBUztBQUN2RDtBQUNBLENBQUMsMkNBQTJDLEtBQUssbURBQW1ELEtBQUssMEVBQTBFLFNBQVMsMkVBQTJFLFNBQVMscUZBQXFGLFdBQVcsa0ZBQWtGLFVBQVUsMEZBQTBGLFVBQVU7QUFDaGpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGtEQUFrRCxRQUFRLHdDQUF3QyxRQUFRO0FBQzFHLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0MsU0FBUyxJQUFJLFNBQVM7QUFDL0Q7QUFDQSxDQUFDLFdBQVcsU0FBUywrQkFBK0IsVUFBVSxZQUFZLFNBQVM7QUFDbkY7QUFDQSxDQUFDLFlBQVksU0FBUztBQUN0QixhQUFhLFVBQVUsV0FBVyxTQUFTO0FBQzNDLGlCQUFpQixVQUFVLG9CQUFvQixTQUFTO0FBQ3hELFNBQVMsVUFBVSxZQUFZLFNBQVM7QUFDeEMsU0FBUyxVQUFVLFlBQVksU0FBUztBQUN4QyxTQUFTLFVBQVUsWUFBWSxTQUFTO0FBQ3hDLFNBQVMsVUFBVSxZQUFZLFNBQVM7QUFDeEMsU0FBUyxVQUFVLFlBQVksU0FBUztBQUN4QyxTQUFTLFVBQVUsWUFBWSxTQUFTO0FBQ3hDLENBQUM7QUFDRCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtDQUErQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrR0FBK0csNEJBQTRCO0FBQzNJO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLElBQUksK0hBQStILGdFQUFTO0FBQzVJO0FBQ0Esa0NBQWtDLHVDQUF1QztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0JBQXdCO0FBQ3BDLFdBQVcsZ0ZBQXlCLG1DQUFtQyxrRkFBMkIsdUNBQXVDLGdGQUF5Qiw0QkFBNEIsMEVBQW1CLDhDQUE4QyxvRkFBNkI7QUFDNVI7QUFDQTtBQUNBLGtDQUFrQyx1Q0FBdUM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2Qyw4QkFBOEIsc0NBQXNDO0FBQ3BFO0FBQ0EseUJBQXlCLHdEQUF3RDtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxzQkFBc0IsTUFBTSxHQUFHLFdBQVcsR0FBRztBQUNsRjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxvQ0FBb0M7QUFDbkc7QUFDQSxrQkFBa0IsMkVBQTJFO0FBQzdGO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QywwQ0FBMEMsOENBQThDO0FBQ3hGO0FBQ0EscUdBQXFHLGtDQUFrQztBQUN2SSxZQUFZLHNFQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksaUJBQWlCLG1CQUFtQixtQ0FBbUM7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsS0FBSyxXQUFXLHlDQUF5QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG9DQUFvQyxzQkFBc0IscUVBQWM7QUFDbEYsK0JBQStCLGlEQUFpRDtBQUNoRjtBQUNBO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9FO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9HYWxvY2svQ1MvYmVob21lLXNpdGUvbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvdG8taHRtbC9kaXN0L3B0LXRvLWh0bWwubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG5lc3RMaXN0cywgaXNQb3J0YWJsZVRleHRUb29sa2l0TGlzdCwgaXNQb3J0YWJsZVRleHRMaXN0SXRlbUJsb2NrLCBpc1BvcnRhYmxlVGV4dFRvb2xraXRTcGFuLCBpc1BvcnRhYmxlVGV4dEJsb2NrLCBpc1BvcnRhYmxlVGV4dFRvb2xraXRUZXh0Tm9kZSwgc3BhblRvUGxhaW5UZXh0LCBidWlsZE1hcmtzVHJlZSB9IGZyb20gXCJAcG9ydGFibGV0ZXh0L3Rvb2xraXRcIjtcbmNvbnN0IGFsbG93ZWRQcm90b2NvbHMgPSBbXCJodHRwXCIsIFwiaHR0cHNcIiwgXCJtYWlsdG9cIiwgXCJ0ZWxcIl0sIGNoYXJNYXAgPSB7XG4gIFwiJlwiOiBcImFtcFwiLFxuICBcIjxcIjogXCJsdFwiLFxuICBcIj5cIjogXCJndFwiLFxuICAnXCInOiBcInF1b3RcIixcbiAgXCInXCI6IFwiI3gyN1wiXG59O1xuZnVuY3Rpb24gZXNjYXBlSFRNTChzdHIpIHtcbiAgcmV0dXJuIHJlcGxhY2VNdWx0aXBsZVNwYWNlcyhzdHIucmVwbGFjZSgvWyY8PlwiJ10vZywgKHMpID0+IGAmJHtjaGFyTWFwW3NdfTtgKSk7XG59XG5mdW5jdGlvbiByZXBsYWNlTXVsdGlwbGVTcGFjZXMoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvIHsyLH0vZywgKG1hdGNoKSA9PiBgJHtcIiZuYnNwO1wiLnJlcGVhdChtYXRjaC5sZW5ndGggLSAxKX0gYCk7XG59XG5mdW5jdGlvbiB1cmlMb29rc1NhZmUodXJpKSB7XG4gIGNvbnN0IHVybCA9ICh1cmkgfHwgXCJcIikudHJpbSgpLCBmaXJzdCA9IHVybC5jaGFyQXQoMCk7XG4gIGlmIChmaXJzdCA9PT0gXCIjXCIgfHwgZmlyc3QgPT09IFwiL1wiKVxuICAgIHJldHVybiAhMDtcbiAgY29uc3QgY29sb25JbmRleCA9IHVybC5pbmRleE9mKFwiOlwiKTtcbiAgaWYgKGNvbG9uSW5kZXggPT09IC0xKVxuICAgIHJldHVybiAhMDtcbiAgY29uc3QgcHJvdG8gPSB1cmwuc2xpY2UoMCwgY29sb25JbmRleCkudG9Mb3dlckNhc2UoKTtcbiAgaWYgKGFsbG93ZWRQcm90b2NvbHMuaW5kZXhPZihwcm90bykgIT09IC0xKVxuICAgIHJldHVybiAhMDtcbiAgY29uc3QgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKFwiP1wiKTtcbiAgaWYgKHF1ZXJ5SW5kZXggIT09IC0xICYmIGNvbG9uSW5kZXggPiBxdWVyeUluZGV4KVxuICAgIHJldHVybiAhMDtcbiAgY29uc3QgaGFzaEluZGV4ID0gdXJsLmluZGV4T2YoXCIjXCIpO1xuICByZXR1cm4gaGFzaEluZGV4ICE9PSAtMSAmJiBjb2xvbkluZGV4ID4gaGFzaEluZGV4O1xufVxuY29uc3QgZGVmYXVsdExpc3RzID0ge1xuICBudW1iZXI6ICh7IGNoaWxkcmVuIH0pID0+IGA8b2w+JHtjaGlsZHJlbn08L29sPmAsXG4gIGJ1bGxldDogKHsgY2hpbGRyZW4gfSkgPT4gYDx1bD4ke2NoaWxkcmVufTwvdWw+YFxufSwgRGVmYXVsdExpc3RJdGVtID0gKHsgY2hpbGRyZW4gfSkgPT4gYDxsaT4ke2NoaWxkcmVufTwvbGk+YCwgbGluayA9ICh7IGNoaWxkcmVuLCB2YWx1ZSB9KSA9PiB7XG4gIGNvbnN0IGhyZWYgPSAodmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IHZhbHVlLmhyZWYpIHx8IFwiXCI7XG4gIHJldHVybiB1cmlMb29rc1NhZmUoaHJlZikgPyBgPGEgaHJlZj1cIiR7ZXNjYXBlSFRNTChocmVmKX1cIj4ke2NoaWxkcmVufTwvYT5gIDogY2hpbGRyZW47XG59LCBkZWZhdWx0TWFya3MgPSB7XG4gIGVtOiAoeyBjaGlsZHJlbiB9KSA9PiBgPGVtPiR7Y2hpbGRyZW59PC9lbT5gLFxuICBzdHJvbmc6ICh7IGNoaWxkcmVuIH0pID0+IGA8c3Ryb25nPiR7Y2hpbGRyZW59PC9zdHJvbmc+YCxcbiAgY29kZTogKHsgY2hpbGRyZW4gfSkgPT4gYDxjb2RlPiR7Y2hpbGRyZW59PC9jb2RlPmAsXG4gIHVuZGVybGluZTogKHsgY2hpbGRyZW4gfSkgPT4gYDxzcGFuIHN0eWxlPVwidGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZVwiPiR7Y2hpbGRyZW59PC9zcGFuPmAsXG4gIFwic3RyaWtlLXRocm91Z2hcIjogKHsgY2hpbGRyZW4gfSkgPT4gYDxkZWw+JHtjaGlsZHJlbn08L2RlbD5gLFxuICBsaW5rXG59LCBnZXRUZW1wbGF0ZSA9ICh0eXBlLCBwcm9wKSA9PiBgVW5rbm93biAke3R5cGV9LCBzcGVjaWZ5IGEgY29tcG9uZW50IGZvciBpdCBpbiB0aGUgXFxgY29tcG9uZW50cy4ke3Byb3B9XFxgIG9wdGlvbmAsIHVua25vd25UeXBlV2FybmluZyA9ICh0eXBlTmFtZSkgPT4gZ2V0VGVtcGxhdGUoYGJsb2NrIHR5cGUgXCIke3R5cGVOYW1lfVwiYCwgXCJ0eXBlc1wiKSwgdW5rbm93bk1hcmtXYXJuaW5nID0gKG1hcmtUeXBlKSA9PiBnZXRUZW1wbGF0ZShgbWFyayB0eXBlIFwiJHttYXJrVHlwZX1cImAsIFwibWFya3NcIiksIHVua25vd25CbG9ja1N0eWxlV2FybmluZyA9IChibG9ja1N0eWxlKSA9PiBnZXRUZW1wbGF0ZShgYmxvY2sgc3R5bGUgXCIke2Jsb2NrU3R5bGV9XCJgLCBcImJsb2NrXCIpLCB1bmtub3duTGlzdFN0eWxlV2FybmluZyA9IChsaXN0U3R5bGUpID0+IGdldFRlbXBsYXRlKGBsaXN0IHN0eWxlIFwiJHtsaXN0U3R5bGV9XCJgLCBcImxpc3RcIiksIHVua25vd25MaXN0SXRlbVN0eWxlV2FybmluZyA9IChsaXN0U3R5bGUpID0+IGdldFRlbXBsYXRlKGBsaXN0IGl0ZW0gc3R5bGUgXCIke2xpc3RTdHlsZX1cImAsIFwibGlzdEl0ZW1cIik7XG5mdW5jdGlvbiBwcmludFdhcm5pbmcobWVzc2FnZSkge1xuICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG59XG5jb25zdCBEZWZhdWx0VW5rbm93blR5cGUgPSAoe1xuICB2YWx1ZSxcbiAgaXNJbmxpbmVcbn0pID0+IHtcbiAgY29uc3Qgd2FybmluZyA9IHVua25vd25UeXBlV2FybmluZyh2YWx1ZS5fdHlwZSk7XG4gIHJldHVybiBpc0lubGluZSA/IGA8c3BhbiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiPiR7d2FybmluZ308L3NwYW4+YCA6IGA8ZGl2IHN0eWxlPVwiZGlzcGxheTpub25lXCI+JHt3YXJuaW5nfTwvZGl2PmA7XG59LCBEZWZhdWx0VW5rbm93bk1hcmsgPSAoe1xuICBtYXJrVHlwZSxcbiAgY2hpbGRyZW5cbn0pID0+IGA8c3BhbiBjbGFzcz1cInVua25vd25fX3B0X19tYXJrX18ke21hcmtUeXBlfVwiPiR7Y2hpbGRyZW59PC9zcGFuPmAsIERlZmF1bHRVbmtub3duQmxvY2tTdHlsZSA9ICh7XG4gIGNoaWxkcmVuXG59KSA9PiBgPHA+JHtjaGlsZHJlbn08L3A+YCwgRGVmYXVsdFVua25vd25MaXN0ID0gKHsgY2hpbGRyZW4gfSkgPT4gYDx1bD4ke2NoaWxkcmVufTwvdWw+YCwgRGVmYXVsdFVua25vd25MaXN0SXRlbSA9ICh7XG4gIGNoaWxkcmVuXG59KSA9PiBgPGxpPiR7Y2hpbGRyZW59PC9saT5gLCBEZWZhdWx0SGFyZEJyZWFrID0gKCkgPT4gXCI8YnIvPlwiLCBkZWZhdWx0UG9ydGFibGVUZXh0QmxvY2tTdHlsZXMgPSB7XG4gIG5vcm1hbDogKHsgY2hpbGRyZW4gfSkgPT4gYDxwPiR7Y2hpbGRyZW59PC9wPmAsXG4gIGJsb2NrcXVvdGU6ICh7IGNoaWxkcmVuIH0pID0+IGA8YmxvY2txdW90ZT4ke2NoaWxkcmVufTwvYmxvY2txdW90ZT5gLFxuICBoMTogKHsgY2hpbGRyZW4gfSkgPT4gYDxoMT4ke2NoaWxkcmVufTwvaDE+YCxcbiAgaDI6ICh7IGNoaWxkcmVuIH0pID0+IGA8aDI+JHtjaGlsZHJlbn08L2gyPmAsXG4gIGgzOiAoeyBjaGlsZHJlbiB9KSA9PiBgPGgzPiR7Y2hpbGRyZW59PC9oMz5gLFxuICBoNDogKHsgY2hpbGRyZW4gfSkgPT4gYDxoND4ke2NoaWxkcmVufTwvaDQ+YCxcbiAgaDU6ICh7IGNoaWxkcmVuIH0pID0+IGA8aDU+JHtjaGlsZHJlbn08L2g1PmAsXG4gIGg2OiAoeyBjaGlsZHJlbiB9KSA9PiBgPGg2PiR7Y2hpbGRyZW59PC9oNj5gXG59LCBkZWZhdWx0Q29tcG9uZW50cyA9IHtcbiAgdHlwZXM6IHt9LFxuICBibG9jazogZGVmYXVsdFBvcnRhYmxlVGV4dEJsb2NrU3R5bGVzLFxuICBtYXJrczogZGVmYXVsdE1hcmtzLFxuICBsaXN0OiBkZWZhdWx0TGlzdHMsXG4gIGxpc3RJdGVtOiBEZWZhdWx0TGlzdEl0ZW0sXG4gIGhhcmRCcmVhazogRGVmYXVsdEhhcmRCcmVhayxcbiAgZXNjYXBlSFRNTCxcbiAgdW5rbm93blR5cGU6IERlZmF1bHRVbmtub3duVHlwZSxcbiAgdW5rbm93bk1hcms6IERlZmF1bHRVbmtub3duTWFyayxcbiAgdW5rbm93bkxpc3Q6IERlZmF1bHRVbmtub3duTGlzdCxcbiAgdW5rbm93bkxpc3RJdGVtOiBEZWZhdWx0VW5rbm93bkxpc3RJdGVtLFxuICB1bmtub3duQmxvY2tTdHlsZTogRGVmYXVsdFVua25vd25CbG9ja1N0eWxlXG59O1xuZnVuY3Rpb24gbWVyZ2VDb21wb25lbnRzKHBhcmVudCwgb3ZlcnJpZGVzKSB7XG4gIGNvbnN0IHsgYmxvY2ssIGxpc3QsIGxpc3RJdGVtLCBtYXJrcywgdHlwZXMsIC4uLnJlc3QgfSA9IG92ZXJyaWRlcztcbiAgcmV0dXJuIHtcbiAgICAuLi5wYXJlbnQsXG4gICAgYmxvY2s6IG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBcImJsb2NrXCIpLFxuICAgIGxpc3Q6IG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBcImxpc3RcIiksXG4gICAgbGlzdEl0ZW06IG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBcImxpc3RJdGVtXCIpLFxuICAgIG1hcmtzOiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywgXCJtYXJrc1wiKSxcbiAgICB0eXBlczogbWVyZ2VEZWVwbHkocGFyZW50LCBvdmVycmlkZXMsIFwidHlwZXNcIiksXG4gICAgLi4ucmVzdFxuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VEZWVwbHkocGFyZW50LCBvdmVycmlkZXMsIGtleSkge1xuICBjb25zdCBvdmVycmlkZSA9IG92ZXJyaWRlc1trZXldLCBwYXJlbnRWYWwgPSBwYXJlbnRba2V5XTtcbiAgcmV0dXJuIHR5cGVvZiBvdmVycmlkZSA9PSBcImZ1bmN0aW9uXCIgfHwgb3ZlcnJpZGUgJiYgdHlwZW9mIHBhcmVudFZhbCA9PSBcImZ1bmN0aW9uXCIgPyBvdmVycmlkZSA6IG92ZXJyaWRlID8geyAuLi5wYXJlbnRWYWwsIC4uLm92ZXJyaWRlIH0gOiBwYXJlbnRWYWw7XG59XG5mdW5jdGlvbiB0b0hUTUwodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgY29tcG9uZW50czogY29tcG9uZW50T3ZlcnJpZGVzLFxuICAgIG9uTWlzc2luZ0NvbXBvbmVudDogbWlzc2luZ0NvbXBvbmVudEhhbmRsZXIgPSBwcmludFdhcm5pbmdcbiAgfSA9IG9wdGlvbnMsIGhhbmRsZU1pc3NpbmdDb21wb25lbnQgPSBtaXNzaW5nQ29tcG9uZW50SGFuZGxlciB8fCBub29wLCBibG9ja3MgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXSwgbmVzdGVkID0gbmVzdExpc3RzKGJsb2NrcywgXCJodG1sXCIpLCBjb21wb25lbnRzID0gY29tcG9uZW50T3ZlcnJpZGVzID8gbWVyZ2VDb21wb25lbnRzKGRlZmF1bHRDb21wb25lbnRzLCBjb21wb25lbnRPdmVycmlkZXMpIDogZGVmYXVsdENvbXBvbmVudHMsIHJlbmRlck5vZGUgPSBnZXROb2RlUmVuZGVyZXIoY29tcG9uZW50cywgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCk7XG4gIHJldHVybiBuZXN0ZWQubWFwKFxuICAgIChub2RlLCBpbmRleCkgPT4gcmVuZGVyTm9kZSh7IG5vZGUsIGluZGV4LCBpc0lubGluZTogITEsIHJlbmRlck5vZGUgfSlcbiAgKS5qb2luKFwiXCIpO1xufVxuY29uc3QgZ2V0Tm9kZVJlbmRlcmVyID0gKGNvbXBvbmVudHMsIGhhbmRsZU1pc3NpbmdDb21wb25lbnQpID0+IHtcbiAgZnVuY3Rpb24gcmVuZGVyTm9kZShvcHRpb25zKSB7XG4gICAgY29uc3QgeyBub2RlLCBpbmRleCwgaXNJbmxpbmUgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIGlzUG9ydGFibGVUZXh0VG9vbGtpdExpc3Qobm9kZSkgPyByZW5kZXJMaXN0KG5vZGUsIGluZGV4KSA6IGlzUG9ydGFibGVUZXh0TGlzdEl0ZW1CbG9jayhub2RlKSA/IHJlbmRlckxpc3RJdGVtKG5vZGUsIGluZGV4KSA6IGlzUG9ydGFibGVUZXh0VG9vbGtpdFNwYW4obm9kZSkgPyByZW5kZXJTcGFuKG5vZGUpIDogaXNQb3J0YWJsZVRleHRCbG9jayhub2RlKSA/IHJlbmRlckJsb2NrKG5vZGUsIGluZGV4LCBpc0lubGluZSkgOiBpc1BvcnRhYmxlVGV4dFRvb2xraXRUZXh0Tm9kZShub2RlKSA/IHJlbmRlclRleHQobm9kZSkgOiByZW5kZXJDdXN0b21CbG9jayhub2RlLCBpbmRleCwgaXNJbmxpbmUpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlckxpc3RJdGVtKG5vZGUsIGluZGV4KSB7XG4gICAgY29uc3QgdHJlZSA9IHNlcmlhbGl6ZUJsb2NrKHsgbm9kZSwgaW5kZXgsIGlzSW5saW5lOiAhMSwgcmVuZGVyTm9kZSB9KSwgcmVuZGVyZXIgPSBjb21wb25lbnRzLmxpc3RJdGVtLCBpdGVtSGFuZGxlciA9ICh0eXBlb2YgcmVuZGVyZXIgPT0gXCJmdW5jdGlvblwiID8gcmVuZGVyZXIgOiByZW5kZXJlcltub2RlLmxpc3RJdGVtXSkgfHwgY29tcG9uZW50cy51bmtub3duTGlzdEl0ZW07XG4gICAgaWYgKGl0ZW1IYW5kbGVyID09PSBjb21wb25lbnRzLnVua25vd25MaXN0SXRlbSkge1xuICAgICAgY29uc3Qgc3R5bGUgPSBub2RlLmxpc3RJdGVtIHx8IFwiYnVsbGV0XCI7XG4gICAgICBoYW5kbGVNaXNzaW5nQ29tcG9uZW50KHVua25vd25MaXN0SXRlbVN0eWxlV2FybmluZyhzdHlsZSksIHtcbiAgICAgICAgdHlwZTogc3R5bGUsXG4gICAgICAgIG5vZGVUeXBlOiBcImxpc3RJdGVtU3R5bGVcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBjaGlsZHJlbiA9IHRyZWUuY2hpbGRyZW47XG4gICAgaWYgKG5vZGUuc3R5bGUgJiYgbm9kZS5zdHlsZSAhPT0gXCJub3JtYWxcIikge1xuICAgICAgY29uc3QgeyBsaXN0SXRlbSwgLi4uYmxvY2tOb2RlIH0gPSBub2RlO1xuICAgICAgY2hpbGRyZW4gPSByZW5kZXJOb2RlKHsgbm9kZTogYmxvY2tOb2RlLCBpbmRleCwgaXNJbmxpbmU6ICExIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbUhhbmRsZXIoeyB2YWx1ZTogbm9kZSwgaW5kZXgsIGlzSW5saW5lOiAhMSwgcmVuZGVyTm9kZSwgY2hpbGRyZW4gfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyTGlzdChub2RlLCBpbmRleCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbi5tYXAoXG4gICAgICAoY2hpbGQsIGNoaWxkSW5kZXgpID0+IHJlbmRlck5vZGUoe1xuICAgICAgICBub2RlOiBjaGlsZC5fa2V5ID8gY2hpbGQgOiB7IC4uLmNoaWxkLCBfa2V5OiBgbGktJHtpbmRleH0tJHtjaGlsZEluZGV4fWAgfSxcbiAgICAgICAgaW5kZXg6IGNoaWxkSW5kZXgsXG4gICAgICAgIGlzSW5saW5lOiAhMVxuICAgICAgfSlcbiAgICApLCBjb21wb25lbnQgPSBjb21wb25lbnRzLmxpc3QsIGxpc3QgPSAodHlwZW9mIGNvbXBvbmVudCA9PSBcImZ1bmN0aW9uXCIgPyBjb21wb25lbnQgOiBjb21wb25lbnRbbm9kZS5saXN0SXRlbV0pIHx8IGNvbXBvbmVudHMudW5rbm93bkxpc3Q7XG4gICAgaWYgKGxpc3QgPT09IGNvbXBvbmVudHMudW5rbm93bkxpc3QpIHtcbiAgICAgIGNvbnN0IHN0eWxlID0gbm9kZS5saXN0SXRlbSB8fCBcImJ1bGxldFwiO1xuICAgICAgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCh1bmtub3duTGlzdFN0eWxlV2FybmluZyhzdHlsZSksIHsgbm9kZVR5cGU6IFwibGlzdFN0eWxlXCIsIHR5cGU6IHN0eWxlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdCh7IHZhbHVlOiBub2RlLCBpbmRleCwgaXNJbmxpbmU6ICExLCByZW5kZXJOb2RlLCBjaGlsZHJlbjogY2hpbGRyZW4uam9pbihcIlwiKSB9KTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJTcGFuKG5vZGUpIHtcbiAgICBjb25zdCB7IG1hcmtEZWYsIG1hcmtUeXBlLCBtYXJrS2V5IH0gPSBub2RlLCBzcGFuID0gY29tcG9uZW50cy5tYXJrc1ttYXJrVHlwZV0gfHwgY29tcG9uZW50cy51bmtub3duTWFyaywgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLm1hcChcbiAgICAgIChjaGlsZCwgY2hpbGRJbmRleCkgPT4gcmVuZGVyTm9kZSh7IG5vZGU6IGNoaWxkLCBpbmRleDogY2hpbGRJbmRleCwgaXNJbmxpbmU6ICEwIH0pXG4gICAgKTtcbiAgICByZXR1cm4gc3BhbiA9PT0gY29tcG9uZW50cy51bmtub3duTWFyayAmJiBoYW5kbGVNaXNzaW5nQ29tcG9uZW50KHVua25vd25NYXJrV2FybmluZyhtYXJrVHlwZSksIHsgbm9kZVR5cGU6IFwibWFya1wiLCB0eXBlOiBtYXJrVHlwZSB9KSwgc3Bhbih7XG4gICAgICB0ZXh0OiBzcGFuVG9QbGFpblRleHQobm9kZSksXG4gICAgICB2YWx1ZTogbWFya0RlZixcbiAgICAgIG1hcmtUeXBlLFxuICAgICAgbWFya0tleSxcbiAgICAgIHJlbmRlck5vZGUsXG4gICAgICBjaGlsZHJlbjogY2hpbGRyZW4uam9pbihcIlwiKVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlckJsb2NrKG5vZGUsIGluZGV4LCBpc0lubGluZSkge1xuICAgIGNvbnN0IHsgX2tleSwgLi4ucHJvcHMgfSA9IHNlcmlhbGl6ZUJsb2NrKHsgbm9kZSwgaW5kZXgsIGlzSW5saW5lLCByZW5kZXJOb2RlIH0pLCBzdHlsZSA9IHByb3BzLm5vZGUuc3R5bGUgfHwgXCJub3JtYWxcIiwgYmxvY2sgPSAodHlwZW9mIGNvbXBvbmVudHMuYmxvY2sgPT0gXCJmdW5jdGlvblwiID8gY29tcG9uZW50cy5ibG9jayA6IGNvbXBvbmVudHMuYmxvY2tbc3R5bGVdKSB8fCBjb21wb25lbnRzLnVua25vd25CbG9ja1N0eWxlO1xuICAgIHJldHVybiBibG9jayA9PT0gY29tcG9uZW50cy51bmtub3duQmxvY2tTdHlsZSAmJiBoYW5kbGVNaXNzaW5nQ29tcG9uZW50KHVua25vd25CbG9ja1N0eWxlV2FybmluZyhzdHlsZSksIHtcbiAgICAgIG5vZGVUeXBlOiBcImJsb2NrU3R5bGVcIixcbiAgICAgIHR5cGU6IHN0eWxlXG4gICAgfSksIGJsb2NrKHsgLi4ucHJvcHMsIHZhbHVlOiBwcm9wcy5ub2RlLCByZW5kZXJOb2RlIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlclRleHQobm9kZSkge1xuICAgIGlmIChub2RlLnRleHQgPT09IGBcbmApIHtcbiAgICAgIGNvbnN0IGhhcmRCcmVhayA9IGNvbXBvbmVudHMuaGFyZEJyZWFrO1xuICAgICAgcmV0dXJuIGhhcmRCcmVhayA/IGhhcmRCcmVhaygpIDogYFxuYDtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudHMuZXNjYXBlSFRNTChub2RlLnRleHQpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlckN1c3RvbUJsb2NrKHZhbHVlLCBpbmRleCwgaXNJbmxpbmUpIHtcbiAgICBjb25zdCBub2RlID0gY29tcG9uZW50cy50eXBlc1t2YWx1ZS5fdHlwZV07XG4gICAgcmV0dXJuIG5vZGUgfHwgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCh1bmtub3duVHlwZVdhcm5pbmcodmFsdWUuX3R5cGUpLCB7XG4gICAgICBub2RlVHlwZTogXCJibG9ja1wiLFxuICAgICAgdHlwZTogdmFsdWUuX3R5cGVcbiAgICB9KSwgKG5vZGUgfHwgY29tcG9uZW50cy51bmtub3duVHlwZSkoe1xuICAgICAgdmFsdWUsXG4gICAgICBpc0lubGluZSxcbiAgICAgIGluZGV4LFxuICAgICAgcmVuZGVyTm9kZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZW5kZXJOb2RlO1xufTtcbmZ1bmN0aW9uIHNlcmlhbGl6ZUJsb2NrKG9wdGlvbnMpIHtcbiAgY29uc3QgeyBub2RlLCBpbmRleCwgaXNJbmxpbmUsIHJlbmRlck5vZGUgfSA9IG9wdGlvbnMsIGNoaWxkcmVuID0gYnVpbGRNYXJrc1RyZWUobm9kZSkubWFwKFxuICAgIChjaGlsZCwgaSkgPT4gcmVuZGVyTm9kZSh7IG5vZGU6IGNoaWxkLCBpc0lubGluZTogITAsIGluZGV4OiBpLCByZW5kZXJOb2RlIH0pXG4gICk7XG4gIHJldHVybiB7XG4gICAgX2tleTogbm9kZS5fa2V5IHx8IGBibG9jay0ke2luZGV4fWAsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLmpvaW4oXCJcIiksXG4gICAgaW5kZXgsXG4gICAgaXNJbmxpbmUsXG4gICAgbm9kZVxuICB9O1xufVxuZnVuY3Rpb24gbm9vcCgpIHtcbn1cbmV4cG9ydCB7XG4gIGRlZmF1bHRDb21wb25lbnRzLFxuICBlc2NhcGVIVE1MLFxuICBtZXJnZUNvbXBvbmVudHMsXG4gIHRvSFRNTCxcbiAgdXJpTG9va3NTYWZlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHQtdG8taHRtbC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@portabletext/to-html/dist/pt-to-html.mjs\n");

/***/ }),

/***/ "(ssr)/../node_modules/@portabletext/toolkit/dist/index.js":
/*!***********************************************************!*\
  !*** ../node_modules/@portabletext/toolkit/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LIST_NEST_MODE_DIRECT: () => (/* binding */ LIST_NEST_MODE_DIRECT),\n/* harmony export */   LIST_NEST_MODE_HTML: () => (/* binding */ LIST_NEST_MODE_HTML),\n/* harmony export */   buildMarksTree: () => (/* binding */ buildMarksTree),\n/* harmony export */   isPortableTextBlock: () => (/* binding */ isPortableTextBlock),\n/* harmony export */   isPortableTextListItemBlock: () => (/* binding */ isPortableTextListItemBlock),\n/* harmony export */   isPortableTextSpan: () => (/* binding */ isPortableTextSpan),\n/* harmony export */   isPortableTextToolkitList: () => (/* binding */ isPortableTextToolkitList),\n/* harmony export */   isPortableTextToolkitSpan: () => (/* binding */ isPortableTextToolkitSpan),\n/* harmony export */   isPortableTextToolkitTextNode: () => (/* binding */ isPortableTextToolkitTextNode),\n/* harmony export */   nestLists: () => (/* binding */ nestLists),\n/* harmony export */   sortMarksByOccurences: () => (/* binding */ sortMarksByOccurences),\n/* harmony export */   spanToPlainText: () => (/* binding */ spanToPlainText),\n/* harmony export */   toPlainText: () => (/* binding */ toPlainText)\n/* harmony export */ });\nfunction isPortableTextSpan(node) {\n  return node._type === \"span\" && \"text\" in node && typeof node.text == \"string\" && (typeof node.marks > \"u\" || Array.isArray(node.marks) && node.marks.every((mark) => typeof mark == \"string\"));\n}\nfunction isPortableTextBlock(node) {\n  return (\n    // A block doesn't _have_ to be named 'block' - to differentiate between\n    // allowed child types and marks, one might name them differently\n    typeof node._type == \"string\" && // Toolkit-types like nested spans are @-prefixed\n    node._type[0] !== \"@\" && // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\n    (!(\"markDefs\" in node) || !node.markDefs || Array.isArray(node.markDefs) && // Every mark definition needs to have an `_key` to be mappable in child spans\n    node.markDefs.every((def) => typeof def._key == \"string\")) && // `children` is required and needs to be an array\n    \"children\" in node && Array.isArray(node.children) && // All children are objects with `_type` (usually spans, but can contain other stuff)\n    node.children.every((child) => typeof child == \"object\" && \"_type\" in child)\n  );\n}\nfunction isPortableTextListItemBlock(block) {\n  return isPortableTextBlock(block) && \"listItem\" in block && typeof block.listItem == \"string\" && (typeof block.level > \"u\" || typeof block.level == \"number\");\n}\nfunction isPortableTextToolkitList(block) {\n  return block._type === \"@list\";\n}\nfunction isPortableTextToolkitSpan(span) {\n  return span._type === \"@span\";\n}\nfunction isPortableTextToolkitTextNode(node) {\n  return node._type === \"@text\";\n}\nconst knownDecorators = [\"strong\", \"em\", \"code\", \"underline\", \"strike-through\"];\nfunction sortMarksByOccurences(span, index, blockChildren) {\n  if (!isPortableTextSpan(span) || !span.marks)\n    return [];\n  if (!span.marks.length)\n    return [];\n  const marks = span.marks.slice(), occurences = {};\n  return marks.forEach((mark) => {\n    occurences[mark] = 1;\n    for (let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++) {\n      const sibling = blockChildren[siblingIndex];\n      if (sibling && isPortableTextSpan(sibling) && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1)\n        occurences[mark]++;\n      else\n        break;\n    }\n  }), marks.sort((markA, markB) => sortMarks(occurences, markA, markB));\n}\nfunction sortMarks(occurences, markA, markB) {\n  const aOccurences = occurences[markA], bOccurences = occurences[markB];\n  if (aOccurences !== bOccurences)\n    return bOccurences - aOccurences;\n  const aKnownPos = knownDecorators.indexOf(markA), bKnownPos = knownDecorators.indexOf(markB);\n  return aKnownPos !== bKnownPos ? aKnownPos - bKnownPos : markA.localeCompare(markB);\n}\nfunction buildMarksTree(block) {\n  var _a;\n  const { children } = block, markDefs = block.markDefs ?? [];\n  if (!children || !children.length)\n    return [];\n  const sortedMarks = children.map(sortMarksByOccurences), rootNode = {\n    _type: \"@span\",\n    children: [],\n    markType: \"<unknown>\"\n  };\n  let nodeStack = [rootNode];\n  for (let i = 0; i < children.length; i++) {\n    const span = children[i];\n    if (!span)\n      continue;\n    const marksNeeded = sortedMarks[i] || [];\n    let pos = 1;\n    if (nodeStack.length > 1)\n      for (pos; pos < nodeStack.length; pos++) {\n        const mark = ((_a = nodeStack[pos]) == null ? void 0 : _a.markKey) || \"\", index = marksNeeded.indexOf(mark);\n        if (index === -1)\n          break;\n        marksNeeded.splice(index, 1);\n      }\n    nodeStack = nodeStack.slice(0, pos);\n    let currentNode = nodeStack[nodeStack.length - 1];\n    if (currentNode) {\n      for (const markKey of marksNeeded) {\n        const markDef = markDefs == null ? void 0 : markDefs.find((def) => def._key === markKey), markType = markDef ? markDef._type : markKey, node = {\n          _type: \"@span\",\n          _key: span._key,\n          children: [],\n          markDef,\n          markType,\n          markKey\n        };\n        currentNode.children.push(node), nodeStack.push(node), currentNode = node;\n      }\n      if (isPortableTextSpan(span)) {\n        const lines = span.text.split(`\n`);\n        for (let line = lines.length; line-- > 1; )\n          lines.splice(line, 0, `\n`);\n        currentNode.children = currentNode.children.concat(\n          lines.map((text) => ({ _type: \"@text\", text }))\n        );\n      } else\n        currentNode.children = currentNode.children.concat(span);\n    }\n  }\n  return rootNode.children;\n}\nfunction nestLists(blocks, mode) {\n  const tree = [];\n  let currentList;\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i];\n    if (block) {\n      if (!isPortableTextListItemBlock(block)) {\n        tree.push(block), currentList = void 0;\n        continue;\n      }\n      if (!currentList) {\n        currentList = listFromBlock(block, i, mode), tree.push(currentList);\n        continue;\n      }\n      if (blockMatchesList(block, currentList)) {\n        currentList.children.push(block);\n        continue;\n      }\n      if ((block.level || 1) > currentList.level) {\n        const newList = listFromBlock(block, i, mode);\n        if (mode === \"html\") {\n          const lastListItem = currentList.children[currentList.children.length - 1], newLastChild = {\n            ...lastListItem,\n            children: [...lastListItem.children, newList]\n          };\n          currentList.children[currentList.children.length - 1] = newLastChild;\n        } else\n          currentList.children.push(\n            newList\n          );\n        currentList = newList;\n        continue;\n      }\n      if ((block.level || 1) < currentList.level) {\n        const matchingBranch = tree[tree.length - 1], match = matchingBranch && findListMatching(matchingBranch, block);\n        if (match) {\n          currentList = match, currentList.children.push(block);\n          continue;\n        }\n        currentList = listFromBlock(block, i, mode), tree.push(currentList);\n        continue;\n      }\n      if (block.listItem !== currentList.listItem) {\n        const matchingBranch = tree[tree.length - 1], match = matchingBranch && findListMatching(matchingBranch, { level: block.level || 1 });\n        if (match && match.listItem === block.listItem) {\n          currentList = match, currentList.children.push(block);\n          continue;\n        } else {\n          currentList = listFromBlock(block, i, mode), tree.push(currentList);\n          continue;\n        }\n      }\n      console.warn(\"Unknown state encountered for block\", block), tree.push(block);\n    }\n  }\n  return tree;\n}\nfunction blockMatchesList(block, list) {\n  return (block.level || 1) === list.level && block.listItem === list.listItem;\n}\nfunction listFromBlock(block, index, mode) {\n  return {\n    _type: \"@list\",\n    _key: `${block._key || `${index}`}-parent`,\n    mode,\n    level: block.level || 1,\n    listItem: block.listItem,\n    children: [block]\n  };\n}\nfunction findListMatching(rootNode, matching) {\n  const level = matching.level || 1, style = matching.listItem || \"normal\", filterOnType = typeof matching.listItem == \"string\";\n  if (isPortableTextToolkitList(rootNode) && (rootNode.level || 1) === level && filterOnType && (rootNode.listItem || \"normal\") === style)\n    return rootNode;\n  if (!(\"children\" in rootNode))\n    return;\n  const node = rootNode.children[rootNode.children.length - 1];\n  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : void 0;\n}\nfunction spanToPlainText(span) {\n  let text = \"\";\n  return span.children.forEach((current) => {\n    isPortableTextToolkitTextNode(current) ? text += current.text : isPortableTextToolkitSpan(current) && (text += spanToPlainText(current));\n  }), text;\n}\nconst leadingSpace = /^\\s/, trailingSpace = /\\s$/;\nfunction toPlainText(block) {\n  const blocks = Array.isArray(block) ? block : [block];\n  let text = \"\";\n  return blocks.forEach((current, index) => {\n    if (!isPortableTextBlock(current))\n      return;\n    let pad = !1;\n    current.children.forEach((span) => {\n      isPortableTextSpan(span) ? (text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? \" \" : \"\", text += span.text, pad = !1) : pad = !0;\n    }), index !== blocks.length - 1 && (text += `\n\n`);\n  }), text;\n}\nconst LIST_NEST_MODE_HTML = \"html\", LIST_NEST_MODE_DIRECT = \"direct\";\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvdG9vbGtpdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMscUNBQXFDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsV0FBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHNCQUFzQjtBQUN2RDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1IQUFtSCx5QkFBeUI7QUFDNUk7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCLE1BQU0sRUFBRTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBZUU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL0dhbG9jay9DUy9iZWhvbWUtc2l0ZS9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC90b29sa2l0L2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gaXNQb3J0YWJsZVRleHRTcGFuKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX3R5cGUgPT09IFwic3BhblwiICYmIFwidGV4dFwiIGluIG5vZGUgJiYgdHlwZW9mIG5vZGUudGV4dCA9PSBcInN0cmluZ1wiICYmICh0eXBlb2Ygbm9kZS5tYXJrcyA+IFwidVwiIHx8IEFycmF5LmlzQXJyYXkobm9kZS5tYXJrcykgJiYgbm9kZS5tYXJrcy5ldmVyeSgobWFyaykgPT4gdHlwZW9mIG1hcmsgPT0gXCJzdHJpbmdcIikpO1xufVxuZnVuY3Rpb24gaXNQb3J0YWJsZVRleHRCbG9jayhub2RlKSB7XG4gIHJldHVybiAoXG4gICAgLy8gQSBibG9jayBkb2Vzbid0IF9oYXZlXyB0byBiZSBuYW1lZCAnYmxvY2snIC0gdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuXG4gICAgLy8gYWxsb3dlZCBjaGlsZCB0eXBlcyBhbmQgbWFya3MsIG9uZSBtaWdodCBuYW1lIHRoZW0gZGlmZmVyZW50bHlcbiAgICB0eXBlb2Ygbm9kZS5fdHlwZSA9PSBcInN0cmluZ1wiICYmIC8vIFRvb2xraXQtdHlwZXMgbGlrZSBuZXN0ZWQgc3BhbnMgYXJlIEAtcHJlZml4ZWRcbiAgICBub2RlLl90eXBlWzBdICE9PSBcIkBcIiAmJiAvLyBgbWFya0RlZnNgIGlzbid0IF9yZXF1aXJlZF8gcGVyIHNheSwgYnV0IGlmIGl0J3MgdGhlcmUsIGl0IG5lZWRzIHRvIGJlIGFuIGFycmF5XG4gICAgKCEoXCJtYXJrRGVmc1wiIGluIG5vZGUpIHx8ICFub2RlLm1hcmtEZWZzIHx8IEFycmF5LmlzQXJyYXkobm9kZS5tYXJrRGVmcykgJiYgLy8gRXZlcnkgbWFyayBkZWZpbml0aW9uIG5lZWRzIHRvIGhhdmUgYW4gYF9rZXlgIHRvIGJlIG1hcHBhYmxlIGluIGNoaWxkIHNwYW5zXG4gICAgbm9kZS5tYXJrRGVmcy5ldmVyeSgoZGVmKSA9PiB0eXBlb2YgZGVmLl9rZXkgPT0gXCJzdHJpbmdcIikpICYmIC8vIGBjaGlsZHJlbmAgaXMgcmVxdWlyZWQgYW5kIG5lZWRzIHRvIGJlIGFuIGFycmF5XG4gICAgXCJjaGlsZHJlblwiIGluIG5vZGUgJiYgQXJyYXkuaXNBcnJheShub2RlLmNoaWxkcmVuKSAmJiAvLyBBbGwgY2hpbGRyZW4gYXJlIG9iamVjdHMgd2l0aCBgX3R5cGVgICh1c3VhbGx5IHNwYW5zLCBidXQgY2FuIGNvbnRhaW4gb3RoZXIgc3R1ZmYpXG4gICAgbm9kZS5jaGlsZHJlbi5ldmVyeSgoY2hpbGQpID0+IHR5cGVvZiBjaGlsZCA9PSBcIm9iamVjdFwiICYmIFwiX3R5cGVcIiBpbiBjaGlsZClcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0TGlzdEl0ZW1CbG9jayhibG9jaykge1xuICByZXR1cm4gaXNQb3J0YWJsZVRleHRCbG9jayhibG9jaykgJiYgXCJsaXN0SXRlbVwiIGluIGJsb2NrICYmIHR5cGVvZiBibG9jay5saXN0SXRlbSA9PSBcInN0cmluZ1wiICYmICh0eXBlb2YgYmxvY2subGV2ZWwgPiBcInVcIiB8fCB0eXBlb2YgYmxvY2subGV2ZWwgPT0gXCJudW1iZXJcIik7XG59XG5mdW5jdGlvbiBpc1BvcnRhYmxlVGV4dFRvb2xraXRMaXN0KGJsb2NrKSB7XG4gIHJldHVybiBibG9jay5fdHlwZSA9PT0gXCJAbGlzdFwiO1xufVxuZnVuY3Rpb24gaXNQb3J0YWJsZVRleHRUb29sa2l0U3BhbihzcGFuKSB7XG4gIHJldHVybiBzcGFuLl90eXBlID09PSBcIkBzcGFuXCI7XG59XG5mdW5jdGlvbiBpc1BvcnRhYmxlVGV4dFRvb2xraXRUZXh0Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlLl90eXBlID09PSBcIkB0ZXh0XCI7XG59XG5jb25zdCBrbm93bkRlY29yYXRvcnMgPSBbXCJzdHJvbmdcIiwgXCJlbVwiLCBcImNvZGVcIiwgXCJ1bmRlcmxpbmVcIiwgXCJzdHJpa2UtdGhyb3VnaFwiXTtcbmZ1bmN0aW9uIHNvcnRNYXJrc0J5T2NjdXJlbmNlcyhzcGFuLCBpbmRleCwgYmxvY2tDaGlsZHJlbikge1xuICBpZiAoIWlzUG9ydGFibGVUZXh0U3BhbihzcGFuKSB8fCAhc3Bhbi5tYXJrcylcbiAgICByZXR1cm4gW107XG4gIGlmICghc3Bhbi5tYXJrcy5sZW5ndGgpXG4gICAgcmV0dXJuIFtdO1xuICBjb25zdCBtYXJrcyA9IHNwYW4ubWFya3Muc2xpY2UoKSwgb2NjdXJlbmNlcyA9IHt9O1xuICByZXR1cm4gbWFya3MuZm9yRWFjaCgobWFyaykgPT4ge1xuICAgIG9jY3VyZW5jZXNbbWFya10gPSAxO1xuICAgIGZvciAobGV0IHNpYmxpbmdJbmRleCA9IGluZGV4ICsgMTsgc2libGluZ0luZGV4IDwgYmxvY2tDaGlsZHJlbi5sZW5ndGg7IHNpYmxpbmdJbmRleCsrKSB7XG4gICAgICBjb25zdCBzaWJsaW5nID0gYmxvY2tDaGlsZHJlbltzaWJsaW5nSW5kZXhdO1xuICAgICAgaWYgKHNpYmxpbmcgJiYgaXNQb3J0YWJsZVRleHRTcGFuKHNpYmxpbmcpICYmIEFycmF5LmlzQXJyYXkoc2libGluZy5tYXJrcykgJiYgc2libGluZy5tYXJrcy5pbmRleE9mKG1hcmspICE9PSAtMSlcbiAgICAgICAgb2NjdXJlbmNlc1ttYXJrXSsrO1xuICAgICAgZWxzZVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0pLCBtYXJrcy5zb3J0KChtYXJrQSwgbWFya0IpID0+IHNvcnRNYXJrcyhvY2N1cmVuY2VzLCBtYXJrQSwgbWFya0IpKTtcbn1cbmZ1bmN0aW9uIHNvcnRNYXJrcyhvY2N1cmVuY2VzLCBtYXJrQSwgbWFya0IpIHtcbiAgY29uc3QgYU9jY3VyZW5jZXMgPSBvY2N1cmVuY2VzW21hcmtBXSwgYk9jY3VyZW5jZXMgPSBvY2N1cmVuY2VzW21hcmtCXTtcbiAgaWYgKGFPY2N1cmVuY2VzICE9PSBiT2NjdXJlbmNlcylcbiAgICByZXR1cm4gYk9jY3VyZW5jZXMgLSBhT2NjdXJlbmNlcztcbiAgY29uc3QgYUtub3duUG9zID0ga25vd25EZWNvcmF0b3JzLmluZGV4T2YobWFya0EpLCBiS25vd25Qb3MgPSBrbm93bkRlY29yYXRvcnMuaW5kZXhPZihtYXJrQik7XG4gIHJldHVybiBhS25vd25Qb3MgIT09IGJLbm93blBvcyA/IGFLbm93blBvcyAtIGJLbm93blBvcyA6IG1hcmtBLmxvY2FsZUNvbXBhcmUobWFya0IpO1xufVxuZnVuY3Rpb24gYnVpbGRNYXJrc1RyZWUoYmxvY2spIHtcbiAgdmFyIF9hO1xuICBjb25zdCB7IGNoaWxkcmVuIH0gPSBibG9jaywgbWFya0RlZnMgPSBibG9jay5tYXJrRGVmcyA/PyBbXTtcbiAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3Qgc29ydGVkTWFya3MgPSBjaGlsZHJlbi5tYXAoc29ydE1hcmtzQnlPY2N1cmVuY2VzKSwgcm9vdE5vZGUgPSB7XG4gICAgX3R5cGU6IFwiQHNwYW5cIixcbiAgICBjaGlsZHJlbjogW10sXG4gICAgbWFya1R5cGU6IFwiPHVua25vd24+XCJcbiAgfTtcbiAgbGV0IG5vZGVTdGFjayA9IFtyb290Tm9kZV07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzcGFuID0gY2hpbGRyZW5baV07XG4gICAgaWYgKCFzcGFuKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgbWFya3NOZWVkZWQgPSBzb3J0ZWRNYXJrc1tpXSB8fCBbXTtcbiAgICBsZXQgcG9zID0gMTtcbiAgICBpZiAobm9kZVN0YWNrLmxlbmd0aCA+IDEpXG4gICAgICBmb3IgKHBvczsgcG9zIDwgbm9kZVN0YWNrLmxlbmd0aDsgcG9zKyspIHtcbiAgICAgICAgY29uc3QgbWFyayA9ICgoX2EgPSBub2RlU3RhY2tbcG9zXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm1hcmtLZXkpIHx8IFwiXCIsIGluZGV4ID0gbWFya3NOZWVkZWQuaW5kZXhPZihtYXJrKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgbWFya3NOZWVkZWQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICBub2RlU3RhY2sgPSBub2RlU3RhY2suc2xpY2UoMCwgcG9zKTtcbiAgICBsZXQgY3VycmVudE5vZGUgPSBub2RlU3RhY2tbbm9kZVN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGlmIChjdXJyZW50Tm9kZSkge1xuICAgICAgZm9yIChjb25zdCBtYXJrS2V5IG9mIG1hcmtzTmVlZGVkKSB7XG4gICAgICAgIGNvbnN0IG1hcmtEZWYgPSBtYXJrRGVmcyA9PSBudWxsID8gdm9pZCAwIDogbWFya0RlZnMuZmluZCgoZGVmKSA9PiBkZWYuX2tleSA9PT0gbWFya0tleSksIG1hcmtUeXBlID0gbWFya0RlZiA/IG1hcmtEZWYuX3R5cGUgOiBtYXJrS2V5LCBub2RlID0ge1xuICAgICAgICAgIF90eXBlOiBcIkBzcGFuXCIsXG4gICAgICAgICAgX2tleTogc3Bhbi5fa2V5LFxuICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICBtYXJrRGVmLFxuICAgICAgICAgIG1hcmtUeXBlLFxuICAgICAgICAgIG1hcmtLZXlcbiAgICAgICAgfTtcbiAgICAgICAgY3VycmVudE5vZGUuY2hpbGRyZW4ucHVzaChub2RlKSwgbm9kZVN0YWNrLnB1c2gobm9kZSksIGN1cnJlbnROb2RlID0gbm9kZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1BvcnRhYmxlVGV4dFNwYW4oc3BhbikpIHtcbiAgICAgICAgY29uc3QgbGluZXMgPSBzcGFuLnRleHQuc3BsaXQoYFxuYCk7XG4gICAgICAgIGZvciAobGV0IGxpbmUgPSBsaW5lcy5sZW5ndGg7IGxpbmUtLSA+IDE7IClcbiAgICAgICAgICBsaW5lcy5zcGxpY2UobGluZSwgMCwgYFxuYCk7XG4gICAgICAgIGN1cnJlbnROb2RlLmNoaWxkcmVuID0gY3VycmVudE5vZGUuY2hpbGRyZW4uY29uY2F0KFxuICAgICAgICAgIGxpbmVzLm1hcCgodGV4dCkgPT4gKHsgX3R5cGU6IFwiQHRleHRcIiwgdGV4dCB9KSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBjdXJyZW50Tm9kZS5jaGlsZHJlbiA9IGN1cnJlbnROb2RlLmNoaWxkcmVuLmNvbmNhdChzcGFuKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJvb3ROb2RlLmNoaWxkcmVuO1xufVxuZnVuY3Rpb24gbmVzdExpc3RzKGJsb2NrcywgbW9kZSkge1xuICBjb25zdCB0cmVlID0gW107XG4gIGxldCBjdXJyZW50TGlzdDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBibG9jayA9IGJsb2Nrc1tpXTtcbiAgICBpZiAoYmxvY2spIHtcbiAgICAgIGlmICghaXNQb3J0YWJsZVRleHRMaXN0SXRlbUJsb2NrKGJsb2NrKSkge1xuICAgICAgICB0cmVlLnB1c2goYmxvY2spLCBjdXJyZW50TGlzdCA9IHZvaWQgMDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIWN1cnJlbnRMaXN0KSB7XG4gICAgICAgIGN1cnJlbnRMaXN0ID0gbGlzdEZyb21CbG9jayhibG9jaywgaSwgbW9kZSksIHRyZWUucHVzaChjdXJyZW50TGlzdCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGJsb2NrTWF0Y2hlc0xpc3QoYmxvY2ssIGN1cnJlbnRMaXN0KSkge1xuICAgICAgICBjdXJyZW50TGlzdC5jaGlsZHJlbi5wdXNoKGJsb2NrKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoKGJsb2NrLmxldmVsIHx8IDEpID4gY3VycmVudExpc3QubGV2ZWwpIHtcbiAgICAgICAgY29uc3QgbmV3TGlzdCA9IGxpc3RGcm9tQmxvY2soYmxvY2ssIGksIG1vZGUpO1xuICAgICAgICBpZiAobW9kZSA9PT0gXCJodG1sXCIpIHtcbiAgICAgICAgICBjb25zdCBsYXN0TGlzdEl0ZW0gPSBjdXJyZW50TGlzdC5jaGlsZHJlbltjdXJyZW50TGlzdC5jaGlsZHJlbi5sZW5ndGggLSAxXSwgbmV3TGFzdENoaWxkID0ge1xuICAgICAgICAgICAgLi4ubGFzdExpc3RJdGVtLFxuICAgICAgICAgICAgY2hpbGRyZW46IFsuLi5sYXN0TGlzdEl0ZW0uY2hpbGRyZW4sIG5ld0xpc3RdXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjdXJyZW50TGlzdC5jaGlsZHJlbltjdXJyZW50TGlzdC5jaGlsZHJlbi5sZW5ndGggLSAxXSA9IG5ld0xhc3RDaGlsZDtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgY3VycmVudExpc3QuY2hpbGRyZW4ucHVzaChcbiAgICAgICAgICAgIG5ld0xpc3RcbiAgICAgICAgICApO1xuICAgICAgICBjdXJyZW50TGlzdCA9IG5ld0xpc3Q7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKChibG9jay5sZXZlbCB8fCAxKSA8IGN1cnJlbnRMaXN0LmxldmVsKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nQnJhbmNoID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdLCBtYXRjaCA9IG1hdGNoaW5nQnJhbmNoICYmIGZpbmRMaXN0TWF0Y2hpbmcobWF0Y2hpbmdCcmFuY2gsIGJsb2NrKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgY3VycmVudExpc3QgPSBtYXRjaCwgY3VycmVudExpc3QuY2hpbGRyZW4ucHVzaChibG9jayk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudExpc3QgPSBsaXN0RnJvbUJsb2NrKGJsb2NrLCBpLCBtb2RlKSwgdHJlZS5wdXNoKGN1cnJlbnRMaXN0KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoYmxvY2subGlzdEl0ZW0gIT09IGN1cnJlbnRMaXN0Lmxpc3RJdGVtKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nQnJhbmNoID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdLCBtYXRjaCA9IG1hdGNoaW5nQnJhbmNoICYmIGZpbmRMaXN0TWF0Y2hpbmcobWF0Y2hpbmdCcmFuY2gsIHsgbGV2ZWw6IGJsb2NrLmxldmVsIHx8IDEgfSk7XG4gICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5saXN0SXRlbSA9PT0gYmxvY2subGlzdEl0ZW0pIHtcbiAgICAgICAgICBjdXJyZW50TGlzdCA9IG1hdGNoLCBjdXJyZW50TGlzdC5jaGlsZHJlbi5wdXNoKGJsb2NrKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50TGlzdCA9IGxpc3RGcm9tQmxvY2soYmxvY2ssIGksIG1vZGUpLCB0cmVlLnB1c2goY3VycmVudExpc3QpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zb2xlLndhcm4oXCJVbmtub3duIHN0YXRlIGVuY291bnRlcmVkIGZvciBibG9ja1wiLCBibG9jayksIHRyZWUucHVzaChibG9jayk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cmVlO1xufVxuZnVuY3Rpb24gYmxvY2tNYXRjaGVzTGlzdChibG9jaywgbGlzdCkge1xuICByZXR1cm4gKGJsb2NrLmxldmVsIHx8IDEpID09PSBsaXN0LmxldmVsICYmIGJsb2NrLmxpc3RJdGVtID09PSBsaXN0Lmxpc3RJdGVtO1xufVxuZnVuY3Rpb24gbGlzdEZyb21CbG9jayhibG9jaywgaW5kZXgsIG1vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICBfdHlwZTogXCJAbGlzdFwiLFxuICAgIF9rZXk6IGAke2Jsb2NrLl9rZXkgfHwgYCR7aW5kZXh9YH0tcGFyZW50YCxcbiAgICBtb2RlLFxuICAgIGxldmVsOiBibG9jay5sZXZlbCB8fCAxLFxuICAgIGxpc3RJdGVtOiBibG9jay5saXN0SXRlbSxcbiAgICBjaGlsZHJlbjogW2Jsb2NrXVxuICB9O1xufVxuZnVuY3Rpb24gZmluZExpc3RNYXRjaGluZyhyb290Tm9kZSwgbWF0Y2hpbmcpIHtcbiAgY29uc3QgbGV2ZWwgPSBtYXRjaGluZy5sZXZlbCB8fCAxLCBzdHlsZSA9IG1hdGNoaW5nLmxpc3RJdGVtIHx8IFwibm9ybWFsXCIsIGZpbHRlck9uVHlwZSA9IHR5cGVvZiBtYXRjaGluZy5saXN0SXRlbSA9PSBcInN0cmluZ1wiO1xuICBpZiAoaXNQb3J0YWJsZVRleHRUb29sa2l0TGlzdChyb290Tm9kZSkgJiYgKHJvb3ROb2RlLmxldmVsIHx8IDEpID09PSBsZXZlbCAmJiBmaWx0ZXJPblR5cGUgJiYgKHJvb3ROb2RlLmxpc3RJdGVtIHx8IFwibm9ybWFsXCIpID09PSBzdHlsZSlcbiAgICByZXR1cm4gcm9vdE5vZGU7XG4gIGlmICghKFwiY2hpbGRyZW5cIiBpbiByb290Tm9kZSkpXG4gICAgcmV0dXJuO1xuICBjb25zdCBub2RlID0gcm9vdE5vZGUuY2hpbGRyZW5bcm9vdE5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gIHJldHVybiBub2RlICYmICFpc1BvcnRhYmxlVGV4dFNwYW4obm9kZSkgPyBmaW5kTGlzdE1hdGNoaW5nKG5vZGUsIG1hdGNoaW5nKSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHNwYW5Ub1BsYWluVGV4dChzcGFuKSB7XG4gIGxldCB0ZXh0ID0gXCJcIjtcbiAgcmV0dXJuIHNwYW4uY2hpbGRyZW4uZm9yRWFjaCgoY3VycmVudCkgPT4ge1xuICAgIGlzUG9ydGFibGVUZXh0VG9vbGtpdFRleHROb2RlKGN1cnJlbnQpID8gdGV4dCArPSBjdXJyZW50LnRleHQgOiBpc1BvcnRhYmxlVGV4dFRvb2xraXRTcGFuKGN1cnJlbnQpICYmICh0ZXh0ICs9IHNwYW5Ub1BsYWluVGV4dChjdXJyZW50KSk7XG4gIH0pLCB0ZXh0O1xufVxuY29uc3QgbGVhZGluZ1NwYWNlID0gL15cXHMvLCB0cmFpbGluZ1NwYWNlID0gL1xccyQvO1xuZnVuY3Rpb24gdG9QbGFpblRleHQoYmxvY2spIHtcbiAgY29uc3QgYmxvY2tzID0gQXJyYXkuaXNBcnJheShibG9jaykgPyBibG9jayA6IFtibG9ja107XG4gIGxldCB0ZXh0ID0gXCJcIjtcbiAgcmV0dXJuIGJsb2Nrcy5mb3JFYWNoKChjdXJyZW50LCBpbmRleCkgPT4ge1xuICAgIGlmICghaXNQb3J0YWJsZVRleHRCbG9jayhjdXJyZW50KSlcbiAgICAgIHJldHVybjtcbiAgICBsZXQgcGFkID0gITE7XG4gICAgY3VycmVudC5jaGlsZHJlbi5mb3JFYWNoKChzcGFuKSA9PiB7XG4gICAgICBpc1BvcnRhYmxlVGV4dFNwYW4oc3BhbikgPyAodGV4dCArPSBwYWQgJiYgdGV4dCAmJiAhdHJhaWxpbmdTcGFjZS50ZXN0KHRleHQpICYmICFsZWFkaW5nU3BhY2UudGVzdChzcGFuLnRleHQpID8gXCIgXCIgOiBcIlwiLCB0ZXh0ICs9IHNwYW4udGV4dCwgcGFkID0gITEpIDogcGFkID0gITA7XG4gICAgfSksIGluZGV4ICE9PSBibG9ja3MubGVuZ3RoIC0gMSAmJiAodGV4dCArPSBgXG5cbmApO1xuICB9KSwgdGV4dDtcbn1cbmNvbnN0IExJU1RfTkVTVF9NT0RFX0hUTUwgPSBcImh0bWxcIiwgTElTVF9ORVNUX01PREVfRElSRUNUID0gXCJkaXJlY3RcIjtcbmV4cG9ydCB7XG4gIExJU1RfTkVTVF9NT0RFX0RJUkVDVCxcbiAgTElTVF9ORVNUX01PREVfSFRNTCxcbiAgYnVpbGRNYXJrc1RyZWUsXG4gIGlzUG9ydGFibGVUZXh0QmxvY2ssXG4gIGlzUG9ydGFibGVUZXh0TGlzdEl0ZW1CbG9jayxcbiAgaXNQb3J0YWJsZVRleHRTcGFuLFxuICBpc1BvcnRhYmxlVGV4dFRvb2xraXRMaXN0LFxuICBpc1BvcnRhYmxlVGV4dFRvb2xraXRTcGFuLFxuICBpc1BvcnRhYmxlVGV4dFRvb2xraXRUZXh0Tm9kZSxcbiAgbmVzdExpc3RzLFxuICBzb3J0TWFya3NCeU9jY3VyZW5jZXMsXG4gIHNwYW5Ub1BsYWluVGV4dCxcbiAgdG9QbGFpblRleHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@portabletext/toolkit/dist/index.js\n");

/***/ })

};
;