"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/slate";
exports.ids = ["vendor-chunks/slate"];
exports.modules = {

/***/ "(ssr)/../node_modules/slate/dist/index.es.js":
/*!**********************************************!*\
  !*** ../node_modules/slate/dist/index.es.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Editor: () => (/* binding */ Editor),\n/* harmony export */   Element: () => (/* binding */ Element),\n/* harmony export */   Location: () => (/* binding */ Location),\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   Operation: () => (/* binding */ Operation),\n/* harmony export */   Path: () => (/* binding */ Path),\n/* harmony export */   PathRef: () => (/* binding */ PathRef),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   PointRef: () => (/* binding */ PointRef),\n/* harmony export */   Range: () => (/* binding */ Range),\n/* harmony export */   RangeRef: () => (/* binding */ RangeRef),\n/* harmony export */   Scrubber: () => (/* binding */ Scrubber),\n/* harmony export */   Span: () => (/* binding */ Span),\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   Transforms: () => (/* binding */ Transforms),\n/* harmony export */   above: () => (/* binding */ above),\n/* harmony export */   addMark: () => (/* binding */ addMark),\n/* harmony export */   after: () => (/* binding */ after),\n/* harmony export */   apply: () => (/* binding */ apply),\n/* harmony export */   before: () => (/* binding */ before),\n/* harmony export */   collapse: () => (/* binding */ collapse),\n/* harmony export */   createEditor: () => (/* binding */ createEditor),\n/* harmony export */   deleteBackward: () => (/* binding */ deleteBackward),\n/* harmony export */   deleteForward: () => (/* binding */ deleteForward),\n/* harmony export */   deleteFragment: () => (/* binding */ deleteFragment),\n/* harmony export */   deleteText: () => (/* binding */ deleteText),\n/* harmony export */   deselect: () => (/* binding */ deselect),\n/* harmony export */   edges: () => (/* binding */ edges),\n/* harmony export */   elementReadOnly: () => (/* binding */ elementReadOnly),\n/* harmony export */   end: () => (/* binding */ end),\n/* harmony export */   first: () => (/* binding */ first),\n/* harmony export */   fragment: () => (/* binding */ fragment),\n/* harmony export */   getDirtyPaths: () => (/* binding */ getDirtyPaths),\n/* harmony export */   getFragment: () => (/* binding */ getFragment),\n/* harmony export */   getVoid: () => (/* binding */ getVoid),\n/* harmony export */   hasBlocks: () => (/* binding */ hasBlocks),\n/* harmony export */   hasInlines: () => (/* binding */ hasInlines),\n/* harmony export */   hasPath: () => (/* binding */ hasPath),\n/* harmony export */   hasTexts: () => (/* binding */ hasTexts),\n/* harmony export */   insertBreak: () => (/* binding */ insertBreak),\n/* harmony export */   insertFragment: () => (/* binding */ insertFragment),\n/* harmony export */   insertNode: () => (/* binding */ insertNode),\n/* harmony export */   insertNodes: () => (/* binding */ insertNodes),\n/* harmony export */   insertSoftBreak: () => (/* binding */ insertSoftBreak),\n/* harmony export */   insertText: () => (/* binding */ insertText),\n/* harmony export */   isBlock: () => (/* binding */ isBlock),\n/* harmony export */   isEdge: () => (/* binding */ isEdge),\n/* harmony export */   isEditor: () => (/* binding */ isEditor),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   isEnd: () => (/* binding */ isEnd),\n/* harmony export */   isNormalizing: () => (/* binding */ isNormalizing),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isStart: () => (/* binding */ isStart),\n/* harmony export */   last: () => (/* binding */ last),\n/* harmony export */   leaf: () => (/* binding */ leaf),\n/* harmony export */   levels: () => (/* binding */ levels),\n/* harmony export */   liftNodes: () => (/* binding */ liftNodes),\n/* harmony export */   marks: () => (/* binding */ marks),\n/* harmony export */   mergeNodes: () => (/* binding */ mergeNodes),\n/* harmony export */   move: () => (/* binding */ move),\n/* harmony export */   moveNodes: () => (/* binding */ moveNodes),\n/* harmony export */   next: () => (/* binding */ next),\n/* harmony export */   node: () => (/* binding */ node),\n/* harmony export */   nodes: () => (/* binding */ nodes),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   normalizeNode: () => (/* binding */ normalizeNode),\n/* harmony export */   parent: () => (/* binding */ parent),\n/* harmony export */   path: () => (/* binding */ path),\n/* harmony export */   pathRef: () => (/* binding */ pathRef),\n/* harmony export */   pathRefs: () => (/* binding */ pathRefs),\n/* harmony export */   point: () => (/* binding */ point),\n/* harmony export */   pointRef: () => (/* binding */ pointRef),\n/* harmony export */   pointRefs: () => (/* binding */ pointRefs),\n/* harmony export */   positions: () => (/* binding */ positions),\n/* harmony export */   previous: () => (/* binding */ previous),\n/* harmony export */   range: () => (/* binding */ range),\n/* harmony export */   rangeRef: () => (/* binding */ rangeRef),\n/* harmony export */   rangeRefs: () => (/* binding */ rangeRefs),\n/* harmony export */   removeMark: () => (/* binding */ removeMark),\n/* harmony export */   removeNodes: () => (/* binding */ removeNodes),\n/* harmony export */   select: () => (/* binding */ select),\n/* harmony export */   setNodes: () => (/* binding */ setNodes),\n/* harmony export */   setNormalizing: () => (/* binding */ setNormalizing),\n/* harmony export */   setPoint: () => (/* binding */ setPoint),\n/* harmony export */   setSelection: () => (/* binding */ setSelection),\n/* harmony export */   shouldMergeNodesRemovePrevNode: () => (/* binding */ shouldMergeNodesRemovePrevNode),\n/* harmony export */   shouldNormalize: () => (/* binding */ shouldNormalize),\n/* harmony export */   splitNodes: () => (/* binding */ splitNodes),\n/* harmony export */   start: () => (/* binding */ start),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   unhangRange: () => (/* binding */ unhangRange),\n/* harmony export */   unsetNodes: () => (/* binding */ unsetNodes),\n/* harmony export */   unwrapNodes: () => (/* binding */ unwrapNodes),\n/* harmony export */   withoutNormalizing: () => (/* binding */ withoutNormalizing),\n/* harmony export */   wrapNodes: () => (/* binding */ wrapNodes)\n/* harmony export */ });\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! immer */ \"(ssr)/../node_modules/immer/dist/immer.mjs\");\n\n\n// eslint-disable-next-line no-redeclare\nvar PathRef = {\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n    if (current == null) {\n      return;\n    }\n    var path = Path.transform(current, op, {\n      affinity\n    });\n    ref.current = path;\n    if (path == null) {\n      ref.unref();\n    }\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar PointRef = {\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n    if (current == null) {\n      return;\n    }\n    var point = Point.transform(current, op, {\n      affinity\n    });\n    ref.current = point;\n    if (point == null) {\n      ref.unref();\n    }\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar RangeRef = {\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n    if (current == null) {\n      return;\n    }\n    var path = Range.transform(current, op, {\n      affinity\n    });\n    ref.current = path;\n    if (path == null) {\n      ref.unref();\n    }\n  }\n};\n\nvar DIRTY_PATHS = new WeakMap();\nvar DIRTY_PATH_KEYS = new WeakMap();\nvar FLUSHING = new WeakMap();\nvar NORMALIZING = new WeakMap();\nvar PATH_REFS = new WeakMap();\nvar POINT_REFS = new WeakMap();\nvar RANGE_REFS = new WeakMap();\n\n// eslint-disable-next-line no-redeclare\nvar Path = {\n  ancestors(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var paths = Path.levels(path, options);\n    if (reverse) {\n      paths = paths.slice(1);\n    } else {\n      paths = paths.slice(0, -1);\n    }\n    return paths;\n  },\n  common(path, another) {\n    var common = [];\n    for (var i = 0; i < path.length && i < another.length; i++) {\n      var av = path[i];\n      var bv = another[i];\n      if (av !== bv) {\n        break;\n      }\n      common.push(av);\n    }\n    return common;\n  },\n  compare(path, another) {\n    var min = Math.min(path.length, another.length);\n    for (var i = 0; i < min; i++) {\n      if (path[i] < another[i]) return -1;\n      if (path[i] > another[i]) return 1;\n    }\n    return 0;\n  },\n  endsAfter(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av > bv;\n  },\n  endsAt(path, another) {\n    var i = path.length;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    return Path.equals(as, bs);\n  },\n  endsBefore(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av < bv;\n  },\n  equals(path, another) {\n    return path.length === another.length && path.every((n, i) => n === another[i]);\n  },\n  hasPrevious(path) {\n    return path[path.length - 1] > 0;\n  },\n  isAfter(path, another) {\n    return Path.compare(path, another) === 1;\n  },\n  isAncestor(path, another) {\n    return path.length < another.length && Path.compare(path, another) === 0;\n  },\n  isBefore(path, another) {\n    return Path.compare(path, another) === -1;\n  },\n  isChild(path, another) {\n    return path.length === another.length + 1 && Path.compare(path, another) === 0;\n  },\n  isCommon(path, another) {\n    return path.length <= another.length && Path.compare(path, another) === 0;\n  },\n  isDescendant(path, another) {\n    return path.length > another.length && Path.compare(path, another) === 0;\n  },\n  isParent(path, another) {\n    return path.length + 1 === another.length && Path.compare(path, another) === 0;\n  },\n  isPath(value) {\n    return Array.isArray(value) && (value.length === 0 || typeof value[0] === 'number');\n  },\n  isSibling(path, another) {\n    if (path.length !== another.length) {\n      return false;\n    }\n    var as = path.slice(0, -1);\n    var bs = another.slice(0, -1);\n    var al = path[path.length - 1];\n    var bl = another[another.length - 1];\n    return al !== bl && Path.equals(as, bs);\n  },\n  levels(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var list = [];\n    for (var i = 0; i <= path.length; i++) {\n      list.push(path.slice(0, i));\n    }\n    if (reverse) {\n      list.reverse();\n    }\n    return list;\n  },\n  next(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the next path of a root path [\".concat(path, \"], because it has no next index.\"));\n    }\n    var last = path[path.length - 1];\n    return path.slice(0, -1).concat(last + 1);\n  },\n  operationCanTransformPath(operation) {\n    switch (operation.type) {\n      case 'insert_node':\n      case 'remove_node':\n      case 'merge_node':\n      case 'split_node':\n      case 'move_node':\n        return true;\n      default:\n        return false;\n    }\n  },\n  parent(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the parent path of the root path [\".concat(path, \"].\"));\n    }\n    return path.slice(0, -1);\n  },\n  previous(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the previous path of a root path [\".concat(path, \"], because it has no previous index.\"));\n    }\n    var last = path[path.length - 1];\n    if (last <= 0) {\n      throw new Error(\"Cannot get the previous path of a first child path [\".concat(path, \"] because it would result in a negative index.\"));\n    }\n    return path.slice(0, -1).concat(last - 1);\n  },\n  relative(path, ancestor) {\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n      throw new Error(\"Cannot get the relative path of [\".concat(path, \"] inside ancestor [\").concat(ancestor, \"], because it is not above or equal to the path.\"));\n    }\n    return path.slice(ancestor.length);\n  },\n  transform(path, operation) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!path) return null;\n    // PERF: use destructing instead of immer\n    var p = [...path];\n    var {\n      affinity = 'forward'\n    } = options;\n    // PERF: Exit early if the operation is guaranteed not to have an effect.\n    if (path.length === 0) {\n      return p;\n    }\n    switch (operation.type) {\n      case 'insert_node':\n        {\n          var {\n            path: op\n          } = operation;\n          if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {\n            p[op.length - 1] += 1;\n          }\n          break;\n        }\n      case 'remove_node':\n        {\n          var {\n            path: _op\n          } = operation;\n          if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {\n            return null;\n          } else if (Path.endsBefore(_op, p)) {\n            p[_op.length - 1] -= 1;\n          }\n          break;\n        }\n      case 'merge_node':\n        {\n          var {\n            path: _op2,\n            position\n          } = operation;\n          if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {\n            p[_op2.length - 1] -= 1;\n          } else if (Path.isAncestor(_op2, p)) {\n            p[_op2.length - 1] -= 1;\n            p[_op2.length] += position;\n          }\n          break;\n        }\n      case 'split_node':\n        {\n          var {\n            path: _op3,\n            position: _position\n          } = operation;\n          if (Path.equals(_op3, p)) {\n            if (affinity === 'forward') {\n              p[p.length - 1] += 1;\n            } else if (affinity === 'backward') ; else {\n              return null;\n            }\n          } else if (Path.endsBefore(_op3, p)) {\n            p[_op3.length - 1] += 1;\n          } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {\n            p[_op3.length - 1] += 1;\n            p[_op3.length] -= _position;\n          }\n          break;\n        }\n      case 'move_node':\n        {\n          var {\n            path: _op4,\n            newPath: onp\n          } = operation;\n          // If the old and new path are the same, it's a no-op.\n          if (Path.equals(_op4, onp)) {\n            return p;\n          }\n          if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {\n            var copy = onp.slice();\n            if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {\n              copy[_op4.length - 1] -= 1;\n            }\n            return copy.concat(p.slice(_op4.length));\n          } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {\n            if (Path.endsBefore(_op4, p)) {\n              p[_op4.length - 1] -= 1;\n            } else {\n              p[_op4.length - 1] += 1;\n            }\n          } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {\n            if (Path.endsBefore(_op4, p)) {\n              p[_op4.length - 1] -= 1;\n            }\n            p[onp.length - 1] += 1;\n          } else if (Path.endsBefore(_op4, p)) {\n            if (Path.equals(onp, p)) {\n              p[onp.length - 1] += 1;\n            }\n            p[_op4.length - 1] -= 1;\n          }\n          break;\n        }\n    }\n    return p;\n  }\n};\n\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\n\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nfunction ownKeys$e(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$e(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$e(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$e(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar insertChildren = function insertChildren(xs, index) {\n  for (var _len = arguments.length, newValues = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    newValues[_key - 2] = arguments[_key];\n  }\n  return [...xs.slice(0, index), ...newValues, ...xs.slice(index)];\n};\nvar replaceChildren = function replaceChildren(xs, index, removeCount) {\n  for (var _len2 = arguments.length, newValues = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n    newValues[_key2 - 3] = arguments[_key2];\n  }\n  return [...xs.slice(0, index), ...newValues, ...xs.slice(index + removeCount)];\n};\nvar removeChildren = replaceChildren;\n/**\n * Replace a descendant with a new node, replacing all ancestors\n */\nvar modifyDescendant = (editor, path, f) => {\n  if (path.length === 0) {\n    throw new Error('Cannot modify the editor');\n  }\n  var node = Node.get(editor, path);\n  var slicedPath = path.slice();\n  var modifiedNode = f(node);\n  while (slicedPath.length > 1) {\n    var _index = slicedPath.pop();\n    var ancestorNode = Node.get(editor, slicedPath);\n    modifiedNode = _objectSpread$e(_objectSpread$e({}, ancestorNode), {}, {\n      children: replaceChildren(ancestorNode.children, _index, 1, modifiedNode)\n    });\n  }\n  var index = slicedPath.pop();\n  editor.children = replaceChildren(editor.children, index, 1, modifiedNode);\n};\n/**\n * Replace the children of a node, replacing all ancestors\n */\nvar modifyChildren = (editor, path, f) => {\n  if (path.length === 0) {\n    editor.children = f(editor.children);\n  } else {\n    modifyDescendant(editor, path, node => {\n      if (Text.isText(node)) {\n        throw new Error(\"Cannot get the element at path [\".concat(path, \"] because it refers to a leaf node: \").concat(Scrubber.stringify(node)));\n      }\n      return _objectSpread$e(_objectSpread$e({}, node), {}, {\n        children: f(node.children)\n      });\n    });\n  }\n};\n/**\n * Replace a leaf, replacing all ancestors\n */\nvar modifyLeaf = (editor, path, f) => modifyDescendant(editor, path, node => {\n  if (!Text.isText(node)) {\n    throw new Error(\"Cannot get the leaf node at path [\".concat(path, \"] because it refers to a non-leaf node: \").concat(Scrubber.stringify(node)));\n  }\n  return f(node);\n});\n// eslint-disable-next-line no-redeclare\nvar GeneralTransforms = {\n  transform(editor, op) {\n    var transformSelection = false;\n    switch (op.type) {\n      case 'insert_node':\n        {\n          var {\n            path,\n            node\n          } = op;\n          modifyChildren(editor, Path.parent(path), children => {\n            var index = path[path.length - 1];\n            if (index > children.length) {\n              throw new Error(\"Cannot apply an \\\"insert_node\\\" operation at path [\".concat(path, \"] because the destination is past the end of the node.\"));\n            }\n            return insertChildren(children, index, node);\n          });\n          transformSelection = true;\n          break;\n        }\n      case 'insert_text':\n        {\n          var {\n            path: _path,\n            offset,\n            text\n          } = op;\n          if (text.length === 0) break;\n          modifyLeaf(editor, _path, node => {\n            var before = node.text.slice(0, offset);\n            var after = node.text.slice(offset);\n            return _objectSpread$e(_objectSpread$e({}, node), {}, {\n              text: before + text + after\n            });\n          });\n          transformSelection = true;\n          break;\n        }\n      case 'merge_node':\n        {\n          var {\n            path: _path2\n          } = op;\n          var index = _path2[_path2.length - 1];\n          var prevPath = Path.previous(_path2);\n          var prevIndex = prevPath[prevPath.length - 1];\n          modifyChildren(editor, Path.parent(_path2), children => {\n            var node = children[index];\n            var prev = children[prevIndex];\n            var newNode;\n            if (Text.isText(node) && Text.isText(prev)) {\n              newNode = _objectSpread$e(_objectSpread$e({}, prev), {}, {\n                text: prev.text + node.text\n              });\n            } else if (!Text.isText(node) && !Text.isText(prev)) {\n              newNode = _objectSpread$e(_objectSpread$e({}, prev), {}, {\n                children: prev.children.concat(node.children)\n              });\n            } else {\n              throw new Error(\"Cannot apply a \\\"merge_node\\\" operation at path [\".concat(_path2, \"] to nodes of different interfaces: \").concat(Scrubber.stringify(node), \" \").concat(Scrubber.stringify(prev)));\n            }\n            return replaceChildren(children, prevIndex, 2, newNode);\n          });\n          transformSelection = true;\n          break;\n        }\n      case 'move_node':\n        {\n          var {\n            path: _path3,\n            newPath\n          } = op;\n          var _index2 = _path3[_path3.length - 1];\n          if (Path.isAncestor(_path3, newPath)) {\n            throw new Error(\"Cannot move a path [\".concat(_path3, \"] to new path [\").concat(newPath, \"] because the destination is inside itself.\"));\n          }\n          var _node = Node.get(editor, _path3);\n          modifyChildren(editor, Path.parent(_path3), children => removeChildren(children, _index2, 1));\n          // This is tricky, but since the `path` and `newPath` both refer to\n          // the same snapshot in time, there's a mismatch. After either\n          // removing the original position, the second step's path can be out\n          // of date. So instead of using the `op.newPath` directly, we\n          // transform `op.path` to ascertain what the `newPath` would be after\n          // the operation was applied.\n          var truePath = Path.transform(_path3, op);\n          var newIndex = truePath[truePath.length - 1];\n          modifyChildren(editor, Path.parent(truePath), children => insertChildren(children, newIndex, _node));\n          transformSelection = true;\n          break;\n        }\n      case 'remove_node':\n        {\n          var {\n            path: _path4\n          } = op;\n          var _index3 = _path4[_path4.length - 1];\n          modifyChildren(editor, Path.parent(_path4), children => removeChildren(children, _index3, 1));\n          // Transform all the points in the value, but if the point was in the\n          // node that was removed we need to update the range or remove it.\n          if (editor.selection) {\n            var selection = _objectSpread$e({}, editor.selection);\n            for (var [point, key] of Range.points(selection)) {\n              var result = Point.transform(point, op);\n              if (selection != null && result != null) {\n                selection[key] = result;\n              } else {\n                var prev = void 0;\n                var next = void 0;\n                for (var [n, p] of Node.texts(editor)) {\n                  if (Path.compare(p, _path4) === -1) {\n                    prev = [n, p];\n                  } else {\n                    next = [n, p];\n                    break;\n                  }\n                }\n                var preferNext = false;\n                if (prev && next) {\n                  if (Path.isSibling(prev[1], _path4)) {\n                    preferNext = false;\n                  } else if (Path.equals(next[1], _path4)) {\n                    preferNext = true;\n                  } else {\n                    preferNext = Path.common(prev[1], _path4).length < Path.common(next[1], _path4).length;\n                  }\n                }\n                if (prev && !preferNext) {\n                  selection[key] = {\n                    path: prev[1],\n                    offset: prev[0].text.length\n                  };\n                } else if (next) {\n                  selection[key] = {\n                    path: next[1],\n                    offset: 0\n                  };\n                } else {\n                  selection = null;\n                }\n              }\n            }\n            if (!selection || !Range.equals(selection, editor.selection)) {\n              editor.selection = selection;\n            }\n          }\n          break;\n        }\n      case 'remove_text':\n        {\n          var {\n            path: _path5,\n            offset: _offset,\n            text: _text\n          } = op;\n          if (_text.length === 0) break;\n          modifyLeaf(editor, _path5, node => {\n            var before = node.text.slice(0, _offset);\n            var after = node.text.slice(_offset + _text.length);\n            return _objectSpread$e(_objectSpread$e({}, node), {}, {\n              text: before + after\n            });\n          });\n          transformSelection = true;\n          break;\n        }\n      case 'set_node':\n        {\n          var {\n            path: _path6,\n            properties,\n            newProperties\n          } = op;\n          if (_path6.length === 0) {\n            throw new Error(\"Cannot set properties on the root node!\");\n          }\n          modifyDescendant(editor, _path6, node => {\n            var newNode = _objectSpread$e({}, node);\n            for (var _key3 in newProperties) {\n              if (_key3 === 'children' || _key3 === 'text') {\n                throw new Error(\"Cannot set the \\\"\".concat(_key3, \"\\\" property of nodes!\"));\n              }\n              var value = newProperties[_key3];\n              if (value == null) {\n                delete newNode[_key3];\n              } else {\n                newNode[_key3] = value;\n              }\n            }\n            // properties that were previously defined, but are now missing, must be deleted\n            for (var _key4 in properties) {\n              if (!newProperties.hasOwnProperty(_key4)) {\n                delete newNode[_key4];\n              }\n            }\n            return newNode;\n          });\n          break;\n        }\n      case 'set_selection':\n        {\n          var {\n            newProperties: _newProperties\n          } = op;\n          if (_newProperties == null) {\n            editor.selection = null;\n            break;\n          }\n          if (editor.selection == null) {\n            if (!Range.isRange(_newProperties)) {\n              throw new Error(\"Cannot apply an incomplete \\\"set_selection\\\" operation properties \".concat(Scrubber.stringify(_newProperties), \" when there is no current selection.\"));\n            }\n            editor.selection = _objectSpread$e({}, _newProperties);\n            break;\n          }\n          var _selection = _objectSpread$e({}, editor.selection);\n          for (var _key5 in _newProperties) {\n            var value = _newProperties[_key5];\n            if (value == null) {\n              if (_key5 === 'anchor' || _key5 === 'focus') {\n                throw new Error(\"Cannot remove the \\\"\".concat(_key5, \"\\\" selection property\"));\n              }\n              delete _selection[_key5];\n            } else {\n              _selection[_key5] = value;\n            }\n          }\n          editor.selection = _selection;\n          break;\n        }\n      case 'split_node':\n        {\n          var {\n            path: _path7,\n            position,\n            properties: _properties\n          } = op;\n          var _index4 = _path7[_path7.length - 1];\n          if (_path7.length === 0) {\n            throw new Error(\"Cannot apply a \\\"split_node\\\" operation at path [\".concat(_path7, \"] because the root node cannot be split.\"));\n          }\n          modifyChildren(editor, Path.parent(_path7), children => {\n            var node = children[_index4];\n            var newNode;\n            var nextNode;\n            if (Text.isText(node)) {\n              var before = node.text.slice(0, position);\n              var after = node.text.slice(position);\n              newNode = _objectSpread$e(_objectSpread$e({}, node), {}, {\n                text: before\n              });\n              nextNode = _objectSpread$e(_objectSpread$e({}, _properties), {}, {\n                text: after\n              });\n            } else {\n              var _before = node.children.slice(0, position);\n              var _after = node.children.slice(position);\n              newNode = _objectSpread$e(_objectSpread$e({}, node), {}, {\n                children: _before\n              });\n              nextNode = _objectSpread$e(_objectSpread$e({}, _properties), {}, {\n                children: _after\n              });\n            }\n            return replaceChildren(children, _index4, 1, newNode, nextNode);\n          });\n          transformSelection = true;\n          break;\n        }\n    }\n    if (transformSelection && editor.selection) {\n      var _selection2 = _objectSpread$e({}, editor.selection);\n      for (var [_point, _key6] of Range.points(_selection2)) {\n        _selection2[_key6] = Point.transform(_point, op);\n      }\n      if (!Range.equals(_selection2, editor.selection)) {\n        editor.selection = _selection2;\n      }\n    }\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar NodeTransforms = {\n  insertNodes(editor, nodes, options) {\n    editor.insertNodes(nodes, options);\n  },\n  liftNodes(editor, options) {\n    editor.liftNodes(options);\n  },\n  mergeNodes(editor, options) {\n    editor.mergeNodes(options);\n  },\n  moveNodes(editor, options) {\n    editor.moveNodes(options);\n  },\n  removeNodes(editor, options) {\n    editor.removeNodes(options);\n  },\n  setNodes(editor, props, options) {\n    editor.setNodes(props, options);\n  },\n  splitNodes(editor, options) {\n    editor.splitNodes(options);\n  },\n  unsetNodes(editor, props, options) {\n    editor.unsetNodes(props, options);\n  },\n  unwrapNodes(editor, options) {\n    editor.unwrapNodes(options);\n  },\n  wrapNodes(editor, element, options) {\n    editor.wrapNodes(element, options);\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar SelectionTransforms = {\n  collapse(editor, options) {\n    editor.collapse(options);\n  },\n  deselect(editor) {\n    editor.deselect();\n  },\n  move(editor, options) {\n    editor.move(options);\n  },\n  select(editor, target) {\n    editor.select(target);\n  },\n  setPoint(editor, props, options) {\n    editor.setPoint(props, options);\n  },\n  setSelection(editor, props) {\n    editor.setSelection(props);\n  }\n};\n\nvar isObject = value => typeof value === 'object' && value !== null;\n\n/*\n  Custom deep equal comparison for Slate nodes.\n\n  We don't need general purpose deep equality;\n  Slate only supports plain values, Arrays, and nested objects.\n  Complex values nested inside Arrays are not supported.\n\n  Slate objects are designed to be serialised, so\n  missing keys are deliberately normalised to undefined.\n */\nvar isDeepEqual = (node, another) => {\n  for (var key in node) {\n    var a = node[key];\n    var b = another[key];\n    if (Array.isArray(a) && Array.isArray(b)) {\n      if (a.length !== b.length) return false;\n      for (var i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) return false;\n      }\n    } else if (isObject(a) && isObject(b)) {\n      if (!isDeepEqual(a, b)) return false;\n    } else if (a !== b) {\n      return false;\n    }\n  }\n  /*\n    Deep object equality is only necessary in one direction; in the reverse direction\n    we are only looking for keys that are missing.\n    As above, undefined keys are normalised to missing.\n  */\n  for (var _key in another) {\n    if (node[_key] === undefined && another[_key] !== undefined) {\n      return false;\n    }\n  }\n  return true;\n};\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\nvar _excluded$4 = [\"anchor\", \"focus\"];\nfunction ownKeys$d(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$d(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$d(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$d(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n// eslint-disable-next-line no-redeclare\nvar Range = {\n  edges(range) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var {\n      anchor,\n      focus\n    } = range;\n    return Range.isBackward(range) === reverse ? [anchor, focus] : [focus, anchor];\n  },\n  end(range) {\n    var [, end] = Range.edges(range);\n    return end;\n  },\n  equals(range, another) {\n    return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);\n  },\n  surrounds(range, target) {\n    var intersectionRange = Range.intersection(range, target);\n    if (!intersectionRange) {\n      return false;\n    }\n    return Range.equals(intersectionRange, target);\n  },\n  includes(range, target) {\n    if (Range.isRange(target)) {\n      if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {\n        return true;\n      }\n      var [rs, re] = Range.edges(range);\n      var [ts, te] = Range.edges(target);\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te);\n    }\n    var [start, end] = Range.edges(range);\n    var isAfterStart = false;\n    var isBeforeEnd = false;\n    if (Point.isPoint(target)) {\n      isAfterStart = Point.compare(target, start) >= 0;\n      isBeforeEnd = Point.compare(target, end) <= 0;\n    } else {\n      isAfterStart = Path.compare(target, start.path) >= 0;\n      isBeforeEnd = Path.compare(target, end.path) <= 0;\n    }\n    return isAfterStart && isBeforeEnd;\n  },\n  intersection(range, another) {\n    var rest = _objectWithoutProperties(range, _excluded$4);\n    var [s1, e1] = Range.edges(range);\n    var [s2, e2] = Range.edges(another);\n    var start = Point.isBefore(s1, s2) ? s2 : s1;\n    var end = Point.isBefore(e1, e2) ? e1 : e2;\n    if (Point.isBefore(end, start)) {\n      return null;\n    } else {\n      return _objectSpread$d({\n        anchor: start,\n        focus: end\n      }, rest);\n    }\n  },\n  isBackward(range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    return Point.isAfter(anchor, focus);\n  },\n  isCollapsed(range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    return Point.equals(anchor, focus);\n  },\n  isExpanded(range) {\n    return !Range.isCollapsed(range);\n  },\n  isForward(range) {\n    return !Range.isBackward(range);\n  },\n  isRange(value) {\n    return isObject(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);\n  },\n  *points(range) {\n    yield [range.anchor, 'anchor'];\n    yield [range.focus, 'focus'];\n  },\n  start(range) {\n    var [start] = Range.edges(range);\n    return start;\n  },\n  transform(range, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (range === null) {\n      return null;\n    }\n    var {\n      affinity = 'inward'\n    } = options;\n    var affinityAnchor;\n    var affinityFocus;\n    if (affinity === 'inward') {\n      // If the range is collapsed, make sure to use the same affinity to\n      // avoid the two points passing each other and expanding in the opposite\n      // direction\n      var isCollapsed = Range.isCollapsed(range);\n      if (Range.isForward(range)) {\n        affinityAnchor = 'forward';\n        affinityFocus = isCollapsed ? affinityAnchor : 'backward';\n      } else {\n        affinityAnchor = 'backward';\n        affinityFocus = isCollapsed ? affinityAnchor : 'forward';\n      }\n    } else if (affinity === 'outward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'backward';\n        affinityFocus = 'forward';\n      } else {\n        affinityAnchor = 'forward';\n        affinityFocus = 'backward';\n      }\n    } else {\n      affinityAnchor = affinity;\n      affinityFocus = affinity;\n    }\n    var anchor = Point.transform(range.anchor, op, {\n      affinity: affinityAnchor\n    });\n    var focus = Point.transform(range.focus, op, {\n      affinity: affinityFocus\n    });\n    if (!anchor || !focus) {\n      return null;\n    }\n    return {\n      anchor,\n      focus\n    };\n  }\n};\n\n/**\n * Shared the function with isElementType utility\n */\nvar isElement = function isElement(value) {\n  var {\n    deep = false\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!isObject(value)) return false;\n  // PERF: No need to use the full Editor.isEditor here\n  var isEditor = typeof value.apply === 'function';\n  if (isEditor) return false;\n  var isChildrenValid = deep ? Node.isNodeList(value.children) : Array.isArray(value.children);\n  return isChildrenValid;\n};\n// eslint-disable-next-line no-redeclare\nvar Element = {\n  isAncestor(value) {\n    var {\n      deep = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return isObject(value) && Node.isNodeList(value.children, {\n      deep\n    });\n  },\n  isElement,\n  isElementList(value) {\n    var {\n      deep = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return Array.isArray(value) && value.every(val => Element.isElement(val, {\n      deep\n    }));\n  },\n  isElementProps(props) {\n    return props.children !== undefined;\n  },\n  isElementType: function isElementType(value, elementVal) {\n    var elementKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'type';\n    return isElement(value) && value[elementKey] === elementVal;\n  },\n  matches(element, props) {\n    for (var key in props) {\n      if (key === 'children') {\n        continue;\n      }\n      if (element[key] !== props[key]) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\n\nvar _excluded$3 = [\"children\"],\n  _excluded2$3 = [\"text\"];\n// eslint-disable-next-line no-redeclare\nvar Node = {\n  ancestor(root, path) {\n    var node = Node.get(root, path);\n    if (Text.isText(node)) {\n      throw new Error(\"Cannot get the ancestor node at path [\".concat(path, \"] because it refers to a text node instead: \").concat(Scrubber.stringify(node)));\n    }\n    return node;\n  },\n  ancestors(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return function* () {\n      for (var p of Path.ancestors(path, options)) {\n        var n = Node.ancestor(root, p);\n        var entry = [n, p];\n        yield entry;\n      }\n    }();\n  },\n  child(root, index) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get the child of a text node: \".concat(Scrubber.stringify(root)));\n    }\n    var c = root.children[index];\n    if (c == null) {\n      throw new Error(\"Cannot get child at index `\".concat(index, \"` in node: \").concat(Scrubber.stringify(root)));\n    }\n    return c;\n  },\n  children(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return function* () {\n      var {\n        reverse = false\n      } = options;\n      var ancestor = Node.ancestor(root, path);\n      var {\n        children\n      } = ancestor;\n      var index = reverse ? children.length - 1 : 0;\n      while (reverse ? index >= 0 : index < children.length) {\n        var child = Node.child(ancestor, index);\n        var childPath = path.concat(index);\n        yield [child, childPath];\n        index = reverse ? index - 1 : index + 1;\n      }\n    }();\n  },\n  common(root, path, another) {\n    var p = Path.common(path, another);\n    var n = Node.get(root, p);\n    return [n, p];\n  },\n  descendant(root, path) {\n    var node = Node.get(root, path);\n    if (Editor.isEditor(node)) {\n      throw new Error(\"Cannot get the descendant node at path [\".concat(path, \"] because it refers to the root editor node instead: \").concat(Scrubber.stringify(node)));\n    }\n    return node;\n  },\n  descendants(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return function* () {\n      for (var [node, path] of Node.nodes(root, options)) {\n        if (path.length !== 0) {\n          // NOTE: we have to coerce here because checking the path's length does\n          // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n          yield [node, path];\n        }\n      }\n    }();\n  },\n  elements(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return function* () {\n      for (var [node, path] of Node.nodes(root, options)) {\n        if (Element.isElement(node)) {\n          yield [node, path];\n        }\n      }\n    }();\n  },\n  extractProps(node) {\n    if (Element.isAncestor(node)) {\n      var properties = _objectWithoutProperties(node, _excluded$3);\n      return properties;\n    } else {\n      var properties = _objectWithoutProperties(node, _excluded2$3);\n      return properties;\n    }\n  },\n  first(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        n = n.children[0];\n        p.push(0);\n      }\n    }\n    return [n, p];\n  },\n  fragment(root, range) {\n    var newRoot = (0,immer__WEBPACK_IMPORTED_MODULE_0__.produce)({\n      children: root.children\n    }, r => {\n      var [start, end] = Range.edges(range);\n      var nodeEntries = Node.nodes(r, {\n        reverse: true,\n        pass: _ref => {\n          var [, path] = _ref;\n          return !Range.includes(range, path);\n        }\n      });\n      for (var [, path] of nodeEntries) {\n        if (!Range.includes(range, path)) {\n          var parent = Node.parent(r, path);\n          var index = path[path.length - 1];\n          parent.children.splice(index, 1);\n        }\n        if (Path.equals(path, end.path)) {\n          var leaf = Node.leaf(r, path);\n          leaf.text = leaf.text.slice(0, end.offset);\n        }\n        if (Path.equals(path, start.path)) {\n          var _leaf = Node.leaf(r, path);\n          _leaf.text = _leaf.text.slice(start.offset);\n        }\n      }\n      if (Editor.isEditor(r)) {\n        r.selection = null;\n      }\n    });\n    return newRoot.children;\n  },\n  get(root, path) {\n    var node = Node.getIf(root, path);\n    if (node === undefined) {\n      throw new Error(\"Cannot find a descendant at path [\".concat(path, \"] in node: \").concat(Scrubber.stringify(root)));\n    }\n    return node;\n  },\n  getIf(root, path) {\n    var node = root;\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n      if (Text.isText(node) || !node.children[p]) {\n        return;\n      }\n      node = node.children[p];\n    }\n    return node;\n  },\n  has(root, path) {\n    var node = root;\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n      if (Text.isText(node) || !node.children[p]) {\n        return false;\n      }\n      node = node.children[p];\n    }\n    return true;\n  },\n  isNode(value) {\n    var {\n      deep = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return Text.isText(value) || Element.isElement(value, {\n      deep\n    }) || Editor.isEditor(value, {\n      deep\n    });\n  },\n  isNodeList(value) {\n    var {\n      deep = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return Array.isArray(value) && value.every(val => Node.isNode(val, {\n      deep\n    }));\n  },\n  last(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        var i = n.children.length - 1;\n        n = n.children[i];\n        p.push(i);\n      }\n    }\n    return [n, p];\n  },\n  leaf(root, path) {\n    var node = Node.get(root, path);\n    if (!Text.isText(node)) {\n      throw new Error(\"Cannot get the leaf node at path [\".concat(path, \"] because it refers to a non-leaf node: \").concat(Scrubber.stringify(node)));\n    }\n    return node;\n  },\n  levels(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return function* () {\n      for (var p of Path.levels(path, options)) {\n        var n = Node.get(root, p);\n        yield [n, p];\n      }\n    }();\n  },\n  matches(node, props) {\n    return Element.isElement(node) && Element.isElementProps(props) && Element.matches(node, props) || Text.isText(node) && Text.isTextProps(props) && Text.matches(node, props);\n  },\n  nodes(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return function* () {\n      var {\n        pass,\n        reverse = false\n      } = options;\n      var {\n        from = [],\n        to\n      } = options;\n      var visited = new Set();\n      var p = [];\n      var n = root;\n      while (true) {\n        if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n          break;\n        }\n        if (!visited.has(n)) {\n          yield [n, p];\n        }\n        // If we're allowed to go downward and we haven't descended yet, do.\n        if (!visited.has(n) && !Text.isText(n) && n.children.length !== 0 && (pass == null || pass([n, p]) === false)) {\n          visited.add(n);\n          var nextIndex = reverse ? n.children.length - 1 : 0;\n          if (Path.isAncestor(p, from)) {\n            nextIndex = from[p.length];\n          }\n          p = p.concat(nextIndex);\n          n = Node.get(root, p);\n          continue;\n        }\n        // If we're at the root and we can't go down, we're done.\n        if (p.length === 0) {\n          break;\n        }\n        // If we're going forward...\n        if (!reverse) {\n          var newPath = Path.next(p);\n          if (Node.has(root, newPath)) {\n            p = newPath;\n            n = Node.get(root, p);\n            continue;\n          }\n        }\n        // If we're going backward...\n        if (reverse && p[p.length - 1] !== 0) {\n          var _newPath = Path.previous(p);\n          p = _newPath;\n          n = Node.get(root, p);\n          continue;\n        }\n        // Otherwise we're going upward...\n        p = Path.parent(p);\n        n = Node.get(root, p);\n        visited.add(n);\n      }\n    }();\n  },\n  parent(root, path) {\n    var parentPath = Path.parent(path);\n    var p = Node.get(root, parentPath);\n    if (Text.isText(p)) {\n      throw new Error(\"Cannot get the parent of path [\".concat(path, \"] because it does not exist in the root.\"));\n    }\n    return p;\n  },\n  string(node) {\n    if (Text.isText(node)) {\n      return node.text;\n    } else {\n      return node.children.map(Node.string).join('');\n    }\n  },\n  texts(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return function* () {\n      for (var [node, path] of Node.nodes(root, options)) {\n        if (Text.isText(node)) {\n          yield [node, path];\n        }\n      }\n    }();\n  }\n};\n\nfunction ownKeys$c(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$c(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$c(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$c(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n// eslint-disable-next-line no-redeclare\nvar Operation = {\n  isNodeOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_node');\n  },\n  isOperation(value) {\n    if (!isObject(value)) {\n      return false;\n    }\n    switch (value.type) {\n      case 'insert_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n      case 'insert_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n      case 'merge_node':\n        return typeof value.position === 'number' && Path.isPath(value.path) && isObject(value.properties);\n      case 'move_node':\n        return Path.isPath(value.path) && Path.isPath(value.newPath);\n      case 'remove_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n      case 'remove_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n      case 'set_node':\n        return Path.isPath(value.path) && isObject(value.properties) && isObject(value.newProperties);\n      case 'set_selection':\n        return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || isObject(value.properties) && isObject(value.newProperties);\n      case 'split_node':\n        return Path.isPath(value.path) && typeof value.position === 'number' && isObject(value.properties);\n      default:\n        return false;\n    }\n  },\n  isOperationList(value) {\n    return Array.isArray(value) && value.every(val => Operation.isOperation(val));\n  },\n  isSelectionOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_selection');\n  },\n  isTextOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_text');\n  },\n  inverse(op) {\n    switch (op.type) {\n      case 'insert_node':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'remove_node'\n          });\n        }\n      case 'insert_text':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'remove_text'\n          });\n        }\n      case 'merge_node':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'split_node',\n            path: Path.previous(op.path)\n          });\n        }\n      case 'move_node':\n        {\n          var {\n            newPath,\n            path\n          } = op;\n          // PERF: in this case the move operation is a no-op anyways.\n          if (Path.equals(newPath, path)) {\n            return op;\n          }\n          // If the move happens completely within a single parent the path and\n          // newPath are stable with respect to each other.\n          if (Path.isSibling(path, newPath)) {\n            return _objectSpread$c(_objectSpread$c({}, op), {}, {\n              path: newPath,\n              newPath: path\n            });\n          }\n          // If the move does not happen within a single parent it is possible\n          // for the move to impact the true path to the location where the node\n          // was removed from and where it was inserted. We have to adjust for this\n          // and find the original path. We can accomplish this (only in non-sibling)\n          // moves by looking at the impact of the move operation on the node\n          // after the original move path.\n          var inversePath = Path.transform(path, op);\n          var inverseNewPath = Path.transform(Path.next(path), op);\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            path: inversePath,\n            newPath: inverseNewPath\n          });\n        }\n      case 'remove_node':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'insert_node'\n          });\n        }\n      case 'remove_text':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'insert_text'\n          });\n        }\n      case 'set_node':\n        {\n          var {\n            properties,\n            newProperties\n          } = op;\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            properties: newProperties,\n            newProperties: properties\n          });\n        }\n      case 'set_selection':\n        {\n          var {\n            properties: _properties,\n            newProperties: _newProperties\n          } = op;\n          if (_properties == null) {\n            return _objectSpread$c(_objectSpread$c({}, op), {}, {\n              properties: _newProperties,\n              newProperties: null\n            });\n          } else if (_newProperties == null) {\n            return _objectSpread$c(_objectSpread$c({}, op), {}, {\n              properties: null,\n              newProperties: _properties\n            });\n          } else {\n            return _objectSpread$c(_objectSpread$c({}, op), {}, {\n              properties: _newProperties,\n              newProperties: _properties\n            });\n          }\n        }\n      case 'split_node':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'merge_node',\n            path: Path.next(op.path)\n          });\n        }\n    }\n  }\n};\n\nvar isEditor = function isEditor(value) {\n  var {\n    deep = false\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!isObject(value)) {\n    return false;\n  }\n  var isEditor = typeof value.addMark === 'function' && typeof value.apply === 'function' && typeof value.deleteFragment === 'function' && typeof value.insertBreak === 'function' && typeof value.insertSoftBreak === 'function' && typeof value.insertFragment === 'function' && typeof value.insertNode === 'function' && typeof value.insertText === 'function' && typeof value.isElementReadOnly === 'function' && typeof value.isInline === 'function' && typeof value.isSelectable === 'function' && typeof value.isVoid === 'function' && typeof value.normalizeNode === 'function' && typeof value.onChange === 'function' && typeof value.removeMark === 'function' && typeof value.getDirtyPaths === 'function' && (value.marks === null || isObject(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && (!deep || Node.isNodeList(value.children)) && Operation.isOperationList(value.operations);\n  return isEditor;\n};\n\n// eslint-disable-next-line no-redeclare\nvar Editor = {\n  above(editor, options) {\n    return editor.above(options);\n  },\n  addMark(editor, key, value) {\n    editor.addMark(key, value);\n  },\n  after(editor, at, options) {\n    return editor.after(at, options);\n  },\n  before(editor, at, options) {\n    return editor.before(at, options);\n  },\n  deleteBackward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      unit = 'character'\n    } = options;\n    editor.deleteBackward(unit);\n  },\n  deleteForward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      unit = 'character'\n    } = options;\n    editor.deleteForward(unit);\n  },\n  deleteFragment(editor, options) {\n    editor.deleteFragment(options);\n  },\n  edges(editor, at) {\n    return editor.edges(at);\n  },\n  elementReadOnly(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return editor.elementReadOnly(options);\n  },\n  end(editor, at) {\n    return editor.end(at);\n  },\n  first(editor, at) {\n    return editor.first(at);\n  },\n  fragment(editor, at) {\n    return editor.fragment(at);\n  },\n  hasBlocks(editor, element) {\n    return editor.hasBlocks(element);\n  },\n  hasInlines(editor, element) {\n    return editor.hasInlines(element);\n  },\n  hasPath(editor, path) {\n    return editor.hasPath(path);\n  },\n  hasTexts(editor, element) {\n    return editor.hasTexts(element);\n  },\n  insertBreak(editor) {\n    editor.insertBreak();\n  },\n  insertFragment(editor, fragment, options) {\n    editor.insertFragment(fragment, options);\n  },\n  insertNode(editor, node) {\n    editor.insertNode(node);\n  },\n  insertSoftBreak(editor) {\n    editor.insertSoftBreak();\n  },\n  insertText(editor, text) {\n    editor.insertText(text);\n  },\n  isBlock(editor, value) {\n    return editor.isBlock(value);\n  },\n  isEdge(editor, point, at) {\n    return editor.isEdge(point, at);\n  },\n  isEditor(value) {\n    return isEditor(value);\n  },\n  isElementReadOnly(editor, element) {\n    return editor.isElementReadOnly(element);\n  },\n  isEmpty(editor, element) {\n    return editor.isEmpty(element);\n  },\n  isEnd(editor, point, at) {\n    return editor.isEnd(point, at);\n  },\n  isInline(editor, value) {\n    return editor.isInline(value);\n  },\n  isNormalizing(editor) {\n    return editor.isNormalizing();\n  },\n  isSelectable(editor, value) {\n    return editor.isSelectable(value);\n  },\n  isStart(editor, point, at) {\n    return editor.isStart(point, at);\n  },\n  isVoid(editor, value) {\n    return editor.isVoid(value);\n  },\n  last(editor, at) {\n    return editor.last(at);\n  },\n  leaf(editor, at, options) {\n    return editor.leaf(at, options);\n  },\n  levels(editor, options) {\n    return editor.levels(options);\n  },\n  marks(editor) {\n    return editor.getMarks();\n  },\n  next(editor, options) {\n    return editor.next(options);\n  },\n  node(editor, at, options) {\n    return editor.node(at, options);\n  },\n  nodes(editor, options) {\n    return editor.nodes(options);\n  },\n  normalize(editor, options) {\n    editor.normalize(options);\n  },\n  parent(editor, at, options) {\n    return editor.parent(at, options);\n  },\n  path(editor, at, options) {\n    return editor.path(at, options);\n  },\n  pathRef(editor, path, options) {\n    return editor.pathRef(path, options);\n  },\n  pathRefs(editor) {\n    return editor.pathRefs();\n  },\n  point(editor, at, options) {\n    return editor.point(at, options);\n  },\n  pointRef(editor, point, options) {\n    return editor.pointRef(point, options);\n  },\n  pointRefs(editor) {\n    return editor.pointRefs();\n  },\n  positions(editor, options) {\n    return editor.positions(options);\n  },\n  previous(editor, options) {\n    return editor.previous(options);\n  },\n  range(editor, at, to) {\n    return editor.range(at, to);\n  },\n  rangeRef(editor, range, options) {\n    return editor.rangeRef(range, options);\n  },\n  rangeRefs(editor) {\n    return editor.rangeRefs();\n  },\n  removeMark(editor, key) {\n    editor.removeMark(key);\n  },\n  setNormalizing(editor, isNormalizing) {\n    editor.setNormalizing(isNormalizing);\n  },\n  start(editor, at) {\n    return editor.start(at);\n  },\n  string(editor, at, options) {\n    return editor.string(at, options);\n  },\n  unhangRange(editor, range, options) {\n    return editor.unhangRange(range, options);\n  },\n  void(editor, options) {\n    return editor.void(options);\n  },\n  withoutNormalizing(editor, fn) {\n    editor.withoutNormalizing(fn);\n  },\n  shouldMergeNodesRemovePrevNode: (editor, prevNode, curNode) => {\n    return editor.shouldMergeNodesRemovePrevNode(prevNode, curNode);\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar Location = {\n  isLocation(value) {\n    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value);\n  }\n};\n// eslint-disable-next-line no-redeclare\nvar Span = {\n  isSpan(value) {\n    return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);\n  }\n};\n\nfunction ownKeys$b(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$b(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$b(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$b(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n// eslint-disable-next-line no-redeclare\nvar Point = {\n  compare(point, another) {\n    var result = Path.compare(point.path, another.path);\n    if (result === 0) {\n      if (point.offset < another.offset) return -1;\n      if (point.offset > another.offset) return 1;\n      return 0;\n    }\n    return result;\n  },\n  isAfter(point, another) {\n    return Point.compare(point, another) === 1;\n  },\n  isBefore(point, another) {\n    return Point.compare(point, another) === -1;\n  },\n  equals(point, another) {\n    // PERF: ensure the offsets are equal first since they are cheaper to check.\n    return point.offset === another.offset && Path.equals(point.path, another.path);\n  },\n  isPoint(value) {\n    return isObject(value) && typeof value.offset === 'number' && Path.isPath(value.path);\n  },\n  transform(point, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (point === null) {\n      return null;\n    }\n    var {\n      affinity = 'forward'\n    } = options;\n    var {\n      path,\n      offset\n    } = point;\n    switch (op.type) {\n      case 'insert_node':\n      case 'move_node':\n        {\n          path = Path.transform(path, op, options);\n          break;\n        }\n      case 'insert_text':\n        {\n          if (Path.equals(op.path, path) && (op.offset < offset || op.offset === offset && affinity === 'forward')) {\n            offset += op.text.length;\n          }\n          break;\n        }\n      case 'merge_node':\n        {\n          if (Path.equals(op.path, path)) {\n            offset += op.position;\n          }\n          path = Path.transform(path, op, options);\n          break;\n        }\n      case 'remove_text':\n        {\n          if (Path.equals(op.path, path) && op.offset <= offset) {\n            offset -= Math.min(offset - op.offset, op.text.length);\n          }\n          break;\n        }\n      case 'remove_node':\n        {\n          if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n            return null;\n          }\n          path = Path.transform(path, op, options);\n          break;\n        }\n      case 'split_node':\n        {\n          if (Path.equals(op.path, path)) {\n            if (op.position === offset && affinity == null) {\n              return null;\n            } else if (op.position < offset || op.position === offset && affinity === 'forward') {\n              offset -= op.position;\n              path = Path.transform(path, op, _objectSpread$b(_objectSpread$b({}, options), {}, {\n                affinity: 'forward'\n              }));\n            }\n          } else {\n            path = Path.transform(path, op, options);\n          }\n          break;\n        }\n      default:\n        return point;\n    }\n    return {\n      path,\n      offset\n    };\n  }\n};\n\nvar _scrubber = undefined;\n/**\n * This interface implements a stringify() function, which is used by Slate\n * internally when generating exceptions containing end user data. Developers\n * using Slate may call Scrubber.setScrubber() to alter the behavior of this\n * stringify() function.\n *\n * For example, to prevent the cleartext logging of 'text' fields within Nodes:\n *\n *    import { Scrubber } from 'slate';\n *    Scrubber.setScrubber((key, val) => {\n *      if (key === 'text') return '...scrubbed...'\n *      return val\n *    });\n *\n */\n// eslint-disable-next-line no-redeclare\nvar Scrubber = {\n  setScrubber(scrubber) {\n    _scrubber = scrubber;\n  },\n  stringify(value) {\n    return JSON.stringify(value, _scrubber);\n  }\n};\n\nvar _excluded$2 = [\"text\"],\n  _excluded2$2 = [\"anchor\", \"focus\", \"merge\"];\nfunction ownKeys$a(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$a(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$a(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$a(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n// eslint-disable-next-line no-redeclare\nvar Text = {\n  equals(text, another) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      loose = false\n    } = options;\n    function omitText(obj) {\n      var rest = _objectWithoutProperties(obj, _excluded$2);\n      return rest;\n    }\n    return isDeepEqual(loose ? omitText(text) : text, loose ? omitText(another) : another);\n  },\n  isText(value) {\n    return isObject(value) && typeof value.text === 'string';\n  },\n  isTextList(value) {\n    return Array.isArray(value) && value.every(val => Text.isText(val));\n  },\n  isTextProps(props) {\n    return props.text !== undefined;\n  },\n  matches(text, props) {\n    for (var key in props) {\n      if (key === 'text') {\n        continue;\n      }\n      if (!text.hasOwnProperty(key) || text[key] !== props[key]) {\n        return false;\n      }\n    }\n    return true;\n  },\n  decorations(node, decorations) {\n    var leaves = [{\n      leaf: _objectSpread$a({}, node)\n    }];\n    for (var dec of decorations) {\n      var {\n          anchor,\n          focus,\n          merge: mergeDecoration\n        } = dec,\n        rest = _objectWithoutProperties(dec, _excluded2$2);\n      var [start, end] = Range.edges(dec);\n      var next = [];\n      var leafEnd = 0;\n      var decorationStart = start.offset;\n      var decorationEnd = end.offset;\n      var merge = mergeDecoration !== null && mergeDecoration !== void 0 ? mergeDecoration : Object.assign;\n      for (var {\n        leaf\n      } of leaves) {\n        var {\n          length\n        } = leaf.text;\n        var leafStart = leafEnd;\n        leafEnd += length;\n        // If the range encompasses the entire leaf, add the range.\n        if (decorationStart <= leafStart && leafEnd <= decorationEnd) {\n          merge(leaf, rest);\n          next.push({\n            leaf\n          });\n          continue;\n        }\n        // If the range expanded and match the leaf, or starts after, or ends before it, continue.\n        if (decorationStart !== decorationEnd && (decorationStart === leafEnd || decorationEnd === leafStart) || decorationStart > leafEnd || decorationEnd < leafStart || decorationEnd === leafStart && leafStart !== 0) {\n          next.push({\n            leaf\n          });\n          continue;\n        }\n        // Otherwise we need to split the leaf, at the start, end, or both,\n        // and add the range to the middle intersecting section. Do the end\n        // split first since we don't need to update the offset that way.\n        var middle = leaf;\n        var before = void 0;\n        var after = void 0;\n        if (decorationEnd < leafEnd) {\n          var off = decorationEnd - leafStart;\n          after = {\n            leaf: _objectSpread$a(_objectSpread$a({}, middle), {}, {\n              text: middle.text.slice(off)\n            })\n          };\n          middle = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n            text: middle.text.slice(0, off)\n          });\n        }\n        if (decorationStart > leafStart) {\n          var _off = decorationStart - leafStart;\n          before = {\n            leaf: _objectSpread$a(_objectSpread$a({}, middle), {}, {\n              text: middle.text.slice(0, _off)\n            })\n          };\n          middle = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n            text: middle.text.slice(_off)\n          });\n        }\n        merge(middle, rest);\n        if (before) {\n          next.push(before);\n        }\n        next.push({\n          leaf: middle\n        });\n        if (after) {\n          next.push(after);\n        }\n      }\n      leaves = next;\n    }\n    if (leaves.length > 1) {\n      var currentOffset = 0;\n      for (var [index, item] of leaves.entries()) {\n        var _start = currentOffset;\n        var _end = _start + item.leaf.text.length;\n        var position = {\n          start: _start,\n          end: _end\n        };\n        if (index === 0) position.isFirst = true;\n        if (index === leaves.length - 1) position.isLast = true;\n        item.position = position;\n        currentOffset = _end;\n      }\n    }\n    return leaves;\n  }\n};\n\n/**\n * Get the default location to insert content into the editor.\n * By default, use the selection as the target location. But if there is\n * no selection, insert at the end of the document since that is such a\n * common use case when inserting from a non-selected state.\n */\nvar getDefaultInsertLocation = editor => {\n  if (editor.selection) {\n    return editor.selection;\n  } else if (editor.children.length > 0) {\n    return Editor.end(editor, []);\n  } else {\n    return [0];\n  }\n};\n\nvar matchPath = (editor, path) => {\n  var [node] = Editor.node(editor, path);\n  return n => n === node;\n};\n\n// Character (grapheme cluster) boundaries are determined according to\n// the default grapheme cluster boundary specification, extended grapheme clusters variant[1].\n//\n// References:\n//\n// [1] https://www.unicode.org/reports/tr29/#Default_Grapheme_Cluster_Table\n// [2] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakProperty.txt\n// [3] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.html\n// [4] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.txt\n/**\n * Get the distance to the end of the first character in a string of text.\n */\nvar getCharacterDistance = function getCharacterDistance(str) {\n  var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var isLTR = !isRTL;\n  var codepoints = isRTL ? codepointsIteratorRTL(str) : str;\n  var left = CodepointType.None;\n  var right = CodepointType.None;\n  var distance = 0;\n  // Evaluation of these conditions are deferred.\n  var gb11 = null; // Is GB11 applicable?\n  var gb12Or13 = null; // Is GB12 or GB13 applicable?\n  for (var char of codepoints) {\n    var code = char.codePointAt(0);\n    if (!code) break;\n    var type = getCodepointType(char, code);\n    [left, right] = isLTR ? [right, type] : [type, left];\n    if (intersects(left, CodepointType.ZWJ) && intersects(right, CodepointType.ExtPict)) {\n      if (isLTR) {\n        gb11 = endsWithEmojiZWJ(str.substring(0, distance));\n      } else {\n        gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance));\n      }\n      if (!gb11) break;\n    }\n    if (intersects(left, CodepointType.RI) && intersects(right, CodepointType.RI)) {\n      if (gb12Or13 !== null) {\n        gb12Or13 = !gb12Or13;\n      } else {\n        if (isLTR) {\n          gb12Or13 = true;\n        } else {\n          gb12Or13 = endsWithOddNumberOfRIs(str.substring(0, str.length - distance));\n        }\n      }\n      if (!gb12Or13) break;\n    }\n    if (left !== CodepointType.None && right !== CodepointType.None && isBoundaryPair(left, right)) {\n      break;\n    }\n    distance += char.length;\n  }\n  return distance || 1;\n};\nvar SPACE = /\\s/;\nvar PUNCTUATION = /[\\u002B\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\nvar CHAMELEON = /['\\u2018\\u2019]/;\n/**\n * Get the distance to the end of the first word in a string of text.\n */\nvar getWordDistance = function getWordDistance(text) {\n  var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var dist = 0;\n  var started = false;\n  while (text.length > 0) {\n    var charDist = getCharacterDistance(text, isRTL);\n    var [char, remaining] = splitByCharacterDistance(text, charDist, isRTL);\n    if (isWordCharacter(char, remaining, isRTL)) {\n      started = true;\n      dist += charDist;\n    } else if (!started) {\n      dist += charDist;\n    } else {\n      break;\n    }\n    text = remaining;\n  }\n  return dist;\n};\n/**\n * Split a string in two parts at a given distance starting from the end when\n * `isRTL` is set to `true`.\n */\nvar splitByCharacterDistance = (str, dist, isRTL) => {\n  if (isRTL) {\n    var at = str.length - dist;\n    return [str.slice(at, str.length), str.slice(0, at)];\n  }\n  return [str.slice(0, dist), str.slice(dist)];\n};\n/**\n * Check if a character is a word character. The `remaining` argument is used\n * because sometimes you must read subsequent characters to truly determine it.\n */\nvar isWordCharacter = function isWordCharacter(char, remaining) {\n  var isRTL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (SPACE.test(char)) {\n    return false;\n  }\n  // Chameleons count as word characters as long as they're in a word, so\n  // recurse to see if the next one is a word character or not.\n  if (CHAMELEON.test(char)) {\n    var charDist = getCharacterDistance(remaining, isRTL);\n    var [nextChar, nextRemaining] = splitByCharacterDistance(remaining, charDist, isRTL);\n    if (isWordCharacter(nextChar, nextRemaining, isRTL)) {\n      return true;\n    }\n  }\n  if (PUNCTUATION.test(char)) {\n    return false;\n  }\n  return true;\n};\n/**\n * Iterate on codepoints from right to left.\n */\nvar codepointsIteratorRTL = function* codepointsIteratorRTL(str) {\n  var end = str.length - 1;\n  for (var i = 0; i < str.length; i++) {\n    var char1 = str.charAt(end - i);\n    if (isLowSurrogate(char1.charCodeAt(0))) {\n      var char2 = str.charAt(end - i - 1);\n      if (isHighSurrogate(char2.charCodeAt(0))) {\n        yield char2 + char1;\n        i++;\n        continue;\n      }\n    }\n    yield char1;\n  }\n};\n/**\n * Is `charCode` a high surrogate.\n *\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\n */\nvar isHighSurrogate = charCode => {\n  return charCode >= 0xd800 && charCode <= 0xdbff;\n};\n/**\n * Is `charCode` a low surrogate.\n *\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\n */\nvar isLowSurrogate = charCode => {\n  return charCode >= 0xdc00 && charCode <= 0xdfff;\n};\nvar CodepointType;\n(function (CodepointType) {\n  CodepointType[CodepointType[\"None\"] = 0] = \"None\";\n  CodepointType[CodepointType[\"Extend\"] = 1] = \"Extend\";\n  CodepointType[CodepointType[\"ZWJ\"] = 2] = \"ZWJ\";\n  CodepointType[CodepointType[\"RI\"] = 4] = \"RI\";\n  CodepointType[CodepointType[\"Prepend\"] = 8] = \"Prepend\";\n  CodepointType[CodepointType[\"SpacingMark\"] = 16] = \"SpacingMark\";\n  CodepointType[CodepointType[\"L\"] = 32] = \"L\";\n  CodepointType[CodepointType[\"V\"] = 64] = \"V\";\n  CodepointType[CodepointType[\"T\"] = 128] = \"T\";\n  CodepointType[CodepointType[\"LV\"] = 256] = \"LV\";\n  CodepointType[CodepointType[\"LVT\"] = 512] = \"LVT\";\n  CodepointType[CodepointType[\"ExtPict\"] = 1024] = \"ExtPict\";\n  CodepointType[CodepointType[\"Any\"] = 2048] = \"Any\";\n})(CodepointType || (CodepointType = {}));\nvar reExtend = /^(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u0898-\\u089F\\u08CA-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3C\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECE\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732\\u1733\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u180F\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1ACE\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDEFD-\\uDEFF\\uDF46-\\uDF50\\uDF82-\\uDF85]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC70\\uDC73\\uDC74\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDCC2\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDE41\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4\\uDF00\\uDF01\\uDF36-\\uDF3A\\uDF40\\uDF42]|\\uD80D[\\uDC40\\uDC47-\\uDC55]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD833[\\uDF00-\\uDF2D\\uDF30-\\uDF46]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDC8F\\uDD30-\\uDD36\\uDEAE\\uDEEC-\\uDEEF]|\\uD839[\\uDCEC-\\uDCEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])$/;\nvar rePrepend = /^(?:[\\u0600-\\u0605\\u06DD\\u070F\\u0890\\u0891\\u08E2\\u0D4E]|\\uD804[\\uDCBD\\uDCCD\\uDDC2\\uDDC3]|\\uD806[\\uDD3F\\uDD41\\uDE3A\\uDE84-\\uDE89]|\\uD807\\uDD46)$/;\nvar reSpacingMark = /^(?:[\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u094F\\u0982\\u0983\\u09BF\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0\\u0CC1\\u0CC3\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0D02\\u0D03\\u0D3F\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D82\\u0D83\\u0DD0\\u0DD1\\u0DD8-\\u0DDE\\u0DF2\\u0DF3\\u0E33\\u0EB3\\u0F3E\\u0F3F\\u0F7F\\u1031\\u103B\\u103C\\u1056\\u1057\\u1084\\u1715\\u1734\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u1A19\\u1A1A\\u1A55\\u1A57\\u1A6D-\\u1A72\\u1B04\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2\\u1BF3\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF7\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BE-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAAEB\\uAAEE\\uAAEF\\uAAF5\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]|\\uD804[\\uDC00\\uDC02\\uDC82\\uDCB0-\\uDCB2\\uDCB7\\uDCB8\\uDD2C\\uDD45\\uDD46\\uDD82\\uDDB3-\\uDDB5\\uDDBF\\uDDC0\\uDDCE\\uDE2C-\\uDE2E\\uDE32\\uDE33\\uDE35\\uDEE0-\\uDEE2\\uDF02\\uDF03\\uDF3F\\uDF41-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF62\\uDF63]|\\uD805[\\uDC35-\\uDC37\\uDC40\\uDC41\\uDC45\\uDCB1\\uDCB2\\uDCB9\\uDCBB\\uDCBC\\uDCBE\\uDCC1\\uDDB0\\uDDB1\\uDDB8-\\uDDBB\\uDDBE\\uDE30-\\uDE32\\uDE3B\\uDE3C\\uDE3E\\uDEAC\\uDEAE\\uDEAF\\uDEB6\\uDF26]|\\uD806[\\uDC2C-\\uDC2E\\uDC38\\uDD31-\\uDD35\\uDD37\\uDD38\\uDD3D\\uDD40\\uDD42\\uDDD1-\\uDDD3\\uDDDC-\\uDDDF\\uDDE4\\uDE39\\uDE57\\uDE58\\uDE97]|\\uD807[\\uDC2F\\uDC3E\\uDCA9\\uDCB1\\uDCB4\\uDD8A-\\uDD8E\\uDD93\\uDD94\\uDD96\\uDEF5\\uDEF6]|\\uD81B[\\uDF51-\\uDF87\\uDFF0\\uDFF1]|\\uD834[\\uDD66\\uDD6D])$/;\nvar reL = /^[\\u1100-\\u115F\\uA960-\\uA97C]$/;\nvar reV = /^[\\u1160-\\u11A7\\uD7B0-\\uD7C6]$/;\nvar reT = /^[\\u11A8-\\u11FF\\uD7CB-\\uD7FB]$/;\nvar reLV = /^[\\uAC00\\uAC1C\\uAC38\\uAC54\\uAC70\\uAC8C\\uACA8\\uACC4\\uACE0\\uACFC\\uAD18\\uAD34\\uAD50\\uAD6C\\uAD88\\uADA4\\uADC0\\uADDC\\uADF8\\uAE14\\uAE30\\uAE4C\\uAE68\\uAE84\\uAEA0\\uAEBC\\uAED8\\uAEF4\\uAF10\\uAF2C\\uAF48\\uAF64\\uAF80\\uAF9C\\uAFB8\\uAFD4\\uAFF0\\uB00C\\uB028\\uB044\\uB060\\uB07C\\uB098\\uB0B4\\uB0D0\\uB0EC\\uB108\\uB124\\uB140\\uB15C\\uB178\\uB194\\uB1B0\\uB1CC\\uB1E8\\uB204\\uB220\\uB23C\\uB258\\uB274\\uB290\\uB2AC\\uB2C8\\uB2E4\\uB300\\uB31C\\uB338\\uB354\\uB370\\uB38C\\uB3A8\\uB3C4\\uB3E0\\uB3FC\\uB418\\uB434\\uB450\\uB46C\\uB488\\uB4A4\\uB4C0\\uB4DC\\uB4F8\\uB514\\uB530\\uB54C\\uB568\\uB584\\uB5A0\\uB5BC\\uB5D8\\uB5F4\\uB610\\uB62C\\uB648\\uB664\\uB680\\uB69C\\uB6B8\\uB6D4\\uB6F0\\uB70C\\uB728\\uB744\\uB760\\uB77C\\uB798\\uB7B4\\uB7D0\\uB7EC\\uB808\\uB824\\uB840\\uB85C\\uB878\\uB894\\uB8B0\\uB8CC\\uB8E8\\uB904\\uB920\\uB93C\\uB958\\uB974\\uB990\\uB9AC\\uB9C8\\uB9E4\\uBA00\\uBA1C\\uBA38\\uBA54\\uBA70\\uBA8C\\uBAA8\\uBAC4\\uBAE0\\uBAFC\\uBB18\\uBB34\\uBB50\\uBB6C\\uBB88\\uBBA4\\uBBC0\\uBBDC\\uBBF8\\uBC14\\uBC30\\uBC4C\\uBC68\\uBC84\\uBCA0\\uBCBC\\uBCD8\\uBCF4\\uBD10\\uBD2C\\uBD48\\uBD64\\uBD80\\uBD9C\\uBDB8\\uBDD4\\uBDF0\\uBE0C\\uBE28\\uBE44\\uBE60\\uBE7C\\uBE98\\uBEB4\\uBED0\\uBEEC\\uBF08\\uBF24\\uBF40\\uBF5C\\uBF78\\uBF94\\uBFB0\\uBFCC\\uBFE8\\uC004\\uC020\\uC03C\\uC058\\uC074\\uC090\\uC0AC\\uC0C8\\uC0E4\\uC100\\uC11C\\uC138\\uC154\\uC170\\uC18C\\uC1A8\\uC1C4\\uC1E0\\uC1FC\\uC218\\uC234\\uC250\\uC26C\\uC288\\uC2A4\\uC2C0\\uC2DC\\uC2F8\\uC314\\uC330\\uC34C\\uC368\\uC384\\uC3A0\\uC3BC\\uC3D8\\uC3F4\\uC410\\uC42C\\uC448\\uC464\\uC480\\uC49C\\uC4B8\\uC4D4\\uC4F0\\uC50C\\uC528\\uC544\\uC560\\uC57C\\uC598\\uC5B4\\uC5D0\\uC5EC\\uC608\\uC624\\uC640\\uC65C\\uC678\\uC694\\uC6B0\\uC6CC\\uC6E8\\uC704\\uC720\\uC73C\\uC758\\uC774\\uC790\\uC7AC\\uC7C8\\uC7E4\\uC800\\uC81C\\uC838\\uC854\\uC870\\uC88C\\uC8A8\\uC8C4\\uC8E0\\uC8FC\\uC918\\uC934\\uC950\\uC96C\\uC988\\uC9A4\\uC9C0\\uC9DC\\uC9F8\\uCA14\\uCA30\\uCA4C\\uCA68\\uCA84\\uCAA0\\uCABC\\uCAD8\\uCAF4\\uCB10\\uCB2C\\uCB48\\uCB64\\uCB80\\uCB9C\\uCBB8\\uCBD4\\uCBF0\\uCC0C\\uCC28\\uCC44\\uCC60\\uCC7C\\uCC98\\uCCB4\\uCCD0\\uCCEC\\uCD08\\uCD24\\uCD40\\uCD5C\\uCD78\\uCD94\\uCDB0\\uCDCC\\uCDE8\\uCE04\\uCE20\\uCE3C\\uCE58\\uCE74\\uCE90\\uCEAC\\uCEC8\\uCEE4\\uCF00\\uCF1C\\uCF38\\uCF54\\uCF70\\uCF8C\\uCFA8\\uCFC4\\uCFE0\\uCFFC\\uD018\\uD034\\uD050\\uD06C\\uD088\\uD0A4\\uD0C0\\uD0DC\\uD0F8\\uD114\\uD130\\uD14C\\uD168\\uD184\\uD1A0\\uD1BC\\uD1D8\\uD1F4\\uD210\\uD22C\\uD248\\uD264\\uD280\\uD29C\\uD2B8\\uD2D4\\uD2F0\\uD30C\\uD328\\uD344\\uD360\\uD37C\\uD398\\uD3B4\\uD3D0\\uD3EC\\uD408\\uD424\\uD440\\uD45C\\uD478\\uD494\\uD4B0\\uD4CC\\uD4E8\\uD504\\uD520\\uD53C\\uD558\\uD574\\uD590\\uD5AC\\uD5C8\\uD5E4\\uD600\\uD61C\\uD638\\uD654\\uD670\\uD68C\\uD6A8\\uD6C4\\uD6E0\\uD6FC\\uD718\\uD734\\uD750\\uD76C\\uD788]$/;\nvar reLVT = /^[\\uAC01-\\uAC1B\\uAC1D-\\uAC37\\uAC39-\\uAC53\\uAC55-\\uAC6F\\uAC71-\\uAC8B\\uAC8D-\\uACA7\\uACA9-\\uACC3\\uACC5-\\uACDF\\uACE1-\\uACFB\\uACFD-\\uAD17\\uAD19-\\uAD33\\uAD35-\\uAD4F\\uAD51-\\uAD6B\\uAD6D-\\uAD87\\uAD89-\\uADA3\\uADA5-\\uADBF\\uADC1-\\uADDB\\uADDD-\\uADF7\\uADF9-\\uAE13\\uAE15-\\uAE2F\\uAE31-\\uAE4B\\uAE4D-\\uAE67\\uAE69-\\uAE83\\uAE85-\\uAE9F\\uAEA1-\\uAEBB\\uAEBD-\\uAED7\\uAED9-\\uAEF3\\uAEF5-\\uAF0F\\uAF11-\\uAF2B\\uAF2D-\\uAF47\\uAF49-\\uAF63\\uAF65-\\uAF7F\\uAF81-\\uAF9B\\uAF9D-\\uAFB7\\uAFB9-\\uAFD3\\uAFD5-\\uAFEF\\uAFF1-\\uB00B\\uB00D-\\uB027\\uB029-\\uB043\\uB045-\\uB05F\\uB061-\\uB07B\\uB07D-\\uB097\\uB099-\\uB0B3\\uB0B5-\\uB0CF\\uB0D1-\\uB0EB\\uB0ED-\\uB107\\uB109-\\uB123\\uB125-\\uB13F\\uB141-\\uB15B\\uB15D-\\uB177\\uB179-\\uB193\\uB195-\\uB1AF\\uB1B1-\\uB1CB\\uB1CD-\\uB1E7\\uB1E9-\\uB203\\uB205-\\uB21F\\uB221-\\uB23B\\uB23D-\\uB257\\uB259-\\uB273\\uB275-\\uB28F\\uB291-\\uB2AB\\uB2AD-\\uB2C7\\uB2C9-\\uB2E3\\uB2E5-\\uB2FF\\uB301-\\uB31B\\uB31D-\\uB337\\uB339-\\uB353\\uB355-\\uB36F\\uB371-\\uB38B\\uB38D-\\uB3A7\\uB3A9-\\uB3C3\\uB3C5-\\uB3DF\\uB3E1-\\uB3FB\\uB3FD-\\uB417\\uB419-\\uB433\\uB435-\\uB44F\\uB451-\\uB46B\\uB46D-\\uB487\\uB489-\\uB4A3\\uB4A5-\\uB4BF\\uB4C1-\\uB4DB\\uB4DD-\\uB4F7\\uB4F9-\\uB513\\uB515-\\uB52F\\uB531-\\uB54B\\uB54D-\\uB567\\uB569-\\uB583\\uB585-\\uB59F\\uB5A1-\\uB5BB\\uB5BD-\\uB5D7\\uB5D9-\\uB5F3\\uB5F5-\\uB60F\\uB611-\\uB62B\\uB62D-\\uB647\\uB649-\\uB663\\uB665-\\uB67F\\uB681-\\uB69B\\uB69D-\\uB6B7\\uB6B9-\\uB6D3\\uB6D5-\\uB6EF\\uB6F1-\\uB70B\\uB70D-\\uB727\\uB729-\\uB743\\uB745-\\uB75F\\uB761-\\uB77B\\uB77D-\\uB797\\uB799-\\uB7B3\\uB7B5-\\uB7CF\\uB7D1-\\uB7EB\\uB7ED-\\uB807\\uB809-\\uB823\\uB825-\\uB83F\\uB841-\\uB85B\\uB85D-\\uB877\\uB879-\\uB893\\uB895-\\uB8AF\\uB8B1-\\uB8CB\\uB8CD-\\uB8E7\\uB8E9-\\uB903\\uB905-\\uB91F\\uB921-\\uB93B\\uB93D-\\uB957\\uB959-\\uB973\\uB975-\\uB98F\\uB991-\\uB9AB\\uB9AD-\\uB9C7\\uB9C9-\\uB9E3\\uB9E5-\\uB9FF\\uBA01-\\uBA1B\\uBA1D-\\uBA37\\uBA39-\\uBA53\\uBA55-\\uBA6F\\uBA71-\\uBA8B\\uBA8D-\\uBAA7\\uBAA9-\\uBAC3\\uBAC5-\\uBADF\\uBAE1-\\uBAFB\\uBAFD-\\uBB17\\uBB19-\\uBB33\\uBB35-\\uBB4F\\uBB51-\\uBB6B\\uBB6D-\\uBB87\\uBB89-\\uBBA3\\uBBA5-\\uBBBF\\uBBC1-\\uBBDB\\uBBDD-\\uBBF7\\uBBF9-\\uBC13\\uBC15-\\uBC2F\\uBC31-\\uBC4B\\uBC4D-\\uBC67\\uBC69-\\uBC83\\uBC85-\\uBC9F\\uBCA1-\\uBCBB\\uBCBD-\\uBCD7\\uBCD9-\\uBCF3\\uBCF5-\\uBD0F\\uBD11-\\uBD2B\\uBD2D-\\uBD47\\uBD49-\\uBD63\\uBD65-\\uBD7F\\uBD81-\\uBD9B\\uBD9D-\\uBDB7\\uBDB9-\\uBDD3\\uBDD5-\\uBDEF\\uBDF1-\\uBE0B\\uBE0D-\\uBE27\\uBE29-\\uBE43\\uBE45-\\uBE5F\\uBE61-\\uBE7B\\uBE7D-\\uBE97\\uBE99-\\uBEB3\\uBEB5-\\uBECF\\uBED1-\\uBEEB\\uBEED-\\uBF07\\uBF09-\\uBF23\\uBF25-\\uBF3F\\uBF41-\\uBF5B\\uBF5D-\\uBF77\\uBF79-\\uBF93\\uBF95-\\uBFAF\\uBFB1-\\uBFCB\\uBFCD-\\uBFE7\\uBFE9-\\uC003\\uC005-\\uC01F\\uC021-\\uC03B\\uC03D-\\uC057\\uC059-\\uC073\\uC075-\\uC08F\\uC091-\\uC0AB\\uC0AD-\\uC0C7\\uC0C9-\\uC0E3\\uC0E5-\\uC0FF\\uC101-\\uC11B\\uC11D-\\uC137\\uC139-\\uC153\\uC155-\\uC16F\\uC171-\\uC18B\\uC18D-\\uC1A7\\uC1A9-\\uC1C3\\uC1C5-\\uC1DF\\uC1E1-\\uC1FB\\uC1FD-\\uC217\\uC219-\\uC233\\uC235-\\uC24F\\uC251-\\uC26B\\uC26D-\\uC287\\uC289-\\uC2A3\\uC2A5-\\uC2BF\\uC2C1-\\uC2DB\\uC2DD-\\uC2F7\\uC2F9-\\uC313\\uC315-\\uC32F\\uC331-\\uC34B\\uC34D-\\uC367\\uC369-\\uC383\\uC385-\\uC39F\\uC3A1-\\uC3BB\\uC3BD-\\uC3D7\\uC3D9-\\uC3F3\\uC3F5-\\uC40F\\uC411-\\uC42B\\uC42D-\\uC447\\uC449-\\uC463\\uC465-\\uC47F\\uC481-\\uC49B\\uC49D-\\uC4B7\\uC4B9-\\uC4D3\\uC4D5-\\uC4EF\\uC4F1-\\uC50B\\uC50D-\\uC527\\uC529-\\uC543\\uC545-\\uC55F\\uC561-\\uC57B\\uC57D-\\uC597\\uC599-\\uC5B3\\uC5B5-\\uC5CF\\uC5D1-\\uC5EB\\uC5ED-\\uC607\\uC609-\\uC623\\uC625-\\uC63F\\uC641-\\uC65B\\uC65D-\\uC677\\uC679-\\uC693\\uC695-\\uC6AF\\uC6B1-\\uC6CB\\uC6CD-\\uC6E7\\uC6E9-\\uC703\\uC705-\\uC71F\\uC721-\\uC73B\\uC73D-\\uC757\\uC759-\\uC773\\uC775-\\uC78F\\uC791-\\uC7AB\\uC7AD-\\uC7C7\\uC7C9-\\uC7E3\\uC7E5-\\uC7FF\\uC801-\\uC81B\\uC81D-\\uC837\\uC839-\\uC853\\uC855-\\uC86F\\uC871-\\uC88B\\uC88D-\\uC8A7\\uC8A9-\\uC8C3\\uC8C5-\\uC8DF\\uC8E1-\\uC8FB\\uC8FD-\\uC917\\uC919-\\uC933\\uC935-\\uC94F\\uC951-\\uC96B\\uC96D-\\uC987\\uC989-\\uC9A3\\uC9A5-\\uC9BF\\uC9C1-\\uC9DB\\uC9DD-\\uC9F7\\uC9F9-\\uCA13\\uCA15-\\uCA2F\\uCA31-\\uCA4B\\uCA4D-\\uCA67\\uCA69-\\uCA83\\uCA85-\\uCA9F\\uCAA1-\\uCABB\\uCABD-\\uCAD7\\uCAD9-\\uCAF3\\uCAF5-\\uCB0F\\uCB11-\\uCB2B\\uCB2D-\\uCB47\\uCB49-\\uCB63\\uCB65-\\uCB7F\\uCB81-\\uCB9B\\uCB9D-\\uCBB7\\uCBB9-\\uCBD3\\uCBD5-\\uCBEF\\uCBF1-\\uCC0B\\uCC0D-\\uCC27\\uCC29-\\uCC43\\uCC45-\\uCC5F\\uCC61-\\uCC7B\\uCC7D-\\uCC97\\uCC99-\\uCCB3\\uCCB5-\\uCCCF\\uCCD1-\\uCCEB\\uCCED-\\uCD07\\uCD09-\\uCD23\\uCD25-\\uCD3F\\uCD41-\\uCD5B\\uCD5D-\\uCD77\\uCD79-\\uCD93\\uCD95-\\uCDAF\\uCDB1-\\uCDCB\\uCDCD-\\uCDE7\\uCDE9-\\uCE03\\uCE05-\\uCE1F\\uCE21-\\uCE3B\\uCE3D-\\uCE57\\uCE59-\\uCE73\\uCE75-\\uCE8F\\uCE91-\\uCEAB\\uCEAD-\\uCEC7\\uCEC9-\\uCEE3\\uCEE5-\\uCEFF\\uCF01-\\uCF1B\\uCF1D-\\uCF37\\uCF39-\\uCF53\\uCF55-\\uCF6F\\uCF71-\\uCF8B\\uCF8D-\\uCFA7\\uCFA9-\\uCFC3\\uCFC5-\\uCFDF\\uCFE1-\\uCFFB\\uCFFD-\\uD017\\uD019-\\uD033\\uD035-\\uD04F\\uD051-\\uD06B\\uD06D-\\uD087\\uD089-\\uD0A3\\uD0A5-\\uD0BF\\uD0C1-\\uD0DB\\uD0DD-\\uD0F7\\uD0F9-\\uD113\\uD115-\\uD12F\\uD131-\\uD14B\\uD14D-\\uD167\\uD169-\\uD183\\uD185-\\uD19F\\uD1A1-\\uD1BB\\uD1BD-\\uD1D7\\uD1D9-\\uD1F3\\uD1F5-\\uD20F\\uD211-\\uD22B\\uD22D-\\uD247\\uD249-\\uD263\\uD265-\\uD27F\\uD281-\\uD29B\\uD29D-\\uD2B7\\uD2B9-\\uD2D3\\uD2D5-\\uD2EF\\uD2F1-\\uD30B\\uD30D-\\uD327\\uD329-\\uD343\\uD345-\\uD35F\\uD361-\\uD37B\\uD37D-\\uD397\\uD399-\\uD3B3\\uD3B5-\\uD3CF\\uD3D1-\\uD3EB\\uD3ED-\\uD407\\uD409-\\uD423\\uD425-\\uD43F\\uD441-\\uD45B\\uD45D-\\uD477\\uD479-\\uD493\\uD495-\\uD4AF\\uD4B1-\\uD4CB\\uD4CD-\\uD4E7\\uD4E9-\\uD503\\uD505-\\uD51F\\uD521-\\uD53B\\uD53D-\\uD557\\uD559-\\uD573\\uD575-\\uD58F\\uD591-\\uD5AB\\uD5AD-\\uD5C7\\uD5C9-\\uD5E3\\uD5E5-\\uD5FF\\uD601-\\uD61B\\uD61D-\\uD637\\uD639-\\uD653\\uD655-\\uD66F\\uD671-\\uD68B\\uD68D-\\uD6A7\\uD6A9-\\uD6C3\\uD6C5-\\uD6DF\\uD6E1-\\uD6FB\\uD6FD-\\uD717\\uD719-\\uD733\\uD735-\\uD74F\\uD751-\\uD76B\\uD76D-\\uD787\\uD789-\\uD7A3]$/;\nvar reExtPict = /^(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])$/;\nvar getCodepointType = (char, code) => {\n  var type = CodepointType.Any;\n  if (char.search(reExtend) !== -1) {\n    type |= CodepointType.Extend;\n  }\n  if (code === 0x200d) {\n    type |= CodepointType.ZWJ;\n  }\n  if (code >= 0x1f1e6 && code <= 0x1f1ff) {\n    type |= CodepointType.RI;\n  }\n  if (char.search(rePrepend) !== -1) {\n    type |= CodepointType.Prepend;\n  }\n  if (char.search(reSpacingMark) !== -1) {\n    type |= CodepointType.SpacingMark;\n  }\n  if (char.search(reL) !== -1) {\n    type |= CodepointType.L;\n  }\n  if (char.search(reV) !== -1) {\n    type |= CodepointType.V;\n  }\n  if (char.search(reT) !== -1) {\n    type |= CodepointType.T;\n  }\n  if (char.search(reLV) !== -1) {\n    type |= CodepointType.LV;\n  }\n  if (char.search(reLVT) !== -1) {\n    type |= CodepointType.LVT;\n  }\n  if (char.search(reExtPict) !== -1) {\n    type |= CodepointType.ExtPict;\n  }\n  return type;\n};\nfunction intersects(x, y) {\n  return (x & y) !== 0;\n}\nvar NonBoundaryPairs = [\n// GB6\n[CodepointType.L, CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT],\n// GB7\n[CodepointType.LV | CodepointType.V, CodepointType.V | CodepointType.T],\n// GB8\n[CodepointType.LVT | CodepointType.T, CodepointType.T],\n// GB9\n[CodepointType.Any, CodepointType.Extend | CodepointType.ZWJ],\n// GB9a\n[CodepointType.Any, CodepointType.SpacingMark],\n// GB9b\n[CodepointType.Prepend, CodepointType.Any],\n// GB11\n[CodepointType.ZWJ, CodepointType.ExtPict],\n// GB12 and GB13\n[CodepointType.RI, CodepointType.RI]];\nfunction isBoundaryPair(left, right) {\n  return NonBoundaryPairs.findIndex(r => intersects(left, r[0]) && intersects(right, r[1])) === -1;\n}\nvar endingEmojiZWJ = /(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u0898-\\u089F\\u08CA-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3C\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECE\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732\\u1733\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u180F\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1ACE\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDEFD-\\uDEFF\\uDF46-\\uDF50\\uDF82-\\uDF85]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC70\\uDC73\\uDC74\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDCC2\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDE41\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4\\uDF00\\uDF01\\uDF36-\\uDF3A\\uDF40\\uDF42]|\\uD80D[\\uDC40\\uDC47-\\uDC55]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD833[\\uDF00-\\uDF2D\\uDF30-\\uDF46]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDC8F\\uDD30-\\uDD36\\uDEAE\\uDEEC-\\uDEEF]|\\uD839[\\uDCEC-\\uDCEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])*\\u200D$/;\nvar endsWithEmojiZWJ = str => {\n  return str.search(endingEmojiZWJ) !== -1;\n};\nvar endingRIs = /(?:\\uD83C[\\uDDE6-\\uDDFF])+$/g;\nvar endsWithOddNumberOfRIs = str => {\n  var match = str.match(endingRIs);\n  if (match === null) {\n    return false;\n  } else {\n    // A RI is represented by a surrogate pair.\n    var numRIs = match[0].length / 2;\n    return numRIs % 2 === 1;\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar TextTransforms = {\n  delete(editor, options) {\n    editor.delete(options);\n  },\n  insertFragment(editor, fragment, options) {\n    editor.insertFragment(fragment, options);\n  },\n  insertText(editor, text) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        voids = false\n      } = options;\n      var {\n        at = getDefaultInsertLocation(editor)\n      } = options;\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at);\n      }\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var end = Range.end(at);\n          if (!voids && Editor.void(editor, {\n            at: end\n          })) {\n            return;\n          }\n          var start = Range.start(at);\n          var startRef = Editor.pointRef(editor, start);\n          var endRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at,\n            voids\n          });\n          var startPoint = startRef.unref();\n          var endPoint = endRef.unref();\n          at = startPoint || endPoint;\n          Transforms.setSelection(editor, {\n            anchor: at,\n            focus: at\n          });\n        }\n      }\n      if (!voids && Editor.void(editor, {\n        at\n      }) || Editor.elementReadOnly(editor, {\n        at\n      })) {\n        return;\n      }\n      var {\n        path,\n        offset\n      } = at;\n      if (text.length > 0) editor.apply({\n        type: 'insert_text',\n        path,\n        offset,\n        text\n      });\n    });\n  }\n};\n\nfunction ownKeys$9(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$9(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$9(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$9(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar Transforms = _objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);\n\n// perf\nvar BATCHING_DIRTY_PATHS = new WeakMap();\nvar isBatchingDirtyPaths = editor => {\n  return BATCHING_DIRTY_PATHS.get(editor) || false;\n};\nvar batchDirtyPaths = (editor, fn, update) => {\n  var value = BATCHING_DIRTY_PATHS.get(editor) || false;\n  BATCHING_DIRTY_PATHS.set(editor, true);\n  try {\n    fn();\n    update();\n  } finally {\n    BATCHING_DIRTY_PATHS.set(editor, value);\n  }\n};\n\n/**\n * update editor dirty paths\n *\n * @param newDirtyPaths: Path[]; new dirty paths\n * @param transform: (p: Path) => Path | null; how to transform existing dirty paths\n */\nfunction updateDirtyPaths(editor, newDirtyPaths, transform) {\n  var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];\n  var oldDirtyPathKeys = DIRTY_PATH_KEYS.get(editor) || new Set();\n  var dirtyPaths;\n  var dirtyPathKeys;\n  var add = path => {\n    if (path) {\n      var key = path.join(',');\n      if (!dirtyPathKeys.has(key)) {\n        dirtyPathKeys.add(key);\n        dirtyPaths.push(path);\n      }\n    }\n  };\n  if (transform) {\n    dirtyPaths = [];\n    dirtyPathKeys = new Set();\n    for (var path of oldDirtyPaths) {\n      var newPath = transform(path);\n      add(newPath);\n    }\n  } else {\n    dirtyPaths = oldDirtyPaths;\n    dirtyPathKeys = oldDirtyPathKeys;\n  }\n  for (var _path of newDirtyPaths) {\n    add(_path);\n  }\n  DIRTY_PATHS.set(editor, dirtyPaths);\n  DIRTY_PATH_KEYS.set(editor, dirtyPathKeys);\n}\n\nvar apply = (editor, op) => {\n  for (var ref of Editor.pathRefs(editor)) {\n    PathRef.transform(ref, op);\n  }\n  for (var _ref of Editor.pointRefs(editor)) {\n    PointRef.transform(_ref, op);\n  }\n  for (var _ref2 of Editor.rangeRefs(editor)) {\n    RangeRef.transform(_ref2, op);\n  }\n  // update dirty paths\n  if (!isBatchingDirtyPaths(editor)) {\n    var transform = Path.operationCanTransformPath(op) ? p => Path.transform(p, op) : undefined;\n    updateDirtyPaths(editor, editor.getDirtyPaths(op), transform);\n  }\n  Transforms.transform(editor, op);\n  editor.operations.push(op);\n  Editor.normalize(editor, {\n    operation: op\n  });\n  // Clear any formats applied to the cursor if the selection changes.\n  if (op.type === 'set_selection') {\n    editor.marks = null;\n  }\n  if (!FLUSHING.get(editor)) {\n    FLUSHING.set(editor, true);\n    Promise.resolve().then(() => {\n      FLUSHING.set(editor, false);\n      editor.onChange({\n        operation: op\n      });\n      editor.operations = [];\n    });\n  }\n};\n\n/**\n * Get the \"dirty\" paths generated from an operation.\n */\nvar getDirtyPaths = (editor, op) => {\n  switch (op.type) {\n    case 'insert_text':\n    case 'remove_text':\n    case 'set_node':\n      {\n        var {\n          path\n        } = op;\n        return Path.levels(path);\n      }\n    case 'insert_node':\n      {\n        var {\n          node,\n          path: _path\n        } = op;\n        var levels = Path.levels(_path);\n        var descendants = Text.isText(node) ? [] : Array.from(Node.nodes(node), _ref => {\n          var [, p] = _ref;\n          return _path.concat(p);\n        });\n        return [...levels, ...descendants];\n      }\n    case 'merge_node':\n      {\n        var {\n          path: _path2\n        } = op;\n        var ancestors = Path.ancestors(_path2);\n        var previousPath = Path.previous(_path2);\n        return [...ancestors, previousPath];\n      }\n    case 'move_node':\n      {\n        var {\n          path: _path3,\n          newPath\n        } = op;\n        if (Path.equals(_path3, newPath)) {\n          return [];\n        }\n        var oldAncestors = [];\n        var newAncestors = [];\n        for (var ancestor of Path.ancestors(_path3)) {\n          var p = Path.transform(ancestor, op);\n          oldAncestors.push(p);\n        }\n        for (var _ancestor of Path.ancestors(newPath)) {\n          var _p = Path.transform(_ancestor, op);\n          newAncestors.push(_p);\n        }\n        var newParent = newAncestors[newAncestors.length - 1];\n        var newIndex = newPath[newPath.length - 1];\n        var resultPath = newParent.concat(newIndex);\n        return [...oldAncestors, ...newAncestors, resultPath];\n      }\n    case 'remove_node':\n      {\n        var {\n          path: _path4\n        } = op;\n        var _ancestors = Path.ancestors(_path4);\n        return [..._ancestors];\n      }\n    case 'split_node':\n      {\n        var {\n          path: _path5\n        } = op;\n        var _levels = Path.levels(_path5);\n        var nextPath = Path.next(_path5);\n        return [..._levels, nextPath];\n      }\n    default:\n      {\n        return [];\n      }\n  }\n};\n\nvar getFragment = editor => {\n  var {\n    selection\n  } = editor;\n  if (selection) {\n    return Node.fragment(editor, selection);\n  }\n  return [];\n};\n\nvar normalizeNode = (editor, entry, options) => {\n  var [node, path] = entry;\n  // There are no core normalizations for text nodes.\n  if (Text.isText(node)) {\n    return;\n  }\n  // Ensure that block and inline nodes have at least one text child.\n  if (Element.isElement(node) && node.children.length === 0) {\n    var child = {\n      text: ''\n    };\n    Transforms.insertNodes(editor, child, {\n      at: path.concat(0),\n      voids: true\n    });\n    return;\n  }\n  // Determine whether the node should have block or inline children.\n  var shouldHaveInlines = Editor.isEditor(node) ? false : Element.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0]));\n  // Since we'll be applying operations while iterating, keep track of an\n  // index that accounts for any added/removed nodes.\n  var n = 0;\n  for (var i = 0; i < node.children.length; i++, n++) {\n    var currentNode = Node.get(editor, path);\n    if (Text.isText(currentNode)) continue;\n    var _child = currentNode.children[n];\n    var prev = currentNode.children[n - 1];\n    var isLast = i === node.children.length - 1;\n    var isInlineOrText = Text.isText(_child) || Element.isElement(_child) && editor.isInline(_child);\n    // Only allow block nodes in the top-level children and parent blocks\n    // that only contain block nodes. Similarly, only allow inline nodes in\n    // other inline nodes, or parent blocks that only contain inlines and\n    // text.\n    if (isInlineOrText !== shouldHaveInlines) {\n      if (isInlineOrText) {\n        if (options !== null && options !== void 0 && options.fallbackElement) {\n          Transforms.wrapNodes(editor, options.fallbackElement(), {\n            at: path.concat(n),\n            voids: true\n          });\n        } else {\n          Transforms.removeNodes(editor, {\n            at: path.concat(n),\n            voids: true\n          });\n        }\n      } else {\n        Transforms.unwrapNodes(editor, {\n          at: path.concat(n),\n          voids: true\n        });\n      }\n      n--;\n    } else if (Element.isElement(_child)) {\n      // Ensure that inline nodes are surrounded by text nodes.\n      if (editor.isInline(_child)) {\n        if (prev == null || !Text.isText(prev)) {\n          var newChild = {\n            text: ''\n          };\n          Transforms.insertNodes(editor, newChild, {\n            at: path.concat(n),\n            voids: true\n          });\n          n++;\n        } else if (isLast) {\n          var _newChild = {\n            text: ''\n          };\n          Transforms.insertNodes(editor, _newChild, {\n            at: path.concat(n + 1),\n            voids: true\n          });\n          n++;\n        }\n      }\n    } else {\n      // If the child is not a text node, and doesn't have a `children` field,\n      // then we have an invalid node that will upset slate.\n      //\n      // eg: `{ type: 'some_node' }`.\n      //\n      // To prevent slate from breaking, we can add the `children` field,\n      // and now that it is valid, we can to many more operations easily,\n      // such as extend normalizers to fix erronous structure.\n      if (!Text.isText(_child) && !('children' in _child)) {\n        var elementChild = _child;\n        elementChild.children = [];\n      }\n      // Merge adjacent text nodes that are empty or match.\n      if (prev != null && Text.isText(prev)) {\n        if (Text.equals(_child, prev, {\n          loose: true\n        })) {\n          Transforms.mergeNodes(editor, {\n            at: path.concat(n),\n            voids: true\n          });\n          n--;\n        } else if (prev.text === '') {\n          Transforms.removeNodes(editor, {\n            at: path.concat(n - 1),\n            voids: true\n          });\n          n--;\n        } else if (_child.text === '') {\n          Transforms.removeNodes(editor, {\n            at: path.concat(n),\n            voids: true\n          });\n          n--;\n        }\n      }\n    }\n  }\n};\n\nvar shouldNormalize = (editor, _ref) => {\n  var {\n    iteration,\n    initialDirtyPathsLength\n  } = _ref;\n  var maxIterations = initialDirtyPathsLength * 42; // HACK: better way?\n  if (iteration > maxIterations) {\n    throw new Error(\"Could not completely normalize the editor after \".concat(maxIterations, \" iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\"));\n  }\n  return true;\n};\n\nvar above = function above(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    voids = false,\n    mode = 'lowest',\n    at = editor.selection,\n    match\n  } = options;\n  if (!at) {\n    return;\n  }\n  var path = Editor.path(editor, at);\n  // If `at` is a Range that spans mulitple nodes, `path` will be their common ancestor.\n  // Otherwise `path` will be a text node and/or the same as `at`, in which cases we want to start with its parent.\n  if (!Range.isRange(at) || Path.equals(at.focus.path, at.anchor.path)) {\n    if (path.length === 0) return;\n    path = Path.parent(path);\n  }\n  var reverse = mode === 'lowest';\n  var [firstMatch] = Editor.levels(editor, {\n    at: path,\n    voids,\n    match,\n    reverse\n  });\n  return firstMatch; // if nothing matches this returns undefined\n};\n\nfunction ownKeys$8(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$8(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$8(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$8(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar addMark = (editor, key, value) => {\n  var {\n    selection\n  } = editor;\n  if (selection) {\n    var match = (node, path) => {\n      if (!Text.isText(node)) {\n        return false; // marks can only be applied to text\n      }\n\n      var [parentNode, parentPath] = Editor.parent(editor, path);\n      return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n    };\n    var expandedSelection = Range.isExpanded(selection);\n    var markAcceptingVoidSelected = false;\n    if (!expandedSelection) {\n      var [selectedNode, selectedPath] = Editor.node(editor, selection);\n      if (selectedNode && match(selectedNode, selectedPath)) {\n        var [parentNode] = Editor.parent(editor, selectedPath);\n        markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n      }\n    }\n    if (expandedSelection || markAcceptingVoidSelected) {\n      Transforms.setNodes(editor, {\n        [key]: value\n      }, {\n        match,\n        split: true,\n        voids: true\n      });\n    } else {\n      var marks = _objectSpread$8(_objectSpread$8({}, Editor.marks(editor) || {}), {}, {\n        [key]: value\n      });\n      editor.marks = marks;\n      if (!FLUSHING.get(editor)) {\n        editor.onChange();\n      }\n    }\n  }\n};\n\nfunction ownKeys$7(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$7(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$7(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$7(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar after = function after(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var anchor = Editor.point(editor, at, {\n    edge: 'end'\n  });\n  var focus = Editor.end(editor, []);\n  var range = {\n    anchor,\n    focus\n  };\n  var {\n    distance = 1\n  } = options;\n  var d = 0;\n  var target;\n  for (var p of Editor.positions(editor, _objectSpread$7(_objectSpread$7({}, options), {}, {\n    at: range\n  }))) {\n    if (d > distance) {\n      break;\n    }\n    if (d !== 0) {\n      target = p;\n    }\n    d++;\n  }\n  return target;\n};\n\nfunction ownKeys$6(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$6(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$6(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar before = function before(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var anchor = Editor.start(editor, []);\n  var focus = Editor.point(editor, at, {\n    edge: 'start'\n  });\n  var range = {\n    anchor,\n    focus\n  };\n  var {\n    distance = 1\n  } = options;\n  var d = 0;\n  var target;\n  for (var p of Editor.positions(editor, _objectSpread$6(_objectSpread$6({}, options), {}, {\n    at: range,\n    reverse: true\n  }))) {\n    if (d > distance) {\n      break;\n    }\n    if (d !== 0) {\n      target = p;\n    }\n    d++;\n  }\n  return target;\n};\n\nvar deleteBackward = (editor, unit) => {\n  var {\n    selection\n  } = editor;\n  if (selection && Range.isCollapsed(selection)) {\n    Transforms.delete(editor, {\n      unit,\n      reverse: true\n    });\n  }\n};\n\nvar deleteForward = (editor, unit) => {\n  var {\n    selection\n  } = editor;\n  if (selection && Range.isCollapsed(selection)) {\n    Transforms.delete(editor, {\n      unit\n    });\n  }\n};\n\nvar deleteFragment = function deleteFragment(editor) {\n  var {\n    direction = 'forward'\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    selection\n  } = editor;\n  if (selection && Range.isExpanded(selection)) {\n    Transforms.delete(editor, {\n      reverse: direction === 'backward'\n    });\n  }\n};\n\nvar edges = (editor, at) => {\n  return [Editor.start(editor, at), Editor.end(editor, at)];\n};\n\nfunction ownKeys$5(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$5(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$5(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar elementReadOnly = function elementReadOnly(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Editor.above(editor, _objectSpread$5(_objectSpread$5({}, options), {}, {\n    match: n => Element.isElement(n) && Editor.isElementReadOnly(editor, n)\n  }));\n};\n\nvar end = (editor, at) => {\n  return Editor.point(editor, at, {\n    edge: 'end'\n  });\n};\n\nvar first = (editor, at) => {\n  var path = Editor.path(editor, at, {\n    edge: 'start'\n  });\n  return Editor.node(editor, path);\n};\n\nvar fragment = (editor, at) => {\n  var range = Editor.range(editor, at);\n  return Node.fragment(editor, range);\n};\n\nfunction ownKeys$4(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$4(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$4(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar getVoid = function getVoid(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Editor.above(editor, _objectSpread$4(_objectSpread$4({}, options), {}, {\n    match: n => Element.isElement(n) && Editor.isVoid(editor, n)\n  }));\n};\n\nvar hasBlocks = (editor, element) => {\n  return element.children.some(n => Element.isElement(n) && Editor.isBlock(editor, n));\n};\n\nvar hasInlines = (editor, element) => {\n  return element.children.some(n => Text.isText(n) || Editor.isInline(editor, n));\n};\n\nvar hasPath = (editor, path) => {\n  return Node.has(editor, path);\n};\n\nvar hasTexts = (editor, element) => {\n  return element.children.every(n => Text.isText(n));\n};\n\nvar insertBreak = editor => {\n  Transforms.splitNodes(editor, {\n    always: true\n  });\n};\n\nvar insertNode = (editor, node, options) => {\n  Transforms.insertNodes(editor, node, options);\n};\n\nvar insertSoftBreak = editor => {\n  Transforms.splitNodes(editor, {\n    always: true\n  });\n};\n\nfunction ownKeys$3(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$3(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$3(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar insertText = function insertText(editor, text) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    selection,\n    marks\n  } = editor;\n  if (selection) {\n    if (marks) {\n      var node = _objectSpread$3({\n        text\n      }, marks);\n      Transforms.insertNodes(editor, node, {\n        at: options.at,\n        voids: options.voids\n      });\n    } else {\n      Transforms.insertText(editor, text, options);\n    }\n    editor.marks = null;\n  }\n};\n\nvar isBlock = (editor, value) => {\n  return !editor.isInline(value);\n};\n\nvar isEdge = (editor, point, at) => {\n  return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);\n};\n\nvar isEmpty = (editor, element) => {\n  var {\n    children\n  } = element;\n  var [first] = children;\n  return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === '' && !editor.isVoid(element);\n};\n\nvar isEnd = (editor, point, at) => {\n  var end = Editor.end(editor, at);\n  return Point.equals(point, end);\n};\n\nvar isNormalizing = editor => {\n  var isNormalizing = NORMALIZING.get(editor);\n  return isNormalizing === undefined ? true : isNormalizing;\n};\n\nvar isStart = (editor, point, at) => {\n  // PERF: If the offset isn't `0` we know it's not the start.\n  if (point.offset !== 0) {\n    return false;\n  }\n  var start = Editor.start(editor, at);\n  return Point.equals(point, start);\n};\n\nvar last = (editor, at) => {\n  var path = Editor.path(editor, at, {\n    edge: 'end'\n  });\n  return Editor.node(editor, path);\n};\n\nvar leaf = function leaf(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var path = Editor.path(editor, at, options);\n  var node = Node.leaf(editor, path);\n  return [node, path];\n};\n\nfunction levels(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function* () {\n    var {\n      at = editor.selection,\n      reverse = false,\n      voids = false\n    } = options;\n    var {\n      match\n    } = options;\n    if (match == null) {\n      match = () => true;\n    }\n    if (!at) {\n      return;\n    }\n    var levels = [];\n    var path = Editor.path(editor, at);\n    for (var [n, p] of Node.levels(editor, path)) {\n      if (!match(n, p)) {\n        continue;\n      }\n      levels.push([n, p]);\n      if (!voids && Element.isElement(n) && Editor.isVoid(editor, n)) {\n        break;\n      }\n    }\n    if (reverse) {\n      levels.reverse();\n    }\n    yield* levels;\n  }();\n}\n\nvar _excluded$1 = [\"text\"],\n  _excluded2$1 = [\"text\"];\nvar marks = function marks(editor) {\n  var {\n    marks,\n    selection\n  } = editor;\n  if (!selection) {\n    return null;\n  }\n  var {\n    anchor,\n    focus\n  } = selection;\n  if (marks) {\n    return marks;\n  }\n  if (Range.isExpanded(selection)) {\n    var isBackward = Range.isBackward(selection);\n    if (isBackward) {\n      [focus, anchor] = [anchor, focus];\n    }\n    /**\n     * COMPAT: Make sure hanging ranges (caused by double clicking in Firefox)\n     * do not adversely affect the returned marks.\n     */\n    var isEnd = Editor.isEnd(editor, anchor, anchor.path);\n    if (isEnd) {\n      var after = Editor.after(editor, anchor);\n      if (after) {\n        anchor = after;\n      }\n    }\n    var [match] = Editor.nodes(editor, {\n      match: Text.isText,\n      at: {\n        anchor,\n        focus\n      }\n    });\n    if (match) {\n      var [_node] = match;\n      var _rest = _objectWithoutProperties(_node, _excluded$1);\n      return _rest;\n    } else {\n      return {};\n    }\n  }\n  var {\n    path\n  } = anchor;\n  var [node] = Editor.leaf(editor, path);\n  if (anchor.offset === 0) {\n    var prev = Editor.previous(editor, {\n      at: path,\n      match: Text.isText\n    });\n    var markedVoid = Editor.above(editor, {\n      match: n => Element.isElement(n) && Editor.isVoid(editor, n) && editor.markableVoid(n)\n    });\n    if (!markedVoid) {\n      var block = Editor.above(editor, {\n        match: n => Element.isElement(n) && Editor.isBlock(editor, n)\n      });\n      if (prev && block) {\n        var [prevNode, prevPath] = prev;\n        var [, blockPath] = block;\n        if (Path.isAncestor(blockPath, prevPath)) {\n          node = prevNode;\n        }\n      }\n    }\n  }\n  var rest = _objectWithoutProperties(node, _excluded2$1);\n  return rest;\n};\n\nvar next = function next(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    mode = 'lowest',\n    voids = false\n  } = options;\n  var {\n    match,\n    at = editor.selection\n  } = options;\n  if (!at) {\n    return;\n  }\n  var pointAfterLocation = Editor.after(editor, at, {\n    voids\n  });\n  if (!pointAfterLocation) return;\n  var [, to] = Editor.last(editor, []);\n  var span = [pointAfterLocation.path, to];\n  if (Path.isPath(at) && at.length === 0) {\n    throw new Error(\"Cannot get the next node from the root node!\");\n  }\n  if (match == null) {\n    if (Path.isPath(at)) {\n      var [parent] = Editor.parent(editor, at);\n      match = n => parent.children.includes(n);\n    } else {\n      match = () => true;\n    }\n  }\n  var [next] = Editor.nodes(editor, {\n    at: span,\n    match,\n    mode,\n    voids\n  });\n  return next;\n};\n\nvar node = function node(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var path = Editor.path(editor, at, options);\n  var node = Node.get(editor, path);\n  return [node, path];\n};\n\nfunction nodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function* () {\n    var {\n      at = editor.selection,\n      mode = 'all',\n      universal = false,\n      reverse = false,\n      voids = false,\n      pass: _pass\n    } = options;\n    var {\n      match\n    } = options;\n    if (!match) {\n      match = () => true;\n    }\n    if (!at) {\n      return;\n    }\n    var from;\n    var to;\n    if (Span.isSpan(at)) {\n      from = at[0];\n      to = at[1];\n    } else {\n      var first = Editor.path(editor, at, {\n        edge: 'start'\n      });\n      var last = Editor.path(editor, at, {\n        edge: 'end'\n      });\n      from = reverse ? last : first;\n      to = reverse ? first : last;\n    }\n    var nodeEntries = Node.nodes(editor, {\n      reverse,\n      from,\n      to,\n      pass: _ref => {\n        var [node, path] = _ref;\n        if (_pass && _pass([node, path])) return true;\n        if (!Element.isElement(node)) return false;\n        if (!voids && (Editor.isVoid(editor, node) || Editor.isElementReadOnly(editor, node))) return true;\n        return false;\n      }\n    });\n    var matches = [];\n    var hit;\n    for (var [node, path] of nodeEntries) {\n      var isLower = hit && Path.compare(path, hit[1]) === 0;\n      // In highest mode any node lower than the last hit is not a match.\n      if (mode === 'highest' && isLower) {\n        continue;\n      }\n      if (!match(node, path)) {\n        // If we've arrived at a leaf text node that is not lower than the last\n        // hit, then we've found a branch that doesn't include a match, which\n        // means the match is not universal.\n        if (universal && !isLower && Text.isText(node)) {\n          return;\n        } else {\n          continue;\n        }\n      }\n      // If there's a match and it's lower than the last, update the hit.\n      if (mode === 'lowest' && isLower) {\n        hit = [node, path];\n        continue;\n      }\n      // In lowest mode we emit the last hit, once it's guaranteed lowest.\n      var emit = mode === 'lowest' ? hit : [node, path];\n      if (emit) {\n        if (universal) {\n          matches.push(emit);\n        } else {\n          yield emit;\n        }\n      }\n      hit = [node, path];\n    }\n    // Since lowest is always emitting one behind, catch up at the end.\n    if (mode === 'lowest' && hit) {\n      if (universal) {\n        matches.push(hit);\n      } else {\n        yield hit;\n      }\n    }\n    // Universal defers to ensure that the match occurs in every branch, so we\n    // yield all of the matches after iterating.\n    if (universal) {\n      yield* matches;\n    }\n  }();\n}\n\nvar normalize = function normalize(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    force = false,\n    operation\n  } = options;\n  var getDirtyPaths = editor => {\n    return DIRTY_PATHS.get(editor) || [];\n  };\n  var getDirtyPathKeys = editor => {\n    return DIRTY_PATH_KEYS.get(editor) || new Set();\n  };\n  var popDirtyPath = editor => {\n    var path = getDirtyPaths(editor).pop();\n    var key = path.join(',');\n    getDirtyPathKeys(editor).delete(key);\n    return path;\n  };\n  if (!Editor.isNormalizing(editor)) {\n    return;\n  }\n  if (force) {\n    var allPaths = Array.from(Node.nodes(editor), _ref => {\n      var [, p] = _ref;\n      return p;\n    });\n    var allPathKeys = new Set(allPaths.map(p => p.join(',')));\n    DIRTY_PATHS.set(editor, allPaths);\n    DIRTY_PATH_KEYS.set(editor, allPathKeys);\n  }\n  if (getDirtyPaths(editor).length === 0) {\n    return;\n  }\n  Editor.withoutNormalizing(editor, () => {\n    /*\n      Fix dirty elements with no children.\n      editor.normalizeNode() does fix this, but some normalization fixes also require it to work.\n      Running an initial pass avoids the catch-22 race condition.\n    */\n    for (var dirtyPath of getDirtyPaths(editor)) {\n      if (Node.has(editor, dirtyPath)) {\n        var entry = Editor.node(editor, dirtyPath);\n        var [node, _] = entry;\n        /*\n          The default normalizer inserts an empty text node in this scenario, but it can be customised.\n          So there is some risk here.\n                   As long as the normalizer only inserts child nodes for this case it is safe to do in any order;\n          by definition adding children to an empty node can't cause other paths to change.\n        */\n        if (Element.isElement(node) && node.children.length === 0) {\n          editor.normalizeNode(entry, {\n            operation\n          });\n        }\n      }\n    }\n    var dirtyPaths = getDirtyPaths(editor);\n    var initialDirtyPathsLength = dirtyPaths.length;\n    var iteration = 0;\n    while (dirtyPaths.length !== 0) {\n      if (!editor.shouldNormalize({\n        dirtyPaths,\n        iteration,\n        initialDirtyPathsLength,\n        operation\n      })) {\n        return;\n      }\n      var _dirtyPath = popDirtyPath(editor);\n      // If the node doesn't exist in the tree, it does not need to be normalized.\n      if (Node.has(editor, _dirtyPath)) {\n        var _entry = Editor.node(editor, _dirtyPath);\n        editor.normalizeNode(_entry, {\n          operation\n        });\n      }\n      iteration++;\n      dirtyPaths = getDirtyPaths(editor);\n    }\n  });\n};\n\nvar parent = function parent(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var path = Editor.path(editor, at, options);\n  var parentPath = Path.parent(path);\n  var entry = Editor.node(editor, parentPath);\n  return entry;\n};\n\nvar pathRef = function pathRef(editor, path) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    affinity = 'forward'\n  } = options;\n  var ref = {\n    current: path,\n    affinity,\n    unref() {\n      var {\n        current\n      } = ref;\n      var pathRefs = Editor.pathRefs(editor);\n      pathRefs.delete(ref);\n      ref.current = null;\n      return current;\n    }\n  };\n  var refs = Editor.pathRefs(editor);\n  refs.add(ref);\n  return ref;\n};\n\nvar pathRefs = editor => {\n  var refs = PATH_REFS.get(editor);\n  if (!refs) {\n    refs = new Set();\n    PATH_REFS.set(editor, refs);\n  }\n  return refs;\n};\n\nvar path = function path(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    depth,\n    edge\n  } = options;\n  if (Path.isPath(at)) {\n    if (edge === 'start') {\n      var [, firstPath] = Node.first(editor, at);\n      at = firstPath;\n    } else if (edge === 'end') {\n      var [, lastPath] = Node.last(editor, at);\n      at = lastPath;\n    }\n  }\n  if (Range.isRange(at)) {\n    if (edge === 'start') {\n      at = Range.start(at);\n    } else if (edge === 'end') {\n      at = Range.end(at);\n    } else {\n      at = Path.common(at.anchor.path, at.focus.path);\n    }\n  }\n  if (Point.isPoint(at)) {\n    at = at.path;\n  }\n  if (depth != null) {\n    at = at.slice(0, depth);\n  }\n  return at;\n};\n\nvar pointRef = function pointRef(editor, point) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    affinity = 'forward'\n  } = options;\n  var ref = {\n    current: point,\n    affinity,\n    unref() {\n      var {\n        current\n      } = ref;\n      var pointRefs = Editor.pointRefs(editor);\n      pointRefs.delete(ref);\n      ref.current = null;\n      return current;\n    }\n  };\n  var refs = Editor.pointRefs(editor);\n  refs.add(ref);\n  return ref;\n};\n\nvar pointRefs = editor => {\n  var refs = POINT_REFS.get(editor);\n  if (!refs) {\n    refs = new Set();\n    POINT_REFS.set(editor, refs);\n  }\n  return refs;\n};\n\nvar point = function point(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    edge = 'start'\n  } = options;\n  if (Path.isPath(at)) {\n    var path;\n    if (edge === 'end') {\n      var [, lastPath] = Node.last(editor, at);\n      path = lastPath;\n    } else {\n      var [, firstPath] = Node.first(editor, at);\n      path = firstPath;\n    }\n    var node = Node.get(editor, path);\n    if (!Text.isText(node)) {\n      throw new Error(\"Cannot get the \".concat(edge, \" point in the node at path [\").concat(at, \"] because it has no \").concat(edge, \" text node.\"));\n    }\n    return {\n      path,\n      offset: edge === 'end' ? node.text.length : 0\n    };\n  }\n  if (Range.isRange(at)) {\n    var [start, end] = Range.edges(at);\n    return edge === 'start' ? start : end;\n  }\n  return at;\n};\n\nfunction positions(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function* () {\n    var {\n      at = editor.selection,\n      unit = 'offset',\n      reverse = false,\n      voids = false\n    } = options;\n    if (!at) {\n      return;\n    }\n    /**\n     * Algorithm notes:\n     *\n     * Each step `distance` is dynamic depending on the underlying text\n     * and the `unit` specified.  Each step, e.g., a line or word, may\n     * span multiple text nodes, so we iterate through the text both on\n     * two levels in step-sync:\n     *\n     * `leafText` stores the text on a text leaf level, and is advanced\n     * through using the counters `leafTextOffset` and `leafTextRemaining`.\n     *\n     * `blockText` stores the text on a block level, and is shortened\n     * by `distance` every time it is advanced.\n     *\n     * We only maintain a window of one blockText and one leafText because\n     * a block node always appears before all of its leaf nodes.\n     */\n    var range = Editor.range(editor, at);\n    var [start, end] = Range.edges(range);\n    var first = reverse ? end : start;\n    var isNewBlock = false;\n    var blockText = '';\n    var distance = 0; // Distance for leafText to catch up to blockText.\n    var leafTextRemaining = 0;\n    var leafTextOffset = 0;\n    var skippedPaths = [];\n    // Iterate through all nodes in range, grabbing entire textual content\n    // of block nodes in blockText, and text nodes in leafText.\n    // Exploits the fact that nodes are sequenced in such a way that we first\n    // encounter the block node, then all of its text nodes, so when iterating\n    // through the blockText and leafText we just need to remember a window of\n    // one block node and leaf node, respectively.\n    var _loop = function* _loop(path) {\n        // If the node is inside a skipped ancestor, do not return any points, but\n        // still process its content so that the iteration state remains correct.\n        var hasSkippedAncestor = skippedPaths.some(p => Path.isAncestor(p, path));\n        function* maybeYield(point) {\n          if (!hasSkippedAncestor) {\n            yield point;\n          }\n        }\n        /*\n         * ELEMENT NODE - Yield position(s) for voids, collect blockText for blocks\n         */\n        if (Element.isElement(node)) {\n          if (!editor.isSelectable(node)) {\n            /**\n             * If the node is not selectable, skip it and its descendants\n             */\n            skippedPaths.push(path);\n            if (reverse) {\n              if (Path.hasPrevious(path)) {\n                yield* maybeYield(Editor.end(editor, Path.previous(path)));\n              }\n              return 0; // continue\n            } else {\n              var nextPath = Path.next(path);\n              if (Editor.hasPath(editor, nextPath)) {\n                yield* maybeYield(Editor.start(editor, nextPath));\n              }\n              return 0; // continue\n            }\n          }\n          // Void nodes are a special case, so by default we will always\n          // yield their first point. If the `voids` option is set to true,\n          // then we will iterate over their content.\n          if (!voids && (editor.isVoid(node) || editor.isElementReadOnly(node))) {\n            yield* maybeYield(Editor.start(editor, path));\n            return 0; // continue\n          }\n          // Inline element nodes are ignored as they don't themselves\n          // contribute to `blockText` or `leafText` - their parent and\n          // children do.\n          if (editor.isInline(node)) return 0; // continue\n          // Block element node - set `blockText` to its text content.\n          if (Editor.hasInlines(editor, node)) {\n            // We always exhaust block nodes before encountering a new one:\n            //   console.assert(blockText === '',\n            //     `blockText='${blockText}' - `+\n            //     `not exhausted before new block node`, path)\n            // Ensure range considered is capped to `range`, in the\n            // start/end edge cases where block extends beyond range.\n            // Equivalent to this, but presumably more performant:\n            //   blockRange = Editor.range(editor, ...Editor.edges(editor, path))\n            //   blockRange = Range.intersection(range, blockRange) // intersect\n            //   blockText = Editor.string(editor, blockRange, { voids })\n            var e = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);\n            var s = Path.isAncestor(path, start.path) ? start : Editor.start(editor, path);\n            blockText = Editor.string(editor, {\n              anchor: s,\n              focus: e\n            }, {\n              voids\n            });\n            isNewBlock = true;\n          }\n        }\n        /*\n         * TEXT LEAF NODE - Iterate through text content, yielding\n         * positions every `distance` offset according to `unit`.\n         */\n        if (Text.isText(node)) {\n          var isFirst = Path.equals(path, first.path);\n          // Proof that we always exhaust text nodes before encountering a new one:\n          //   console.assert(leafTextRemaining <= 0,\n          //     `leafTextRemaining=${leafTextRemaining} - `+\n          //     `not exhausted before new leaf text node`, path)\n          // Reset `leafText` counters for new text node.\n          if (isFirst) {\n            leafTextRemaining = reverse ? first.offset : node.text.length - first.offset;\n            leafTextOffset = first.offset; // Works for reverse too.\n          } else {\n            leafTextRemaining = node.text.length;\n            leafTextOffset = reverse ? leafTextRemaining : 0;\n          }\n          // Yield position at the start of node (potentially).\n          if (isFirst || isNewBlock || unit === 'offset') {\n            yield* maybeYield({\n              path,\n              offset: leafTextOffset\n            });\n            isNewBlock = false;\n          }\n          // Yield positions every (dynamically calculated) `distance` offset.\n          while (true) {\n            // If `leafText` has caught up with `blockText` (distance=0),\n            // and if blockText is exhausted, break to get another block node,\n            // otherwise advance blockText forward by the new `distance`.\n            if (distance === 0) {\n              if (blockText === '') break;\n              distance = calcDistance(blockText, unit, reverse);\n              // Split the string at the previously found distance and use the\n              // remaining string for the next iteration.\n              blockText = splitByCharacterDistance(blockText, distance, reverse)[1];\n            }\n            // Advance `leafText` by the current `distance`.\n            leafTextOffset = reverse ? leafTextOffset - distance : leafTextOffset + distance;\n            leafTextRemaining = leafTextRemaining - distance;\n            // If `leafText` is exhausted, break to get a new leaf node\n            // and set distance to the overflow amount, so we'll (maybe)\n            // catch up to blockText in the next leaf text node.\n            if (leafTextRemaining < 0) {\n              distance = -leafTextRemaining;\n              break;\n            }\n            // Successfully walked `distance` offsets through `leafText`\n            // to catch up with `blockText`, so we can reset `distance`\n            // and yield this position in this node.\n            distance = 0;\n            yield* maybeYield({\n              path,\n              offset: leafTextOffset\n            });\n          }\n        }\n      },\n      _ret;\n    for (var [node, path] of Editor.nodes(editor, {\n      at,\n      reverse,\n      voids\n    })) {\n      _ret = yield* _loop(path);\n      if (_ret === 0) continue;\n    }\n    // Proof that upon completion, we've exahusted both leaf and block text:\n    //   console.assert(leafTextRemaining <= 0, \"leafText wasn't exhausted\")\n    //   console.assert(blockText === '', \"blockText wasn't exhausted\")\n    // Helper:\n    // Return the distance in offsets for a step of size `unit` on given string.\n    function calcDistance(text, unit, reverse) {\n      if (unit === 'character') {\n        return getCharacterDistance(text, reverse);\n      } else if (unit === 'word') {\n        return getWordDistance(text, reverse);\n      } else if (unit === 'line' || unit === 'block') {\n        return text.length;\n      }\n      return 1;\n    }\n  }();\n}\n\nvar previous = function previous(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    mode = 'lowest',\n    voids = false\n  } = options;\n  var {\n    match,\n    at = editor.selection\n  } = options;\n  if (!at) {\n    return;\n  }\n  var pointBeforeLocation = Editor.before(editor, at, {\n    voids\n  });\n  if (!pointBeforeLocation) {\n    return;\n  }\n  var [, to] = Editor.first(editor, []);\n  // The search location is from the start of the document to the path of\n  // the point before the location passed in\n  var span = [pointBeforeLocation.path, to];\n  if (Path.isPath(at) && at.length === 0) {\n    throw new Error(\"Cannot get the previous node from the root node!\");\n  }\n  if (match == null) {\n    if (Path.isPath(at)) {\n      var [parent] = Editor.parent(editor, at);\n      match = n => parent.children.includes(n);\n    } else {\n      match = () => true;\n    }\n  }\n  var [previous] = Editor.nodes(editor, {\n    reverse: true,\n    at: span,\n    match,\n    mode,\n    voids\n  });\n  return previous;\n};\n\nvar rangeRef = function rangeRef(editor, range) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    affinity = 'forward'\n  } = options;\n  var ref = {\n    current: range,\n    affinity,\n    unref() {\n      var {\n        current\n      } = ref;\n      var rangeRefs = Editor.rangeRefs(editor);\n      rangeRefs.delete(ref);\n      ref.current = null;\n      return current;\n    }\n  };\n  var refs = Editor.rangeRefs(editor);\n  refs.add(ref);\n  return ref;\n};\n\nvar rangeRefs = editor => {\n  var refs = RANGE_REFS.get(editor);\n  if (!refs) {\n    refs = new Set();\n    RANGE_REFS.set(editor, refs);\n  }\n  return refs;\n};\n\nvar range = (editor, at, to) => {\n  if (Range.isRange(at) && !to) {\n    return at;\n  }\n  var start = Editor.start(editor, at);\n  var end = Editor.end(editor, to || at);\n  return {\n    anchor: start,\n    focus: end\n  };\n};\n\nfunction ownKeys$2(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$2(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$2(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar removeMark = (editor, key) => {\n  var {\n    selection\n  } = editor;\n  if (selection) {\n    var match = (node, path) => {\n      if (!Text.isText(node)) {\n        return false; // marks can only be applied to text\n      }\n\n      var [parentNode, parentPath] = Editor.parent(editor, path);\n      return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n    };\n    var expandedSelection = Range.isExpanded(selection);\n    var markAcceptingVoidSelected = false;\n    if (!expandedSelection) {\n      var [selectedNode, selectedPath] = Editor.node(editor, selection);\n      if (selectedNode && match(selectedNode, selectedPath)) {\n        var [parentNode] = Editor.parent(editor, selectedPath);\n        markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n      }\n    }\n    if (expandedSelection || markAcceptingVoidSelected) {\n      Transforms.unsetNodes(editor, key, {\n        match,\n        split: true,\n        voids: true\n      });\n    } else {\n      var marks = _objectSpread$2({}, Editor.marks(editor) || {});\n      delete marks[key];\n      editor.marks = marks;\n      if (!FLUSHING.get(editor)) {\n        editor.onChange();\n      }\n    }\n  }\n};\n\nvar setNormalizing = (editor, isNormalizing) => {\n  NORMALIZING.set(editor, isNormalizing);\n};\n\nvar start = (editor, at) => {\n  return Editor.point(editor, at, {\n    edge: 'start'\n  });\n};\n\nvar string = function string(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    voids = false\n  } = options;\n  var range = Editor.range(editor, at);\n  var [start, end] = Range.edges(range);\n  var text = '';\n  for (var [node, path] of Editor.nodes(editor, {\n    at: range,\n    match: Text.isText,\n    voids\n  })) {\n    var t = node.text;\n    if (Path.equals(path, end.path)) {\n      t = t.slice(0, end.offset);\n    }\n    if (Path.equals(path, start.path)) {\n      t = t.slice(start.offset);\n    }\n    text += t;\n  }\n  return text;\n};\n\nvar unhangRange = function unhangRange(editor, range) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    voids = false\n  } = options;\n  var [start, end] = Range.edges(range);\n  // PERF: exit early if we can guarantee that the range isn't hanging.\n  if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range) || Path.hasPrevious(end.path)) {\n    return range;\n  }\n  var endBlock = Editor.above(editor, {\n    at: end,\n    match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n    voids\n  });\n  var blockPath = endBlock ? endBlock[1] : [];\n  var first = Editor.start(editor, start);\n  var before = {\n    anchor: first,\n    focus: end\n  };\n  var skip = true;\n  for (var [node, path] of Editor.nodes(editor, {\n    at: before,\n    match: Text.isText,\n    reverse: true,\n    voids\n  })) {\n    if (skip) {\n      skip = false;\n      continue;\n    }\n    if (node.text !== '' || Path.isBefore(path, blockPath)) {\n      end = {\n        path,\n        offset: node.text.length\n      };\n      break;\n    }\n  }\n  return {\n    anchor: start,\n    focus: end\n  };\n};\n\nvar withoutNormalizing = (editor, fn) => {\n  var value = Editor.isNormalizing(editor);\n  Editor.setNormalizing(editor, false);\n  try {\n    fn();\n  } finally {\n    Editor.setNormalizing(editor, value);\n  }\n  Editor.normalize(editor);\n};\n\nvar shouldMergeNodesRemovePrevNode = (editor, _ref, _ref2) => {\n  var [prevNode, prevPath] = _ref;\n  // If the target node that we're merging with is empty, remove it instead\n  // of merging the two. This is a common rich text editor behavior to\n  // prevent losing formatting when deleting entire nodes when you have a\n  // hanging selection.\n  // if prevNode is first child in parent,don't remove it.\n  return Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === '' && prevPath[prevPath.length - 1] !== 0;\n};\n\nvar deleteText = function deleteText(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var _Editor$void, _Editor$void2;\n    var {\n      reverse = false,\n      unit = 'character',\n      distance = 1,\n      voids = false\n    } = options;\n    var {\n      at = editor.selection,\n      hanging = false\n    } = options;\n    if (!at) {\n      return;\n    }\n    var isCollapsed = false;\n    if (Range.isRange(at) && Range.isCollapsed(at)) {\n      isCollapsed = true;\n      at = at.anchor;\n    }\n    if (Point.isPoint(at)) {\n      var furthestVoid = Editor.void(editor, {\n        at,\n        mode: 'highest'\n      });\n      if (!voids && furthestVoid) {\n        var [, voidPath] = furthestVoid;\n        at = voidPath;\n      } else {\n        var opts = {\n          unit,\n          distance\n        };\n        var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);\n        at = {\n          anchor: at,\n          focus: target\n        };\n        hanging = true;\n      }\n    }\n    if (Path.isPath(at)) {\n      Transforms.removeNodes(editor, {\n        at,\n        voids\n      });\n      return;\n    }\n    if (Range.isCollapsed(at)) {\n      return;\n    }\n    if (!hanging) {\n      var [, _end] = Range.edges(at);\n      var endOfDoc = Editor.end(editor, []);\n      if (!Point.equals(_end, endOfDoc)) {\n        at = Editor.unhangRange(editor, at, {\n          voids\n        });\n      }\n    }\n    var [start, end] = Range.edges(at);\n    var startBlock = Editor.above(editor, {\n      match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n      at: start,\n      voids\n    });\n    var endBlock = Editor.above(editor, {\n      match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n      at: end,\n      voids\n    });\n    var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n    var isSingleText = Path.equals(start.path, end.path);\n    var startNonEditable = voids ? null : (_Editor$void = Editor.void(editor, {\n      at: start,\n      mode: 'highest'\n    })) !== null && _Editor$void !== void 0 ? _Editor$void : Editor.elementReadOnly(editor, {\n      at: start,\n      mode: 'highest'\n    });\n    var endNonEditable = voids ? null : (_Editor$void2 = Editor.void(editor, {\n      at: end,\n      mode: 'highest'\n    })) !== null && _Editor$void2 !== void 0 ? _Editor$void2 : Editor.elementReadOnly(editor, {\n      at: end,\n      mode: 'highest'\n    });\n    // If the start or end points are inside an inline void, nudge them out.\n    if (startNonEditable) {\n      var before = Editor.before(editor, start);\n      if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n        start = before;\n      }\n    }\n    if (endNonEditable) {\n      var after = Editor.after(editor, end);\n      if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n        end = after;\n      }\n    }\n    // Get the highest nodes that are completely inside the range, as well as\n    // the start and end nodes.\n    var matches = [];\n    var lastPath;\n    for (var entry of Editor.nodes(editor, {\n      at,\n      voids\n    })) {\n      var [node, path] = entry;\n      if (lastPath && Path.compare(path, lastPath) === 0) {\n        continue;\n      }\n      if (!voids && Element.isElement(node) && (Editor.isVoid(editor, node) || Editor.isElementReadOnly(editor, node)) || !Path.isCommon(path, start.path) && !Path.isCommon(path, end.path)) {\n        matches.push(entry);\n        lastPath = path;\n      }\n    }\n    var pathRefs = Array.from(matches, _ref => {\n      var [, p] = _ref;\n      return Editor.pathRef(editor, p);\n    });\n    var startRef = Editor.pointRef(editor, start);\n    var endRef = Editor.pointRef(editor, end);\n    var removedText = '';\n    if (!isSingleText && !startNonEditable) {\n      var _point = startRef.current;\n      var [_node] = Editor.leaf(editor, _point);\n      var {\n        path: _path\n      } = _point;\n      var {\n        offset\n      } = start;\n      var text = _node.text.slice(offset);\n      if (text.length > 0) {\n        editor.apply({\n          type: 'remove_text',\n          path: _path,\n          offset,\n          text\n        });\n        removedText = text;\n      }\n    }\n    pathRefs.reverse().map(r => r.unref()).filter(r => r !== null).forEach(p => Transforms.removeNodes(editor, {\n      at: p,\n      voids\n    }));\n    if (!endNonEditable) {\n      var _point2 = endRef.current;\n      var [_node2] = Editor.leaf(editor, _point2);\n      var {\n        path: _path2\n      } = _point2;\n      var _offset = isSingleText ? start.offset : 0;\n      var _text = _node2.text.slice(_offset, end.offset);\n      if (_text.length > 0) {\n        editor.apply({\n          type: 'remove_text',\n          path: _path2,\n          offset: _offset,\n          text: _text\n        });\n        removedText = _text;\n      }\n    }\n    if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n      Transforms.mergeNodes(editor, {\n        at: endRef.current,\n        hanging: true,\n        voids\n      });\n    }\n    // For certain scripts, deleting N character(s) backward should delete\n    // N code point(s) instead of an entire grapheme cluster.\n    // Therefore, the remaining code points should be inserted back.\n    // Bengali: \\u0980-\\u09FF\n    // Thai: \\u0E00-\\u0E7F\n    // Burmese (Myanmar): \\u1000-\\u109F\n    // Hindi (Devanagari): \\u0900-\\u097F\n    // Khmer: \\u1780-\\u17FF\n    // Malayalam: \\u0D00-\\u0D7F\n    // Oriya: \\u0B00-\\u0B7F\n    // Punjabi (Gurmukhi): \\u0A00-\\u0A7F\n    // Tamil: \\u0B80-\\u0BFF\n    // Telugu: \\u0C00-\\u0C7F\n    if (isCollapsed && reverse && unit === 'character' && removedText.length > 1 && removedText.match(/[\\u0980-\\u09FF\\u0E00-\\u0E7F\\u1000-\\u109F\\u0900-\\u097F\\u1780-\\u17FF\\u0D00-\\u0D7F\\u0B00-\\u0B7F\\u0A00-\\u0A7F\\u0B80-\\u0BFF\\u0C00-\\u0C7F]+/)) {\n      Transforms.insertText(editor, removedText.slice(0, removedText.length - distance));\n    }\n    var startUnref = startRef.unref();\n    var endUnref = endRef.unref();\n    var point = reverse ? startUnref || endUnref : endUnref || startUnref;\n    if (options.at == null && point) {\n      Transforms.select(editor, point);\n    }\n  });\n};\n\nvar insertFragment = function insertFragment(editor, fragment) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      hanging = false,\n      voids = false\n    } = options;\n    var {\n      at = getDefaultInsertLocation(editor),\n      batchDirty = true\n    } = options;\n    if (!fragment.length) {\n      return;\n    }\n    if (Range.isRange(at)) {\n      if (!hanging) {\n        at = Editor.unhangRange(editor, at, {\n          voids\n        });\n      }\n      if (Range.isCollapsed(at)) {\n        at = at.anchor;\n      } else {\n        var [, end] = Range.edges(at);\n        if (!voids && Editor.void(editor, {\n          at: end\n        })) {\n          return;\n        }\n        var pointRef = Editor.pointRef(editor, end);\n        Transforms.delete(editor, {\n          at\n        });\n        at = pointRef.unref();\n      }\n    } else if (Path.isPath(at)) {\n      at = Editor.start(editor, at);\n    }\n    if (!voids && Editor.void(editor, {\n      at\n    })) {\n      return;\n    }\n    // If the insert point is at the edge of an inline node, move it outside\n    // instead since it will need to be split otherwise.\n    var inlineElementMatch = Editor.above(editor, {\n      at,\n      match: n => Element.isElement(n) && Editor.isInline(editor, n),\n      mode: 'highest',\n      voids\n    });\n    if (inlineElementMatch) {\n      var [, _inlinePath] = inlineElementMatch;\n      if (Editor.isEnd(editor, at, _inlinePath)) {\n        var after = Editor.after(editor, _inlinePath);\n        at = after;\n      } else if (Editor.isStart(editor, at, _inlinePath)) {\n        var before = Editor.before(editor, _inlinePath);\n        at = before;\n      }\n    }\n    var blockMatch = Editor.above(editor, {\n      match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n      at,\n      voids\n    });\n    var [, blockPath] = blockMatch;\n    var isBlockStart = Editor.isStart(editor, at, blockPath);\n    var isBlockEnd = Editor.isEnd(editor, at, blockPath);\n    var isBlockEmpty = isBlockStart && isBlockEnd;\n    var [, firstLeafPath] = Node.first({\n      children: fragment\n    }, []);\n    var [, lastLeafPath] = Node.last({\n      children: fragment\n    }, []);\n    // For each node in the fragment, determine what level of wrapping should\n    // be kept. At minimum, all text nodes will be inserted, but if\n    // `shouldInsert` returns true for some ancestor of a particular text node,\n    // then the entire ancestor will be inserted rather than inserting the text\n    // nodes individually.\n    var shouldInsert = _ref => {\n      var [n, p] = _ref;\n      var isRoot = p.length === 0;\n      if (isRoot) {\n        return false;\n      }\n      // If the destination block is empty, insert all top-level blocks of the\n      // fragment.\n      if (isBlockEmpty) {\n        return true;\n      }\n      // Unless we're at the start of the destination block, unwrap any\n      // non-void blocks that contain the first leaf node in the fragment.\n      if (!isBlockStart && Path.isAncestor(p, firstLeafPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n        return false;\n      }\n      // Unless we're at the end of the destination block, unwrap any non-void\n      // blocks that contain the last leaf node in the fragment.\n      if (!isBlockEnd && Path.isAncestor(p, lastLeafPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n        return false;\n      }\n      // Always insert void nodes, inline elements and text nodes.\n      return true;\n    };\n    // Whether the current node is in the first block of the fragment.\n    var starting = true;\n    // Inline nodes in the first block of the fragment, to be merged with the\n    // destination block.\n    var starts = [];\n    // Blocks in the middle of the fragment.\n    var middles = [];\n    // Inline nodes in the last block of the fragment, to be merged with the\n    // destination block. If the fragment contains only one block, this will be\n    // empty.\n    var ends = [];\n    for (var entry of Node.nodes({\n      children: fragment\n    }, {\n      pass: shouldInsert\n    })) {\n      var [node, path] = entry;\n      // If we encounter a block that does not contain the first leaf, we're no\n      // longer in the first block of the fragment.\n      if (starting && Element.isElement(node) && !editor.isInline(node) && !Path.isAncestor(path, firstLeafPath)) {\n        starting = false;\n      }\n      if (shouldInsert(entry)) {\n        if (Element.isElement(node) && !editor.isInline(node)) {\n          starting = false;\n          middles.push(node);\n        } else if (starting) {\n          starts.push(node);\n        } else {\n          ends.push(node);\n        }\n      }\n    }\n    var [inlineMatch] = Editor.nodes(editor, {\n      at,\n      match: n => Text.isText(n) || Editor.isInline(editor, n),\n      mode: 'highest',\n      voids\n    });\n    var [, inlinePath] = inlineMatch;\n    var isInlineStart = Editor.isStart(editor, at, inlinePath);\n    var isInlineEnd = Editor.isEnd(editor, at, inlinePath);\n    var middleRef = Editor.pathRef(editor, isBlockEnd && !ends.length ? Path.next(blockPath) : blockPath);\n    var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);\n    // If the fragment contains inlines in multiple distinct blocks, split the\n    // destination block.\n    var splitBlock = ends.length > 0;\n    Transforms.splitNodes(editor, {\n      at,\n      match: n => splitBlock ? Element.isElement(n) && Editor.isBlock(editor, n) : Text.isText(n) || Editor.isInline(editor, n),\n      mode: splitBlock ? 'lowest' : 'highest',\n      always: splitBlock && (!isBlockStart || starts.length > 0) && (!isBlockEnd || ends.length > 0),\n      voids\n    });\n    var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);\n    Transforms.insertNodes(editor, starts, {\n      at: startRef.current,\n      match: n => Text.isText(n) || Editor.isInline(editor, n),\n      mode: 'highest',\n      voids,\n      batchDirty\n    });\n    if (isBlockEmpty && !starts.length && middles.length && !ends.length) {\n      Transforms.delete(editor, {\n        at: blockPath,\n        voids\n      });\n    }\n    Transforms.insertNodes(editor, middles, {\n      at: middleRef.current,\n      match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n      mode: 'lowest',\n      voids,\n      batchDirty\n    });\n    Transforms.insertNodes(editor, ends, {\n      at: endRef.current,\n      match: n => Text.isText(n) || Editor.isInline(editor, n),\n      mode: 'highest',\n      voids,\n      batchDirty\n    });\n    if (!options.at) {\n      var _path;\n      if (ends.length > 0 && endRef.current) {\n        _path = Path.previous(endRef.current);\n      } else if (middles.length > 0 && middleRef.current) {\n        _path = Path.previous(middleRef.current);\n      } else if (startRef.current) {\n        _path = Path.previous(startRef.current);\n      }\n      if (_path) {\n        var _end = Editor.end(editor, _path);\n        Transforms.select(editor, _end);\n      }\n    }\n    startRef.unref();\n    middleRef.unref();\n    endRef.unref();\n  });\n};\n\nvar collapse = function collapse(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    edge = 'anchor'\n  } = options;\n  var {\n    selection\n  } = editor;\n  if (!selection) {\n    return;\n  } else if (edge === 'anchor') {\n    Transforms.select(editor, selection.anchor);\n  } else if (edge === 'focus') {\n    Transforms.select(editor, selection.focus);\n  } else if (edge === 'start') {\n    var [start] = Range.edges(selection);\n    Transforms.select(editor, start);\n  } else if (edge === 'end') {\n    var [, end] = Range.edges(selection);\n    Transforms.select(editor, end);\n  }\n};\n\nvar deselect = editor => {\n  var {\n    selection\n  } = editor;\n  if (selection) {\n    editor.apply({\n      type: 'set_selection',\n      properties: selection,\n      newProperties: null\n    });\n  }\n};\n\nvar move = function move(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    selection\n  } = editor;\n  var {\n    distance = 1,\n    unit = 'character',\n    reverse = false\n  } = options;\n  var {\n    edge = null\n  } = options;\n  if (!selection) {\n    return;\n  }\n  if (edge === 'start') {\n    edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n  }\n  if (edge === 'end') {\n    edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n  }\n  var {\n    anchor,\n    focus\n  } = selection;\n  var opts = {\n    distance,\n    unit\n  };\n  var props = {};\n  if (edge == null || edge === 'anchor') {\n    var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);\n    if (point) {\n      props.anchor = point;\n    }\n  }\n  if (edge == null || edge === 'focus') {\n    var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);\n    if (_point) {\n      props.focus = _point;\n    }\n  }\n  Transforms.setSelection(editor, props);\n};\n\nvar select = (editor, target) => {\n  var {\n    selection\n  } = editor;\n  target = Editor.range(editor, target);\n  if (selection) {\n    Transforms.setSelection(editor, target);\n    return;\n  }\n  if (!Range.isRange(target)) {\n    throw new Error(\"When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: \".concat(Scrubber.stringify(target)));\n  }\n  editor.apply({\n    type: 'set_selection',\n    properties: selection,\n    newProperties: target\n  });\n};\n\nfunction ownKeys$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar setPoint = function setPoint(editor, props) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    selection\n  } = editor;\n  var {\n    edge = 'both'\n  } = options;\n  if (!selection) {\n    return;\n  }\n  if (edge === 'start') {\n    edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n  }\n  if (edge === 'end') {\n    edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n  }\n  var {\n    anchor,\n    focus\n  } = selection;\n  var point = edge === 'anchor' ? anchor : focus;\n  Transforms.setSelection(editor, {\n    [edge === 'anchor' ? 'anchor' : 'focus']: _objectSpread$1(_objectSpread$1({}, point), props)\n  });\n};\n\nvar setSelection = (editor, props) => {\n  var {\n    selection\n  } = editor;\n  var oldProps = {};\n  var newProps = {};\n  if (!selection) {\n    return;\n  }\n  for (var k in props) {\n    if (k === 'anchor' && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === 'focus' && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== 'anchor' && k !== 'focus' && props[k] !== selection[k]) {\n      oldProps[k] = selection[k];\n      newProps[k] = props[k];\n    }\n  }\n  if (Object.keys(oldProps).length > 0) {\n    editor.apply({\n      type: 'set_selection',\n      properties: oldProps,\n      newProperties: newProps\n    });\n  }\n};\n\nvar insertNodes = function insertNodes(editor, nodes) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      hanging = false,\n      voids = false,\n      mode = 'lowest',\n      batchDirty = true\n    } = options;\n    var {\n      at,\n      match,\n      select\n    } = options;\n    if (Node.isNode(nodes)) {\n      nodes = [nodes];\n    }\n    if (nodes.length === 0) {\n      return;\n    }\n    var [node] = nodes;\n    if (!at) {\n      at = getDefaultInsertLocation(editor);\n      if (select !== false) {\n        select = true;\n      }\n    }\n    if (select == null) {\n      select = false;\n    }\n    if (Range.isRange(at)) {\n      if (!hanging) {\n        at = Editor.unhangRange(editor, at, {\n          voids\n        });\n      }\n      if (Range.isCollapsed(at)) {\n        at = at.anchor;\n      } else {\n        var [, end] = Range.edges(at);\n        var pointRef = Editor.pointRef(editor, end);\n        Transforms.delete(editor, {\n          at\n        });\n        at = pointRef.unref();\n      }\n    }\n    if (Point.isPoint(at)) {\n      if (match == null) {\n        if (Text.isText(node)) {\n          match = n => Text.isText(n);\n        } else if (editor.isInline(node)) {\n          match = n => Text.isText(n) || Editor.isInline(editor, n);\n        } else {\n          match = n => Element.isElement(n) && Editor.isBlock(editor, n);\n        }\n      }\n      var [entry] = Editor.nodes(editor, {\n        at: at.path,\n        match,\n        mode,\n        voids\n      });\n      if (entry) {\n        var [, matchPath] = entry;\n        var pathRef = Editor.pathRef(editor, matchPath);\n        var isAtEnd = Editor.isEnd(editor, at, matchPath);\n        Transforms.splitNodes(editor, {\n          at,\n          match,\n          mode,\n          voids\n        });\n        var path = pathRef.unref();\n        at = isAtEnd ? Path.next(path) : path;\n      } else {\n        return;\n      }\n    }\n    var parentPath = Path.parent(at);\n    var index = at[at.length - 1];\n    if (!voids && Editor.void(editor, {\n      at: parentPath\n    })) {\n      return;\n    }\n    if (batchDirty) {\n      // PERF: batch update dirty paths\n      // batched ops used to transform existing dirty paths\n      var batchedOps = [];\n      var newDirtyPaths = Path.levels(parentPath);\n      batchDirtyPaths(editor, () => {\n        var _loop = function _loop() {\n          var path = parentPath.concat(index);\n          index++;\n          var op = {\n            type: 'insert_node',\n            path,\n            node: _node\n          };\n          editor.apply(op);\n          at = Path.next(at);\n          batchedOps.push(op);\n          if (Text.isText(_node)) {\n            newDirtyPaths.push(path);\n          } else {\n            newDirtyPaths.push(...Array.from(Node.nodes(_node), _ref => {\n              var [, p] = _ref;\n              return path.concat(p);\n            }));\n          }\n        };\n        for (var _node of nodes) {\n          _loop();\n        }\n      }, () => {\n        updateDirtyPaths(editor, newDirtyPaths, p => {\n          var newPath = p;\n          for (var op of batchedOps) {\n            if (Path.operationCanTransformPath(op)) {\n              newPath = Path.transform(newPath, op);\n              if (!newPath) {\n                return null;\n              }\n            }\n          }\n          return newPath;\n        });\n      });\n    } else {\n      for (var _node2 of nodes) {\n        var _path = parentPath.concat(index);\n        index++;\n        editor.apply({\n          type: 'insert_node',\n          path: _path,\n          node: _node2\n        });\n        at = Path.next(at);\n      }\n    }\n    at = Path.previous(at);\n    if (select) {\n      var point = Editor.end(editor, at);\n      if (point) {\n        Transforms.select(editor, point);\n      }\n    }\n  });\n};\n\nvar liftNodes = function liftNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      at = editor.selection,\n      mode = 'lowest',\n      voids = false\n    } = options;\n    var {\n      match\n    } = options;\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : n => Element.isElement(n) && Editor.isBlock(editor, n);\n    }\n    if (!at) {\n      return;\n    }\n    var matches = Editor.nodes(editor, {\n      at,\n      match,\n      mode,\n      voids\n    });\n    var pathRefs = Array.from(matches, _ref => {\n      var [, p] = _ref;\n      return Editor.pathRef(editor, p);\n    });\n    for (var pathRef of pathRefs) {\n      var path = pathRef.unref();\n      if (path.length < 2) {\n        throw new Error(\"Cannot lift node at a path [\".concat(path, \"] because it has a depth of less than `2`.\"));\n      }\n      var parentNodeEntry = Editor.node(editor, Path.parent(path));\n      var [parent, parentPath] = parentNodeEntry;\n      var index = path[path.length - 1];\n      var {\n        length\n      } = parent.children;\n      if (length === 1) {\n        var toPath = Path.next(parentPath);\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: toPath,\n          voids\n        });\n        Transforms.removeNodes(editor, {\n          at: parentPath,\n          voids\n        });\n      } else if (index === 0) {\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: parentPath,\n          voids\n        });\n      } else if (index === length - 1) {\n        var _toPath = Path.next(parentPath);\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: _toPath,\n          voids\n        });\n      } else {\n        var splitPath = Path.next(path);\n        var _toPath2 = Path.next(parentPath);\n        Transforms.splitNodes(editor, {\n          at: splitPath,\n          voids\n        });\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: _toPath2,\n          voids\n        });\n      }\n    }\n  });\n};\n\nvar _excluded = [\"text\"],\n  _excluded2 = [\"children\"];\nvar hasSingleChildNest = (editor, node) => {\n  if (Element.isElement(node)) {\n    var element = node;\n    if (Editor.isVoid(editor, node)) {\n      return true;\n    } else if (element.children.length === 1) {\n      return hasSingleChildNest(editor, element.children[0]);\n    } else {\n      return false;\n    }\n  } else if (Editor.isEditor(node)) {\n    return false;\n  } else {\n    return true;\n  }\n};\nvar mergeNodes = function mergeNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      match,\n      at = editor.selection\n    } = options;\n    var {\n      hanging = false,\n      voids = false,\n      mode = 'lowest'\n    } = options;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      if (Path.isPath(at)) {\n        var [parent] = Editor.parent(editor, at);\n        match = n => parent.children.includes(n);\n      } else {\n        match = n => Element.isElement(n) && Editor.isBlock(editor, n);\n      }\n    }\n    if (!hanging && Range.isRange(at)) {\n      at = Editor.unhangRange(editor, at, {\n        voids\n      });\n    }\n    if (Range.isRange(at)) {\n      if (Range.isCollapsed(at)) {\n        at = at.anchor;\n      } else {\n        var [, end] = Range.edges(at);\n        var pointRef = Editor.pointRef(editor, end);\n        Transforms.delete(editor, {\n          at\n        });\n        at = pointRef.unref();\n        if (options.at == null) {\n          Transforms.select(editor, at);\n        }\n      }\n    }\n    var [current] = Editor.nodes(editor, {\n      at,\n      match,\n      voids,\n      mode\n    });\n    var prev = Editor.previous(editor, {\n      at,\n      match,\n      voids,\n      mode\n    });\n    if (!current || !prev) {\n      return;\n    }\n    var [node, path] = current;\n    var [prevNode, prevPath] = prev;\n    if (path.length === 0 || prevPath.length === 0) {\n      return;\n    }\n    var newPath = Path.next(prevPath);\n    var commonPath = Path.common(path, prevPath);\n    var isPreviousSibling = Path.isSibling(path, prevPath);\n    var levels = Array.from(Editor.levels(editor, {\n      at: path\n    }), _ref => {\n      var [n] = _ref;\n      return n;\n    }).slice(commonPath.length).slice(0, -1);\n    // Determine if the merge will leave an ancestor of the path empty as a\n    // result, in which case we'll want to remove it after merging.\n    var emptyAncestor = Editor.above(editor, {\n      at: path,\n      mode: 'highest',\n      match: n => levels.includes(n) && hasSingleChildNest(editor, n)\n    });\n    var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);\n    var properties;\n    var position;\n    // Ensure that the nodes are equivalent, and figure out what the position\n    // and extra properties of the merge will be.\n    if (Text.isText(node) && Text.isText(prevNode)) {\n      var rest = _objectWithoutProperties(node, _excluded);\n      position = prevNode.text.length;\n      properties = rest;\n    } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n      var rest = _objectWithoutProperties(node, _excluded2);\n      position = prevNode.children.length;\n      properties = rest;\n    } else {\n      throw new Error(\"Cannot merge the node at path [\".concat(path, \"] with the previous sibling because it is not the same kind: \").concat(Scrubber.stringify(node), \" \").concat(Scrubber.stringify(prevNode)));\n    }\n    // If the node isn't already the next sibling of the previous node, move\n    // it so that it is before merging.\n    if (!isPreviousSibling) {\n      Transforms.moveNodes(editor, {\n        at: path,\n        to: newPath,\n        voids\n      });\n    }\n    // If there was going to be an empty ancestor of the node that was merged,\n    // we remove it from the tree.\n    if (emptyRef) {\n      Transforms.removeNodes(editor, {\n        at: emptyRef.current,\n        voids\n      });\n    }\n    if (Editor.shouldMergeNodesRemovePrevNode(editor, prev, current)) {\n      Transforms.removeNodes(editor, {\n        at: prevPath,\n        voids\n      });\n    } else {\n      editor.apply({\n        type: 'merge_node',\n        path: newPath,\n        position,\n        properties\n      });\n    }\n    if (emptyRef) {\n      emptyRef.unref();\n    }\n  });\n};\n\nvar moveNodes = (editor, options) => {\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      to,\n      at = editor.selection,\n      mode = 'lowest',\n      voids = false\n    } = options;\n    var {\n      match\n    } = options;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : n => Element.isElement(n) && Editor.isBlock(editor, n);\n    }\n    var toRef = Editor.pathRef(editor, to);\n    var targets = Editor.nodes(editor, {\n      at,\n      match,\n      mode,\n      voids\n    });\n    var pathRefs = Array.from(targets, _ref => {\n      var [, p] = _ref;\n      return Editor.pathRef(editor, p);\n    });\n    for (var pathRef of pathRefs) {\n      var path = pathRef.unref();\n      var newPath = toRef.current;\n      if (path.length !== 0) {\n        editor.apply({\n          type: 'move_node',\n          path,\n          newPath\n        });\n      }\n      if (toRef.current && Path.isSibling(newPath, path) && Path.isAfter(newPath, path)) {\n        // When performing a sibling move to a later index, the path at the destination is shifted\n        // to before the insertion point instead of after. To ensure our group of nodes are inserted\n        // in the correct order we increment toRef to account for that\n        toRef.current = Path.next(toRef.current);\n      }\n    }\n    toRef.unref();\n  });\n};\n\nvar removeNodes = function removeNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      hanging = false,\n      voids = false,\n      mode = 'lowest'\n    } = options;\n    var {\n      at = editor.selection,\n      match\n    } = options;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : n => Element.isElement(n) && Editor.isBlock(editor, n);\n    }\n    if (!hanging && Range.isRange(at)) {\n      at = Editor.unhangRange(editor, at, {\n        voids\n      });\n    }\n    var depths = Editor.nodes(editor, {\n      at,\n      match,\n      mode,\n      voids\n    });\n    var pathRefs = Array.from(depths, _ref => {\n      var [, p] = _ref;\n      return Editor.pathRef(editor, p);\n    });\n    for (var pathRef of pathRefs) {\n      var path = pathRef.unref();\n      if (path) {\n        var [node] = Editor.node(editor, path);\n        editor.apply({\n          type: 'remove_node',\n          path,\n          node\n        });\n      }\n    }\n  });\n};\n\nvar setNodes = function setNodes(editor, props) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      match,\n      at = editor.selection,\n      compare,\n      merge\n    } = options;\n    var {\n      hanging = false,\n      mode = 'lowest',\n      split = false,\n      voids = false\n    } = options;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : n => Element.isElement(n) && Editor.isBlock(editor, n);\n    }\n    if (!hanging && Range.isRange(at)) {\n      at = Editor.unhangRange(editor, at, {\n        voids\n      });\n    }\n    if (split && Range.isRange(at)) {\n      if (Range.isCollapsed(at) && Editor.leaf(editor, at.anchor)[0].text.length > 0) {\n        // If the range is collapsed in a non-empty node and 'split' is true, there's nothing to\n        // set that won't get normalized away\n        return;\n      }\n      var rangeRef = Editor.rangeRef(editor, at, {\n        affinity: 'inward'\n      });\n      var [start, end] = Range.edges(at);\n      var splitMode = mode === 'lowest' ? 'lowest' : 'highest';\n      var endAtEndOfNode = Editor.isEnd(editor, end, end.path);\n      Transforms.splitNodes(editor, {\n        at: end,\n        match,\n        mode: splitMode,\n        voids,\n        always: !endAtEndOfNode\n      });\n      var startAtStartOfNode = Editor.isStart(editor, start, start.path);\n      Transforms.splitNodes(editor, {\n        at: start,\n        match,\n        mode: splitMode,\n        voids,\n        always: !startAtStartOfNode\n      });\n      at = rangeRef.unref();\n      if (options.at == null) {\n        Transforms.select(editor, at);\n      }\n    }\n    if (!compare) {\n      compare = (prop, nodeProp) => prop !== nodeProp;\n    }\n    for (var [node, path] of Editor.nodes(editor, {\n      at,\n      match,\n      mode,\n      voids\n    })) {\n      var properties = {};\n      // FIXME: is this correct?\n      var newProperties = {};\n      // You can't set properties on the editor node.\n      if (path.length === 0) {\n        continue;\n      }\n      var hasChanges = false;\n      for (var k in props) {\n        if (k === 'children' || k === 'text') {\n          continue;\n        }\n        if (compare(props[k], node[k])) {\n          hasChanges = true;\n          // Omit new properties from the old properties list\n          if (node.hasOwnProperty(k)) properties[k] = node[k];\n          // Omit properties that have been removed from the new properties list\n          if (merge) {\n            if (props[k] != null) newProperties[k] = merge(node[k], props[k]);\n          } else {\n            if (props[k] != null) newProperties[k] = props[k];\n          }\n        }\n      }\n      if (hasChanges) {\n        editor.apply({\n          type: 'set_node',\n          path,\n          properties,\n          newProperties\n        });\n      }\n    }\n  });\n};\n\n/**\n * Convert a range into a point by deleting it's content.\n */\nvar deleteRange = (editor, range) => {\n  if (Range.isCollapsed(range)) {\n    return range.anchor;\n  } else {\n    var [, end] = Range.edges(range);\n    var pointRef = Editor.pointRef(editor, end);\n    Transforms.delete(editor, {\n      at: range\n    });\n    return pointRef.unref();\n  }\n};\nvar splitNodes = function splitNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      mode = 'lowest',\n      voids = false\n    } = options;\n    var {\n      match,\n      at = editor.selection,\n      height = 0,\n      always = false\n    } = options;\n    if (match == null) {\n      match = n => Element.isElement(n) && Editor.isBlock(editor, n);\n    }\n    if (Range.isRange(at)) {\n      at = deleteRange(editor, at);\n    }\n    // If the target is a path, the default height-skipping and position\n    // counters need to account for us potentially splitting at a non-leaf.\n    if (Path.isPath(at)) {\n      var path = at;\n      var point = Editor.point(editor, path);\n      var [parent] = Editor.parent(editor, path);\n      match = n => n === parent;\n      height = point.path.length - path.length + 1;\n      at = point;\n      always = true;\n    }\n    if (!at) {\n      return;\n    }\n    var beforeRef = Editor.pointRef(editor, at, {\n      affinity: 'backward'\n    });\n    var afterRef;\n    try {\n      var [highest] = Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      });\n      if (!highest) {\n        return;\n      }\n      var voidMatch = Editor.void(editor, {\n        at,\n        mode: 'highest'\n      });\n      var nudge = 0;\n      if (!voids && voidMatch) {\n        var [voidNode, voidPath] = voidMatch;\n        if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n          var after = Editor.after(editor, voidPath);\n          if (!after) {\n            var text = {\n              text: ''\n            };\n            var afterPath = Path.next(voidPath);\n            Transforms.insertNodes(editor, text, {\n              at: afterPath,\n              voids\n            });\n            after = Editor.point(editor, afterPath);\n          }\n          at = after;\n          always = true;\n        }\n        var siblingHeight = at.path.length - voidPath.length;\n        height = siblingHeight + 1;\n        always = true;\n      }\n      afterRef = Editor.pointRef(editor, at);\n      var depth = at.path.length - height;\n      var [, highestPath] = highest;\n      var lowestPath = at.path.slice(0, depth);\n      var position = height === 0 ? at.offset : at.path[depth] + nudge;\n      for (var [node, _path] of Editor.levels(editor, {\n        at: lowestPath,\n        reverse: true,\n        voids\n      })) {\n        var split = false;\n        if (_path.length < highestPath.length || _path.length === 0 || !voids && Element.isElement(node) && Editor.isVoid(editor, node)) {\n          break;\n        }\n        var _point = beforeRef.current;\n        var isEnd = Editor.isEnd(editor, _point, _path);\n        if (always || !beforeRef || !Editor.isEdge(editor, _point, _path)) {\n          split = true;\n          var properties = Node.extractProps(node);\n          editor.apply({\n            type: 'split_node',\n            path: _path,\n            position,\n            properties\n          });\n        }\n        position = _path[_path.length - 1] + (split || isEnd ? 1 : 0);\n      }\n      if (options.at == null) {\n        var _point2 = afterRef.current || Editor.end(editor, []);\n        Transforms.select(editor, _point2);\n      }\n    } finally {\n      var _afterRef;\n      beforeRef.unref();\n      (_afterRef = afterRef) === null || _afterRef === void 0 || _afterRef.unref();\n    }\n  });\n};\n\nvar unsetNodes = function unsetNodes(editor, props) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!Array.isArray(props)) {\n    props = [props];\n  }\n  var obj = {};\n  for (var key of props) {\n    obj[key] = null;\n  }\n  Transforms.setNodes(editor, obj, options);\n};\n\nvar unwrapNodes = function unwrapNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      mode = 'lowest',\n      split = false,\n      voids = false\n    } = options;\n    var {\n      at = editor.selection,\n      match\n    } = options;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : n => Element.isElement(n) && Editor.isBlock(editor, n);\n    }\n    if (Path.isPath(at)) {\n      at = Editor.range(editor, at);\n    }\n    var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;\n    var matches = Editor.nodes(editor, {\n      at,\n      match,\n      mode,\n      voids\n    });\n    var pathRefs = Array.from(matches, _ref => {\n      var [, p] = _ref;\n      return Editor.pathRef(editor, p);\n    }\n    // unwrapNode will call liftNode which does not support splitting the node when nested.\n    // If we do not reverse the order and call it from top to the bottom, it will remove all blocks\n    // that wrap target node. So we reverse the order.\n    ).reverse();\n    var _loop = function _loop() {\n      var path = pathRef.unref();\n      var [node] = Editor.node(editor, path);\n      var range = Editor.range(editor, path);\n      if (split && rangeRef) {\n        range = Range.intersection(rangeRef.current, range);\n      }\n      Transforms.liftNodes(editor, {\n        at: range,\n        match: n => Element.isAncestor(node) && node.children.includes(n),\n        voids\n      });\n    };\n    for (var pathRef of pathRefs) {\n      _loop();\n    }\n    if (rangeRef) {\n      rangeRef.unref();\n    }\n  });\n};\n\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar wrapNodes = function wrapNodes(editor, element) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      mode = 'lowest',\n      split = false,\n      voids = false\n    } = options;\n    var {\n      match,\n      at = editor.selection\n    } = options;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      if (Path.isPath(at)) {\n        match = matchPath(editor, at);\n      } else if (editor.isInline(element)) {\n        match = n => Element.isElement(n) && Editor.isInline(editor, n) || Text.isText(n);\n      } else {\n        match = n => Element.isElement(n) && Editor.isBlock(editor, n);\n      }\n    }\n    if (split && Range.isRange(at)) {\n      var [start, end] = Range.edges(at);\n      var rangeRef = Editor.rangeRef(editor, at, {\n        affinity: 'inward'\n      });\n      // Always split if we're in the middle of a block, to ensure that text\n      // node boundaries are handled correctly.\n      var isAtBlockEdge = point => {\n        var blockAbove = Editor.above(editor, {\n          at: point,\n          match: n => Element.isElement(n) && Editor.isBlock(editor, n)\n        });\n        return blockAbove && Editor.isEdge(editor, point, blockAbove[1]);\n      };\n      Transforms.splitNodes(editor, {\n        at: end,\n        match,\n        voids,\n        always: !isAtBlockEdge(end)\n      });\n      Transforms.splitNodes(editor, {\n        at: start,\n        match,\n        voids,\n        always: !isAtBlockEdge(start)\n      });\n      at = rangeRef.unref();\n      if (options.at == null) {\n        Transforms.select(editor, at);\n      }\n    }\n    var roots = Array.from(Editor.nodes(editor, {\n      at,\n      match: editor.isInline(element) ? n => Element.isElement(n) && Editor.isBlock(editor, n) : n => Editor.isEditor(n),\n      mode: 'lowest',\n      voids\n    }));\n    var _loop = function _loop() {\n        var a = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;\n        if (!a) {\n          return 0; // continue\n        }\n        var matches = Array.from(Editor.nodes(editor, {\n          at: a,\n          match,\n          mode,\n          voids\n        }));\n        if (matches.length > 0) {\n          var [first] = matches;\n          var last = matches[matches.length - 1];\n          var [, firstPath] = first;\n          var [, lastPath] = last;\n          if (firstPath.length === 0 && lastPath.length === 0) {\n            // if there's no matching parent - usually means the node is an editor - don't do anything\n            return 0; // continue\n          }\n          var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);\n          var range = Editor.range(editor, firstPath, lastPath);\n          var commonNodeEntry = Editor.node(editor, commonPath);\n          var [commonNode] = commonNodeEntry;\n          var depth = commonPath.length + 1;\n          var wrapperPath = Path.next(lastPath.slice(0, depth));\n          var wrapper = _objectSpread(_objectSpread({}, element), {}, {\n            children: []\n          });\n          Transforms.insertNodes(editor, wrapper, {\n            at: wrapperPath,\n            voids\n          });\n          Transforms.moveNodes(editor, {\n            at: range,\n            match: n => Element.isAncestor(commonNode) && commonNode.children.includes(n),\n            to: wrapperPath.concat(0),\n            voids\n          });\n        }\n      },\n      _ret;\n    for (var [, rootPath] of roots) {\n      _ret = _loop();\n      if (_ret === 0) continue;\n    }\n  });\n};\n\n/**\n * Create a new Slate `Editor` object.\n */\nvar createEditor = () => {\n  var editor = {\n    children: [],\n    operations: [],\n    selection: null,\n    marks: null,\n    isElementReadOnly: () => false,\n    isInline: () => false,\n    isSelectable: () => true,\n    isVoid: () => false,\n    markableVoid: () => false,\n    onChange: () => {},\n    // Core\n    apply: function apply$1() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return apply(editor, ...args);\n    },\n    // Editor\n    addMark: function addMark$1() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return addMark(editor, ...args);\n    },\n    deleteBackward: function deleteBackward$1() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return deleteBackward(editor, ...args);\n    },\n    deleteForward: function deleteForward$1() {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return deleteForward(editor, ...args);\n    },\n    deleteFragment: function deleteFragment$1() {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return deleteFragment(editor, ...args);\n    },\n    getFragment: function getFragment$1() {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return getFragment(editor, ...args);\n    },\n    insertBreak: function insertBreak$1() {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return insertBreak(editor, ...args);\n    },\n    insertSoftBreak: function insertSoftBreak$1() {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      return insertSoftBreak(editor, ...args);\n    },\n    insertFragment: function insertFragment$1() {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n      return insertFragment(editor, ...args);\n    },\n    insertNode: function insertNode$1() {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n      return insertNode(editor, ...args);\n    },\n    insertText: function insertText$1() {\n      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        args[_key11] = arguments[_key11];\n      }\n      return insertText(editor, ...args);\n    },\n    normalizeNode: function normalizeNode$1() {\n      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        args[_key12] = arguments[_key12];\n      }\n      return normalizeNode(editor, ...args);\n    },\n    removeMark: function removeMark$1() {\n      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        args[_key13] = arguments[_key13];\n      }\n      return removeMark(editor, ...args);\n    },\n    getDirtyPaths: function getDirtyPaths$1() {\n      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        args[_key14] = arguments[_key14];\n      }\n      return getDirtyPaths(editor, ...args);\n    },\n    shouldNormalize: function shouldNormalize$1() {\n      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n        args[_key15] = arguments[_key15];\n      }\n      return shouldNormalize(editor, ...args);\n    },\n    // Editor interface\n    above: function above$1() {\n      for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n        args[_key16] = arguments[_key16];\n      }\n      return above(editor, ...args);\n    },\n    after: function after$1() {\n      for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n        args[_key17] = arguments[_key17];\n      }\n      return after(editor, ...args);\n    },\n    before: function before$1() {\n      for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {\n        args[_key18] = arguments[_key18];\n      }\n      return before(editor, ...args);\n    },\n    collapse: function collapse$1() {\n      for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {\n        args[_key19] = arguments[_key19];\n      }\n      return collapse(editor, ...args);\n    },\n    delete: function _delete() {\n      for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {\n        args[_key20] = arguments[_key20];\n      }\n      return deleteText(editor, ...args);\n    },\n    deselect: function deselect$1() {\n      for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {\n        args[_key21] = arguments[_key21];\n      }\n      return deselect(editor, ...args);\n    },\n    edges: function edges$1() {\n      for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {\n        args[_key22] = arguments[_key22];\n      }\n      return edges(editor, ...args);\n    },\n    elementReadOnly: function elementReadOnly$1() {\n      for (var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {\n        args[_key23] = arguments[_key23];\n      }\n      return elementReadOnly(editor, ...args);\n    },\n    end: function end$1() {\n      for (var _len24 = arguments.length, args = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {\n        args[_key24] = arguments[_key24];\n      }\n      return end(editor, ...args);\n    },\n    first: function first$1() {\n      for (var _len25 = arguments.length, args = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {\n        args[_key25] = arguments[_key25];\n      }\n      return first(editor, ...args);\n    },\n    fragment: function fragment$1() {\n      for (var _len26 = arguments.length, args = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++) {\n        args[_key26] = arguments[_key26];\n      }\n      return fragment(editor, ...args);\n    },\n    getMarks: function getMarks() {\n      for (var _len27 = arguments.length, args = new Array(_len27), _key27 = 0; _key27 < _len27; _key27++) {\n        args[_key27] = arguments[_key27];\n      }\n      return marks(editor, ...args);\n    },\n    hasBlocks: function hasBlocks$1() {\n      for (var _len28 = arguments.length, args = new Array(_len28), _key28 = 0; _key28 < _len28; _key28++) {\n        args[_key28] = arguments[_key28];\n      }\n      return hasBlocks(editor, ...args);\n    },\n    hasInlines: function hasInlines$1() {\n      for (var _len29 = arguments.length, args = new Array(_len29), _key29 = 0; _key29 < _len29; _key29++) {\n        args[_key29] = arguments[_key29];\n      }\n      return hasInlines(editor, ...args);\n    },\n    hasPath: function hasPath$1() {\n      for (var _len30 = arguments.length, args = new Array(_len30), _key30 = 0; _key30 < _len30; _key30++) {\n        args[_key30] = arguments[_key30];\n      }\n      return hasPath(editor, ...args);\n    },\n    hasTexts: function hasTexts$1() {\n      for (var _len31 = arguments.length, args = new Array(_len31), _key31 = 0; _key31 < _len31; _key31++) {\n        args[_key31] = arguments[_key31];\n      }\n      return hasTexts(editor, ...args);\n    },\n    insertNodes: function insertNodes$1() {\n      for (var _len32 = arguments.length, args = new Array(_len32), _key32 = 0; _key32 < _len32; _key32++) {\n        args[_key32] = arguments[_key32];\n      }\n      return insertNodes(editor, ...args);\n    },\n    isBlock: function isBlock$1() {\n      for (var _len33 = arguments.length, args = new Array(_len33), _key33 = 0; _key33 < _len33; _key33++) {\n        args[_key33] = arguments[_key33];\n      }\n      return isBlock(editor, ...args);\n    },\n    isEdge: function isEdge$1() {\n      for (var _len34 = arguments.length, args = new Array(_len34), _key34 = 0; _key34 < _len34; _key34++) {\n        args[_key34] = arguments[_key34];\n      }\n      return isEdge(editor, ...args);\n    },\n    isEmpty: function isEmpty$1() {\n      for (var _len35 = arguments.length, args = new Array(_len35), _key35 = 0; _key35 < _len35; _key35++) {\n        args[_key35] = arguments[_key35];\n      }\n      return isEmpty(editor, ...args);\n    },\n    isEnd: function isEnd$1() {\n      for (var _len36 = arguments.length, args = new Array(_len36), _key36 = 0; _key36 < _len36; _key36++) {\n        args[_key36] = arguments[_key36];\n      }\n      return isEnd(editor, ...args);\n    },\n    isNormalizing: function isNormalizing$1() {\n      for (var _len37 = arguments.length, args = new Array(_len37), _key37 = 0; _key37 < _len37; _key37++) {\n        args[_key37] = arguments[_key37];\n      }\n      return isNormalizing(editor, ...args);\n    },\n    isStart: function isStart$1() {\n      for (var _len38 = arguments.length, args = new Array(_len38), _key38 = 0; _key38 < _len38; _key38++) {\n        args[_key38] = arguments[_key38];\n      }\n      return isStart(editor, ...args);\n    },\n    last: function last$1() {\n      for (var _len39 = arguments.length, args = new Array(_len39), _key39 = 0; _key39 < _len39; _key39++) {\n        args[_key39] = arguments[_key39];\n      }\n      return last(editor, ...args);\n    },\n    leaf: function leaf$1() {\n      for (var _len40 = arguments.length, args = new Array(_len40), _key40 = 0; _key40 < _len40; _key40++) {\n        args[_key40] = arguments[_key40];\n      }\n      return leaf(editor, ...args);\n    },\n    levels: function levels$1() {\n      for (var _len41 = arguments.length, args = new Array(_len41), _key41 = 0; _key41 < _len41; _key41++) {\n        args[_key41] = arguments[_key41];\n      }\n      return levels(editor, ...args);\n    },\n    liftNodes: function liftNodes$1() {\n      for (var _len42 = arguments.length, args = new Array(_len42), _key42 = 0; _key42 < _len42; _key42++) {\n        args[_key42] = arguments[_key42];\n      }\n      return liftNodes(editor, ...args);\n    },\n    mergeNodes: function mergeNodes$1() {\n      for (var _len43 = arguments.length, args = new Array(_len43), _key43 = 0; _key43 < _len43; _key43++) {\n        args[_key43] = arguments[_key43];\n      }\n      return mergeNodes(editor, ...args);\n    },\n    move: function move$1() {\n      for (var _len44 = arguments.length, args = new Array(_len44), _key44 = 0; _key44 < _len44; _key44++) {\n        args[_key44] = arguments[_key44];\n      }\n      return move(editor, ...args);\n    },\n    moveNodes: function moveNodes$1() {\n      for (var _len45 = arguments.length, args = new Array(_len45), _key45 = 0; _key45 < _len45; _key45++) {\n        args[_key45] = arguments[_key45];\n      }\n      return moveNodes(editor, ...args);\n    },\n    next: function next$1() {\n      for (var _len46 = arguments.length, args = new Array(_len46), _key46 = 0; _key46 < _len46; _key46++) {\n        args[_key46] = arguments[_key46];\n      }\n      return next(editor, ...args);\n    },\n    node: function node$1() {\n      for (var _len47 = arguments.length, args = new Array(_len47), _key47 = 0; _key47 < _len47; _key47++) {\n        args[_key47] = arguments[_key47];\n      }\n      return node(editor, ...args);\n    },\n    nodes: function nodes$1() {\n      for (var _len48 = arguments.length, args = new Array(_len48), _key48 = 0; _key48 < _len48; _key48++) {\n        args[_key48] = arguments[_key48];\n      }\n      return nodes(editor, ...args);\n    },\n    normalize: function normalize$1() {\n      for (var _len49 = arguments.length, args = new Array(_len49), _key49 = 0; _key49 < _len49; _key49++) {\n        args[_key49] = arguments[_key49];\n      }\n      return normalize(editor, ...args);\n    },\n    parent: function parent$1() {\n      for (var _len50 = arguments.length, args = new Array(_len50), _key50 = 0; _key50 < _len50; _key50++) {\n        args[_key50] = arguments[_key50];\n      }\n      return parent(editor, ...args);\n    },\n    path: function path$1() {\n      for (var _len51 = arguments.length, args = new Array(_len51), _key51 = 0; _key51 < _len51; _key51++) {\n        args[_key51] = arguments[_key51];\n      }\n      return path(editor, ...args);\n    },\n    pathRef: function pathRef$1() {\n      for (var _len52 = arguments.length, args = new Array(_len52), _key52 = 0; _key52 < _len52; _key52++) {\n        args[_key52] = arguments[_key52];\n      }\n      return pathRef(editor, ...args);\n    },\n    pathRefs: function pathRefs$1() {\n      for (var _len53 = arguments.length, args = new Array(_len53), _key53 = 0; _key53 < _len53; _key53++) {\n        args[_key53] = arguments[_key53];\n      }\n      return pathRefs(editor, ...args);\n    },\n    point: function point$1() {\n      for (var _len54 = arguments.length, args = new Array(_len54), _key54 = 0; _key54 < _len54; _key54++) {\n        args[_key54] = arguments[_key54];\n      }\n      return point(editor, ...args);\n    },\n    pointRef: function pointRef$1() {\n      for (var _len55 = arguments.length, args = new Array(_len55), _key55 = 0; _key55 < _len55; _key55++) {\n        args[_key55] = arguments[_key55];\n      }\n      return pointRef(editor, ...args);\n    },\n    pointRefs: function pointRefs$1() {\n      for (var _len56 = arguments.length, args = new Array(_len56), _key56 = 0; _key56 < _len56; _key56++) {\n        args[_key56] = arguments[_key56];\n      }\n      return pointRefs(editor, ...args);\n    },\n    positions: function positions$1() {\n      for (var _len57 = arguments.length, args = new Array(_len57), _key57 = 0; _key57 < _len57; _key57++) {\n        args[_key57] = arguments[_key57];\n      }\n      return positions(editor, ...args);\n    },\n    previous: function previous$1() {\n      for (var _len58 = arguments.length, args = new Array(_len58), _key58 = 0; _key58 < _len58; _key58++) {\n        args[_key58] = arguments[_key58];\n      }\n      return previous(editor, ...args);\n    },\n    range: function range$1() {\n      for (var _len59 = arguments.length, args = new Array(_len59), _key59 = 0; _key59 < _len59; _key59++) {\n        args[_key59] = arguments[_key59];\n      }\n      return range(editor, ...args);\n    },\n    rangeRef: function rangeRef$1() {\n      for (var _len60 = arguments.length, args = new Array(_len60), _key60 = 0; _key60 < _len60; _key60++) {\n        args[_key60] = arguments[_key60];\n      }\n      return rangeRef(editor, ...args);\n    },\n    rangeRefs: function rangeRefs$1() {\n      for (var _len61 = arguments.length, args = new Array(_len61), _key61 = 0; _key61 < _len61; _key61++) {\n        args[_key61] = arguments[_key61];\n      }\n      return rangeRefs(editor, ...args);\n    },\n    removeNodes: function removeNodes$1() {\n      for (var _len62 = arguments.length, args = new Array(_len62), _key62 = 0; _key62 < _len62; _key62++) {\n        args[_key62] = arguments[_key62];\n      }\n      return removeNodes(editor, ...args);\n    },\n    select: function select$1() {\n      for (var _len63 = arguments.length, args = new Array(_len63), _key63 = 0; _key63 < _len63; _key63++) {\n        args[_key63] = arguments[_key63];\n      }\n      return select(editor, ...args);\n    },\n    setNodes: function setNodes$1() {\n      for (var _len64 = arguments.length, args = new Array(_len64), _key64 = 0; _key64 < _len64; _key64++) {\n        args[_key64] = arguments[_key64];\n      }\n      return setNodes(editor, ...args);\n    },\n    setNormalizing: function setNormalizing$1() {\n      for (var _len65 = arguments.length, args = new Array(_len65), _key65 = 0; _key65 < _len65; _key65++) {\n        args[_key65] = arguments[_key65];\n      }\n      return setNormalizing(editor, ...args);\n    },\n    setPoint: function setPoint$1() {\n      for (var _len66 = arguments.length, args = new Array(_len66), _key66 = 0; _key66 < _len66; _key66++) {\n        args[_key66] = arguments[_key66];\n      }\n      return setPoint(editor, ...args);\n    },\n    setSelection: function setSelection$1() {\n      for (var _len67 = arguments.length, args = new Array(_len67), _key67 = 0; _key67 < _len67; _key67++) {\n        args[_key67] = arguments[_key67];\n      }\n      return setSelection(editor, ...args);\n    },\n    splitNodes: function splitNodes$1() {\n      for (var _len68 = arguments.length, args = new Array(_len68), _key68 = 0; _key68 < _len68; _key68++) {\n        args[_key68] = arguments[_key68];\n      }\n      return splitNodes(editor, ...args);\n    },\n    start: function start$1() {\n      for (var _len69 = arguments.length, args = new Array(_len69), _key69 = 0; _key69 < _len69; _key69++) {\n        args[_key69] = arguments[_key69];\n      }\n      return start(editor, ...args);\n    },\n    string: function string$1() {\n      for (var _len70 = arguments.length, args = new Array(_len70), _key70 = 0; _key70 < _len70; _key70++) {\n        args[_key70] = arguments[_key70];\n      }\n      return string(editor, ...args);\n    },\n    unhangRange: function unhangRange$1() {\n      for (var _len71 = arguments.length, args = new Array(_len71), _key71 = 0; _key71 < _len71; _key71++) {\n        args[_key71] = arguments[_key71];\n      }\n      return unhangRange(editor, ...args);\n    },\n    unsetNodes: function unsetNodes$1() {\n      for (var _len72 = arguments.length, args = new Array(_len72), _key72 = 0; _key72 < _len72; _key72++) {\n        args[_key72] = arguments[_key72];\n      }\n      return unsetNodes(editor, ...args);\n    },\n    unwrapNodes: function unwrapNodes$1() {\n      for (var _len73 = arguments.length, args = new Array(_len73), _key73 = 0; _key73 < _len73; _key73++) {\n        args[_key73] = arguments[_key73];\n      }\n      return unwrapNodes(editor, ...args);\n    },\n    void: function _void() {\n      for (var _len74 = arguments.length, args = new Array(_len74), _key74 = 0; _key74 < _len74; _key74++) {\n        args[_key74] = arguments[_key74];\n      }\n      return getVoid(editor, ...args);\n    },\n    withoutNormalizing: function withoutNormalizing$1() {\n      for (var _len75 = arguments.length, args = new Array(_len75), _key75 = 0; _key75 < _len75; _key75++) {\n        args[_key75] = arguments[_key75];\n      }\n      return withoutNormalizing(editor, ...args);\n    },\n    wrapNodes: function wrapNodes$1() {\n      for (var _len76 = arguments.length, args = new Array(_len76), _key76 = 0; _key76 < _len76; _key76++) {\n        args[_key76] = arguments[_key76];\n      }\n      return wrapNodes(editor, ...args);\n    },\n    shouldMergeNodesRemovePrevNode: function shouldMergeNodesRemovePrevNode$1() {\n      for (var _len77 = arguments.length, args = new Array(_len77), _key77 = 0; _key77 < _len77; _key77++) {\n        args[_key77] = arguments[_key77];\n      }\n      return shouldMergeNodesRemovePrevNode(editor, ...args);\n    }\n  };\n  return editor;\n};\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NsYXRlL2Rpc3QvaW5kZXguZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW9CLHVDQUF1QztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvQ0FBb0M7QUFDbEQ7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3RQLDhCQUE4QixnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHdEQUF3RCw4QkFBOEIscUpBQXFKLHFFQUFxRSxLQUFLO0FBQ2xiO0FBQ0EsOEZBQThGLGFBQWE7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRyxlQUFlO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxtQkFBbUI7QUFDeEU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsV0FBVztBQUMxRDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxXQUFXO0FBQ2hFO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFdBQVc7QUFDckU7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkLDBEQUEwRCxXQUFXO0FBQ3JFO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFdBQVc7QUFDaEU7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFdBQVc7QUFDckU7QUFDQSxlQUFlO0FBQ2YsMkRBQTJELGtCQUFrQjtBQUM3RTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBLDBEQUEwRCxXQUFXO0FBQ3JFO0FBQ0EsZUFBZTtBQUNmLDJEQUEyRCxrQkFBa0I7QUFDN0U7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3RQLDhCQUE4QixnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHdEQUF3RCw4QkFBOEIscUpBQXFKLHFFQUFxRSxLQUFLO0FBQ2xiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGtCQUFrQiw4Q0FBTztBQUN6QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLDJCQUEyQix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUN0UCw4QkFBOEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCx3REFBd0QsOEJBQThCLHFKQUFxSixxRUFBcUUsS0FBSztBQUNsYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1oscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1oscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3RQLDhCQUE4QixnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHdEQUF3RCw4QkFBOEIscUpBQXFKLHFFQUFxRSxLQUFLO0FBQ2xiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsZ0ZBQWdGLGNBQWM7QUFDOUY7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUN0UCw4QkFBOEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCx3REFBd0QsOEJBQThCLHFKQUFxSixxRUFBcUUsS0FBSztBQUNsYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGFBQWE7QUFDakU7QUFDQSxhQUFhO0FBQ2I7QUFDQSxxREFBcUQsYUFBYTtBQUNsRTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxhQUFhO0FBQ2pFO0FBQ0EsYUFBYTtBQUNiO0FBQ0EscURBQXFELGFBQWE7QUFDbEU7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQSwyQkFBMkIsd0JBQXdCLG9DQUFvQyx5Q0FBeUMsa0NBQWtDLDBEQUEwRCwwQkFBMEI7QUFDdFAsOEJBQThCLGdCQUFnQixzQkFBc0IsT0FBTyxrREFBa0Qsd0RBQXdELDhCQUE4QixxSkFBcUoscUVBQXFFLEtBQUs7QUFDbGIsbUZBQW1GOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxxQkFBcUI7QUFDckI7O0FBRUEsMkJBQTJCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3RQLDhCQUE4QixnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHdEQUF3RCw4QkFBOEIscUpBQXFKLHFFQUFxRSxLQUFLO0FBQ2xiO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ04sb0RBQW9ELDRCQUE0QixLQUFLO0FBQ3JGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUN0UCw4QkFBOEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCx3REFBd0QsOEJBQThCLHFKQUFxSixxRUFBcUUsS0FBSztBQUNsYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsMkVBQTJFLGNBQWM7QUFDekY7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3RQLDhCQUE4QixnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHdEQUF3RCw4QkFBOEIscUpBQXFKLHFFQUFxRSxLQUFLO0FBQ2xiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSwyRUFBMkUsY0FBYztBQUN6RjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3RQLDhCQUE4QixnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHdEQUF3RCw4QkFBOEIscUpBQXFKLHFFQUFxRSxLQUFLO0FBQ2xiO0FBQ0E7QUFDQSxnRUFBZ0UsY0FBYztBQUM5RTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3RQLDhCQUE4QixnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHdEQUF3RCw4QkFBOEIscUpBQXFKLHFFQUFxRSxLQUFLO0FBQ2xiO0FBQ0E7QUFDQSxnRUFBZ0UsY0FBYztBQUM5RTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsMkJBQTJCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3RQLDhCQUE4QixnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHdEQUF3RCw4QkFBOEIscUpBQXFKLHFFQUFxRSxLQUFLO0FBQ2xiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsVUFBVTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsT0FBTztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsbUJBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUN0UCw4QkFBOEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCx3REFBd0QsOEJBQThCLHFKQUFxSixxRUFBcUUsS0FBSztBQUNsYjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOLG9DQUFvQyw0QkFBNEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLDJCQUEyQix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUN0UCw4QkFBOEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCx3REFBd0QsOEJBQThCLHFKQUFxSixxRUFBcUUsS0FBSztBQUNsYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLHlCQUF5Qix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUNwUCw0QkFBNEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCxzREFBc0QsOEJBQThCLG1KQUFtSixxRUFBcUUsS0FBSztBQUM1YTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsY0FBYztBQUNwRTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLDBFQUEwRSxhQUFhO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkVBQTZFLGVBQWU7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNkVBQTZFLGVBQWU7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNkVBQTZFLGVBQWU7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNkVBQTZFLGVBQWU7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNkVBQTZFLGVBQWU7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNkVBQTZFLGVBQWU7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNkVBQTZFLGVBQWU7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNkVBQTZFLGVBQWU7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTIrQjtBQUMzK0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9HYWxvY2svQ1MvYmVob21lLXNpdGUvbm9kZV9tb2R1bGVzL3NsYXRlL2Rpc3QvaW5kZXguZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcHJvZHVjZSB9IGZyb20gJ2ltbWVyJztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFBhdGhSZWYgPSB7XG4gIHRyYW5zZm9ybShyZWYsIG9wKSB7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBhZmZpbml0eVxuICAgIH0gPSByZWY7XG4gICAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcGF0aCA9IFBhdGgudHJhbnNmb3JtKGN1cnJlbnQsIG9wLCB7XG4gICAgICBhZmZpbml0eVxuICAgIH0pO1xuICAgIHJlZi5jdXJyZW50ID0gcGF0aDtcbiAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICByZWYudW5yZWYoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBQb2ludFJlZiA9IHtcbiAgdHJhbnNmb3JtKHJlZiwgb3ApIHtcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIGFmZmluaXR5XG4gICAgfSA9IHJlZjtcbiAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwb2ludCA9IFBvaW50LnRyYW5zZm9ybShjdXJyZW50LCBvcCwge1xuICAgICAgYWZmaW5pdHlcbiAgICB9KTtcbiAgICByZWYuY3VycmVudCA9IHBvaW50O1xuICAgIGlmIChwb2ludCA9PSBudWxsKSB7XG4gICAgICByZWYudW5yZWYoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBSYW5nZVJlZiA9IHtcbiAgdHJhbnNmb3JtKHJlZiwgb3ApIHtcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIGFmZmluaXR5XG4gICAgfSA9IHJlZjtcbiAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwYXRoID0gUmFuZ2UudHJhbnNmb3JtKGN1cnJlbnQsIG9wLCB7XG4gICAgICBhZmZpbml0eVxuICAgIH0pO1xuICAgIHJlZi5jdXJyZW50ID0gcGF0aDtcbiAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICByZWYudW5yZWYoKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBESVJUWV9QQVRIUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRElSVFlfUEFUSF9LRVlTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBGTFVTSElORyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgTk9STUFMSVpJTkcgPSBuZXcgV2Vha01hcCgpO1xudmFyIFBBVEhfUkVGUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgUE9JTlRfUkVGUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgUkFOR0VfUkVGUyA9IG5ldyBXZWFrTWFwKCk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBQYXRoID0ge1xuICBhbmNlc3RvcnMocGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgcmV2ZXJzZSA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHBhdGhzID0gUGF0aC5sZXZlbHMocGF0aCwgb3B0aW9ucyk7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHBhdGhzID0gcGF0aHMuc2xpY2UoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGhzID0gcGF0aHMuc2xpY2UoMCwgLTEpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aHM7XG4gIH0sXG4gIGNvbW1vbihwYXRoLCBhbm90aGVyKSB7XG4gICAgdmFyIGNvbW1vbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggJiYgaSA8IGFub3RoZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhdiA9IHBhdGhbaV07XG4gICAgICB2YXIgYnYgPSBhbm90aGVyW2ldO1xuICAgICAgaWYgKGF2ICE9PSBidikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbW1vbi5wdXNoKGF2KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbW1vbjtcbiAgfSxcbiAgY29tcGFyZShwYXRoLCBhbm90aGVyKSB7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluKHBhdGgubGVuZ3RoLCBhbm90aGVyLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW47IGkrKykge1xuICAgICAgaWYgKHBhdGhbaV0gPCBhbm90aGVyW2ldKSByZXR1cm4gLTE7XG4gICAgICBpZiAocGF0aFtpXSA+IGFub3RoZXJbaV0pIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgZW5kc0FmdGVyKHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTtcbiAgICB2YXIgYXMgPSBwYXRoLnNsaWNlKDAsIGkpO1xuICAgIHZhciBicyA9IGFub3RoZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGF2ID0gcGF0aFtpXTtcbiAgICB2YXIgYnYgPSBhbm90aGVyW2ldO1xuICAgIHJldHVybiBQYXRoLmVxdWFscyhhcywgYnMpICYmIGF2ID4gYnY7XG4gIH0sXG4gIGVuZHNBdChwYXRoLCBhbm90aGVyKSB7XG4gICAgdmFyIGkgPSBwYXRoLmxlbmd0aDtcbiAgICB2YXIgYXMgPSBwYXRoLnNsaWNlKDAsIGkpO1xuICAgIHZhciBicyA9IGFub3RoZXIuc2xpY2UoMCwgaSk7XG4gICAgcmV0dXJuIFBhdGguZXF1YWxzKGFzLCBicyk7XG4gIH0sXG4gIGVuZHNCZWZvcmUocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBpID0gcGF0aC5sZW5ndGggLSAxO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXYgPSBwYXRoW2ldO1xuICAgIHZhciBidiA9IGFub3RoZXJbaV07XG4gICAgcmV0dXJuIFBhdGguZXF1YWxzKGFzLCBicykgJiYgYXYgPCBidjtcbiAgfSxcbiAgZXF1YWxzKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPT09IGFub3RoZXIubGVuZ3RoICYmIHBhdGguZXZlcnkoKG4sIGkpID0+IG4gPT09IGFub3RoZXJbaV0pO1xuICB9LFxuICBoYXNQcmV2aW91cyhwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGhbcGF0aC5sZW5ndGggLSAxXSA+IDA7XG4gIH0sXG4gIGlzQWZ0ZXIocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDE7XG4gIH0sXG4gIGlzQW5jZXN0b3IocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA8IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcbiAgaXNCZWZvcmUocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IC0xO1xuICB9LFxuICBpc0NoaWxkKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPT09IGFub3RoZXIubGVuZ3RoICsgMSAmJiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDA7XG4gIH0sXG4gIGlzQ29tbW9uKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPD0gYW5vdGhlci5sZW5ndGggJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuICBpc0Rlc2NlbmRhbnQocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA+IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcbiAgaXNQYXJlbnQocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCArIDEgPT09IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcbiAgaXNQYXRoKHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmICh2YWx1ZS5sZW5ndGggPT09IDAgfHwgdHlwZW9mIHZhbHVlWzBdID09PSAnbnVtYmVyJyk7XG4gIH0sXG4gIGlzU2libGluZyhwYXRoLCBhbm90aGVyKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoICE9PSBhbm90aGVyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgYXMgPSBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgICB2YXIgYnMgPSBhbm90aGVyLnNsaWNlKDAsIC0xKTtcbiAgICB2YXIgYWwgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgdmFyIGJsID0gYW5vdGhlclthbm90aGVyLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBhbCAhPT0gYmwgJiYgUGF0aC5lcXVhbHMoYXMsIGJzKTtcbiAgfSxcbiAgbGV2ZWxzKHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBsaXN0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgbGlzdC5wdXNoKHBhdGguc2xpY2UoMCwgaSkpO1xuICAgIH1cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgbGlzdC5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xuICB9LFxuICBuZXh0KHBhdGgpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIG5leHQgcGF0aCBvZiBhIHJvb3QgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSwgYmVjYXVzZSBpdCBoYXMgbm8gbmV4dCBpbmRleC5cIikpO1xuICAgIH1cbiAgICB2YXIgbGFzdCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gcGF0aC5zbGljZSgwLCAtMSkuY29uY2F0KGxhc3QgKyAxKTtcbiAgfSxcbiAgb3BlcmF0aW9uQ2FuVHJhbnNmb3JtUGF0aChvcGVyYXRpb24pIHtcbiAgICBzd2l0Y2ggKG9wZXJhdGlvbi50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuICBwYXJlbnQocGF0aCkge1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcGFyZW50IHBhdGggb2YgdGhlIHJvb3QgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXS5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aC5zbGljZSgwLCAtMSk7XG4gIH0sXG4gIHByZXZpb3VzKHBhdGgpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHByZXZpb3VzIHBhdGggb2YgYSByb290IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0sIGJlY2F1c2UgaXQgaGFzIG5vIHByZXZpb3VzIGluZGV4LlwiKSk7XG4gICAgfVxuICAgIHZhciBsYXN0ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0IDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHByZXZpb3VzIHBhdGggb2YgYSBmaXJzdCBjaGlsZCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgd291bGQgcmVzdWx0IGluIGEgbmVnYXRpdmUgaW5kZXguXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgLTEpLmNvbmNhdChsYXN0IC0gMSk7XG4gIH0sXG4gIHJlbGF0aXZlKHBhdGgsIGFuY2VzdG9yKSB7XG4gICAgaWYgKCFQYXRoLmlzQW5jZXN0b3IoYW5jZXN0b3IsIHBhdGgpICYmICFQYXRoLmVxdWFscyhwYXRoLCBhbmNlc3RvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHJlbGF0aXZlIHBhdGggb2YgW1wiLmNvbmNhdChwYXRoLCBcIl0gaW5zaWRlIGFuY2VzdG9yIFtcIikuY29uY2F0KGFuY2VzdG9yLCBcIl0sIGJlY2F1c2UgaXQgaXMgbm90IGFib3ZlIG9yIGVxdWFsIHRvIHRoZSBwYXRoLlwiKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoLnNsaWNlKGFuY2VzdG9yLmxlbmd0aCk7XG4gIH0sXG4gIHRyYW5zZm9ybShwYXRoLCBvcGVyYXRpb24pIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgaWYgKCFwYXRoKSByZXR1cm4gbnVsbDtcbiAgICAvLyBQRVJGOiB1c2UgZGVzdHJ1Y3RpbmcgaW5zdGVhZCBvZiBpbW1lclxuICAgIHZhciBwID0gWy4uLnBhdGhdO1xuICAgIHZhciB7XG4gICAgICBhZmZpbml0eSA9ICdmb3J3YXJkJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIC8vIFBFUkY6IEV4aXQgZWFybHkgaWYgdGhlIG9wZXJhdGlvbiBpcyBndWFyYW50ZWVkIG5vdCB0byBoYXZlIGFuIGVmZmVjdC5cbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBzd2l0Y2ggKG9wZXJhdGlvbi50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcGF0aDogb3BcbiAgICAgICAgICB9ID0gb3BlcmF0aW9uO1xuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcCwgcCkgfHwgUGF0aC5lbmRzQmVmb3JlKG9wLCBwKSB8fCBQYXRoLmlzQW5jZXN0b3Iob3AsIHApKSB7XG4gICAgICAgICAgICBwW29wLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcGF0aDogX29wXG4gICAgICAgICAgfSA9IG9wZXJhdGlvbjtcbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX29wLCBwKSB8fCBQYXRoLmlzQW5jZXN0b3IoX29wLCBwKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wLCBwKSkge1xuICAgICAgICAgICAgcFtfb3AubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IF9vcDIsXG4gICAgICAgICAgICBwb3NpdGlvblxuICAgICAgICAgIH0gPSBvcGVyYXRpb247XG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcDIsIHApIHx8IFBhdGguZW5kc0JlZm9yZShfb3AyLCBwKSkge1xuICAgICAgICAgICAgcFtfb3AyLmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmlzQW5jZXN0b3IoX29wMiwgcCkpIHtcbiAgICAgICAgICAgIHBbX29wMi5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgICAgcFtfb3AyLmxlbmd0aF0gKz0gcG9zaXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoOiBfb3AzLFxuICAgICAgICAgICAgcG9zaXRpb246IF9wb3NpdGlvblxuICAgICAgICAgIH0gPSBvcGVyYXRpb247XG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcDMsIHApKSB7XG4gICAgICAgICAgICBpZiAoYWZmaW5pdHkgPT09ICdmb3J3YXJkJykge1xuICAgICAgICAgICAgICBwW3AubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWZmaW5pdHkgPT09ICdiYWNrd2FyZCcpIDsgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDMsIHApKSB7XG4gICAgICAgICAgICBwW19vcDMubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguaXNBbmNlc3Rvcihfb3AzLCBwKSAmJiBwYXRoW19vcDMubGVuZ3RoXSA+PSBfcG9zaXRpb24pIHtcbiAgICAgICAgICAgIHBbX29wMy5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgcFtfb3AzLmxlbmd0aF0gLT0gX3Bvc2l0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoOiBfb3A0LFxuICAgICAgICAgICAgbmV3UGF0aDogb25wXG4gICAgICAgICAgfSA9IG9wZXJhdGlvbjtcbiAgICAgICAgICAvLyBJZiB0aGUgb2xkIGFuZCBuZXcgcGF0aCBhcmUgdGhlIHNhbWUsIGl0J3MgYSBuby1vcC5cbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX29wNCwgb25wKSkge1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IoX29wNCwgcCkgfHwgUGF0aC5lcXVhbHMoX29wNCwgcCkpIHtcbiAgICAgICAgICAgIHZhciBjb3B5ID0gb25wLnNsaWNlKCk7XG4gICAgICAgICAgICBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDQsIG9ucCkgJiYgX29wNC5sZW5ndGggPCBvbnAubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvcHlbX29wNC5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvcHkuY29uY2F0KHAuc2xpY2UoX29wNC5sZW5ndGgpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguaXNTaWJsaW5nKF9vcDQsIG9ucCkgJiYgKFBhdGguaXNBbmNlc3RvcihvbnAsIHApIHx8IFBhdGguZXF1YWxzKG9ucCwgcCkpKSB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDQsIHApKSB7XG4gICAgICAgICAgICAgIHBbX29wNC5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcFtfb3A0Lmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmVuZHNCZWZvcmUob25wLCBwKSB8fCBQYXRoLmVxdWFscyhvbnAsIHApIHx8IFBhdGguaXNBbmNlc3RvcihvbnAsIHApKSB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDQsIHApKSB7XG4gICAgICAgICAgICAgIHBbX29wNC5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcFtvbnAubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguZW5kc0JlZm9yZShfb3A0LCBwKSkge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9ucCwgcCkpIHtcbiAgICAgICAgICAgICAgcFtvbnAubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBbX29wNC5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfVxufTtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvO1xuICB9IDogZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgfSwgX3R5cGVvZihvKTtcbn1cblxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7XG4gIGlmIChfdHlwZW9mKGlucHV0KSAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0O1xuICB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbn1cblxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7XG4gIHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIF90eXBlb2Yoa2V5KSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIG93bktleXMkZShlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJGUoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyRlKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyRlKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgaW5zZXJ0Q2hpbGRyZW4gPSBmdW5jdGlvbiBpbnNlcnRDaGlsZHJlbih4cywgaW5kZXgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG5ld1ZhbHVlcyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgbmV3VmFsdWVzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICByZXR1cm4gWy4uLnhzLnNsaWNlKDAsIGluZGV4KSwgLi4ubmV3VmFsdWVzLCAuLi54cy5zbGljZShpbmRleCldO1xufTtcbnZhciByZXBsYWNlQ2hpbGRyZW4gPSBmdW5jdGlvbiByZXBsYWNlQ2hpbGRyZW4oeHMsIGluZGV4LCByZW1vdmVDb3VudCkge1xuICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIG5ld1ZhbHVlcyA9IG5ldyBBcnJheShfbGVuMiA+IDMgPyBfbGVuMiAtIDMgOiAwKSwgX2tleTIgPSAzOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgbmV3VmFsdWVzW19rZXkyIC0gM10gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG4gIHJldHVybiBbLi4ueHMuc2xpY2UoMCwgaW5kZXgpLCAuLi5uZXdWYWx1ZXMsIC4uLnhzLnNsaWNlKGluZGV4ICsgcmVtb3ZlQ291bnQpXTtcbn07XG52YXIgcmVtb3ZlQ2hpbGRyZW4gPSByZXBsYWNlQ2hpbGRyZW47XG4vKipcbiAqIFJlcGxhY2UgYSBkZXNjZW5kYW50IHdpdGggYSBuZXcgbm9kZSwgcmVwbGFjaW5nIGFsbCBhbmNlc3RvcnNcbiAqL1xudmFyIG1vZGlmeURlc2NlbmRhbnQgPSAoZWRpdG9yLCBwYXRoLCBmKSA9PiB7XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IG1vZGlmeSB0aGUgZWRpdG9yJyk7XG4gIH1cbiAgdmFyIG5vZGUgPSBOb2RlLmdldChlZGl0b3IsIHBhdGgpO1xuICB2YXIgc2xpY2VkUGF0aCA9IHBhdGguc2xpY2UoKTtcbiAgdmFyIG1vZGlmaWVkTm9kZSA9IGYobm9kZSk7XG4gIHdoaWxlIChzbGljZWRQYXRoLmxlbmd0aCA+IDEpIHtcbiAgICB2YXIgX2luZGV4ID0gc2xpY2VkUGF0aC5wb3AoKTtcbiAgICB2YXIgYW5jZXN0b3JOb2RlID0gTm9kZS5nZXQoZWRpdG9yLCBzbGljZWRQYXRoKTtcbiAgICBtb2RpZmllZE5vZGUgPSBfb2JqZWN0U3ByZWFkJGUoX29iamVjdFNwcmVhZCRlKHt9LCBhbmNlc3Rvck5vZGUpLCB7fSwge1xuICAgICAgY2hpbGRyZW46IHJlcGxhY2VDaGlsZHJlbihhbmNlc3Rvck5vZGUuY2hpbGRyZW4sIF9pbmRleCwgMSwgbW9kaWZpZWROb2RlKVxuICAgIH0pO1xuICB9XG4gIHZhciBpbmRleCA9IHNsaWNlZFBhdGgucG9wKCk7XG4gIGVkaXRvci5jaGlsZHJlbiA9IHJlcGxhY2VDaGlsZHJlbihlZGl0b3IuY2hpbGRyZW4sIGluZGV4LCAxLCBtb2RpZmllZE5vZGUpO1xufTtcbi8qKlxuICogUmVwbGFjZSB0aGUgY2hpbGRyZW4gb2YgYSBub2RlLCByZXBsYWNpbmcgYWxsIGFuY2VzdG9yc1xuICovXG52YXIgbW9kaWZ5Q2hpbGRyZW4gPSAoZWRpdG9yLCBwYXRoLCBmKSA9PiB7XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgIGVkaXRvci5jaGlsZHJlbiA9IGYoZWRpdG9yLmNoaWxkcmVuKTtcbiAgfSBlbHNlIHtcbiAgICBtb2RpZnlEZXNjZW5kYW50KGVkaXRvciwgcGF0aCwgbm9kZSA9PiB7XG4gICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgZWxlbWVudCBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgcmVmZXJzIHRvIGEgbGVhZiBub2RlOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShub2RlKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkZShfb2JqZWN0U3ByZWFkJGUoe30sIG5vZGUpLCB7fSwge1xuICAgICAgICBjaGlsZHJlbjogZihub2RlLmNoaWxkcmVuKVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn07XG4vKipcbiAqIFJlcGxhY2UgYSBsZWFmLCByZXBsYWNpbmcgYWxsIGFuY2VzdG9yc1xuICovXG52YXIgbW9kaWZ5TGVhZiA9IChlZGl0b3IsIHBhdGgsIGYpID0+IG1vZGlmeURlc2NlbmRhbnQoZWRpdG9yLCBwYXRoLCBub2RlID0+IHtcbiAgaWYgKCFUZXh0LmlzVGV4dChub2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIGxlYWYgbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgcmVmZXJzIHRvIGEgbm9uLWxlYWYgbm9kZTogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSkpKTtcbiAgfVxuICByZXR1cm4gZihub2RlKTtcbn0pO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIEdlbmVyYWxUcmFuc2Zvcm1zID0ge1xuICB0cmFuc2Zvcm0oZWRpdG9yLCBvcCkge1xuICAgIHZhciB0cmFuc2Zvcm1TZWxlY3Rpb24gPSBmYWxzZTtcbiAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgbm9kZVxuICAgICAgICAgIH0gPSBvcDtcbiAgICAgICAgICBtb2RpZnlDaGlsZHJlbihlZGl0b3IsIFBhdGgucGFyZW50KHBhdGgpLCBjaGlsZHJlbiA9PiB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAoaW5kZXggPiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IGFuIFxcXCJpbnNlcnRfbm9kZVxcXCIgb3BlcmF0aW9uIGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSB0aGUgZGVzdGluYXRpb24gaXMgcGFzdCB0aGUgZW5kIG9mIHRoZSBub2RlLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0Q2hpbGRyZW4oY2hpbGRyZW4sIGluZGV4LCBub2RlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0cmFuc2Zvcm1TZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgfSA9IG9wO1xuICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkgYnJlYWs7XG4gICAgICAgICAgbW9kaWZ5TGVhZihlZGl0b3IsIF9wYXRoLCBub2RlID0+IHtcbiAgICAgICAgICAgIHZhciBiZWZvcmUgPSBub2RlLnRleHQuc2xpY2UoMCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIHZhciBhZnRlciA9IG5vZGUudGV4dC5zbGljZShvZmZzZXQpO1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkZShfb2JqZWN0U3ByZWFkJGUoe30sIG5vZGUpLCB7fSwge1xuICAgICAgICAgICAgICB0ZXh0OiBiZWZvcmUgKyB0ZXh0ICsgYWZ0ZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRyYW5zZm9ybVNlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IF9wYXRoMlxuICAgICAgICAgIH0gPSBvcDtcbiAgICAgICAgICB2YXIgaW5kZXggPSBfcGF0aDJbX3BhdGgyLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIHZhciBwcmV2UGF0aCA9IFBhdGgucHJldmlvdXMoX3BhdGgyKTtcbiAgICAgICAgICB2YXIgcHJldkluZGV4ID0gcHJldlBhdGhbcHJldlBhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgbW9kaWZ5Q2hpbGRyZW4oZWRpdG9yLCBQYXRoLnBhcmVudChfcGF0aDIpLCBjaGlsZHJlbiA9PiB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gY2hpbGRyZW5bcHJldkluZGV4XTtcbiAgICAgICAgICAgIHZhciBuZXdOb2RlO1xuICAgICAgICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpICYmIFRleHQuaXNUZXh0KHByZXYpKSB7XG4gICAgICAgICAgICAgIG5ld05vZGUgPSBfb2JqZWN0U3ByZWFkJGUoX29iamVjdFNwcmVhZCRlKHt9LCBwcmV2KSwge30sIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBwcmV2LnRleHQgKyBub2RlLnRleHRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFUZXh0LmlzVGV4dChub2RlKSAmJiAhVGV4dC5pc1RleHQocHJldikpIHtcbiAgICAgICAgICAgICAgbmV3Tm9kZSA9IF9vYmplY3RTcHJlYWQkZShfb2JqZWN0U3ByZWFkJGUoe30sIHByZXYpLCB7fSwge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBwcmV2LmNoaWxkcmVuLmNvbmNhdChub2RlLmNoaWxkcmVuKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhcHBseSBhIFxcXCJtZXJnZV9ub2RlXFxcIiBvcGVyYXRpb24gYXQgcGF0aCBbXCIuY29uY2F0KF9wYXRoMiwgXCJdIHRvIG5vZGVzIG9mIGRpZmZlcmVudCBpbnRlcmZhY2VzOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShub2RlKSwgXCIgXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocHJldikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlQ2hpbGRyZW4oY2hpbGRyZW4sIHByZXZJbmRleCwgMiwgbmV3Tm9kZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdHJhbnNmb3JtU2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoOiBfcGF0aDMsXG4gICAgICAgICAgICBuZXdQYXRoXG4gICAgICAgICAgfSA9IG9wO1xuICAgICAgICAgIHZhciBfaW5kZXgyID0gX3BhdGgzW19wYXRoMy5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKF9wYXRoMywgbmV3UGF0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtb3ZlIGEgcGF0aCBbXCIuY29uY2F0KF9wYXRoMywgXCJdIHRvIG5ldyBwYXRoIFtcIikuY29uY2F0KG5ld1BhdGgsIFwiXSBiZWNhdXNlIHRoZSBkZXN0aW5hdGlvbiBpcyBpbnNpZGUgaXRzZWxmLlwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBfbm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgX3BhdGgzKTtcbiAgICAgICAgICBtb2RpZnlDaGlsZHJlbihlZGl0b3IsIFBhdGgucGFyZW50KF9wYXRoMyksIGNoaWxkcmVuID0+IHJlbW92ZUNoaWxkcmVuKGNoaWxkcmVuLCBfaW5kZXgyLCAxKSk7XG4gICAgICAgICAgLy8gVGhpcyBpcyB0cmlja3ksIGJ1dCBzaW5jZSB0aGUgYHBhdGhgIGFuZCBgbmV3UGF0aGAgYm90aCByZWZlciB0b1xuICAgICAgICAgIC8vIHRoZSBzYW1lIHNuYXBzaG90IGluIHRpbWUsIHRoZXJlJ3MgYSBtaXNtYXRjaC4gQWZ0ZXIgZWl0aGVyXG4gICAgICAgICAgLy8gcmVtb3ZpbmcgdGhlIG9yaWdpbmFsIHBvc2l0aW9uLCB0aGUgc2Vjb25kIHN0ZXAncyBwYXRoIGNhbiBiZSBvdXRcbiAgICAgICAgICAvLyBvZiBkYXRlLiBTbyBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBgb3AubmV3UGF0aGAgZGlyZWN0bHksIHdlXG4gICAgICAgICAgLy8gdHJhbnNmb3JtIGBvcC5wYXRoYCB0byBhc2NlcnRhaW4gd2hhdCB0aGUgYG5ld1BhdGhgIHdvdWxkIGJlIGFmdGVyXG4gICAgICAgICAgLy8gdGhlIG9wZXJhdGlvbiB3YXMgYXBwbGllZC5cbiAgICAgICAgICB2YXIgdHJ1ZVBhdGggPSBQYXRoLnRyYW5zZm9ybShfcGF0aDMsIG9wKTtcbiAgICAgICAgICB2YXIgbmV3SW5kZXggPSB0cnVlUGF0aFt0cnVlUGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICBtb2RpZnlDaGlsZHJlbihlZGl0b3IsIFBhdGgucGFyZW50KHRydWVQYXRoKSwgY2hpbGRyZW4gPT4gaW5zZXJ0Q2hpbGRyZW4oY2hpbGRyZW4sIG5ld0luZGV4LCBfbm9kZSkpO1xuICAgICAgICAgIHRyYW5zZm9ybVNlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoOiBfcGF0aDRcbiAgICAgICAgICB9ID0gb3A7XG4gICAgICAgICAgdmFyIF9pbmRleDMgPSBfcGF0aDRbX3BhdGg0Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgIG1vZGlmeUNoaWxkcmVuKGVkaXRvciwgUGF0aC5wYXJlbnQoX3BhdGg0KSwgY2hpbGRyZW4gPT4gcmVtb3ZlQ2hpbGRyZW4oY2hpbGRyZW4sIF9pbmRleDMsIDEpKTtcbiAgICAgICAgICAvLyBUcmFuc2Zvcm0gYWxsIHRoZSBwb2ludHMgaW4gdGhlIHZhbHVlLCBidXQgaWYgdGhlIHBvaW50IHdhcyBpbiB0aGVcbiAgICAgICAgICAvLyBub2RlIHRoYXQgd2FzIHJlbW92ZWQgd2UgbmVlZCB0byB1cGRhdGUgdGhlIHJhbmdlIG9yIHJlbW92ZSBpdC5cbiAgICAgICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IF9vYmplY3RTcHJlYWQkZSh7fSwgZWRpdG9yLnNlbGVjdGlvbik7XG4gICAgICAgICAgICBmb3IgKHZhciBbcG9pbnQsIGtleV0gb2YgUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFBvaW50LnRyYW5zZm9ybShwb2ludCwgb3ApO1xuICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uICE9IG51bGwgJiYgcmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25ba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBbbiwgcF0gb2YgTm9kZS50ZXh0cyhlZGl0b3IpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoUGF0aC5jb21wYXJlKHAsIF9wYXRoNCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXYgPSBbbiwgcF07XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gW24sIHBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHByZWZlck5leHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAocHJldiAmJiBuZXh0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoUGF0aC5pc1NpYmxpbmcocHJldlsxXSwgX3BhdGg0KSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVmZXJOZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguZXF1YWxzKG5leHRbMV0sIF9wYXRoNCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZmVyTmV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmVmZXJOZXh0ID0gUGF0aC5jb21tb24ocHJldlsxXSwgX3BhdGg0KS5sZW5ndGggPCBQYXRoLmNvbW1vbihuZXh0WzFdLCBfcGF0aDQpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgJiYgIXByZWZlck5leHQpIHtcbiAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbltrZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBwYXRoOiBwcmV2WzFdLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHByZXZbMF0udGV4dC5sZW5ndGhcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgICAgICBzZWxlY3Rpb25ba2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogbmV4dFsxXSxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb24gfHwgIVJhbmdlLmVxdWFscyhzZWxlY3Rpb24sIGVkaXRvci5zZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcGF0aDogX3BhdGg1LFxuICAgICAgICAgICAgb2Zmc2V0OiBfb2Zmc2V0LFxuICAgICAgICAgICAgdGV4dDogX3RleHRcbiAgICAgICAgICB9ID0gb3A7XG4gICAgICAgICAgaWYgKF90ZXh0Lmxlbmd0aCA9PT0gMCkgYnJlYWs7XG4gICAgICAgICAgbW9kaWZ5TGVhZihlZGl0b3IsIF9wYXRoNSwgbm9kZSA9PiB7XG4gICAgICAgICAgICB2YXIgYmVmb3JlID0gbm9kZS50ZXh0LnNsaWNlKDAsIF9vZmZzZXQpO1xuICAgICAgICAgICAgdmFyIGFmdGVyID0gbm9kZS50ZXh0LnNsaWNlKF9vZmZzZXQgKyBfdGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkZShfb2JqZWN0U3ByZWFkJGUoe30sIG5vZGUpLCB7fSwge1xuICAgICAgICAgICAgICB0ZXh0OiBiZWZvcmUgKyBhZnRlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdHJhbnNmb3JtU2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IF9wYXRoNixcbiAgICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgICBuZXdQcm9wZXJ0aWVzXG4gICAgICAgICAgfSA9IG9wO1xuICAgICAgICAgIGlmIChfcGF0aDYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHByb3BlcnRpZXMgb24gdGhlIHJvb3Qgbm9kZSFcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1vZGlmeURlc2NlbmRhbnQoZWRpdG9yLCBfcGF0aDYsIG5vZGUgPT4ge1xuICAgICAgICAgICAgdmFyIG5ld05vZGUgPSBfb2JqZWN0U3ByZWFkJGUoe30sIG5vZGUpO1xuICAgICAgICAgICAgZm9yICh2YXIgX2tleTMgaW4gbmV3UHJvcGVydGllcykge1xuICAgICAgICAgICAgICBpZiAoX2tleTMgPT09ICdjaGlsZHJlbicgfHwgX2tleTMgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgdGhlIFxcXCJcIi5jb25jYXQoX2tleTMsIFwiXFxcIiBwcm9wZXJ0eSBvZiBub2RlcyFcIikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG5ld1Byb3BlcnRpZXNbX2tleTNdO1xuICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuZXdOb2RlW19rZXkzXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdOb2RlW19rZXkzXSA9IHZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwcm9wZXJ0aWVzIHRoYXQgd2VyZSBwcmV2aW91c2x5IGRlZmluZWQsIGJ1dCBhcmUgbm93IG1pc3NpbmcsIG11c3QgYmUgZGVsZXRlZFxuICAgICAgICAgICAgZm9yICh2YXIgX2tleTQgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgICBpZiAoIW5ld1Byb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoX2tleTQpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5ld05vZGVbX2tleTRdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgbmV3UHJvcGVydGllczogX25ld1Byb3BlcnRpZXNcbiAgICAgICAgICB9ID0gb3A7XG4gICAgICAgICAgaWYgKF9uZXdQcm9wZXJ0aWVzID09IG51bGwpIHtcbiAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghUmFuZ2UuaXNSYW5nZShfbmV3UHJvcGVydGllcykpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IGFuIGluY29tcGxldGUgXFxcInNldF9zZWxlY3Rpb25cXFwiIG9wZXJhdGlvbiBwcm9wZXJ0aWVzIFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkoX25ld1Byb3BlcnRpZXMpLCBcIiB3aGVuIHRoZXJlIGlzIG5vIGN1cnJlbnQgc2VsZWN0aW9uLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uID0gX29iamVjdFNwcmVhZCRlKHt9LCBfbmV3UHJvcGVydGllcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIF9zZWxlY3Rpb24gPSBfb2JqZWN0U3ByZWFkJGUoe30sIGVkaXRvci5zZWxlY3Rpb24pO1xuICAgICAgICAgIGZvciAodmFyIF9rZXk1IGluIF9uZXdQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfbmV3UHJvcGVydGllc1tfa2V5NV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoX2tleTUgPT09ICdhbmNob3InIHx8IF9rZXk1ID09PSAnZm9jdXMnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlbW92ZSB0aGUgXFxcIlwiLmNvbmNhdChfa2V5NSwgXCJcXFwiIHNlbGVjdGlvbiBwcm9wZXJ0eVwiKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVsZXRlIF9zZWxlY3Rpb25bX2tleTVdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3NlbGVjdGlvbltfa2V5NV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbiA9IF9zZWxlY3Rpb247XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IF9wYXRoNyxcbiAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgcHJvcGVydGllczogX3Byb3BlcnRpZXNcbiAgICAgICAgICB9ID0gb3A7XG4gICAgICAgICAgdmFyIF9pbmRleDQgPSBfcGF0aDdbX3BhdGg3Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChfcGF0aDcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXBwbHkgYSBcXFwic3BsaXRfbm9kZVxcXCIgb3BlcmF0aW9uIGF0IHBhdGggW1wiLmNvbmNhdChfcGF0aDcsIFwiXSBiZWNhdXNlIHRoZSByb290IG5vZGUgY2Fubm90IGJlIHNwbGl0LlwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1vZGlmeUNoaWxkcmVuKGVkaXRvciwgUGF0aC5wYXJlbnQoX3BhdGg3KSwgY2hpbGRyZW4gPT4ge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBjaGlsZHJlbltfaW5kZXg0XTtcbiAgICAgICAgICAgIHZhciBuZXdOb2RlO1xuICAgICAgICAgICAgdmFyIG5leHROb2RlO1xuICAgICAgICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgICAgICAgIHZhciBiZWZvcmUgPSBub2RlLnRleHQuc2xpY2UoMCwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICB2YXIgYWZ0ZXIgPSBub2RlLnRleHQuc2xpY2UocG9zaXRpb24pO1xuICAgICAgICAgICAgICBuZXdOb2RlID0gX29iamVjdFNwcmVhZCRlKF9vYmplY3RTcHJlYWQkZSh7fSwgbm9kZSksIHt9LCB7XG4gICAgICAgICAgICAgICAgdGV4dDogYmVmb3JlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBuZXh0Tm9kZSA9IF9vYmplY3RTcHJlYWQkZShfb2JqZWN0U3ByZWFkJGUoe30sIF9wcm9wZXJ0aWVzKSwge30sIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBhZnRlclxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBfYmVmb3JlID0gbm9kZS5jaGlsZHJlbi5zbGljZSgwLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgIHZhciBfYWZ0ZXIgPSBub2RlLmNoaWxkcmVuLnNsaWNlKHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgbmV3Tm9kZSA9IF9vYmplY3RTcHJlYWQkZShfb2JqZWN0U3ByZWFkJGUoe30sIG5vZGUpLCB7fSwge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBfYmVmb3JlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBuZXh0Tm9kZSA9IF9vYmplY3RTcHJlYWQkZShfb2JqZWN0U3ByZWFkJGUoe30sIF9wcm9wZXJ0aWVzKSwge30sIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogX2FmdGVyXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VDaGlsZHJlbihjaGlsZHJlbiwgX2luZGV4NCwgMSwgbmV3Tm9kZSwgbmV4dE5vZGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRyYW5zZm9ybVNlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRyYW5zZm9ybVNlbGVjdGlvbiAmJiBlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICB2YXIgX3NlbGVjdGlvbjIgPSBfb2JqZWN0U3ByZWFkJGUoe30sIGVkaXRvci5zZWxlY3Rpb24pO1xuICAgICAgZm9yICh2YXIgW19wb2ludCwgX2tleTZdIG9mIFJhbmdlLnBvaW50cyhfc2VsZWN0aW9uMikpIHtcbiAgICAgICAgX3NlbGVjdGlvbjJbX2tleTZdID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludCwgb3ApO1xuICAgICAgfVxuICAgICAgaWYgKCFSYW5nZS5lcXVhbHMoX3NlbGVjdGlvbjIsIGVkaXRvci5zZWxlY3Rpb24pKSB7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24gPSBfc2VsZWN0aW9uMjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBOb2RlVHJhbnNmb3JtcyA9IHtcbiAgaW5zZXJ0Tm9kZXMoZWRpdG9yLCBub2Rlcywgb3B0aW9ucykge1xuICAgIGVkaXRvci5pbnNlcnROb2Rlcyhub2Rlcywgb3B0aW9ucyk7XG4gIH0sXG4gIGxpZnROb2RlcyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IubGlmdE5vZGVzKG9wdGlvbnMpO1xuICB9LFxuICBtZXJnZU5vZGVzKGVkaXRvciwgb3B0aW9ucykge1xuICAgIGVkaXRvci5tZXJnZU5vZGVzKG9wdGlvbnMpO1xuICB9LFxuICBtb3ZlTm9kZXMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLm1vdmVOb2RlcyhvcHRpb25zKTtcbiAgfSxcbiAgcmVtb3ZlTm9kZXMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLnJlbW92ZU5vZGVzKG9wdGlvbnMpO1xuICB9LFxuICBzZXROb2RlcyhlZGl0b3IsIHByb3BzLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLnNldE5vZGVzKHByb3BzLCBvcHRpb25zKTtcbiAgfSxcbiAgc3BsaXROb2RlcyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3Iuc3BsaXROb2RlcyhvcHRpb25zKTtcbiAgfSxcbiAgdW5zZXROb2RlcyhlZGl0b3IsIHByb3BzLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLnVuc2V0Tm9kZXMocHJvcHMsIG9wdGlvbnMpO1xuICB9LFxuICB1bndyYXBOb2RlcyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IudW53cmFwTm9kZXMob3B0aW9ucyk7XG4gIH0sXG4gIHdyYXBOb2RlcyhlZGl0b3IsIGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3Iud3JhcE5vZGVzKGVsZW1lbnQsIG9wdGlvbnMpO1xuICB9XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgU2VsZWN0aW9uVHJhbnNmb3JtcyA9IHtcbiAgY29sbGFwc2UoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLmNvbGxhcHNlKG9wdGlvbnMpO1xuICB9LFxuICBkZXNlbGVjdChlZGl0b3IpIHtcbiAgICBlZGl0b3IuZGVzZWxlY3QoKTtcbiAgfSxcbiAgbW92ZShlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IubW92ZShvcHRpb25zKTtcbiAgfSxcbiAgc2VsZWN0KGVkaXRvciwgdGFyZ2V0KSB7XG4gICAgZWRpdG9yLnNlbGVjdCh0YXJnZXQpO1xuICB9LFxuICBzZXRQb2ludChlZGl0b3IsIHByb3BzLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLnNldFBvaW50KHByb3BzLCBvcHRpb25zKTtcbiAgfSxcbiAgc2V0U2VsZWN0aW9uKGVkaXRvciwgcHJvcHMpIHtcbiAgICBlZGl0b3Iuc2V0U2VsZWN0aW9uKHByb3BzKTtcbiAgfVxufTtcblxudmFyIGlzT2JqZWN0ID0gdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbDtcblxuLypcbiAgQ3VzdG9tIGRlZXAgZXF1YWwgY29tcGFyaXNvbiBmb3IgU2xhdGUgbm9kZXMuXG5cbiAgV2UgZG9uJ3QgbmVlZCBnZW5lcmFsIHB1cnBvc2UgZGVlcCBlcXVhbGl0eTtcbiAgU2xhdGUgb25seSBzdXBwb3J0cyBwbGFpbiB2YWx1ZXMsIEFycmF5cywgYW5kIG5lc3RlZCBvYmplY3RzLlxuICBDb21wbGV4IHZhbHVlcyBuZXN0ZWQgaW5zaWRlIEFycmF5cyBhcmUgbm90IHN1cHBvcnRlZC5cblxuICBTbGF0ZSBvYmplY3RzIGFyZSBkZXNpZ25lZCB0byBiZSBzZXJpYWxpc2VkLCBzb1xuICBtaXNzaW5nIGtleXMgYXJlIGRlbGliZXJhdGVseSBub3JtYWxpc2VkIHRvIHVuZGVmaW5lZC5cbiAqL1xudmFyIGlzRGVlcEVxdWFsID0gKG5vZGUsIGFub3RoZXIpID0+IHtcbiAgZm9yICh2YXIga2V5IGluIG5vZGUpIHtcbiAgICB2YXIgYSA9IG5vZGVba2V5XTtcbiAgICB2YXIgYiA9IGFub3RoZXJba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSAmJiBBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGEpICYmIGlzT2JqZWN0KGIpKSB7XG4gICAgICBpZiAoIWlzRGVlcEVxdWFsKGEsIGIpKSByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChhICE9PSBiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qXG4gICAgRGVlcCBvYmplY3QgZXF1YWxpdHkgaXMgb25seSBuZWNlc3NhcnkgaW4gb25lIGRpcmVjdGlvbjsgaW4gdGhlIHJldmVyc2UgZGlyZWN0aW9uXG4gICAgd2UgYXJlIG9ubHkgbG9va2luZyBmb3Iga2V5cyB0aGF0IGFyZSBtaXNzaW5nLlxuICAgIEFzIGFib3ZlLCB1bmRlZmluZWQga2V5cyBhcmUgbm9ybWFsaXNlZCB0byBtaXNzaW5nLlxuICAqL1xuICBmb3IgKHZhciBfa2V5IGluIGFub3RoZXIpIHtcbiAgICBpZiAobm9kZVtfa2V5XSA9PT0gdW5kZWZpbmVkICYmIGFub3RoZXJbX2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gIHZhciBrZXksIGk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBfZXhjbHVkZWQkNCA9IFtcImFuY2hvclwiLCBcImZvY3VzXCJdO1xuZnVuY3Rpb24gb3duS2V5cyRkKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJGQoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJGQoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBSYW5nZSA9IHtcbiAgZWRnZXMocmFuZ2UpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSByYW5nZTtcbiAgICByZXR1cm4gUmFuZ2UuaXNCYWNrd2FyZChyYW5nZSkgPT09IHJldmVyc2UgPyBbYW5jaG9yLCBmb2N1c10gOiBbZm9jdXMsIGFuY2hvcl07XG4gIH0sXG4gIGVuZChyYW5nZSkge1xuICAgIHZhciBbLCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgIHJldHVybiBlbmQ7XG4gIH0sXG4gIGVxdWFscyhyYW5nZSwgYW5vdGhlcikge1xuICAgIHJldHVybiBQb2ludC5lcXVhbHMocmFuZ2UuYW5jaG9yLCBhbm90aGVyLmFuY2hvcikgJiYgUG9pbnQuZXF1YWxzKHJhbmdlLmZvY3VzLCBhbm90aGVyLmZvY3VzKTtcbiAgfSxcbiAgc3Vycm91bmRzKHJhbmdlLCB0YXJnZXQpIHtcbiAgICB2YXIgaW50ZXJzZWN0aW9uUmFuZ2UgPSBSYW5nZS5pbnRlcnNlY3Rpb24ocmFuZ2UsIHRhcmdldCk7XG4gICAgaWYgKCFpbnRlcnNlY3Rpb25SYW5nZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gUmFuZ2UuZXF1YWxzKGludGVyc2VjdGlvblJhbmdlLCB0YXJnZXQpO1xuICB9LFxuICBpbmNsdWRlcyhyYW5nZSwgdGFyZ2V0KSB7XG4gICAgaWYgKFJhbmdlLmlzUmFuZ2UodGFyZ2V0KSkge1xuICAgICAgaWYgKFJhbmdlLmluY2x1ZGVzKHJhbmdlLCB0YXJnZXQuYW5jaG9yKSB8fCBSYW5nZS5pbmNsdWRlcyhyYW5nZSwgdGFyZ2V0LmZvY3VzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBbcnMsIHJlXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICAgIHZhciBbdHMsIHRlXSA9IFJhbmdlLmVkZ2VzKHRhcmdldCk7XG4gICAgICByZXR1cm4gUG9pbnQuaXNCZWZvcmUocnMsIHRzKSAmJiBQb2ludC5pc0FmdGVyKHJlLCB0ZSk7XG4gICAgfVxuICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgdmFyIGlzQWZ0ZXJTdGFydCA9IGZhbHNlO1xuICAgIHZhciBpc0JlZm9yZUVuZCA9IGZhbHNlO1xuICAgIGlmIChQb2ludC5pc1BvaW50KHRhcmdldCkpIHtcbiAgICAgIGlzQWZ0ZXJTdGFydCA9IFBvaW50LmNvbXBhcmUodGFyZ2V0LCBzdGFydCkgPj0gMDtcbiAgICAgIGlzQmVmb3JlRW5kID0gUG9pbnQuY29tcGFyZSh0YXJnZXQsIGVuZCkgPD0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNBZnRlclN0YXJ0ID0gUGF0aC5jb21wYXJlKHRhcmdldCwgc3RhcnQucGF0aCkgPj0gMDtcbiAgICAgIGlzQmVmb3JlRW5kID0gUGF0aC5jb21wYXJlKHRhcmdldCwgZW5kLnBhdGgpIDw9IDA7XG4gICAgfVxuICAgIHJldHVybiBpc0FmdGVyU3RhcnQgJiYgaXNCZWZvcmVFbmQ7XG4gIH0sXG4gIGludGVyc2VjdGlvbihyYW5nZSwgYW5vdGhlcikge1xuICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHJhbmdlLCBfZXhjbHVkZWQkNCk7XG4gICAgdmFyIFtzMSwgZTFdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgIHZhciBbczIsIGUyXSA9IFJhbmdlLmVkZ2VzKGFub3RoZXIpO1xuICAgIHZhciBzdGFydCA9IFBvaW50LmlzQmVmb3JlKHMxLCBzMikgPyBzMiA6IHMxO1xuICAgIHZhciBlbmQgPSBQb2ludC5pc0JlZm9yZShlMSwgZTIpID8gZTEgOiBlMjtcbiAgICBpZiAoUG9pbnQuaXNCZWZvcmUoZW5kLCBzdGFydCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRkKHtcbiAgICAgICAgYW5jaG9yOiBzdGFydCxcbiAgICAgICAgZm9jdXM6IGVuZFxuICAgICAgfSwgcmVzdCk7XG4gICAgfVxuICB9LFxuICBpc0JhY2t3YXJkKHJhbmdlKSB7XG4gICAgdmFyIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHJhbmdlO1xuICAgIHJldHVybiBQb2ludC5pc0FmdGVyKGFuY2hvciwgZm9jdXMpO1xuICB9LFxuICBpc0NvbGxhcHNlZChyYW5nZSkge1xuICAgIHZhciB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSByYW5nZTtcbiAgICByZXR1cm4gUG9pbnQuZXF1YWxzKGFuY2hvciwgZm9jdXMpO1xuICB9LFxuICBpc0V4cGFuZGVkKHJhbmdlKSB7XG4gICAgcmV0dXJuICFSYW5nZS5pc0NvbGxhcHNlZChyYW5nZSk7XG4gIH0sXG4gIGlzRm9yd2FyZChyYW5nZSkge1xuICAgIHJldHVybiAhUmFuZ2UuaXNCYWNrd2FyZChyYW5nZSk7XG4gIH0sXG4gIGlzUmFuZ2UodmFsdWUpIHtcbiAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIFBvaW50LmlzUG9pbnQodmFsdWUuYW5jaG9yKSAmJiBQb2ludC5pc1BvaW50KHZhbHVlLmZvY3VzKTtcbiAgfSxcbiAgKnBvaW50cyhyYW5nZSkge1xuICAgIHlpZWxkIFtyYW5nZS5hbmNob3IsICdhbmNob3InXTtcbiAgICB5aWVsZCBbcmFuZ2UuZm9jdXMsICdmb2N1cyddO1xuICB9LFxuICBzdGFydChyYW5nZSkge1xuICAgIHZhciBbc3RhcnRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgIHJldHVybiBzdGFydDtcbiAgfSxcbiAgdHJhbnNmb3JtKHJhbmdlLCBvcCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBpZiAocmFuZ2UgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIge1xuICAgICAgYWZmaW5pdHkgPSAnaW53YXJkJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBhZmZpbml0eUFuY2hvcjtcbiAgICB2YXIgYWZmaW5pdHlGb2N1cztcbiAgICBpZiAoYWZmaW5pdHkgPT09ICdpbndhcmQnKSB7XG4gICAgICAvLyBJZiB0aGUgcmFuZ2UgaXMgY29sbGFwc2VkLCBtYWtlIHN1cmUgdG8gdXNlIHRoZSBzYW1lIGFmZmluaXR5IHRvXG4gICAgICAvLyBhdm9pZCB0aGUgdHdvIHBvaW50cyBwYXNzaW5nIGVhY2ggb3RoZXIgYW5kIGV4cGFuZGluZyBpbiB0aGUgb3Bwb3NpdGVcbiAgICAgIC8vIGRpcmVjdGlvblxuICAgICAgdmFyIGlzQ29sbGFwc2VkID0gUmFuZ2UuaXNDb2xsYXBzZWQocmFuZ2UpO1xuICAgICAgaWYgKFJhbmdlLmlzRm9yd2FyZChyYW5nZSkpIHtcbiAgICAgICAgYWZmaW5pdHlBbmNob3IgPSAnZm9yd2FyZCc7XG4gICAgICAgIGFmZmluaXR5Rm9jdXMgPSBpc0NvbGxhcHNlZCA/IGFmZmluaXR5QW5jaG9yIDogJ2JhY2t3YXJkJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFmZmluaXR5QW5jaG9yID0gJ2JhY2t3YXJkJztcbiAgICAgICAgYWZmaW5pdHlGb2N1cyA9IGlzQ29sbGFwc2VkID8gYWZmaW5pdHlBbmNob3IgOiAnZm9yd2FyZCc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhZmZpbml0eSA9PT0gJ291dHdhcmQnKSB7XG4gICAgICBpZiAoUmFuZ2UuaXNGb3J3YXJkKHJhbmdlKSkge1xuICAgICAgICBhZmZpbml0eUFuY2hvciA9ICdiYWNrd2FyZCc7XG4gICAgICAgIGFmZmluaXR5Rm9jdXMgPSAnZm9yd2FyZCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZmZpbml0eUFuY2hvciA9ICdmb3J3YXJkJztcbiAgICAgICAgYWZmaW5pdHlGb2N1cyA9ICdiYWNrd2FyZCc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmZmluaXR5QW5jaG9yID0gYWZmaW5pdHk7XG4gICAgICBhZmZpbml0eUZvY3VzID0gYWZmaW5pdHk7XG4gICAgfVxuICAgIHZhciBhbmNob3IgPSBQb2ludC50cmFuc2Zvcm0ocmFuZ2UuYW5jaG9yLCBvcCwge1xuICAgICAgYWZmaW5pdHk6IGFmZmluaXR5QW5jaG9yXG4gICAgfSk7XG4gICAgdmFyIGZvY3VzID0gUG9pbnQudHJhbnNmb3JtKHJhbmdlLmZvY3VzLCBvcCwge1xuICAgICAgYWZmaW5pdHk6IGFmZmluaXR5Rm9jdXNcbiAgICB9KTtcbiAgICBpZiAoIWFuY2hvciB8fCAhZm9jdXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXNcbiAgICB9O1xuICB9XG59O1xuXG4vKipcbiAqIFNoYXJlZCB0aGUgZnVuY3Rpb24gd2l0aCBpc0VsZW1lbnRUeXBlIHV0aWxpdHlcbiAqL1xudmFyIGlzRWxlbWVudCA9IGZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICB2YXIge1xuICAgIGRlZXAgPSBmYWxzZVxuICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHJldHVybiBmYWxzZTtcbiAgLy8gUEVSRjogTm8gbmVlZCB0byB1c2UgdGhlIGZ1bGwgRWRpdG9yLmlzRWRpdG9yIGhlcmVcbiAgdmFyIGlzRWRpdG9yID0gdHlwZW9mIHZhbHVlLmFwcGx5ID09PSAnZnVuY3Rpb24nO1xuICBpZiAoaXNFZGl0b3IpIHJldHVybiBmYWxzZTtcbiAgdmFyIGlzQ2hpbGRyZW5WYWxpZCA9IGRlZXAgPyBOb2RlLmlzTm9kZUxpc3QodmFsdWUuY2hpbGRyZW4pIDogQXJyYXkuaXNBcnJheSh2YWx1ZS5jaGlsZHJlbik7XG4gIHJldHVybiBpc0NoaWxkcmVuVmFsaWQ7XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIEVsZW1lbnQgPSB7XG4gIGlzQW5jZXN0b3IodmFsdWUpIHtcbiAgICB2YXIge1xuICAgICAgZGVlcCA9IGZhbHNlXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBOb2RlLmlzTm9kZUxpc3QodmFsdWUuY2hpbGRyZW4sIHtcbiAgICAgIGRlZXBcbiAgICB9KTtcbiAgfSxcbiAgaXNFbGVtZW50LFxuICBpc0VsZW1lbnRMaXN0KHZhbHVlKSB7XG4gICAgdmFyIHtcbiAgICAgIGRlZXAgPSBmYWxzZVxuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeSh2YWwgPT4gRWxlbWVudC5pc0VsZW1lbnQodmFsLCB7XG4gICAgICBkZWVwXG4gICAgfSkpO1xuICB9LFxuICBpc0VsZW1lbnRQcm9wcyhwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy5jaGlsZHJlbiAhPT0gdW5kZWZpbmVkO1xuICB9LFxuICBpc0VsZW1lbnRUeXBlOiBmdW5jdGlvbiBpc0VsZW1lbnRUeXBlKHZhbHVlLCBlbGVtZW50VmFsKSB7XG4gICAgdmFyIGVsZW1lbnRLZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICd0eXBlJztcbiAgICByZXR1cm4gaXNFbGVtZW50KHZhbHVlKSAmJiB2YWx1ZVtlbGVtZW50S2V5XSA9PT0gZWxlbWVudFZhbDtcbiAgfSxcbiAgbWF0Y2hlcyhlbGVtZW50LCBwcm9wcykge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKGtleSA9PT0gJ2NoaWxkcmVuJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50W2tleV0gIT09IHByb3BzW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxudmFyIF9leGNsdWRlZCQzID0gW1wiY2hpbGRyZW5cIl0sXG4gIF9leGNsdWRlZDIkMyA9IFtcInRleHRcIl07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgTm9kZSA9IHtcbiAgYW5jZXN0b3Iocm9vdCwgcGF0aCkge1xuICAgIHZhciBub2RlID0gTm9kZS5nZXQocm9vdCwgcGF0aCk7XG4gICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBhbmNlc3RvciBub2RlIGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCByZWZlcnMgdG8gYSB0ZXh0IG5vZGUgaW5zdGVhZDogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG4gIGFuY2VzdG9ycyhyb290LCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yICh2YXIgcCBvZiBQYXRoLmFuY2VzdG9ycyhwYXRoLCBvcHRpb25zKSkge1xuICAgICAgICB2YXIgbiA9IE5vZGUuYW5jZXN0b3Iocm9vdCwgcCk7XG4gICAgICAgIHZhciBlbnRyeSA9IFtuLCBwXTtcbiAgICAgICAgeWllbGQgZW50cnk7XG4gICAgICB9XG4gICAgfSgpO1xuICB9LFxuICBjaGlsZChyb290LCBpbmRleCkge1xuICAgIGlmIChUZXh0LmlzVGV4dChyb290KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgY2hpbGQgb2YgYSB0ZXh0IG5vZGU6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICB9XG4gICAgdmFyIGMgPSByb290LmNoaWxkcmVuW2luZGV4XTtcbiAgICBpZiAoYyA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IGNoaWxkIGF0IGluZGV4IGBcIi5jb25jYXQoaW5kZXgsIFwiYCBpbiBub2RlOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShyb290KSkpO1xuICAgIH1cbiAgICByZXR1cm4gYztcbiAgfSxcbiAgY2hpbGRyZW4ocm9vdCwgcGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciB7XG4gICAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBOb2RlLmFuY2VzdG9yKHJvb3QsIHBhdGgpO1xuICAgICAgdmFyIHtcbiAgICAgICAgY2hpbGRyZW5cbiAgICAgIH0gPSBhbmNlc3RvcjtcbiAgICAgIHZhciBpbmRleCA9IHJldmVyc2UgPyBjaGlsZHJlbi5sZW5ndGggLSAxIDogMDtcbiAgICAgIHdoaWxlIChyZXZlcnNlID8gaW5kZXggPj0gMCA6IGluZGV4IDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IE5vZGUuY2hpbGQoYW5jZXN0b3IsIGluZGV4KTtcbiAgICAgICAgdmFyIGNoaWxkUGF0aCA9IHBhdGguY29uY2F0KGluZGV4KTtcbiAgICAgICAgeWllbGQgW2NoaWxkLCBjaGlsZFBhdGhdO1xuICAgICAgICBpbmRleCA9IHJldmVyc2UgPyBpbmRleCAtIDEgOiBpbmRleCArIDE7XG4gICAgICB9XG4gICAgfSgpO1xuICB9LFxuICBjb21tb24ocm9vdCwgcGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBwID0gUGF0aC5jb21tb24ocGF0aCwgYW5vdGhlcik7XG4gICAgdmFyIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICByZXR1cm4gW24sIHBdO1xuICB9LFxuICBkZXNjZW5kYW50KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KHJvb3QsIHBhdGgpO1xuICAgIGlmIChFZGl0b3IuaXNFZGl0b3Iobm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIGRlc2NlbmRhbnQgbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgcmVmZXJzIHRvIHRoZSByb290IGVkaXRvciBub2RlIGluc3RlYWQ6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9LFxuICBkZXNjZW5kYW50cyhyb290KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIE5vZGUubm9kZXMocm9vdCwgb3B0aW9ucykpIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgLy8gTk9URTogd2UgaGF2ZSB0byBjb2VyY2UgaGVyZSBiZWNhdXNlIGNoZWNraW5nIHRoZSBwYXRoJ3MgbGVuZ3RoIGRvZXNcbiAgICAgICAgICAvLyBndWFyYW50ZWUgdGhhdCBgbm9kZWAgaXMgbm90IGEgYEVkaXRvcmAsIGJ1dCBUeXBlU2NyaXB0IGRvZXNuJ3Qga25vdy5cbiAgICAgICAgICB5aWVsZCBbbm9kZSwgcGF0aF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KCk7XG4gIH0sXG4gIGVsZW1lbnRzKHJvb3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgTm9kZS5ub2Rlcyhyb290LCBvcHRpb25zKSkge1xuICAgICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgICB5aWVsZCBbbm9kZSwgcGF0aF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KCk7XG4gIH0sXG4gIGV4dHJhY3RQcm9wcyhub2RlKSB7XG4gICAgaWYgKEVsZW1lbnQuaXNBbmNlc3Rvcihub2RlKSkge1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkJDMpO1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5vZGUsIF9leGNsdWRlZDIkMyk7XG4gICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICB9XG4gIH0sXG4gIGZpcnN0KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgcCA9IHBhdGguc2xpY2UoKTtcbiAgICB2YXIgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAoVGV4dC5pc1RleHQobikgfHwgbi5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gbi5jaGlsZHJlblswXTtcbiAgICAgICAgcC5wdXNoKDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW24sIHBdO1xuICB9LFxuICBmcmFnbWVudChyb290LCByYW5nZSkge1xuICAgIHZhciBuZXdSb290ID0gcHJvZHVjZSh7XG4gICAgICBjaGlsZHJlbjogcm9vdC5jaGlsZHJlblxuICAgIH0sIHIgPT4ge1xuICAgICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICAgIHZhciBub2RlRW50cmllcyA9IE5vZGUubm9kZXMociwge1xuICAgICAgICByZXZlcnNlOiB0cnVlLFxuICAgICAgICBwYXNzOiBfcmVmID0+IHtcbiAgICAgICAgICB2YXIgWywgcGF0aF0gPSBfcmVmO1xuICAgICAgICAgIHJldHVybiAhUmFuZ2UuaW5jbHVkZXMocmFuZ2UsIHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGZvciAodmFyIFssIHBhdGhdIG9mIG5vZGVFbnRyaWVzKSB7XG4gICAgICAgIGlmICghUmFuZ2UuaW5jbHVkZXMocmFuZ2UsIHBhdGgpKSB7XG4gICAgICAgICAgdmFyIHBhcmVudCA9IE5vZGUucGFyZW50KHIsIHBhdGgpO1xuICAgICAgICAgIHZhciBpbmRleCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgZW5kLnBhdGgpKSB7XG4gICAgICAgICAgdmFyIGxlYWYgPSBOb2RlLmxlYWYociwgcGF0aCk7XG4gICAgICAgICAgbGVhZi50ZXh0ID0gbGVhZi50ZXh0LnNsaWNlKDAsIGVuZC5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChQYXRoLmVxdWFscyhwYXRoLCBzdGFydC5wYXRoKSkge1xuICAgICAgICAgIHZhciBfbGVhZiA9IE5vZGUubGVhZihyLCBwYXRoKTtcbiAgICAgICAgICBfbGVhZi50ZXh0ID0gX2xlYWYudGV4dC5zbGljZShzdGFydC5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoRWRpdG9yLmlzRWRpdG9yKHIpKSB7XG4gICAgICAgIHIuc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3Um9vdC5jaGlsZHJlbjtcbiAgfSxcbiAgZ2V0KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0SWYocm9vdCwgcGF0aCk7XG4gICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgYSBkZXNjZW5kYW50IGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gaW4gbm9kZTogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG4gIGdldElmKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IHJvb3Q7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHBhdGhbaV07XG4gICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkgfHwgIW5vZGUuY2hpbGRyZW5bcF0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bcF07XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9LFxuICBoYXMocm9vdCwgcGF0aCkge1xuICAgIHZhciBub2RlID0gcm9vdDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gcGF0aFtpXTtcbiAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSB8fCAhbm9kZS5jaGlsZHJlbltwXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5jaGlsZHJlbltwXTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGlzTm9kZSh2YWx1ZSkge1xuICAgIHZhciB7XG4gICAgICBkZWVwID0gZmFsc2VcbiAgICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICByZXR1cm4gVGV4dC5pc1RleHQodmFsdWUpIHx8IEVsZW1lbnQuaXNFbGVtZW50KHZhbHVlLCB7XG4gICAgICBkZWVwXG4gICAgfSkgfHwgRWRpdG9yLmlzRWRpdG9yKHZhbHVlLCB7XG4gICAgICBkZWVwXG4gICAgfSk7XG4gIH0sXG4gIGlzTm9kZUxpc3QodmFsdWUpIHtcbiAgICB2YXIge1xuICAgICAgZGVlcCA9IGZhbHNlXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KHZhbCA9PiBOb2RlLmlzTm9kZSh2YWwsIHtcbiAgICAgIGRlZXBcbiAgICB9KSk7XG4gIH0sXG4gIGxhc3Qocm9vdCwgcGF0aCkge1xuICAgIHZhciBwID0gcGF0aC5zbGljZSgpO1xuICAgIHZhciBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChUZXh0LmlzVGV4dChuKSB8fCBuLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpID0gbi5jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgICBuID0gbi5jaGlsZHJlbltpXTtcbiAgICAgICAgcC5wdXNoKGkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW24sIHBdO1xuICB9LFxuICBsZWFmKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KHJvb3QsIHBhdGgpO1xuICAgIGlmICghVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIGxlYWYgbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgcmVmZXJzIHRvIGEgbm9uLWxlYWYgbm9kZTogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG4gIGxldmVscyhyb290LCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yICh2YXIgcCBvZiBQYXRoLmxldmVscyhwYXRoLCBvcHRpb25zKSkge1xuICAgICAgICB2YXIgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICB5aWVsZCBbbiwgcF07XG4gICAgICB9XG4gICAgfSgpO1xuICB9LFxuICBtYXRjaGVzKG5vZGUsIHByb3BzKSB7XG4gICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIEVsZW1lbnQuaXNFbGVtZW50UHJvcHMocHJvcHMpICYmIEVsZW1lbnQubWF0Y2hlcyhub2RlLCBwcm9wcykgfHwgVGV4dC5pc1RleHQobm9kZSkgJiYgVGV4dC5pc1RleHRQcm9wcyhwcm9wcykgJiYgVGV4dC5tYXRjaGVzKG5vZGUsIHByb3BzKTtcbiAgfSxcbiAgbm9kZXMocm9vdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciB7XG4gICAgICAgIHBhc3MsXG4gICAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBmcm9tID0gW10sXG4gICAgICAgIHRvXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgICAgdmFyIHAgPSBbXTtcbiAgICAgIHZhciBuID0gcm9vdDtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmICh0byAmJiAocmV2ZXJzZSA/IFBhdGguaXNCZWZvcmUocCwgdG8pIDogUGF0aC5pc0FmdGVyKHAsIHRvKSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKG4pKSB7XG4gICAgICAgICAgeWllbGQgW24sIHBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlJ3JlIGFsbG93ZWQgdG8gZ28gZG93bndhcmQgYW5kIHdlIGhhdmVuJ3QgZGVzY2VuZGVkIHlldCwgZG8uXG4gICAgICAgIGlmICghdmlzaXRlZC5oYXMobikgJiYgIVRleHQuaXNUZXh0KG4pICYmIG4uY2hpbGRyZW4ubGVuZ3RoICE9PSAwICYmIChwYXNzID09IG51bGwgfHwgcGFzcyhbbiwgcF0pID09PSBmYWxzZSkpIHtcbiAgICAgICAgICB2aXNpdGVkLmFkZChuKTtcbiAgICAgICAgICB2YXIgbmV4dEluZGV4ID0gcmV2ZXJzZSA/IG4uY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDA7XG4gICAgICAgICAgaWYgKFBhdGguaXNBbmNlc3RvcihwLCBmcm9tKSkge1xuICAgICAgICAgICAgbmV4dEluZGV4ID0gZnJvbVtwLmxlbmd0aF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHAgPSBwLmNvbmNhdChuZXh0SW5kZXgpO1xuICAgICAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSdyZSBhdCB0aGUgcm9vdCBhbmQgd2UgY2FuJ3QgZ28gZG93biwgd2UncmUgZG9uZS5cbiAgICAgICAgaWYgKHAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UncmUgZ29pbmcgZm9yd2FyZC4uLlxuICAgICAgICBpZiAoIXJldmVyc2UpIHtcbiAgICAgICAgICB2YXIgbmV3UGF0aCA9IFBhdGgubmV4dChwKTtcbiAgICAgICAgICBpZiAoTm9kZS5oYXMocm9vdCwgbmV3UGF0aCkpIHtcbiAgICAgICAgICAgIHAgPSBuZXdQYXRoO1xuICAgICAgICAgICAgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlJ3JlIGdvaW5nIGJhY2t3YXJkLi4uXG4gICAgICAgIGlmIChyZXZlcnNlICYmIHBbcC5sZW5ndGggLSAxXSAhPT0gMCkge1xuICAgICAgICAgIHZhciBfbmV3UGF0aCA9IFBhdGgucHJldmlvdXMocCk7XG4gICAgICAgICAgcCA9IF9uZXdQYXRoO1xuICAgICAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2Ugd2UncmUgZ29pbmcgdXB3YXJkLi4uXG4gICAgICAgIHAgPSBQYXRoLnBhcmVudChwKTtcbiAgICAgICAgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICB2aXNpdGVkLmFkZChuKTtcbiAgICAgIH1cbiAgICB9KCk7XG4gIH0sXG4gIHBhcmVudChyb290LCBwYXRoKSB7XG4gICAgdmFyIHBhcmVudFBhdGggPSBQYXRoLnBhcmVudChwYXRoKTtcbiAgICB2YXIgcCA9IE5vZGUuZ2V0KHJvb3QsIHBhcmVudFBhdGgpO1xuICAgIGlmIChUZXh0LmlzVGV4dChwKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcGFyZW50IG9mIHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgcm9vdC5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSxcbiAgc3RyaW5nKG5vZGUpIHtcbiAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlLnRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLm1hcChOb2RlLnN0cmluZykuam9pbignJyk7XG4gICAgfVxuICB9LFxuICB0ZXh0cyhyb290KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIE5vZGUubm9kZXMocm9vdCwgb3B0aW9ucykpIHtcbiAgICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgICAgeWllbGQgW25vZGUsIHBhdGhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJGMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCRjKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkYyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkYyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIE9wZXJhdGlvbiA9IHtcbiAgaXNOb2RlT3BlcmF0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIE9wZXJhdGlvbi5pc09wZXJhdGlvbih2YWx1ZSkgJiYgdmFsdWUudHlwZS5lbmRzV2l0aCgnX25vZGUnKTtcbiAgfSxcbiAgaXNPcGVyYXRpb24odmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIE5vZGUuaXNOb2RlKHZhbHVlLm5vZGUpO1xuICAgICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlLm9mZnNldCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbHVlLnRleHQgPT09ICdzdHJpbmcnICYmIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpO1xuICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUucG9zaXRpb24gPT09ICdudW1iZXInICYmIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIGlzT2JqZWN0KHZhbHVlLnByb3BlcnRpZXMpO1xuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIFBhdGguaXNQYXRoKHZhbHVlLm5ld1BhdGgpO1xuICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgTm9kZS5pc05vZGUodmFsdWUubm9kZSk7XG4gICAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZycgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCk7XG4gICAgICBjYXNlICdzZXRfbm9kZSc6XG4gICAgICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiBpc09iamVjdCh2YWx1ZS5wcm9wZXJ0aWVzKSAmJiBpc09iamVjdCh2YWx1ZS5uZXdQcm9wZXJ0aWVzKTtcbiAgICAgIGNhc2UgJ3NldF9zZWxlY3Rpb24nOlxuICAgICAgICByZXR1cm4gdmFsdWUucHJvcGVydGllcyA9PT0gbnVsbCAmJiBSYW5nZS5pc1JhbmdlKHZhbHVlLm5ld1Byb3BlcnRpZXMpIHx8IHZhbHVlLm5ld1Byb3BlcnRpZXMgPT09IG51bGwgJiYgUmFuZ2UuaXNSYW5nZSh2YWx1ZS5wcm9wZXJ0aWVzKSB8fCBpc09iamVjdCh2YWx1ZS5wcm9wZXJ0aWVzKSAmJiBpc09iamVjdCh2YWx1ZS5uZXdQcm9wZXJ0aWVzKTtcbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgdHlwZW9mIHZhbHVlLnBvc2l0aW9uID09PSAnbnVtYmVyJyAmJiBpc09iamVjdCh2YWx1ZS5wcm9wZXJ0aWVzKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG4gIGlzT3BlcmF0aW9uTGlzdCh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeSh2YWwgPT4gT3BlcmF0aW9uLmlzT3BlcmF0aW9uKHZhbCkpO1xuICB9LFxuICBpc1NlbGVjdGlvbk9wZXJhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBPcGVyYXRpb24uaXNPcGVyYXRpb24odmFsdWUpICYmIHZhbHVlLnR5cGUuZW5kc1dpdGgoJ19zZWxlY3Rpb24nKTtcbiAgfSxcbiAgaXNUZXh0T3BlcmF0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIE9wZXJhdGlvbi5pc09wZXJhdGlvbih2YWx1ZSkgJiYgdmFsdWUudHlwZS5lbmRzV2l0aCgnX3RleHQnKTtcbiAgfSxcbiAgaW52ZXJzZShvcCkge1xuICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdyZW1vdmVfbm9kZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdyZW1vdmVfdGV4dCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ3NwbGl0X25vZGUnLFxuICAgICAgICAgICAgcGF0aDogUGF0aC5wcmV2aW91cyhvcC5wYXRoKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIG5ld1BhdGgsXG4gICAgICAgICAgICBwYXRoXG4gICAgICAgICAgfSA9IG9wO1xuICAgICAgICAgIC8vIFBFUkY6IGluIHRoaXMgY2FzZSB0aGUgbW92ZSBvcGVyYXRpb24gaXMgYSBuby1vcCBhbnl3YXlzLlxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhuZXdQYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJZiB0aGUgbW92ZSBoYXBwZW5zIGNvbXBsZXRlbHkgd2l0aGluIGEgc2luZ2xlIHBhcmVudCB0aGUgcGF0aCBhbmRcbiAgICAgICAgICAvLyBuZXdQYXRoIGFyZSBzdGFibGUgd2l0aCByZXNwZWN0IHRvIGVhY2ggb3RoZXIuXG4gICAgICAgICAgaWYgKFBhdGguaXNTaWJsaW5nKHBhdGgsIG5ld1BhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgICBwYXRoOiBuZXdQYXRoLFxuICAgICAgICAgICAgICBuZXdQYXRoOiBwYXRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSWYgdGhlIG1vdmUgZG9lcyBub3QgaGFwcGVuIHdpdGhpbiBhIHNpbmdsZSBwYXJlbnQgaXQgaXMgcG9zc2libGVcbiAgICAgICAgICAvLyBmb3IgdGhlIG1vdmUgdG8gaW1wYWN0IHRoZSB0cnVlIHBhdGggdG8gdGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBub2RlXG4gICAgICAgICAgLy8gd2FzIHJlbW92ZWQgZnJvbSBhbmQgd2hlcmUgaXQgd2FzIGluc2VydGVkLiBXZSBoYXZlIHRvIGFkanVzdCBmb3IgdGhpc1xuICAgICAgICAgIC8vIGFuZCBmaW5kIHRoZSBvcmlnaW5hbCBwYXRoLiBXZSBjYW4gYWNjb21wbGlzaCB0aGlzIChvbmx5IGluIG5vbi1zaWJsaW5nKVxuICAgICAgICAgIC8vIG1vdmVzIGJ5IGxvb2tpbmcgYXQgdGhlIGltcGFjdCBvZiB0aGUgbW92ZSBvcGVyYXRpb24gb24gdGhlIG5vZGVcbiAgICAgICAgICAvLyBhZnRlciB0aGUgb3JpZ2luYWwgbW92ZSBwYXRoLlxuICAgICAgICAgIHZhciBpbnZlcnNlUGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wKTtcbiAgICAgICAgICB2YXIgaW52ZXJzZU5ld1BhdGggPSBQYXRoLnRyYW5zZm9ybShQYXRoLm5leHQocGF0aCksIG9wKTtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgcGF0aDogaW52ZXJzZVBhdGgsXG4gICAgICAgICAgICBuZXdQYXRoOiBpbnZlcnNlTmV3UGF0aFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ2luc2VydF9ub2RlJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ2luc2VydF90ZXh0J1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlICdzZXRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgICAgIG5ld1Byb3BlcnRpZXNcbiAgICAgICAgICB9ID0gb3A7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IG5ld1Byb3BlcnRpZXMsXG4gICAgICAgICAgICBuZXdQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3NldF9zZWxlY3Rpb24nOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IF9wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgbmV3UHJvcGVydGllczogX25ld1Byb3BlcnRpZXNcbiAgICAgICAgICB9ID0gb3A7XG4gICAgICAgICAgaWYgKF9wcm9wZXJ0aWVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICAgIHByb3BlcnRpZXM6IF9uZXdQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICBuZXdQcm9wZXJ0aWVzOiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKF9uZXdQcm9wZXJ0aWVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICAgIHByb3BlcnRpZXM6IG51bGwsXG4gICAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IF9wcm9wZXJ0aWVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgICAgcHJvcGVydGllczogX25ld1Byb3BlcnRpZXMsXG4gICAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IF9wcm9wZXJ0aWVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdtZXJnZV9ub2RlJyxcbiAgICAgICAgICAgIHBhdGg6IFBhdGgubmV4dChvcC5wYXRoKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgaXNFZGl0b3IgPSBmdW5jdGlvbiBpc0VkaXRvcih2YWx1ZSkge1xuICB2YXIge1xuICAgIGRlZXAgPSBmYWxzZVxuICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGlzRWRpdG9yID0gdHlwZW9mIHZhbHVlLmFkZE1hcmsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmFwcGx5ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5kZWxldGVGcmFnbWVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0QnJlYWsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydFNvZnRCcmVhayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0RnJhZ21lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydE5vZGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydFRleHQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmlzRWxlbWVudFJlYWRPbmx5ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pc0lubGluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaXNTZWxlY3RhYmxlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pc1ZvaWQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLm5vcm1hbGl6ZU5vZGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLm9uQ2hhbmdlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5yZW1vdmVNYXJrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5nZXREaXJ0eVBhdGhzID09PSAnZnVuY3Rpb24nICYmICh2YWx1ZS5tYXJrcyA9PT0gbnVsbCB8fCBpc09iamVjdCh2YWx1ZS5tYXJrcykpICYmICh2YWx1ZS5zZWxlY3Rpb24gPT09IG51bGwgfHwgUmFuZ2UuaXNSYW5nZSh2YWx1ZS5zZWxlY3Rpb24pKSAmJiAoIWRlZXAgfHwgTm9kZS5pc05vZGVMaXN0KHZhbHVlLmNoaWxkcmVuKSkgJiYgT3BlcmF0aW9uLmlzT3BlcmF0aW9uTGlzdCh2YWx1ZS5vcGVyYXRpb25zKTtcbiAgcmV0dXJuIGlzRWRpdG9yO1xufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIEVkaXRvciA9IHtcbiAgYWJvdmUoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5hYm92ZShvcHRpb25zKTtcbiAgfSxcbiAgYWRkTWFyayhlZGl0b3IsIGtleSwgdmFsdWUpIHtcbiAgICBlZGl0b3IuYWRkTWFyayhrZXksIHZhbHVlKTtcbiAgfSxcbiAgYWZ0ZXIoZWRpdG9yLCBhdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IuYWZ0ZXIoYXQsIG9wdGlvbnMpO1xuICB9LFxuICBiZWZvcmUoZWRpdG9yLCBhdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IuYmVmb3JlKGF0LCBvcHRpb25zKTtcbiAgfSxcbiAgZGVsZXRlQmFja3dhcmQoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICB1bml0ID0gJ2NoYXJhY3RlcidcbiAgICB9ID0gb3B0aW9ucztcbiAgICBlZGl0b3IuZGVsZXRlQmFja3dhcmQodW5pdCk7XG4gIH0sXG4gIGRlbGV0ZUZvcndhcmQoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICB1bml0ID0gJ2NoYXJhY3RlcidcbiAgICB9ID0gb3B0aW9ucztcbiAgICBlZGl0b3IuZGVsZXRlRm9yd2FyZCh1bml0KTtcbiAgfSxcbiAgZGVsZXRlRnJhZ21lbnQoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLmRlbGV0ZUZyYWdtZW50KG9wdGlvbnMpO1xuICB9LFxuICBlZGdlcyhlZGl0b3IsIGF0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5lZGdlcyhhdCk7XG4gIH0sXG4gIGVsZW1lbnRSZWFkT25seShlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgcmV0dXJuIGVkaXRvci5lbGVtZW50UmVhZE9ubHkob3B0aW9ucyk7XG4gIH0sXG4gIGVuZChlZGl0b3IsIGF0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5lbmQoYXQpO1xuICB9LFxuICBmaXJzdChlZGl0b3IsIGF0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5maXJzdChhdCk7XG4gIH0sXG4gIGZyYWdtZW50KGVkaXRvciwgYXQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmZyYWdtZW50KGF0KTtcbiAgfSxcbiAgaGFzQmxvY2tzKGVkaXRvciwgZWxlbWVudCkge1xuICAgIHJldHVybiBlZGl0b3IuaGFzQmxvY2tzKGVsZW1lbnQpO1xuICB9LFxuICBoYXNJbmxpbmVzKGVkaXRvciwgZWxlbWVudCkge1xuICAgIHJldHVybiBlZGl0b3IuaGFzSW5saW5lcyhlbGVtZW50KTtcbiAgfSxcbiAgaGFzUGF0aChlZGl0b3IsIHBhdGgpIHtcbiAgICByZXR1cm4gZWRpdG9yLmhhc1BhdGgocGF0aCk7XG4gIH0sXG4gIGhhc1RleHRzKGVkaXRvciwgZWxlbWVudCkge1xuICAgIHJldHVybiBlZGl0b3IuaGFzVGV4dHMoZWxlbWVudCk7XG4gIH0sXG4gIGluc2VydEJyZWFrKGVkaXRvcikge1xuICAgIGVkaXRvci5pbnNlcnRCcmVhaygpO1xuICB9LFxuICBpbnNlcnRGcmFnbWVudChlZGl0b3IsIGZyYWdtZW50LCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLmluc2VydEZyYWdtZW50KGZyYWdtZW50LCBvcHRpb25zKTtcbiAgfSxcbiAgaW5zZXJ0Tm9kZShlZGl0b3IsIG5vZGUpIHtcbiAgICBlZGl0b3IuaW5zZXJ0Tm9kZShub2RlKTtcbiAgfSxcbiAgaW5zZXJ0U29mdEJyZWFrKGVkaXRvcikge1xuICAgIGVkaXRvci5pbnNlcnRTb2Z0QnJlYWsoKTtcbiAgfSxcbiAgaW5zZXJ0VGV4dChlZGl0b3IsIHRleHQpIHtcbiAgICBlZGl0b3IuaW5zZXJ0VGV4dCh0ZXh0KTtcbiAgfSxcbiAgaXNCbG9jayhlZGl0b3IsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc0Jsb2NrKHZhbHVlKTtcbiAgfSxcbiAgaXNFZGdlKGVkaXRvciwgcG9pbnQsIGF0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc0VkZ2UocG9pbnQsIGF0KTtcbiAgfSxcbiAgaXNFZGl0b3IodmFsdWUpIHtcbiAgICByZXR1cm4gaXNFZGl0b3IodmFsdWUpO1xuICB9LFxuICBpc0VsZW1lbnRSZWFkT25seShlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzRWxlbWVudFJlYWRPbmx5KGVsZW1lbnQpO1xuICB9LFxuICBpc0VtcHR5KGVkaXRvciwgZWxlbWVudCkge1xuICAgIHJldHVybiBlZGl0b3IuaXNFbXB0eShlbGVtZW50KTtcbiAgfSxcbiAgaXNFbmQoZWRpdG9yLCBwb2ludCwgYXQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzRW5kKHBvaW50LCBhdCk7XG4gIH0sXG4gIGlzSW5saW5lKGVkaXRvciwgdmFsdWUpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzSW5saW5lKHZhbHVlKTtcbiAgfSxcbiAgaXNOb3JtYWxpemluZyhlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzTm9ybWFsaXppbmcoKTtcbiAgfSxcbiAgaXNTZWxlY3RhYmxlKGVkaXRvciwgdmFsdWUpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzU2VsZWN0YWJsZSh2YWx1ZSk7XG4gIH0sXG4gIGlzU3RhcnQoZWRpdG9yLCBwb2ludCwgYXQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzU3RhcnQocG9pbnQsIGF0KTtcbiAgfSxcbiAgaXNWb2lkKGVkaXRvciwgdmFsdWUpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzVm9pZCh2YWx1ZSk7XG4gIH0sXG4gIGxhc3QoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBlZGl0b3IubGFzdChhdCk7XG4gIH0sXG4gIGxlYWYoZWRpdG9yLCBhdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IubGVhZihhdCwgb3B0aW9ucyk7XG4gIH0sXG4gIGxldmVscyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLmxldmVscyhvcHRpb25zKTtcbiAgfSxcbiAgbWFya3MoZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5nZXRNYXJrcygpO1xuICB9LFxuICBuZXh0KGVkaXRvciwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IubmV4dChvcHRpb25zKTtcbiAgfSxcbiAgbm9kZShlZGl0b3IsIGF0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5ub2RlKGF0LCBvcHRpb25zKTtcbiAgfSxcbiAgbm9kZXMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5ub2RlcyhvcHRpb25zKTtcbiAgfSxcbiAgbm9ybWFsaXplKGVkaXRvciwgb3B0aW9ucykge1xuICAgIGVkaXRvci5ub3JtYWxpemUob3B0aW9ucyk7XG4gIH0sXG4gIHBhcmVudChlZGl0b3IsIGF0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5wYXJlbnQoYXQsIG9wdGlvbnMpO1xuICB9LFxuICBwYXRoKGVkaXRvciwgYXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLnBhdGgoYXQsIG9wdGlvbnMpO1xuICB9LFxuICBwYXRoUmVmKGVkaXRvciwgcGF0aCwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IucGF0aFJlZihwYXRoLCBvcHRpb25zKTtcbiAgfSxcbiAgcGF0aFJlZnMoZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5wYXRoUmVmcygpO1xuICB9LFxuICBwb2ludChlZGl0b3IsIGF0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5wb2ludChhdCwgb3B0aW9ucyk7XG4gIH0sXG4gIHBvaW50UmVmKGVkaXRvciwgcG9pbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLnBvaW50UmVmKHBvaW50LCBvcHRpb25zKTtcbiAgfSxcbiAgcG9pbnRSZWZzKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IucG9pbnRSZWZzKCk7XG4gIH0sXG4gIHBvc2l0aW9ucyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLnBvc2l0aW9ucyhvcHRpb25zKTtcbiAgfSxcbiAgcHJldmlvdXMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5wcmV2aW91cyhvcHRpb25zKTtcbiAgfSxcbiAgcmFuZ2UoZWRpdG9yLCBhdCwgdG8pIHtcbiAgICByZXR1cm4gZWRpdG9yLnJhbmdlKGF0LCB0byk7XG4gIH0sXG4gIHJhbmdlUmVmKGVkaXRvciwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLnJhbmdlUmVmKHJhbmdlLCBvcHRpb25zKTtcbiAgfSxcbiAgcmFuZ2VSZWZzKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IucmFuZ2VSZWZzKCk7XG4gIH0sXG4gIHJlbW92ZU1hcmsoZWRpdG9yLCBrZXkpIHtcbiAgICBlZGl0b3IucmVtb3ZlTWFyayhrZXkpO1xuICB9LFxuICBzZXROb3JtYWxpemluZyhlZGl0b3IsIGlzTm9ybWFsaXppbmcpIHtcbiAgICBlZGl0b3Iuc2V0Tm9ybWFsaXppbmcoaXNOb3JtYWxpemluZyk7XG4gIH0sXG4gIHN0YXJ0KGVkaXRvciwgYXQpIHtcbiAgICByZXR1cm4gZWRpdG9yLnN0YXJ0KGF0KTtcbiAgfSxcbiAgc3RyaW5nKGVkaXRvciwgYXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLnN0cmluZyhhdCwgb3B0aW9ucyk7XG4gIH0sXG4gIHVuaGFuZ1JhbmdlKGVkaXRvciwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLnVuaGFuZ1JhbmdlKHJhbmdlLCBvcHRpb25zKTtcbiAgfSxcbiAgdm9pZChlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLnZvaWQob3B0aW9ucyk7XG4gIH0sXG4gIHdpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZuKSB7XG4gICAgZWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhmbik7XG4gIH0sXG4gIHNob3VsZE1lcmdlTm9kZXNSZW1vdmVQcmV2Tm9kZTogKGVkaXRvciwgcHJldk5vZGUsIGN1ck5vZGUpID0+IHtcbiAgICByZXR1cm4gZWRpdG9yLnNob3VsZE1lcmdlTm9kZXNSZW1vdmVQcmV2Tm9kZShwcmV2Tm9kZSwgY3VyTm9kZSk7XG4gIH1cbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBMb2NhdGlvbiA9IHtcbiAgaXNMb2NhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZSkgfHwgUG9pbnQuaXNQb2ludCh2YWx1ZSkgfHwgUmFuZ2UuaXNSYW5nZSh2YWx1ZSk7XG4gIH1cbn07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgU3BhbiA9IHtcbiAgaXNTcGFuKHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMiAmJiB2YWx1ZS5ldmVyeShQYXRoLmlzUGF0aCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG93bktleXMkYihlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJGIoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyRiKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyRiKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgUG9pbnQgPSB7XG4gIGNvbXBhcmUocG9pbnQsIGFub3RoZXIpIHtcbiAgICB2YXIgcmVzdWx0ID0gUGF0aC5jb21wYXJlKHBvaW50LnBhdGgsIGFub3RoZXIucGF0aCk7XG4gICAgaWYgKHJlc3VsdCA9PT0gMCkge1xuICAgICAgaWYgKHBvaW50Lm9mZnNldCA8IGFub3RoZXIub2Zmc2V0KSByZXR1cm4gLTE7XG4gICAgICBpZiAocG9pbnQub2Zmc2V0ID4gYW5vdGhlci5vZmZzZXQpIHJldHVybiAxO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIGlzQWZ0ZXIocG9pbnQsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUG9pbnQuY29tcGFyZShwb2ludCwgYW5vdGhlcikgPT09IDE7XG4gIH0sXG4gIGlzQmVmb3JlKHBvaW50LCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBvaW50LmNvbXBhcmUocG9pbnQsIGFub3RoZXIpID09PSAtMTtcbiAgfSxcbiAgZXF1YWxzKHBvaW50LCBhbm90aGVyKSB7XG4gICAgLy8gUEVSRjogZW5zdXJlIHRoZSBvZmZzZXRzIGFyZSBlcXVhbCBmaXJzdCBzaW5jZSB0aGV5IGFyZSBjaGVhcGVyIHRvIGNoZWNrLlxuICAgIHJldHVybiBwb2ludC5vZmZzZXQgPT09IGFub3RoZXIub2Zmc2V0ICYmIFBhdGguZXF1YWxzKHBvaW50LnBhdGgsIGFub3RoZXIucGF0aCk7XG4gIH0sXG4gIGlzUG9pbnQodmFsdWUpIHtcbiAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIHR5cGVvZiB2YWx1ZS5vZmZzZXQgPT09ICdudW1iZXInICYmIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpO1xuICB9LFxuICB0cmFuc2Zvcm0ocG9pbnQsIG9wKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGlmIChwb2ludCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciB7XG4gICAgICBhZmZpbml0eSA9ICdmb3J3YXJkJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBwYXRoLFxuICAgICAgb2Zmc2V0XG4gICAgfSA9IHBvaW50O1xuICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgb3B0aW9ucyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSAmJiAob3Aub2Zmc2V0IDwgb2Zmc2V0IHx8IG9wLm9mZnNldCA9PT0gb2Zmc2V0ICYmIGFmZmluaXR5ID09PSAnZm9yd2FyZCcpKSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gb3AudGV4dC5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IG9wLnBvc2l0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIG9wdGlvbnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgJiYgb3Aub2Zmc2V0IDw9IG9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0IC09IE1hdGgubWluKG9mZnNldCAtIG9wLm9mZnNldCwgb3AudGV4dC5sZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpIHx8IFBhdGguaXNBbmNlc3RvcihvcC5wYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgb3B0aW9ucyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgICBpZiAob3AucG9zaXRpb24gPT09IG9mZnNldCAmJiBhZmZpbml0eSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcC5wb3NpdGlvbiA8IG9mZnNldCB8fCBvcC5wb3NpdGlvbiA9PT0gb2Zmc2V0ICYmIGFmZmluaXR5ID09PSAnZm9yd2FyZCcpIHtcbiAgICAgICAgICAgICAgb2Zmc2V0IC09IG9wLnBvc2l0aW9uO1xuICAgICAgICAgICAgICBwYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIF9vYmplY3RTcHJlYWQkYihfb2JqZWN0U3ByZWFkJGIoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgICAgICAgIGFmZmluaXR5OiAnZm9yd2FyZCdcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcGF0aCxcbiAgICAgIG9mZnNldFxuICAgIH07XG4gIH1cbn07XG5cbnZhciBfc2NydWJiZXIgPSB1bmRlZmluZWQ7XG4vKipcbiAqIFRoaXMgaW50ZXJmYWNlIGltcGxlbWVudHMgYSBzdHJpbmdpZnkoKSBmdW5jdGlvbiwgd2hpY2ggaXMgdXNlZCBieSBTbGF0ZVxuICogaW50ZXJuYWxseSB3aGVuIGdlbmVyYXRpbmcgZXhjZXB0aW9ucyBjb250YWluaW5nIGVuZCB1c2VyIGRhdGEuIERldmVsb3BlcnNcbiAqIHVzaW5nIFNsYXRlIG1heSBjYWxsIFNjcnViYmVyLnNldFNjcnViYmVyKCkgdG8gYWx0ZXIgdGhlIGJlaGF2aW9yIG9mIHRoaXNcbiAqIHN0cmluZ2lmeSgpIGZ1bmN0aW9uLlxuICpcbiAqIEZvciBleGFtcGxlLCB0byBwcmV2ZW50IHRoZSBjbGVhcnRleHQgbG9nZ2luZyBvZiAndGV4dCcgZmllbGRzIHdpdGhpbiBOb2RlczpcbiAqXG4gKiAgICBpbXBvcnQgeyBTY3J1YmJlciB9IGZyb20gJ3NsYXRlJztcbiAqICAgIFNjcnViYmVyLnNldFNjcnViYmVyKChrZXksIHZhbCkgPT4ge1xuICogICAgICBpZiAoa2V5ID09PSAndGV4dCcpIHJldHVybiAnLi4uc2NydWJiZWQuLi4nXG4gKiAgICAgIHJldHVybiB2YWxcbiAqICAgIH0pO1xuICpcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFNjcnViYmVyID0ge1xuICBzZXRTY3J1YmJlcihzY3J1YmJlcikge1xuICAgIF9zY3J1YmJlciA9IHNjcnViYmVyO1xuICB9LFxuICBzdHJpbmdpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIF9zY3J1YmJlcik7XG4gIH1cbn07XG5cbnZhciBfZXhjbHVkZWQkMiA9IFtcInRleHRcIl0sXG4gIF9leGNsdWRlZDIkMiA9IFtcImFuY2hvclwiLCBcImZvY3VzXCIsIFwibWVyZ2VcIl07XG5mdW5jdGlvbiBvd25LZXlzJGEoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCRhKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkYShPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkYShPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFRleHQgPSB7XG4gIGVxdWFscyh0ZXh0LCBhbm90aGVyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBsb29zZSA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgZnVuY3Rpb24gb21pdFRleHQob2JqKSB7XG4gICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIF9leGNsdWRlZCQyKTtcbiAgICAgIHJldHVybiByZXN0O1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWVwRXF1YWwobG9vc2UgPyBvbWl0VGV4dCh0ZXh0KSA6IHRleHQsIGxvb3NlID8gb21pdFRleHQoYW5vdGhlcikgOiBhbm90aGVyKTtcbiAgfSxcbiAgaXNUZXh0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzVGV4dExpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkodmFsID0+IFRleHQuaXNUZXh0KHZhbCkpO1xuICB9LFxuICBpc1RleHRQcm9wcyhwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy50ZXh0ICE9PSB1bmRlZmluZWQ7XG4gIH0sXG4gIG1hdGNoZXModGV4dCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICd0ZXh0Jykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGV4dC5oYXNPd25Qcm9wZXJ0eShrZXkpIHx8IHRleHRba2V5XSAhPT0gcHJvcHNba2V5XSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBkZWNvcmF0aW9ucyhub2RlLCBkZWNvcmF0aW9ucykge1xuICAgIHZhciBsZWF2ZXMgPSBbe1xuICAgICAgbGVhZjogX29iamVjdFNwcmVhZCRhKHt9LCBub2RlKVxuICAgIH1dO1xuICAgIGZvciAodmFyIGRlYyBvZiBkZWNvcmF0aW9ucykge1xuICAgICAgdmFyIHtcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgZm9jdXMsXG4gICAgICAgICAgbWVyZ2U6IG1lcmdlRGVjb3JhdGlvblxuICAgICAgICB9ID0gZGVjLFxuICAgICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGRlYywgX2V4Y2x1ZGVkMiQyKTtcbiAgICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhkZWMpO1xuICAgICAgdmFyIG5leHQgPSBbXTtcbiAgICAgIHZhciBsZWFmRW5kID0gMDtcbiAgICAgIHZhciBkZWNvcmF0aW9uU3RhcnQgPSBzdGFydC5vZmZzZXQ7XG4gICAgICB2YXIgZGVjb3JhdGlvbkVuZCA9IGVuZC5vZmZzZXQ7XG4gICAgICB2YXIgbWVyZ2UgPSBtZXJnZURlY29yYXRpb24gIT09IG51bGwgJiYgbWVyZ2VEZWNvcmF0aW9uICE9PSB2b2lkIDAgPyBtZXJnZURlY29yYXRpb24gOiBPYmplY3QuYXNzaWduO1xuICAgICAgZm9yICh2YXIge1xuICAgICAgICBsZWFmXG4gICAgICB9IG9mIGxlYXZlcykge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIGxlbmd0aFxuICAgICAgICB9ID0gbGVhZi50ZXh0O1xuICAgICAgICB2YXIgbGVhZlN0YXJ0ID0gbGVhZkVuZDtcbiAgICAgICAgbGVhZkVuZCArPSBsZW5ndGg7XG4gICAgICAgIC8vIElmIHRoZSByYW5nZSBlbmNvbXBhc3NlcyB0aGUgZW50aXJlIGxlYWYsIGFkZCB0aGUgcmFuZ2UuXG4gICAgICAgIGlmIChkZWNvcmF0aW9uU3RhcnQgPD0gbGVhZlN0YXJ0ICYmIGxlYWZFbmQgPD0gZGVjb3JhdGlvbkVuZCkge1xuICAgICAgICAgIG1lcmdlKGxlYWYsIHJlc3QpO1xuICAgICAgICAgIG5leHQucHVzaCh7XG4gICAgICAgICAgICBsZWFmXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHJhbmdlIGV4cGFuZGVkIGFuZCBtYXRjaCB0aGUgbGVhZiwgb3Igc3RhcnRzIGFmdGVyLCBvciBlbmRzIGJlZm9yZSBpdCwgY29udGludWUuXG4gICAgICAgIGlmIChkZWNvcmF0aW9uU3RhcnQgIT09IGRlY29yYXRpb25FbmQgJiYgKGRlY29yYXRpb25TdGFydCA9PT0gbGVhZkVuZCB8fCBkZWNvcmF0aW9uRW5kID09PSBsZWFmU3RhcnQpIHx8IGRlY29yYXRpb25TdGFydCA+IGxlYWZFbmQgfHwgZGVjb3JhdGlvbkVuZCA8IGxlYWZTdGFydCB8fCBkZWNvcmF0aW9uRW5kID09PSBsZWFmU3RhcnQgJiYgbGVhZlN0YXJ0ICE9PSAwKSB7XG4gICAgICAgICAgbmV4dC5wdXNoKHtcbiAgICAgICAgICAgIGxlYWZcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2Ugd2UgbmVlZCB0byBzcGxpdCB0aGUgbGVhZiwgYXQgdGhlIHN0YXJ0LCBlbmQsIG9yIGJvdGgsXG4gICAgICAgIC8vIGFuZCBhZGQgdGhlIHJhbmdlIHRvIHRoZSBtaWRkbGUgaW50ZXJzZWN0aW5nIHNlY3Rpb24uIERvIHRoZSBlbmRcbiAgICAgICAgLy8gc3BsaXQgZmlyc3Qgc2luY2Ugd2UgZG9uJ3QgbmVlZCB0byB1cGRhdGUgdGhlIG9mZnNldCB0aGF0IHdheS5cbiAgICAgICAgdmFyIG1pZGRsZSA9IGxlYWY7XG4gICAgICAgIHZhciBiZWZvcmUgPSB2b2lkIDA7XG4gICAgICAgIHZhciBhZnRlciA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGRlY29yYXRpb25FbmQgPCBsZWFmRW5kKSB7XG4gICAgICAgICAgdmFyIG9mZiA9IGRlY29yYXRpb25FbmQgLSBsZWFmU3RhcnQ7XG4gICAgICAgICAgYWZ0ZXIgPSB7XG4gICAgICAgICAgICBsZWFmOiBfb2JqZWN0U3ByZWFkJGEoX29iamVjdFNwcmVhZCRhKHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgICB0ZXh0OiBtaWRkbGUudGV4dC5zbGljZShvZmYpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH07XG4gICAgICAgICAgbWlkZGxlID0gX29iamVjdFNwcmVhZCRhKF9vYmplY3RTcHJlYWQkYSh7fSwgbWlkZGxlKSwge30sIHtcbiAgICAgICAgICAgIHRleHQ6IG1pZGRsZS50ZXh0LnNsaWNlKDAsIG9mZilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVjb3JhdGlvblN0YXJ0ID4gbGVhZlN0YXJ0KSB7XG4gICAgICAgICAgdmFyIF9vZmYgPSBkZWNvcmF0aW9uU3RhcnQgLSBsZWFmU3RhcnQ7XG4gICAgICAgICAgYmVmb3JlID0ge1xuICAgICAgICAgICAgbGVhZjogX29iamVjdFNwcmVhZCRhKF9vYmplY3RTcHJlYWQkYSh7fSwgbWlkZGxlKSwge30sIHtcbiAgICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2UoMCwgX29mZilcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfTtcbiAgICAgICAgICBtaWRkbGUgPSBfb2JqZWN0U3ByZWFkJGEoX29iamVjdFNwcmVhZCRhKHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2UoX29mZilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBtZXJnZShtaWRkbGUsIHJlc3QpO1xuICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgbmV4dC5wdXNoKGJlZm9yZSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dC5wdXNoKHtcbiAgICAgICAgICBsZWFmOiBtaWRkbGVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhZnRlcikge1xuICAgICAgICAgIG5leHQucHVzaChhZnRlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxlYXZlcyA9IG5leHQ7XG4gICAgfVxuICAgIGlmIChsZWF2ZXMubGVuZ3RoID4gMSkge1xuICAgICAgdmFyIGN1cnJlbnRPZmZzZXQgPSAwO1xuICAgICAgZm9yICh2YXIgW2luZGV4LCBpdGVtXSBvZiBsZWF2ZXMuZW50cmllcygpKSB7XG4gICAgICAgIHZhciBfc3RhcnQgPSBjdXJyZW50T2Zmc2V0O1xuICAgICAgICB2YXIgX2VuZCA9IF9zdGFydCArIGl0ZW0ubGVhZi50ZXh0Lmxlbmd0aDtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0ge1xuICAgICAgICAgIHN0YXJ0OiBfc3RhcnQsXG4gICAgICAgICAgZW5kOiBfZW5kXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpbmRleCA9PT0gMCkgcG9zaXRpb24uaXNGaXJzdCA9IHRydWU7XG4gICAgICAgIGlmIChpbmRleCA9PT0gbGVhdmVzLmxlbmd0aCAtIDEpIHBvc2l0aW9uLmlzTGFzdCA9IHRydWU7XG4gICAgICAgIGl0ZW0ucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgY3VycmVudE9mZnNldCA9IF9lbmQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZWF2ZXM7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IGxvY2F0aW9uIHRvIGluc2VydCBjb250ZW50IGludG8gdGhlIGVkaXRvci5cbiAqIEJ5IGRlZmF1bHQsIHVzZSB0aGUgc2VsZWN0aW9uIGFzIHRoZSB0YXJnZXQgbG9jYXRpb24uIEJ1dCBpZiB0aGVyZSBpc1xuICogbm8gc2VsZWN0aW9uLCBpbnNlcnQgYXQgdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQgc2luY2UgdGhhdCBpcyBzdWNoIGFcbiAqIGNvbW1vbiB1c2UgY2FzZSB3aGVuIGluc2VydGluZyBmcm9tIGEgbm9uLXNlbGVjdGVkIHN0YXRlLlxuICovXG52YXIgZ2V0RGVmYXVsdEluc2VydExvY2F0aW9uID0gZWRpdG9yID0+IHtcbiAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICByZXR1cm4gZWRpdG9yLnNlbGVjdGlvbjtcbiAgfSBlbHNlIGlmIChlZGl0b3IuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBFZGl0b3IuZW5kKGVkaXRvciwgW10pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbMF07XG4gIH1cbn07XG5cbnZhciBtYXRjaFBhdGggPSAoZWRpdG9yLCBwYXRoKSA9PiB7XG4gIHZhciBbbm9kZV0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpO1xuICByZXR1cm4gbiA9PiBuID09PSBub2RlO1xufTtcblxuLy8gQ2hhcmFjdGVyIChncmFwaGVtZSBjbHVzdGVyKSBib3VuZGFyaWVzIGFyZSBkZXRlcm1pbmVkIGFjY29yZGluZyB0b1xuLy8gdGhlIGRlZmF1bHQgZ3JhcGhlbWUgY2x1c3RlciBib3VuZGFyeSBzcGVjaWZpY2F0aW9uLCBleHRlbmRlZCBncmFwaGVtZSBjbHVzdGVycyB2YXJpYW50WzFdLlxuLy9cbi8vIFJlZmVyZW5jZXM6XG4vL1xuLy8gWzFdIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIyOS8jRGVmYXVsdF9HcmFwaGVtZV9DbHVzdGVyX1RhYmxlXG4vLyBbMl0gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvUHVibGljL1VDRC9sYXRlc3QvdWNkL2F1eGlsaWFyeS9HcmFwaGVtZUJyZWFrUHJvcGVydHkudHh0XG4vLyBbM10gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvUHVibGljL1VDRC9sYXRlc3QvdWNkL2F1eGlsaWFyeS9HcmFwaGVtZUJyZWFrVGVzdC5odG1sXG4vLyBbNF0gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvUHVibGljL1VDRC9sYXRlc3QvdWNkL2F1eGlsaWFyeS9HcmFwaGVtZUJyZWFrVGVzdC50eHRcbi8qKlxuICogR2V0IHRoZSBkaXN0YW5jZSB0byB0aGUgZW5kIG9mIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gYSBzdHJpbmcgb2YgdGV4dC5cbiAqL1xudmFyIGdldENoYXJhY3RlckRpc3RhbmNlID0gZnVuY3Rpb24gZ2V0Q2hhcmFjdGVyRGlzdGFuY2Uoc3RyKSB7XG4gIHZhciBpc1JUTCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gIHZhciBpc0xUUiA9ICFpc1JUTDtcbiAgdmFyIGNvZGVwb2ludHMgPSBpc1JUTCA/IGNvZGVwb2ludHNJdGVyYXRvclJUTChzdHIpIDogc3RyO1xuICB2YXIgbGVmdCA9IENvZGVwb2ludFR5cGUuTm9uZTtcbiAgdmFyIHJpZ2h0ID0gQ29kZXBvaW50VHlwZS5Ob25lO1xuICB2YXIgZGlzdGFuY2UgPSAwO1xuICAvLyBFdmFsdWF0aW9uIG9mIHRoZXNlIGNvbmRpdGlvbnMgYXJlIGRlZmVycmVkLlxuICB2YXIgZ2IxMSA9IG51bGw7IC8vIElzIEdCMTEgYXBwbGljYWJsZT9cbiAgdmFyIGdiMTJPcjEzID0gbnVsbDsgLy8gSXMgR0IxMiBvciBHQjEzIGFwcGxpY2FibGU/XG4gIGZvciAodmFyIGNoYXIgb2YgY29kZXBvaW50cykge1xuICAgIHZhciBjb2RlID0gY2hhci5jb2RlUG9pbnRBdCgwKTtcbiAgICBpZiAoIWNvZGUpIGJyZWFrO1xuICAgIHZhciB0eXBlID0gZ2V0Q29kZXBvaW50VHlwZShjaGFyLCBjb2RlKTtcbiAgICBbbGVmdCwgcmlnaHRdID0gaXNMVFIgPyBbcmlnaHQsIHR5cGVdIDogW3R5cGUsIGxlZnRdO1xuICAgIGlmIChpbnRlcnNlY3RzKGxlZnQsIENvZGVwb2ludFR5cGUuWldKKSAmJiBpbnRlcnNlY3RzKHJpZ2h0LCBDb2RlcG9pbnRUeXBlLkV4dFBpY3QpKSB7XG4gICAgICBpZiAoaXNMVFIpIHtcbiAgICAgICAgZ2IxMSA9IGVuZHNXaXRoRW1vamlaV0ooc3RyLnN1YnN0cmluZygwLCBkaXN0YW5jZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2IxMSA9IGVuZHNXaXRoRW1vamlaV0ooc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gZGlzdGFuY2UpKTtcbiAgICAgIH1cbiAgICAgIGlmICghZ2IxMSkgYnJlYWs7XG4gICAgfVxuICAgIGlmIChpbnRlcnNlY3RzKGxlZnQsIENvZGVwb2ludFR5cGUuUkkpICYmIGludGVyc2VjdHMocmlnaHQsIENvZGVwb2ludFR5cGUuUkkpKSB7XG4gICAgICBpZiAoZ2IxMk9yMTMgIT09IG51bGwpIHtcbiAgICAgICAgZ2IxMk9yMTMgPSAhZ2IxMk9yMTM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNMVFIpIHtcbiAgICAgICAgICBnYjEyT3IxMyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2IxMk9yMTMgPSBlbmRzV2l0aE9kZE51bWJlck9mUklzKHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIGRpc3RhbmNlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZ2IxMk9yMTMpIGJyZWFrO1xuICAgIH1cbiAgICBpZiAobGVmdCAhPT0gQ29kZXBvaW50VHlwZS5Ob25lICYmIHJpZ2h0ICE9PSBDb2RlcG9pbnRUeXBlLk5vbmUgJiYgaXNCb3VuZGFyeVBhaXIobGVmdCwgcmlnaHQpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGlzdGFuY2UgKz0gY2hhci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIGRpc3RhbmNlIHx8IDE7XG59O1xudmFyIFNQQUNFID0gL1xccy87XG52YXIgUFVOQ1RVQVRJT04gPSAvW1xcdTAwMkJcXHUwMDIxLVxcdTAwMjNcXHUwMDI1LVxcdTAwMkFcXHUwMDJDLVxcdTAwMkZcXHUwMDNBXFx1MDAzQlxcdTAwM0ZcXHUwMDQwXFx1MDA1Qi1cXHUwMDVEXFx1MDA1RlxcdTAwN0JcXHUwMDdEXFx1MDBBMVxcdTAwQTdcXHUwMEFCXFx1MDBCNlxcdTAwQjdcXHUwMEJCXFx1MDBCRlxcdTAzN0VcXHUwMzg3XFx1MDU1QS1cXHUwNTVGXFx1MDU4OVxcdTA1OEFcXHUwNUJFXFx1MDVDMFxcdTA1QzNcXHUwNUM2XFx1MDVGM1xcdTA1RjRcXHUwNjA5XFx1MDYwQVxcdTA2MENcXHUwNjBEXFx1MDYxQlxcdTA2MUVcXHUwNjFGXFx1MDY2QS1cXHUwNjZEXFx1MDZENFxcdTA3MDAtXFx1MDcwRFxcdTA3RjctXFx1MDdGOVxcdTA4MzAtXFx1MDgzRVxcdTA4NUVcXHUwOTY0XFx1MDk2NVxcdTA5NzBcXHUwQUYwXFx1MERGNFxcdTBFNEZcXHUwRTVBXFx1MEU1QlxcdTBGMDQtXFx1MEYxMlxcdTBGMTRcXHUwRjNBLVxcdTBGM0RcXHUwRjg1XFx1MEZEMC1cXHUwRkQ0XFx1MEZEOVxcdTBGREFcXHUxMDRBLVxcdTEwNEZcXHUxMEZCXFx1MTM2MC1cXHUxMzY4XFx1MTQwMFxcdTE2NkRcXHUxNjZFXFx1MTY5QlxcdTE2OUNcXHUxNkVCLVxcdTE2RURcXHUxNzM1XFx1MTczNlxcdTE3RDQtXFx1MTdENlxcdTE3RDgtXFx1MTdEQVxcdTE4MDAtXFx1MTgwQVxcdTE5NDRcXHUxOTQ1XFx1MUExRVxcdTFBMUZcXHUxQUEwLVxcdTFBQTZcXHUxQUE4LVxcdTFBQURcXHUxQjVBLVxcdTFCNjBcXHUxQkZDLVxcdTFCRkZcXHUxQzNCLVxcdTFDM0ZcXHUxQzdFXFx1MUM3RlxcdTFDQzAtXFx1MUNDN1xcdTFDRDNcXHUyMDEwLVxcdTIwMjdcXHUyMDMwLVxcdTIwNDNcXHUyMDQ1LVxcdTIwNTFcXHUyMDUzLVxcdTIwNUVcXHUyMDdEXFx1MjA3RVxcdTIwOERcXHUyMDhFXFx1MjMyOVxcdTIzMkFcXHUyNzY4LVxcdTI3NzVcXHUyN0M1XFx1MjdDNlxcdTI3RTYtXFx1MjdFRlxcdTI5ODMtXFx1Mjk5OFxcdTI5RDgtXFx1MjlEQlxcdTI5RkNcXHUyOUZEXFx1MkNGOS1cXHUyQ0ZDXFx1MkNGRVxcdTJDRkZcXHUyRDcwXFx1MkUwMC1cXHUyRTJFXFx1MkUzMC1cXHUyRTNCXFx1MzAwMS1cXHUzMDAzXFx1MzAwOC1cXHUzMDExXFx1MzAxNC1cXHUzMDFGXFx1MzAzMFxcdTMwM0RcXHUzMEEwXFx1MzBGQlxcdUE0RkVcXHVBNEZGXFx1QTYwRC1cXHVBNjBGXFx1QTY3M1xcdUE2N0VcXHVBNkYyLVxcdUE2RjdcXHVBODc0LVxcdUE4NzdcXHVBOENFXFx1QThDRlxcdUE4RjgtXFx1QThGQVxcdUE5MkVcXHVBOTJGXFx1QTk1RlxcdUE5QzEtXFx1QTlDRFxcdUE5REVcXHVBOURGXFx1QUE1Qy1cXHVBQTVGXFx1QUFERVxcdUFBREZcXHVBQUYwXFx1QUFGMVxcdUFCRUJcXHVGRDNFXFx1RkQzRlxcdUZFMTAtXFx1RkUxOVxcdUZFMzAtXFx1RkU1MlxcdUZFNTQtXFx1RkU2MVxcdUZFNjNcXHVGRTY4XFx1RkU2QVxcdUZFNkJcXHVGRjAxLVxcdUZGMDNcXHVGRjA1LVxcdUZGMEFcXHVGRjBDLVxcdUZGMEZcXHVGRjFBXFx1RkYxQlxcdUZGMUZcXHVGRjIwXFx1RkYzQi1cXHVGRjNEXFx1RkYzRlxcdUZGNUJcXHVGRjVEXFx1RkY1Ri1cXHVGRjY1XS87XG52YXIgQ0hBTUVMRU9OID0gL1snXFx1MjAxOFxcdTIwMTldLztcbi8qKlxuICogR2V0IHRoZSBkaXN0YW5jZSB0byB0aGUgZW5kIG9mIHRoZSBmaXJzdCB3b3JkIGluIGEgc3RyaW5nIG9mIHRleHQuXG4gKi9cbnZhciBnZXRXb3JkRGlzdGFuY2UgPSBmdW5jdGlvbiBnZXRXb3JkRGlzdGFuY2UodGV4dCkge1xuICB2YXIgaXNSVEwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICB2YXIgZGlzdCA9IDA7XG4gIHZhciBzdGFydGVkID0gZmFsc2U7XG4gIHdoaWxlICh0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICB2YXIgY2hhckRpc3QgPSBnZXRDaGFyYWN0ZXJEaXN0YW5jZSh0ZXh0LCBpc1JUTCk7XG4gICAgdmFyIFtjaGFyLCByZW1haW5pbmddID0gc3BsaXRCeUNoYXJhY3RlckRpc3RhbmNlKHRleHQsIGNoYXJEaXN0LCBpc1JUTCk7XG4gICAgaWYgKGlzV29yZENoYXJhY3RlcihjaGFyLCByZW1haW5pbmcsIGlzUlRMKSkge1xuICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICBkaXN0ICs9IGNoYXJEaXN0O1xuICAgIH0gZWxzZSBpZiAoIXN0YXJ0ZWQpIHtcbiAgICAgIGRpc3QgKz0gY2hhckRpc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0ZXh0ID0gcmVtYWluaW5nO1xuICB9XG4gIHJldHVybiBkaXN0O1xufTtcbi8qKlxuICogU3BsaXQgYSBzdHJpbmcgaW4gdHdvIHBhcnRzIGF0IGEgZ2l2ZW4gZGlzdGFuY2Ugc3RhcnRpbmcgZnJvbSB0aGUgZW5kIHdoZW5cbiAqIGBpc1JUTGAgaXMgc2V0IHRvIGB0cnVlYC5cbiAqL1xudmFyIHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZSA9IChzdHIsIGRpc3QsIGlzUlRMKSA9PiB7XG4gIGlmIChpc1JUTCkge1xuICAgIHZhciBhdCA9IHN0ci5sZW5ndGggLSBkaXN0O1xuICAgIHJldHVybiBbc3RyLnNsaWNlKGF0LCBzdHIubGVuZ3RoKSwgc3RyLnNsaWNlKDAsIGF0KV07XG4gIH1cbiAgcmV0dXJuIFtzdHIuc2xpY2UoMCwgZGlzdCksIHN0ci5zbGljZShkaXN0KV07XG59O1xuLyoqXG4gKiBDaGVjayBpZiBhIGNoYXJhY3RlciBpcyBhIHdvcmQgY2hhcmFjdGVyLiBUaGUgYHJlbWFpbmluZ2AgYXJndW1lbnQgaXMgdXNlZFxuICogYmVjYXVzZSBzb21ldGltZXMgeW91IG11c3QgcmVhZCBzdWJzZXF1ZW50IGNoYXJhY3RlcnMgdG8gdHJ1bHkgZGV0ZXJtaW5lIGl0LlxuICovXG52YXIgaXNXb3JkQ2hhcmFjdGVyID0gZnVuY3Rpb24gaXNXb3JkQ2hhcmFjdGVyKGNoYXIsIHJlbWFpbmluZykge1xuICB2YXIgaXNSVEwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICBpZiAoU1BBQ0UudGVzdChjaGFyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBDaGFtZWxlb25zIGNvdW50IGFzIHdvcmQgY2hhcmFjdGVycyBhcyBsb25nIGFzIHRoZXkncmUgaW4gYSB3b3JkLCBzb1xuICAvLyByZWN1cnNlIHRvIHNlZSBpZiB0aGUgbmV4dCBvbmUgaXMgYSB3b3JkIGNoYXJhY3RlciBvciBub3QuXG4gIGlmIChDSEFNRUxFT04udGVzdChjaGFyKSkge1xuICAgIHZhciBjaGFyRGlzdCA9IGdldENoYXJhY3RlckRpc3RhbmNlKHJlbWFpbmluZywgaXNSVEwpO1xuICAgIHZhciBbbmV4dENoYXIsIG5leHRSZW1haW5pbmddID0gc3BsaXRCeUNoYXJhY3RlckRpc3RhbmNlKHJlbWFpbmluZywgY2hhckRpc3QsIGlzUlRMKTtcbiAgICBpZiAoaXNXb3JkQ2hhcmFjdGVyKG5leHRDaGFyLCBuZXh0UmVtYWluaW5nLCBpc1JUTCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoUFVOQ1RVQVRJT04udGVzdChjaGFyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbiAqIEl0ZXJhdGUgb24gY29kZXBvaW50cyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKi9cbnZhciBjb2RlcG9pbnRzSXRlcmF0b3JSVEwgPSBmdW5jdGlvbiogY29kZXBvaW50c0l0ZXJhdG9yUlRMKHN0cikge1xuICB2YXIgZW5kID0gc3RyLmxlbmd0aCAtIDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoYXIxID0gc3RyLmNoYXJBdChlbmQgLSBpKTtcbiAgICBpZiAoaXNMb3dTdXJyb2dhdGUoY2hhcjEuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgIHZhciBjaGFyMiA9IHN0ci5jaGFyQXQoZW5kIC0gaSAtIDEpO1xuICAgICAgaWYgKGlzSGlnaFN1cnJvZ2F0ZShjaGFyMi5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICB5aWVsZCBjaGFyMiArIGNoYXIxO1xuICAgICAgICBpKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICB5aWVsZCBjaGFyMTtcbiAgfVxufTtcbi8qKlxuICogSXMgYGNoYXJDb2RlYCBhIGhpZ2ggc3Vycm9nYXRlLlxuICpcbiAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VuaXZlcnNhbF9DaGFyYWN0ZXJfU2V0X2NoYXJhY3RlcnMjU3Vycm9nYXRlc1xuICovXG52YXIgaXNIaWdoU3Vycm9nYXRlID0gY2hhckNvZGUgPT4ge1xuICByZXR1cm4gY2hhckNvZGUgPj0gMHhkODAwICYmIGNoYXJDb2RlIDw9IDB4ZGJmZjtcbn07XG4vKipcbiAqIElzIGBjaGFyQ29kZWAgYSBsb3cgc3Vycm9nYXRlLlxuICpcbiAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VuaXZlcnNhbF9DaGFyYWN0ZXJfU2V0X2NoYXJhY3RlcnMjU3Vycm9nYXRlc1xuICovXG52YXIgaXNMb3dTdXJyb2dhdGUgPSBjaGFyQ29kZSA9PiB7XG4gIHJldHVybiBjaGFyQ29kZSA+PSAweGRjMDAgJiYgY2hhckNvZGUgPD0gMHhkZmZmO1xufTtcbnZhciBDb2RlcG9pbnRUeXBlO1xuKGZ1bmN0aW9uIChDb2RlcG9pbnRUeXBlKSB7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJFeHRlbmRcIl0gPSAxXSA9IFwiRXh0ZW5kXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlpXSlwiXSA9IDJdID0gXCJaV0pcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiUklcIl0gPSA0XSA9IFwiUklcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiUHJlcGVuZFwiXSA9IDhdID0gXCJQcmVwZW5kXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlNwYWNpbmdNYXJrXCJdID0gMTZdID0gXCJTcGFjaW5nTWFya1wiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJMXCJdID0gMzJdID0gXCJMXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlZcIl0gPSA2NF0gPSBcIlZcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiVFwiXSA9IDEyOF0gPSBcIlRcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiTFZcIl0gPSAyNTZdID0gXCJMVlwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJMVlRcIl0gPSA1MTJdID0gXCJMVlRcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiRXh0UGljdFwiXSA9IDEwMjRdID0gXCJFeHRQaWN0XCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkFueVwiXSA9IDIwNDhdID0gXCJBbnlcIjtcbn0pKENvZGVwb2ludFR5cGUgfHwgKENvZGVwb2ludFR5cGUgPSB7fSkpO1xudmFyIHJlRXh0ZW5kID0gL14oPzpbXFx1MDMwMC1cXHUwMzZGXFx1MDQ4My1cXHUwNDg5XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDYxMC1cXHUwNjFBXFx1MDY0Qi1cXHUwNjVGXFx1MDY3MFxcdTA2RDYtXFx1MDZEQ1xcdTA2REYtXFx1MDZFNFxcdTA2RTdcXHUwNkU4XFx1MDZFQS1cXHUwNkVEXFx1MDcxMVxcdTA3MzAtXFx1MDc0QVxcdTA3QTYtXFx1MDdCMFxcdTA3RUItXFx1MDdGM1xcdTA3RkRcXHUwODE2LVxcdTA4MTlcXHUwODFCLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MkRcXHUwODU5LVxcdTA4NUJcXHUwODk4LVxcdTA4OUZcXHUwOENBLVxcdTA4RTFcXHUwOEUzLVxcdTA5MDJcXHUwOTNBXFx1MDkzQ1xcdTA5NDEtXFx1MDk0OFxcdTA5NERcXHUwOTUxLVxcdTA5NTdcXHUwOTYyXFx1MDk2M1xcdTA5ODFcXHUwOUJDXFx1MDlCRVxcdTA5QzEtXFx1MDlDNFxcdTA5Q0RcXHUwOUQ3XFx1MDlFMlxcdTA5RTNcXHUwOUZFXFx1MEEwMVxcdTBBMDJcXHUwQTNDXFx1MEE0MVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTcwXFx1MEE3MVxcdTBBNzVcXHUwQTgxXFx1MEE4MlxcdTBBQkNcXHUwQUMxLVxcdTBBQzVcXHUwQUM3XFx1MEFDOFxcdTBBQ0RcXHUwQUUyXFx1MEFFM1xcdTBBRkEtXFx1MEFGRlxcdTBCMDFcXHUwQjNDXFx1MEIzRVxcdTBCM0ZcXHUwQjQxLVxcdTBCNDRcXHUwQjREXFx1MEI1NS1cXHUwQjU3XFx1MEI2MlxcdTBCNjNcXHUwQjgyXFx1MEJCRVxcdTBCQzBcXHUwQkNEXFx1MEJEN1xcdTBDMDBcXHUwQzA0XFx1MEMzQ1xcdTBDM0UtXFx1MEM0MFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM2MlxcdTBDNjNcXHUwQzgxXFx1MENCQ1xcdTBDQkZcXHUwQ0MyXFx1MENDNlxcdTBDQ0NcXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0UyXFx1MENFM1xcdTBEMDBcXHUwRDAxXFx1MEQzQlxcdTBEM0NcXHUwRDNFXFx1MEQ0MS1cXHUwRDQ0XFx1MEQ0RFxcdTBENTdcXHUwRDYyXFx1MEQ2M1xcdTBEODFcXHUwRENBXFx1MERDRlxcdTBERDItXFx1MERENFxcdTBERDZcXHUwRERGXFx1MEUzMVxcdTBFMzQtXFx1MEUzQVxcdTBFNDctXFx1MEU0RVxcdTBFQjFcXHUwRUI0LVxcdTBFQkNcXHUwRUM4LVxcdTBFQ0VcXHUwRjE4XFx1MEYxOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGNzEtXFx1MEY3RVxcdTBGODAtXFx1MEY4NFxcdTBGODZcXHUwRjg3XFx1MEY4RC1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMkQtXFx1MTAzMFxcdTEwMzItXFx1MTAzN1xcdTEwMzlcXHUxMDNBXFx1MTAzRFxcdTEwM0VcXHUxMDU4XFx1MTA1OVxcdTEwNUUtXFx1MTA2MFxcdTEwNzEtXFx1MTA3NFxcdTEwODJcXHUxMDg1XFx1MTA4NlxcdTEwOERcXHUxMDlEXFx1MTM1RC1cXHUxMzVGXFx1MTcxMi1cXHUxNzE0XFx1MTczMlxcdTE3MzNcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdCNFxcdTE3QjVcXHUxN0I3LVxcdTE3QkRcXHUxN0M2XFx1MTdDOS1cXHUxN0QzXFx1MTdERFxcdTE4MEItXFx1MTgwRFxcdTE4MEZcXHUxODg1XFx1MTg4NlxcdTE4QTlcXHUxOTIwLVxcdTE5MjJcXHUxOTI3XFx1MTkyOFxcdTE5MzJcXHUxOTM5LVxcdTE5M0JcXHUxQTE3XFx1MUExOFxcdTFBMUJcXHUxQTU2XFx1MUE1OC1cXHUxQTVFXFx1MUE2MFxcdTFBNjJcXHUxQTY1LVxcdTFBNkNcXHUxQTczLVxcdTFBN0NcXHUxQTdGXFx1MUFCMC1cXHUxQUNFXFx1MUIwMC1cXHUxQjAzXFx1MUIzNC1cXHUxQjNBXFx1MUIzQ1xcdTFCNDJcXHUxQjZCLVxcdTFCNzNcXHUxQjgwXFx1MUI4MVxcdTFCQTItXFx1MUJBNVxcdTFCQThcXHUxQkE5XFx1MUJBQi1cXHUxQkFEXFx1MUJFNlxcdTFCRThcXHUxQkU5XFx1MUJFRFxcdTFCRUYtXFx1MUJGMVxcdTFDMkMtXFx1MUMzM1xcdTFDMzZcXHUxQzM3XFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0UwXFx1MUNFMi1cXHUxQ0U4XFx1MUNFRFxcdTFDRjRcXHUxQ0Y4XFx1MUNGOVxcdTFEQzAtXFx1MURGRlxcdTIwMENcXHUyMEQwLVxcdTIwRjBcXHUyQ0VGLVxcdTJDRjFcXHUyRDdGXFx1MkRFMC1cXHUyREZGXFx1MzAyQS1cXHUzMDJGXFx1MzA5OVxcdTMwOUFcXHVBNjZGLVxcdUE2NzJcXHVBNjc0LVxcdUE2N0RcXHVBNjlFXFx1QTY5RlxcdUE2RjBcXHVBNkYxXFx1QTgwMlxcdUE4MDZcXHVBODBCXFx1QTgyNVxcdUE4MjZcXHVBODJDXFx1QThDNFxcdUE4QzVcXHVBOEUwLVxcdUE4RjFcXHVBOEZGXFx1QTkyNi1cXHVBOTJEXFx1QTk0Ny1cXHVBOTUxXFx1QTk4MC1cXHVBOTgyXFx1QTlCM1xcdUE5QjYtXFx1QTlCOVxcdUE5QkNcXHVBOUJEXFx1QTlFNVxcdUFBMjktXFx1QUEyRVxcdUFBMzFcXHVBQTMyXFx1QUEzNVxcdUFBMzZcXHVBQTQzXFx1QUE0Q1xcdUFBN0NcXHVBQUIwXFx1QUFCMi1cXHVBQUI0XFx1QUFCN1xcdUFBQjhcXHVBQUJFXFx1QUFCRlxcdUFBQzFcXHVBQUVDXFx1QUFFRFxcdUFBRjZcXHVBQkU1XFx1QUJFOFxcdUFCRURcXHVGQjFFXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJGXFx1RkY5RVxcdUZGOUZdfFxcdUQ4MDBbXFx1RERGRFxcdURFRTBcXHVERjc2LVxcdURGN0FdfFxcdUQ4MDJbXFx1REUwMS1cXHVERTAzXFx1REUwNVxcdURFMDZcXHVERTBDLVxcdURFMEZcXHVERTM4LVxcdURFM0FcXHVERTNGXFx1REVFNVxcdURFRTZdfFxcdUQ4MDNbXFx1REQyNC1cXHVERDI3XFx1REVBQlxcdURFQUNcXHVERUZELVxcdURFRkZcXHVERjQ2LVxcdURGNTBcXHVERjgyLVxcdURGODVdfFxcdUQ4MDRbXFx1REMwMVxcdURDMzgtXFx1REM0NlxcdURDNzBcXHVEQzczXFx1REM3NFxcdURDN0YtXFx1REM4MVxcdURDQjMtXFx1RENCNlxcdURDQjlcXHVEQ0JBXFx1RENDMlxcdUREMDAtXFx1REQwMlxcdUREMjctXFx1REQyQlxcdUREMkQtXFx1REQzNFxcdURENzNcXHVERDgwXFx1REQ4MVxcdUREQjYtXFx1RERCRVxcdUREQzktXFx1RERDQ1xcdUREQ0ZcXHVERTJGLVxcdURFMzFcXHVERTM0XFx1REUzNlxcdURFMzdcXHVERTNFXFx1REU0MVxcdURFREZcXHVERUUzLVxcdURFRUFcXHVERjAwXFx1REYwMVxcdURGM0JcXHVERjNDXFx1REYzRVxcdURGNDBcXHVERjU3XFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XXxcXHVEODA1W1xcdURDMzgtXFx1REMzRlxcdURDNDItXFx1REM0NFxcdURDNDZcXHVEQzVFXFx1RENCMFxcdURDQjMtXFx1RENCOFxcdURDQkFcXHVEQ0JEXFx1RENCRlxcdURDQzBcXHVEQ0MyXFx1RENDM1xcdUREQUZcXHVEREIyLVxcdUREQjVcXHVEREJDXFx1RERCRFxcdUREQkZcXHVEREMwXFx1REREQ1xcdURERERcXHVERTMzLVxcdURFM0FcXHVERTNEXFx1REUzRlxcdURFNDBcXHVERUFCXFx1REVBRFxcdURFQjAtXFx1REVCNVxcdURFQjdcXHVERjFELVxcdURGMUZcXHVERjIyLVxcdURGMjVcXHVERjI3LVxcdURGMkJdfFxcdUQ4MDZbXFx1REMyRi1cXHVEQzM3XFx1REMzOVxcdURDM0FcXHVERDMwXFx1REQzQlxcdUREM0NcXHVERDNFXFx1REQ0M1xcdURERDQtXFx1REREN1xcdUREREFcXHVERERCXFx1RERFMFxcdURFMDEtXFx1REUwQVxcdURFMzMtXFx1REUzOFxcdURFM0ItXFx1REUzRVxcdURFNDdcXHVERTUxLVxcdURFNTZcXHVERTU5LVxcdURFNUJcXHVERThBLVxcdURFOTZcXHVERTk4XFx1REU5OV18XFx1RDgwN1tcXHVEQzMwLVxcdURDMzZcXHVEQzM4LVxcdURDM0RcXHVEQzNGXFx1REM5Mi1cXHVEQ0E3XFx1RENBQS1cXHVEQ0IwXFx1RENCMlxcdURDQjNcXHVEQ0I1XFx1RENCNlxcdUREMzEtXFx1REQzNlxcdUREM0FcXHVERDNDXFx1REQzRFxcdUREM0YtXFx1REQ0NVxcdURENDdcXHVERDkwXFx1REQ5MVxcdUREOTVcXHVERDk3XFx1REVGM1xcdURFRjRcXHVERjAwXFx1REYwMVxcdURGMzYtXFx1REYzQVxcdURGNDBcXHVERjQyXXxcXHVEODBEW1xcdURDNDBcXHVEQzQ3LVxcdURDNTVdfFxcdUQ4MUFbXFx1REVGMC1cXHVERUY0XFx1REYzMC1cXHVERjM2XXxcXHVEODFCW1xcdURGNEZcXHVERjhGLVxcdURGOTJcXHVERkU0XXxcXHVEODJGW1xcdURDOURcXHVEQzlFXXxcXHVEODMzW1xcdURGMDAtXFx1REYyRFxcdURGMzAtXFx1REY0Nl18XFx1RDgzNFtcXHVERDY1XFx1REQ2Ny1cXHVERDY5XFx1REQ2RS1cXHVERDcyXFx1REQ3Qi1cXHVERDgyXFx1REQ4NS1cXHVERDhCXFx1RERBQS1cXHVEREFEXFx1REU0Mi1cXHVERTQ0XXxcXHVEODM2W1xcdURFMDAtXFx1REUzNlxcdURFM0ItXFx1REU2Q1xcdURFNzVcXHVERTg0XFx1REU5Qi1cXHVERTlGXFx1REVBMS1cXHVERUFGXXxcXHVEODM4W1xcdURDMDAtXFx1REMwNlxcdURDMDgtXFx1REMxOFxcdURDMUItXFx1REMyMVxcdURDMjNcXHVEQzI0XFx1REMyNi1cXHVEQzJBXFx1REM4RlxcdUREMzAtXFx1REQzNlxcdURFQUVcXHVERUVDLVxcdURFRUZdfFxcdUQ4MzlbXFx1RENFQy1cXHVEQ0VGXXxcXHVEODNBW1xcdURDRDAtXFx1RENENlxcdURENDQtXFx1REQ0QV18XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdURCNDBbXFx1REMyMC1cXHVEQzdGXFx1REQwMC1cXHVEREVGXSkkLztcbnZhciByZVByZXBlbmQgPSAvXig/OltcXHUwNjAwLVxcdTA2MDVcXHUwNkREXFx1MDcwRlxcdTA4OTBcXHUwODkxXFx1MDhFMlxcdTBENEVdfFxcdUQ4MDRbXFx1RENCRFxcdURDQ0RcXHVEREMyXFx1RERDM118XFx1RDgwNltcXHVERDNGXFx1REQ0MVxcdURFM0FcXHVERTg0LVxcdURFODldfFxcdUQ4MDdcXHVERDQ2KSQvO1xudmFyIHJlU3BhY2luZ01hcmsgPSAvXig/OltcXHUwOTAzXFx1MDkzQlxcdTA5M0UtXFx1MDk0MFxcdTA5NDktXFx1MDk0Q1xcdTA5NEVcXHUwOTRGXFx1MDk4MlxcdTA5ODNcXHUwOUJGXFx1MDlDMFxcdTA5QzdcXHUwOUM4XFx1MDlDQlxcdTA5Q0NcXHUwQTAzXFx1MEEzRS1cXHUwQTQwXFx1MEE4M1xcdTBBQkUtXFx1MEFDMFxcdTBBQzlcXHUwQUNCXFx1MEFDQ1xcdTBCMDJcXHUwQjAzXFx1MEI0MFxcdTBCNDdcXHUwQjQ4XFx1MEI0QlxcdTBCNENcXHUwQkJGXFx1MEJDMVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0NcXHUwQzAxLVxcdTBDMDNcXHUwQzQxLVxcdTBDNDRcXHUwQzgyXFx1MEM4M1xcdTBDQkVcXHUwQ0MwXFx1MENDMVxcdTBDQzNcXHUwQ0M0XFx1MENDN1xcdTBDQzhcXHUwQ0NBXFx1MENDQlxcdTBEMDJcXHUwRDAzXFx1MEQzRlxcdTBENDBcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENENcXHUwRDgyXFx1MEQ4M1xcdTBERDBcXHUwREQxXFx1MEREOC1cXHUwRERFXFx1MERGMlxcdTBERjNcXHUwRTMzXFx1MEVCM1xcdTBGM0VcXHUwRjNGXFx1MEY3RlxcdTEwMzFcXHUxMDNCXFx1MTAzQ1xcdTEwNTZcXHUxMDU3XFx1MTA4NFxcdTE3MTVcXHUxNzM0XFx1MTdCNlxcdTE3QkUtXFx1MTdDNVxcdTE3QzdcXHUxN0M4XFx1MTkyMy1cXHUxOTI2XFx1MTkyOS1cXHUxOTJCXFx1MTkzMFxcdTE5MzFcXHUxOTMzLVxcdTE5MzhcXHUxQTE5XFx1MUExQVxcdTFBNTVcXHUxQTU3XFx1MUE2RC1cXHUxQTcyXFx1MUIwNFxcdTFCM0JcXHUxQjNELVxcdTFCNDFcXHUxQjQzXFx1MUI0NFxcdTFCODJcXHUxQkExXFx1MUJBNlxcdTFCQTdcXHUxQkFBXFx1MUJFN1xcdTFCRUEtXFx1MUJFQ1xcdTFCRUVcXHUxQkYyXFx1MUJGM1xcdTFDMjQtXFx1MUMyQlxcdTFDMzRcXHUxQzM1XFx1MUNFMVxcdTFDRjdcXHVBODIzXFx1QTgyNFxcdUE4MjdcXHVBODgwXFx1QTg4MVxcdUE4QjQtXFx1QThDM1xcdUE5NTJcXHVBOTUzXFx1QTk4M1xcdUE5QjRcXHVBOUI1XFx1QTlCQVxcdUE5QkJcXHVBOUJFLVxcdUE5QzBcXHVBQTJGXFx1QUEzMFxcdUFBMzNcXHVBQTM0XFx1QUE0RFxcdUFBRUJcXHVBQUVFXFx1QUFFRlxcdUFBRjVcXHVBQkUzXFx1QUJFNFxcdUFCRTZcXHVBQkU3XFx1QUJFOVxcdUFCRUFcXHVBQkVDXXxcXHVEODA0W1xcdURDMDBcXHVEQzAyXFx1REM4MlxcdURDQjAtXFx1RENCMlxcdURDQjdcXHVEQ0I4XFx1REQyQ1xcdURENDVcXHVERDQ2XFx1REQ4MlxcdUREQjMtXFx1RERCNVxcdUREQkZcXHVEREMwXFx1RERDRVxcdURFMkMtXFx1REUyRVxcdURFMzJcXHVERTMzXFx1REUzNVxcdURFRTAtXFx1REVFMlxcdURGMDJcXHVERjAzXFx1REYzRlxcdURGNDEtXFx1REY0NFxcdURGNDdcXHVERjQ4XFx1REY0Qi1cXHVERjREXFx1REY2MlxcdURGNjNdfFxcdUQ4MDVbXFx1REMzNS1cXHVEQzM3XFx1REM0MFxcdURDNDFcXHVEQzQ1XFx1RENCMVxcdURDQjJcXHVEQ0I5XFx1RENCQlxcdURDQkNcXHVEQ0JFXFx1RENDMVxcdUREQjBcXHVEREIxXFx1RERCOC1cXHVEREJCXFx1RERCRVxcdURFMzAtXFx1REUzMlxcdURFM0JcXHVERTNDXFx1REUzRVxcdURFQUNcXHVERUFFXFx1REVBRlxcdURFQjZcXHVERjI2XXxcXHVEODA2W1xcdURDMkMtXFx1REMyRVxcdURDMzhcXHVERDMxLVxcdUREMzVcXHVERDM3XFx1REQzOFxcdUREM0RcXHVERDQwXFx1REQ0MlxcdURERDEtXFx1REREM1xcdUREREMtXFx1RERERlxcdURERTRcXHVERTM5XFx1REU1N1xcdURFNThcXHVERTk3XXxcXHVEODA3W1xcdURDMkZcXHVEQzNFXFx1RENBOVxcdURDQjFcXHVEQ0I0XFx1REQ4QS1cXHVERDhFXFx1REQ5M1xcdUREOTRcXHVERDk2XFx1REVGNVxcdURFRjZdfFxcdUQ4MUJbXFx1REY1MS1cXHVERjg3XFx1REZGMFxcdURGRjFdfFxcdUQ4MzRbXFx1REQ2NlxcdURENkRdKSQvO1xudmFyIHJlTCA9IC9eW1xcdTExMDAtXFx1MTE1RlxcdUE5NjAtXFx1QTk3Q10kLztcbnZhciByZVYgPSAvXltcXHUxMTYwLVxcdTExQTdcXHVEN0IwLVxcdUQ3QzZdJC87XG52YXIgcmVUID0gL15bXFx1MTFBOC1cXHUxMUZGXFx1RDdDQi1cXHVEN0ZCXSQvO1xudmFyIHJlTFYgPSAvXltcXHVBQzAwXFx1QUMxQ1xcdUFDMzhcXHVBQzU0XFx1QUM3MFxcdUFDOENcXHVBQ0E4XFx1QUNDNFxcdUFDRTBcXHVBQ0ZDXFx1QUQxOFxcdUFEMzRcXHVBRDUwXFx1QUQ2Q1xcdUFEODhcXHVBREE0XFx1QURDMFxcdUFERENcXHVBREY4XFx1QUUxNFxcdUFFMzBcXHVBRTRDXFx1QUU2OFxcdUFFODRcXHVBRUEwXFx1QUVCQ1xcdUFFRDhcXHVBRUY0XFx1QUYxMFxcdUFGMkNcXHVBRjQ4XFx1QUY2NFxcdUFGODBcXHVBRjlDXFx1QUZCOFxcdUFGRDRcXHVBRkYwXFx1QjAwQ1xcdUIwMjhcXHVCMDQ0XFx1QjA2MFxcdUIwN0NcXHVCMDk4XFx1QjBCNFxcdUIwRDBcXHVCMEVDXFx1QjEwOFxcdUIxMjRcXHVCMTQwXFx1QjE1Q1xcdUIxNzhcXHVCMTk0XFx1QjFCMFxcdUIxQ0NcXHVCMUU4XFx1QjIwNFxcdUIyMjBcXHVCMjNDXFx1QjI1OFxcdUIyNzRcXHVCMjkwXFx1QjJBQ1xcdUIyQzhcXHVCMkU0XFx1QjMwMFxcdUIzMUNcXHVCMzM4XFx1QjM1NFxcdUIzNzBcXHVCMzhDXFx1QjNBOFxcdUIzQzRcXHVCM0UwXFx1QjNGQ1xcdUI0MThcXHVCNDM0XFx1QjQ1MFxcdUI0NkNcXHVCNDg4XFx1QjRBNFxcdUI0QzBcXHVCNERDXFx1QjRGOFxcdUI1MTRcXHVCNTMwXFx1QjU0Q1xcdUI1NjhcXHVCNTg0XFx1QjVBMFxcdUI1QkNcXHVCNUQ4XFx1QjVGNFxcdUI2MTBcXHVCNjJDXFx1QjY0OFxcdUI2NjRcXHVCNjgwXFx1QjY5Q1xcdUI2QjhcXHVCNkQ0XFx1QjZGMFxcdUI3MENcXHVCNzI4XFx1Qjc0NFxcdUI3NjBcXHVCNzdDXFx1Qjc5OFxcdUI3QjRcXHVCN0QwXFx1QjdFQ1xcdUI4MDhcXHVCODI0XFx1Qjg0MFxcdUI4NUNcXHVCODc4XFx1Qjg5NFxcdUI4QjBcXHVCOENDXFx1QjhFOFxcdUI5MDRcXHVCOTIwXFx1QjkzQ1xcdUI5NThcXHVCOTc0XFx1Qjk5MFxcdUI5QUNcXHVCOUM4XFx1QjlFNFxcdUJBMDBcXHVCQTFDXFx1QkEzOFxcdUJBNTRcXHVCQTcwXFx1QkE4Q1xcdUJBQThcXHVCQUM0XFx1QkFFMFxcdUJBRkNcXHVCQjE4XFx1QkIzNFxcdUJCNTBcXHVCQjZDXFx1QkI4OFxcdUJCQTRcXHVCQkMwXFx1QkJEQ1xcdUJCRjhcXHVCQzE0XFx1QkMzMFxcdUJDNENcXHVCQzY4XFx1QkM4NFxcdUJDQTBcXHVCQ0JDXFx1QkNEOFxcdUJDRjRcXHVCRDEwXFx1QkQyQ1xcdUJENDhcXHVCRDY0XFx1QkQ4MFxcdUJEOUNcXHVCREI4XFx1QkRENFxcdUJERjBcXHVCRTBDXFx1QkUyOFxcdUJFNDRcXHVCRTYwXFx1QkU3Q1xcdUJFOThcXHVCRUI0XFx1QkVEMFxcdUJFRUNcXHVCRjA4XFx1QkYyNFxcdUJGNDBcXHVCRjVDXFx1QkY3OFxcdUJGOTRcXHVCRkIwXFx1QkZDQ1xcdUJGRThcXHVDMDA0XFx1QzAyMFxcdUMwM0NcXHVDMDU4XFx1QzA3NFxcdUMwOTBcXHVDMEFDXFx1QzBDOFxcdUMwRTRcXHVDMTAwXFx1QzExQ1xcdUMxMzhcXHVDMTU0XFx1QzE3MFxcdUMxOENcXHVDMUE4XFx1QzFDNFxcdUMxRTBcXHVDMUZDXFx1QzIxOFxcdUMyMzRcXHVDMjUwXFx1QzI2Q1xcdUMyODhcXHVDMkE0XFx1QzJDMFxcdUMyRENcXHVDMkY4XFx1QzMxNFxcdUMzMzBcXHVDMzRDXFx1QzM2OFxcdUMzODRcXHVDM0EwXFx1QzNCQ1xcdUMzRDhcXHVDM0Y0XFx1QzQxMFxcdUM0MkNcXHVDNDQ4XFx1QzQ2NFxcdUM0ODBcXHVDNDlDXFx1QzRCOFxcdUM0RDRcXHVDNEYwXFx1QzUwQ1xcdUM1MjhcXHVDNTQ0XFx1QzU2MFxcdUM1N0NcXHVDNTk4XFx1QzVCNFxcdUM1RDBcXHVDNUVDXFx1QzYwOFxcdUM2MjRcXHVDNjQwXFx1QzY1Q1xcdUM2NzhcXHVDNjk0XFx1QzZCMFxcdUM2Q0NcXHVDNkU4XFx1QzcwNFxcdUM3MjBcXHVDNzNDXFx1Qzc1OFxcdUM3NzRcXHVDNzkwXFx1QzdBQ1xcdUM3QzhcXHVDN0U0XFx1QzgwMFxcdUM4MUNcXHVDODM4XFx1Qzg1NFxcdUM4NzBcXHVDODhDXFx1QzhBOFxcdUM4QzRcXHVDOEUwXFx1QzhGQ1xcdUM5MThcXHVDOTM0XFx1Qzk1MFxcdUM5NkNcXHVDOTg4XFx1QzlBNFxcdUM5QzBcXHVDOURDXFx1QzlGOFxcdUNBMTRcXHVDQTMwXFx1Q0E0Q1xcdUNBNjhcXHVDQTg0XFx1Q0FBMFxcdUNBQkNcXHVDQUQ4XFx1Q0FGNFxcdUNCMTBcXHVDQjJDXFx1Q0I0OFxcdUNCNjRcXHVDQjgwXFx1Q0I5Q1xcdUNCQjhcXHVDQkQ0XFx1Q0JGMFxcdUNDMENcXHVDQzI4XFx1Q0M0NFxcdUNDNjBcXHVDQzdDXFx1Q0M5OFxcdUNDQjRcXHVDQ0QwXFx1Q0NFQ1xcdUNEMDhcXHVDRDI0XFx1Q0Q0MFxcdUNENUNcXHVDRDc4XFx1Q0Q5NFxcdUNEQjBcXHVDRENDXFx1Q0RFOFxcdUNFMDRcXHVDRTIwXFx1Q0UzQ1xcdUNFNThcXHVDRTc0XFx1Q0U5MFxcdUNFQUNcXHVDRUM4XFx1Q0VFNFxcdUNGMDBcXHVDRjFDXFx1Q0YzOFxcdUNGNTRcXHVDRjcwXFx1Q0Y4Q1xcdUNGQThcXHVDRkM0XFx1Q0ZFMFxcdUNGRkNcXHVEMDE4XFx1RDAzNFxcdUQwNTBcXHVEMDZDXFx1RDA4OFxcdUQwQTRcXHVEMEMwXFx1RDBEQ1xcdUQwRjhcXHVEMTE0XFx1RDEzMFxcdUQxNENcXHVEMTY4XFx1RDE4NFxcdUQxQTBcXHVEMUJDXFx1RDFEOFxcdUQxRjRcXHVEMjEwXFx1RDIyQ1xcdUQyNDhcXHVEMjY0XFx1RDI4MFxcdUQyOUNcXHVEMkI4XFx1RDJENFxcdUQyRjBcXHVEMzBDXFx1RDMyOFxcdUQzNDRcXHVEMzYwXFx1RDM3Q1xcdUQzOThcXHVEM0I0XFx1RDNEMFxcdUQzRUNcXHVENDA4XFx1RDQyNFxcdUQ0NDBcXHVENDVDXFx1RDQ3OFxcdUQ0OTRcXHVENEIwXFx1RDRDQ1xcdUQ0RThcXHVENTA0XFx1RDUyMFxcdUQ1M0NcXHVENTU4XFx1RDU3NFxcdUQ1OTBcXHVENUFDXFx1RDVDOFxcdUQ1RTRcXHVENjAwXFx1RDYxQ1xcdUQ2MzhcXHVENjU0XFx1RDY3MFxcdUQ2OENcXHVENkE4XFx1RDZDNFxcdUQ2RTBcXHVENkZDXFx1RDcxOFxcdUQ3MzRcXHVENzUwXFx1RDc2Q1xcdUQ3ODhdJC87XG52YXIgcmVMVlQgPSAvXltcXHVBQzAxLVxcdUFDMUJcXHVBQzFELVxcdUFDMzdcXHVBQzM5LVxcdUFDNTNcXHVBQzU1LVxcdUFDNkZcXHVBQzcxLVxcdUFDOEJcXHVBQzhELVxcdUFDQTdcXHVBQ0E5LVxcdUFDQzNcXHVBQ0M1LVxcdUFDREZcXHVBQ0UxLVxcdUFDRkJcXHVBQ0ZELVxcdUFEMTdcXHVBRDE5LVxcdUFEMzNcXHVBRDM1LVxcdUFENEZcXHVBRDUxLVxcdUFENkJcXHVBRDZELVxcdUFEODdcXHVBRDg5LVxcdUFEQTNcXHVBREE1LVxcdUFEQkZcXHVBREMxLVxcdUFEREJcXHVBRERELVxcdUFERjdcXHVBREY5LVxcdUFFMTNcXHVBRTE1LVxcdUFFMkZcXHVBRTMxLVxcdUFFNEJcXHVBRTRELVxcdUFFNjdcXHVBRTY5LVxcdUFFODNcXHVBRTg1LVxcdUFFOUZcXHVBRUExLVxcdUFFQkJcXHVBRUJELVxcdUFFRDdcXHVBRUQ5LVxcdUFFRjNcXHVBRUY1LVxcdUFGMEZcXHVBRjExLVxcdUFGMkJcXHVBRjJELVxcdUFGNDdcXHVBRjQ5LVxcdUFGNjNcXHVBRjY1LVxcdUFGN0ZcXHVBRjgxLVxcdUFGOUJcXHVBRjlELVxcdUFGQjdcXHVBRkI5LVxcdUFGRDNcXHVBRkQ1LVxcdUFGRUZcXHVBRkYxLVxcdUIwMEJcXHVCMDBELVxcdUIwMjdcXHVCMDI5LVxcdUIwNDNcXHVCMDQ1LVxcdUIwNUZcXHVCMDYxLVxcdUIwN0JcXHVCMDdELVxcdUIwOTdcXHVCMDk5LVxcdUIwQjNcXHVCMEI1LVxcdUIwQ0ZcXHVCMEQxLVxcdUIwRUJcXHVCMEVELVxcdUIxMDdcXHVCMTA5LVxcdUIxMjNcXHVCMTI1LVxcdUIxM0ZcXHVCMTQxLVxcdUIxNUJcXHVCMTVELVxcdUIxNzdcXHVCMTc5LVxcdUIxOTNcXHVCMTk1LVxcdUIxQUZcXHVCMUIxLVxcdUIxQ0JcXHVCMUNELVxcdUIxRTdcXHVCMUU5LVxcdUIyMDNcXHVCMjA1LVxcdUIyMUZcXHVCMjIxLVxcdUIyM0JcXHVCMjNELVxcdUIyNTdcXHVCMjU5LVxcdUIyNzNcXHVCMjc1LVxcdUIyOEZcXHVCMjkxLVxcdUIyQUJcXHVCMkFELVxcdUIyQzdcXHVCMkM5LVxcdUIyRTNcXHVCMkU1LVxcdUIyRkZcXHVCMzAxLVxcdUIzMUJcXHVCMzFELVxcdUIzMzdcXHVCMzM5LVxcdUIzNTNcXHVCMzU1LVxcdUIzNkZcXHVCMzcxLVxcdUIzOEJcXHVCMzhELVxcdUIzQTdcXHVCM0E5LVxcdUIzQzNcXHVCM0M1LVxcdUIzREZcXHVCM0UxLVxcdUIzRkJcXHVCM0ZELVxcdUI0MTdcXHVCNDE5LVxcdUI0MzNcXHVCNDM1LVxcdUI0NEZcXHVCNDUxLVxcdUI0NkJcXHVCNDZELVxcdUI0ODdcXHVCNDg5LVxcdUI0QTNcXHVCNEE1LVxcdUI0QkZcXHVCNEMxLVxcdUI0REJcXHVCNERELVxcdUI0RjdcXHVCNEY5LVxcdUI1MTNcXHVCNTE1LVxcdUI1MkZcXHVCNTMxLVxcdUI1NEJcXHVCNTRELVxcdUI1NjdcXHVCNTY5LVxcdUI1ODNcXHVCNTg1LVxcdUI1OUZcXHVCNUExLVxcdUI1QkJcXHVCNUJELVxcdUI1RDdcXHVCNUQ5LVxcdUI1RjNcXHVCNUY1LVxcdUI2MEZcXHVCNjExLVxcdUI2MkJcXHVCNjJELVxcdUI2NDdcXHVCNjQ5LVxcdUI2NjNcXHVCNjY1LVxcdUI2N0ZcXHVCNjgxLVxcdUI2OUJcXHVCNjlELVxcdUI2QjdcXHVCNkI5LVxcdUI2RDNcXHVCNkQ1LVxcdUI2RUZcXHVCNkYxLVxcdUI3MEJcXHVCNzBELVxcdUI3MjdcXHVCNzI5LVxcdUI3NDNcXHVCNzQ1LVxcdUI3NUZcXHVCNzYxLVxcdUI3N0JcXHVCNzdELVxcdUI3OTdcXHVCNzk5LVxcdUI3QjNcXHVCN0I1LVxcdUI3Q0ZcXHVCN0QxLVxcdUI3RUJcXHVCN0VELVxcdUI4MDdcXHVCODA5LVxcdUI4MjNcXHVCODI1LVxcdUI4M0ZcXHVCODQxLVxcdUI4NUJcXHVCODVELVxcdUI4NzdcXHVCODc5LVxcdUI4OTNcXHVCODk1LVxcdUI4QUZcXHVCOEIxLVxcdUI4Q0JcXHVCOENELVxcdUI4RTdcXHVCOEU5LVxcdUI5MDNcXHVCOTA1LVxcdUI5MUZcXHVCOTIxLVxcdUI5M0JcXHVCOTNELVxcdUI5NTdcXHVCOTU5LVxcdUI5NzNcXHVCOTc1LVxcdUI5OEZcXHVCOTkxLVxcdUI5QUJcXHVCOUFELVxcdUI5QzdcXHVCOUM5LVxcdUI5RTNcXHVCOUU1LVxcdUI5RkZcXHVCQTAxLVxcdUJBMUJcXHVCQTFELVxcdUJBMzdcXHVCQTM5LVxcdUJBNTNcXHVCQTU1LVxcdUJBNkZcXHVCQTcxLVxcdUJBOEJcXHVCQThELVxcdUJBQTdcXHVCQUE5LVxcdUJBQzNcXHVCQUM1LVxcdUJBREZcXHVCQUUxLVxcdUJBRkJcXHVCQUZELVxcdUJCMTdcXHVCQjE5LVxcdUJCMzNcXHVCQjM1LVxcdUJCNEZcXHVCQjUxLVxcdUJCNkJcXHVCQjZELVxcdUJCODdcXHVCQjg5LVxcdUJCQTNcXHVCQkE1LVxcdUJCQkZcXHVCQkMxLVxcdUJCREJcXHVCQkRELVxcdUJCRjdcXHVCQkY5LVxcdUJDMTNcXHVCQzE1LVxcdUJDMkZcXHVCQzMxLVxcdUJDNEJcXHVCQzRELVxcdUJDNjdcXHVCQzY5LVxcdUJDODNcXHVCQzg1LVxcdUJDOUZcXHVCQ0ExLVxcdUJDQkJcXHVCQ0JELVxcdUJDRDdcXHVCQ0Q5LVxcdUJDRjNcXHVCQ0Y1LVxcdUJEMEZcXHVCRDExLVxcdUJEMkJcXHVCRDJELVxcdUJENDdcXHVCRDQ5LVxcdUJENjNcXHVCRDY1LVxcdUJEN0ZcXHVCRDgxLVxcdUJEOUJcXHVCRDlELVxcdUJEQjdcXHVCREI5LVxcdUJERDNcXHVCREQ1LVxcdUJERUZcXHVCREYxLVxcdUJFMEJcXHVCRTBELVxcdUJFMjdcXHVCRTI5LVxcdUJFNDNcXHVCRTQ1LVxcdUJFNUZcXHVCRTYxLVxcdUJFN0JcXHVCRTdELVxcdUJFOTdcXHVCRTk5LVxcdUJFQjNcXHVCRUI1LVxcdUJFQ0ZcXHVCRUQxLVxcdUJFRUJcXHVCRUVELVxcdUJGMDdcXHVCRjA5LVxcdUJGMjNcXHVCRjI1LVxcdUJGM0ZcXHVCRjQxLVxcdUJGNUJcXHVCRjVELVxcdUJGNzdcXHVCRjc5LVxcdUJGOTNcXHVCRjk1LVxcdUJGQUZcXHVCRkIxLVxcdUJGQ0JcXHVCRkNELVxcdUJGRTdcXHVCRkU5LVxcdUMwMDNcXHVDMDA1LVxcdUMwMUZcXHVDMDIxLVxcdUMwM0JcXHVDMDNELVxcdUMwNTdcXHVDMDU5LVxcdUMwNzNcXHVDMDc1LVxcdUMwOEZcXHVDMDkxLVxcdUMwQUJcXHVDMEFELVxcdUMwQzdcXHVDMEM5LVxcdUMwRTNcXHVDMEU1LVxcdUMwRkZcXHVDMTAxLVxcdUMxMUJcXHVDMTFELVxcdUMxMzdcXHVDMTM5LVxcdUMxNTNcXHVDMTU1LVxcdUMxNkZcXHVDMTcxLVxcdUMxOEJcXHVDMThELVxcdUMxQTdcXHVDMUE5LVxcdUMxQzNcXHVDMUM1LVxcdUMxREZcXHVDMUUxLVxcdUMxRkJcXHVDMUZELVxcdUMyMTdcXHVDMjE5LVxcdUMyMzNcXHVDMjM1LVxcdUMyNEZcXHVDMjUxLVxcdUMyNkJcXHVDMjZELVxcdUMyODdcXHVDMjg5LVxcdUMyQTNcXHVDMkE1LVxcdUMyQkZcXHVDMkMxLVxcdUMyREJcXHVDMkRELVxcdUMyRjdcXHVDMkY5LVxcdUMzMTNcXHVDMzE1LVxcdUMzMkZcXHVDMzMxLVxcdUMzNEJcXHVDMzRELVxcdUMzNjdcXHVDMzY5LVxcdUMzODNcXHVDMzg1LVxcdUMzOUZcXHVDM0ExLVxcdUMzQkJcXHVDM0JELVxcdUMzRDdcXHVDM0Q5LVxcdUMzRjNcXHVDM0Y1LVxcdUM0MEZcXHVDNDExLVxcdUM0MkJcXHVDNDJELVxcdUM0NDdcXHVDNDQ5LVxcdUM0NjNcXHVDNDY1LVxcdUM0N0ZcXHVDNDgxLVxcdUM0OUJcXHVDNDlELVxcdUM0QjdcXHVDNEI5LVxcdUM0RDNcXHVDNEQ1LVxcdUM0RUZcXHVDNEYxLVxcdUM1MEJcXHVDNTBELVxcdUM1MjdcXHVDNTI5LVxcdUM1NDNcXHVDNTQ1LVxcdUM1NUZcXHVDNTYxLVxcdUM1N0JcXHVDNTdELVxcdUM1OTdcXHVDNTk5LVxcdUM1QjNcXHVDNUI1LVxcdUM1Q0ZcXHVDNUQxLVxcdUM1RUJcXHVDNUVELVxcdUM2MDdcXHVDNjA5LVxcdUM2MjNcXHVDNjI1LVxcdUM2M0ZcXHVDNjQxLVxcdUM2NUJcXHVDNjVELVxcdUM2NzdcXHVDNjc5LVxcdUM2OTNcXHVDNjk1LVxcdUM2QUZcXHVDNkIxLVxcdUM2Q0JcXHVDNkNELVxcdUM2RTdcXHVDNkU5LVxcdUM3MDNcXHVDNzA1LVxcdUM3MUZcXHVDNzIxLVxcdUM3M0JcXHVDNzNELVxcdUM3NTdcXHVDNzU5LVxcdUM3NzNcXHVDNzc1LVxcdUM3OEZcXHVDNzkxLVxcdUM3QUJcXHVDN0FELVxcdUM3QzdcXHVDN0M5LVxcdUM3RTNcXHVDN0U1LVxcdUM3RkZcXHVDODAxLVxcdUM4MUJcXHVDODFELVxcdUM4MzdcXHVDODM5LVxcdUM4NTNcXHVDODU1LVxcdUM4NkZcXHVDODcxLVxcdUM4OEJcXHVDODhELVxcdUM4QTdcXHVDOEE5LVxcdUM4QzNcXHVDOEM1LVxcdUM4REZcXHVDOEUxLVxcdUM4RkJcXHVDOEZELVxcdUM5MTdcXHVDOTE5LVxcdUM5MzNcXHVDOTM1LVxcdUM5NEZcXHVDOTUxLVxcdUM5NkJcXHVDOTZELVxcdUM5ODdcXHVDOTg5LVxcdUM5QTNcXHVDOUE1LVxcdUM5QkZcXHVDOUMxLVxcdUM5REJcXHVDOURELVxcdUM5RjdcXHVDOUY5LVxcdUNBMTNcXHVDQTE1LVxcdUNBMkZcXHVDQTMxLVxcdUNBNEJcXHVDQTRELVxcdUNBNjdcXHVDQTY5LVxcdUNBODNcXHVDQTg1LVxcdUNBOUZcXHVDQUExLVxcdUNBQkJcXHVDQUJELVxcdUNBRDdcXHVDQUQ5LVxcdUNBRjNcXHVDQUY1LVxcdUNCMEZcXHVDQjExLVxcdUNCMkJcXHVDQjJELVxcdUNCNDdcXHVDQjQ5LVxcdUNCNjNcXHVDQjY1LVxcdUNCN0ZcXHVDQjgxLVxcdUNCOUJcXHVDQjlELVxcdUNCQjdcXHVDQkI5LVxcdUNCRDNcXHVDQkQ1LVxcdUNCRUZcXHVDQkYxLVxcdUNDMEJcXHVDQzBELVxcdUNDMjdcXHVDQzI5LVxcdUNDNDNcXHVDQzQ1LVxcdUNDNUZcXHVDQzYxLVxcdUNDN0JcXHVDQzdELVxcdUNDOTdcXHVDQzk5LVxcdUNDQjNcXHVDQ0I1LVxcdUNDQ0ZcXHVDQ0QxLVxcdUNDRUJcXHVDQ0VELVxcdUNEMDdcXHVDRDA5LVxcdUNEMjNcXHVDRDI1LVxcdUNEM0ZcXHVDRDQxLVxcdUNENUJcXHVDRDVELVxcdUNENzdcXHVDRDc5LVxcdUNEOTNcXHVDRDk1LVxcdUNEQUZcXHVDREIxLVxcdUNEQ0JcXHVDRENELVxcdUNERTdcXHVDREU5LVxcdUNFMDNcXHVDRTA1LVxcdUNFMUZcXHVDRTIxLVxcdUNFM0JcXHVDRTNELVxcdUNFNTdcXHVDRTU5LVxcdUNFNzNcXHVDRTc1LVxcdUNFOEZcXHVDRTkxLVxcdUNFQUJcXHVDRUFELVxcdUNFQzdcXHVDRUM5LVxcdUNFRTNcXHVDRUU1LVxcdUNFRkZcXHVDRjAxLVxcdUNGMUJcXHVDRjFELVxcdUNGMzdcXHVDRjM5LVxcdUNGNTNcXHVDRjU1LVxcdUNGNkZcXHVDRjcxLVxcdUNGOEJcXHVDRjhELVxcdUNGQTdcXHVDRkE5LVxcdUNGQzNcXHVDRkM1LVxcdUNGREZcXHVDRkUxLVxcdUNGRkJcXHVDRkZELVxcdUQwMTdcXHVEMDE5LVxcdUQwMzNcXHVEMDM1LVxcdUQwNEZcXHVEMDUxLVxcdUQwNkJcXHVEMDZELVxcdUQwODdcXHVEMDg5LVxcdUQwQTNcXHVEMEE1LVxcdUQwQkZcXHVEMEMxLVxcdUQwREJcXHVEMERELVxcdUQwRjdcXHVEMEY5LVxcdUQxMTNcXHVEMTE1LVxcdUQxMkZcXHVEMTMxLVxcdUQxNEJcXHVEMTRELVxcdUQxNjdcXHVEMTY5LVxcdUQxODNcXHVEMTg1LVxcdUQxOUZcXHVEMUExLVxcdUQxQkJcXHVEMUJELVxcdUQxRDdcXHVEMUQ5LVxcdUQxRjNcXHVEMUY1LVxcdUQyMEZcXHVEMjExLVxcdUQyMkJcXHVEMjJELVxcdUQyNDdcXHVEMjQ5LVxcdUQyNjNcXHVEMjY1LVxcdUQyN0ZcXHVEMjgxLVxcdUQyOUJcXHVEMjlELVxcdUQyQjdcXHVEMkI5LVxcdUQyRDNcXHVEMkQ1LVxcdUQyRUZcXHVEMkYxLVxcdUQzMEJcXHVEMzBELVxcdUQzMjdcXHVEMzI5LVxcdUQzNDNcXHVEMzQ1LVxcdUQzNUZcXHVEMzYxLVxcdUQzN0JcXHVEMzdELVxcdUQzOTdcXHVEMzk5LVxcdUQzQjNcXHVEM0I1LVxcdUQzQ0ZcXHVEM0QxLVxcdUQzRUJcXHVEM0VELVxcdUQ0MDdcXHVENDA5LVxcdUQ0MjNcXHVENDI1LVxcdUQ0M0ZcXHVENDQxLVxcdUQ0NUJcXHVENDVELVxcdUQ0NzdcXHVENDc5LVxcdUQ0OTNcXHVENDk1LVxcdUQ0QUZcXHVENEIxLVxcdUQ0Q0JcXHVENENELVxcdUQ0RTdcXHVENEU5LVxcdUQ1MDNcXHVENTA1LVxcdUQ1MUZcXHVENTIxLVxcdUQ1M0JcXHVENTNELVxcdUQ1NTdcXHVENTU5LVxcdUQ1NzNcXHVENTc1LVxcdUQ1OEZcXHVENTkxLVxcdUQ1QUJcXHVENUFELVxcdUQ1QzdcXHVENUM5LVxcdUQ1RTNcXHVENUU1LVxcdUQ1RkZcXHVENjAxLVxcdUQ2MUJcXHVENjFELVxcdUQ2MzdcXHVENjM5LVxcdUQ2NTNcXHVENjU1LVxcdUQ2NkZcXHVENjcxLVxcdUQ2OEJcXHVENjhELVxcdUQ2QTdcXHVENkE5LVxcdUQ2QzNcXHVENkM1LVxcdUQ2REZcXHVENkUxLVxcdUQ2RkJcXHVENkZELVxcdUQ3MTdcXHVENzE5LVxcdUQ3MzNcXHVENzM1LVxcdUQ3NEZcXHVENzUxLVxcdUQ3NkJcXHVENzZELVxcdUQ3ODdcXHVENzg5LVxcdUQ3QTNdJC87XG52YXIgcmVFeHRQaWN0ID0gL14oPzpbXFx4QTlcXHhBRVxcdTIwM0NcXHUyMDQ5XFx1MjEyMlxcdTIxMzlcXHUyMTk0LVxcdTIxOTlcXHUyMUE5XFx1MjFBQVxcdTIzMUFcXHUyMzFCXFx1MjMyOFxcdTIzODhcXHUyM0NGXFx1MjNFOS1cXHUyM0YzXFx1MjNGOC1cXHUyM0ZBXFx1MjRDMlxcdTI1QUFcXHUyNUFCXFx1MjVCNlxcdTI1QzBcXHUyNUZCLVxcdTI1RkVcXHUyNjAwLVxcdTI2MDVcXHUyNjA3LVxcdTI2MTJcXHUyNjE0LVxcdTI2ODVcXHUyNjkwLVxcdTI3MDVcXHUyNzA4LVxcdTI3MTJcXHUyNzE0XFx1MjcxNlxcdTI3MURcXHUyNzIxXFx1MjcyOFxcdTI3MzNcXHUyNzM0XFx1Mjc0NFxcdTI3NDdcXHUyNzRDXFx1Mjc0RVxcdTI3NTMtXFx1Mjc1NVxcdTI3NTdcXHUyNzYzLVxcdTI3NjdcXHUyNzk1LVxcdTI3OTdcXHUyN0ExXFx1MjdCMFxcdTI3QkZcXHUyOTM0XFx1MjkzNVxcdTJCMDUtXFx1MkIwN1xcdTJCMUJcXHUyQjFDXFx1MkI1MFxcdTJCNTVcXHUzMDMwXFx1MzAzRFxcdTMyOTdcXHUzMjk5XXxcXHVEODNDW1xcdURDMDAtXFx1RENGRlxcdUREMEQtXFx1REQwRlxcdUREMkZcXHVERDZDLVxcdURENzFcXHVERDdFXFx1REQ3RlxcdUREOEVcXHVERDkxLVxcdUREOUFcXHVEREFELVxcdURERTVcXHVERTAxLVxcdURFMEZcXHVERTFBXFx1REUyRlxcdURFMzItXFx1REUzQVxcdURFM0MtXFx1REUzRlxcdURFNDktXFx1REZGQV18XFx1RDgzRFtcXHVEQzAwLVxcdUREM0RcXHVERDQ2LVxcdURFNEZcXHVERTgwLVxcdURFRkZcXHVERjc0LVxcdURGN0ZcXHVERkQ1LVxcdURGRkZdfFxcdUQ4M0VbXFx1REMwQy1cXHVEQzBGXFx1REM0OC1cXHVEQzRGXFx1REM1QS1cXHVEQzVGXFx1REM4OC1cXHVEQzhGXFx1RENBRS1cXHVEQ0ZGXFx1REQwQy1cXHVERDNBXFx1REQzQy1cXHVERDQ1XFx1REQ0Ny1cXHVERUZGXXxcXHVEODNGW1xcdURDMDAtXFx1REZGRF0pJC87XG52YXIgZ2V0Q29kZXBvaW50VHlwZSA9IChjaGFyLCBjb2RlKSA9PiB7XG4gIHZhciB0eXBlID0gQ29kZXBvaW50VHlwZS5Bbnk7XG4gIGlmIChjaGFyLnNlYXJjaChyZUV4dGVuZCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkV4dGVuZDtcbiAgfVxuICBpZiAoY29kZSA9PT0gMHgyMDBkKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlpXSjtcbiAgfVxuICBpZiAoY29kZSA+PSAweDFmMWU2ICYmIGNvZGUgPD0gMHgxZjFmZikge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5SSTtcbiAgfVxuICBpZiAoY2hhci5zZWFyY2gocmVQcmVwZW5kKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuUHJlcGVuZDtcbiAgfVxuICBpZiAoY2hhci5zZWFyY2gocmVTcGFjaW5nTWFyaykgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlNwYWNpbmdNYXJrO1xuICB9XG4gIGlmIChjaGFyLnNlYXJjaChyZUwpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5MO1xuICB9XG4gIGlmIChjaGFyLnNlYXJjaChyZVYpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5WO1xuICB9XG4gIGlmIChjaGFyLnNlYXJjaChyZVQpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5UO1xuICB9XG4gIGlmIChjaGFyLnNlYXJjaChyZUxWKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuTFY7XG4gIH1cbiAgaWYgKGNoYXIuc2VhcmNoKHJlTFZUKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuTFZUO1xuICB9XG4gIGlmIChjaGFyLnNlYXJjaChyZUV4dFBpY3QpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5FeHRQaWN0O1xuICB9XG4gIHJldHVybiB0eXBlO1xufTtcbmZ1bmN0aW9uIGludGVyc2VjdHMoeCwgeSkge1xuICByZXR1cm4gKHggJiB5KSAhPT0gMDtcbn1cbnZhciBOb25Cb3VuZGFyeVBhaXJzID0gW1xuLy8gR0I2XG5bQ29kZXBvaW50VHlwZS5MLCBDb2RlcG9pbnRUeXBlLkwgfCBDb2RlcG9pbnRUeXBlLlYgfCBDb2RlcG9pbnRUeXBlLkxWIHwgQ29kZXBvaW50VHlwZS5MVlRdLFxuLy8gR0I3XG5bQ29kZXBvaW50VHlwZS5MViB8IENvZGVwb2ludFR5cGUuViwgQ29kZXBvaW50VHlwZS5WIHwgQ29kZXBvaW50VHlwZS5UXSxcbi8vIEdCOFxuW0NvZGVwb2ludFR5cGUuTFZUIHwgQ29kZXBvaW50VHlwZS5ULCBDb2RlcG9pbnRUeXBlLlRdLFxuLy8gR0I5XG5bQ29kZXBvaW50VHlwZS5BbnksIENvZGVwb2ludFR5cGUuRXh0ZW5kIHwgQ29kZXBvaW50VHlwZS5aV0pdLFxuLy8gR0I5YVxuW0NvZGVwb2ludFR5cGUuQW55LCBDb2RlcG9pbnRUeXBlLlNwYWNpbmdNYXJrXSxcbi8vIEdCOWJcbltDb2RlcG9pbnRUeXBlLlByZXBlbmQsIENvZGVwb2ludFR5cGUuQW55XSxcbi8vIEdCMTFcbltDb2RlcG9pbnRUeXBlLlpXSiwgQ29kZXBvaW50VHlwZS5FeHRQaWN0XSxcbi8vIEdCMTIgYW5kIEdCMTNcbltDb2RlcG9pbnRUeXBlLlJJLCBDb2RlcG9pbnRUeXBlLlJJXV07XG5mdW5jdGlvbiBpc0JvdW5kYXJ5UGFpcihsZWZ0LCByaWdodCkge1xuICByZXR1cm4gTm9uQm91bmRhcnlQYWlycy5maW5kSW5kZXgociA9PiBpbnRlcnNlY3RzKGxlZnQsIHJbMF0pICYmIGludGVyc2VjdHMocmlnaHQsIHJbMV0pKSA9PT0gLTE7XG59XG52YXIgZW5kaW5nRW1vamlaV0ogPSAvKD86W1xceEE5XFx4QUVcXHUyMDNDXFx1MjA0OVxcdTIxMjJcXHUyMTM5XFx1MjE5NC1cXHUyMTk5XFx1MjFBOVxcdTIxQUFcXHUyMzFBXFx1MjMxQlxcdTIzMjhcXHUyMzg4XFx1MjNDRlxcdTIzRTktXFx1MjNGM1xcdTIzRjgtXFx1MjNGQVxcdTI0QzJcXHUyNUFBXFx1MjVBQlxcdTI1QjZcXHUyNUMwXFx1MjVGQi1cXHUyNUZFXFx1MjYwMC1cXHUyNjA1XFx1MjYwNy1cXHUyNjEyXFx1MjYxNC1cXHUyNjg1XFx1MjY5MC1cXHUyNzA1XFx1MjcwOC1cXHUyNzEyXFx1MjcxNFxcdTI3MTZcXHUyNzFEXFx1MjcyMVxcdTI3MjhcXHUyNzMzXFx1MjczNFxcdTI3NDRcXHUyNzQ3XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzU3XFx1Mjc2My1cXHUyNzY3XFx1Mjc5NS1cXHUyNzk3XFx1MjdBMVxcdTI3QjBcXHUyN0JGXFx1MjkzNFxcdTI5MzVcXHUyQjA1LVxcdTJCMDdcXHUyQjFCXFx1MkIxQ1xcdTJCNTBcXHUyQjU1XFx1MzAzMFxcdTMwM0RcXHUzMjk3XFx1MzI5OV18XFx1RDgzQ1tcXHVEQzAwLVxcdURDRkZcXHVERDBELVxcdUREMEZcXHVERDJGXFx1REQ2Qy1cXHVERDcxXFx1REQ3RVxcdUREN0ZcXHVERDhFXFx1REQ5MS1cXHVERDlBXFx1RERBRC1cXHVEREU1XFx1REUwMS1cXHVERTBGXFx1REUxQVxcdURFMkZcXHVERTMyLVxcdURFM0FcXHVERTNDLVxcdURFM0ZcXHVERTQ5LVxcdURGRkFdfFxcdUQ4M0RbXFx1REMwMC1cXHVERDNEXFx1REQ0Ni1cXHVERTRGXFx1REU4MC1cXHVERUZGXFx1REY3NC1cXHVERjdGXFx1REZENS1cXHVERkZGXXxcXHVEODNFW1xcdURDMEMtXFx1REMwRlxcdURDNDgtXFx1REM0RlxcdURDNUEtXFx1REM1RlxcdURDODgtXFx1REM4RlxcdURDQUUtXFx1RENGRlxcdUREMEMtXFx1REQzQVxcdUREM0MtXFx1REQ0NVxcdURENDctXFx1REVGRl18XFx1RDgzRltcXHVEQzAwLVxcdURGRkRdKSg/OltcXHUwMzAwLVxcdTAzNkZcXHUwNDgzLVxcdTA0ODlcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNjEwLVxcdTA2MUFcXHUwNjRCLVxcdTA2NUZcXHUwNjcwXFx1MDZENi1cXHUwNkRDXFx1MDZERi1cXHUwNkU0XFx1MDZFN1xcdTA2RThcXHUwNkVBLVxcdTA2RURcXHUwNzExXFx1MDczMC1cXHUwNzRBXFx1MDdBNi1cXHUwN0IwXFx1MDdFQi1cXHUwN0YzXFx1MDdGRFxcdTA4MTYtXFx1MDgxOVxcdTA4MUItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyRFxcdTA4NTktXFx1MDg1QlxcdTA4OTgtXFx1MDg5RlxcdTA4Q0EtXFx1MDhFMVxcdTA4RTMtXFx1MDkwMlxcdTA5M0FcXHUwOTNDXFx1MDk0MS1cXHUwOTQ4XFx1MDk0RFxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk4MVxcdTA5QkNcXHUwOUJFXFx1MDlDMS1cXHUwOUM0XFx1MDlDRFxcdTA5RDdcXHUwOUUyXFx1MDlFM1xcdTA5RkVcXHUwQTAxXFx1MEEwMlxcdTBBM0NcXHUwQTQxXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNzBcXHUwQTcxXFx1MEE3NVxcdTBBODFcXHUwQTgyXFx1MEFCQ1xcdTBBQzEtXFx1MEFDNVxcdTBBQzdcXHUwQUM4XFx1MEFDRFxcdTBBRTJcXHUwQUUzXFx1MEFGQS1cXHUwQUZGXFx1MEIwMVxcdTBCM0NcXHUwQjNFXFx1MEIzRlxcdTBCNDEtXFx1MEI0NFxcdTBCNERcXHUwQjU1LVxcdTBCNTdcXHUwQjYyXFx1MEI2M1xcdTBCODJcXHUwQkJFXFx1MEJDMFxcdTBCQ0RcXHUwQkQ3XFx1MEMwMFxcdTBDMDRcXHUwQzNDXFx1MEMzRS1cXHUwQzQwXFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzYyXFx1MEM2M1xcdTBDODFcXHUwQ0JDXFx1MENCRlxcdTBDQzJcXHUwQ0M2XFx1MENDQ1xcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDRTJcXHUwQ0UzXFx1MEQwMFxcdTBEMDFcXHUwRDNCXFx1MEQzQ1xcdTBEM0VcXHUwRDQxLVxcdTBENDRcXHUwRDREXFx1MEQ1N1xcdTBENjJcXHUwRDYzXFx1MEQ4MVxcdTBEQ0FcXHUwRENGXFx1MEREMi1cXHUwREQ0XFx1MERENlxcdTBEREZcXHUwRTMxXFx1MEUzNC1cXHUwRTNBXFx1MEU0Ny1cXHUwRTRFXFx1MEVCMVxcdTBFQjQtXFx1MEVCQ1xcdTBFQzgtXFx1MEVDRVxcdTBGMThcXHUwRjE5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEY3MS1cXHUwRjdFXFx1MEY4MC1cXHUwRjg0XFx1MEY4NlxcdTBGODdcXHUwRjhELVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAyRC1cXHUxMDMwXFx1MTAzMi1cXHUxMDM3XFx1MTAzOVxcdTEwM0FcXHUxMDNEXFx1MTAzRVxcdTEwNThcXHUxMDU5XFx1MTA1RS1cXHUxMDYwXFx1MTA3MS1cXHUxMDc0XFx1MTA4MlxcdTEwODVcXHUxMDg2XFx1MTA4RFxcdTEwOURcXHUxMzVELVxcdTEzNUZcXHUxNzEyLVxcdTE3MTRcXHUxNzMyXFx1MTczM1xcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN0I0XFx1MTdCNVxcdTE3QjctXFx1MTdCRFxcdTE3QzZcXHUxN0M5LVxcdTE3RDNcXHUxN0REXFx1MTgwQi1cXHUxODBEXFx1MTgwRlxcdTE4ODVcXHUxODg2XFx1MThBOVxcdTE5MjAtXFx1MTkyMlxcdTE5MjdcXHUxOTI4XFx1MTkzMlxcdTE5MzktXFx1MTkzQlxcdTFBMTdcXHUxQTE4XFx1MUExQlxcdTFBNTZcXHUxQTU4LVxcdTFBNUVcXHUxQTYwXFx1MUE2MlxcdTFBNjUtXFx1MUE2Q1xcdTFBNzMtXFx1MUE3Q1xcdTFBN0ZcXHUxQUIwLVxcdTFBQ0VcXHUxQjAwLVxcdTFCMDNcXHUxQjM0LVxcdTFCM0FcXHUxQjNDXFx1MUI0MlxcdTFCNkItXFx1MUI3M1xcdTFCODBcXHUxQjgxXFx1MUJBMi1cXHUxQkE1XFx1MUJBOFxcdTFCQTlcXHUxQkFCLVxcdTFCQURcXHUxQkU2XFx1MUJFOFxcdTFCRTlcXHUxQkVEXFx1MUJFRi1cXHUxQkYxXFx1MUMyQy1cXHUxQzMzXFx1MUMzNlxcdTFDMzdcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRTBcXHUxQ0UyLVxcdTFDRThcXHUxQ0VEXFx1MUNGNFxcdTFDRjhcXHUxQ0Y5XFx1MURDMC1cXHUxREZGXFx1MjAwQ1xcdTIwRDAtXFx1MjBGMFxcdTJDRUYtXFx1MkNGMVxcdTJEN0ZcXHUyREUwLVxcdTJERkZcXHUzMDJBLVxcdTMwMkZcXHUzMDk5XFx1MzA5QVxcdUE2NkYtXFx1QTY3MlxcdUE2NzQtXFx1QTY3RFxcdUE2OUVcXHVBNjlGXFx1QTZGMFxcdUE2RjFcXHVBODAyXFx1QTgwNlxcdUE4MEJcXHVBODI1XFx1QTgyNlxcdUE4MkNcXHVBOEM0XFx1QThDNVxcdUE4RTAtXFx1QThGMVxcdUE4RkZcXHVBOTI2LVxcdUE5MkRcXHVBOTQ3LVxcdUE5NTFcXHVBOTgwLVxcdUE5ODJcXHVBOUIzXFx1QTlCNi1cXHVBOUI5XFx1QTlCQ1xcdUE5QkRcXHVBOUU1XFx1QUEyOS1cXHVBQTJFXFx1QUEzMVxcdUFBMzJcXHVBQTM1XFx1QUEzNlxcdUFBNDNcXHVBQTRDXFx1QUE3Q1xcdUFBQjBcXHVBQUIyLVxcdUFBQjRcXHVBQUI3XFx1QUFCOFxcdUFBQkVcXHVBQUJGXFx1QUFDMVxcdUFBRUNcXHVBQUVEXFx1QUFGNlxcdUFCRTVcXHVBQkU4XFx1QUJFRFxcdUZCMUVcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkZcXHVGRjlFXFx1RkY5Rl18XFx1RDgwMFtcXHVEREZEXFx1REVFMFxcdURGNzYtXFx1REY3QV18XFx1RDgwMltcXHVERTAxLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUwRlxcdURFMzgtXFx1REUzQVxcdURFM0ZcXHVERUU1XFx1REVFNl18XFx1RDgwM1tcXHVERDI0LVxcdUREMjdcXHVERUFCXFx1REVBQ1xcdURFRkQtXFx1REVGRlxcdURGNDYtXFx1REY1MFxcdURGODItXFx1REY4NV18XFx1RDgwNFtcXHVEQzAxXFx1REMzOC1cXHVEQzQ2XFx1REM3MFxcdURDNzNcXHVEQzc0XFx1REM3Ri1cXHVEQzgxXFx1RENCMy1cXHVEQ0I2XFx1RENCOVxcdURDQkFcXHVEQ0MyXFx1REQwMC1cXHVERDAyXFx1REQyNy1cXHVERDJCXFx1REQyRC1cXHVERDM0XFx1REQ3M1xcdUREODBcXHVERDgxXFx1RERCNi1cXHVEREJFXFx1RERDOS1cXHVERENDXFx1RERDRlxcdURFMkYtXFx1REUzMVxcdURFMzRcXHVERTM2XFx1REUzN1xcdURFM0VcXHVERTQxXFx1REVERlxcdURFRTMtXFx1REVFQVxcdURGMDBcXHVERjAxXFx1REYzQlxcdURGM0NcXHVERjNFXFx1REY0MFxcdURGNTdcXHVERjY2LVxcdURGNkNcXHVERjcwLVxcdURGNzRdfFxcdUQ4MDVbXFx1REMzOC1cXHVEQzNGXFx1REM0Mi1cXHVEQzQ0XFx1REM0NlxcdURDNUVcXHVEQ0IwXFx1RENCMy1cXHVEQ0I4XFx1RENCQVxcdURDQkRcXHVEQ0JGXFx1RENDMFxcdURDQzJcXHVEQ0MzXFx1RERBRlxcdUREQjItXFx1RERCNVxcdUREQkNcXHVEREJEXFx1RERCRlxcdUREQzBcXHVERERDXFx1RERERFxcdURFMzMtXFx1REUzQVxcdURFM0RcXHVERTNGXFx1REU0MFxcdURFQUJcXHVERUFEXFx1REVCMC1cXHVERUI1XFx1REVCN1xcdURGMUQtXFx1REYxRlxcdURGMjItXFx1REYyNVxcdURGMjctXFx1REYyQl18XFx1RDgwNltcXHVEQzJGLVxcdURDMzdcXHVEQzM5XFx1REMzQVxcdUREMzBcXHVERDNCXFx1REQzQ1xcdUREM0VcXHVERDQzXFx1RERENC1cXHVEREQ3XFx1REREQVxcdUREREJcXHVEREUwXFx1REUwMS1cXHVERTBBXFx1REUzMy1cXHVERTM4XFx1REUzQi1cXHVERTNFXFx1REU0N1xcdURFNTEtXFx1REU1NlxcdURFNTktXFx1REU1QlxcdURFOEEtXFx1REU5NlxcdURFOThcXHVERTk5XXxcXHVEODA3W1xcdURDMzAtXFx1REMzNlxcdURDMzgtXFx1REMzRFxcdURDM0ZcXHVEQzkyLVxcdURDQTdcXHVEQ0FBLVxcdURDQjBcXHVEQ0IyXFx1RENCM1xcdURDQjVcXHVEQ0I2XFx1REQzMS1cXHVERDM2XFx1REQzQVxcdUREM0NcXHVERDNEXFx1REQzRi1cXHVERDQ1XFx1REQ0N1xcdUREOTBcXHVERDkxXFx1REQ5NVxcdUREOTdcXHVERUYzXFx1REVGNFxcdURGMDBcXHVERjAxXFx1REYzNi1cXHVERjNBXFx1REY0MFxcdURGNDJdfFxcdUQ4MERbXFx1REM0MFxcdURDNDctXFx1REM1NV18XFx1RDgxQVtcXHVERUYwLVxcdURFRjRcXHVERjMwLVxcdURGMzZdfFxcdUQ4MUJbXFx1REY0RlxcdURGOEYtXFx1REY5MlxcdURGRTRdfFxcdUQ4MkZbXFx1REM5RFxcdURDOUVdfFxcdUQ4MzNbXFx1REYwMC1cXHVERjJEXFx1REYzMC1cXHVERjQ2XXxcXHVEODM0W1xcdURENjVcXHVERDY3LVxcdURENjlcXHVERDZFLVxcdURENzJcXHVERDdCLVxcdUREODJcXHVERDg1LVxcdUREOEJcXHVEREFBLVxcdUREQURcXHVERTQyLVxcdURFNDRdfFxcdUQ4MzZbXFx1REUwMC1cXHVERTM2XFx1REUzQi1cXHVERTZDXFx1REU3NVxcdURFODRcXHVERTlCLVxcdURFOUZcXHVERUExLVxcdURFQUZdfFxcdUQ4MzhbXFx1REMwMC1cXHVEQzA2XFx1REMwOC1cXHVEQzE4XFx1REMxQi1cXHVEQzIxXFx1REMyM1xcdURDMjRcXHVEQzI2LVxcdURDMkFcXHVEQzhGXFx1REQzMC1cXHVERDM2XFx1REVBRVxcdURFRUMtXFx1REVFRl18XFx1RDgzOVtcXHVEQ0VDLVxcdURDRUZdfFxcdUQ4M0FbXFx1RENEMC1cXHVEQ0Q2XFx1REQ0NC1cXHVERDRBXXxcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1REI0MFtcXHVEQzIwLVxcdURDN0ZcXHVERDAwLVxcdURERUZdKSpcXHUyMDBEJC87XG52YXIgZW5kc1dpdGhFbW9qaVpXSiA9IHN0ciA9PiB7XG4gIHJldHVybiBzdHIuc2VhcmNoKGVuZGluZ0Vtb2ppWldKKSAhPT0gLTE7XG59O1xudmFyIGVuZGluZ1JJcyA9IC8oPzpcXHVEODNDW1xcdURERTYtXFx1RERGRl0pKyQvZztcbnZhciBlbmRzV2l0aE9kZE51bWJlck9mUklzID0gc3RyID0+IHtcbiAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKGVuZGluZ1JJcyk7XG4gIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBBIFJJIGlzIHJlcHJlc2VudGVkIGJ5IGEgc3Vycm9nYXRlIHBhaXIuXG4gICAgdmFyIG51bVJJcyA9IG1hdGNoWzBdLmxlbmd0aCAvIDI7XG4gICAgcmV0dXJuIG51bVJJcyAlIDIgPT09IDE7XG4gIH1cbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBUZXh0VHJhbnNmb3JtcyA9IHtcbiAgZGVsZXRlKGVkaXRvciwgb3B0aW9ucykge1xuICAgIGVkaXRvci5kZWxldGUob3B0aW9ucyk7XG4gIH0sXG4gIGluc2VydEZyYWdtZW50KGVkaXRvciwgZnJhZ21lbnQsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IuaW5zZXJ0RnJhZ21lbnQoZnJhZ21lbnQsIG9wdGlvbnMpO1xuICB9LFxuICBpbnNlcnRUZXh0KGVkaXRvciwgdGV4dCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgdm9pZHMgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBhdCA9IGdldERlZmF1bHRJbnNlcnRMb2NhdGlvbihlZGl0b3IpXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgYXQgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgICB9XG4gICAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbmQgPSBSYW5nZS5lbmQoYXQpO1xuICAgICAgICAgIGlmICghdm9pZHMgJiYgRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogZW5kXG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gUmFuZ2Uuc3RhcnQoYXQpO1xuICAgICAgICAgIHZhciBzdGFydFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIHN0YXJ0KTtcbiAgICAgICAgICB2YXIgZW5kUmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0LFxuICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgc3RhcnRQb2ludCA9IHN0YXJ0UmVmLnVucmVmKCk7XG4gICAgICAgICAgdmFyIGVuZFBvaW50ID0gZW5kUmVmLnVucmVmKCk7XG4gICAgICAgICAgYXQgPSBzdGFydFBvaW50IHx8IGVuZFBvaW50O1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwge1xuICAgICAgICAgICAgYW5jaG9yOiBhdCxcbiAgICAgICAgICAgIGZvY3VzOiBhdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXZvaWRzICYmIEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICBhdFxuICAgICAgfSkgfHwgRWRpdG9yLmVsZW1lbnRSZWFkT25seShlZGl0b3IsIHtcbiAgICAgICAgYXRcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIG9mZnNldFxuICAgICAgfSA9IGF0O1xuICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgdHlwZTogJ2luc2VydF90ZXh0JyxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICB0ZXh0XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gb3duS2V5cyQ5KGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkOShlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDkoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDkoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbnZhciBUcmFuc2Zvcm1zID0gX29iamVjdFNwcmVhZCQ5KF9vYmplY3RTcHJlYWQkOShfb2JqZWN0U3ByZWFkJDkoX29iamVjdFNwcmVhZCQ5KHt9LCBHZW5lcmFsVHJhbnNmb3JtcyksIE5vZGVUcmFuc2Zvcm1zKSwgU2VsZWN0aW9uVHJhbnNmb3JtcyksIFRleHRUcmFuc2Zvcm1zKTtcblxuLy8gcGVyZlxudmFyIEJBVENISU5HX0RJUlRZX1BBVEhTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBpc0JhdGNoaW5nRGlydHlQYXRocyA9IGVkaXRvciA9PiB7XG4gIHJldHVybiBCQVRDSElOR19ESVJUWV9QQVRIUy5nZXQoZWRpdG9yKSB8fCBmYWxzZTtcbn07XG52YXIgYmF0Y2hEaXJ0eVBhdGhzID0gKGVkaXRvciwgZm4sIHVwZGF0ZSkgPT4ge1xuICB2YXIgdmFsdWUgPSBCQVRDSElOR19ESVJUWV9QQVRIUy5nZXQoZWRpdG9yKSB8fCBmYWxzZTtcbiAgQkFUQ0hJTkdfRElSVFlfUEFUSFMuc2V0KGVkaXRvciwgdHJ1ZSk7XG4gIHRyeSB7XG4gICAgZm4oKTtcbiAgICB1cGRhdGUoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBCQVRDSElOR19ESVJUWV9QQVRIUy5zZXQoZWRpdG9yLCB2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogdXBkYXRlIGVkaXRvciBkaXJ0eSBwYXRoc1xuICpcbiAqIEBwYXJhbSBuZXdEaXJ0eVBhdGhzOiBQYXRoW107IG5ldyBkaXJ0eSBwYXRoc1xuICogQHBhcmFtIHRyYW5zZm9ybTogKHA6IFBhdGgpID0+IFBhdGggfCBudWxsOyBob3cgdG8gdHJhbnNmb3JtIGV4aXN0aW5nIGRpcnR5IHBhdGhzXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZURpcnR5UGF0aHMoZWRpdG9yLCBuZXdEaXJ0eVBhdGhzLCB0cmFuc2Zvcm0pIHtcbiAgdmFyIG9sZERpcnR5UGF0aHMgPSBESVJUWV9QQVRIUy5nZXQoZWRpdG9yKSB8fCBbXTtcbiAgdmFyIG9sZERpcnR5UGF0aEtleXMgPSBESVJUWV9QQVRIX0tFWVMuZ2V0KGVkaXRvcikgfHwgbmV3IFNldCgpO1xuICB2YXIgZGlydHlQYXRocztcbiAgdmFyIGRpcnR5UGF0aEtleXM7XG4gIHZhciBhZGQgPSBwYXRoID0+IHtcbiAgICBpZiAocGF0aCkge1xuICAgICAgdmFyIGtleSA9IHBhdGguam9pbignLCcpO1xuICAgICAgaWYgKCFkaXJ0eVBhdGhLZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgIGRpcnR5UGF0aEtleXMuYWRkKGtleSk7XG4gICAgICAgIGRpcnR5UGF0aHMucHVzaChwYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGlmICh0cmFuc2Zvcm0pIHtcbiAgICBkaXJ0eVBhdGhzID0gW107XG4gICAgZGlydHlQYXRoS2V5cyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKHZhciBwYXRoIG9mIG9sZERpcnR5UGF0aHMpIHtcbiAgICAgIHZhciBuZXdQYXRoID0gdHJhbnNmb3JtKHBhdGgpO1xuICAgICAgYWRkKG5ld1BhdGgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkaXJ0eVBhdGhzID0gb2xkRGlydHlQYXRocztcbiAgICBkaXJ0eVBhdGhLZXlzID0gb2xkRGlydHlQYXRoS2V5cztcbiAgfVxuICBmb3IgKHZhciBfcGF0aCBvZiBuZXdEaXJ0eVBhdGhzKSB7XG4gICAgYWRkKF9wYXRoKTtcbiAgfVxuICBESVJUWV9QQVRIUy5zZXQoZWRpdG9yLCBkaXJ0eVBhdGhzKTtcbiAgRElSVFlfUEFUSF9LRVlTLnNldChlZGl0b3IsIGRpcnR5UGF0aEtleXMpO1xufVxuXG52YXIgYXBwbHkgPSAoZWRpdG9yLCBvcCkgPT4ge1xuICBmb3IgKHZhciByZWYgb2YgRWRpdG9yLnBhdGhSZWZzKGVkaXRvcikpIHtcbiAgICBQYXRoUmVmLnRyYW5zZm9ybShyZWYsIG9wKTtcbiAgfVxuICBmb3IgKHZhciBfcmVmIG9mIEVkaXRvci5wb2ludFJlZnMoZWRpdG9yKSkge1xuICAgIFBvaW50UmVmLnRyYW5zZm9ybShfcmVmLCBvcCk7XG4gIH1cbiAgZm9yICh2YXIgX3JlZjIgb2YgRWRpdG9yLnJhbmdlUmVmcyhlZGl0b3IpKSB7XG4gICAgUmFuZ2VSZWYudHJhbnNmb3JtKF9yZWYyLCBvcCk7XG4gIH1cbiAgLy8gdXBkYXRlIGRpcnR5IHBhdGhzXG4gIGlmICghaXNCYXRjaGluZ0RpcnR5UGF0aHMoZWRpdG9yKSkge1xuICAgIHZhciB0cmFuc2Zvcm0gPSBQYXRoLm9wZXJhdGlvbkNhblRyYW5zZm9ybVBhdGgob3ApID8gcCA9PiBQYXRoLnRyYW5zZm9ybShwLCBvcCkgOiB1bmRlZmluZWQ7XG4gICAgdXBkYXRlRGlydHlQYXRocyhlZGl0b3IsIGVkaXRvci5nZXREaXJ0eVBhdGhzKG9wKSwgdHJhbnNmb3JtKTtcbiAgfVxuICBUcmFuc2Zvcm1zLnRyYW5zZm9ybShlZGl0b3IsIG9wKTtcbiAgZWRpdG9yLm9wZXJhdGlvbnMucHVzaChvcCk7XG4gIEVkaXRvci5ub3JtYWxpemUoZWRpdG9yLCB7XG4gICAgb3BlcmF0aW9uOiBvcFxuICB9KTtcbiAgLy8gQ2xlYXIgYW55IGZvcm1hdHMgYXBwbGllZCB0byB0aGUgY3Vyc29yIGlmIHRoZSBzZWxlY3Rpb24gY2hhbmdlcy5cbiAgaWYgKG9wLnR5cGUgPT09ICdzZXRfc2VsZWN0aW9uJykge1xuICAgIGVkaXRvci5tYXJrcyA9IG51bGw7XG4gIH1cbiAgaWYgKCFGTFVTSElORy5nZXQoZWRpdG9yKSkge1xuICAgIEZMVVNISU5HLnNldChlZGl0b3IsIHRydWUpO1xuICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgRkxVU0hJTkcuc2V0KGVkaXRvciwgZmFsc2UpO1xuICAgICAgZWRpdG9yLm9uQ2hhbmdlKHtcbiAgICAgICAgb3BlcmF0aW9uOiBvcFxuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub3BlcmF0aW9ucyA9IFtdO1xuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgXCJkaXJ0eVwiIHBhdGhzIGdlbmVyYXRlZCBmcm9tIGFuIG9wZXJhdGlvbi5cbiAqL1xudmFyIGdldERpcnR5UGF0aHMgPSAoZWRpdG9yLCBvcCkgPT4ge1xuICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoXG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgcmV0dXJuIFBhdGgubGV2ZWxzKHBhdGgpO1xuICAgICAgfVxuICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIHBhdGg6IF9wYXRoXG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgdmFyIGxldmVscyA9IFBhdGgubGV2ZWxzKF9wYXRoKTtcbiAgICAgICAgdmFyIGRlc2NlbmRhbnRzID0gVGV4dC5pc1RleHQobm9kZSkgPyBbXSA6IEFycmF5LmZyb20oTm9kZS5ub2Rlcyhub2RlKSwgX3JlZiA9PiB7XG4gICAgICAgICAgdmFyIFssIHBdID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gX3BhdGguY29uY2F0KHApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFsuLi5sZXZlbHMsIC4uLmRlc2NlbmRhbnRzXTtcbiAgICAgIH1cbiAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDJcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICB2YXIgYW5jZXN0b3JzID0gUGF0aC5hbmNlc3RvcnMoX3BhdGgyKTtcbiAgICAgICAgdmFyIHByZXZpb3VzUGF0aCA9IFBhdGgucHJldmlvdXMoX3BhdGgyKTtcbiAgICAgICAgcmV0dXJuIFsuLi5hbmNlc3RvcnMsIHByZXZpb3VzUGF0aF07XG4gICAgICB9XG4gICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDMsXG4gICAgICAgICAgbmV3UGF0aFxuICAgICAgICB9ID0gb3A7XG4gICAgICAgIGlmIChQYXRoLmVxdWFscyhfcGF0aDMsIG5ld1BhdGgpKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvbGRBbmNlc3RvcnMgPSBbXTtcbiAgICAgICAgdmFyIG5ld0FuY2VzdG9ycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBhbmNlc3RvciBvZiBQYXRoLmFuY2VzdG9ycyhfcGF0aDMpKSB7XG4gICAgICAgICAgdmFyIHAgPSBQYXRoLnRyYW5zZm9ybShhbmNlc3Rvciwgb3ApO1xuICAgICAgICAgIG9sZEFuY2VzdG9ycy5wdXNoKHApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9hbmNlc3RvciBvZiBQYXRoLmFuY2VzdG9ycyhuZXdQYXRoKSkge1xuICAgICAgICAgIHZhciBfcCA9IFBhdGgudHJhbnNmb3JtKF9hbmNlc3Rvciwgb3ApO1xuICAgICAgICAgIG5ld0FuY2VzdG9ycy5wdXNoKF9wKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3UGFyZW50ID0gbmV3QW5jZXN0b3JzW25ld0FuY2VzdG9ycy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIG5ld0luZGV4ID0gbmV3UGF0aFtuZXdQYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgcmVzdWx0UGF0aCA9IG5ld1BhcmVudC5jb25jYXQobmV3SW5kZXgpO1xuICAgICAgICByZXR1cm4gWy4uLm9sZEFuY2VzdG9ycywgLi4ubmV3QW5jZXN0b3JzLCByZXN1bHRQYXRoXTtcbiAgICAgIH1cbiAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGg0XG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgdmFyIF9hbmNlc3RvcnMgPSBQYXRoLmFuY2VzdG9ycyhfcGF0aDQpO1xuICAgICAgICByZXR1cm4gWy4uLl9hbmNlc3RvcnNdO1xuICAgICAgfVxuICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoNVxuICAgICAgICB9ID0gb3A7XG4gICAgICAgIHZhciBfbGV2ZWxzID0gUGF0aC5sZXZlbHMoX3BhdGg1KTtcbiAgICAgICAgdmFyIG5leHRQYXRoID0gUGF0aC5uZXh0KF9wYXRoNSk7XG4gICAgICAgIHJldHVybiBbLi4uX2xldmVscywgbmV4dFBhdGhdO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgfVxufTtcblxudmFyIGdldEZyYWdtZW50ID0gZWRpdG9yID0+IHtcbiAgdmFyIHtcbiAgICBzZWxlY3Rpb25cbiAgfSA9IGVkaXRvcjtcbiAgaWYgKHNlbGVjdGlvbikge1xuICAgIHJldHVybiBOb2RlLmZyYWdtZW50KGVkaXRvciwgc2VsZWN0aW9uKTtcbiAgfVxuICByZXR1cm4gW107XG59O1xuXG52YXIgbm9ybWFsaXplTm9kZSA9IChlZGl0b3IsIGVudHJ5LCBvcHRpb25zKSA9PiB7XG4gIHZhciBbbm9kZSwgcGF0aF0gPSBlbnRyeTtcbiAgLy8gVGhlcmUgYXJlIG5vIGNvcmUgbm9ybWFsaXphdGlvbnMgZm9yIHRleHQgbm9kZXMuXG4gIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBFbnN1cmUgdGhhdCBibG9jayBhbmQgaW5saW5lIG5vZGVzIGhhdmUgYXQgbGVhc3Qgb25lIHRleHQgY2hpbGQuXG4gIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgIHZhciBjaGlsZCA9IHtcbiAgICAgIHRleHQ6ICcnXG4gICAgfTtcbiAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgY2hpbGQsIHtcbiAgICAgIGF0OiBwYXRoLmNvbmNhdCgwKSxcbiAgICAgIHZvaWRzOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIERldGVybWluZSB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBoYXZlIGJsb2NrIG9yIGlubGluZSBjaGlsZHJlbi5cbiAgdmFyIHNob3VsZEhhdmVJbmxpbmVzID0gRWRpdG9yLmlzRWRpdG9yKG5vZGUpID8gZmFsc2UgOiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiAoZWRpdG9yLmlzSW5saW5lKG5vZGUpIHx8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IFRleHQuaXNUZXh0KG5vZGUuY2hpbGRyZW5bMF0pIHx8IGVkaXRvci5pc0lubGluZShub2RlLmNoaWxkcmVuWzBdKSk7XG4gIC8vIFNpbmNlIHdlJ2xsIGJlIGFwcGx5aW5nIG9wZXJhdGlvbnMgd2hpbGUgaXRlcmF0aW5nLCBrZWVwIHRyYWNrIG9mIGFuXG4gIC8vIGluZGV4IHRoYXQgYWNjb3VudHMgZm9yIGFueSBhZGRlZC9yZW1vdmVkIG5vZGVzLlxuICB2YXIgbiA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKywgbisrKSB7XG4gICAgdmFyIGN1cnJlbnROb2RlID0gTm9kZS5nZXQoZWRpdG9yLCBwYXRoKTtcbiAgICBpZiAoVGV4dC5pc1RleHQoY3VycmVudE5vZGUpKSBjb250aW51ZTtcbiAgICB2YXIgX2NoaWxkID0gY3VycmVudE5vZGUuY2hpbGRyZW5bbl07XG4gICAgdmFyIHByZXYgPSBjdXJyZW50Tm9kZS5jaGlsZHJlbltuIC0gMV07XG4gICAgdmFyIGlzTGFzdCA9IGkgPT09IG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICB2YXIgaXNJbmxpbmVPclRleHQgPSBUZXh0LmlzVGV4dChfY2hpbGQpIHx8IEVsZW1lbnQuaXNFbGVtZW50KF9jaGlsZCkgJiYgZWRpdG9yLmlzSW5saW5lKF9jaGlsZCk7XG4gICAgLy8gT25seSBhbGxvdyBibG9jayBub2RlcyBpbiB0aGUgdG9wLWxldmVsIGNoaWxkcmVuIGFuZCBwYXJlbnQgYmxvY2tzXG4gICAgLy8gdGhhdCBvbmx5IGNvbnRhaW4gYmxvY2sgbm9kZXMuIFNpbWlsYXJseSwgb25seSBhbGxvdyBpbmxpbmUgbm9kZXMgaW5cbiAgICAvLyBvdGhlciBpbmxpbmUgbm9kZXMsIG9yIHBhcmVudCBibG9ja3MgdGhhdCBvbmx5IGNvbnRhaW4gaW5saW5lcyBhbmRcbiAgICAvLyB0ZXh0LlxuICAgIGlmIChpc0lubGluZU9yVGV4dCAhPT0gc2hvdWxkSGF2ZUlubGluZXMpIHtcbiAgICAgIGlmIChpc0lubGluZU9yVGV4dCkge1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgJiYgb3B0aW9ucy5mYWxsYmFja0VsZW1lbnQpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLndyYXBOb2RlcyhlZGl0b3IsIG9wdGlvbnMuZmFsbGJhY2tFbGVtZW50KCksIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuKSxcbiAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuKSxcbiAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4pLFxuICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbi0tO1xuICAgIH0gZWxzZSBpZiAoRWxlbWVudC5pc0VsZW1lbnQoX2NoaWxkKSkge1xuICAgICAgLy8gRW5zdXJlIHRoYXQgaW5saW5lIG5vZGVzIGFyZSBzdXJyb3VuZGVkIGJ5IHRleHQgbm9kZXMuXG4gICAgICBpZiAoZWRpdG9yLmlzSW5saW5lKF9jaGlsZCkpIHtcbiAgICAgICAgaWYgKHByZXYgPT0gbnVsbCB8fCAhVGV4dC5pc1RleHQocHJldikpIHtcbiAgICAgICAgICB2YXIgbmV3Q2hpbGQgPSB7XG4gICAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICAgIH07XG4gICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIG5ld0NoaWxkLCB7XG4gICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiksXG4gICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG4rKztcbiAgICAgICAgfSBlbHNlIGlmIChpc0xhc3QpIHtcbiAgICAgICAgICB2YXIgX25ld0NoaWxkID0ge1xuICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICB9O1xuICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBfbmV3Q2hpbGQsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuICsgMSksXG4gICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG4rKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGUgY2hpbGQgaXMgbm90IGEgdGV4dCBub2RlLCBhbmQgZG9lc24ndCBoYXZlIGEgYGNoaWxkcmVuYCBmaWVsZCxcbiAgICAgIC8vIHRoZW4gd2UgaGF2ZSBhbiBpbnZhbGlkIG5vZGUgdGhhdCB3aWxsIHVwc2V0IHNsYXRlLlxuICAgICAgLy9cbiAgICAgIC8vIGVnOiBgeyB0eXBlOiAnc29tZV9ub2RlJyB9YC5cbiAgICAgIC8vXG4gICAgICAvLyBUbyBwcmV2ZW50IHNsYXRlIGZyb20gYnJlYWtpbmcsIHdlIGNhbiBhZGQgdGhlIGBjaGlsZHJlbmAgZmllbGQsXG4gICAgICAvLyBhbmQgbm93IHRoYXQgaXQgaXMgdmFsaWQsIHdlIGNhbiB0byBtYW55IG1vcmUgb3BlcmF0aW9ucyBlYXNpbHksXG4gICAgICAvLyBzdWNoIGFzIGV4dGVuZCBub3JtYWxpemVycyB0byBmaXggZXJyb25vdXMgc3RydWN0dXJlLlxuICAgICAgaWYgKCFUZXh0LmlzVGV4dChfY2hpbGQpICYmICEoJ2NoaWxkcmVuJyBpbiBfY2hpbGQpKSB7XG4gICAgICAgIHZhciBlbGVtZW50Q2hpbGQgPSBfY2hpbGQ7XG4gICAgICAgIGVsZW1lbnRDaGlsZC5jaGlsZHJlbiA9IFtdO1xuICAgICAgfVxuICAgICAgLy8gTWVyZ2UgYWRqYWNlbnQgdGV4dCBub2RlcyB0aGF0IGFyZSBlbXB0eSBvciBtYXRjaC5cbiAgICAgIGlmIChwcmV2ICE9IG51bGwgJiYgVGV4dC5pc1RleHQocHJldikpIHtcbiAgICAgICAgaWYgKFRleHQuZXF1YWxzKF9jaGlsZCwgcHJldiwge1xuICAgICAgICAgIGxvb3NlOiB0cnVlXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tZXJnZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4pLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuLS07XG4gICAgICAgIH0gZWxzZSBpZiAocHJldi50ZXh0ID09PSAnJykge1xuICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiAtIDEpLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuLS07XG4gICAgICAgIH0gZWxzZSBpZiAoX2NoaWxkLnRleHQgPT09ICcnKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuKSxcbiAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbi0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgc2hvdWxkTm9ybWFsaXplID0gKGVkaXRvciwgX3JlZikgPT4ge1xuICB2YXIge1xuICAgIGl0ZXJhdGlvbixcbiAgICBpbml0aWFsRGlydHlQYXRoc0xlbmd0aFxuICB9ID0gX3JlZjtcbiAgdmFyIG1heEl0ZXJhdGlvbnMgPSBpbml0aWFsRGlydHlQYXRoc0xlbmd0aCAqIDQyOyAvLyBIQUNLOiBiZXR0ZXIgd2F5P1xuICBpZiAoaXRlcmF0aW9uID4gbWF4SXRlcmF0aW9ucykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBjb21wbGV0ZWx5IG5vcm1hbGl6ZSB0aGUgZWRpdG9yIGFmdGVyIFwiLmNvbmNhdChtYXhJdGVyYXRpb25zLCBcIiBpdGVyYXRpb25zISBUaGlzIGlzIHVzdWFsbHkgZHVlIHRvIGluY29ycmVjdCBub3JtYWxpemF0aW9uIGxvZ2ljIHRoYXQgbGVhdmVzIGEgbm9kZSBpbiBhbiBpbnZhbGlkIHN0YXRlLlwiKSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgYWJvdmUgPSBmdW5jdGlvbiBhYm92ZShlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIge1xuICAgIHZvaWRzID0gZmFsc2UsXG4gICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICBtYXRjaFxuICB9ID0gb3B0aW9ucztcbiAgaWYgKCFhdCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQpO1xuICAvLyBJZiBgYXRgIGlzIGEgUmFuZ2UgdGhhdCBzcGFucyBtdWxpdHBsZSBub2RlcywgYHBhdGhgIHdpbGwgYmUgdGhlaXIgY29tbW9uIGFuY2VzdG9yLlxuICAvLyBPdGhlcndpc2UgYHBhdGhgIHdpbGwgYmUgYSB0ZXh0IG5vZGUgYW5kL29yIHRoZSBzYW1lIGFzIGBhdGAsIGluIHdoaWNoIGNhc2VzIHdlIHdhbnQgdG8gc3RhcnQgd2l0aCBpdHMgcGFyZW50LlxuICBpZiAoIVJhbmdlLmlzUmFuZ2UoYXQpIHx8IFBhdGguZXF1YWxzKGF0LmZvY3VzLnBhdGgsIGF0LmFuY2hvci5wYXRoKSkge1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHBhdGggPSBQYXRoLnBhcmVudChwYXRoKTtcbiAgfVxuICB2YXIgcmV2ZXJzZSA9IG1vZGUgPT09ICdsb3dlc3QnO1xuICB2YXIgW2ZpcnN0TWF0Y2hdID0gRWRpdG9yLmxldmVscyhlZGl0b3IsIHtcbiAgICBhdDogcGF0aCxcbiAgICB2b2lkcyxcbiAgICBtYXRjaCxcbiAgICByZXZlcnNlXG4gIH0pO1xuICByZXR1cm4gZmlyc3RNYXRjaDsgLy8gaWYgbm90aGluZyBtYXRjaGVzIHRoaXMgcmV0dXJucyB1bmRlZmluZWRcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkOChlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDgoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQ4KE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQ4KE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgYWRkTWFyayA9IChlZGl0b3IsIGtleSwgdmFsdWUpID0+IHtcbiAgdmFyIHtcbiAgICBzZWxlY3Rpb25cbiAgfSA9IGVkaXRvcjtcbiAgaWYgKHNlbGVjdGlvbikge1xuICAgIHZhciBtYXRjaCA9IChub2RlLCBwYXRoKSA9PiB7XG4gICAgICBpZiAoIVRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gbWFya3MgY2FuIG9ubHkgYmUgYXBwbGllZCB0byB0ZXh0XG4gICAgICB9XG5cbiAgICAgIHZhciBbcGFyZW50Tm9kZSwgcGFyZW50UGF0aF0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgcGF0aCk7XG4gICAgICByZXR1cm4gIWVkaXRvci5pc1ZvaWQocGFyZW50Tm9kZSkgfHwgZWRpdG9yLm1hcmthYmxlVm9pZChwYXJlbnROb2RlKTtcbiAgICB9O1xuICAgIHZhciBleHBhbmRlZFNlbGVjdGlvbiA9IFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKTtcbiAgICB2YXIgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCA9IGZhbHNlO1xuICAgIGlmICghZXhwYW5kZWRTZWxlY3Rpb24pIHtcbiAgICAgIHZhciBbc2VsZWN0ZWROb2RlLCBzZWxlY3RlZFBhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBzZWxlY3Rpb24pO1xuICAgICAgaWYgKHNlbGVjdGVkTm9kZSAmJiBtYXRjaChzZWxlY3RlZE5vZGUsIHNlbGVjdGVkUGF0aCkpIHtcbiAgICAgICAgdmFyIFtwYXJlbnROb2RlXSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBzZWxlY3RlZFBhdGgpO1xuICAgICAgICBtYXJrQWNjZXB0aW5nVm9pZFNlbGVjdGVkID0gcGFyZW50Tm9kZSAmJiBlZGl0b3IubWFya2FibGVWb2lkKHBhcmVudE5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXhwYW5kZWRTZWxlY3Rpb24gfHwgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCkge1xuICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgW2tleV06IHZhbHVlXG4gICAgICB9LCB7XG4gICAgICAgIG1hdGNoLFxuICAgICAgICBzcGxpdDogdHJ1ZSxcbiAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbWFya3MgPSBfb2JqZWN0U3ByZWFkJDgoX29iamVjdFNwcmVhZCQ4KHt9LCBFZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fSksIHt9LCB7XG4gICAgICAgIFtrZXldOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgICBlZGl0b3IubWFya3MgPSBtYXJrcztcbiAgICAgIGlmICghRkxVU0hJTkcuZ2V0KGVkaXRvcikpIHtcbiAgICAgICAgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDcoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ3KGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkNyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkNyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxudmFyIGFmdGVyID0gZnVuY3Rpb24gYWZ0ZXIoZWRpdG9yLCBhdCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBhbmNob3IgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBhdCwge1xuICAgIGVkZ2U6ICdlbmQnXG4gIH0pO1xuICB2YXIgZm9jdXMgPSBFZGl0b3IuZW5kKGVkaXRvciwgW10pO1xuICB2YXIgcmFuZ2UgPSB7XG4gICAgYW5jaG9yLFxuICAgIGZvY3VzXG4gIH07XG4gIHZhciB7XG4gICAgZGlzdGFuY2UgPSAxXG4gIH0gPSBvcHRpb25zO1xuICB2YXIgZCA9IDA7XG4gIHZhciB0YXJnZXQ7XG4gIGZvciAodmFyIHAgb2YgRWRpdG9yLnBvc2l0aW9ucyhlZGl0b3IsIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgIGF0OiByYW5nZVxuICB9KSkpIHtcbiAgICBpZiAoZCA+IGRpc3RhbmNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGQgIT09IDApIHtcbiAgICAgIHRhcmdldCA9IHA7XG4gICAgfVxuICAgIGQrKztcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuZnVuY3Rpb24gb3duS2V5cyQ2KGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNihlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDYoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDYoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbnZhciBiZWZvcmUgPSBmdW5jdGlvbiBiZWZvcmUoZWRpdG9yLCBhdCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBhbmNob3IgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBbXSk7XG4gIHZhciBmb2N1cyA9IEVkaXRvci5wb2ludChlZGl0b3IsIGF0LCB7XG4gICAgZWRnZTogJ3N0YXJ0J1xuICB9KTtcbiAgdmFyIHJhbmdlID0ge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9O1xuICB2YXIge1xuICAgIGRpc3RhbmNlID0gMVxuICB9ID0gb3B0aW9ucztcbiAgdmFyIGQgPSAwO1xuICB2YXIgdGFyZ2V0O1xuICBmb3IgKHZhciBwIG9mIEVkaXRvci5wb3NpdGlvbnMoZWRpdG9yLCBfb2JqZWN0U3ByZWFkJDYoX29iamVjdFNwcmVhZCQ2KHt9LCBvcHRpb25zKSwge30sIHtcbiAgICBhdDogcmFuZ2UsXG4gICAgcmV2ZXJzZTogdHJ1ZVxuICB9KSkpIHtcbiAgICBpZiAoZCA+IGRpc3RhbmNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGQgIT09IDApIHtcbiAgICAgIHRhcmdldCA9IHA7XG4gICAgfVxuICAgIGQrKztcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIGRlbGV0ZUJhY2t3YXJkID0gKGVkaXRvciwgdW5pdCkgPT4ge1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikpIHtcbiAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgIHVuaXQsXG4gICAgICByZXZlcnNlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBkZWxldGVGb3J3YXJkID0gKGVkaXRvciwgdW5pdCkgPT4ge1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikpIHtcbiAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgIHVuaXRcbiAgICB9KTtcbiAgfVxufTtcblxudmFyIGRlbGV0ZUZyYWdtZW50ID0gZnVuY3Rpb24gZGVsZXRlRnJhZ21lbnQoZWRpdG9yKSB7XG4gIHZhciB7XG4gICAgZGlyZWN0aW9uID0gJ2ZvcndhcmQnXG4gIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgcmV2ZXJzZTogZGlyZWN0aW9uID09PSAnYmFja3dhcmQnXG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBlZGdlcyA9IChlZGl0b3IsIGF0KSA9PiB7XG4gIHJldHVybiBbRWRpdG9yLnN0YXJ0KGVkaXRvciwgYXQpLCBFZGl0b3IuZW5kKGVkaXRvciwgYXQpXTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkNShlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDUoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQ1KE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQ1KE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgZWxlbWVudFJlYWRPbmx5ID0gZnVuY3Rpb24gZWxlbWVudFJlYWRPbmx5KGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHJldHVybiBFZGl0b3IuYWJvdmUoZWRpdG9yLCBfb2JqZWN0U3ByZWFkJDUoX29iamVjdFNwcmVhZCQ1KHt9LCBvcHRpb25zKSwge30sIHtcbiAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNFbGVtZW50UmVhZE9ubHkoZWRpdG9yLCBuKVxuICB9KSk7XG59O1xuXG52YXIgZW5kID0gKGVkaXRvciwgYXQpID0+IHtcbiAgcmV0dXJuIEVkaXRvci5wb2ludChlZGl0b3IsIGF0LCB7XG4gICAgZWRnZTogJ2VuZCdcbiAgfSk7XG59O1xuXG52YXIgZmlyc3QgPSAoZWRpdG9yLCBhdCkgPT4ge1xuICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIHtcbiAgICBlZGdlOiAnc3RhcnQnXG4gIH0pO1xuICByZXR1cm4gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKTtcbn07XG5cbnZhciBmcmFnbWVudCA9IChlZGl0b3IsIGF0KSA9PiB7XG4gIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgcmV0dXJuIE5vZGUuZnJhZ21lbnQoZWRpdG9yLCByYW5nZSk7XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDQoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ0KGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkNChPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkNChPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxudmFyIGdldFZvaWQgPSBmdW5jdGlvbiBnZXRWb2lkKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHJldHVybiBFZGl0b3IuYWJvdmUoZWRpdG9yLCBfb2JqZWN0U3ByZWFkJDQoX29iamVjdFNwcmVhZCQ0KHt9LCBvcHRpb25zKSwge30sIHtcbiAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbilcbiAgfSkpO1xufTtcblxudmFyIGhhc0Jsb2NrcyA9IChlZGl0b3IsIGVsZW1lbnQpID0+IHtcbiAgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW4uc29tZShuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbikpO1xufTtcblxudmFyIGhhc0lubGluZXMgPSAoZWRpdG9yLCBlbGVtZW50KSA9PiB7XG4gIHJldHVybiBlbGVtZW50LmNoaWxkcmVuLnNvbWUobiA9PiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSk7XG59O1xuXG52YXIgaGFzUGF0aCA9IChlZGl0b3IsIHBhdGgpID0+IHtcbiAgcmV0dXJuIE5vZGUuaGFzKGVkaXRvciwgcGF0aCk7XG59O1xuXG52YXIgaGFzVGV4dHMgPSAoZWRpdG9yLCBlbGVtZW50KSA9PiB7XG4gIHJldHVybiBlbGVtZW50LmNoaWxkcmVuLmV2ZXJ5KG4gPT4gVGV4dC5pc1RleHQobikpO1xufTtcblxudmFyIGluc2VydEJyZWFrID0gZWRpdG9yID0+IHtcbiAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgIGFsd2F5czogdHJ1ZVxuICB9KTtcbn07XG5cbnZhciBpbnNlcnROb2RlID0gKGVkaXRvciwgbm9kZSwgb3B0aW9ucykgPT4ge1xuICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbm9kZSwgb3B0aW9ucyk7XG59O1xuXG52YXIgaW5zZXJ0U29mdEJyZWFrID0gZWRpdG9yID0+IHtcbiAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgIGFsd2F5czogdHJ1ZVxuICB9KTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkMyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDMoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgaW5zZXJ0VGV4dCA9IGZ1bmN0aW9uIGluc2VydFRleHQoZWRpdG9yLCB0ZXh0KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHtcbiAgICBzZWxlY3Rpb24sXG4gICAgbWFya3NcbiAgfSA9IGVkaXRvcjtcbiAgaWYgKHNlbGVjdGlvbikge1xuICAgIGlmIChtYXJrcykge1xuICAgICAgdmFyIG5vZGUgPSBfb2JqZWN0U3ByZWFkJDMoe1xuICAgICAgICB0ZXh0XG4gICAgICB9LCBtYXJrcyk7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbm9kZSwge1xuICAgICAgICBhdDogb3B0aW9ucy5hdCxcbiAgICAgICAgdm9pZHM6IG9wdGlvbnMudm9pZHNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydFRleHQoZWRpdG9yLCB0ZXh0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgZWRpdG9yLm1hcmtzID0gbnVsbDtcbiAgfVxufTtcblxudmFyIGlzQmxvY2sgPSAoZWRpdG9yLCB2YWx1ZSkgPT4ge1xuICByZXR1cm4gIWVkaXRvci5pc0lubGluZSh2YWx1ZSk7XG59O1xuXG52YXIgaXNFZGdlID0gKGVkaXRvciwgcG9pbnQsIGF0KSA9PiB7XG4gIHJldHVybiBFZGl0b3IuaXNTdGFydChlZGl0b3IsIHBvaW50LCBhdCkgfHwgRWRpdG9yLmlzRW5kKGVkaXRvciwgcG9pbnQsIGF0KTtcbn07XG5cbnZhciBpc0VtcHR5ID0gKGVkaXRvciwgZWxlbWVudCkgPT4ge1xuICB2YXIge1xuICAgIGNoaWxkcmVuXG4gIH0gPSBlbGVtZW50O1xuICB2YXIgW2ZpcnN0XSA9IGNoaWxkcmVuO1xuICByZXR1cm4gY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBUZXh0LmlzVGV4dChmaXJzdCkgJiYgZmlyc3QudGV4dCA9PT0gJycgJiYgIWVkaXRvci5pc1ZvaWQoZWxlbWVudCk7XG59O1xuXG52YXIgaXNFbmQgPSAoZWRpdG9yLCBwb2ludCwgYXQpID0+IHtcbiAgdmFyIGVuZCA9IEVkaXRvci5lbmQoZWRpdG9yLCBhdCk7XG4gIHJldHVybiBQb2ludC5lcXVhbHMocG9pbnQsIGVuZCk7XG59O1xuXG52YXIgaXNOb3JtYWxpemluZyA9IGVkaXRvciA9PiB7XG4gIHZhciBpc05vcm1hbGl6aW5nID0gTk9STUFMSVpJTkcuZ2V0KGVkaXRvcik7XG4gIHJldHVybiBpc05vcm1hbGl6aW5nID09PSB1bmRlZmluZWQgPyB0cnVlIDogaXNOb3JtYWxpemluZztcbn07XG5cbnZhciBpc1N0YXJ0ID0gKGVkaXRvciwgcG9pbnQsIGF0KSA9PiB7XG4gIC8vIFBFUkY6IElmIHRoZSBvZmZzZXQgaXNuJ3QgYDBgIHdlIGtub3cgaXQncyBub3QgdGhlIHN0YXJ0LlxuICBpZiAocG9pbnQub2Zmc2V0ICE9PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBzdGFydCA9IEVkaXRvci5zdGFydChlZGl0b3IsIGF0KTtcbiAgcmV0dXJuIFBvaW50LmVxdWFscyhwb2ludCwgc3RhcnQpO1xufTtcblxudmFyIGxhc3QgPSAoZWRpdG9yLCBhdCkgPT4ge1xuICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIHtcbiAgICBlZGdlOiAnZW5kJ1xuICB9KTtcbiAgcmV0dXJuIEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCk7XG59O1xuXG52YXIgbGVhZiA9IGZ1bmN0aW9uIGxlYWYoZWRpdG9yLCBhdCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwgb3B0aW9ucyk7XG4gIHZhciBub2RlID0gTm9kZS5sZWFmKGVkaXRvciwgcGF0aCk7XG4gIHJldHVybiBbbm9kZSwgcGF0aF07XG59O1xuXG5mdW5jdGlvbiBsZXZlbHMoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgdmFyIHtcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgIHJldmVyc2UgPSBmYWxzZSxcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgbWF0Y2hcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgbWF0Y2ggPSAoKSA9PiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBsZXZlbHMgPSBbXTtcbiAgICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQpO1xuICAgIGZvciAodmFyIFtuLCBwXSBvZiBOb2RlLmxldmVscyhlZGl0b3IsIHBhdGgpKSB7XG4gICAgICBpZiAoIW1hdGNoKG4sIHApKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV2ZWxzLnB1c2goW24sIHBdKTtcbiAgICAgIGlmICghdm9pZHMgJiYgRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG4pKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgbGV2ZWxzLnJldmVyc2UoKTtcbiAgICB9XG4gICAgeWllbGQqIGxldmVscztcbiAgfSgpO1xufVxuXG52YXIgX2V4Y2x1ZGVkJDEgPSBbXCJ0ZXh0XCJdLFxuICBfZXhjbHVkZWQyJDEgPSBbXCJ0ZXh0XCJdO1xudmFyIG1hcmtzID0gZnVuY3Rpb24gbWFya3MoZWRpdG9yKSB7XG4gIHZhciB7XG4gICAgbWFya3MsXG4gICAgc2VsZWN0aW9uXG4gIH0gPSBlZGl0b3I7XG4gIGlmICghc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXNcbiAgfSA9IHNlbGVjdGlvbjtcbiAgaWYgKG1hcmtzKSB7XG4gICAgcmV0dXJuIG1hcmtzO1xuICB9XG4gIGlmIChSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICB2YXIgaXNCYWNrd2FyZCA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKTtcbiAgICBpZiAoaXNCYWNrd2FyZCkge1xuICAgICAgW2ZvY3VzLCBhbmNob3JdID0gW2FuY2hvciwgZm9jdXNdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDT01QQVQ6IE1ha2Ugc3VyZSBoYW5naW5nIHJhbmdlcyAoY2F1c2VkIGJ5IGRvdWJsZSBjbGlja2luZyBpbiBGaXJlZm94KVxuICAgICAqIGRvIG5vdCBhZHZlcnNlbHkgYWZmZWN0IHRoZSByZXR1cm5lZCBtYXJrcy5cbiAgICAgKi9cbiAgICB2YXIgaXNFbmQgPSBFZGl0b3IuaXNFbmQoZWRpdG9yLCBhbmNob3IsIGFuY2hvci5wYXRoKTtcbiAgICBpZiAoaXNFbmQpIHtcbiAgICAgIHZhciBhZnRlciA9IEVkaXRvci5hZnRlcihlZGl0b3IsIGFuY2hvcik7XG4gICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgYW5jaG9yID0gYWZ0ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBbbWF0Y2hdID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0LFxuICAgICAgYXQ6IHtcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBmb2N1c1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgdmFyIFtfbm9kZV0gPSBtYXRjaDtcbiAgICAgIHZhciBfcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfbm9kZSwgX2V4Y2x1ZGVkJDEpO1xuICAgICAgcmV0dXJuIF9yZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG4gIHZhciB7XG4gICAgcGF0aFxuICB9ID0gYW5jaG9yO1xuICB2YXIgW25vZGVdID0gRWRpdG9yLmxlYWYoZWRpdG9yLCBwYXRoKTtcbiAgaWYgKGFuY2hvci5vZmZzZXQgPT09IDApIHtcbiAgICB2YXIgcHJldiA9IEVkaXRvci5wcmV2aW91cyhlZGl0b3IsIHtcbiAgICAgIGF0OiBwYXRoLFxuICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0XG4gICAgfSk7XG4gICAgdmFyIG1hcmtlZFZvaWQgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbikgJiYgZWRpdG9yLm1hcmthYmxlVm9pZChuKVxuICAgIH0pO1xuICAgIGlmICghbWFya2VkVm9pZCkge1xuICAgICAgdmFyIGJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pXG4gICAgICB9KTtcbiAgICAgIGlmIChwcmV2ICYmIGJsb2NrKSB7XG4gICAgICAgIHZhciBbcHJldk5vZGUsIHByZXZQYXRoXSA9IHByZXY7XG4gICAgICAgIHZhciBbLCBibG9ja1BhdGhdID0gYmxvY2s7XG4gICAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IoYmxvY2tQYXRoLCBwcmV2UGF0aCkpIHtcbiAgICAgICAgICBub2RlID0gcHJldk5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkMiQxKTtcbiAgcmV0dXJuIHJlc3Q7XG59O1xuXG52YXIgbmV4dCA9IGZ1bmN0aW9uIG5leHQoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIHtcbiAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgdm9pZHMgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgdmFyIHtcbiAgICBtYXRjaCxcbiAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb25cbiAgfSA9IG9wdGlvbnM7XG4gIGlmICghYXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHBvaW50QWZ0ZXJMb2NhdGlvbiA9IEVkaXRvci5hZnRlcihlZGl0b3IsIGF0LCB7XG4gICAgdm9pZHNcbiAgfSk7XG4gIGlmICghcG9pbnRBZnRlckxvY2F0aW9uKSByZXR1cm47XG4gIHZhciBbLCB0b10gPSBFZGl0b3IubGFzdChlZGl0b3IsIFtdKTtcbiAgdmFyIHNwYW4gPSBbcG9pbnRBZnRlckxvY2F0aW9uLnBhdGgsIHRvXTtcbiAgaWYgKFBhdGguaXNQYXRoKGF0KSAmJiBhdC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBuZXh0IG5vZGUgZnJvbSB0aGUgcm9vdCBub2RlIVwiKTtcbiAgfVxuICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgIHZhciBbcGFyZW50XSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBhdCk7XG4gICAgICBtYXRjaCA9IG4gPT4gcGFyZW50LmNoaWxkcmVuLmluY2x1ZGVzKG4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXRjaCA9ICgpID0+IHRydWU7XG4gICAgfVxuICB9XG4gIHZhciBbbmV4dF0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgYXQ6IHNwYW4sXG4gICAgbWF0Y2gsXG4gICAgbW9kZSxcbiAgICB2b2lkc1xuICB9KTtcbiAgcmV0dXJuIG5leHQ7XG59O1xuXG52YXIgbm9kZSA9IGZ1bmN0aW9uIG5vZGUoZWRpdG9yLCBhdCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwgb3B0aW9ucyk7XG4gIHZhciBub2RlID0gTm9kZS5nZXQoZWRpdG9yLCBwYXRoKTtcbiAgcmV0dXJuIFtub2RlLCBwYXRoXTtcbn07XG5cbmZ1bmN0aW9uIG5vZGVzKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgIHZhciB7XG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICBtb2RlID0gJ2FsbCcsXG4gICAgICB1bml2ZXJzYWwgPSBmYWxzZSxcbiAgICAgIHJldmVyc2UgPSBmYWxzZSxcbiAgICAgIHZvaWRzID0gZmFsc2UsXG4gICAgICBwYXNzOiBfcGFzc1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBtYXRjaFxuICAgIH0gPSBvcHRpb25zO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIG1hdGNoID0gKCkgPT4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZnJvbTtcbiAgICB2YXIgdG87XG4gICAgaWYgKFNwYW4uaXNTcGFuKGF0KSkge1xuICAgICAgZnJvbSA9IGF0WzBdO1xuICAgICAgdG8gPSBhdFsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZpcnN0ID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgICAgICBlZGdlOiAnc3RhcnQnXG4gICAgICB9KTtcbiAgICAgIHZhciBsYXN0ID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgICAgICBlZGdlOiAnZW5kJ1xuICAgICAgfSk7XG4gICAgICBmcm9tID0gcmV2ZXJzZSA/IGxhc3QgOiBmaXJzdDtcbiAgICAgIHRvID0gcmV2ZXJzZSA/IGZpcnN0IDogbGFzdDtcbiAgICB9XG4gICAgdmFyIG5vZGVFbnRyaWVzID0gTm9kZS5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIHJldmVyc2UsXG4gICAgICBmcm9tLFxuICAgICAgdG8sXG4gICAgICBwYXNzOiBfcmVmID0+IHtcbiAgICAgICAgdmFyIFtub2RlLCBwYXRoXSA9IF9yZWY7XG4gICAgICAgIGlmIChfcGFzcyAmJiBfcGFzcyhbbm9kZSwgcGF0aF0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCFFbGVtZW50LmlzRWxlbWVudChub2RlKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXZvaWRzICYmIChFZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkgfHwgRWRpdG9yLmlzRWxlbWVudFJlYWRPbmx5KGVkaXRvciwgbm9kZSkpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgdmFyIGhpdDtcbiAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2Ygbm9kZUVudHJpZXMpIHtcbiAgICAgIHZhciBpc0xvd2VyID0gaGl0ICYmIFBhdGguY29tcGFyZShwYXRoLCBoaXRbMV0pID09PSAwO1xuICAgICAgLy8gSW4gaGlnaGVzdCBtb2RlIGFueSBub2RlIGxvd2VyIHRoYW4gdGhlIGxhc3QgaGl0IGlzIG5vdCBhIG1hdGNoLlxuICAgICAgaWYgKG1vZGUgPT09ICdoaWdoZXN0JyAmJiBpc0xvd2VyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXRjaChub2RlLCBwYXRoKSkge1xuICAgICAgICAvLyBJZiB3ZSd2ZSBhcnJpdmVkIGF0IGEgbGVhZiB0ZXh0IG5vZGUgdGhhdCBpcyBub3QgbG93ZXIgdGhhbiB0aGUgbGFzdFxuICAgICAgICAvLyBoaXQsIHRoZW4gd2UndmUgZm91bmQgYSBicmFuY2ggdGhhdCBkb2Vzbid0IGluY2x1ZGUgYSBtYXRjaCwgd2hpY2hcbiAgICAgICAgLy8gbWVhbnMgdGhlIG1hdGNoIGlzIG5vdCB1bml2ZXJzYWwuXG4gICAgICAgIGlmICh1bml2ZXJzYWwgJiYgIWlzTG93ZXIgJiYgVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZXJlJ3MgYSBtYXRjaCBhbmQgaXQncyBsb3dlciB0aGFuIHRoZSBsYXN0LCB1cGRhdGUgdGhlIGhpdC5cbiAgICAgIGlmIChtb2RlID09PSAnbG93ZXN0JyAmJiBpc0xvd2VyKSB7XG4gICAgICAgIGhpdCA9IFtub2RlLCBwYXRoXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBJbiBsb3dlc3QgbW9kZSB3ZSBlbWl0IHRoZSBsYXN0IGhpdCwgb25jZSBpdCdzIGd1YXJhbnRlZWQgbG93ZXN0LlxuICAgICAgdmFyIGVtaXQgPSBtb2RlID09PSAnbG93ZXN0JyA/IGhpdCA6IFtub2RlLCBwYXRoXTtcbiAgICAgIGlmIChlbWl0KSB7XG4gICAgICAgIGlmICh1bml2ZXJzYWwpIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goZW1pdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeWllbGQgZW1pdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaGl0ID0gW25vZGUsIHBhdGhdO1xuICAgIH1cbiAgICAvLyBTaW5jZSBsb3dlc3QgaXMgYWx3YXlzIGVtaXR0aW5nIG9uZSBiZWhpbmQsIGNhdGNoIHVwIGF0IHRoZSBlbmQuXG4gICAgaWYgKG1vZGUgPT09ICdsb3dlc3QnICYmIGhpdCkge1xuICAgICAgaWYgKHVuaXZlcnNhbCkge1xuICAgICAgICBtYXRjaGVzLnB1c2goaGl0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkIGhpdDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gVW5pdmVyc2FsIGRlZmVycyB0byBlbnN1cmUgdGhhdCB0aGUgbWF0Y2ggb2NjdXJzIGluIGV2ZXJ5IGJyYW5jaCwgc28gd2VcbiAgICAvLyB5aWVsZCBhbGwgb2YgdGhlIG1hdGNoZXMgYWZ0ZXIgaXRlcmF0aW5nLlxuICAgIGlmICh1bml2ZXJzYWwpIHtcbiAgICAgIHlpZWxkKiBtYXRjaGVzO1xuICAgIH1cbiAgfSgpO1xufVxuXG52YXIgbm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciB7XG4gICAgZm9yY2UgPSBmYWxzZSxcbiAgICBvcGVyYXRpb25cbiAgfSA9IG9wdGlvbnM7XG4gIHZhciBnZXREaXJ0eVBhdGhzID0gZWRpdG9yID0+IHtcbiAgICByZXR1cm4gRElSVFlfUEFUSFMuZ2V0KGVkaXRvcikgfHwgW107XG4gIH07XG4gIHZhciBnZXREaXJ0eVBhdGhLZXlzID0gZWRpdG9yID0+IHtcbiAgICByZXR1cm4gRElSVFlfUEFUSF9LRVlTLmdldChlZGl0b3IpIHx8IG5ldyBTZXQoKTtcbiAgfTtcbiAgdmFyIHBvcERpcnR5UGF0aCA9IGVkaXRvciA9PiB7XG4gICAgdmFyIHBhdGggPSBnZXREaXJ0eVBhdGhzKGVkaXRvcikucG9wKCk7XG4gICAgdmFyIGtleSA9IHBhdGguam9pbignLCcpO1xuICAgIGdldERpcnR5UGF0aEtleXMoZWRpdG9yKS5kZWxldGUoa2V5KTtcbiAgICByZXR1cm4gcGF0aDtcbiAgfTtcbiAgaWYgKCFFZGl0b3IuaXNOb3JtYWxpemluZyhlZGl0b3IpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChmb3JjZSkge1xuICAgIHZhciBhbGxQYXRocyA9IEFycmF5LmZyb20oTm9kZS5ub2RlcyhlZGl0b3IpLCBfcmVmID0+IHtcbiAgICAgIHZhciBbLCBwXSA9IF9yZWY7XG4gICAgICByZXR1cm4gcDtcbiAgICB9KTtcbiAgICB2YXIgYWxsUGF0aEtleXMgPSBuZXcgU2V0KGFsbFBhdGhzLm1hcChwID0+IHAuam9pbignLCcpKSk7XG4gICAgRElSVFlfUEFUSFMuc2V0KGVkaXRvciwgYWxsUGF0aHMpO1xuICAgIERJUlRZX1BBVEhfS0VZUy5zZXQoZWRpdG9yLCBhbGxQYXRoS2V5cyk7XG4gIH1cbiAgaWYgKGdldERpcnR5UGF0aHMoZWRpdG9yKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAvKlxuICAgICAgRml4IGRpcnR5IGVsZW1lbnRzIHdpdGggbm8gY2hpbGRyZW4uXG4gICAgICBlZGl0b3Iubm9ybWFsaXplTm9kZSgpIGRvZXMgZml4IHRoaXMsIGJ1dCBzb21lIG5vcm1hbGl6YXRpb24gZml4ZXMgYWxzbyByZXF1aXJlIGl0IHRvIHdvcmsuXG4gICAgICBSdW5uaW5nIGFuIGluaXRpYWwgcGFzcyBhdm9pZHMgdGhlIGNhdGNoLTIyIHJhY2UgY29uZGl0aW9uLlxuICAgICovXG4gICAgZm9yICh2YXIgZGlydHlQYXRoIG9mIGdldERpcnR5UGF0aHMoZWRpdG9yKSkge1xuICAgICAgaWYgKE5vZGUuaGFzKGVkaXRvciwgZGlydHlQYXRoKSkge1xuICAgICAgICB2YXIgZW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIGRpcnR5UGF0aCk7XG4gICAgICAgIHZhciBbbm9kZSwgX10gPSBlbnRyeTtcbiAgICAgICAgLypcbiAgICAgICAgICBUaGUgZGVmYXVsdCBub3JtYWxpemVyIGluc2VydHMgYW4gZW1wdHkgdGV4dCBub2RlIGluIHRoaXMgc2NlbmFyaW8sIGJ1dCBpdCBjYW4gYmUgY3VzdG9taXNlZC5cbiAgICAgICAgICBTbyB0aGVyZSBpcyBzb21lIHJpc2sgaGVyZS5cbiAgICAgICAgICAgICAgICAgICBBcyBsb25nIGFzIHRoZSBub3JtYWxpemVyIG9ubHkgaW5zZXJ0cyBjaGlsZCBub2RlcyBmb3IgdGhpcyBjYXNlIGl0IGlzIHNhZmUgdG8gZG8gaW4gYW55IG9yZGVyO1xuICAgICAgICAgIGJ5IGRlZmluaXRpb24gYWRkaW5nIGNoaWxkcmVuIHRvIGFuIGVtcHR5IG5vZGUgY2FuJ3QgY2F1c2Ugb3RoZXIgcGF0aHMgdG8gY2hhbmdlLlxuICAgICAgICAqL1xuICAgICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBlZGl0b3Iubm9ybWFsaXplTm9kZShlbnRyeSwge1xuICAgICAgICAgICAgb3BlcmF0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGRpcnR5UGF0aHMgPSBnZXREaXJ0eVBhdGhzKGVkaXRvcik7XG4gICAgdmFyIGluaXRpYWxEaXJ0eVBhdGhzTGVuZ3RoID0gZGlydHlQYXRocy5sZW5ndGg7XG4gICAgdmFyIGl0ZXJhdGlvbiA9IDA7XG4gICAgd2hpbGUgKGRpcnR5UGF0aHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICBpZiAoIWVkaXRvci5zaG91bGROb3JtYWxpemUoe1xuICAgICAgICBkaXJ0eVBhdGhzLFxuICAgICAgICBpdGVyYXRpb24sXG4gICAgICAgIGluaXRpYWxEaXJ0eVBhdGhzTGVuZ3RoLFxuICAgICAgICBvcGVyYXRpb25cbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBfZGlydHlQYXRoID0gcG9wRGlydHlQYXRoKGVkaXRvcik7XG4gICAgICAvLyBJZiB0aGUgbm9kZSBkb2Vzbid0IGV4aXN0IGluIHRoZSB0cmVlLCBpdCBkb2VzIG5vdCBuZWVkIHRvIGJlIG5vcm1hbGl6ZWQuXG4gICAgICBpZiAoTm9kZS5oYXMoZWRpdG9yLCBfZGlydHlQYXRoKSkge1xuICAgICAgICB2YXIgX2VudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBfZGlydHlQYXRoKTtcbiAgICAgICAgZWRpdG9yLm5vcm1hbGl6ZU5vZGUoX2VudHJ5LCB7XG4gICAgICAgICAgb3BlcmF0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaXRlcmF0aW9uKys7XG4gICAgICBkaXJ0eVBhdGhzID0gZ2V0RGlydHlQYXRocyhlZGl0b3IpO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgcGFyZW50ID0gZnVuY3Rpb24gcGFyZW50KGVkaXRvciwgYXQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIG9wdGlvbnMpO1xuICB2YXIgcGFyZW50UGF0aCA9IFBhdGgucGFyZW50KHBhdGgpO1xuICB2YXIgZW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhcmVudFBhdGgpO1xuICByZXR1cm4gZW50cnk7XG59O1xuXG52YXIgcGF0aFJlZiA9IGZ1bmN0aW9uIHBhdGhSZWYoZWRpdG9yLCBwYXRoKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHtcbiAgICBhZmZpbml0eSA9ICdmb3J3YXJkJ1xuICB9ID0gb3B0aW9ucztcbiAgdmFyIHJlZiA9IHtcbiAgICBjdXJyZW50OiBwYXRoLFxuICAgIGFmZmluaXR5LFxuICAgIHVucmVmKCkge1xuICAgICAgdmFyIHtcbiAgICAgICAgY3VycmVudFxuICAgICAgfSA9IHJlZjtcbiAgICAgIHZhciBwYXRoUmVmcyA9IEVkaXRvci5wYXRoUmVmcyhlZGl0b3IpO1xuICAgICAgcGF0aFJlZnMuZGVsZXRlKHJlZik7XG4gICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gIH07XG4gIHZhciByZWZzID0gRWRpdG9yLnBhdGhSZWZzKGVkaXRvcik7XG4gIHJlZnMuYWRkKHJlZik7XG4gIHJldHVybiByZWY7XG59O1xuXG52YXIgcGF0aFJlZnMgPSBlZGl0b3IgPT4ge1xuICB2YXIgcmVmcyA9IFBBVEhfUkVGUy5nZXQoZWRpdG9yKTtcbiAgaWYgKCFyZWZzKSB7XG4gICAgcmVmcyA9IG5ldyBTZXQoKTtcbiAgICBQQVRIX1JFRlMuc2V0KGVkaXRvciwgcmVmcyk7XG4gIH1cbiAgcmV0dXJuIHJlZnM7XG59O1xuXG52YXIgcGF0aCA9IGZ1bmN0aW9uIHBhdGgoZWRpdG9yLCBhdCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciB7XG4gICAgZGVwdGgsXG4gICAgZWRnZVxuICB9ID0gb3B0aW9ucztcbiAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgIGlmIChlZGdlID09PSAnc3RhcnQnKSB7XG4gICAgICB2YXIgWywgZmlyc3RQYXRoXSA9IE5vZGUuZmlyc3QoZWRpdG9yLCBhdCk7XG4gICAgICBhdCA9IGZpcnN0UGF0aDtcbiAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICB2YXIgWywgbGFzdFBhdGhdID0gTm9kZS5sYXN0KGVkaXRvciwgYXQpO1xuICAgICAgYXQgPSBsYXN0UGF0aDtcbiAgICB9XG4gIH1cbiAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICAgIGF0ID0gUmFuZ2Uuc3RhcnQoYXQpO1xuICAgIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgIGF0ID0gUmFuZ2UuZW5kKGF0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXQgPSBQYXRoLmNvbW1vbihhdC5hbmNob3IucGF0aCwgYXQuZm9jdXMucGF0aCk7XG4gICAgfVxuICB9XG4gIGlmIChQb2ludC5pc1BvaW50KGF0KSkge1xuICAgIGF0ID0gYXQucGF0aDtcbiAgfVxuICBpZiAoZGVwdGggIT0gbnVsbCkge1xuICAgIGF0ID0gYXQuc2xpY2UoMCwgZGVwdGgpO1xuICB9XG4gIHJldHVybiBhdDtcbn07XG5cbnZhciBwb2ludFJlZiA9IGZ1bmN0aW9uIHBvaW50UmVmKGVkaXRvciwgcG9pbnQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIge1xuICAgIGFmZmluaXR5ID0gJ2ZvcndhcmQnXG4gIH0gPSBvcHRpb25zO1xuICB2YXIgcmVmID0ge1xuICAgIGN1cnJlbnQ6IHBvaW50LFxuICAgIGFmZmluaXR5LFxuICAgIHVucmVmKCkge1xuICAgICAgdmFyIHtcbiAgICAgICAgY3VycmVudFxuICAgICAgfSA9IHJlZjtcbiAgICAgIHZhciBwb2ludFJlZnMgPSBFZGl0b3IucG9pbnRSZWZzKGVkaXRvcik7XG4gICAgICBwb2ludFJlZnMuZGVsZXRlKHJlZik7XG4gICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gIH07XG4gIHZhciByZWZzID0gRWRpdG9yLnBvaW50UmVmcyhlZGl0b3IpO1xuICByZWZzLmFkZChyZWYpO1xuICByZXR1cm4gcmVmO1xufTtcblxudmFyIHBvaW50UmVmcyA9IGVkaXRvciA9PiB7XG4gIHZhciByZWZzID0gUE9JTlRfUkVGUy5nZXQoZWRpdG9yKTtcbiAgaWYgKCFyZWZzKSB7XG4gICAgcmVmcyA9IG5ldyBTZXQoKTtcbiAgICBQT0lOVF9SRUZTLnNldChlZGl0b3IsIHJlZnMpO1xuICB9XG4gIHJldHVybiByZWZzO1xufTtcblxudmFyIHBvaW50ID0gZnVuY3Rpb24gcG9pbnQoZWRpdG9yLCBhdCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciB7XG4gICAgZWRnZSA9ICdzdGFydCdcbiAgfSA9IG9wdGlvbnM7XG4gIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICB2YXIgcGF0aDtcbiAgICBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgIHZhciBbLCBsYXN0UGF0aF0gPSBOb2RlLmxhc3QoZWRpdG9yLCBhdCk7XG4gICAgICBwYXRoID0gbGFzdFBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBbLCBmaXJzdFBhdGhdID0gTm9kZS5maXJzdChlZGl0b3IsIGF0KTtcbiAgICAgIHBhdGggPSBmaXJzdFBhdGg7XG4gICAgfVxuICAgIHZhciBub2RlID0gTm9kZS5nZXQoZWRpdG9yLCBwYXRoKTtcbiAgICBpZiAoIVRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBcIi5jb25jYXQoZWRnZSwgXCIgcG9pbnQgaW4gdGhlIG5vZGUgYXQgcGF0aCBbXCIpLmNvbmNhdChhdCwgXCJdIGJlY2F1c2UgaXQgaGFzIG5vIFwiKS5jb25jYXQoZWRnZSwgXCIgdGV4dCBub2RlLlwiKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwYXRoLFxuICAgICAgb2Zmc2V0OiBlZGdlID09PSAnZW5kJyA/IG5vZGUudGV4dC5sZW5ndGggOiAwXG4gICAgfTtcbiAgfVxuICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICAgIHJldHVybiBlZGdlID09PSAnc3RhcnQnID8gc3RhcnQgOiBlbmQ7XG4gIH1cbiAgcmV0dXJuIGF0O1xufTtcblxuZnVuY3Rpb24gcG9zaXRpb25zKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgIHZhciB7XG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICB1bml0ID0gJ29mZnNldCcsXG4gICAgICByZXZlcnNlID0gZmFsc2UsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGdvcml0aG0gbm90ZXM6XG4gICAgICpcbiAgICAgKiBFYWNoIHN0ZXAgYGRpc3RhbmNlYCBpcyBkeW5hbWljIGRlcGVuZGluZyBvbiB0aGUgdW5kZXJseWluZyB0ZXh0XG4gICAgICogYW5kIHRoZSBgdW5pdGAgc3BlY2lmaWVkLiAgRWFjaCBzdGVwLCBlLmcuLCBhIGxpbmUgb3Igd29yZCwgbWF5XG4gICAgICogc3BhbiBtdWx0aXBsZSB0ZXh0IG5vZGVzLCBzbyB3ZSBpdGVyYXRlIHRocm91Z2ggdGhlIHRleHQgYm90aCBvblxuICAgICAqIHR3byBsZXZlbHMgaW4gc3RlcC1zeW5jOlxuICAgICAqXG4gICAgICogYGxlYWZUZXh0YCBzdG9yZXMgdGhlIHRleHQgb24gYSB0ZXh0IGxlYWYgbGV2ZWwsIGFuZCBpcyBhZHZhbmNlZFxuICAgICAqIHRocm91Z2ggdXNpbmcgdGhlIGNvdW50ZXJzIGBsZWFmVGV4dE9mZnNldGAgYW5kIGBsZWFmVGV4dFJlbWFpbmluZ2AuXG4gICAgICpcbiAgICAgKiBgYmxvY2tUZXh0YCBzdG9yZXMgdGhlIHRleHQgb24gYSBibG9jayBsZXZlbCwgYW5kIGlzIHNob3J0ZW5lZFxuICAgICAqIGJ5IGBkaXN0YW5jZWAgZXZlcnkgdGltZSBpdCBpcyBhZHZhbmNlZC5cbiAgICAgKlxuICAgICAqIFdlIG9ubHkgbWFpbnRhaW4gYSB3aW5kb3cgb2Ygb25lIGJsb2NrVGV4dCBhbmQgb25lIGxlYWZUZXh0IGJlY2F1c2VcbiAgICAgKiBhIGJsb2NrIG5vZGUgYWx3YXlzIGFwcGVhcnMgYmVmb3JlIGFsbCBvZiBpdHMgbGVhZiBub2Rlcy5cbiAgICAgKi9cbiAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICB2YXIgZmlyc3QgPSByZXZlcnNlID8gZW5kIDogc3RhcnQ7XG4gICAgdmFyIGlzTmV3QmxvY2sgPSBmYWxzZTtcbiAgICB2YXIgYmxvY2tUZXh0ID0gJyc7XG4gICAgdmFyIGRpc3RhbmNlID0gMDsgLy8gRGlzdGFuY2UgZm9yIGxlYWZUZXh0IHRvIGNhdGNoIHVwIHRvIGJsb2NrVGV4dC5cbiAgICB2YXIgbGVhZlRleHRSZW1haW5pbmcgPSAwO1xuICAgIHZhciBsZWFmVGV4dE9mZnNldCA9IDA7XG4gICAgdmFyIHNraXBwZWRQYXRocyA9IFtdO1xuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgbm9kZXMgaW4gcmFuZ2UsIGdyYWJiaW5nIGVudGlyZSB0ZXh0dWFsIGNvbnRlbnRcbiAgICAvLyBvZiBibG9jayBub2RlcyBpbiBibG9ja1RleHQsIGFuZCB0ZXh0IG5vZGVzIGluIGxlYWZUZXh0LlxuICAgIC8vIEV4cGxvaXRzIHRoZSBmYWN0IHRoYXQgbm9kZXMgYXJlIHNlcXVlbmNlZCBpbiBzdWNoIGEgd2F5IHRoYXQgd2UgZmlyc3RcbiAgICAvLyBlbmNvdW50ZXIgdGhlIGJsb2NrIG5vZGUsIHRoZW4gYWxsIG9mIGl0cyB0ZXh0IG5vZGVzLCBzbyB3aGVuIGl0ZXJhdGluZ1xuICAgIC8vIHRocm91Z2ggdGhlIGJsb2NrVGV4dCBhbmQgbGVhZlRleHQgd2UganVzdCBuZWVkIHRvIHJlbWVtYmVyIGEgd2luZG93IG9mXG4gICAgLy8gb25lIGJsb2NrIG5vZGUgYW5kIGxlYWYgbm9kZSwgcmVzcGVjdGl2ZWx5LlxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uKiBfbG9vcChwYXRoKSB7XG4gICAgICAgIC8vIElmIHRoZSBub2RlIGlzIGluc2lkZSBhIHNraXBwZWQgYW5jZXN0b3IsIGRvIG5vdCByZXR1cm4gYW55IHBvaW50cywgYnV0XG4gICAgICAgIC8vIHN0aWxsIHByb2Nlc3MgaXRzIGNvbnRlbnQgc28gdGhhdCB0aGUgaXRlcmF0aW9uIHN0YXRlIHJlbWFpbnMgY29ycmVjdC5cbiAgICAgICAgdmFyIGhhc1NraXBwZWRBbmNlc3RvciA9IHNraXBwZWRQYXRocy5zb21lKHAgPT4gUGF0aC5pc0FuY2VzdG9yKHAsIHBhdGgpKTtcbiAgICAgICAgZnVuY3Rpb24qIG1heWJlWWllbGQocG9pbnQpIHtcbiAgICAgICAgICBpZiAoIWhhc1NraXBwZWRBbmNlc3Rvcikge1xuICAgICAgICAgICAgeWllbGQgcG9pbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqIEVMRU1FTlQgTk9ERSAtIFlpZWxkIHBvc2l0aW9uKHMpIGZvciB2b2lkcywgY29sbGVjdCBibG9ja1RleHQgZm9yIGJsb2Nrc1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgICAgaWYgKCFlZGl0b3IuaXNTZWxlY3RhYmxlKG5vZGUpKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoZSBub2RlIGlzIG5vdCBzZWxlY3RhYmxlLCBza2lwIGl0IGFuZCBpdHMgZGVzY2VuZGFudHNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2tpcHBlZFBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICAgICAgICBpZiAoUGF0aC5oYXNQcmV2aW91cyhwYXRoKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkKiBtYXliZVlpZWxkKEVkaXRvci5lbmQoZWRpdG9yLCBQYXRoLnByZXZpb3VzKHBhdGgpKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIDA7IC8vIGNvbnRpbnVlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgbmV4dFBhdGggPSBQYXRoLm5leHQocGF0aCk7XG4gICAgICAgICAgICAgIGlmIChFZGl0b3IuaGFzUGF0aChlZGl0b3IsIG5leHRQYXRoKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkKiBtYXliZVlpZWxkKEVkaXRvci5zdGFydChlZGl0b3IsIG5leHRQYXRoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIDA7IC8vIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFZvaWQgbm9kZXMgYXJlIGEgc3BlY2lhbCBjYXNlLCBzbyBieSBkZWZhdWx0IHdlIHdpbGwgYWx3YXlzXG4gICAgICAgICAgLy8geWllbGQgdGhlaXIgZmlyc3QgcG9pbnQuIElmIHRoZSBgdm9pZHNgIG9wdGlvbiBpcyBzZXQgdG8gdHJ1ZSxcbiAgICAgICAgICAvLyB0aGVuIHdlIHdpbGwgaXRlcmF0ZSBvdmVyIHRoZWlyIGNvbnRlbnQuXG4gICAgICAgICAgaWYgKCF2b2lkcyAmJiAoZWRpdG9yLmlzVm9pZChub2RlKSB8fCBlZGl0b3IuaXNFbGVtZW50UmVhZE9ubHkobm9kZSkpKSB7XG4gICAgICAgICAgICB5aWVsZCogbWF5YmVZaWVsZChFZGl0b3Iuc3RhcnQoZWRpdG9yLCBwYXRoKSk7XG4gICAgICAgICAgICByZXR1cm4gMDsgLy8gY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSW5saW5lIGVsZW1lbnQgbm9kZXMgYXJlIGlnbm9yZWQgYXMgdGhleSBkb24ndCB0aGVtc2VsdmVzXG4gICAgICAgICAgLy8gY29udHJpYnV0ZSB0byBgYmxvY2tUZXh0YCBvciBgbGVhZlRleHRgIC0gdGhlaXIgcGFyZW50IGFuZFxuICAgICAgICAgIC8vIGNoaWxkcmVuIGRvLlxuICAgICAgICAgIGlmIChlZGl0b3IuaXNJbmxpbmUobm9kZSkpIHJldHVybiAwOyAvLyBjb250aW51ZVxuICAgICAgICAgIC8vIEJsb2NrIGVsZW1lbnQgbm9kZSAtIHNldCBgYmxvY2tUZXh0YCB0byBpdHMgdGV4dCBjb250ZW50LlxuICAgICAgICAgIGlmIChFZGl0b3IuaGFzSW5saW5lcyhlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBXZSBhbHdheXMgZXhoYXVzdCBibG9jayBub2RlcyBiZWZvcmUgZW5jb3VudGVyaW5nIGEgbmV3IG9uZTpcbiAgICAgICAgICAgIC8vICAgY29uc29sZS5hc3NlcnQoYmxvY2tUZXh0ID09PSAnJyxcbiAgICAgICAgICAgIC8vICAgICBgYmxvY2tUZXh0PScke2Jsb2NrVGV4dH0nIC0gYCtcbiAgICAgICAgICAgIC8vICAgICBgbm90IGV4aGF1c3RlZCBiZWZvcmUgbmV3IGJsb2NrIG5vZGVgLCBwYXRoKVxuICAgICAgICAgICAgLy8gRW5zdXJlIHJhbmdlIGNvbnNpZGVyZWQgaXMgY2FwcGVkIHRvIGByYW5nZWAsIGluIHRoZVxuICAgICAgICAgICAgLy8gc3RhcnQvZW5kIGVkZ2UgY2FzZXMgd2hlcmUgYmxvY2sgZXh0ZW5kcyBiZXlvbmQgcmFuZ2UuXG4gICAgICAgICAgICAvLyBFcXVpdmFsZW50IHRvIHRoaXMsIGJ1dCBwcmVzdW1hYmx5IG1vcmUgcGVyZm9ybWFudDpcbiAgICAgICAgICAgIC8vICAgYmxvY2tSYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIC4uLkVkaXRvci5lZGdlcyhlZGl0b3IsIHBhdGgpKVxuICAgICAgICAgICAgLy8gICBibG9ja1JhbmdlID0gUmFuZ2UuaW50ZXJzZWN0aW9uKHJhbmdlLCBibG9ja1JhbmdlKSAvLyBpbnRlcnNlY3RcbiAgICAgICAgICAgIC8vICAgYmxvY2tUZXh0ID0gRWRpdG9yLnN0cmluZyhlZGl0b3IsIGJsb2NrUmFuZ2UsIHsgdm9pZHMgfSlcbiAgICAgICAgICAgIHZhciBlID0gUGF0aC5pc0FuY2VzdG9yKHBhdGgsIGVuZC5wYXRoKSA/IGVuZCA6IEVkaXRvci5lbmQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgICAgIHZhciBzID0gUGF0aC5pc0FuY2VzdG9yKHBhdGgsIHN0YXJ0LnBhdGgpID8gc3RhcnQgOiBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgICAgIGJsb2NrVGV4dCA9IEVkaXRvci5zdHJpbmcoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGFuY2hvcjogcyxcbiAgICAgICAgICAgICAgZm9jdXM6IGVcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaXNOZXdCbG9jayA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqIFRFWFQgTEVBRiBOT0RFIC0gSXRlcmF0ZSB0aHJvdWdoIHRleHQgY29udGVudCwgeWllbGRpbmdcbiAgICAgICAgICogcG9zaXRpb25zIGV2ZXJ5IGBkaXN0YW5jZWAgb2Zmc2V0IGFjY29yZGluZyB0byBgdW5pdGAuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgICB2YXIgaXNGaXJzdCA9IFBhdGguZXF1YWxzKHBhdGgsIGZpcnN0LnBhdGgpO1xuICAgICAgICAgIC8vIFByb29mIHRoYXQgd2UgYWx3YXlzIGV4aGF1c3QgdGV4dCBub2RlcyBiZWZvcmUgZW5jb3VudGVyaW5nIGEgbmV3IG9uZTpcbiAgICAgICAgICAvLyAgIGNvbnNvbGUuYXNzZXJ0KGxlYWZUZXh0UmVtYWluaW5nIDw9IDAsXG4gICAgICAgICAgLy8gICAgIGBsZWFmVGV4dFJlbWFpbmluZz0ke2xlYWZUZXh0UmVtYWluaW5nfSAtIGArXG4gICAgICAgICAgLy8gICAgIGBub3QgZXhoYXVzdGVkIGJlZm9yZSBuZXcgbGVhZiB0ZXh0IG5vZGVgLCBwYXRoKVxuICAgICAgICAgIC8vIFJlc2V0IGBsZWFmVGV4dGAgY291bnRlcnMgZm9yIG5ldyB0ZXh0IG5vZGUuXG4gICAgICAgICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgICAgICAgIGxlYWZUZXh0UmVtYWluaW5nID0gcmV2ZXJzZSA/IGZpcnN0Lm9mZnNldCA6IG5vZGUudGV4dC5sZW5ndGggLSBmaXJzdC5vZmZzZXQ7XG4gICAgICAgICAgICBsZWFmVGV4dE9mZnNldCA9IGZpcnN0Lm9mZnNldDsgLy8gV29ya3MgZm9yIHJldmVyc2UgdG9vLlxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZWFmVGV4dFJlbWFpbmluZyA9IG5vZGUudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBsZWFmVGV4dE9mZnNldCA9IHJldmVyc2UgPyBsZWFmVGV4dFJlbWFpbmluZyA6IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFlpZWxkIHBvc2l0aW9uIGF0IHRoZSBzdGFydCBvZiBub2RlIChwb3RlbnRpYWxseSkuXG4gICAgICAgICAgaWYgKGlzRmlyc3QgfHwgaXNOZXdCbG9jayB8fCB1bml0ID09PSAnb2Zmc2V0Jykge1xuICAgICAgICAgICAgeWllbGQqIG1heWJlWWllbGQoe1xuICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICBvZmZzZXQ6IGxlYWZUZXh0T2Zmc2V0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlzTmV3QmxvY2sgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gWWllbGQgcG9zaXRpb25zIGV2ZXJ5IChkeW5hbWljYWxseSBjYWxjdWxhdGVkKSBgZGlzdGFuY2VgIG9mZnNldC5cbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgLy8gSWYgYGxlYWZUZXh0YCBoYXMgY2F1Z2h0IHVwIHdpdGggYGJsb2NrVGV4dGAgKGRpc3RhbmNlPTApLFxuICAgICAgICAgICAgLy8gYW5kIGlmIGJsb2NrVGV4dCBpcyBleGhhdXN0ZWQsIGJyZWFrIHRvIGdldCBhbm90aGVyIGJsb2NrIG5vZGUsXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgYWR2YW5jZSBibG9ja1RleHQgZm9yd2FyZCBieSB0aGUgbmV3IGBkaXN0YW5jZWAuXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPT09IDApIHtcbiAgICAgICAgICAgICAgaWYgKGJsb2NrVGV4dCA9PT0gJycpIGJyZWFrO1xuICAgICAgICAgICAgICBkaXN0YW5jZSA9IGNhbGNEaXN0YW5jZShibG9ja1RleHQsIHVuaXQsIHJldmVyc2UpO1xuICAgICAgICAgICAgICAvLyBTcGxpdCB0aGUgc3RyaW5nIGF0IHRoZSBwcmV2aW91c2x5IGZvdW5kIGRpc3RhbmNlIGFuZCB1c2UgdGhlXG4gICAgICAgICAgICAgIC8vIHJlbWFpbmluZyBzdHJpbmcgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvbi5cbiAgICAgICAgICAgICAgYmxvY2tUZXh0ID0gc3BsaXRCeUNoYXJhY3RlckRpc3RhbmNlKGJsb2NrVGV4dCwgZGlzdGFuY2UsIHJldmVyc2UpWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWR2YW5jZSBgbGVhZlRleHRgIGJ5IHRoZSBjdXJyZW50IGBkaXN0YW5jZWAuXG4gICAgICAgICAgICBsZWFmVGV4dE9mZnNldCA9IHJldmVyc2UgPyBsZWFmVGV4dE9mZnNldCAtIGRpc3RhbmNlIDogbGVhZlRleHRPZmZzZXQgKyBkaXN0YW5jZTtcbiAgICAgICAgICAgIGxlYWZUZXh0UmVtYWluaW5nID0gbGVhZlRleHRSZW1haW5pbmcgLSBkaXN0YW5jZTtcbiAgICAgICAgICAgIC8vIElmIGBsZWFmVGV4dGAgaXMgZXhoYXVzdGVkLCBicmVhayB0byBnZXQgYSBuZXcgbGVhZiBub2RlXG4gICAgICAgICAgICAvLyBhbmQgc2V0IGRpc3RhbmNlIHRvIHRoZSBvdmVyZmxvdyBhbW91bnQsIHNvIHdlJ2xsIChtYXliZSlcbiAgICAgICAgICAgIC8vIGNhdGNoIHVwIHRvIGJsb2NrVGV4dCBpbiB0aGUgbmV4dCBsZWFmIHRleHQgbm9kZS5cbiAgICAgICAgICAgIGlmIChsZWFmVGV4dFJlbWFpbmluZyA8IDApIHtcbiAgICAgICAgICAgICAgZGlzdGFuY2UgPSAtbGVhZlRleHRSZW1haW5pbmc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3VjY2Vzc2Z1bGx5IHdhbGtlZCBgZGlzdGFuY2VgIG9mZnNldHMgdGhyb3VnaCBgbGVhZlRleHRgXG4gICAgICAgICAgICAvLyB0byBjYXRjaCB1cCB3aXRoIGBibG9ja1RleHRgLCBzbyB3ZSBjYW4gcmVzZXQgYGRpc3RhbmNlYFxuICAgICAgICAgICAgLy8gYW5kIHlpZWxkIHRoaXMgcG9zaXRpb24gaW4gdGhpcyBub2RlLlxuICAgICAgICAgICAgZGlzdGFuY2UgPSAwO1xuICAgICAgICAgICAgeWllbGQqIG1heWJlWWllbGQoe1xuICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICBvZmZzZXQ6IGxlYWZUZXh0T2Zmc2V0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfcmV0O1xuICAgIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIHJldmVyc2UsXG4gICAgICB2b2lkc1xuICAgIH0pKSB7XG4gICAgICBfcmV0ID0geWllbGQqIF9sb29wKHBhdGgpO1xuICAgICAgaWYgKF9yZXQgPT09IDApIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBQcm9vZiB0aGF0IHVwb24gY29tcGxldGlvbiwgd2UndmUgZXhhaHVzdGVkIGJvdGggbGVhZiBhbmQgYmxvY2sgdGV4dDpcbiAgICAvLyAgIGNvbnNvbGUuYXNzZXJ0KGxlYWZUZXh0UmVtYWluaW5nIDw9IDAsIFwibGVhZlRleHQgd2Fzbid0IGV4aGF1c3RlZFwiKVxuICAgIC8vICAgY29uc29sZS5hc3NlcnQoYmxvY2tUZXh0ID09PSAnJywgXCJibG9ja1RleHQgd2Fzbid0IGV4aGF1c3RlZFwiKVxuICAgIC8vIEhlbHBlcjpcbiAgICAvLyBSZXR1cm4gdGhlIGRpc3RhbmNlIGluIG9mZnNldHMgZm9yIGEgc3RlcCBvZiBzaXplIGB1bml0YCBvbiBnaXZlbiBzdHJpbmcuXG4gICAgZnVuY3Rpb24gY2FsY0Rpc3RhbmNlKHRleHQsIHVuaXQsIHJldmVyc2UpIHtcbiAgICAgIGlmICh1bml0ID09PSAnY2hhcmFjdGVyJykge1xuICAgICAgICByZXR1cm4gZ2V0Q2hhcmFjdGVyRGlzdGFuY2UodGV4dCwgcmV2ZXJzZSk7XG4gICAgICB9IGVsc2UgaWYgKHVuaXQgPT09ICd3b3JkJykge1xuICAgICAgICByZXR1cm4gZ2V0V29yZERpc3RhbmNlKHRleHQsIHJldmVyc2UpO1xuICAgICAgfSBlbHNlIGlmICh1bml0ID09PSAnbGluZScgfHwgdW5pdCA9PT0gJ2Jsb2NrJykge1xuICAgICAgICByZXR1cm4gdGV4dC5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0oKTtcbn1cblxudmFyIHByZXZpb3VzID0gZnVuY3Rpb24gcHJldmlvdXMoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIHtcbiAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgdm9pZHMgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgdmFyIHtcbiAgICBtYXRjaCxcbiAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb25cbiAgfSA9IG9wdGlvbnM7XG4gIGlmICghYXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHBvaW50QmVmb3JlTG9jYXRpb24gPSBFZGl0b3IuYmVmb3JlKGVkaXRvciwgYXQsIHtcbiAgICB2b2lkc1xuICB9KTtcbiAgaWYgKCFwb2ludEJlZm9yZUxvY2F0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBbLCB0b10gPSBFZGl0b3IuZmlyc3QoZWRpdG9yLCBbXSk7XG4gIC8vIFRoZSBzZWFyY2ggbG9jYXRpb24gaXMgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGRvY3VtZW50IHRvIHRoZSBwYXRoIG9mXG4gIC8vIHRoZSBwb2ludCBiZWZvcmUgdGhlIGxvY2F0aW9uIHBhc3NlZCBpblxuICB2YXIgc3BhbiA9IFtwb2ludEJlZm9yZUxvY2F0aW9uLnBhdGgsIHRvXTtcbiAgaWYgKFBhdGguaXNQYXRoKGF0KSAmJiBhdC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBwcmV2aW91cyBub2RlIGZyb20gdGhlIHJvb3Qgbm9kZSFcIik7XG4gIH1cbiAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICB2YXIgW3BhcmVudF0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgYXQpO1xuICAgICAgbWF0Y2ggPSBuID0+IHBhcmVudC5jaGlsZHJlbi5pbmNsdWRlcyhuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF0Y2ggPSAoKSA9PiB0cnVlO1xuICAgIH1cbiAgfVxuICB2YXIgW3ByZXZpb3VzXSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICByZXZlcnNlOiB0cnVlLFxuICAgIGF0OiBzcGFuLFxuICAgIG1hdGNoLFxuICAgIG1vZGUsXG4gICAgdm9pZHNcbiAgfSk7XG4gIHJldHVybiBwcmV2aW91cztcbn07XG5cbnZhciByYW5nZVJlZiA9IGZ1bmN0aW9uIHJhbmdlUmVmKGVkaXRvciwgcmFuZ2UpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIge1xuICAgIGFmZmluaXR5ID0gJ2ZvcndhcmQnXG4gIH0gPSBvcHRpb25zO1xuICB2YXIgcmVmID0ge1xuICAgIGN1cnJlbnQ6IHJhbmdlLFxuICAgIGFmZmluaXR5LFxuICAgIHVucmVmKCkge1xuICAgICAgdmFyIHtcbiAgICAgICAgY3VycmVudFxuICAgICAgfSA9IHJlZjtcbiAgICAgIHZhciByYW5nZVJlZnMgPSBFZGl0b3IucmFuZ2VSZWZzKGVkaXRvcik7XG4gICAgICByYW5nZVJlZnMuZGVsZXRlKHJlZik7XG4gICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gIH07XG4gIHZhciByZWZzID0gRWRpdG9yLnJhbmdlUmVmcyhlZGl0b3IpO1xuICByZWZzLmFkZChyZWYpO1xuICByZXR1cm4gcmVmO1xufTtcblxudmFyIHJhbmdlUmVmcyA9IGVkaXRvciA9PiB7XG4gIHZhciByZWZzID0gUkFOR0VfUkVGUy5nZXQoZWRpdG9yKTtcbiAgaWYgKCFyZWZzKSB7XG4gICAgcmVmcyA9IG5ldyBTZXQoKTtcbiAgICBSQU5HRV9SRUZTLnNldChlZGl0b3IsIHJlZnMpO1xuICB9XG4gIHJldHVybiByZWZzO1xufTtcblxudmFyIHJhbmdlID0gKGVkaXRvciwgYXQsIHRvKSA9PiB7XG4gIGlmIChSYW5nZS5pc1JhbmdlKGF0KSAmJiAhdG8pIHtcbiAgICByZXR1cm4gYXQ7XG4gIH1cbiAgdmFyIHN0YXJ0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgYXQpO1xuICB2YXIgZW5kID0gRWRpdG9yLmVuZChlZGl0b3IsIHRvIHx8IGF0KTtcbiAgcmV0dXJuIHtcbiAgICBhbmNob3I6IHN0YXJ0LFxuICAgIGZvY3VzOiBlbmRcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkMihlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDIoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQyKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQyKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgcmVtb3ZlTWFyayA9IChlZGl0b3IsIGtleSkgPT4ge1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgdmFyIG1hdGNoID0gKG5vZGUsIHBhdGgpID0+IHtcbiAgICAgIGlmICghVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBtYXJrcyBjYW4gb25seSBiZSBhcHBsaWVkIHRvIHRleHRcbiAgICAgIH1cblxuICAgICAgdmFyIFtwYXJlbnROb2RlLCBwYXJlbnRQYXRoXSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgIHJldHVybiAhZWRpdG9yLmlzVm9pZChwYXJlbnROb2RlKSB8fCBlZGl0b3IubWFya2FibGVWb2lkKHBhcmVudE5vZGUpO1xuICAgIH07XG4gICAgdmFyIGV4cGFuZGVkU2VsZWN0aW9uID0gUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pO1xuICAgIHZhciBtYXJrQWNjZXB0aW5nVm9pZFNlbGVjdGVkID0gZmFsc2U7XG4gICAgaWYgKCFleHBhbmRlZFNlbGVjdGlvbikge1xuICAgICAgdmFyIFtzZWxlY3RlZE5vZGUsIHNlbGVjdGVkUGF0aF0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHNlbGVjdGlvbik7XG4gICAgICBpZiAoc2VsZWN0ZWROb2RlICYmIG1hdGNoKHNlbGVjdGVkTm9kZSwgc2VsZWN0ZWRQYXRoKSkge1xuICAgICAgICB2YXIgW3BhcmVudE5vZGVdID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHNlbGVjdGVkUGF0aCk7XG4gICAgICAgIG1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQgPSBwYXJlbnROb2RlICYmIGVkaXRvci5tYXJrYWJsZVZvaWQocGFyZW50Tm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChleHBhbmRlZFNlbGVjdGlvbiB8fCBtYXJrQWNjZXB0aW5nVm9pZFNlbGVjdGVkKSB7XG4gICAgICBUcmFuc2Zvcm1zLnVuc2V0Tm9kZXMoZWRpdG9yLCBrZXksIHtcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIHNwbGl0OiB0cnVlLFxuICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXJrcyA9IF9vYmplY3RTcHJlYWQkMih7fSwgRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge30pO1xuICAgICAgZGVsZXRlIG1hcmtzW2tleV07XG4gICAgICBlZGl0b3IubWFya3MgPSBtYXJrcztcbiAgICAgIGlmICghRkxVU0hJTkcuZ2V0KGVkaXRvcikpIHtcbiAgICAgICAgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgc2V0Tm9ybWFsaXppbmcgPSAoZWRpdG9yLCBpc05vcm1hbGl6aW5nKSA9PiB7XG4gIE5PUk1BTElaSU5HLnNldChlZGl0b3IsIGlzTm9ybWFsaXppbmcpO1xufTtcblxudmFyIHN0YXJ0ID0gKGVkaXRvciwgYXQpID0+IHtcbiAgcmV0dXJuIEVkaXRvci5wb2ludChlZGl0b3IsIGF0LCB7XG4gICAgZWRnZTogJ3N0YXJ0J1xuICB9KTtcbn07XG5cbnZhciBzdHJpbmcgPSBmdW5jdGlvbiBzdHJpbmcoZWRpdG9yLCBhdCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciB7XG4gICAgdm9pZHMgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICB2YXIgdGV4dCA9ICcnO1xuICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgIGF0OiByYW5nZSxcbiAgICBtYXRjaDogVGV4dC5pc1RleHQsXG4gICAgdm9pZHNcbiAgfSkpIHtcbiAgICB2YXIgdCA9IG5vZGUudGV4dDtcbiAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgZW5kLnBhdGgpKSB7XG4gICAgICB0ID0gdC5zbGljZSgwLCBlbmQub2Zmc2V0KTtcbiAgICB9XG4gICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIHN0YXJ0LnBhdGgpKSB7XG4gICAgICB0ID0gdC5zbGljZShzdGFydC5vZmZzZXQpO1xuICAgIH1cbiAgICB0ZXh0ICs9IHQ7XG4gIH1cbiAgcmV0dXJuIHRleHQ7XG59O1xuXG52YXIgdW5oYW5nUmFuZ2UgPSBmdW5jdGlvbiB1bmhhbmdSYW5nZShlZGl0b3IsIHJhbmdlKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHtcbiAgICB2b2lkcyA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAvLyBQRVJGOiBleGl0IGVhcmx5IGlmIHdlIGNhbiBndWFyYW50ZWUgdGhhdCB0aGUgcmFuZ2UgaXNuJ3QgaGFuZ2luZy5cbiAgaWYgKHN0YXJ0Lm9mZnNldCAhPT0gMCB8fCBlbmQub2Zmc2V0ICE9PSAwIHx8IFJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKSB8fCBQYXRoLmhhc1ByZXZpb3VzKGVuZC5wYXRoKSkge1xuICAgIHJldHVybiByYW5nZTtcbiAgfVxuICB2YXIgZW5kQmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgYXQ6IGVuZCxcbiAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pLFxuICAgIHZvaWRzXG4gIH0pO1xuICB2YXIgYmxvY2tQYXRoID0gZW5kQmxvY2sgPyBlbmRCbG9ja1sxXSA6IFtdO1xuICB2YXIgZmlyc3QgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBzdGFydCk7XG4gIHZhciBiZWZvcmUgPSB7XG4gICAgYW5jaG9yOiBmaXJzdCxcbiAgICBmb2N1czogZW5kXG4gIH07XG4gIHZhciBza2lwID0gdHJ1ZTtcbiAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICBhdDogYmVmb3JlLFxuICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICByZXZlcnNlOiB0cnVlLFxuICAgIHZvaWRzXG4gIH0pKSB7XG4gICAgaWYgKHNraXApIHtcbiAgICAgIHNraXAgPSBmYWxzZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobm9kZS50ZXh0ICE9PSAnJyB8fCBQYXRoLmlzQmVmb3JlKHBhdGgsIGJsb2NrUGF0aCkpIHtcbiAgICAgIGVuZCA9IHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgb2Zmc2V0OiBub2RlLnRleHQubGVuZ3RoXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgYW5jaG9yOiBzdGFydCxcbiAgICBmb2N1czogZW5kXG4gIH07XG59O1xuXG52YXIgd2l0aG91dE5vcm1hbGl6aW5nID0gKGVkaXRvciwgZm4pID0+IHtcbiAgdmFyIHZhbHVlID0gRWRpdG9yLmlzTm9ybWFsaXppbmcoZWRpdG9yKTtcbiAgRWRpdG9yLnNldE5vcm1hbGl6aW5nKGVkaXRvciwgZmFsc2UpO1xuICB0cnkge1xuICAgIGZuKCk7XG4gIH0gZmluYWxseSB7XG4gICAgRWRpdG9yLnNldE5vcm1hbGl6aW5nKGVkaXRvciwgdmFsdWUpO1xuICB9XG4gIEVkaXRvci5ub3JtYWxpemUoZWRpdG9yKTtcbn07XG5cbnZhciBzaG91bGRNZXJnZU5vZGVzUmVtb3ZlUHJldk5vZGUgPSAoZWRpdG9yLCBfcmVmLCBfcmVmMikgPT4ge1xuICB2YXIgW3ByZXZOb2RlLCBwcmV2UGF0aF0gPSBfcmVmO1xuICAvLyBJZiB0aGUgdGFyZ2V0IG5vZGUgdGhhdCB3ZSdyZSBtZXJnaW5nIHdpdGggaXMgZW1wdHksIHJlbW92ZSBpdCBpbnN0ZWFkXG4gIC8vIG9mIG1lcmdpbmcgdGhlIHR3by4gVGhpcyBpcyBhIGNvbW1vbiByaWNoIHRleHQgZWRpdG9yIGJlaGF2aW9yIHRvXG4gIC8vIHByZXZlbnQgbG9zaW5nIGZvcm1hdHRpbmcgd2hlbiBkZWxldGluZyBlbnRpcmUgbm9kZXMgd2hlbiB5b3UgaGF2ZSBhXG4gIC8vIGhhbmdpbmcgc2VsZWN0aW9uLlxuICAvLyBpZiBwcmV2Tm9kZSBpcyBmaXJzdCBjaGlsZCBpbiBwYXJlbnQsZG9uJ3QgcmVtb3ZlIGl0LlxuICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQocHJldk5vZGUpICYmIEVkaXRvci5pc0VtcHR5KGVkaXRvciwgcHJldk5vZGUpIHx8IFRleHQuaXNUZXh0KHByZXZOb2RlKSAmJiBwcmV2Tm9kZS50ZXh0ID09PSAnJyAmJiBwcmV2UGF0aFtwcmV2UGF0aC5sZW5ndGggLSAxXSAhPT0gMDtcbn07XG5cbnZhciBkZWxldGVUZXh0ID0gZnVuY3Rpb24gZGVsZXRlVGV4dChlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgIHZhciBfRWRpdG9yJHZvaWQsIF9FZGl0b3Ikdm9pZDI7XG4gICAgdmFyIHtcbiAgICAgIHJldmVyc2UgPSBmYWxzZSxcbiAgICAgIHVuaXQgPSAnY2hhcmFjdGVyJyxcbiAgICAgIGRpc3RhbmNlID0gMSxcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgaGFuZ2luZyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaXNDb2xsYXBzZWQgPSBmYWxzZTtcbiAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkgJiYgUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICBpc0NvbGxhcHNlZCA9IHRydWU7XG4gICAgICBhdCA9IGF0LmFuY2hvcjtcbiAgICB9XG4gICAgaWYgKFBvaW50LmlzUG9pbnQoYXQpKSB7XG4gICAgICB2YXIgZnVydGhlc3RWb2lkID0gRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICAgIH0pO1xuICAgICAgaWYgKCF2b2lkcyAmJiBmdXJ0aGVzdFZvaWQpIHtcbiAgICAgICAgdmFyIFssIHZvaWRQYXRoXSA9IGZ1cnRoZXN0Vm9pZDtcbiAgICAgICAgYXQgPSB2b2lkUGF0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICAgIHVuaXQsXG4gICAgICAgICAgZGlzdGFuY2VcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRhcmdldCA9IHJldmVyc2UgPyBFZGl0b3IuYmVmb3JlKGVkaXRvciwgYXQsIG9wdHMpIHx8IEVkaXRvci5zdGFydChlZGl0b3IsIFtdKSA6IEVkaXRvci5hZnRlcihlZGl0b3IsIGF0LCBvcHRzKSB8fCBFZGl0b3IuZW5kKGVkaXRvciwgW10pO1xuICAgICAgICBhdCA9IHtcbiAgICAgICAgICBhbmNob3I6IGF0LFxuICAgICAgICAgIGZvY3VzOiB0YXJnZXRcbiAgICAgICAgfTtcbiAgICAgICAgaGFuZ2luZyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFoYW5naW5nKSB7XG4gICAgICB2YXIgWywgX2VuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgICB2YXIgZW5kT2ZEb2MgPSBFZGl0b3IuZW5kKGVkaXRvciwgW10pO1xuICAgICAgaWYgKCFQb2ludC5lcXVhbHMoX2VuZCwgZW5kT2ZEb2MpKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHtcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICB2YXIgc3RhcnRCbG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICBhdDogc3RhcnQsXG4gICAgICB2b2lkc1xuICAgIH0pO1xuICAgIHZhciBlbmRCbG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICBhdDogZW5kLFxuICAgICAgdm9pZHNcbiAgICB9KTtcbiAgICB2YXIgaXNBY3Jvc3NCbG9ja3MgPSBzdGFydEJsb2NrICYmIGVuZEJsb2NrICYmICFQYXRoLmVxdWFscyhzdGFydEJsb2NrWzFdLCBlbmRCbG9ja1sxXSk7XG4gICAgdmFyIGlzU2luZ2xlVGV4dCA9IFBhdGguZXF1YWxzKHN0YXJ0LnBhdGgsIGVuZC5wYXRoKTtcbiAgICB2YXIgc3RhcnROb25FZGl0YWJsZSA9IHZvaWRzID8gbnVsbCA6IChfRWRpdG9yJHZvaWQgPSBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgIGF0OiBzdGFydCxcbiAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgIH0pKSAhPT0gbnVsbCAmJiBfRWRpdG9yJHZvaWQgIT09IHZvaWQgMCA/IF9FZGl0b3Ikdm9pZCA6IEVkaXRvci5lbGVtZW50UmVhZE9ubHkoZWRpdG9yLCB7XG4gICAgICBhdDogc3RhcnQsXG4gICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICB9KTtcbiAgICB2YXIgZW5kTm9uRWRpdGFibGUgPSB2b2lkcyA/IG51bGwgOiAoX0VkaXRvciR2b2lkMiA9IEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgYXQ6IGVuZCxcbiAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgIH0pKSAhPT0gbnVsbCAmJiBfRWRpdG9yJHZvaWQyICE9PSB2b2lkIDAgPyBfRWRpdG9yJHZvaWQyIDogRWRpdG9yLmVsZW1lbnRSZWFkT25seShlZGl0b3IsIHtcbiAgICAgIGF0OiBlbmQsXG4gICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICB9KTtcbiAgICAvLyBJZiB0aGUgc3RhcnQgb3IgZW5kIHBvaW50cyBhcmUgaW5zaWRlIGFuIGlubGluZSB2b2lkLCBudWRnZSB0aGVtIG91dC5cbiAgICBpZiAoc3RhcnROb25FZGl0YWJsZSkge1xuICAgICAgdmFyIGJlZm9yZSA9IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBzdGFydCk7XG4gICAgICBpZiAoYmVmb3JlICYmIHN0YXJ0QmxvY2sgJiYgUGF0aC5pc0FuY2VzdG9yKHN0YXJ0QmxvY2tbMV0sIGJlZm9yZS5wYXRoKSkge1xuICAgICAgICBzdGFydCA9IGJlZm9yZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuZE5vbkVkaXRhYmxlKSB7XG4gICAgICB2YXIgYWZ0ZXIgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBlbmQpO1xuICAgICAgaWYgKGFmdGVyICYmIGVuZEJsb2NrICYmIFBhdGguaXNBbmNlc3RvcihlbmRCbG9ja1sxXSwgYWZ0ZXIucGF0aCkpIHtcbiAgICAgICAgZW5kID0gYWZ0ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEdldCB0aGUgaGlnaGVzdCBub2RlcyB0aGF0IGFyZSBjb21wbGV0ZWx5IGluc2lkZSB0aGUgcmFuZ2UsIGFzIHdlbGwgYXNcbiAgICAvLyB0aGUgc3RhcnQgYW5kIGVuZCBub2Rlcy5cbiAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgIHZhciBsYXN0UGF0aDtcbiAgICBmb3IgKHZhciBlbnRyeSBvZiBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIHZvaWRzXG4gICAgfSkpIHtcbiAgICAgIHZhciBbbm9kZSwgcGF0aF0gPSBlbnRyeTtcbiAgICAgIGlmIChsYXN0UGF0aCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgbGFzdFBhdGgpID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCF2b2lkcyAmJiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiAoRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpIHx8IEVkaXRvci5pc0VsZW1lbnRSZWFkT25seShlZGl0b3IsIG5vZGUpKSB8fCAhUGF0aC5pc0NvbW1vbihwYXRoLCBzdGFydC5wYXRoKSAmJiAhUGF0aC5pc0NvbW1vbihwYXRoLCBlbmQucGF0aCkpIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgbGFzdFBhdGggPSBwYXRoO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKG1hdGNoZXMsIF9yZWYgPT4ge1xuICAgICAgdmFyIFssIHBdID0gX3JlZjtcbiAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgIH0pO1xuICAgIHZhciBzdGFydFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIHN0YXJ0KTtcbiAgICB2YXIgZW5kUmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICB2YXIgcmVtb3ZlZFRleHQgPSAnJztcbiAgICBpZiAoIWlzU2luZ2xlVGV4dCAmJiAhc3RhcnROb25FZGl0YWJsZSkge1xuICAgICAgdmFyIF9wb2ludCA9IHN0YXJ0UmVmLmN1cnJlbnQ7XG4gICAgICB2YXIgW19ub2RlXSA9IEVkaXRvci5sZWFmKGVkaXRvciwgX3BvaW50KTtcbiAgICAgIHZhciB7XG4gICAgICAgIHBhdGg6IF9wYXRoXG4gICAgICB9ID0gX3BvaW50O1xuICAgICAgdmFyIHtcbiAgICAgICAgb2Zmc2V0XG4gICAgICB9ID0gc3RhcnQ7XG4gICAgICB2YXIgdGV4dCA9IF9ub2RlLnRleHQuc2xpY2Uob2Zmc2V0KTtcbiAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICB0eXBlOiAncmVtb3ZlX3RleHQnLFxuICAgICAgICAgIHBhdGg6IF9wYXRoLFxuICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICB0ZXh0XG4gICAgICAgIH0pO1xuICAgICAgICByZW1vdmVkVGV4dCA9IHRleHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHBhdGhSZWZzLnJldmVyc2UoKS5tYXAociA9PiByLnVucmVmKCkpLmZpbHRlcihyID0+IHIgIT09IG51bGwpLmZvckVhY2gocCA9PiBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IHAsXG4gICAgICB2b2lkc1xuICAgIH0pKTtcbiAgICBpZiAoIWVuZE5vbkVkaXRhYmxlKSB7XG4gICAgICB2YXIgX3BvaW50MiA9IGVuZFJlZi5jdXJyZW50O1xuICAgICAgdmFyIFtfbm9kZTJdID0gRWRpdG9yLmxlYWYoZWRpdG9yLCBfcG9pbnQyKTtcbiAgICAgIHZhciB7XG4gICAgICAgIHBhdGg6IF9wYXRoMlxuICAgICAgfSA9IF9wb2ludDI7XG4gICAgICB2YXIgX29mZnNldCA9IGlzU2luZ2xlVGV4dCA/IHN0YXJ0Lm9mZnNldCA6IDA7XG4gICAgICB2YXIgX3RleHQgPSBfbm9kZTIudGV4dC5zbGljZShfb2Zmc2V0LCBlbmQub2Zmc2V0KTtcbiAgICAgIGlmIChfdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgdHlwZTogJ3JlbW92ZV90ZXh0JyxcbiAgICAgICAgICBwYXRoOiBfcGF0aDIsXG4gICAgICAgICAgb2Zmc2V0OiBfb2Zmc2V0LFxuICAgICAgICAgIHRleHQ6IF90ZXh0XG4gICAgICAgIH0pO1xuICAgICAgICByZW1vdmVkVGV4dCA9IF90ZXh0O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzU2luZ2xlVGV4dCAmJiBpc0Fjcm9zc0Jsb2NrcyAmJiBlbmRSZWYuY3VycmVudCAmJiBzdGFydFJlZi5jdXJyZW50KSB7XG4gICAgICBUcmFuc2Zvcm1zLm1lcmdlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlbmRSZWYuY3VycmVudCxcbiAgICAgICAgaGFuZ2luZzogdHJ1ZSxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBGb3IgY2VydGFpbiBzY3JpcHRzLCBkZWxldGluZyBOIGNoYXJhY3RlcihzKSBiYWNrd2FyZCBzaG91bGQgZGVsZXRlXG4gICAgLy8gTiBjb2RlIHBvaW50KHMpIGluc3RlYWQgb2YgYW4gZW50aXJlIGdyYXBoZW1lIGNsdXN0ZXIuXG4gICAgLy8gVGhlcmVmb3JlLCB0aGUgcmVtYWluaW5nIGNvZGUgcG9pbnRzIHNob3VsZCBiZSBpbnNlcnRlZCBiYWNrLlxuICAgIC8vIEJlbmdhbGk6IFxcdTA5ODAtXFx1MDlGRlxuICAgIC8vIFRoYWk6IFxcdTBFMDAtXFx1MEU3RlxuICAgIC8vIEJ1cm1lc2UgKE15YW5tYXIpOiBcXHUxMDAwLVxcdTEwOUZcbiAgICAvLyBIaW5kaSAoRGV2YW5hZ2FyaSk6IFxcdTA5MDAtXFx1MDk3RlxuICAgIC8vIEtobWVyOiBcXHUxNzgwLVxcdTE3RkZcbiAgICAvLyBNYWxheWFsYW06IFxcdTBEMDAtXFx1MEQ3RlxuICAgIC8vIE9yaXlhOiBcXHUwQjAwLVxcdTBCN0ZcbiAgICAvLyBQdW5qYWJpIChHdXJtdWtoaSk6IFxcdTBBMDAtXFx1MEE3RlxuICAgIC8vIFRhbWlsOiBcXHUwQjgwLVxcdTBCRkZcbiAgICAvLyBUZWx1Z3U6IFxcdTBDMDAtXFx1MEM3RlxuICAgIGlmIChpc0NvbGxhcHNlZCAmJiByZXZlcnNlICYmIHVuaXQgPT09ICdjaGFyYWN0ZXInICYmIHJlbW92ZWRUZXh0Lmxlbmd0aCA+IDEgJiYgcmVtb3ZlZFRleHQubWF0Y2goL1tcXHUwOTgwLVxcdTA5RkZcXHUwRTAwLVxcdTBFN0ZcXHUxMDAwLVxcdTEwOUZcXHUwOTAwLVxcdTA5N0ZcXHUxNzgwLVxcdTE3RkZcXHUwRDAwLVxcdTBEN0ZcXHUwQjAwLVxcdTBCN0ZcXHUwQTAwLVxcdTBBN0ZcXHUwQjgwLVxcdTBCRkZcXHUwQzAwLVxcdTBDN0ZdKy8pKSB7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydFRleHQoZWRpdG9yLCByZW1vdmVkVGV4dC5zbGljZSgwLCByZW1vdmVkVGV4dC5sZW5ndGggLSBkaXN0YW5jZSkpO1xuICAgIH1cbiAgICB2YXIgc3RhcnRVbnJlZiA9IHN0YXJ0UmVmLnVucmVmKCk7XG4gICAgdmFyIGVuZFVucmVmID0gZW5kUmVmLnVucmVmKCk7XG4gICAgdmFyIHBvaW50ID0gcmV2ZXJzZSA/IHN0YXJ0VW5yZWYgfHwgZW5kVW5yZWYgOiBlbmRVbnJlZiB8fCBzdGFydFVucmVmO1xuICAgIGlmIChvcHRpb25zLmF0ID09IG51bGwgJiYgcG9pbnQpIHtcbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcG9pbnQpO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgaW5zZXJ0RnJhZ21lbnQgPSBmdW5jdGlvbiBpbnNlcnRGcmFnbWVudChlZGl0b3IsIGZyYWdtZW50KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICB2YXIge1xuICAgICAgaGFuZ2luZyA9IGZhbHNlLFxuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBhdCA9IGdldERlZmF1bHRJbnNlcnRMb2NhdGlvbihlZGl0b3IpLFxuICAgICAgYmF0Y2hEaXJ0eSA9IHRydWVcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAoIWZyYWdtZW50Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGlmICghaGFuZ2luZykge1xuICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgICAgIGlmICghdm9pZHMgJiYgRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVuZFxuICAgICAgICB9KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9pbnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBlbmQpO1xuICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICBhdFxuICAgICAgICB9KTtcbiAgICAgICAgYXQgPSBwb2ludFJlZi51bnJlZigpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICBhdCA9IEVkaXRvci5zdGFydChlZGl0b3IsIGF0KTtcbiAgICB9XG4gICAgaWYgKCF2b2lkcyAmJiBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgIGF0XG4gICAgfSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgdGhlIGluc2VydCBwb2ludCBpcyBhdCB0aGUgZWRnZSBvZiBhbiBpbmxpbmUgbm9kZSwgbW92ZSBpdCBvdXRzaWRlXG4gICAgLy8gaW5zdGVhZCBzaW5jZSBpdCB3aWxsIG5lZWQgdG8gYmUgc3BsaXQgb3RoZXJ3aXNlLlxuICAgIHZhciBpbmxpbmVFbGVtZW50TWF0Y2ggPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pLFxuICAgICAgbW9kZTogJ2hpZ2hlc3QnLFxuICAgICAgdm9pZHNcbiAgICB9KTtcbiAgICBpZiAoaW5saW5lRWxlbWVudE1hdGNoKSB7XG4gICAgICB2YXIgWywgX2lubGluZVBhdGhdID0gaW5saW5lRWxlbWVudE1hdGNoO1xuICAgICAgaWYgKEVkaXRvci5pc0VuZChlZGl0b3IsIGF0LCBfaW5saW5lUGF0aCkpIHtcbiAgICAgICAgdmFyIGFmdGVyID0gRWRpdG9yLmFmdGVyKGVkaXRvciwgX2lubGluZVBhdGgpO1xuICAgICAgICBhdCA9IGFmdGVyO1xuICAgICAgfSBlbHNlIGlmIChFZGl0b3IuaXNTdGFydChlZGl0b3IsIGF0LCBfaW5saW5lUGF0aCkpIHtcbiAgICAgICAgdmFyIGJlZm9yZSA9IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBfaW5saW5lUGF0aCk7XG4gICAgICAgIGF0ID0gYmVmb3JlO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgYmxvY2tNYXRjaCA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICBhdCxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG4gICAgdmFyIFssIGJsb2NrUGF0aF0gPSBibG9ja01hdGNoO1xuICAgIHZhciBpc0Jsb2NrU3RhcnQgPSBFZGl0b3IuaXNTdGFydChlZGl0b3IsIGF0LCBibG9ja1BhdGgpO1xuICAgIHZhciBpc0Jsb2NrRW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgYXQsIGJsb2NrUGF0aCk7XG4gICAgdmFyIGlzQmxvY2tFbXB0eSA9IGlzQmxvY2tTdGFydCAmJiBpc0Jsb2NrRW5kO1xuICAgIHZhciBbLCBmaXJzdExlYWZQYXRoXSA9IE5vZGUuZmlyc3Qoe1xuICAgICAgY2hpbGRyZW46IGZyYWdtZW50XG4gICAgfSwgW10pO1xuICAgIHZhciBbLCBsYXN0TGVhZlBhdGhdID0gTm9kZS5sYXN0KHtcbiAgICAgIGNoaWxkcmVuOiBmcmFnbWVudFxuICAgIH0sIFtdKTtcbiAgICAvLyBGb3IgZWFjaCBub2RlIGluIHRoZSBmcmFnbWVudCwgZGV0ZXJtaW5lIHdoYXQgbGV2ZWwgb2Ygd3JhcHBpbmcgc2hvdWxkXG4gICAgLy8gYmUga2VwdC4gQXQgbWluaW11bSwgYWxsIHRleHQgbm9kZXMgd2lsbCBiZSBpbnNlcnRlZCwgYnV0IGlmXG4gICAgLy8gYHNob3VsZEluc2VydGAgcmV0dXJucyB0cnVlIGZvciBzb21lIGFuY2VzdG9yIG9mIGEgcGFydGljdWxhciB0ZXh0IG5vZGUsXG4gICAgLy8gdGhlbiB0aGUgZW50aXJlIGFuY2VzdG9yIHdpbGwgYmUgaW5zZXJ0ZWQgcmF0aGVyIHRoYW4gaW5zZXJ0aW5nIHRoZSB0ZXh0XG4gICAgLy8gbm9kZXMgaW5kaXZpZHVhbGx5LlxuICAgIHZhciBzaG91bGRJbnNlcnQgPSBfcmVmID0+IHtcbiAgICAgIHZhciBbbiwgcF0gPSBfcmVmO1xuICAgICAgdmFyIGlzUm9vdCA9IHAubGVuZ3RoID09PSAwO1xuICAgICAgaWYgKGlzUm9vdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBJZiB0aGUgZGVzdGluYXRpb24gYmxvY2sgaXMgZW1wdHksIGluc2VydCBhbGwgdG9wLWxldmVsIGJsb2NrcyBvZiB0aGVcbiAgICAgIC8vIGZyYWdtZW50LlxuICAgICAgaWYgKGlzQmxvY2tFbXB0eSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIFVubGVzcyB3ZSdyZSBhdCB0aGUgc3RhcnQgb2YgdGhlIGRlc3RpbmF0aW9uIGJsb2NrLCB1bndyYXAgYW55XG4gICAgICAvLyBub24tdm9pZCBibG9ja3MgdGhhdCBjb250YWluIHRoZSBmaXJzdCBsZWFmIG5vZGUgaW4gdGhlIGZyYWdtZW50LlxuICAgICAgaWYgKCFpc0Jsb2NrU3RhcnQgJiYgUGF0aC5pc0FuY2VzdG9yKHAsIGZpcnN0TGVhZlBhdGgpICYmIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmICFlZGl0b3IuaXNWb2lkKG4pICYmICFlZGl0b3IuaXNJbmxpbmUobikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gVW5sZXNzIHdlJ3JlIGF0IHRoZSBlbmQgb2YgdGhlIGRlc3RpbmF0aW9uIGJsb2NrLCB1bndyYXAgYW55IG5vbi12b2lkXG4gICAgICAvLyBibG9ja3MgdGhhdCBjb250YWluIHRoZSBsYXN0IGxlYWYgbm9kZSBpbiB0aGUgZnJhZ21lbnQuXG4gICAgICBpZiAoIWlzQmxvY2tFbmQgJiYgUGF0aC5pc0FuY2VzdG9yKHAsIGxhc3RMZWFmUGF0aCkgJiYgRWxlbWVudC5pc0VsZW1lbnQobikgJiYgIWVkaXRvci5pc1ZvaWQobikgJiYgIWVkaXRvci5pc0lubGluZShuKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBbHdheXMgaW5zZXJ0IHZvaWQgbm9kZXMsIGlubGluZSBlbGVtZW50cyBhbmQgdGV4dCBub2Rlcy5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLy8gV2hldGhlciB0aGUgY3VycmVudCBub2RlIGlzIGluIHRoZSBmaXJzdCBibG9jayBvZiB0aGUgZnJhZ21lbnQuXG4gICAgdmFyIHN0YXJ0aW5nID0gdHJ1ZTtcbiAgICAvLyBJbmxpbmUgbm9kZXMgaW4gdGhlIGZpcnN0IGJsb2NrIG9mIHRoZSBmcmFnbWVudCwgdG8gYmUgbWVyZ2VkIHdpdGggdGhlXG4gICAgLy8gZGVzdGluYXRpb24gYmxvY2suXG4gICAgdmFyIHN0YXJ0cyA9IFtdO1xuICAgIC8vIEJsb2NrcyBpbiB0aGUgbWlkZGxlIG9mIHRoZSBmcmFnbWVudC5cbiAgICB2YXIgbWlkZGxlcyA9IFtdO1xuICAgIC8vIElubGluZSBub2RlcyBpbiB0aGUgbGFzdCBibG9jayBvZiB0aGUgZnJhZ21lbnQsIHRvIGJlIG1lcmdlZCB3aXRoIHRoZVxuICAgIC8vIGRlc3RpbmF0aW9uIGJsb2NrLiBJZiB0aGUgZnJhZ21lbnQgY29udGFpbnMgb25seSBvbmUgYmxvY2ssIHRoaXMgd2lsbCBiZVxuICAgIC8vIGVtcHR5LlxuICAgIHZhciBlbmRzID0gW107XG4gICAgZm9yICh2YXIgZW50cnkgb2YgTm9kZS5ub2Rlcyh7XG4gICAgICBjaGlsZHJlbjogZnJhZ21lbnRcbiAgICB9LCB7XG4gICAgICBwYXNzOiBzaG91bGRJbnNlcnRcbiAgICB9KSkge1xuICAgICAgdmFyIFtub2RlLCBwYXRoXSA9IGVudHJ5O1xuICAgICAgLy8gSWYgd2UgZW5jb3VudGVyIGEgYmxvY2sgdGhhdCBkb2VzIG5vdCBjb250YWluIHRoZSBmaXJzdCBsZWFmLCB3ZSdyZSBub1xuICAgICAgLy8gbG9uZ2VyIGluIHRoZSBmaXJzdCBibG9jayBvZiB0aGUgZnJhZ21lbnQuXG4gICAgICBpZiAoc3RhcnRpbmcgJiYgRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgIWVkaXRvci5pc0lubGluZShub2RlKSAmJiAhUGF0aC5pc0FuY2VzdG9yKHBhdGgsIGZpcnN0TGVhZlBhdGgpKSB7XG4gICAgICAgIHN0YXJ0aW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkSW5zZXJ0KGVudHJ5KSkge1xuICAgICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgIWVkaXRvci5pc0lubGluZShub2RlKSkge1xuICAgICAgICAgIHN0YXJ0aW5nID0gZmFsc2U7XG4gICAgICAgICAgbWlkZGxlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0aW5nKSB7XG4gICAgICAgICAgc3RhcnRzLnB1c2gobm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBbaW5saW5lTWF0Y2hdID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICBtYXRjaDogbiA9PiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSxcbiAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG4gICAgdmFyIFssIGlubGluZVBhdGhdID0gaW5saW5lTWF0Y2g7XG4gICAgdmFyIGlzSW5saW5lU3RhcnQgPSBFZGl0b3IuaXNTdGFydChlZGl0b3IsIGF0LCBpbmxpbmVQYXRoKTtcbiAgICB2YXIgaXNJbmxpbmVFbmQgPSBFZGl0b3IuaXNFbmQoZWRpdG9yLCBhdCwgaW5saW5lUGF0aCk7XG4gICAgdmFyIG1pZGRsZVJlZiA9IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgaXNCbG9ja0VuZCAmJiAhZW5kcy5sZW5ndGggPyBQYXRoLm5leHQoYmxvY2tQYXRoKSA6IGJsb2NrUGF0aCk7XG4gICAgdmFyIGVuZFJlZiA9IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgaXNJbmxpbmVFbmQgPyBQYXRoLm5leHQoaW5saW5lUGF0aCkgOiBpbmxpbmVQYXRoKTtcbiAgICAvLyBJZiB0aGUgZnJhZ21lbnQgY29udGFpbnMgaW5saW5lcyBpbiBtdWx0aXBsZSBkaXN0aW5jdCBibG9ja3MsIHNwbGl0IHRoZVxuICAgIC8vIGRlc3RpbmF0aW9uIGJsb2NrLlxuICAgIHZhciBzcGxpdEJsb2NrID0gZW5kcy5sZW5ndGggPiAwO1xuICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0LFxuICAgICAgbWF0Y2g6IG4gPT4gc3BsaXRCbG9jayA/IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbikgOiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSxcbiAgICAgIG1vZGU6IHNwbGl0QmxvY2sgPyAnbG93ZXN0JyA6ICdoaWdoZXN0JyxcbiAgICAgIGFsd2F5czogc3BsaXRCbG9jayAmJiAoIWlzQmxvY2tTdGFydCB8fCBzdGFydHMubGVuZ3RoID4gMCkgJiYgKCFpc0Jsb2NrRW5kIHx8IGVuZHMubGVuZ3RoID4gMCksXG4gICAgICB2b2lkc1xuICAgIH0pO1xuICAgIHZhciBzdGFydFJlZiA9IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgIWlzSW5saW5lU3RhcnQgfHwgaXNJbmxpbmVTdGFydCAmJiBpc0lubGluZUVuZCA/IFBhdGgubmV4dChpbmxpbmVQYXRoKSA6IGlubGluZVBhdGgpO1xuICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBzdGFydHMsIHtcbiAgICAgIGF0OiBzdGFydFJlZi5jdXJyZW50LFxuICAgICAgbWF0Y2g6IG4gPT4gVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbiksXG4gICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICB2b2lkcyxcbiAgICAgIGJhdGNoRGlydHlcbiAgICB9KTtcbiAgICBpZiAoaXNCbG9ja0VtcHR5ICYmICFzdGFydHMubGVuZ3RoICYmIG1pZGRsZXMubGVuZ3RoICYmICFlbmRzLmxlbmd0aCkge1xuICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBibG9ja1BhdGgsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICB9XG4gICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIG1pZGRsZXMsIHtcbiAgICAgIGF0OiBtaWRkbGVSZWYuY3VycmVudCxcbiAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICBtb2RlOiAnbG93ZXN0JyxcbiAgICAgIHZvaWRzLFxuICAgICAgYmF0Y2hEaXJ0eVxuICAgIH0pO1xuICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBlbmRzLCB7XG4gICAgICBhdDogZW5kUmVmLmN1cnJlbnQsXG4gICAgICBtYXRjaDogbiA9PiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSxcbiAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgIHZvaWRzLFxuICAgICAgYmF0Y2hEaXJ0eVxuICAgIH0pO1xuICAgIGlmICghb3B0aW9ucy5hdCkge1xuICAgICAgdmFyIF9wYXRoO1xuICAgICAgaWYgKGVuZHMubGVuZ3RoID4gMCAmJiBlbmRSZWYuY3VycmVudCkge1xuICAgICAgICBfcGF0aCA9IFBhdGgucHJldmlvdXMoZW5kUmVmLmN1cnJlbnQpO1xuICAgICAgfSBlbHNlIGlmIChtaWRkbGVzLmxlbmd0aCA+IDAgJiYgbWlkZGxlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgX3BhdGggPSBQYXRoLnByZXZpb3VzKG1pZGRsZVJlZi5jdXJyZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnRSZWYuY3VycmVudCkge1xuICAgICAgICBfcGF0aCA9IFBhdGgucHJldmlvdXMoc3RhcnRSZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgICBpZiAoX3BhdGgpIHtcbiAgICAgICAgdmFyIF9lbmQgPSBFZGl0b3IuZW5kKGVkaXRvciwgX3BhdGgpO1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIF9lbmQpO1xuICAgICAgfVxuICAgIH1cbiAgICBzdGFydFJlZi51bnJlZigpO1xuICAgIG1pZGRsZVJlZi51bnJlZigpO1xuICAgIGVuZFJlZi51bnJlZigpO1xuICB9KTtcbn07XG5cbnZhciBjb2xsYXBzZSA9IGZ1bmN0aW9uIGNvbGxhcHNlKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciB7XG4gICAgZWRnZSA9ICdhbmNob3InXG4gIH0gPSBvcHRpb25zO1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuICBpZiAoIXNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChlZGdlID09PSAnYW5jaG9yJykge1xuICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc2VsZWN0aW9uLmFuY2hvcik7XG4gIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2ZvY3VzJykge1xuICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc2VsZWN0aW9uLmZvY3VzKTtcbiAgfSBlbHNlIGlmIChlZGdlID09PSAnc3RhcnQnKSB7XG4gICAgdmFyIFtzdGFydF0gPSBSYW5nZS5lZGdlcyhzZWxlY3Rpb24pO1xuICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc3RhcnQpO1xuICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhzZWxlY3Rpb24pO1xuICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgZW5kKTtcbiAgfVxufTtcblxudmFyIGRlc2VsZWN0ID0gZWRpdG9yID0+IHtcbiAgdmFyIHtcbiAgICBzZWxlY3Rpb25cbiAgfSA9IGVkaXRvcjtcbiAgaWYgKHNlbGVjdGlvbikge1xuICAgIGVkaXRvci5hcHBseSh7XG4gICAgICB0eXBlOiAnc2V0X3NlbGVjdGlvbicsXG4gICAgICBwcm9wZXJ0aWVzOiBzZWxlY3Rpb24sXG4gICAgICBuZXdQcm9wZXJ0aWVzOiBudWxsXG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBtb3ZlID0gZnVuY3Rpb24gbW92ZShlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuICB2YXIge1xuICAgIGRpc3RhbmNlID0gMSxcbiAgICB1bml0ID0gJ2NoYXJhY3RlcicsXG4gICAgcmV2ZXJzZSA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICB2YXIge1xuICAgIGVkZ2UgPSBudWxsXG4gIH0gPSBvcHRpb25zO1xuICBpZiAoIXNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgIGVkZ2UgPSBSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbikgPyAnZm9jdXMnIDogJ2FuY2hvcic7XG4gIH1cbiAgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgZWRnZSA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSA/ICdhbmNob3InIDogJ2ZvY3VzJztcbiAgfVxuICB2YXIge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9ID0gc2VsZWN0aW9uO1xuICB2YXIgb3B0cyA9IHtcbiAgICBkaXN0YW5jZSxcbiAgICB1bml0XG4gIH07XG4gIHZhciBwcm9wcyA9IHt9O1xuICBpZiAoZWRnZSA9PSBudWxsIHx8IGVkZ2UgPT09ICdhbmNob3InKSB7XG4gICAgdmFyIHBvaW50ID0gcmV2ZXJzZSA/IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBhbmNob3IsIG9wdHMpIDogRWRpdG9yLmFmdGVyKGVkaXRvciwgYW5jaG9yLCBvcHRzKTtcbiAgICBpZiAocG9pbnQpIHtcbiAgICAgIHByb3BzLmFuY2hvciA9IHBvaW50O1xuICAgIH1cbiAgfVxuICBpZiAoZWRnZSA9PSBudWxsIHx8IGVkZ2UgPT09ICdmb2N1cycpIHtcbiAgICB2YXIgX3BvaW50ID0gcmV2ZXJzZSA/IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBmb2N1cywgb3B0cykgOiBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBmb2N1cywgb3B0cyk7XG4gICAgaWYgKF9wb2ludCkge1xuICAgICAgcHJvcHMuZm9jdXMgPSBfcG9pbnQ7XG4gICAgfVxuICB9XG4gIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwgcHJvcHMpO1xufTtcblxudmFyIHNlbGVjdCA9IChlZGl0b3IsIHRhcmdldCkgPT4ge1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuICB0YXJnZXQgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCB0YXJnZXQpO1xuICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCB0YXJnZXQpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIVJhbmdlLmlzUmFuZ2UodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIldoZW4gc2V0dGluZyB0aGUgc2VsZWN0aW9uIGFuZCB0aGUgY3VycmVudCBzZWxlY3Rpb24gaXMgYG51bGxgIHlvdSBtdXN0IHByb3ZpZGUgYXQgbGVhc3QgYW4gYGFuY2hvcmAgYW5kIGBmb2N1c2AsIGJ1dCB5b3UgcGFzc2VkOiBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHRhcmdldCkpKTtcbiAgfVxuICBlZGl0b3IuYXBwbHkoe1xuICAgIHR5cGU6ICdzZXRfc2VsZWN0aW9uJyxcbiAgICBwcm9wZXJ0aWVzOiBzZWxlY3Rpb24sXG4gICAgbmV3UHJvcGVydGllczogdGFyZ2V0XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gb3duS2V5cyQxKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMShlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDEoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDEoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbnZhciBzZXRQb2ludCA9IGZ1bmN0aW9uIHNldFBvaW50KGVkaXRvciwgcHJvcHMpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuICB2YXIge1xuICAgIGVkZ2UgPSAnYm90aCdcbiAgfSA9IG9wdGlvbnM7XG4gIGlmICghc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlZGdlID09PSAnc3RhcnQnKSB7XG4gICAgZWRnZSA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSA/ICdmb2N1cycgOiAnYW5jaG9yJztcbiAgfVxuICBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICBlZGdlID0gUmFuZ2UuaXNCYWNrd2FyZChzZWxlY3Rpb24pID8gJ2FuY2hvcicgOiAnZm9jdXMnO1xuICB9XG4gIHZhciB7XG4gICAgYW5jaG9yLFxuICAgIGZvY3VzXG4gIH0gPSBzZWxlY3Rpb247XG4gIHZhciBwb2ludCA9IGVkZ2UgPT09ICdhbmNob3InID8gYW5jaG9yIDogZm9jdXM7XG4gIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwge1xuICAgIFtlZGdlID09PSAnYW5jaG9yJyA/ICdhbmNob3InIDogJ2ZvY3VzJ106IF9vYmplY3RTcHJlYWQkMShfb2JqZWN0U3ByZWFkJDEoe30sIHBvaW50KSwgcHJvcHMpXG4gIH0pO1xufTtcblxudmFyIHNldFNlbGVjdGlvbiA9IChlZGl0b3IsIHByb3BzKSA9PiB7XG4gIHZhciB7XG4gICAgc2VsZWN0aW9uXG4gIH0gPSBlZGl0b3I7XG4gIHZhciBvbGRQcm9wcyA9IHt9O1xuICB2YXIgbmV3UHJvcHMgPSB7fTtcbiAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgayBpbiBwcm9wcykge1xuICAgIGlmIChrID09PSAnYW5jaG9yJyAmJiBwcm9wcy5hbmNob3IgIT0gbnVsbCAmJiAhUG9pbnQuZXF1YWxzKHByb3BzLmFuY2hvciwgc2VsZWN0aW9uLmFuY2hvcikgfHwgayA9PT0gJ2ZvY3VzJyAmJiBwcm9wcy5mb2N1cyAhPSBudWxsICYmICFQb2ludC5lcXVhbHMocHJvcHMuZm9jdXMsIHNlbGVjdGlvbi5mb2N1cykgfHwgayAhPT0gJ2FuY2hvcicgJiYgayAhPT0gJ2ZvY3VzJyAmJiBwcm9wc1trXSAhPT0gc2VsZWN0aW9uW2tdKSB7XG4gICAgICBvbGRQcm9wc1trXSA9IHNlbGVjdGlvbltrXTtcbiAgICAgIG5ld1Byb3BzW2tdID0gcHJvcHNba107XG4gICAgfVxuICB9XG4gIGlmIChPYmplY3Qua2V5cyhvbGRQcm9wcykubGVuZ3RoID4gMCkge1xuICAgIGVkaXRvci5hcHBseSh7XG4gICAgICB0eXBlOiAnc2V0X3NlbGVjdGlvbicsXG4gICAgICBwcm9wZXJ0aWVzOiBvbGRQcm9wcyxcbiAgICAgIG5ld1Byb3BlcnRpZXM6IG5ld1Byb3BzXG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBpbnNlcnROb2RlcyA9IGZ1bmN0aW9uIGluc2VydE5vZGVzKGVkaXRvciwgbm9kZXMpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgIHZhciB7XG4gICAgICBoYW5naW5nID0gZmFsc2UsXG4gICAgICB2b2lkcyA9IGZhbHNlLFxuICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgYmF0Y2hEaXJ0eSA9IHRydWVcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgYXQsXG4gICAgICBtYXRjaCxcbiAgICAgIHNlbGVjdFxuICAgIH0gPSBvcHRpb25zO1xuICAgIGlmIChOb2RlLmlzTm9kZShub2RlcykpIHtcbiAgICAgIG5vZGVzID0gW25vZGVzXTtcbiAgICB9XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgW25vZGVdID0gbm9kZXM7XG4gICAgaWYgKCFhdCkge1xuICAgICAgYXQgPSBnZXREZWZhdWx0SW5zZXJ0TG9jYXRpb24oZWRpdG9yKTtcbiAgICAgIGlmIChzZWxlY3QgIT09IGZhbHNlKSB7XG4gICAgICAgIHNlbGVjdCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzZWxlY3QgPT0gbnVsbCkge1xuICAgICAgc2VsZWN0ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgaWYgKCFoYW5naW5nKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHtcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgWywgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICAgICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgYXRcbiAgICAgICAgfSk7XG4gICAgICAgIGF0ID0gcG9pbnRSZWYudW5yZWYoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKFBvaW50LmlzUG9pbnQoYXQpKSB7XG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgICBtYXRjaCA9IG4gPT4gVGV4dC5pc1RleHQobik7XG4gICAgICAgIH0gZWxzZSBpZiAoZWRpdG9yLmlzSW5saW5lKG5vZGUpKSB7XG4gICAgICAgICAgbWF0Y2ggPSBuID0+IFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoID0gbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgW2VudHJ5XSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGF0LnBhdGgsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBtb2RlLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgdmFyIFssIG1hdGNoUGF0aF0gPSBlbnRyeTtcbiAgICAgICAgdmFyIHBhdGhSZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsIG1hdGNoUGF0aCk7XG4gICAgICAgIHZhciBpc0F0RW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgYXQsIG1hdGNoUGF0aCk7XG4gICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtb2RlLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcbiAgICAgICAgYXQgPSBpc0F0RW5kID8gUGF0aC5uZXh0KHBhdGgpIDogcGF0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHBhcmVudFBhdGggPSBQYXRoLnBhcmVudChhdCk7XG4gICAgdmFyIGluZGV4ID0gYXRbYXQubGVuZ3RoIC0gMV07XG4gICAgaWYgKCF2b2lkcyAmJiBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgIGF0OiBwYXJlbnRQYXRoXG4gICAgfSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGJhdGNoRGlydHkpIHtcbiAgICAgIC8vIFBFUkY6IGJhdGNoIHVwZGF0ZSBkaXJ0eSBwYXRoc1xuICAgICAgLy8gYmF0Y2hlZCBvcHMgdXNlZCB0byB0cmFuc2Zvcm0gZXhpc3RpbmcgZGlydHkgcGF0aHNcbiAgICAgIHZhciBiYXRjaGVkT3BzID0gW107XG4gICAgICB2YXIgbmV3RGlydHlQYXRocyA9IFBhdGgubGV2ZWxzKHBhcmVudFBhdGgpO1xuICAgICAgYmF0Y2hEaXJ0eVBhdGhzKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgICAgICB2YXIgcGF0aCA9IHBhcmVudFBhdGguY29uY2F0KGluZGV4KTtcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgIHZhciBvcCA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdpbnNlcnRfbm9kZScsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgbm9kZTogX25vZGVcbiAgICAgICAgICB9O1xuICAgICAgICAgIGVkaXRvci5hcHBseShvcCk7XG4gICAgICAgICAgYXQgPSBQYXRoLm5leHQoYXQpO1xuICAgICAgICAgIGJhdGNoZWRPcHMucHVzaChvcCk7XG4gICAgICAgICAgaWYgKFRleHQuaXNUZXh0KF9ub2RlKSkge1xuICAgICAgICAgICAgbmV3RGlydHlQYXRocy5wdXNoKHBhdGgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdEaXJ0eVBhdGhzLnB1c2goLi4uQXJyYXkuZnJvbShOb2RlLm5vZGVzKF9ub2RlKSwgX3JlZiA9PiB7XG4gICAgICAgICAgICAgIHZhciBbLCBwXSA9IF9yZWY7XG4gICAgICAgICAgICAgIHJldHVybiBwYXRoLmNvbmNhdChwKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIF9ub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgICAgX2xvb3AoKTtcbiAgICAgICAgfVxuICAgICAgfSwgKCkgPT4ge1xuICAgICAgICB1cGRhdGVEaXJ0eVBhdGhzKGVkaXRvciwgbmV3RGlydHlQYXRocywgcCA9PiB7XG4gICAgICAgICAgdmFyIG5ld1BhdGggPSBwO1xuICAgICAgICAgIGZvciAodmFyIG9wIG9mIGJhdGNoZWRPcHMpIHtcbiAgICAgICAgICAgIGlmIChQYXRoLm9wZXJhdGlvbkNhblRyYW5zZm9ybVBhdGgob3ApKSB7XG4gICAgICAgICAgICAgIG5ld1BhdGggPSBQYXRoLnRyYW5zZm9ybShuZXdQYXRoLCBvcCk7XG4gICAgICAgICAgICAgIGlmICghbmV3UGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXdQYXRoO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBfbm9kZTIgb2Ygbm9kZXMpIHtcbiAgICAgICAgdmFyIF9wYXRoID0gcGFyZW50UGF0aC5jb25jYXQoaW5kZXgpO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgIHR5cGU6ICdpbnNlcnRfbm9kZScsXG4gICAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgICAgbm9kZTogX25vZGUyXG4gICAgICAgIH0pO1xuICAgICAgICBhdCA9IFBhdGgubmV4dChhdCk7XG4gICAgICB9XG4gICAgfVxuICAgIGF0ID0gUGF0aC5wcmV2aW91cyhhdCk7XG4gICAgaWYgKHNlbGVjdCkge1xuICAgICAgdmFyIHBvaW50ID0gRWRpdG9yLmVuZChlZGl0b3IsIGF0KTtcbiAgICAgIGlmIChwb2ludCkge1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHBvaW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxudmFyIGxpZnROb2RlcyA9IGZ1bmN0aW9uIGxpZnROb2RlcyhlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgIHZhciB7XG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIG1hdGNoXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgIH1cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBtYXRjaGVzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICBtYXRjaCxcbiAgICAgIG1vZGUsXG4gICAgICB2b2lkc1xuICAgIH0pO1xuICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20obWF0Y2hlcywgX3JlZiA9PiB7XG4gICAgICB2YXIgWywgcF0gPSBfcmVmO1xuICAgICAgcmV0dXJuIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgcCk7XG4gICAgfSk7XG4gICAgZm9yICh2YXIgcGF0aFJlZiBvZiBwYXRoUmVmcykge1xuICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG4gICAgICBpZiAocGF0aC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBsaWZ0IG5vZGUgYXQgYSBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgaGFzIGEgZGVwdGggb2YgbGVzcyB0aGFuIGAyYC5cIikpO1xuICAgICAgfVxuICAgICAgdmFyIHBhcmVudE5vZGVFbnRyeSA9IEVkaXRvci5ub2RlKGVkaXRvciwgUGF0aC5wYXJlbnQocGF0aCkpO1xuICAgICAgdmFyIFtwYXJlbnQsIHBhcmVudFBhdGhdID0gcGFyZW50Tm9kZUVudHJ5O1xuICAgICAgdmFyIGluZGV4ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIHtcbiAgICAgICAgbGVuZ3RoXG4gICAgICB9ID0gcGFyZW50LmNoaWxkcmVuO1xuICAgICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YXIgdG9QYXRoID0gUGF0aC5uZXh0KHBhcmVudFBhdGgpO1xuICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICB0bzogdG9QYXRoLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBwYXJlbnRQYXRoLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICB0bzogcGFyZW50UGF0aCxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgdmFyIF90b1BhdGggPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG4gICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgIHRvOiBfdG9QYXRoLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNwbGl0UGF0aCA9IFBhdGgubmV4dChwYXRoKTtcbiAgICAgICAgdmFyIF90b1BhdGgyID0gUGF0aC5uZXh0KHBhcmVudFBhdGgpO1xuICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHNwbGl0UGF0aCxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgICAgdG86IF90b1BhdGgyLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgX2V4Y2x1ZGVkID0gW1widGV4dFwiXSxcbiAgX2V4Y2x1ZGVkMiA9IFtcImNoaWxkcmVuXCJdO1xudmFyIGhhc1NpbmdsZUNoaWxkTmVzdCA9IChlZGl0b3IsIG5vZGUpID0+IHtcbiAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBub2RlO1xuICAgIGlmIChFZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudC5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBoYXNTaW5nbGVDaGlsZE5lc3QoZWRpdG9yLCBlbGVtZW50LmNoaWxkcmVuWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChFZGl0b3IuaXNFZGl0b3Iobm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG52YXIgbWVyZ2VOb2RlcyA9IGZ1bmN0aW9uIG1lcmdlTm9kZXMoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICB2YXIge1xuICAgICAgbWF0Y2gsXG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb25cbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgaGFuZ2luZyA9IGZhbHNlLFxuICAgICAgdm9pZHMgPSBmYWxzZSxcbiAgICAgIG1vZGUgPSAnbG93ZXN0J1xuICAgIH0gPSBvcHRpb25zO1xuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgdmFyIFtwYXJlbnRdID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIGF0KTtcbiAgICAgICAgbWF0Y2ggPSBuID0+IHBhcmVudC5jaGlsZHJlbi5pbmNsdWRlcyhuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoID0gbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWhhbmdpbmcgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHtcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgWywgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICAgICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgYXRcbiAgICAgICAgfSk7XG4gICAgICAgIGF0ID0gcG9pbnRSZWYudW5yZWYoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCkge1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgYXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBbY3VycmVudF0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIG1hdGNoLFxuICAgICAgdm9pZHMsXG4gICAgICBtb2RlXG4gICAgfSk7XG4gICAgdmFyIHByZXYgPSBFZGl0b3IucHJldmlvdXMoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIG1hdGNoLFxuICAgICAgdm9pZHMsXG4gICAgICBtb2RlXG4gICAgfSk7XG4gICAgaWYgKCFjdXJyZW50IHx8ICFwcmV2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBbbm9kZSwgcGF0aF0gPSBjdXJyZW50O1xuICAgIHZhciBbcHJldk5vZGUsIHByZXZQYXRoXSA9IHByZXY7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwIHx8IHByZXZQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmV3UGF0aCA9IFBhdGgubmV4dChwcmV2UGF0aCk7XG4gICAgdmFyIGNvbW1vblBhdGggPSBQYXRoLmNvbW1vbihwYXRoLCBwcmV2UGF0aCk7XG4gICAgdmFyIGlzUHJldmlvdXNTaWJsaW5nID0gUGF0aC5pc1NpYmxpbmcocGF0aCwgcHJldlBhdGgpO1xuICAgIHZhciBsZXZlbHMgPSBBcnJheS5mcm9tKEVkaXRvci5sZXZlbHMoZWRpdG9yLCB7XG4gICAgICBhdDogcGF0aFxuICAgIH0pLCBfcmVmID0+IHtcbiAgICAgIHZhciBbbl0gPSBfcmVmO1xuICAgICAgcmV0dXJuIG47XG4gICAgfSkuc2xpY2UoY29tbW9uUGF0aC5sZW5ndGgpLnNsaWNlKDAsIC0xKTtcbiAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIG1lcmdlIHdpbGwgbGVhdmUgYW4gYW5jZXN0b3Igb2YgdGhlIHBhdGggZW1wdHkgYXMgYVxuICAgIC8vIHJlc3VsdCwgaW4gd2hpY2ggY2FzZSB3ZSdsbCB3YW50IHRvIHJlbW92ZSBpdCBhZnRlciBtZXJnaW5nLlxuICAgIHZhciBlbXB0eUFuY2VzdG9yID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgYXQ6IHBhdGgsXG4gICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICBtYXRjaDogbiA9PiBsZXZlbHMuaW5jbHVkZXMobikgJiYgaGFzU2luZ2xlQ2hpbGROZXN0KGVkaXRvciwgbilcbiAgICB9KTtcbiAgICB2YXIgZW1wdHlSZWYgPSBlbXB0eUFuY2VzdG9yICYmIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgZW1wdHlBbmNlc3RvclsxXSk7XG4gICAgdmFyIHByb3BlcnRpZXM7XG4gICAgdmFyIHBvc2l0aW9uO1xuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBub2RlcyBhcmUgZXF1aXZhbGVudCwgYW5kIGZpZ3VyZSBvdXQgd2hhdCB0aGUgcG9zaXRpb25cbiAgICAvLyBhbmQgZXh0cmEgcHJvcGVydGllcyBvZiB0aGUgbWVyZ2Ugd2lsbCBiZS5cbiAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkgJiYgVGV4dC5pc1RleHQocHJldk5vZGUpKSB7XG4gICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQpO1xuICAgICAgcG9zaXRpb24gPSBwcmV2Tm9kZS50ZXh0Lmxlbmd0aDtcbiAgICAgIHByb3BlcnRpZXMgPSByZXN0O1xuICAgIH0gZWxzZSBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgRWxlbWVudC5pc0VsZW1lbnQocHJldk5vZGUpKSB7XG4gICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQyKTtcbiAgICAgIHBvc2l0aW9uID0gcHJldk5vZGUuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgcHJvcGVydGllcyA9IHJlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtZXJnZSB0aGUgbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIHdpdGggdGhlIHByZXZpb3VzIHNpYmxpbmcgYmVjYXVzZSBpdCBpcyBub3QgdGhlIHNhbWUga2luZDogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSksIFwiIFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHByZXZOb2RlKSkpO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgbm9kZSBpc24ndCBhbHJlYWR5IHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhlIHByZXZpb3VzIG5vZGUsIG1vdmVcbiAgICAvLyBpdCBzbyB0aGF0IGl0IGlzIGJlZm9yZSBtZXJnaW5nLlxuICAgIGlmICghaXNQcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgdG86IG5ld1BhdGgsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gSWYgdGhlcmUgd2FzIGdvaW5nIHRvIGJlIGFuIGVtcHR5IGFuY2VzdG9yIG9mIHRoZSBub2RlIHRoYXQgd2FzIG1lcmdlZCxcbiAgICAvLyB3ZSByZW1vdmUgaXQgZnJvbSB0aGUgdHJlZS5cbiAgICBpZiAoZW1wdHlSZWYpIHtcbiAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlbXB0eVJlZi5jdXJyZW50LFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChFZGl0b3Iuc2hvdWxkTWVyZ2VOb2Rlc1JlbW92ZVByZXZOb2RlKGVkaXRvciwgcHJldiwgY3VycmVudCkpIHtcbiAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBwcmV2UGF0aCxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiAnbWVyZ2Vfbm9kZScsXG4gICAgICAgIHBhdGg6IG5ld1BhdGgsXG4gICAgICAgIHBvc2l0aW9uLFxuICAgICAgICBwcm9wZXJ0aWVzXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVtcHR5UmVmKSB7XG4gICAgICBlbXB0eVJlZi51bnJlZigpO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgbW92ZU5vZGVzID0gKGVkaXRvciwgb3B0aW9ucykgPT4ge1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgIHZhciB7XG4gICAgICB0byxcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgbWF0Y2hcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICB9XG4gICAgdmFyIHRvUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCB0byk7XG4gICAgdmFyIHRhcmdldHMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIG1hdGNoLFxuICAgICAgbW9kZSxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG4gICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbSh0YXJnZXRzLCBfcmVmID0+IHtcbiAgICAgIHZhciBbLCBwXSA9IF9yZWY7XG4gICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICB9KTtcbiAgICBmb3IgKHZhciBwYXRoUmVmIG9mIHBhdGhSZWZzKSB7XG4gICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcbiAgICAgIHZhciBuZXdQYXRoID0gdG9SZWYuY3VycmVudDtcbiAgICAgIGlmIChwYXRoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgIHR5cGU6ICdtb3ZlX25vZGUnLFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgbmV3UGF0aFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0b1JlZi5jdXJyZW50ICYmIFBhdGguaXNTaWJsaW5nKG5ld1BhdGgsIHBhdGgpICYmIFBhdGguaXNBZnRlcihuZXdQYXRoLCBwYXRoKSkge1xuICAgICAgICAvLyBXaGVuIHBlcmZvcm1pbmcgYSBzaWJsaW5nIG1vdmUgdG8gYSBsYXRlciBpbmRleCwgdGhlIHBhdGggYXQgdGhlIGRlc3RpbmF0aW9uIGlzIHNoaWZ0ZWRcbiAgICAgICAgLy8gdG8gYmVmb3JlIHRoZSBpbnNlcnRpb24gcG9pbnQgaW5zdGVhZCBvZiBhZnRlci4gVG8gZW5zdXJlIG91ciBncm91cCBvZiBub2RlcyBhcmUgaW5zZXJ0ZWRcbiAgICAgICAgLy8gaW4gdGhlIGNvcnJlY3Qgb3JkZXIgd2UgaW5jcmVtZW50IHRvUmVmIHRvIGFjY291bnQgZm9yIHRoYXRcbiAgICAgICAgdG9SZWYuY3VycmVudCA9IFBhdGgubmV4dCh0b1JlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdG9SZWYudW5yZWYoKTtcbiAgfSk7XG59O1xuXG52YXIgcmVtb3ZlTm9kZXMgPSBmdW5jdGlvbiByZW1vdmVOb2RlcyhlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgIHZhciB7XG4gICAgICBoYW5naW5nID0gZmFsc2UsXG4gICAgICB2b2lkcyA9IGZhbHNlLFxuICAgICAgbW9kZSA9ICdsb3dlc3QnXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgIG1hdGNoXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgbWF0Y2ggPSBQYXRoLmlzUGF0aChhdCkgPyBtYXRjaFBhdGgoZWRpdG9yLCBhdCkgOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgfVxuICAgIGlmICghaGFuZ2luZyAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgYXQgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCBhdCwge1xuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBkZXB0aHMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIG1hdGNoLFxuICAgICAgbW9kZSxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG4gICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbShkZXB0aHMsIF9yZWYgPT4ge1xuICAgICAgdmFyIFssIHBdID0gX3JlZjtcbiAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgIH0pO1xuICAgIGZvciAodmFyIHBhdGhSZWYgb2YgcGF0aFJlZnMpIHtcbiAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgdmFyIFtub2RlXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCk7XG4gICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgdHlwZTogJ3JlbW92ZV9ub2RlJyxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIG5vZGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBzZXROb2RlcyA9IGZ1bmN0aW9uIHNldE5vZGVzKGVkaXRvciwgcHJvcHMpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgIHZhciB7XG4gICAgICBtYXRjaCxcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgIGNvbXBhcmUsXG4gICAgICBtZXJnZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBoYW5naW5nID0gZmFsc2UsXG4gICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICBzcGxpdCA9IGZhbHNlLFxuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgIH1cbiAgICBpZiAoIWhhbmdpbmcgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHtcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc3BsaXQgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkgJiYgRWRpdG9yLmxlYWYoZWRpdG9yLCBhdC5hbmNob3IpWzBdLnRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBJZiB0aGUgcmFuZ2UgaXMgY29sbGFwc2VkIGluIGEgbm9uLWVtcHR5IG5vZGUgYW5kICdzcGxpdCcgaXMgdHJ1ZSwgdGhlcmUncyBub3RoaW5nIHRvXG4gICAgICAgIC8vIHNldCB0aGF0IHdvbid0IGdldCBub3JtYWxpemVkIGF3YXlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHJhbmdlUmVmID0gRWRpdG9yLnJhbmdlUmVmKGVkaXRvciwgYXQsIHtcbiAgICAgICAgYWZmaW5pdHk6ICdpbndhcmQnXG4gICAgICB9KTtcbiAgICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgICB2YXIgc3BsaXRNb2RlID0gbW9kZSA9PT0gJ2xvd2VzdCcgPyAnbG93ZXN0JyA6ICdoaWdoZXN0JztcbiAgICAgIHZhciBlbmRBdEVuZE9mTm9kZSA9IEVkaXRvci5pc0VuZChlZGl0b3IsIGVuZCwgZW5kLnBhdGgpO1xuICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogZW5kLFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgbW9kZTogc3BsaXRNb2RlLFxuICAgICAgICB2b2lkcyxcbiAgICAgICAgYWx3YXlzOiAhZW5kQXRFbmRPZk5vZGVcbiAgICAgIH0pO1xuICAgICAgdmFyIHN0YXJ0QXRTdGFydE9mTm9kZSA9IEVkaXRvci5pc1N0YXJ0KGVkaXRvciwgc3RhcnQsIHN0YXJ0LnBhdGgpO1xuICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogc3RhcnQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBtb2RlOiBzcGxpdE1vZGUsXG4gICAgICAgIHZvaWRzLFxuICAgICAgICBhbHdheXM6ICFzdGFydEF0U3RhcnRPZk5vZGVcbiAgICAgIH0pO1xuICAgICAgYXQgPSByYW5nZVJlZi51bnJlZigpO1xuICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCkge1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIGF0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjb21wYXJlKSB7XG4gICAgICBjb21wYXJlID0gKHByb3AsIG5vZGVQcm9wKSA9PiBwcm9wICE9PSBub2RlUHJvcDtcbiAgICB9XG4gICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0LFxuICAgICAgbWF0Y2gsXG4gICAgICBtb2RlLFxuICAgICAgdm9pZHNcbiAgICB9KSkge1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgIC8vIEZJWE1FOiBpcyB0aGlzIGNvcnJlY3Q/XG4gICAgICB2YXIgbmV3UHJvcGVydGllcyA9IHt9O1xuICAgICAgLy8gWW91IGNhbid0IHNldCBwcm9wZXJ0aWVzIG9uIHRoZSBlZGl0b3Igbm9kZS5cbiAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNDaGFuZ2VzID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBrIGluIHByb3BzKSB7XG4gICAgICAgIGlmIChrID09PSAnY2hpbGRyZW4nIHx8IGsgPT09ICd0ZXh0Jykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wYXJlKHByb3BzW2tdLCBub2RlW2tdKSkge1xuICAgICAgICAgIGhhc0NoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgIC8vIE9taXQgbmV3IHByb3BlcnRpZXMgZnJvbSB0aGUgb2xkIHByb3BlcnRpZXMgbGlzdFxuICAgICAgICAgIGlmIChub2RlLmhhc093blByb3BlcnR5KGspKSBwcm9wZXJ0aWVzW2tdID0gbm9kZVtrXTtcbiAgICAgICAgICAvLyBPbWl0IHByb3BlcnRpZXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBuZXcgcHJvcGVydGllcyBsaXN0XG4gICAgICAgICAgaWYgKG1lcmdlKSB7XG4gICAgICAgICAgICBpZiAocHJvcHNba10gIT0gbnVsbCkgbmV3UHJvcGVydGllc1trXSA9IG1lcmdlKG5vZGVba10sIHByb3BzW2tdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHByb3BzW2tdICE9IG51bGwpIG5ld1Byb3BlcnRpZXNba10gPSBwcm9wc1trXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChoYXNDaGFuZ2VzKSB7XG4gICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgdHlwZTogJ3NldF9ub2RlJyxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgbmV3UHJvcGVydGllc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgcmFuZ2UgaW50byBhIHBvaW50IGJ5IGRlbGV0aW5nIGl0J3MgY29udGVudC5cbiAqL1xudmFyIGRlbGV0ZVJhbmdlID0gKGVkaXRvciwgcmFuZ2UpID0+IHtcbiAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKSkge1xuICAgIHJldHVybiByYW5nZS5hbmNob3I7XG4gIH0gZWxzZSB7XG4gICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgIGF0OiByYW5nZVxuICAgIH0pO1xuICAgIHJldHVybiBwb2ludFJlZi51bnJlZigpO1xuICB9XG59O1xudmFyIHNwbGl0Tm9kZXMgPSBmdW5jdGlvbiBzcGxpdE5vZGVzKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgbWF0Y2gsXG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICBoZWlnaHQgPSAwLFxuICAgICAgYWx3YXlzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgbWF0Y2ggPSBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgfVxuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgYXQgPSBkZWxldGVSYW5nZShlZGl0b3IsIGF0KTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIHRhcmdldCBpcyBhIHBhdGgsIHRoZSBkZWZhdWx0IGhlaWdodC1za2lwcGluZyBhbmQgcG9zaXRpb25cbiAgICAvLyBjb3VudGVycyBuZWVkIHRvIGFjY291bnQgZm9yIHVzIHBvdGVudGlhbGx5IHNwbGl0dGluZyBhdCBhIG5vbi1sZWFmLlxuICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgIHZhciBwYXRoID0gYXQ7XG4gICAgICB2YXIgcG9pbnQgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgIHZhciBbcGFyZW50XSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgIG1hdGNoID0gbiA9PiBuID09PSBwYXJlbnQ7XG4gICAgICBoZWlnaHQgPSBwb2ludC5wYXRoLmxlbmd0aCAtIHBhdGgubGVuZ3RoICsgMTtcbiAgICAgIGF0ID0gcG9pbnQ7XG4gICAgICBhbHdheXMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBiZWZvcmVSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBhdCwge1xuICAgICAgYWZmaW5pdHk6ICdiYWNrd2FyZCdcbiAgICB9KTtcbiAgICB2YXIgYWZ0ZXJSZWY7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBbaGlnaGVzdF0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgaWYgKCFoaWdoZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB2b2lkTWF0Y2ggPSBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgICAgfSk7XG4gICAgICB2YXIgbnVkZ2UgPSAwO1xuICAgICAgaWYgKCF2b2lkcyAmJiB2b2lkTWF0Y2gpIHtcbiAgICAgICAgdmFyIFt2b2lkTm9kZSwgdm9pZFBhdGhdID0gdm9pZE1hdGNoO1xuICAgICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQodm9pZE5vZGUpICYmIGVkaXRvci5pc0lubGluZSh2b2lkTm9kZSkpIHtcbiAgICAgICAgICB2YXIgYWZ0ZXIgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCB2b2lkUGF0aCk7XG4gICAgICAgICAgaWYgKCFhZnRlcikge1xuICAgICAgICAgICAgdmFyIHRleHQgPSB7XG4gICAgICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGFmdGVyUGF0aCA9IFBhdGgubmV4dCh2b2lkUGF0aCk7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgdGV4dCwge1xuICAgICAgICAgICAgICBhdDogYWZ0ZXJQYXRoLFxuICAgICAgICAgICAgICB2b2lkc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhZnRlciA9IEVkaXRvci5wb2ludChlZGl0b3IsIGFmdGVyUGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF0ID0gYWZ0ZXI7XG4gICAgICAgICAgYWx3YXlzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2libGluZ0hlaWdodCA9IGF0LnBhdGgubGVuZ3RoIC0gdm9pZFBhdGgubGVuZ3RoO1xuICAgICAgICBoZWlnaHQgPSBzaWJsaW5nSGVpZ2h0ICsgMTtcbiAgICAgICAgYWx3YXlzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGFmdGVyUmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgYXQpO1xuICAgICAgdmFyIGRlcHRoID0gYXQucGF0aC5sZW5ndGggLSBoZWlnaHQ7XG4gICAgICB2YXIgWywgaGlnaGVzdFBhdGhdID0gaGlnaGVzdDtcbiAgICAgIHZhciBsb3dlc3RQYXRoID0gYXQucGF0aC5zbGljZSgwLCBkZXB0aCk7XG4gICAgICB2YXIgcG9zaXRpb24gPSBoZWlnaHQgPT09IDAgPyBhdC5vZmZzZXQgOiBhdC5wYXRoW2RlcHRoXSArIG51ZGdlO1xuICAgICAgZm9yICh2YXIgW25vZGUsIF9wYXRoXSBvZiBFZGl0b3IubGV2ZWxzKGVkaXRvciwge1xuICAgICAgICBhdDogbG93ZXN0UGF0aCxcbiAgICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pKSB7XG4gICAgICAgIHZhciBzcGxpdCA9IGZhbHNlO1xuICAgICAgICBpZiAoX3BhdGgubGVuZ3RoIDwgaGlnaGVzdFBhdGgubGVuZ3RoIHx8IF9wYXRoLmxlbmd0aCA9PT0gMCB8fCAhdm9pZHMgJiYgRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9wb2ludCA9IGJlZm9yZVJlZi5jdXJyZW50O1xuICAgICAgICB2YXIgaXNFbmQgPSBFZGl0b3IuaXNFbmQoZWRpdG9yLCBfcG9pbnQsIF9wYXRoKTtcbiAgICAgICAgaWYgKGFsd2F5cyB8fCAhYmVmb3JlUmVmIHx8ICFFZGl0b3IuaXNFZGdlKGVkaXRvciwgX3BvaW50LCBfcGF0aCkpIHtcbiAgICAgICAgICBzcGxpdCA9IHRydWU7XG4gICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBOb2RlLmV4dHJhY3RQcm9wcyhub2RlKTtcbiAgICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgICAgdHlwZTogJ3NwbGl0X25vZGUnLFxuICAgICAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIHByb3BlcnRpZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBwb3NpdGlvbiA9IF9wYXRoW19wYXRoLmxlbmd0aCAtIDFdICsgKHNwbGl0IHx8IGlzRW5kID8gMSA6IDApO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCkge1xuICAgICAgICB2YXIgX3BvaW50MiA9IGFmdGVyUmVmLmN1cnJlbnQgfHwgRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBfcG9pbnQyKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdmFyIF9hZnRlclJlZjtcbiAgICAgIGJlZm9yZVJlZi51bnJlZigpO1xuICAgICAgKF9hZnRlclJlZiA9IGFmdGVyUmVmKSA9PT0gbnVsbCB8fCBfYWZ0ZXJSZWYgPT09IHZvaWQgMCB8fCBfYWZ0ZXJSZWYudW5yZWYoKTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIHVuc2V0Tm9kZXMgPSBmdW5jdGlvbiB1bnNldE5vZGVzKGVkaXRvciwgcHJvcHMpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgcHJvcHMgPSBbcHJvcHNdO1xuICB9XG4gIHZhciBvYmogPSB7fTtcbiAgZm9yICh2YXIga2V5IG9mIHByb3BzKSB7XG4gICAgb2JqW2tleV0gPSBudWxsO1xuICB9XG4gIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCBvYmosIG9wdGlvbnMpO1xufTtcblxudmFyIHVud3JhcE5vZGVzID0gZnVuY3Rpb24gdW53cmFwTm9kZXMoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICB2YXIge1xuICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgc3BsaXQgPSBmYWxzZSxcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgbWF0Y2hcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICB9XG4gICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgYXQgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgfVxuICAgIHZhciByYW5nZVJlZiA9IFJhbmdlLmlzUmFuZ2UoYXQpID8gRWRpdG9yLnJhbmdlUmVmKGVkaXRvciwgYXQpIDogbnVsbDtcbiAgICB2YXIgbWF0Y2hlcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0LFxuICAgICAgbWF0Y2gsXG4gICAgICBtb2RlLFxuICAgICAgdm9pZHNcbiAgICB9KTtcbiAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKG1hdGNoZXMsIF9yZWYgPT4ge1xuICAgICAgdmFyIFssIHBdID0gX3JlZjtcbiAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgIH1cbiAgICAvLyB1bndyYXBOb2RlIHdpbGwgY2FsbCBsaWZ0Tm9kZSB3aGljaCBkb2VzIG5vdCBzdXBwb3J0IHNwbGl0dGluZyB0aGUgbm9kZSB3aGVuIG5lc3RlZC5cbiAgICAvLyBJZiB3ZSBkbyBub3QgcmV2ZXJzZSB0aGUgb3JkZXIgYW5kIGNhbGwgaXQgZnJvbSB0b3AgdG8gdGhlIGJvdHRvbSwgaXQgd2lsbCByZW1vdmUgYWxsIGJsb2Nrc1xuICAgIC8vIHRoYXQgd3JhcCB0YXJnZXQgbm9kZS4gU28gd2UgcmV2ZXJzZSB0aGUgb3JkZXIuXG4gICAgKS5yZXZlcnNlKCk7XG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcbiAgICAgIHZhciBbbm9kZV0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpO1xuICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgcGF0aCk7XG4gICAgICBpZiAoc3BsaXQgJiYgcmFuZ2VSZWYpIHtcbiAgICAgICAgcmFuZ2UgPSBSYW5nZS5pbnRlcnNlY3Rpb24ocmFuZ2VSZWYuY3VycmVudCwgcmFuZ2UpO1xuICAgICAgfVxuICAgICAgVHJhbnNmb3Jtcy5saWZ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiByYW5nZSxcbiAgICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0FuY2VzdG9yKG5vZGUpICYmIG5vZGUuY2hpbGRyZW4uaW5jbHVkZXMobiksXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGZvciAodmFyIHBhdGhSZWYgb2YgcGF0aFJlZnMpIHtcbiAgICAgIF9sb29wKCk7XG4gICAgfVxuICAgIGlmIChyYW5nZVJlZikge1xuICAgICAgcmFuZ2VSZWYudW5yZWYoKTtcbiAgICB9XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgd3JhcE5vZGVzID0gZnVuY3Rpb24gd3JhcE5vZGVzKGVkaXRvciwgZWxlbWVudCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICAgIHNwbGl0ID0gZmFsc2UsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIG1hdGNoLFxuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICBtYXRjaCA9IG1hdGNoUGF0aChlZGl0b3IsIGF0KTtcbiAgICAgIH0gZWxzZSBpZiAoZWRpdG9yLmlzSW5saW5lKGVsZW1lbnQpKSB7XG4gICAgICAgIG1hdGNoID0gbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSB8fCBUZXh0LmlzVGV4dChuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoID0gbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3BsaXQgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgICB2YXIgcmFuZ2VSZWYgPSBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBhdCwge1xuICAgICAgICBhZmZpbml0eTogJ2lud2FyZCdcbiAgICAgIH0pO1xuICAgICAgLy8gQWx3YXlzIHNwbGl0IGlmIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSBibG9jaywgdG8gZW5zdXJlIHRoYXQgdGV4dFxuICAgICAgLy8gbm9kZSBib3VuZGFyaWVzIGFyZSBoYW5kbGVkIGNvcnJlY3RseS5cbiAgICAgIHZhciBpc0F0QmxvY2tFZGdlID0gcG9pbnQgPT4ge1xuICAgICAgICB2YXIgYmxvY2tBYm92ZSA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcG9pbnQsXG4gICAgICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGJsb2NrQWJvdmUgJiYgRWRpdG9yLmlzRWRnZShlZGl0b3IsIHBvaW50LCBibG9ja0Fib3ZlWzFdKTtcbiAgICAgIH07XG4gICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlbmQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICB2b2lkcyxcbiAgICAgICAgYWx3YXlzOiAhaXNBdEJsb2NrRWRnZShlbmQpXG4gICAgICB9KTtcbiAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHN0YXJ0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgdm9pZHMsXG4gICAgICAgIGFsd2F5czogIWlzQXRCbG9ja0VkZ2Uoc3RhcnQpXG4gICAgICB9KTtcbiAgICAgIGF0ID0gcmFuZ2VSZWYudW5yZWYoKTtcbiAgICAgIGlmIChvcHRpb25zLmF0ID09IG51bGwpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBhdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciByb290cyA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICBtYXRjaDogZWRpdG9yLmlzSW5saW5lKGVsZW1lbnQpID8gbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pIDogbiA9PiBFZGl0b3IuaXNFZGl0b3IobiksXG4gICAgICBtb2RlOiAnbG93ZXN0JyxcbiAgICAgIHZvaWRzXG4gICAgfSkpO1xuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgICB2YXIgYSA9IFJhbmdlLmlzUmFuZ2UoYXQpID8gUmFuZ2UuaW50ZXJzZWN0aW9uKGF0LCBFZGl0b3IucmFuZ2UoZWRpdG9yLCByb290UGF0aCkpIDogYXQ7XG4gICAgICAgIGlmICghYSkge1xuICAgICAgICAgIHJldHVybiAwOyAvLyBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIHZhciBtYXRjaGVzID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGEsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgbW9kZSxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KSk7XG4gICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgW2ZpcnN0XSA9IG1hdGNoZXM7XG4gICAgICAgICAgdmFyIGxhc3QgPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgdmFyIFssIGZpcnN0UGF0aF0gPSBmaXJzdDtcbiAgICAgICAgICB2YXIgWywgbGFzdFBhdGhdID0gbGFzdDtcbiAgICAgICAgICBpZiAoZmlyc3RQYXRoLmxlbmd0aCA9PT0gMCAmJiBsYXN0UGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3Mgbm8gbWF0Y2hpbmcgcGFyZW50IC0gdXN1YWxseSBtZWFucyB0aGUgbm9kZSBpcyBhbiBlZGl0b3IgLSBkb24ndCBkbyBhbnl0aGluZ1xuICAgICAgICAgICAgcmV0dXJuIDA7IC8vIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjb21tb25QYXRoID0gUGF0aC5lcXVhbHMoZmlyc3RQYXRoLCBsYXN0UGF0aCkgPyBQYXRoLnBhcmVudChmaXJzdFBhdGgpIDogUGF0aC5jb21tb24oZmlyc3RQYXRoLCBsYXN0UGF0aCk7XG4gICAgICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgZmlyc3RQYXRoLCBsYXN0UGF0aCk7XG4gICAgICAgICAgdmFyIGNvbW1vbk5vZGVFbnRyeSA9IEVkaXRvci5ub2RlKGVkaXRvciwgY29tbW9uUGF0aCk7XG4gICAgICAgICAgdmFyIFtjb21tb25Ob2RlXSA9IGNvbW1vbk5vZGVFbnRyeTtcbiAgICAgICAgICB2YXIgZGVwdGggPSBjb21tb25QYXRoLmxlbmd0aCArIDE7XG4gICAgICAgICAgdmFyIHdyYXBwZXJQYXRoID0gUGF0aC5uZXh0KGxhc3RQYXRoLnNsaWNlKDAsIGRlcHRoKSk7XG4gICAgICAgICAgdmFyIHdyYXBwZXIgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVsZW1lbnQpLCB7fSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHdyYXBwZXIsIHtcbiAgICAgICAgICAgIGF0OiB3cmFwcGVyUGF0aCxcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcmFuZ2UsXG4gICAgICAgICAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzQW5jZXN0b3IoY29tbW9uTm9kZSkgJiYgY29tbW9uTm9kZS5jaGlsZHJlbi5pbmNsdWRlcyhuKSxcbiAgICAgICAgICAgIHRvOiB3cmFwcGVyUGF0aC5jb25jYXQoMCksXG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX3JldDtcbiAgICBmb3IgKHZhciBbLCByb290UGF0aF0gb2Ygcm9vdHMpIHtcbiAgICAgIF9yZXQgPSBfbG9vcCgpO1xuICAgICAgaWYgKF9yZXQgPT09IDApIGNvbnRpbnVlO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBTbGF0ZSBgRWRpdG9yYCBvYmplY3QuXG4gKi9cbnZhciBjcmVhdGVFZGl0b3IgPSAoKSA9PiB7XG4gIHZhciBlZGl0b3IgPSB7XG4gICAgY2hpbGRyZW46IFtdLFxuICAgIG9wZXJhdGlvbnM6IFtdLFxuICAgIHNlbGVjdGlvbjogbnVsbCxcbiAgICBtYXJrczogbnVsbCxcbiAgICBpc0VsZW1lbnRSZWFkT25seTogKCkgPT4gZmFsc2UsXG4gICAgaXNJbmxpbmU6ICgpID0+IGZhbHNlLFxuICAgIGlzU2VsZWN0YWJsZTogKCkgPT4gdHJ1ZSxcbiAgICBpc1ZvaWQ6ICgpID0+IGZhbHNlLFxuICAgIG1hcmthYmxlVm9pZDogKCkgPT4gZmFsc2UsXG4gICAgb25DaGFuZ2U6ICgpID0+IHt9LFxuICAgIC8vIENvcmVcbiAgICBhcHBseTogZnVuY3Rpb24gYXBwbHkkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFwcGx5KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICAvLyBFZGl0b3JcbiAgICBhZGRNYXJrOiBmdW5jdGlvbiBhZGRNYXJrJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFkZE1hcmsoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGRlbGV0ZUJhY2t3YXJkOiBmdW5jdGlvbiBkZWxldGVCYWNrd2FyZCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWxldGVCYWNrd2FyZChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZGVsZXRlRm9yd2FyZDogZnVuY3Rpb24gZGVsZXRlRm9yd2FyZCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTRdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWxldGVGb3J3YXJkKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBkZWxldGVGcmFnbWVudDogZnVuY3Rpb24gZGVsZXRlRnJhZ21lbnQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNSksIF9rZXk1ID0gMDsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xuICAgICAgICBhcmdzW19rZXk1XSA9IGFyZ3VtZW50c1tfa2V5NV07XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVsZXRlRnJhZ21lbnQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGdldEZyYWdtZW50OiBmdW5jdGlvbiBnZXRGcmFnbWVudCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42KSwgX2tleTYgPSAwOyBfa2V5NiA8IF9sZW42OyBfa2V5NisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTZdID0gYXJndW1lbnRzW19rZXk2XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRGcmFnbWVudChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgaW5zZXJ0QnJlYWs6IGZ1bmN0aW9uIGluc2VydEJyZWFrJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjcpLCBfa2V5NyA9IDA7IF9rZXk3IDwgX2xlbjc7IF9rZXk3KyspIHtcbiAgICAgICAgYXJnc1tfa2V5N10gPSBhcmd1bWVudHNbX2tleTddO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluc2VydEJyZWFrKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBpbnNlcnRTb2Z0QnJlYWs6IGZ1bmN0aW9uIGluc2VydFNvZnRCcmVhayQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW44KSwgX2tleTggPSAwOyBfa2V5OCA8IF9sZW44OyBfa2V5OCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleThdID0gYXJndW1lbnRzW19rZXk4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnNlcnRTb2Z0QnJlYWsoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGluc2VydEZyYWdtZW50OiBmdW5jdGlvbiBpbnNlcnRGcmFnbWVudCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW45KSwgX2tleTkgPSAwOyBfa2V5OSA8IF9sZW45OyBfa2V5OSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTldID0gYXJndW1lbnRzW19rZXk5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnNlcnRGcmFnbWVudChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgaW5zZXJ0Tm9kZTogZnVuY3Rpb24gaW5zZXJ0Tm9kZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjEwID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTApLCBfa2V5MTAgPSAwOyBfa2V5MTAgPCBfbGVuMTA7IF9rZXkxMCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTEwXSA9IGFyZ3VtZW50c1tfa2V5MTBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluc2VydE5vZGUoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGluc2VydFRleHQ6IGZ1bmN0aW9uIGluc2VydFRleHQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4xMSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjExKSwgX2tleTExID0gMDsgX2tleTExIDwgX2xlbjExOyBfa2V5MTErKykge1xuICAgICAgICBhcmdzW19rZXkxMV0gPSBhcmd1bWVudHNbX2tleTExXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnNlcnRUZXh0KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBub3JtYWxpemVOb2RlOiBmdW5jdGlvbiBub3JtYWxpemVOb2RlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xMiksIF9rZXkxMiA9IDA7IF9rZXkxMiA8IF9sZW4xMjsgX2tleTEyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTJdID0gYXJndW1lbnRzW19rZXkxMl07XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9ybWFsaXplTm9kZShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgcmVtb3ZlTWFyazogZnVuY3Rpb24gcmVtb3ZlTWFyayQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjEzID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTMpLCBfa2V5MTMgPSAwOyBfa2V5MTMgPCBfbGVuMTM7IF9rZXkxMysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTEzXSA9IGFyZ3VtZW50c1tfa2V5MTNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlbW92ZU1hcmsoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGdldERpcnR5UGF0aHM6IGZ1bmN0aW9uIGdldERpcnR5UGF0aHMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4xNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjE0KSwgX2tleTE0ID0gMDsgX2tleTE0IDwgX2xlbjE0OyBfa2V5MTQrKykge1xuICAgICAgICBhcmdzW19rZXkxNF0gPSBhcmd1bWVudHNbX2tleTE0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXREaXJ0eVBhdGhzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBzaG91bGROb3JtYWxpemU6IGZ1bmN0aW9uIHNob3VsZE5vcm1hbGl6ZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjE1ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTUpLCBfa2V5MTUgPSAwOyBfa2V5MTUgPCBfbGVuMTU7IF9rZXkxNSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTE1XSA9IGFyZ3VtZW50c1tfa2V5MTVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNob3VsZE5vcm1hbGl6ZShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgLy8gRWRpdG9yIGludGVyZmFjZVxuICAgIGFib3ZlOiBmdW5jdGlvbiBhYm92ZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjE2ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTYpLCBfa2V5MTYgPSAwOyBfa2V5MTYgPCBfbGVuMTY7IF9rZXkxNisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTE2XSA9IGFyZ3VtZW50c1tfa2V5MTZdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFib3ZlKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBhZnRlcjogZnVuY3Rpb24gYWZ0ZXIkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4xNyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjE3KSwgX2tleTE3ID0gMDsgX2tleTE3IDwgX2xlbjE3OyBfa2V5MTcrKykge1xuICAgICAgICBhcmdzW19rZXkxN10gPSBhcmd1bWVudHNbX2tleTE3XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhZnRlcihlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgYmVmb3JlOiBmdW5jdGlvbiBiZWZvcmUkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4xOCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjE4KSwgX2tleTE4ID0gMDsgX2tleTE4IDwgX2xlbjE4OyBfa2V5MTgrKykge1xuICAgICAgICBhcmdzW19rZXkxOF0gPSBhcmd1bWVudHNbX2tleTE4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiZWZvcmUoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGNvbGxhcHNlOiBmdW5jdGlvbiBjb2xsYXBzZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjE5ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTkpLCBfa2V5MTkgPSAwOyBfa2V5MTkgPCBfbGVuMTk7IF9rZXkxOSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTE5XSA9IGFyZ3VtZW50c1tfa2V5MTldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbGxhcHNlKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBkZWxldGU6IGZ1bmN0aW9uIF9kZWxldGUoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjAgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yMCksIF9rZXkyMCA9IDA7IF9rZXkyMCA8IF9sZW4yMDsgX2tleTIwKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjBdID0gYXJndW1lbnRzW19rZXkyMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVsZXRlVGV4dChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZGVzZWxlY3Q6IGZ1bmN0aW9uIGRlc2VsZWN0JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjEgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yMSksIF9rZXkyMSA9IDA7IF9rZXkyMSA8IF9sZW4yMTsgX2tleTIxKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjFdID0gYXJndW1lbnRzW19rZXkyMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzZWxlY3QoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGVkZ2VzOiBmdW5jdGlvbiBlZGdlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIyID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMjIpLCBfa2V5MjIgPSAwOyBfa2V5MjIgPCBfbGVuMjI7IF9rZXkyMisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIyXSA9IGFyZ3VtZW50c1tfa2V5MjJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVkZ2VzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBlbGVtZW50UmVhZE9ubHk6IGZ1bmN0aW9uIGVsZW1lbnRSZWFkT25seSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIzID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMjMpLCBfa2V5MjMgPSAwOyBfa2V5MjMgPCBfbGVuMjM7IF9rZXkyMysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIzXSA9IGFyZ3VtZW50c1tfa2V5MjNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnRSZWFkT25seShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZW5kOiBmdW5jdGlvbiBlbmQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjI0KSwgX2tleTI0ID0gMDsgX2tleTI0IDwgX2xlbjI0OyBfa2V5MjQrKykge1xuICAgICAgICBhcmdzW19rZXkyNF0gPSBhcmd1bWVudHNbX2tleTI0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbmQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGZpcnN0OiBmdW5jdGlvbiBmaXJzdCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjI1ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMjUpLCBfa2V5MjUgPSAwOyBfa2V5MjUgPCBfbGVuMjU7IF9rZXkyNSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTI1XSA9IGFyZ3VtZW50c1tfa2V5MjVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpcnN0KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBmcmFnbWVudDogZnVuY3Rpb24gZnJhZ21lbnQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjI2KSwgX2tleTI2ID0gMDsgX2tleTI2IDwgX2xlbjI2OyBfa2V5MjYrKykge1xuICAgICAgICBhcmdzW19rZXkyNl0gPSBhcmd1bWVudHNbX2tleTI2XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcmFnbWVudChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZ2V0TWFya3M6IGZ1bmN0aW9uIGdldE1hcmtzKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjI3ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMjcpLCBfa2V5MjcgPSAwOyBfa2V5MjcgPCBfbGVuMjc7IF9rZXkyNysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTI3XSA9IGFyZ3VtZW50c1tfa2V5MjddO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcmtzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBoYXNCbG9ja3M6IGZ1bmN0aW9uIGhhc0Jsb2NrcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjI4ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMjgpLCBfa2V5MjggPSAwOyBfa2V5MjggPCBfbGVuMjg7IF9rZXkyOCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTI4XSA9IGFyZ3VtZW50c1tfa2V5MjhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc0Jsb2NrcyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgaGFzSW5saW5lczogZnVuY3Rpb24gaGFzSW5saW5lcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjI5ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMjkpLCBfa2V5MjkgPSAwOyBfa2V5MjkgPCBfbGVuMjk7IF9rZXkyOSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTI5XSA9IGFyZ3VtZW50c1tfa2V5MjldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc0lubGluZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGhhc1BhdGg6IGZ1bmN0aW9uIGhhc1BhdGgkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zMCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMwKSwgX2tleTMwID0gMDsgX2tleTMwIDwgX2xlbjMwOyBfa2V5MzArKykge1xuICAgICAgICBhcmdzW19rZXkzMF0gPSBhcmd1bWVudHNbX2tleTMwXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNQYXRoKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBoYXNUZXh0czogZnVuY3Rpb24gaGFzVGV4dHMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zMSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMxKSwgX2tleTMxID0gMDsgX2tleTMxIDwgX2xlbjMxOyBfa2V5MzErKykge1xuICAgICAgICBhcmdzW19rZXkzMV0gPSBhcmd1bWVudHNbX2tleTMxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNUZXh0cyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgaW5zZXJ0Tm9kZXM6IGZ1bmN0aW9uIGluc2VydE5vZGVzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMzIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zMiksIF9rZXkzMiA9IDA7IF9rZXkzMiA8IF9sZW4zMjsgX2tleTMyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MzJdID0gYXJndW1lbnRzW19rZXkzMl07XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5zZXJ0Tm9kZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGlzQmxvY2s6IGZ1bmN0aW9uIGlzQmxvY2skMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMzKSwgX2tleTMzID0gMDsgX2tleTMzIDwgX2xlbjMzOyBfa2V5MzMrKykge1xuICAgICAgICBhcmdzW19rZXkzM10gPSBhcmd1bWVudHNbX2tleTMzXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0Jsb2NrKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBpc0VkZ2U6IGZ1bmN0aW9uIGlzRWRnZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjM0ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMzQpLCBfa2V5MzQgPSAwOyBfa2V5MzQgPCBfbGVuMzQ7IF9rZXkzNCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTM0XSA9IGFyZ3VtZW50c1tfa2V5MzRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzRWRnZShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgaXNFbXB0eTogZnVuY3Rpb24gaXNFbXB0eSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjM1ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMzUpLCBfa2V5MzUgPSAwOyBfa2V5MzUgPCBfbGVuMzU7IF9rZXkzNSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTM1XSA9IGFyZ3VtZW50c1tfa2V5MzVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzRW1wdHkoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGlzRW5kOiBmdW5jdGlvbiBpc0VuZCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjM2ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMzYpLCBfa2V5MzYgPSAwOyBfa2V5MzYgPCBfbGVuMzY7IF9rZXkzNisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTM2XSA9IGFyZ3VtZW50c1tfa2V5MzZdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzRW5kKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBpc05vcm1hbGl6aW5nOiBmdW5jdGlvbiBpc05vcm1hbGl6aW5nJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMzcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zNyksIF9rZXkzNyA9IDA7IF9rZXkzNyA8IF9sZW4zNzsgX2tleTM3KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MzddID0gYXJndW1lbnRzW19rZXkzN107XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNOb3JtYWxpemluZyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgaXNTdGFydDogZnVuY3Rpb24gaXNTdGFydCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjM4ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMzgpLCBfa2V5MzggPSAwOyBfa2V5MzggPCBfbGVuMzg7IF9rZXkzOCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTM4XSA9IGFyZ3VtZW50c1tfa2V5MzhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzU3RhcnQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGxhc3Q6IGZ1bmN0aW9uIGxhc3QkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zOSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjM5KSwgX2tleTM5ID0gMDsgX2tleTM5IDwgX2xlbjM5OyBfa2V5MzkrKykge1xuICAgICAgICBhcmdzW19rZXkzOV0gPSBhcmd1bWVudHNbX2tleTM5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYXN0KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBsZWFmOiBmdW5jdGlvbiBsZWFmJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDAgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40MCksIF9rZXk0MCA9IDA7IF9rZXk0MCA8IF9sZW40MDsgX2tleTQwKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDBdID0gYXJndW1lbnRzW19rZXk0MF07XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVhZihlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgbGV2ZWxzOiBmdW5jdGlvbiBsZXZlbHMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40MSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQxKSwgX2tleTQxID0gMDsgX2tleTQxIDwgX2xlbjQxOyBfa2V5NDErKykge1xuICAgICAgICBhcmdzW19rZXk0MV0gPSBhcmd1bWVudHNbX2tleTQxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZXZlbHMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGxpZnROb2RlczogZnVuY3Rpb24gbGlmdE5vZGVzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40MiksIF9rZXk0MiA9IDA7IF9rZXk0MiA8IF9sZW40MjsgX2tleTQyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDJdID0gYXJndW1lbnRzW19rZXk0Ml07XG4gICAgICB9XG4gICAgICByZXR1cm4gbGlmdE5vZGVzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBtZXJnZU5vZGVzOiBmdW5jdGlvbiBtZXJnZU5vZGVzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40MyksIF9rZXk0MyA9IDA7IF9rZXk0MyA8IF9sZW40MzsgX2tleTQzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDNdID0gYXJndW1lbnRzW19rZXk0M107XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVyZ2VOb2RlcyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgbW92ZTogZnVuY3Rpb24gbW92ZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQ0ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNDQpLCBfa2V5NDQgPSAwOyBfa2V5NDQgPCBfbGVuNDQ7IF9rZXk0NCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTQ0XSA9IGFyZ3VtZW50c1tfa2V5NDRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1vdmUoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIG1vdmVOb2RlczogZnVuY3Rpb24gbW92ZU5vZGVzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40NSksIF9rZXk0NSA9IDA7IF9rZXk0NSA8IF9sZW40NTsgX2tleTQ1KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDVdID0gYXJndW1lbnRzW19rZXk0NV07XG4gICAgICB9XG4gICAgICByZXR1cm4gbW92ZU5vZGVzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBuZXh0OiBmdW5jdGlvbiBuZXh0JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40NiksIF9rZXk0NiA9IDA7IF9rZXk0NiA8IF9sZW40NjsgX2tleTQ2KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDZdID0gYXJndW1lbnRzW19rZXk0Nl07XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV4dChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgbm9kZTogZnVuY3Rpb24gbm9kZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQ3ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNDcpLCBfa2V5NDcgPSAwOyBfa2V5NDcgPCBfbGVuNDc7IF9rZXk0NysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTQ3XSA9IGFyZ3VtZW50c1tfa2V5NDddO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGUoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIG5vZGVzOiBmdW5jdGlvbiBub2RlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQ4ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNDgpLCBfa2V5NDggPSAwOyBfa2V5NDggPCBfbGVuNDg7IF9rZXk0OCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTQ4XSA9IGFyZ3VtZW50c1tfa2V5NDhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGVzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBub3JtYWxpemU6IGZ1bmN0aW9uIG5vcm1hbGl6ZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQ5ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNDkpLCBfa2V5NDkgPSAwOyBfa2V5NDkgPCBfbGVuNDk7IF9rZXk0OSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTQ5XSA9IGFyZ3VtZW50c1tfa2V5NDldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vcm1hbGl6ZShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgcGFyZW50OiBmdW5jdGlvbiBwYXJlbnQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41MCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUwKSwgX2tleTUwID0gMDsgX2tleTUwIDwgX2xlbjUwOyBfa2V5NTArKykge1xuICAgICAgICBhcmdzW19rZXk1MF0gPSBhcmd1bWVudHNbX2tleTUwXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHBhdGg6IGZ1bmN0aW9uIHBhdGgkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41MSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUxKSwgX2tleTUxID0gMDsgX2tleTUxIDwgX2xlbjUxOyBfa2V5NTErKykge1xuICAgICAgICBhcmdzW19rZXk1MV0gPSBhcmd1bWVudHNbX2tleTUxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXRoKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBwYXRoUmVmOiBmdW5jdGlvbiBwYXRoUmVmJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNTIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41MiksIF9rZXk1MiA9IDA7IF9rZXk1MiA8IF9sZW41MjsgX2tleTUyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NTJdID0gYXJndW1lbnRzW19rZXk1Ml07XG4gICAgICB9XG4gICAgICByZXR1cm4gcGF0aFJlZihlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgcGF0aFJlZnM6IGZ1bmN0aW9uIHBhdGhSZWZzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNTMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41MyksIF9rZXk1MyA9IDA7IF9rZXk1MyA8IF9sZW41MzsgX2tleTUzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NTNdID0gYXJndW1lbnRzW19rZXk1M107XG4gICAgICB9XG4gICAgICByZXR1cm4gcGF0aFJlZnMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHBvaW50OiBmdW5jdGlvbiBwb2ludCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjU0ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTQpLCBfa2V5NTQgPSAwOyBfa2V5NTQgPCBfbGVuNTQ7IF9rZXk1NCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTU0XSA9IGFyZ3VtZW50c1tfa2V5NTRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvaW50KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBwb2ludFJlZjogZnVuY3Rpb24gcG9pbnRSZWYkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41NSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjU1KSwgX2tleTU1ID0gMDsgX2tleTU1IDwgX2xlbjU1OyBfa2V5NTUrKykge1xuICAgICAgICBhcmdzW19rZXk1NV0gPSBhcmd1bWVudHNbX2tleTU1XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwb2ludFJlZihlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgcG9pbnRSZWZzOiBmdW5jdGlvbiBwb2ludFJlZnMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41NiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjU2KSwgX2tleTU2ID0gMDsgX2tleTU2IDwgX2xlbjU2OyBfa2V5NTYrKykge1xuICAgICAgICBhcmdzW19rZXk1Nl0gPSBhcmd1bWVudHNbX2tleTU2XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwb2ludFJlZnMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHBvc2l0aW9uczogZnVuY3Rpb24gcG9zaXRpb25zJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNTcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41NyksIF9rZXk1NyA9IDA7IF9rZXk1NyA8IF9sZW41NzsgX2tleTU3KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NTddID0gYXJndW1lbnRzW19rZXk1N107XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9zaXRpb25zKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBwcmV2aW91czogZnVuY3Rpb24gcHJldmlvdXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41OCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjU4KSwgX2tleTU4ID0gMDsgX2tleTU4IDwgX2xlbjU4OyBfa2V5NTgrKykge1xuICAgICAgICBhcmdzW19rZXk1OF0gPSBhcmd1bWVudHNbX2tleTU4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmV2aW91cyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgcmFuZ2U6IGZ1bmN0aW9uIHJhbmdlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNTkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41OSksIF9rZXk1OSA9IDA7IF9rZXk1OSA8IF9sZW41OTsgX2tleTU5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NTldID0gYXJndW1lbnRzW19rZXk1OV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmFuZ2UoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHJhbmdlUmVmOiBmdW5jdGlvbiByYW5nZVJlZiQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjYwID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNjApLCBfa2V5NjAgPSAwOyBfa2V5NjAgPCBfbGVuNjA7IF9rZXk2MCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTYwXSA9IGFyZ3VtZW50c1tfa2V5NjBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJhbmdlUmVmKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICByYW5nZVJlZnM6IGZ1bmN0aW9uIHJhbmdlUmVmcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjYxID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNjEpLCBfa2V5NjEgPSAwOyBfa2V5NjEgPCBfbGVuNjE7IF9rZXk2MSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTYxXSA9IGFyZ3VtZW50c1tfa2V5NjFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJhbmdlUmVmcyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgcmVtb3ZlTm9kZXM6IGZ1bmN0aW9uIHJlbW92ZU5vZGVzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42MiksIF9rZXk2MiA9IDA7IF9rZXk2MiA8IF9sZW42MjsgX2tleTYyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NjJdID0gYXJndW1lbnRzW19rZXk2Ml07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVtb3ZlTm9kZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHNlbGVjdDogZnVuY3Rpb24gc2VsZWN0JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42MyksIF9rZXk2MyA9IDA7IF9rZXk2MyA8IF9sZW42MzsgX2tleTYzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NjNdID0gYXJndW1lbnRzW19rZXk2M107XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBzZXROb2RlczogZnVuY3Rpb24gc2V0Tm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42NCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjY0KSwgX2tleTY0ID0gMDsgX2tleTY0IDwgX2xlbjY0OyBfa2V5NjQrKykge1xuICAgICAgICBhcmdzW19rZXk2NF0gPSBhcmd1bWVudHNbX2tleTY0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXROb2RlcyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgc2V0Tm9ybWFsaXppbmc6IGZ1bmN0aW9uIHNldE5vcm1hbGl6aW5nJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42NSksIF9rZXk2NSA9IDA7IF9rZXk2NSA8IF9sZW42NTsgX2tleTY1KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NjVdID0gYXJndW1lbnRzW19rZXk2NV07XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0Tm9ybWFsaXppbmcoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHNldFBvaW50OiBmdW5jdGlvbiBzZXRQb2ludCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjY2ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNjYpLCBfa2V5NjYgPSAwOyBfa2V5NjYgPCBfbGVuNjY7IF9rZXk2NisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTY2XSA9IGFyZ3VtZW50c1tfa2V5NjZdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldFBvaW50KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBzZXRTZWxlY3Rpb246IGZ1bmN0aW9uIHNldFNlbGVjdGlvbiQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjY3ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNjcpLCBfa2V5NjcgPSAwOyBfa2V5NjcgPCBfbGVuNjc7IF9rZXk2NysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTY3XSA9IGFyZ3VtZW50c1tfa2V5NjddO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldFNlbGVjdGlvbihlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgc3BsaXROb2RlczogZnVuY3Rpb24gc3BsaXROb2RlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjY4ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNjgpLCBfa2V5NjggPSAwOyBfa2V5NjggPCBfbGVuNjg7IF9rZXk2OCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTY4XSA9IGFyZ3VtZW50c1tfa2V5NjhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNwbGl0Tm9kZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjY5ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNjkpLCBfa2V5NjkgPSAwOyBfa2V5NjkgPCBfbGVuNjk7IF9rZXk2OSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTY5XSA9IGFyZ3VtZW50c1tfa2V5NjldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXJ0KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBzdHJpbmc6IGZ1bmN0aW9uIHN0cmluZyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjcwID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNzApLCBfa2V5NzAgPSAwOyBfa2V5NzAgPCBfbGVuNzA7IF9rZXk3MCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTcwXSA9IGFyZ3VtZW50c1tfa2V5NzBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgdW5oYW5nUmFuZ2U6IGZ1bmN0aW9uIHVuaGFuZ1JhbmdlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNzEgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43MSksIF9rZXk3MSA9IDA7IF9rZXk3MSA8IF9sZW43MTsgX2tleTcxKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NzFdID0gYXJndW1lbnRzW19rZXk3MV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5oYW5nUmFuZ2UoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHVuc2V0Tm9kZXM6IGZ1bmN0aW9uIHVuc2V0Tm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW43MiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjcyKSwgX2tleTcyID0gMDsgX2tleTcyIDwgX2xlbjcyOyBfa2V5NzIrKykge1xuICAgICAgICBhcmdzW19rZXk3Ml0gPSBhcmd1bWVudHNbX2tleTcyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bnNldE5vZGVzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICB1bndyYXBOb2RlczogZnVuY3Rpb24gdW53cmFwTm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW43MyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjczKSwgX2tleTczID0gMDsgX2tleTczIDwgX2xlbjczOyBfa2V5NzMrKykge1xuICAgICAgICBhcmdzW19rZXk3M10gPSBhcmd1bWVudHNbX2tleTczXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bndyYXBOb2RlcyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgdm9pZDogZnVuY3Rpb24gX3ZvaWQoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNzQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43NCksIF9rZXk3NCA9IDA7IF9rZXk3NCA8IF9sZW43NDsgX2tleTc0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NzRdID0gYXJndW1lbnRzW19rZXk3NF07XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0Vm9pZChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgd2l0aG91dE5vcm1hbGl6aW5nOiBmdW5jdGlvbiB3aXRob3V0Tm9ybWFsaXppbmckMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW43NSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjc1KSwgX2tleTc1ID0gMDsgX2tleTc1IDwgX2xlbjc1OyBfa2V5NzUrKykge1xuICAgICAgICBhcmdzW19rZXk3NV0gPSBhcmd1bWVudHNbX2tleTc1XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHdyYXBOb2RlczogZnVuY3Rpb24gd3JhcE5vZGVzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNzYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43NiksIF9rZXk3NiA9IDA7IF9rZXk3NiA8IF9sZW43NjsgX2tleTc2KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NzZdID0gYXJndW1lbnRzW19rZXk3Nl07XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcE5vZGVzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBzaG91bGRNZXJnZU5vZGVzUmVtb3ZlUHJldk5vZGU6IGZ1bmN0aW9uIHNob3VsZE1lcmdlTm9kZXNSZW1vdmVQcmV2Tm9kZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjc3ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNzcpLCBfa2V5NzcgPSAwOyBfa2V5NzcgPCBfbGVuNzc7IF9rZXk3NysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTc3XSA9IGFyZ3VtZW50c1tfa2V5NzddO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNob3VsZE1lcmdlTm9kZXNSZW1vdmVQcmV2Tm9kZShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGVkaXRvcjtcbn07XG5cbmV4cG9ydCB7IEVkaXRvciwgRWxlbWVudCwgTG9jYXRpb24sIE5vZGUsIE9wZXJhdGlvbiwgUGF0aCwgUGF0aFJlZiwgUG9pbnQsIFBvaW50UmVmLCBSYW5nZSwgUmFuZ2VSZWYsIFNjcnViYmVyLCBTcGFuLCBUZXh0LCBUcmFuc2Zvcm1zLCBhYm92ZSwgYWRkTWFyaywgYWZ0ZXIsIGFwcGx5LCBiZWZvcmUsIGNvbGxhcHNlLCBjcmVhdGVFZGl0b3IsIGRlbGV0ZUJhY2t3YXJkLCBkZWxldGVGb3J3YXJkLCBkZWxldGVGcmFnbWVudCwgZGVsZXRlVGV4dCwgZGVzZWxlY3QsIGVkZ2VzLCBlbGVtZW50UmVhZE9ubHksIGVuZCwgZmlyc3QsIGZyYWdtZW50LCBnZXREaXJ0eVBhdGhzLCBnZXRGcmFnbWVudCwgZ2V0Vm9pZCwgaGFzQmxvY2tzLCBoYXNJbmxpbmVzLCBoYXNQYXRoLCBoYXNUZXh0cywgaW5zZXJ0QnJlYWssIGluc2VydEZyYWdtZW50LCBpbnNlcnROb2RlLCBpbnNlcnROb2RlcywgaW5zZXJ0U29mdEJyZWFrLCBpbnNlcnRUZXh0LCBpc0Jsb2NrLCBpc0VkZ2UsIGlzRWRpdG9yLCBpc0VtcHR5LCBpc0VuZCwgaXNOb3JtYWxpemluZywgaXNPYmplY3QsIGlzU3RhcnQsIGxhc3QsIGxlYWYsIGxldmVscywgbGlmdE5vZGVzLCBtYXJrcywgbWVyZ2VOb2RlcywgbW92ZSwgbW92ZU5vZGVzLCBuZXh0LCBub2RlLCBub2Rlcywgbm9ybWFsaXplLCBub3JtYWxpemVOb2RlLCBwYXJlbnQsIHBhdGgsIHBhdGhSZWYsIHBhdGhSZWZzLCBwb2ludCwgcG9pbnRSZWYsIHBvaW50UmVmcywgcG9zaXRpb25zLCBwcmV2aW91cywgcmFuZ2UsIHJhbmdlUmVmLCByYW5nZVJlZnMsIHJlbW92ZU1hcmssIHJlbW92ZU5vZGVzLCBzZWxlY3QsIHNldE5vZGVzLCBzZXROb3JtYWxpemluZywgc2V0UG9pbnQsIHNldFNlbGVjdGlvbiwgc2hvdWxkTWVyZ2VOb2Rlc1JlbW92ZVByZXZOb2RlLCBzaG91bGROb3JtYWxpemUsIHNwbGl0Tm9kZXMsIHN0YXJ0LCBzdHJpbmcsIHVuaGFuZ1JhbmdlLCB1bnNldE5vZGVzLCB1bndyYXBOb2Rlcywgd2l0aG91dE5vcm1hbGl6aW5nLCB3cmFwTm9kZXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/slate/dist/index.es.js\n");

/***/ })

};
;