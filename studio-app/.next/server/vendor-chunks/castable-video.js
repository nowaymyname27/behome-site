"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/castable-video";
exports.ids = ["vendor-chunks/castable-video"];
exports.modules = {

/***/ "(ssr)/../node_modules/castable-video/castable-mixin.js":
/*!********************************************************!*\
  !*** ../node_modules/castable-video/castable-mixin.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CastableMediaMixin: () => (/* binding */ CastableMediaMixin),\n/* harmony export */   CastableVideoMixin: () => (/* binding */ CastableVideoMixin)\n/* harmony export */ });\n/* harmony import */ var _castable_remote_playback_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./castable-remote-playback.js */ \"(ssr)/../node_modules/castable-video/castable-remote-playback.js\");\n/* harmony import */ var _castable_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./castable-utils.js */ \"(ssr)/../node_modules/castable-video/castable-utils.js\");\n/* global chrome */\n\n\n\n/**\n * CastableMediaMixin\n *\n * This mixin function provides a way to compose multiple classes.\n * @see https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/\n *\n * @param  {HTMLMediaElement} superclass - HTMLMediaElement or an extended class of it.\n * @return {CastableMedia}\n */\nconst CastableMediaMixin = (superclass) =>\n  class CastableMedia extends superclass {\n\n    static observedAttributes = [\n      ...(superclass.observedAttributes ?? []),\n      'cast-src',\n      'cast-content-type',\n      'cast-stream-type',\n      'cast-receiver',\n    ];\n\n    #localState = { paused: false };\n    #castOptions = (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_1__.getDefaultCastOptions)();\n    #castCustomData;\n    #remote;\n\n    get remote() {\n      if (this.#remote) return this.#remote;\n\n      if ((0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_1__.requiresCastFramework)()) {\n        // No need to load the Cast framework if it's disabled.\n        if (!this.disableRemotePlayback) {\n          (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_1__.loadCastFramework)();\n        }\n\n        _castable_utils_js__WEBPACK_IMPORTED_MODULE_1__.privateProps.set(this, {\n          loadOnPrompt: () => this.#loadOnPrompt()\n        });\n\n        return (this.#remote = new _castable_remote_playback_js__WEBPACK_IMPORTED_MODULE_0__.RemotePlayback(this));\n      }\n\n      return super.remote;\n    }\n\n    get #castPlayer() {\n      return _castable_utils_js__WEBPACK_IMPORTED_MODULE_1__.privateProps.get(this.remote)?.getCastPlayer?.();\n    }\n\n    attributeChangedCallback(attrName, oldValue, newValue) {\n      super.attributeChangedCallback(attrName, oldValue, newValue);\n\n      if (attrName === 'cast-receiver' && newValue) {\n        this.#castOptions.receiverApplicationId = newValue;\n        return;\n      }\n\n      if (!this.#castPlayer) return;\n\n      switch (attrName) {\n        case 'cast-stream-type':\n        case 'cast-src':\n          this.load();\n          break;\n      }\n    }\n\n    async #loadOnPrompt() {\n      // Pause locally when the session is created.\n      this.#localState.paused = super.paused;\n      super.pause();\n\n      // Sync over the muted state but not volume, 100% is different on TV's :P\n      this.muted = super.muted;\n\n      try {\n        await this.load();\n      } catch (err) {\n        console.error(err);\n      }\n    }\n\n    async load() {\n      if (!this.#castPlayer) return super.load();\n\n      const mediaInfo = new chrome.cast.media.MediaInfo(this.castSrc, this.castContentType);\n      mediaInfo.customData = this.castCustomData;\n\n      // Manually add text tracks with a `src` attribute.\n      // M3U8's load text tracks in the receiver, handle these in the media loaded event.\n      const subtitles = [...this.querySelectorAll('track')].filter(\n        ({ kind, src }) => src && (kind === 'subtitles' || kind === 'captions')\n      );\n\n      const activeTrackIds = [];\n      let textTrackIdCount = 0;\n\n      if (subtitles.length) {\n        mediaInfo.tracks = subtitles.map((trackEl) => {\n          const trackId = ++textTrackIdCount;\n          // only activate 1 subtitle text track.\n          if (activeTrackIds.length === 0 && trackEl.track.mode === 'showing') {\n            activeTrackIds.push(trackId);\n          }\n\n          const track = new chrome.cast.media.Track(\n            trackId,\n            chrome.cast.media.TrackType.TEXT\n          );\n          track.trackContentId = trackEl.src;\n          track.trackContentType = 'text/vtt';\n          track.subtype =\n            trackEl.kind === 'captions'\n              ? chrome.cast.media.TextTrackType.CAPTIONS\n              : chrome.cast.media.TextTrackType.SUBTITLES;\n          track.name = trackEl.label;\n          track.language = trackEl.srclang;\n          return track;\n        });\n      }\n\n      if (this.castStreamType === 'live') {\n        mediaInfo.streamType = chrome.cast.media.StreamType.LIVE;\n      } else {\n        mediaInfo.streamType = chrome.cast.media.StreamType.BUFFERED;\n      }\n\n      mediaInfo.metadata = new chrome.cast.media.GenericMediaMetadata();\n      mediaInfo.metadata.title = this.title;\n      mediaInfo.metadata.images = [{ url: this.poster }];\n\n      if ((0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_1__.isHls)(this.castSrc)) {\n        const segmentFormat = await (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPlaylistSegmentFormat)(this.castSrc);\n        const isFragmentedMP4 = segmentFormat?.includes('m4s') || segmentFormat?.includes('mp4');\n        if (isFragmentedMP4) {\n          mediaInfo.hlsSegmentFormat = chrome.cast.media.HlsSegmentFormat.FMP4;\n          mediaInfo.hlsVideoSegmentFormat = chrome.cast.media.HlsVideoSegmentFormat.FMP4;\n        } else if (segmentFormat?.includes('ts')) {\n          mediaInfo.hlsSegmentFormat = chrome.cast.media.HlsSegmentFormat.TS;\n          mediaInfo.hlsVideoSegmentFormat = chrome.cast.media.HlsVideoSegmentFormat.TS;\n        }\n      }\n\n      const request = new chrome.cast.media.LoadRequest(mediaInfo);\n      request.currentTime = super.currentTime ?? 0;\n      request.autoplay = !this.#localState.paused;\n      request.activeTrackIds = activeTrackIds;\n\n      await (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_1__.currentSession)()?.loadMedia(request);\n\n      this.dispatchEvent(new Event('volumechange'));\n    }\n\n    play() {\n      if (this.#castPlayer) {\n        if (this.#castPlayer.isPaused) {\n          this.#castPlayer.controller?.playOrPause();\n        }\n        return;\n      }\n      return super.play();\n    }\n\n    pause() {\n      if (this.#castPlayer) {\n        if (!this.#castPlayer.isPaused) {\n          this.#castPlayer.controller?.playOrPause();\n        }\n        return;\n      }\n      super.pause();\n    }\n\n    /**\n     * @see https://developers.google.com/cast/docs/reference/web_sender/cast.framework.CastOptions\n     * @readonly\n     *\n     * @typedef {Object} CastOptions\n     * @property {string} [receiverApplicationId='CC1AD845'] - The app id of the cast receiver.\n     * @property {string} [autoJoinPolicy='origin_scoped'] - The auto join policy.\n     * @property {string} [language='en-US'] - The language to use for the cast receiver.\n     * @property {boolean} [androidReceiverCompatible=false] - Whether to use the Cast Connect.\n     * @property {boolean} [resumeSavedSession=true] - Whether to resume the last session.\n     *\n     * @return {CastOptions}\n     */\n    get castOptions() {\n      return this.#castOptions;\n    }\n\n    get castReceiver() {\n      return this.getAttribute('cast-receiver') ?? undefined;\n    }\n\n    set castReceiver(val) {\n      if (this.castReceiver == val) return;\n      this.setAttribute('cast-receiver', `${val}`);\n    }\n\n    // Allow the cast source url to be different than <video src>, could be a blob.\n    get castSrc() {\n      // Try the first <source src> for usage with even more native markup.\n      return (\n        this.getAttribute('cast-src') ??\n        this.querySelector('source')?.src ??\n        this.currentSrc\n      );\n    }\n\n    set castSrc(val) {\n      if (this.castSrc == val) return;\n      this.setAttribute('cast-src', `${val}`);\n    }\n\n    get castContentType() {\n      return this.getAttribute('cast-content-type') ?? undefined;\n    }\n\n    set castContentType(val) {\n      this.setAttribute('cast-content-type', `${val}`);\n    }\n\n    get castStreamType() {\n      // NOTE: Per https://github.com/video-dev/media-ui-extensions/issues/3 `streamType` may yield `\"unknown\"`\n      return this.getAttribute('cast-stream-type') ?? this.streamType ?? undefined;\n    }\n\n    set castStreamType(val) {\n      this.setAttribute('cast-stream-type', `${val}`);\n    }\n\n    get castCustomData() {\n      return this.#castCustomData;\n    }\n\n    set castCustomData(val) {\n      const valType = typeof val;\n      if (!['object', 'undefined'].includes(valType)) {\n        console.error(`castCustomData must be nullish or an object but value was of type ${valType}`);\n        return;\n      }\n\n      this.#castCustomData = val;\n    }\n\n    get readyState() {\n      if (this.#castPlayer) {\n        switch (this.#castPlayer.playerState) {\n          case chrome.cast.media.PlayerState.IDLE:\n            return 0;\n          case chrome.cast.media.PlayerState.BUFFERING:\n            return 2;\n          default:\n            return 3;\n        }\n      }\n      return super.readyState;\n    }\n\n    get paused() {\n      if (this.#castPlayer) return this.#castPlayer.isPaused;\n      return super.paused;\n    }\n\n    get muted() {\n      if (this.#castPlayer) return this.#castPlayer?.isMuted;\n      return super.muted;\n    }\n\n    set muted(val) {\n      if (this.#castPlayer) {\n        if (\n          (val && !this.#castPlayer.isMuted) ||\n          (!val && this.#castPlayer.isMuted)\n        ) {\n          this.#castPlayer.controller?.muteOrUnmute();\n        }\n        return;\n      }\n      super.muted = val;\n    }\n\n    get volume() {\n      if (this.#castPlayer) return this.#castPlayer?.volumeLevel ?? 1;\n      return super.volume;\n    }\n\n    set volume(val) {\n      if (this.#castPlayer) {\n        this.#castPlayer.volumeLevel = +val;\n        this.#castPlayer.controller?.setVolumeLevel();\n        return;\n      }\n      super.volume = val;\n    }\n\n    get duration() {\n      // castPlayer duration returns `0` when no media is loaded.\n      if (this.#castPlayer && this.#castPlayer?.isMediaLoaded) {\n        return this.#castPlayer?.duration ?? NaN;\n      }\n      return super.duration;\n    }\n\n    get currentTime() {\n      if (this.#castPlayer && this.#castPlayer?.isMediaLoaded) {\n        return this.#castPlayer?.currentTime ?? 0;\n      }\n      return super.currentTime;\n    }\n\n    set currentTime(val) {\n      if (this.#castPlayer) {\n        this.#castPlayer.currentTime = val;\n        this.#castPlayer.controller?.seek();\n        return;\n      }\n      super.currentTime = val;\n    }\n  };\n\nconst CastableVideoMixin = CastableMediaMixin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2Nhc3RhYmxlLXZpZGVvL2Nhc3RhYmxlLW1peGluLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUMrRDtBQVNsQzs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUIsWUFBWTtBQUNaO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEIsbUJBQW1CLHlFQUFxQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsVUFBVSx5RUFBcUI7QUFDL0I7QUFDQTtBQUNBLFVBQVUscUVBQWlCO0FBQzNCOztBQUVBLFFBQVEsNERBQVk7QUFDcEI7QUFDQSxTQUFTOztBQUVULG1DQUFtQyx3RUFBYztBQUNqRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSw0REFBWTtBQUN6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLGtCQUFrQjs7QUFFdkQsVUFBVSx5REFBSztBQUNmLG9DQUFvQyw0RUFBd0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxrRUFBYzs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLFNBQVM7QUFDM0Isa0JBQWtCLFNBQVM7QUFDM0I7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsSUFBSTtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxJQUFJO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCxJQUFJO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLElBQUk7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRixRQUFRO0FBQ25HO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPIiwic291cmNlcyI6WyIvVXNlcnMvR2Fsb2NrL0NTL2JlaG9tZS1zaXRlL25vZGVfbW9kdWxlcy9jYXN0YWJsZS12aWRlby9jYXN0YWJsZS1taXhpbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgY2hyb21lICovXG5pbXBvcnQgeyBSZW1vdGVQbGF5YmFjayB9IGZyb20gJy4vY2FzdGFibGUtcmVtb3RlLXBsYXliYWNrLmpzJztcbmltcG9ydCB7XG4gIHByaXZhdGVQcm9wcyxcbiAgcmVxdWlyZXNDYXN0RnJhbWV3b3JrLFxuICBsb2FkQ2FzdEZyYW1ld29yayxcbiAgY3VycmVudFNlc3Npb24sXG4gIGdldERlZmF1bHRDYXN0T3B0aW9ucyxcbiAgaXNIbHMsXG4gIGdldFBsYXlsaXN0U2VnbWVudEZvcm1hdFxufSBmcm9tICcuL2Nhc3RhYmxlLXV0aWxzLmpzJztcblxuLyoqXG4gKiBDYXN0YWJsZU1lZGlhTWl4aW5cbiAqXG4gKiBUaGlzIG1peGluIGZ1bmN0aW9uIHByb3ZpZGVzIGEgd2F5IHRvIGNvbXBvc2UgbXVsdGlwbGUgY2xhc3Nlcy5cbiAqIEBzZWUgaHR0cHM6Ly9qdXN0aW5mYWduYW5pLmNvbS8yMDE1LzEyLzIxL3JlYWwtbWl4aW5zLXdpdGgtamF2YXNjcmlwdC1jbGFzc2VzL1xuICpcbiAqIEBwYXJhbSAge0hUTUxNZWRpYUVsZW1lbnR9IHN1cGVyY2xhc3MgLSBIVE1MTWVkaWFFbGVtZW50IG9yIGFuIGV4dGVuZGVkIGNsYXNzIG9mIGl0LlxuICogQHJldHVybiB7Q2FzdGFibGVNZWRpYX1cbiAqL1xuZXhwb3J0IGNvbnN0IENhc3RhYmxlTWVkaWFNaXhpbiA9IChzdXBlcmNsYXNzKSA9PlxuICBjbGFzcyBDYXN0YWJsZU1lZGlhIGV4dGVuZHMgc3VwZXJjbGFzcyB7XG5cbiAgICBzdGF0aWMgb2JzZXJ2ZWRBdHRyaWJ1dGVzID0gW1xuICAgICAgLi4uKHN1cGVyY2xhc3Mub2JzZXJ2ZWRBdHRyaWJ1dGVzID8/IFtdKSxcbiAgICAgICdjYXN0LXNyYycsXG4gICAgICAnY2FzdC1jb250ZW50LXR5cGUnLFxuICAgICAgJ2Nhc3Qtc3RyZWFtLXR5cGUnLFxuICAgICAgJ2Nhc3QtcmVjZWl2ZXInLFxuICAgIF07XG5cbiAgICAjbG9jYWxTdGF0ZSA9IHsgcGF1c2VkOiBmYWxzZSB9O1xuICAgICNjYXN0T3B0aW9ucyA9IGdldERlZmF1bHRDYXN0T3B0aW9ucygpO1xuICAgICNjYXN0Q3VzdG9tRGF0YTtcbiAgICAjcmVtb3RlO1xuXG4gICAgZ2V0IHJlbW90ZSgpIHtcbiAgICAgIGlmICh0aGlzLiNyZW1vdGUpIHJldHVybiB0aGlzLiNyZW1vdGU7XG5cbiAgICAgIGlmIChyZXF1aXJlc0Nhc3RGcmFtZXdvcmsoKSkge1xuICAgICAgICAvLyBObyBuZWVkIHRvIGxvYWQgdGhlIENhc3QgZnJhbWV3b3JrIGlmIGl0J3MgZGlzYWJsZWQuXG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlUmVtb3RlUGxheWJhY2spIHtcbiAgICAgICAgICBsb2FkQ2FzdEZyYW1ld29yaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJpdmF0ZVByb3BzLnNldCh0aGlzLCB7XG4gICAgICAgICAgbG9hZE9uUHJvbXB0OiAoKSA9PiB0aGlzLiNsb2FkT25Qcm9tcHQoKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gKHRoaXMuI3JlbW90ZSA9IG5ldyBSZW1vdGVQbGF5YmFjayh0aGlzKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdXBlci5yZW1vdGU7XG4gICAgfVxuXG4gICAgZ2V0ICNjYXN0UGxheWVyKCkge1xuICAgICAgcmV0dXJuIHByaXZhdGVQcm9wcy5nZXQodGhpcy5yZW1vdGUpPy5nZXRDYXN0UGxheWVyPy4oKTtcbiAgICB9XG5cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ck5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHJOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuXG4gICAgICBpZiAoYXR0ck5hbWUgPT09ICdjYXN0LXJlY2VpdmVyJyAmJiBuZXdWYWx1ZSkge1xuICAgICAgICB0aGlzLiNjYXN0T3B0aW9ucy5yZWNlaXZlckFwcGxpY2F0aW9uSWQgPSBuZXdWYWx1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuI2Nhc3RQbGF5ZXIpIHJldHVybjtcblxuICAgICAgc3dpdGNoIChhdHRyTmFtZSkge1xuICAgICAgICBjYXNlICdjYXN0LXN0cmVhbS10eXBlJzpcbiAgICAgICAgY2FzZSAnY2FzdC1zcmMnOlxuICAgICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jICNsb2FkT25Qcm9tcHQoKSB7XG4gICAgICAvLyBQYXVzZSBsb2NhbGx5IHdoZW4gdGhlIHNlc3Npb24gaXMgY3JlYXRlZC5cbiAgICAgIHRoaXMuI2xvY2FsU3RhdGUucGF1c2VkID0gc3VwZXIucGF1c2VkO1xuICAgICAgc3VwZXIucGF1c2UoKTtcblxuICAgICAgLy8gU3luYyBvdmVyIHRoZSBtdXRlZCBzdGF0ZSBidXQgbm90IHZvbHVtZSwgMTAwJSBpcyBkaWZmZXJlbnQgb24gVFYncyA6UFxuICAgICAgdGhpcy5tdXRlZCA9IHN1cGVyLm11dGVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWQoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgbG9hZCgpIHtcbiAgICAgIGlmICghdGhpcy4jY2FzdFBsYXllcikgcmV0dXJuIHN1cGVyLmxvYWQoKTtcblxuICAgICAgY29uc3QgbWVkaWFJbmZvID0gbmV3IGNocm9tZS5jYXN0Lm1lZGlhLk1lZGlhSW5mbyh0aGlzLmNhc3RTcmMsIHRoaXMuY2FzdENvbnRlbnRUeXBlKTtcbiAgICAgIG1lZGlhSW5mby5jdXN0b21EYXRhID0gdGhpcy5jYXN0Q3VzdG9tRGF0YTtcblxuICAgICAgLy8gTWFudWFsbHkgYWRkIHRleHQgdHJhY2tzIHdpdGggYSBgc3JjYCBhdHRyaWJ1dGUuXG4gICAgICAvLyBNM1U4J3MgbG9hZCB0ZXh0IHRyYWNrcyBpbiB0aGUgcmVjZWl2ZXIsIGhhbmRsZSB0aGVzZSBpbiB0aGUgbWVkaWEgbG9hZGVkIGV2ZW50LlxuICAgICAgY29uc3Qgc3VidGl0bGVzID0gWy4uLnRoaXMucXVlcnlTZWxlY3RvckFsbCgndHJhY2snKV0uZmlsdGVyKFxuICAgICAgICAoeyBraW5kLCBzcmMgfSkgPT4gc3JjICYmIChraW5kID09PSAnc3VidGl0bGVzJyB8fCBraW5kID09PSAnY2FwdGlvbnMnKVxuICAgICAgKTtcblxuICAgICAgY29uc3QgYWN0aXZlVHJhY2tJZHMgPSBbXTtcbiAgICAgIGxldCB0ZXh0VHJhY2tJZENvdW50ID0gMDtcblxuICAgICAgaWYgKHN1YnRpdGxlcy5sZW5ndGgpIHtcbiAgICAgICAgbWVkaWFJbmZvLnRyYWNrcyA9IHN1YnRpdGxlcy5tYXAoKHRyYWNrRWwpID0+IHtcbiAgICAgICAgICBjb25zdCB0cmFja0lkID0gKyt0ZXh0VHJhY2tJZENvdW50O1xuICAgICAgICAgIC8vIG9ubHkgYWN0aXZhdGUgMSBzdWJ0aXRsZSB0ZXh0IHRyYWNrLlxuICAgICAgICAgIGlmIChhY3RpdmVUcmFja0lkcy5sZW5ndGggPT09IDAgJiYgdHJhY2tFbC50cmFjay5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgICAgIGFjdGl2ZVRyYWNrSWRzLnB1c2godHJhY2tJZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgdHJhY2sgPSBuZXcgY2hyb21lLmNhc3QubWVkaWEuVHJhY2soXG4gICAgICAgICAgICB0cmFja0lkLFxuICAgICAgICAgICAgY2hyb21lLmNhc3QubWVkaWEuVHJhY2tUeXBlLlRFWFRcbiAgICAgICAgICApO1xuICAgICAgICAgIHRyYWNrLnRyYWNrQ29udGVudElkID0gdHJhY2tFbC5zcmM7XG4gICAgICAgICAgdHJhY2sudHJhY2tDb250ZW50VHlwZSA9ICd0ZXh0L3Z0dCc7XG4gICAgICAgICAgdHJhY2suc3VidHlwZSA9XG4gICAgICAgICAgICB0cmFja0VsLmtpbmQgPT09ICdjYXB0aW9ucydcbiAgICAgICAgICAgICAgPyBjaHJvbWUuY2FzdC5tZWRpYS5UZXh0VHJhY2tUeXBlLkNBUFRJT05TXG4gICAgICAgICAgICAgIDogY2hyb21lLmNhc3QubWVkaWEuVGV4dFRyYWNrVHlwZS5TVUJUSVRMRVM7XG4gICAgICAgICAgdHJhY2submFtZSA9IHRyYWNrRWwubGFiZWw7XG4gICAgICAgICAgdHJhY2subGFuZ3VhZ2UgPSB0cmFja0VsLnNyY2xhbmc7XG4gICAgICAgICAgcmV0dXJuIHRyYWNrO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2FzdFN0cmVhbVR5cGUgPT09ICdsaXZlJykge1xuICAgICAgICBtZWRpYUluZm8uc3RyZWFtVHlwZSA9IGNocm9tZS5jYXN0Lm1lZGlhLlN0cmVhbVR5cGUuTElWRTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lZGlhSW5mby5zdHJlYW1UeXBlID0gY2hyb21lLmNhc3QubWVkaWEuU3RyZWFtVHlwZS5CVUZGRVJFRDtcbiAgICAgIH1cblxuICAgICAgbWVkaWFJbmZvLm1ldGFkYXRhID0gbmV3IGNocm9tZS5jYXN0Lm1lZGlhLkdlbmVyaWNNZWRpYU1ldGFkYXRhKCk7XG4gICAgICBtZWRpYUluZm8ubWV0YWRhdGEudGl0bGUgPSB0aGlzLnRpdGxlO1xuICAgICAgbWVkaWFJbmZvLm1ldGFkYXRhLmltYWdlcyA9IFt7IHVybDogdGhpcy5wb3N0ZXIgfV07XG5cbiAgICAgIGlmIChpc0hscyh0aGlzLmNhc3RTcmMpKSB7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRGb3JtYXQgPSBhd2FpdCBnZXRQbGF5bGlzdFNlZ21lbnRGb3JtYXQodGhpcy5jYXN0U3JjKTtcbiAgICAgICAgY29uc3QgaXNGcmFnbWVudGVkTVA0ID0gc2VnbWVudEZvcm1hdD8uaW5jbHVkZXMoJ200cycpIHx8IHNlZ21lbnRGb3JtYXQ/LmluY2x1ZGVzKCdtcDQnKTtcbiAgICAgICAgaWYgKGlzRnJhZ21lbnRlZE1QNCkge1xuICAgICAgICAgIG1lZGlhSW5mby5obHNTZWdtZW50Rm9ybWF0ID0gY2hyb21lLmNhc3QubWVkaWEuSGxzU2VnbWVudEZvcm1hdC5GTVA0O1xuICAgICAgICAgIG1lZGlhSW5mby5obHNWaWRlb1NlZ21lbnRGb3JtYXQgPSBjaHJvbWUuY2FzdC5tZWRpYS5IbHNWaWRlb1NlZ21lbnRGb3JtYXQuRk1QNDtcbiAgICAgICAgfSBlbHNlIGlmIChzZWdtZW50Rm9ybWF0Py5pbmNsdWRlcygndHMnKSkge1xuICAgICAgICAgIG1lZGlhSW5mby5obHNTZWdtZW50Rm9ybWF0ID0gY2hyb21lLmNhc3QubWVkaWEuSGxzU2VnbWVudEZvcm1hdC5UUztcbiAgICAgICAgICBtZWRpYUluZm8uaGxzVmlkZW9TZWdtZW50Rm9ybWF0ID0gY2hyb21lLmNhc3QubWVkaWEuSGxzVmlkZW9TZWdtZW50Rm9ybWF0LlRTO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgY2hyb21lLmNhc3QubWVkaWEuTG9hZFJlcXVlc3QobWVkaWFJbmZvKTtcbiAgICAgIHJlcXVlc3QuY3VycmVudFRpbWUgPSBzdXBlci5jdXJyZW50VGltZSA/PyAwO1xuICAgICAgcmVxdWVzdC5hdXRvcGxheSA9ICF0aGlzLiNsb2NhbFN0YXRlLnBhdXNlZDtcbiAgICAgIHJlcXVlc3QuYWN0aXZlVHJhY2tJZHMgPSBhY3RpdmVUcmFja0lkcztcblxuICAgICAgYXdhaXQgY3VycmVudFNlc3Npb24oKT8ubG9hZE1lZGlhKHJlcXVlc3QpO1xuXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCd2b2x1bWVjaGFuZ2UnKSk7XG4gICAgfVxuXG4gICAgcGxheSgpIHtcbiAgICAgIGlmICh0aGlzLiNjYXN0UGxheWVyKSB7XG4gICAgICAgIGlmICh0aGlzLiNjYXN0UGxheWVyLmlzUGF1c2VkKSB7XG4gICAgICAgICAgdGhpcy4jY2FzdFBsYXllci5jb250cm9sbGVyPy5wbGF5T3JQYXVzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdXBlci5wbGF5KCk7XG4gICAgfVxuXG4gICAgcGF1c2UoKSB7XG4gICAgICBpZiAodGhpcy4jY2FzdFBsYXllcikge1xuICAgICAgICBpZiAoIXRoaXMuI2Nhc3RQbGF5ZXIuaXNQYXVzZWQpIHtcbiAgICAgICAgICB0aGlzLiNjYXN0UGxheWVyLmNvbnRyb2xsZXI/LnBsYXlPclBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3VwZXIucGF1c2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL2Nhc3QvZG9jcy9yZWZlcmVuY2Uvd2ViX3NlbmRlci9jYXN0LmZyYW1ld29yay5DYXN0T3B0aW9uc1xuICAgICAqIEByZWFkb25seVxuICAgICAqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gQ2FzdE9wdGlvbnNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3JlY2VpdmVyQXBwbGljYXRpb25JZD0nQ0MxQUQ4NDUnXSAtIFRoZSBhcHAgaWQgb2YgdGhlIGNhc3QgcmVjZWl2ZXIuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFthdXRvSm9pblBvbGljeT0nb3JpZ2luX3Njb3BlZCddIC0gVGhlIGF1dG8gam9pbiBwb2xpY3kuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtsYW5ndWFnZT0nZW4tVVMnXSAtIFRoZSBsYW5ndWFnZSB0byB1c2UgZm9yIHRoZSBjYXN0IHJlY2VpdmVyLlxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2FuZHJvaWRSZWNlaXZlckNvbXBhdGlibGU9ZmFsc2VdIC0gV2hldGhlciB0byB1c2UgdGhlIENhc3QgQ29ubmVjdC5cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZXN1bWVTYXZlZFNlc3Npb249dHJ1ZV0gLSBXaGV0aGVyIHRvIHJlc3VtZSB0aGUgbGFzdCBzZXNzaW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Q2FzdE9wdGlvbnN9XG4gICAgICovXG4gICAgZ2V0IGNhc3RPcHRpb25zKCkge1xuICAgICAgcmV0dXJuIHRoaXMuI2Nhc3RPcHRpb25zO1xuICAgIH1cblxuICAgIGdldCBjYXN0UmVjZWl2ZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2Nhc3QtcmVjZWl2ZXInKSA/PyB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgc2V0IGNhc3RSZWNlaXZlcih2YWwpIHtcbiAgICAgIGlmICh0aGlzLmNhc3RSZWNlaXZlciA9PSB2YWwpIHJldHVybjtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdjYXN0LXJlY2VpdmVyJywgYCR7dmFsfWApO1xuICAgIH1cblxuICAgIC8vIEFsbG93IHRoZSBjYXN0IHNvdXJjZSB1cmwgdG8gYmUgZGlmZmVyZW50IHRoYW4gPHZpZGVvIHNyYz4sIGNvdWxkIGJlIGEgYmxvYi5cbiAgICBnZXQgY2FzdFNyYygpIHtcbiAgICAgIC8vIFRyeSB0aGUgZmlyc3QgPHNvdXJjZSBzcmM+IGZvciB1c2FnZSB3aXRoIGV2ZW4gbW9yZSBuYXRpdmUgbWFya3VwLlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ2Nhc3Qtc3JjJykgPz9cbiAgICAgICAgdGhpcy5xdWVyeVNlbGVjdG9yKCdzb3VyY2UnKT8uc3JjID8/XG4gICAgICAgIHRoaXMuY3VycmVudFNyY1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBzZXQgY2FzdFNyYyh2YWwpIHtcbiAgICAgIGlmICh0aGlzLmNhc3RTcmMgPT0gdmFsKSByZXR1cm47XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnY2FzdC1zcmMnLCBgJHt2YWx9YCk7XG4gICAgfVxuXG4gICAgZ2V0IGNhc3RDb250ZW50VHlwZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnY2FzdC1jb250ZW50LXR5cGUnKSA/PyB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgc2V0IGNhc3RDb250ZW50VHlwZSh2YWwpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdjYXN0LWNvbnRlbnQtdHlwZScsIGAke3ZhbH1gKTtcbiAgICB9XG5cbiAgICBnZXQgY2FzdFN0cmVhbVR5cGUoKSB7XG4gICAgICAvLyBOT1RFOiBQZXIgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9tZWRpYS11aS1leHRlbnNpb25zL2lzc3Vlcy8zIGBzdHJlYW1UeXBlYCBtYXkgeWllbGQgYFwidW5rbm93blwiYFxuICAgICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdjYXN0LXN0cmVhbS10eXBlJykgPz8gdGhpcy5zdHJlYW1UeXBlID8/IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBzZXQgY2FzdFN0cmVhbVR5cGUodmFsKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnY2FzdC1zdHJlYW0tdHlwZScsIGAke3ZhbH1gKTtcbiAgICB9XG5cbiAgICBnZXQgY2FzdEN1c3RvbURhdGEoKSB7XG4gICAgICByZXR1cm4gdGhpcy4jY2FzdEN1c3RvbURhdGE7XG4gICAgfVxuXG4gICAgc2V0IGNhc3RDdXN0b21EYXRhKHZhbCkge1xuICAgICAgY29uc3QgdmFsVHlwZSA9IHR5cGVvZiB2YWw7XG4gICAgICBpZiAoIVsnb2JqZWN0JywgJ3VuZGVmaW5lZCddLmluY2x1ZGVzKHZhbFR5cGUpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYGNhc3RDdXN0b21EYXRhIG11c3QgYmUgbnVsbGlzaCBvciBhbiBvYmplY3QgYnV0IHZhbHVlIHdhcyBvZiB0eXBlICR7dmFsVHlwZX1gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiNjYXN0Q3VzdG9tRGF0YSA9IHZhbDtcbiAgICB9XG5cbiAgICBnZXQgcmVhZHlTdGF0ZSgpIHtcbiAgICAgIGlmICh0aGlzLiNjYXN0UGxheWVyKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy4jY2FzdFBsYXllci5wbGF5ZXJTdGF0ZSkge1xuICAgICAgICAgIGNhc2UgY2hyb21lLmNhc3QubWVkaWEuUGxheWVyU3RhdGUuSURMRTpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIGNhc2UgY2hyb21lLmNhc3QubWVkaWEuUGxheWVyU3RhdGUuQlVGRkVSSU5HOlxuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VwZXIucmVhZHlTdGF0ZTtcbiAgICB9XG5cbiAgICBnZXQgcGF1c2VkKCkge1xuICAgICAgaWYgKHRoaXMuI2Nhc3RQbGF5ZXIpIHJldHVybiB0aGlzLiNjYXN0UGxheWVyLmlzUGF1c2VkO1xuICAgICAgcmV0dXJuIHN1cGVyLnBhdXNlZDtcbiAgICB9XG5cbiAgICBnZXQgbXV0ZWQoKSB7XG4gICAgICBpZiAodGhpcy4jY2FzdFBsYXllcikgcmV0dXJuIHRoaXMuI2Nhc3RQbGF5ZXI/LmlzTXV0ZWQ7XG4gICAgICByZXR1cm4gc3VwZXIubXV0ZWQ7XG4gICAgfVxuXG4gICAgc2V0IG11dGVkKHZhbCkge1xuICAgICAgaWYgKHRoaXMuI2Nhc3RQbGF5ZXIpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICh2YWwgJiYgIXRoaXMuI2Nhc3RQbGF5ZXIuaXNNdXRlZCkgfHxcbiAgICAgICAgICAoIXZhbCAmJiB0aGlzLiNjYXN0UGxheWVyLmlzTXV0ZWQpXG4gICAgICAgICkge1xuICAgICAgICAgIHRoaXMuI2Nhc3RQbGF5ZXIuY29udHJvbGxlcj8ubXV0ZU9yVW5tdXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3VwZXIubXV0ZWQgPSB2YWw7XG4gICAgfVxuXG4gICAgZ2V0IHZvbHVtZSgpIHtcbiAgICAgIGlmICh0aGlzLiNjYXN0UGxheWVyKSByZXR1cm4gdGhpcy4jY2FzdFBsYXllcj8udm9sdW1lTGV2ZWwgPz8gMTtcbiAgICAgIHJldHVybiBzdXBlci52b2x1bWU7XG4gICAgfVxuXG4gICAgc2V0IHZvbHVtZSh2YWwpIHtcbiAgICAgIGlmICh0aGlzLiNjYXN0UGxheWVyKSB7XG4gICAgICAgIHRoaXMuI2Nhc3RQbGF5ZXIudm9sdW1lTGV2ZWwgPSArdmFsO1xuICAgICAgICB0aGlzLiNjYXN0UGxheWVyLmNvbnRyb2xsZXI/LnNldFZvbHVtZUxldmVsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN1cGVyLnZvbHVtZSA9IHZhbDtcbiAgICB9XG5cbiAgICBnZXQgZHVyYXRpb24oKSB7XG4gICAgICAvLyBjYXN0UGxheWVyIGR1cmF0aW9uIHJldHVybnMgYDBgIHdoZW4gbm8gbWVkaWEgaXMgbG9hZGVkLlxuICAgICAgaWYgKHRoaXMuI2Nhc3RQbGF5ZXIgJiYgdGhpcy4jY2FzdFBsYXllcj8uaXNNZWRpYUxvYWRlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY2FzdFBsYXllcj8uZHVyYXRpb24gPz8gTmFOO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1cGVyLmR1cmF0aW9uO1xuICAgIH1cblxuICAgIGdldCBjdXJyZW50VGltZSgpIHtcbiAgICAgIGlmICh0aGlzLiNjYXN0UGxheWVyICYmIHRoaXMuI2Nhc3RQbGF5ZXI/LmlzTWVkaWFMb2FkZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2Nhc3RQbGF5ZXI/LmN1cnJlbnRUaW1lID8/IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VwZXIuY3VycmVudFRpbWU7XG4gICAgfVxuXG4gICAgc2V0IGN1cnJlbnRUaW1lKHZhbCkge1xuICAgICAgaWYgKHRoaXMuI2Nhc3RQbGF5ZXIpIHtcbiAgICAgICAgdGhpcy4jY2FzdFBsYXllci5jdXJyZW50VGltZSA9IHZhbDtcbiAgICAgICAgdGhpcy4jY2FzdFBsYXllci5jb250cm9sbGVyPy5zZWVrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN1cGVyLmN1cnJlbnRUaW1lID0gdmFsO1xuICAgIH1cbiAgfTtcblxuZXhwb3J0IGNvbnN0IENhc3RhYmxlVmlkZW9NaXhpbiA9IENhc3RhYmxlTWVkaWFNaXhpbjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/castable-video/castable-mixin.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/castable-video/castable-remote-playback.js":
/*!******************************************************************!*\
  !*** ../node_modules/castable-video/castable-remote-playback.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RemotePlayback: () => (/* binding */ RemotePlayback)\n/* harmony export */ });\n/* harmony import */ var _castable_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./castable-utils.js */ \"(ssr)/../node_modules/castable-video/castable-utils.js\");\n/* global chrome, cast */\n\n\nconst remoteInstances = new _castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.IterableWeakSet();\nconst castElementRef = new WeakSet();\n\nlet cf;\n\n(0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.onCastApiAvailable)(() => {\n  if (!globalThis.chrome?.cast?.isAvailable) {\n    // Useful to see in verbose logs if this shows undefined or false.\n    console.debug('chrome.cast.isAvailable', globalThis.chrome?.cast?.isAvailable);\n    return;\n  }\n\n  if (!cf) {\n    cf = cast.framework;\n\n    (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.castContext)().addEventListener(cf.CastContextEventType.CAST_STATE_CHANGED, (e) => {\n      remoteInstances.forEach((r) => _castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.privateProps.get(r).onCastStateChanged?.(e));\n    });\n\n    (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.castContext)().addEventListener(cf.CastContextEventType.SESSION_STATE_CHANGED, (e) => {\n      remoteInstances.forEach((r) => _castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.privateProps.get(r).onSessionStateChanged?.(e));\n    });\n\n    remoteInstances.forEach((r) => _castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.privateProps.get(r).init?.());\n  }\n});\n\n\nlet remotePlaybackCallbackIdCount = 0;\n\n/**\n * Remote Playback shim for the Google cast SDK.\n * https://w3c.github.io/remote-playback/\n */\nclass RemotePlayback extends EventTarget {\n  #media;\n  #isInit;\n  #remotePlayer;\n  #remoteListeners;\n  #state = 'disconnected';\n  #available = false;\n  #callbacks = new Set();\n  #callbackIds = new WeakMap();\n\n  constructor(media) {\n    super();\n\n    this.#media = media;\n\n    remoteInstances.add(this);\n    _castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.privateProps.set(this, {\n      init: () => this.#init(),\n      onCastStateChanged: () => this.#onCastStateChanged(),\n      onSessionStateChanged: () => this.#onSessionStateChanged(),\n      getCastPlayer: () => this.#castPlayer,\n    });\n\n    this.#init();\n  }\n\n  get #castPlayer() {\n    if (castElementRef.has(this.#media)) return this.#remotePlayer;\n    return undefined;\n  }\n\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/RemotePlayback/state\n   * @return {'disconnected'|'connecting'|'connected'}\n   */\n  get state() {\n    return this.#state;\n  }\n\n  async watchAvailability(callback) {\n    if (this.#media.disableRemotePlayback) {\n      throw new _castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.InvalidStateError('disableRemotePlayback attribute is present.');\n    }\n\n    this.#callbackIds.set(callback, ++remotePlaybackCallbackIdCount);\n    this.#callbacks.add(callback);\n\n    // https://w3c.github.io/remote-playback/#getting-the-remote-playback-devices-availability-information\n    queueMicrotask(() => callback(this.#hasDevicesAvailable()));\n\n    return remotePlaybackCallbackIdCount;\n  }\n\n  async cancelWatchAvailability(callback) {\n    if (this.#media.disableRemotePlayback) {\n      throw new _castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.InvalidStateError('disableRemotePlayback attribute is present.');\n    }\n\n    if (callback) {\n      this.#callbacks.delete(callback);\n    } else {\n      this.#callbacks.clear();\n    }\n  }\n\n  async prompt() {\n    if (this.#media.disableRemotePlayback) {\n      throw new _castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.InvalidStateError('disableRemotePlayback attribute is present.');\n    }\n\n    if (!globalThis.chrome?.cast?.isAvailable) {\n      throw new _castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.NotSupportedError('The RemotePlayback API is disabled on this platform.');\n    }\n\n    const willDisconnect = castElementRef.has(this.#media);\n    castElementRef.add(this.#media);\n\n    (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.setCastOptions)(this.#media.castOptions);\n\n    Object.entries(this.#remoteListeners).forEach(([event, listener]) => {\n      this.#remotePlayer.controller.addEventListener(event, listener);\n    });\n\n    try {\n      // Open browser cast menu.\n      await (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.castContext)().requestSession();\n    } catch (err) {\n      // If there will be no disconnect, reset some state here.\n      if (!willDisconnect) {\n        castElementRef.delete(this.#media);\n      }\n\n      // Don't throw an error if disconnecting or cancelling.\n      if (err === 'cancel') {\n        return;\n      }\n\n      throw new Error(err);\n    }\n\n    _castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.privateProps.get(this.#media)?.loadOnPrompt?.();\n  }\n\n  #disconnect() {\n    if (!castElementRef.has(this.#media)) return;\n\n    Object.entries(this.#remoteListeners).forEach(([event, listener]) => {\n      this.#remotePlayer.controller.removeEventListener(event, listener);\n    });\n\n    castElementRef.delete(this.#media);\n\n    // isMuted is not in savedPlayerState. should we sync this back to local?\n    this.#media.muted = this.#remotePlayer.isMuted;\n    this.#media.currentTime = this.#remotePlayer.savedPlayerState.currentTime;\n    if (this.#remotePlayer.savedPlayerState.isPaused === false) {\n      this.#media.play();\n    }\n  }\n\n  #hasDevicesAvailable() {\n    // Cast state: NO_DEVICES_AVAILABLE, NOT_CONNECTED, CONNECTING, CONNECTED\n    // https://developers.google.com/cast/docs/reference/web_sender/cast.framework#.CastState\n    const castState = (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.castContext)()?.getCastState();\n    return castState && castState !== 'NO_DEVICES_AVAILABLE';\n  }\n\n  #onCastStateChanged() {\n    // Cast state: NO_DEVICES_AVAILABLE, NOT_CONNECTED, CONNECTING, CONNECTED\n    // https://developers.google.com/cast/docs/reference/web_sender/cast.framework#.CastState\n    const castState = (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.castContext)().getCastState();\n\n    if (castElementRef.has(this.#media)) {\n      if (castState === 'CONNECTING') {\n        this.#state = 'connecting';\n        this.dispatchEvent(new Event('connecting'));\n      }\n    }\n\n    if (!this.#available && castState?.includes('CONNECT')) {\n      this.#available = true;\n      for (let callback of this.#callbacks) callback(true);\n    }\n    else if (this.#available && (!castState || castState === 'NO_DEVICES_AVAILABLE')) {\n      this.#available = false;\n      for (let callback of this.#callbacks) callback(false);\n    }\n  }\n\n  async #onSessionStateChanged() {\n    // Session states: NO_SESSION, SESSION_STARTING, SESSION_STARTED, SESSION_START_FAILED,\n    //                 SESSION_ENDING, SESSION_ENDED, SESSION_RESUMED\n    // https://developers.google.com/cast/docs/reference/web_sender/cast.framework#.SessionState\n\n    const { SESSION_RESUMED } = cf.SessionState;\n    if ((0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.castContext)().getSessionState() === SESSION_RESUMED) {\n      /**\n       * Figure out if this was the video that started the resumed session.\n       * @TODO make this more specific than just checking against the video src!! (WL)\n       *\n       * If this video element can get the same unique id on each browser refresh\n       * it would be possible to pass this unique id w/ `LoadRequest.customData`\n       * and verify against currentMedia().customData below.\n       */\n      if (this.#media.castSrc === (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.currentMedia)()?.media.contentId) {\n        castElementRef.add(this.#media);\n\n        Object.entries(this.#remoteListeners).forEach(([event, listener]) => {\n          this.#remotePlayer.controller.addEventListener(event, listener);\n        });\n\n        /**\n         * There is cast framework resume session bug when you refresh the page a few\n         * times the this.#remotePlayer.currentTime will not be in sync with the receiver :(\n         * The below status request syncs it back up.\n         */\n        try {\n          await (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.getMediaStatus)(new chrome.cast.media.GetStatusRequest());\n        } catch (error) {\n          console.error(error);\n        }\n\n        // Dispatch the play, playing events manually to sync remote playing state.\n        this.#remoteListeners[cf.RemotePlayerEventType.IS_PAUSED_CHANGED]();\n        this.#remoteListeners[cf.RemotePlayerEventType.PLAYER_STATE_CHANGED]();\n      }\n    }\n  }\n\n  #init() {\n    if (!cf || this.#isInit) return;\n    this.#isInit = true;\n\n    (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.setCastOptions)(this.#media.castOptions);\n\n    /**\n     * @TODO add listeners for addtrack, removetrack (WL)\n     * This only has an impact on <track> with a `src` because these have to be\n     * loaded manually in the load() method. This will require a new load() call\n     * for each added/removed track w/ src.\n     */\n    this.#media.textTracks.addEventListener('change', () => this.#updateRemoteTextTrack());\n\n    this.#onCastStateChanged();\n\n    this.#remotePlayer = new cf.RemotePlayer();\n    new cf.RemotePlayerController(this.#remotePlayer);\n\n    this.#remoteListeners = {\n      [cf.RemotePlayerEventType.IS_CONNECTED_CHANGED]: ({ value }) => {\n        if (value === true) {\n          this.#state = 'connected';\n          this.dispatchEvent(new Event('connect'));\n        } else {\n          this.#disconnect();\n          this.#state = 'disconnected';\n          this.dispatchEvent(new Event('disconnect'));\n        }\n      },\n      [cf.RemotePlayerEventType.DURATION_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('durationchange'));\n      },\n      [cf.RemotePlayerEventType.VOLUME_LEVEL_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('volumechange'));\n      },\n      [cf.RemotePlayerEventType.IS_MUTED_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('volumechange'));\n      },\n      [cf.RemotePlayerEventType.CURRENT_TIME_CHANGED]: () => {\n        if (!this.#castPlayer?.isMediaLoaded) return;\n        this.#media.dispatchEvent(new Event('timeupdate'));\n      },\n      [cf.RemotePlayerEventType.VIDEO_INFO_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('resize'));\n      },\n      [cf.RemotePlayerEventType.IS_PAUSED_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event(this.paused ? 'pause' : 'play'));\n      },\n      [cf.RemotePlayerEventType.PLAYER_STATE_CHANGED]: () => {\n        // Player states: IDLE, PLAYING, PAUSED, BUFFERING\n        // https://developers.google.com/cast/docs/reference/web_sender/chrome.cast.media#.PlayerState\n\n        // pause event is handled above.\n        if (this.#castPlayer?.playerState === chrome.cast.media.PlayerState.PAUSED) {\n          return;\n        }\n\n        this.#media.dispatchEvent(\n          new Event(\n            {\n              [chrome.cast.media.PlayerState.PLAYING]: 'playing',\n              [chrome.cast.media.PlayerState.BUFFERING]: 'waiting',\n              [chrome.cast.media.PlayerState.IDLE]: 'emptied',\n            }[this.#castPlayer?.playerState]\n          )\n        );\n      },\n      [cf.RemotePlayerEventType.IS_MEDIA_LOADED_CHANGED]: async () => {\n        if (!this.#castPlayer?.isMediaLoaded) return;\n\n        // mediaInfo is not immediately available due to a bug? wait one tick\n        await Promise.resolve();\n        this.#onRemoteMediaLoaded();\n      },\n    };\n  }\n\n  #onRemoteMediaLoaded() {\n    this.#updateRemoteTextTrack();\n  }\n\n  async #updateRemoteTextTrack() {\n    if (!this.#castPlayer) return;\n\n    // Get the tracks w/ trackId's that have been loaded; manually or via a playlist like a M3U8 or MPD.\n    const remoteTracks = this.#remotePlayer.mediaInfo?.tracks ?? [];\n    const remoteSubtitles = remoteTracks.filter(\n      ({ type }) => type === chrome.cast.media.TrackType.TEXT\n    );\n\n    const localSubtitles = [...this.#media.textTracks].filter(\n      ({ kind }) => kind === 'subtitles' || kind === 'captions'\n    );\n\n    // Create a new array from the local subs w/ the trackId's from the remote subs.\n    const subtitles = remoteSubtitles\n      .map(({ language, name, trackId }) => {\n        // Find the corresponding local text track and assign the trackId.\n        const { mode } =\n          localSubtitles.find(\n            (local) => local.language === language && local.label === name\n          ) ?? {};\n        if (mode) return { mode, trackId };\n        return false;\n      })\n      .filter(Boolean);\n\n    const hiddenSubtitles = subtitles.filter(\n      ({ mode }) => mode !== 'showing'\n    );\n    const hiddenTrackIds = hiddenSubtitles.map(({ trackId }) => trackId);\n    const showingSubtitle = subtitles.find(({ mode }) => mode === 'showing');\n\n    // Note this could also include audio or video tracks, diff against local state.\n    const activeTrackIds =\n      (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.currentSession)()?.getSessionObj().media[0]\n        ?.activeTrackIds ?? [];\n    let requestTrackIds = activeTrackIds;\n\n    if (activeTrackIds.length) {\n      // Filter out all local hidden subtitle trackId's.\n      requestTrackIds = requestTrackIds.filter(\n        (id) => !hiddenTrackIds.includes(id)\n      );\n    }\n\n    if (showingSubtitle?.trackId) {\n      requestTrackIds = [...requestTrackIds, showingSubtitle.trackId];\n    }\n\n    // Remove duplicate ids.\n    requestTrackIds = [...new Set(requestTrackIds)];\n\n    const arrayEquals = (a, b) =>\n      a.length === b.length && a.every((a) => b.includes(a));\n    if (!arrayEquals(activeTrackIds, requestTrackIds)) {\n      try {\n        const request = new chrome.cast.media.EditTracksInfoRequest(\n          requestTrackIds\n        );\n        await (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.editTracksInfo)(request);\n      } catch (error) {\n        console.error(error);\n      }\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2Nhc3RhYmxlLXZpZGVvL2Nhc3RhYmxlLXJlbW90ZS1wbGF5YmFjay5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBYTZCOztBQUU3Qiw0QkFBNEIsK0RBQWU7QUFDM0M7O0FBRUE7O0FBRUEsc0VBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJLCtEQUFXO0FBQ2YscUNBQXFDLDREQUFZO0FBQ2pELEtBQUs7O0FBRUwsSUFBSSwrREFBVztBQUNmLHFDQUFxQyw0REFBWTtBQUNqRCxLQUFLOztBQUVMLG1DQUFtQyw0REFBWTtBQUMvQztBQUNBLENBQUM7OztBQUdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJLDREQUFZO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixpRUFBaUI7QUFDakM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixpRUFBaUI7QUFDakM7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixpRUFBaUI7QUFDakM7O0FBRUE7QUFDQSxnQkFBZ0IsaUVBQWlCO0FBQ2pDOztBQUVBO0FBQ0E7O0FBRUEsSUFBSSxrRUFBYzs7QUFFbEI7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLFlBQVksK0RBQVc7QUFDdkIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSSw0REFBWTtBQUNoQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrREFBVztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrREFBVzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGtCQUFrQjtBQUM5QixRQUFRLCtEQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0VBQVk7QUFDOUM7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtFQUFjO0FBQzlCLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxrRUFBYzs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBEQUEwRCxPQUFPO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0EsU0FBUyxNQUFNO0FBQ2Y7O0FBRUE7QUFDQSxTQUFTLE1BQU07QUFDZjs7QUFFQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkM7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxTQUFTLE1BQU07QUFDZjtBQUNBLGtEQUFrRCxTQUFTO0FBQzNELDhDQUE4QyxNQUFNOztBQUVwRDtBQUNBO0FBQ0EsTUFBTSxrRUFBYztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0VBQWM7QUFDNUIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9HYWxvY2svQ1MvYmVob21lLXNpdGUvbm9kZV9tb2R1bGVzL2Nhc3RhYmxlLXZpZGVvL2Nhc3RhYmxlLXJlbW90ZS1wbGF5YmFjay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgY2hyb21lLCBjYXN0ICovXG5pbXBvcnQge1xuICBwcml2YXRlUHJvcHMsXG4gIEl0ZXJhYmxlV2Vha1NldCxcbiAgSW52YWxpZFN0YXRlRXJyb3IsXG4gIE5vdFN1cHBvcnRlZEVycm9yLFxuICBvbkNhc3RBcGlBdmFpbGFibGUsXG4gIGNhc3RDb250ZXh0LFxuICBjdXJyZW50U2Vzc2lvbixcbiAgY3VycmVudE1lZGlhLFxuICBlZGl0VHJhY2tzSW5mbyxcbiAgZ2V0TWVkaWFTdGF0dXMsXG4gIHNldENhc3RPcHRpb25zXG59IGZyb20gJy4vY2FzdGFibGUtdXRpbHMuanMnO1xuXG5jb25zdCByZW1vdGVJbnN0YW5jZXMgPSBuZXcgSXRlcmFibGVXZWFrU2V0KCk7XG5jb25zdCBjYXN0RWxlbWVudFJlZiA9IG5ldyBXZWFrU2V0KCk7XG5cbmxldCBjZjtcblxub25DYXN0QXBpQXZhaWxhYmxlKCgpID0+IHtcbiAgaWYgKCFnbG9iYWxUaGlzLmNocm9tZT8uY2FzdD8uaXNBdmFpbGFibGUpIHtcbiAgICAvLyBVc2VmdWwgdG8gc2VlIGluIHZlcmJvc2UgbG9ncyBpZiB0aGlzIHNob3dzIHVuZGVmaW5lZCBvciBmYWxzZS5cbiAgICBjb25zb2xlLmRlYnVnKCdjaHJvbWUuY2FzdC5pc0F2YWlsYWJsZScsIGdsb2JhbFRoaXMuY2hyb21lPy5jYXN0Py5pc0F2YWlsYWJsZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFjZikge1xuICAgIGNmID0gY2FzdC5mcmFtZXdvcms7XG5cbiAgICBjYXN0Q29udGV4dCgpLmFkZEV2ZW50TGlzdGVuZXIoY2YuQ2FzdENvbnRleHRFdmVudFR5cGUuQ0FTVF9TVEFURV9DSEFOR0VELCAoZSkgPT4ge1xuICAgICAgcmVtb3RlSW5zdGFuY2VzLmZvckVhY2goKHIpID0+IHByaXZhdGVQcm9wcy5nZXQocikub25DYXN0U3RhdGVDaGFuZ2VkPy4oZSkpO1xuICAgIH0pO1xuXG4gICAgY2FzdENvbnRleHQoKS5hZGRFdmVudExpc3RlbmVyKGNmLkNhc3RDb250ZXh0RXZlbnRUeXBlLlNFU1NJT05fU1RBVEVfQ0hBTkdFRCwgKGUpID0+IHtcbiAgICAgIHJlbW90ZUluc3RhbmNlcy5mb3JFYWNoKChyKSA9PiBwcml2YXRlUHJvcHMuZ2V0KHIpLm9uU2Vzc2lvblN0YXRlQ2hhbmdlZD8uKGUpKTtcbiAgICB9KTtcblxuICAgIHJlbW90ZUluc3RhbmNlcy5mb3JFYWNoKChyKSA9PiBwcml2YXRlUHJvcHMuZ2V0KHIpLmluaXQ/LigpKTtcbiAgfVxufSk7XG5cblxubGV0IHJlbW90ZVBsYXliYWNrQ2FsbGJhY2tJZENvdW50ID0gMDtcblxuLyoqXG4gKiBSZW1vdGUgUGxheWJhY2sgc2hpbSBmb3IgdGhlIEdvb2dsZSBjYXN0IFNESy5cbiAqIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9yZW1vdGUtcGxheWJhY2svXG4gKi9cbmV4cG9ydCBjbGFzcyBSZW1vdGVQbGF5YmFjayBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgI21lZGlhO1xuICAjaXNJbml0O1xuICAjcmVtb3RlUGxheWVyO1xuICAjcmVtb3RlTGlzdGVuZXJzO1xuICAjc3RhdGUgPSAnZGlzY29ubmVjdGVkJztcbiAgI2F2YWlsYWJsZSA9IGZhbHNlO1xuICAjY2FsbGJhY2tzID0gbmV3IFNldCgpO1xuICAjY2FsbGJhY2tJZHMgPSBuZXcgV2Vha01hcCgpO1xuXG4gIGNvbnN0cnVjdG9yKG1lZGlhKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuI21lZGlhID0gbWVkaWE7XG5cbiAgICByZW1vdGVJbnN0YW5jZXMuYWRkKHRoaXMpO1xuICAgIHByaXZhdGVQcm9wcy5zZXQodGhpcywge1xuICAgICAgaW5pdDogKCkgPT4gdGhpcy4jaW5pdCgpLFxuICAgICAgb25DYXN0U3RhdGVDaGFuZ2VkOiAoKSA9PiB0aGlzLiNvbkNhc3RTdGF0ZUNoYW5nZWQoKSxcbiAgICAgIG9uU2Vzc2lvblN0YXRlQ2hhbmdlZDogKCkgPT4gdGhpcy4jb25TZXNzaW9uU3RhdGVDaGFuZ2VkKCksXG4gICAgICBnZXRDYXN0UGxheWVyOiAoKSA9PiB0aGlzLiNjYXN0UGxheWVyLFxuICAgIH0pO1xuXG4gICAgdGhpcy4jaW5pdCgpO1xuICB9XG5cbiAgZ2V0ICNjYXN0UGxheWVyKCkge1xuICAgIGlmIChjYXN0RWxlbWVudFJlZi5oYXModGhpcy4jbWVkaWEpKSByZXR1cm4gdGhpcy4jcmVtb3RlUGxheWVyO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1JlbW90ZVBsYXliYWNrL3N0YXRlXG4gICAqIEByZXR1cm4geydkaXNjb25uZWN0ZWQnfCdjb25uZWN0aW5nJ3wnY29ubmVjdGVkJ31cbiAgICovXG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RhdGU7XG4gIH1cblxuICBhc3luYyB3YXRjaEF2YWlsYWJpbGl0eShjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLiNtZWRpYS5kaXNhYmxlUmVtb3RlUGxheWJhY2spIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkU3RhdGVFcnJvcignZGlzYWJsZVJlbW90ZVBsYXliYWNrIGF0dHJpYnV0ZSBpcyBwcmVzZW50LicpO1xuICAgIH1cblxuICAgIHRoaXMuI2NhbGxiYWNrSWRzLnNldChjYWxsYmFjaywgKytyZW1vdGVQbGF5YmFja0NhbGxiYWNrSWRDb3VudCk7XG4gICAgdGhpcy4jY2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG5cbiAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vcmVtb3RlLXBsYXliYWNrLyNnZXR0aW5nLXRoZS1yZW1vdGUtcGxheWJhY2stZGV2aWNlcy1hdmFpbGFiaWxpdHktaW5mb3JtYXRpb25cbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjYWxsYmFjayh0aGlzLiNoYXNEZXZpY2VzQXZhaWxhYmxlKCkpKTtcblxuICAgIHJldHVybiByZW1vdGVQbGF5YmFja0NhbGxiYWNrSWRDb3VudDtcbiAgfVxuXG4gIGFzeW5jIGNhbmNlbFdhdGNoQXZhaWxhYmlsaXR5KGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuI21lZGlhLmRpc2FibGVSZW1vdGVQbGF5YmFjaykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRTdGF0ZUVycm9yKCdkaXNhYmxlUmVtb3RlUGxheWJhY2sgYXR0cmlidXRlIGlzIHByZXNlbnQuJyk7XG4gICAgfVxuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLiNjYWxsYmFja3MuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jY2FsbGJhY2tzLmNsZWFyKCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgcHJvbXB0KCkge1xuICAgIGlmICh0aGlzLiNtZWRpYS5kaXNhYmxlUmVtb3RlUGxheWJhY2spIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkU3RhdGVFcnJvcignZGlzYWJsZVJlbW90ZVBsYXliYWNrIGF0dHJpYnV0ZSBpcyBwcmVzZW50LicpO1xuICAgIH1cblxuICAgIGlmICghZ2xvYmFsVGhpcy5jaHJvbWU/LmNhc3Q/LmlzQXZhaWxhYmxlKSB7XG4gICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXJyb3IoJ1RoZSBSZW1vdGVQbGF5YmFjayBBUEkgaXMgZGlzYWJsZWQgb24gdGhpcyBwbGF0Zm9ybS4nKTtcbiAgICB9XG5cbiAgICBjb25zdCB3aWxsRGlzY29ubmVjdCA9IGNhc3RFbGVtZW50UmVmLmhhcyh0aGlzLiNtZWRpYSk7XG4gICAgY2FzdEVsZW1lbnRSZWYuYWRkKHRoaXMuI21lZGlhKTtcblxuICAgIHNldENhc3RPcHRpb25zKHRoaXMuI21lZGlhLmNhc3RPcHRpb25zKTtcblxuICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuI3JlbW90ZUxpc3RlbmVycykuZm9yRWFjaCgoW2V2ZW50LCBsaXN0ZW5lcl0pID0+IHtcbiAgICAgIHRoaXMuI3JlbW90ZVBsYXllci5jb250cm9sbGVyLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9KTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBPcGVuIGJyb3dzZXIgY2FzdCBtZW51LlxuICAgICAgYXdhaXQgY2FzdENvbnRleHQoKS5yZXF1ZXN0U2Vzc2lvbigpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gSWYgdGhlcmUgd2lsbCBiZSBubyBkaXNjb25uZWN0LCByZXNldCBzb21lIHN0YXRlIGhlcmUuXG4gICAgICBpZiAoIXdpbGxEaXNjb25uZWN0KSB7XG4gICAgICAgIGNhc3RFbGVtZW50UmVmLmRlbGV0ZSh0aGlzLiNtZWRpYSk7XG4gICAgICB9XG5cbiAgICAgIC8vIERvbid0IHRocm93IGFuIGVycm9yIGlmIGRpc2Nvbm5lY3Rpbmcgb3IgY2FuY2VsbGluZy5cbiAgICAgIGlmIChlcnIgPT09ICdjYW5jZWwnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZVByb3BzLmdldCh0aGlzLiNtZWRpYSk/LmxvYWRPblByb21wdD8uKCk7XG4gIH1cblxuICAjZGlzY29ubmVjdCgpIHtcbiAgICBpZiAoIWNhc3RFbGVtZW50UmVmLmhhcyh0aGlzLiNtZWRpYSkpIHJldHVybjtcblxuICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuI3JlbW90ZUxpc3RlbmVycykuZm9yRWFjaCgoW2V2ZW50LCBsaXN0ZW5lcl0pID0+IHtcbiAgICAgIHRoaXMuI3JlbW90ZVBsYXllci5jb250cm9sbGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9KTtcblxuICAgIGNhc3RFbGVtZW50UmVmLmRlbGV0ZSh0aGlzLiNtZWRpYSk7XG5cbiAgICAvLyBpc011dGVkIGlzIG5vdCBpbiBzYXZlZFBsYXllclN0YXRlLiBzaG91bGQgd2Ugc3luYyB0aGlzIGJhY2sgdG8gbG9jYWw/XG4gICAgdGhpcy4jbWVkaWEubXV0ZWQgPSB0aGlzLiNyZW1vdGVQbGF5ZXIuaXNNdXRlZDtcbiAgICB0aGlzLiNtZWRpYS5jdXJyZW50VGltZSA9IHRoaXMuI3JlbW90ZVBsYXllci5zYXZlZFBsYXllclN0YXRlLmN1cnJlbnRUaW1lO1xuICAgIGlmICh0aGlzLiNyZW1vdGVQbGF5ZXIuc2F2ZWRQbGF5ZXJTdGF0ZS5pc1BhdXNlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuI21lZGlhLnBsYXkoKTtcbiAgICB9XG4gIH1cblxuICAjaGFzRGV2aWNlc0F2YWlsYWJsZSgpIHtcbiAgICAvLyBDYXN0IHN0YXRlOiBOT19ERVZJQ0VTX0FWQUlMQUJMRSwgTk9UX0NPTk5FQ1RFRCwgQ09OTkVDVElORywgQ09OTkVDVEVEXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vY2FzdC9kb2NzL3JlZmVyZW5jZS93ZWJfc2VuZGVyL2Nhc3QuZnJhbWV3b3JrIy5DYXN0U3RhdGVcbiAgICBjb25zdCBjYXN0U3RhdGUgPSBjYXN0Q29udGV4dCgpPy5nZXRDYXN0U3RhdGUoKTtcbiAgICByZXR1cm4gY2FzdFN0YXRlICYmIGNhc3RTdGF0ZSAhPT0gJ05PX0RFVklDRVNfQVZBSUxBQkxFJztcbiAgfVxuXG4gICNvbkNhc3RTdGF0ZUNoYW5nZWQoKSB7XG4gICAgLy8gQ2FzdCBzdGF0ZTogTk9fREVWSUNFU19BVkFJTEFCTEUsIE5PVF9DT05ORUNURUQsIENPTk5FQ1RJTkcsIENPTk5FQ1RFRFxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL2Nhc3QvZG9jcy9yZWZlcmVuY2Uvd2ViX3NlbmRlci9jYXN0LmZyYW1ld29yayMuQ2FzdFN0YXRlXG4gICAgY29uc3QgY2FzdFN0YXRlID0gY2FzdENvbnRleHQoKS5nZXRDYXN0U3RhdGUoKTtcblxuICAgIGlmIChjYXN0RWxlbWVudFJlZi5oYXModGhpcy4jbWVkaWEpKSB7XG4gICAgICBpZiAoY2FzdFN0YXRlID09PSAnQ09OTkVDVElORycpIHtcbiAgICAgICAgdGhpcy4jc3RhdGUgPSAnY29ubmVjdGluZyc7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2Nvbm5lY3RpbmcnKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLiNhdmFpbGFibGUgJiYgY2FzdFN0YXRlPy5pbmNsdWRlcygnQ09OTkVDVCcpKSB7XG4gICAgICB0aGlzLiNhdmFpbGFibGUgPSB0cnVlO1xuICAgICAgZm9yIChsZXQgY2FsbGJhY2sgb2YgdGhpcy4jY2FsbGJhY2tzKSBjYWxsYmFjayh0cnVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy4jYXZhaWxhYmxlICYmICghY2FzdFN0YXRlIHx8IGNhc3RTdGF0ZSA9PT0gJ05PX0RFVklDRVNfQVZBSUxBQkxFJykpIHtcbiAgICAgIHRoaXMuI2F2YWlsYWJsZSA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgY2FsbGJhY2sgb2YgdGhpcy4jY2FsbGJhY2tzKSBjYWxsYmFjayhmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgI29uU2Vzc2lvblN0YXRlQ2hhbmdlZCgpIHtcbiAgICAvLyBTZXNzaW9uIHN0YXRlczogTk9fU0VTU0lPTiwgU0VTU0lPTl9TVEFSVElORywgU0VTU0lPTl9TVEFSVEVELCBTRVNTSU9OX1NUQVJUX0ZBSUxFRCxcbiAgICAvLyAgICAgICAgICAgICAgICAgU0VTU0lPTl9FTkRJTkcsIFNFU1NJT05fRU5ERUQsIFNFU1NJT05fUkVTVU1FRFxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL2Nhc3QvZG9jcy9yZWZlcmVuY2Uvd2ViX3NlbmRlci9jYXN0LmZyYW1ld29yayMuU2Vzc2lvblN0YXRlXG5cbiAgICBjb25zdCB7IFNFU1NJT05fUkVTVU1FRCB9ID0gY2YuU2Vzc2lvblN0YXRlO1xuICAgIGlmIChjYXN0Q29udGV4dCgpLmdldFNlc3Npb25TdGF0ZSgpID09PSBTRVNTSU9OX1JFU1VNRUQpIHtcbiAgICAgIC8qKlxuICAgICAgICogRmlndXJlIG91dCBpZiB0aGlzIHdhcyB0aGUgdmlkZW8gdGhhdCBzdGFydGVkIHRoZSByZXN1bWVkIHNlc3Npb24uXG4gICAgICAgKiBAVE9ETyBtYWtlIHRoaXMgbW9yZSBzcGVjaWZpYyB0aGFuIGp1c3QgY2hlY2tpbmcgYWdhaW5zdCB0aGUgdmlkZW8gc3JjISEgKFdMKVxuICAgICAgICpcbiAgICAgICAqIElmIHRoaXMgdmlkZW8gZWxlbWVudCBjYW4gZ2V0IHRoZSBzYW1lIHVuaXF1ZSBpZCBvbiBlYWNoIGJyb3dzZXIgcmVmcmVzaFxuICAgICAgICogaXQgd291bGQgYmUgcG9zc2libGUgdG8gcGFzcyB0aGlzIHVuaXF1ZSBpZCB3LyBgTG9hZFJlcXVlc3QuY3VzdG9tRGF0YWBcbiAgICAgICAqIGFuZCB2ZXJpZnkgYWdhaW5zdCBjdXJyZW50TWVkaWEoKS5jdXN0b21EYXRhIGJlbG93LlxuICAgICAgICovXG4gICAgICBpZiAodGhpcy4jbWVkaWEuY2FzdFNyYyA9PT0gY3VycmVudE1lZGlhKCk/Lm1lZGlhLmNvbnRlbnRJZCkge1xuICAgICAgICBjYXN0RWxlbWVudFJlZi5hZGQodGhpcy4jbWVkaWEpO1xuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuI3JlbW90ZUxpc3RlbmVycykuZm9yRWFjaCgoW2V2ZW50LCBsaXN0ZW5lcl0pID0+IHtcbiAgICAgICAgICB0aGlzLiNyZW1vdGVQbGF5ZXIuY29udHJvbGxlci5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGVyZSBpcyBjYXN0IGZyYW1ld29yayByZXN1bWUgc2Vzc2lvbiBidWcgd2hlbiB5b3UgcmVmcmVzaCB0aGUgcGFnZSBhIGZld1xuICAgICAgICAgKiB0aW1lcyB0aGUgdGhpcy4jcmVtb3RlUGxheWVyLmN1cnJlbnRUaW1lIHdpbGwgbm90IGJlIGluIHN5bmMgd2l0aCB0aGUgcmVjZWl2ZXIgOihcbiAgICAgICAgICogVGhlIGJlbG93IHN0YXR1cyByZXF1ZXN0IHN5bmNzIGl0IGJhY2sgdXAuXG4gICAgICAgICAqL1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IGdldE1lZGlhU3RhdHVzKG5ldyBjaHJvbWUuY2FzdC5tZWRpYS5HZXRTdGF0dXNSZXF1ZXN0KCkpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIHBsYXksIHBsYXlpbmcgZXZlbnRzIG1hbnVhbGx5IHRvIHN5bmMgcmVtb3RlIHBsYXlpbmcgc3RhdGUuXG4gICAgICAgIHRoaXMuI3JlbW90ZUxpc3RlbmVyc1tjZi5SZW1vdGVQbGF5ZXJFdmVudFR5cGUuSVNfUEFVU0VEX0NIQU5HRURdKCk7XG4gICAgICAgIHRoaXMuI3JlbW90ZUxpc3RlbmVyc1tjZi5SZW1vdGVQbGF5ZXJFdmVudFR5cGUuUExBWUVSX1NUQVRFX0NIQU5HRURdKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgI2luaXQoKSB7XG4gICAgaWYgKCFjZiB8fCB0aGlzLiNpc0luaXQpIHJldHVybjtcbiAgICB0aGlzLiNpc0luaXQgPSB0cnVlO1xuXG4gICAgc2V0Q2FzdE9wdGlvbnModGhpcy4jbWVkaWEuY2FzdE9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQFRPRE8gYWRkIGxpc3RlbmVycyBmb3IgYWRkdHJhY2ssIHJlbW92ZXRyYWNrIChXTClcbiAgICAgKiBUaGlzIG9ubHkgaGFzIGFuIGltcGFjdCBvbiA8dHJhY2s+IHdpdGggYSBgc3JjYCBiZWNhdXNlIHRoZXNlIGhhdmUgdG8gYmVcbiAgICAgKiBsb2FkZWQgbWFudWFsbHkgaW4gdGhlIGxvYWQoKSBtZXRob2QuIFRoaXMgd2lsbCByZXF1aXJlIGEgbmV3IGxvYWQoKSBjYWxsXG4gICAgICogZm9yIGVhY2ggYWRkZWQvcmVtb3ZlZCB0cmFjayB3LyBzcmMuXG4gICAgICovXG4gICAgdGhpcy4jbWVkaWEudGV4dFRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB0aGlzLiN1cGRhdGVSZW1vdGVUZXh0VHJhY2soKSk7XG5cbiAgICB0aGlzLiNvbkNhc3RTdGF0ZUNoYW5nZWQoKTtcblxuICAgIHRoaXMuI3JlbW90ZVBsYXllciA9IG5ldyBjZi5SZW1vdGVQbGF5ZXIoKTtcbiAgICBuZXcgY2YuUmVtb3RlUGxheWVyQ29udHJvbGxlcih0aGlzLiNyZW1vdGVQbGF5ZXIpO1xuXG4gICAgdGhpcy4jcmVtb3RlTGlzdGVuZXJzID0ge1xuICAgICAgW2NmLlJlbW90ZVBsYXllckV2ZW50VHlwZS5JU19DT05ORUNURURfQ0hBTkdFRF06ICh7IHZhbHVlIH0pID0+IHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy4jc3RhdGUgPSAnY29ubmVjdGVkJztcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdjb25uZWN0JykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuI2Rpc2Nvbm5lY3QoKTtcbiAgICAgICAgICB0aGlzLiNzdGF0ZSA9ICdkaXNjb25uZWN0ZWQnO1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2Rpc2Nvbm5lY3QnKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBbY2YuUmVtb3RlUGxheWVyRXZlbnRUeXBlLkRVUkFUSU9OX0NIQU5HRURdOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuI21lZGlhLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdkdXJhdGlvbmNoYW5nZScpKTtcbiAgICAgIH0sXG4gICAgICBbY2YuUmVtb3RlUGxheWVyRXZlbnRUeXBlLlZPTFVNRV9MRVZFTF9DSEFOR0VEXTogKCkgPT4ge1xuICAgICAgICB0aGlzLiNtZWRpYS5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgndm9sdW1lY2hhbmdlJykpO1xuICAgICAgfSxcbiAgICAgIFtjZi5SZW1vdGVQbGF5ZXJFdmVudFR5cGUuSVNfTVVURURfQ0hBTkdFRF06ICgpID0+IHtcbiAgICAgICAgdGhpcy4jbWVkaWEuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ3ZvbHVtZWNoYW5nZScpKTtcbiAgICAgIH0sXG4gICAgICBbY2YuUmVtb3RlUGxheWVyRXZlbnRUeXBlLkNVUlJFTlRfVElNRV9DSEFOR0VEXTogKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuI2Nhc3RQbGF5ZXI/LmlzTWVkaWFMb2FkZWQpIHJldHVybjtcbiAgICAgICAgdGhpcy4jbWVkaWEuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ3RpbWV1cGRhdGUnKSk7XG4gICAgICB9LFxuICAgICAgW2NmLlJlbW90ZVBsYXllckV2ZW50VHlwZS5WSURFT19JTkZPX0NIQU5HRURdOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuI21lZGlhLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdyZXNpemUnKSk7XG4gICAgICB9LFxuICAgICAgW2NmLlJlbW90ZVBsYXllckV2ZW50VHlwZS5JU19QQVVTRURfQ0hBTkdFRF06ICgpID0+IHtcbiAgICAgICAgdGhpcy4jbWVkaWEuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQodGhpcy5wYXVzZWQgPyAncGF1c2UnIDogJ3BsYXknKSk7XG4gICAgICB9LFxuICAgICAgW2NmLlJlbW90ZVBsYXllckV2ZW50VHlwZS5QTEFZRVJfU1RBVEVfQ0hBTkdFRF06ICgpID0+IHtcbiAgICAgICAgLy8gUGxheWVyIHN0YXRlczogSURMRSwgUExBWUlORywgUEFVU0VELCBCVUZGRVJJTkdcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vY2FzdC9kb2NzL3JlZmVyZW5jZS93ZWJfc2VuZGVyL2Nocm9tZS5jYXN0Lm1lZGlhIy5QbGF5ZXJTdGF0ZVxuXG4gICAgICAgIC8vIHBhdXNlIGV2ZW50IGlzIGhhbmRsZWQgYWJvdmUuXG4gICAgICAgIGlmICh0aGlzLiNjYXN0UGxheWVyPy5wbGF5ZXJTdGF0ZSA9PT0gY2hyb21lLmNhc3QubWVkaWEuUGxheWVyU3RhdGUuUEFVU0VEKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4jbWVkaWEuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICBuZXcgRXZlbnQoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIFtjaHJvbWUuY2FzdC5tZWRpYS5QbGF5ZXJTdGF0ZS5QTEFZSU5HXTogJ3BsYXlpbmcnLFxuICAgICAgICAgICAgICBbY2hyb21lLmNhc3QubWVkaWEuUGxheWVyU3RhdGUuQlVGRkVSSU5HXTogJ3dhaXRpbmcnLFxuICAgICAgICAgICAgICBbY2hyb21lLmNhc3QubWVkaWEuUGxheWVyU3RhdGUuSURMRV06ICdlbXB0aWVkJyxcbiAgICAgICAgICAgIH1bdGhpcy4jY2FzdFBsYXllcj8ucGxheWVyU3RhdGVdXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIFtjZi5SZW1vdGVQbGF5ZXJFdmVudFR5cGUuSVNfTUVESUFfTE9BREVEX0NIQU5HRURdOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy4jY2FzdFBsYXllcj8uaXNNZWRpYUxvYWRlZCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIG1lZGlhSW5mbyBpcyBub3QgaW1tZWRpYXRlbHkgYXZhaWxhYmxlIGR1ZSB0byBhIGJ1Zz8gd2FpdCBvbmUgdGlja1xuICAgICAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgdGhpcy4jb25SZW1vdGVNZWRpYUxvYWRlZCgpO1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgI29uUmVtb3RlTWVkaWFMb2FkZWQoKSB7XG4gICAgdGhpcy4jdXBkYXRlUmVtb3RlVGV4dFRyYWNrKCk7XG4gIH1cblxuICBhc3luYyAjdXBkYXRlUmVtb3RlVGV4dFRyYWNrKCkge1xuICAgIGlmICghdGhpcy4jY2FzdFBsYXllcikgcmV0dXJuO1xuXG4gICAgLy8gR2V0IHRoZSB0cmFja3Mgdy8gdHJhY2tJZCdzIHRoYXQgaGF2ZSBiZWVuIGxvYWRlZDsgbWFudWFsbHkgb3IgdmlhIGEgcGxheWxpc3QgbGlrZSBhIE0zVTggb3IgTVBELlxuICAgIGNvbnN0IHJlbW90ZVRyYWNrcyA9IHRoaXMuI3JlbW90ZVBsYXllci5tZWRpYUluZm8/LnRyYWNrcyA/PyBbXTtcbiAgICBjb25zdCByZW1vdGVTdWJ0aXRsZXMgPSByZW1vdGVUcmFja3MuZmlsdGVyKFxuICAgICAgKHsgdHlwZSB9KSA9PiB0eXBlID09PSBjaHJvbWUuY2FzdC5tZWRpYS5UcmFja1R5cGUuVEVYVFxuICAgICk7XG5cbiAgICBjb25zdCBsb2NhbFN1YnRpdGxlcyA9IFsuLi50aGlzLiNtZWRpYS50ZXh0VHJhY2tzXS5maWx0ZXIoXG4gICAgICAoeyBraW5kIH0pID0+IGtpbmQgPT09ICdzdWJ0aXRsZXMnIHx8IGtpbmQgPT09ICdjYXB0aW9ucydcbiAgICApO1xuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGFycmF5IGZyb20gdGhlIGxvY2FsIHN1YnMgdy8gdGhlIHRyYWNrSWQncyBmcm9tIHRoZSByZW1vdGUgc3Vicy5cbiAgICBjb25zdCBzdWJ0aXRsZXMgPSByZW1vdGVTdWJ0aXRsZXNcbiAgICAgIC5tYXAoKHsgbGFuZ3VhZ2UsIG5hbWUsIHRyYWNrSWQgfSkgPT4ge1xuICAgICAgICAvLyBGaW5kIHRoZSBjb3JyZXNwb25kaW5nIGxvY2FsIHRleHQgdHJhY2sgYW5kIGFzc2lnbiB0aGUgdHJhY2tJZC5cbiAgICAgICAgY29uc3QgeyBtb2RlIH0gPVxuICAgICAgICAgIGxvY2FsU3VidGl0bGVzLmZpbmQoXG4gICAgICAgICAgICAobG9jYWwpID0+IGxvY2FsLmxhbmd1YWdlID09PSBsYW5ndWFnZSAmJiBsb2NhbC5sYWJlbCA9PT0gbmFtZVxuICAgICAgICAgICkgPz8ge307XG4gICAgICAgIGlmIChtb2RlKSByZXR1cm4geyBtb2RlLCB0cmFja0lkIH07XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pO1xuXG4gICAgY29uc3QgaGlkZGVuU3VidGl0bGVzID0gc3VidGl0bGVzLmZpbHRlcihcbiAgICAgICh7IG1vZGUgfSkgPT4gbW9kZSAhPT0gJ3Nob3dpbmcnXG4gICAgKTtcbiAgICBjb25zdCBoaWRkZW5UcmFja0lkcyA9IGhpZGRlblN1YnRpdGxlcy5tYXAoKHsgdHJhY2tJZCB9KSA9PiB0cmFja0lkKTtcbiAgICBjb25zdCBzaG93aW5nU3VidGl0bGUgPSBzdWJ0aXRsZXMuZmluZCgoeyBtb2RlIH0pID0+IG1vZGUgPT09ICdzaG93aW5nJyk7XG5cbiAgICAvLyBOb3RlIHRoaXMgY291bGQgYWxzbyBpbmNsdWRlIGF1ZGlvIG9yIHZpZGVvIHRyYWNrcywgZGlmZiBhZ2FpbnN0IGxvY2FsIHN0YXRlLlxuICAgIGNvbnN0IGFjdGl2ZVRyYWNrSWRzID1cbiAgICAgIGN1cnJlbnRTZXNzaW9uKCk/LmdldFNlc3Npb25PYmooKS5tZWRpYVswXVxuICAgICAgICA/LmFjdGl2ZVRyYWNrSWRzID8/IFtdO1xuICAgIGxldCByZXF1ZXN0VHJhY2tJZHMgPSBhY3RpdmVUcmFja0lkcztcblxuICAgIGlmIChhY3RpdmVUcmFja0lkcy5sZW5ndGgpIHtcbiAgICAgIC8vIEZpbHRlciBvdXQgYWxsIGxvY2FsIGhpZGRlbiBzdWJ0aXRsZSB0cmFja0lkJ3MuXG4gICAgICByZXF1ZXN0VHJhY2tJZHMgPSByZXF1ZXN0VHJhY2tJZHMuZmlsdGVyKFxuICAgICAgICAoaWQpID0+ICFoaWRkZW5UcmFja0lkcy5pbmNsdWRlcyhpZClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHNob3dpbmdTdWJ0aXRsZT8udHJhY2tJZCkge1xuICAgICAgcmVxdWVzdFRyYWNrSWRzID0gWy4uLnJlcXVlc3RUcmFja0lkcywgc2hvd2luZ1N1YnRpdGxlLnRyYWNrSWRdO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBkdXBsaWNhdGUgaWRzLlxuICAgIHJlcXVlc3RUcmFja0lkcyA9IFsuLi5uZXcgU2V0KHJlcXVlc3RUcmFja0lkcyldO1xuXG4gICAgY29uc3QgYXJyYXlFcXVhbHMgPSAoYSwgYikgPT5cbiAgICAgIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KChhKSA9PiBiLmluY2x1ZGVzKGEpKTtcbiAgICBpZiAoIWFycmF5RXF1YWxzKGFjdGl2ZVRyYWNrSWRzLCByZXF1ZXN0VHJhY2tJZHMpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IGNocm9tZS5jYXN0Lm1lZGlhLkVkaXRUcmFja3NJbmZvUmVxdWVzdChcbiAgICAgICAgICByZXF1ZXN0VHJhY2tJZHNcbiAgICAgICAgKTtcbiAgICAgICAgYXdhaXQgZWRpdFRyYWNrc0luZm8ocmVxdWVzdCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/castable-video/castable-remote-playback.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/castable-video/castable-utils.js":
/*!********************************************************!*\
  !*** ../node_modules/castable-video/castable-utils.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidStateError: () => (/* binding */ InvalidStateError),\n/* harmony export */   IterableWeakSet: () => (/* binding */ IterableWeakSet),\n/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError),\n/* harmony export */   NotSupportedError: () => (/* binding */ NotSupportedError),\n/* harmony export */   castContext: () => (/* binding */ castContext),\n/* harmony export */   currentMedia: () => (/* binding */ currentMedia),\n/* harmony export */   currentSession: () => (/* binding */ currentSession),\n/* harmony export */   editTracksInfo: () => (/* binding */ editTracksInfo),\n/* harmony export */   getDefaultCastOptions: () => (/* binding */ getDefaultCastOptions),\n/* harmony export */   getMediaStatus: () => (/* binding */ getMediaStatus),\n/* harmony export */   getPlaylistSegmentFormat: () => (/* binding */ getPlaylistSegmentFormat),\n/* harmony export */   isHls: () => (/* binding */ isHls),\n/* harmony export */   loadCastFramework: () => (/* binding */ loadCastFramework),\n/* harmony export */   onCastApiAvailable: () => (/* binding */ onCastApiAvailable),\n/* harmony export */   privateProps: () => (/* binding */ privateProps),\n/* harmony export */   requiresCastFramework: () => (/* binding */ requiresCastFramework),\n/* harmony export */   setCastOptions: () => (/* binding */ setCastOptions)\n/* harmony export */ });\n/* global WeakRef */\n\nconst privateProps = new WeakMap();\n\nclass InvalidStateError extends Error {}\nclass NotSupportedError extends Error {}\nclass NotFoundError extends Error {}\n\nconst HLS_RESPONSE_HEADERS = ['application/x-mpegURL','application/vnd.apple.mpegurl','audio/mpegurl']\n\n// Fallback to a plain Set if WeakRef is not available.\nconst IterableWeakSet = globalThis.WeakRef ?\n  class extends Set {\n    add(el) {\n      super.add(new WeakRef(el));\n    }\n    forEach(fn) {\n      super.forEach((ref) => {\n        const value = ref.deref();\n        if (value) fn(value);\n      });\n    }\n  } : Set;\n\nfunction onCastApiAvailable(callback) {\n  if (!globalThis.chrome?.cast?.isAvailable) {\n    globalThis.__onGCastApiAvailable = () => {\n      // The globalThis.__onGCastApiAvailable callback alone is not reliable for\n      // the added cast.framework. It's loaded in a separate JS file.\n      // https://www.gstatic.com/eureka/clank/101/cast_sender.js\n      // https://www.gstatic.com/cast/sdk/libs/sender/1.0/cast_framework.js\n      customElements\n        .whenDefined('google-cast-button')\n        .then(callback);\n    };\n  } else if (!globalThis.cast?.framework) {\n    customElements\n      .whenDefined('google-cast-button')\n      .then(callback);\n  } else {\n    callback();\n  }\n}\n\nfunction requiresCastFramework() {\n  // todo: exclude for Android>=56 which supports the Remote Playback API natively.\n  return globalThis.chrome;\n}\n\nfunction loadCastFramework() {\n  const sdkUrl = 'https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1';\n  if (globalThis.chrome?.cast || document.querySelector(`script[src=\"${sdkUrl}\"]`)) return;\n\n  const script = document.createElement('script');\n  script.src = sdkUrl;\n  document.head.append(script);\n}\n\nfunction castContext() {\n  return globalThis.cast?.framework?.CastContext.getInstance();\n}\n\nfunction currentSession() {\n  return castContext()?.getCurrentSession();\n}\n\nfunction currentMedia() {\n  return currentSession()?.getSessionObj().media[0];\n}\n\nfunction editTracksInfo(request) {\n  return new Promise((resolve, reject) => {\n    currentMedia().editTracksInfo(request, resolve, reject);\n  });\n}\n\nfunction getMediaStatus(request) {\n  return new Promise((resolve, reject) => {\n    currentMedia().getStatus(request, resolve, reject);\n  });\n}\n\nfunction setCastOptions(options) {\n  return castContext().setOptions({\n    ...getDefaultCastOptions(),\n    ...options,\n  });\n}\n\nfunction getDefaultCastOptions() {\n  return {\n    // Set the receiver application ID to your own (created in the\n    // Google Cast Developer Console), or optionally\n    // use the chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID\n    receiverApplicationId: 'CC1AD845',\n\n    // Auto join policy can be one of the following three:\n    // ORIGIN_SCOPED - Auto connect from same appId and page origin\n    // TAB_AND_ORIGIN_SCOPED - Auto connect from same appId, page origin, and tab\n    // PAGE_SCOPED - No auto connect\n    autoJoinPolicy: 'origin_scoped',\n\n    // The following flag enables Cast Connect(requires Chrome 87 or higher)\n    // https://developers.googleblog.com/2020/08/introducing-cast-connect-android-tv.html\n    androidReceiverCompatible: false,\n\n    language: 'en-US',\n    resumeSavedSession: true,\n  };\n}\n\n//Get the segment format given the end of the URL (.m4s, .ts, etc)\nfunction getFormat(segment) {\n  if (!segment) return undefined;\n\n  const regex = /\\.([a-zA-Z0-9]+)(?:\\?.*)?$/;\n  const match = segment.match(regex);\n  return match ? match[1] : null;\n}\n\nfunction parsePlaylistUrls(playlistContent) {\n  const lines = playlistContent.split('\\n');\n  const urls = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n\n    // Locate available video playlists and get the next line which is the URI (https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-17#section-4.4.6.2)\n    if (line.startsWith('#EXT-X-STREAM-INF')) {\n      const nextLine = lines[i + 1] ? lines[i + 1].trim() : '';\n      if (nextLine && !nextLine.startsWith('#')) {\n        urls.push(nextLine);\n      }\n    }\n  }\n\n  return urls;\n}\n\nfunction parseSegment(playlistContent){\n  const lines = playlistContent.split('\\n');\n\n  const url = lines.find(line => !line.trim().startsWith('#') && line.trim() !== '');\n\n  return url;\n}\n\nasync function isHls(url) {\n  try {\n    const response = await fetch(url, {method: 'HEAD'});\n    const contentType = response.headers.get('Content-Type');\n\n    return HLS_RESPONSE_HEADERS.some((header) => contentType === header);\n  } catch (err) {\n    console.error('Error while trying to get the Content-Type of the manifest', err);\n    return false;\n  }\n}\n\nasync function getPlaylistSegmentFormat(url) {\n  try {\n    const mainManifestContent = await (await fetch(url)).text();\n    let availableChunksContent = mainManifestContent;\n\n    const playlists = parsePlaylistUrls(mainManifestContent);\n    if (playlists.length > 0) {    \n      const chosenPlaylistUrl = new URL(playlists[0], url).toString();\n      availableChunksContent = await (await fetch(chosenPlaylistUrl)).text();\n    }\n\n    const segment = parseSegment(availableChunksContent);\n    const format = getFormat(segment);\n    return format\n  } catch (err) {\n    console.error('Error while trying to parse the manifest playlist', err);\n    return undefined;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2Nhc3RhYmxlLXZpZGVvL2Nhc3RhYmxlLXV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBRU87O0FBRUE7QUFDQTtBQUNBOztBQUVQOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSTs7QUFFRztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLHVFQUF1RSxPQUFPOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9HYWxvY2svQ1MvYmVob21lLXNpdGUvbm9kZV9tb2R1bGVzL2Nhc3RhYmxlLXZpZGVvL2Nhc3RhYmxlLXV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbCBXZWFrUmVmICovXG5cbmV4cG9ydCBjb25zdCBwcml2YXRlUHJvcHMgPSBuZXcgV2Vha01hcCgpO1xuXG5leHBvcnQgY2xhc3MgSW52YWxpZFN0YXRlRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuZXhwb3J0IGNsYXNzIE5vdFN1cHBvcnRlZEVycm9yIGV4dGVuZHMgRXJyb3Ige31cbmV4cG9ydCBjbGFzcyBOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuY29uc3QgSExTX1JFU1BPTlNFX0hFQURFUlMgPSBbJ2FwcGxpY2F0aW9uL3gtbXBlZ1VSTCcsJ2FwcGxpY2F0aW9uL3ZuZC5hcHBsZS5tcGVndXJsJywnYXVkaW8vbXBlZ3VybCddXG5cbi8vIEZhbGxiYWNrIHRvIGEgcGxhaW4gU2V0IGlmIFdlYWtSZWYgaXMgbm90IGF2YWlsYWJsZS5cbmV4cG9ydCBjb25zdCBJdGVyYWJsZVdlYWtTZXQgPSBnbG9iYWxUaGlzLldlYWtSZWYgP1xuICBjbGFzcyBleHRlbmRzIFNldCB7XG4gICAgYWRkKGVsKSB7XG4gICAgICBzdXBlci5hZGQobmV3IFdlYWtSZWYoZWwpKTtcbiAgICB9XG4gICAgZm9yRWFjaChmbikge1xuICAgICAgc3VwZXIuZm9yRWFjaCgocmVmKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcmVmLmRlcmVmKCk7XG4gICAgICAgIGlmICh2YWx1ZSkgZm4odmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9IDogU2V0O1xuXG5leHBvcnQgZnVuY3Rpb24gb25DYXN0QXBpQXZhaWxhYmxlKGNhbGxiYWNrKSB7XG4gIGlmICghZ2xvYmFsVGhpcy5jaHJvbWU/LmNhc3Q/LmlzQXZhaWxhYmxlKSB7XG4gICAgZ2xvYmFsVGhpcy5fX29uR0Nhc3RBcGlBdmFpbGFibGUgPSAoKSA9PiB7XG4gICAgICAvLyBUaGUgZ2xvYmFsVGhpcy5fX29uR0Nhc3RBcGlBdmFpbGFibGUgY2FsbGJhY2sgYWxvbmUgaXMgbm90IHJlbGlhYmxlIGZvclxuICAgICAgLy8gdGhlIGFkZGVkIGNhc3QuZnJhbWV3b3JrLiBJdCdzIGxvYWRlZCBpbiBhIHNlcGFyYXRlIEpTIGZpbGUuXG4gICAgICAvLyBodHRwczovL3d3dy5nc3RhdGljLmNvbS9ldXJla2EvY2xhbmsvMTAxL2Nhc3Rfc2VuZGVyLmpzXG4gICAgICAvLyBodHRwczovL3d3dy5nc3RhdGljLmNvbS9jYXN0L3Nkay9saWJzL3NlbmRlci8xLjAvY2FzdF9mcmFtZXdvcmsuanNcbiAgICAgIGN1c3RvbUVsZW1lbnRzXG4gICAgICAgIC53aGVuRGVmaW5lZCgnZ29vZ2xlLWNhc3QtYnV0dG9uJylcbiAgICAgICAgLnRoZW4oY2FsbGJhY2spO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoIWdsb2JhbFRoaXMuY2FzdD8uZnJhbWV3b3JrKSB7XG4gICAgY3VzdG9tRWxlbWVudHNcbiAgICAgIC53aGVuRGVmaW5lZCgnZ29vZ2xlLWNhc3QtYnV0dG9uJylcbiAgICAgIC50aGVuKGNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXF1aXJlc0Nhc3RGcmFtZXdvcmsoKSB7XG4gIC8vIHRvZG86IGV4Y2x1ZGUgZm9yIEFuZHJvaWQ+PTU2IHdoaWNoIHN1cHBvcnRzIHRoZSBSZW1vdGUgUGxheWJhY2sgQVBJIG5hdGl2ZWx5LlxuICByZXR1cm4gZ2xvYmFsVGhpcy5jaHJvbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkQ2FzdEZyYW1ld29yaygpIHtcbiAgY29uc3Qgc2RrVXJsID0gJ2h0dHBzOi8vd3d3LmdzdGF0aWMuY29tL2N2L2pzL3NlbmRlci92MS9jYXN0X3NlbmRlci5qcz9sb2FkQ2FzdEZyYW1ld29yaz0xJztcbiAgaWYgKGdsb2JhbFRoaXMuY2hyb21lPy5jYXN0IHx8IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYHNjcmlwdFtzcmM9XCIke3Nka1VybH1cIl1gKSkgcmV0dXJuO1xuXG4gIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICBzY3JpcHQuc3JjID0gc2RrVXJsO1xuICBkb2N1bWVudC5oZWFkLmFwcGVuZChzY3JpcHQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FzdENvbnRleHQoKSB7XG4gIHJldHVybiBnbG9iYWxUaGlzLmNhc3Q/LmZyYW1ld29yaz8uQ2FzdENvbnRleHQuZ2V0SW5zdGFuY2UoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGN1cnJlbnRTZXNzaW9uKCkge1xuICByZXR1cm4gY2FzdENvbnRleHQoKT8uZ2V0Q3VycmVudFNlc3Npb24oKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGN1cnJlbnRNZWRpYSgpIHtcbiAgcmV0dXJuIGN1cnJlbnRTZXNzaW9uKCk/LmdldFNlc3Npb25PYmooKS5tZWRpYVswXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVkaXRUcmFja3NJbmZvKHJlcXVlc3QpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjdXJyZW50TWVkaWEoKS5lZGl0VHJhY2tzSW5mbyhyZXF1ZXN0LCByZXNvbHZlLCByZWplY3QpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1lZGlhU3RhdHVzKHJlcXVlc3QpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjdXJyZW50TWVkaWEoKS5nZXRTdGF0dXMocmVxdWVzdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRDYXN0T3B0aW9ucyhvcHRpb25zKSB7XG4gIHJldHVybiBjYXN0Q29udGV4dCgpLnNldE9wdGlvbnMoe1xuICAgIC4uLmdldERlZmF1bHRDYXN0T3B0aW9ucygpLFxuICAgIC4uLm9wdGlvbnMsXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdENhc3RPcHRpb25zKCkge1xuICByZXR1cm4ge1xuICAgIC8vIFNldCB0aGUgcmVjZWl2ZXIgYXBwbGljYXRpb24gSUQgdG8geW91ciBvd24gKGNyZWF0ZWQgaW4gdGhlXG4gICAgLy8gR29vZ2xlIENhc3QgRGV2ZWxvcGVyIENvbnNvbGUpLCBvciBvcHRpb25hbGx5XG4gICAgLy8gdXNlIHRoZSBjaHJvbWUuY2FzdC5tZWRpYS5ERUZBVUxUX01FRElBX1JFQ0VJVkVSX0FQUF9JRFxuICAgIHJlY2VpdmVyQXBwbGljYXRpb25JZDogJ0NDMUFEODQ1JyxcblxuICAgIC8vIEF1dG8gam9pbiBwb2xpY3kgY2FuIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHRocmVlOlxuICAgIC8vIE9SSUdJTl9TQ09QRUQgLSBBdXRvIGNvbm5lY3QgZnJvbSBzYW1lIGFwcElkIGFuZCBwYWdlIG9yaWdpblxuICAgIC8vIFRBQl9BTkRfT1JJR0lOX1NDT1BFRCAtIEF1dG8gY29ubmVjdCBmcm9tIHNhbWUgYXBwSWQsIHBhZ2Ugb3JpZ2luLCBhbmQgdGFiXG4gICAgLy8gUEFHRV9TQ09QRUQgLSBObyBhdXRvIGNvbm5lY3RcbiAgICBhdXRvSm9pblBvbGljeTogJ29yaWdpbl9zY29wZWQnLFxuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBmbGFnIGVuYWJsZXMgQ2FzdCBDb25uZWN0KHJlcXVpcmVzIENocm9tZSA4NyBvciBoaWdoZXIpXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZWJsb2cuY29tLzIwMjAvMDgvaW50cm9kdWNpbmctY2FzdC1jb25uZWN0LWFuZHJvaWQtdHYuaHRtbFxuICAgIGFuZHJvaWRSZWNlaXZlckNvbXBhdGlibGU6IGZhbHNlLFxuXG4gICAgbGFuZ3VhZ2U6ICdlbi1VUycsXG4gICAgcmVzdW1lU2F2ZWRTZXNzaW9uOiB0cnVlLFxuICB9O1xufVxuXG4vL0dldCB0aGUgc2VnbWVudCBmb3JtYXQgZ2l2ZW4gdGhlIGVuZCBvZiB0aGUgVVJMICgubTRzLCAudHMsIGV0YylcbmZ1bmN0aW9uIGdldEZvcm1hdChzZWdtZW50KSB7XG4gIGlmICghc2VnbWVudCkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICBjb25zdCByZWdleCA9IC9cXC4oW2EtekEtWjAtOV0rKSg/OlxcPy4qKT8kLztcbiAgY29uc3QgbWF0Y2ggPSBzZWdtZW50Lm1hdGNoKHJlZ2V4KTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiBudWxsO1xufVxuXG5mdW5jdGlvbiBwYXJzZVBsYXlsaXN0VXJscyhwbGF5bGlzdENvbnRlbnQpIHtcbiAgY29uc3QgbGluZXMgPSBwbGF5bGlzdENvbnRlbnQuc3BsaXQoJ1xcbicpO1xuICBjb25zdCB1cmxzID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXS50cmltKCk7XG5cbiAgICAvLyBMb2NhdGUgYXZhaWxhYmxlIHZpZGVvIHBsYXlsaXN0cyBhbmQgZ2V0IHRoZSBuZXh0IGxpbmUgd2hpY2ggaXMgdGhlIFVSSSAoaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1wYW50b3MtaGxzLXJmYzgyMTZiaXMtMTcjc2VjdGlvbi00LjQuNi4yKVxuICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoJyNFWFQtWC1TVFJFQU0tSU5GJykpIHtcbiAgICAgIGNvbnN0IG5leHRMaW5lID0gbGluZXNbaSArIDFdID8gbGluZXNbaSArIDFdLnRyaW0oKSA6ICcnO1xuICAgICAgaWYgKG5leHRMaW5lICYmICFuZXh0TGluZS5zdGFydHNXaXRoKCcjJykpIHtcbiAgICAgICAgdXJscy5wdXNoKG5leHRMaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdXJscztcbn1cblxuZnVuY3Rpb24gcGFyc2VTZWdtZW50KHBsYXlsaXN0Q29udGVudCl7XG4gIGNvbnN0IGxpbmVzID0gcGxheWxpc3RDb250ZW50LnNwbGl0KCdcXG4nKTtcblxuICBjb25zdCB1cmwgPSBsaW5lcy5maW5kKGxpbmUgPT4gIWxpbmUudHJpbSgpLnN0YXJ0c1dpdGgoJyMnKSAmJiBsaW5lLnRyaW0oKSAhPT0gJycpO1xuXG4gIHJldHVybiB1cmw7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpc0hscyh1cmwpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge21ldGhvZDogJ0hFQUQnfSk7XG4gICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJyk7XG5cbiAgICByZXR1cm4gSExTX1JFU1BPTlNFX0hFQURFUlMuc29tZSgoaGVhZGVyKSA9PiBjb250ZW50VHlwZSA9PT0gaGVhZGVyKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igd2hpbGUgdHJ5aW5nIHRvIGdldCB0aGUgQ29udGVudC1UeXBlIG9mIHRoZSBtYW5pZmVzdCcsIGVycik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQbGF5bGlzdFNlZ21lbnRGb3JtYXQodXJsKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgbWFpbk1hbmlmZXN0Q29udGVudCA9IGF3YWl0IChhd2FpdCBmZXRjaCh1cmwpKS50ZXh0KCk7XG4gICAgbGV0IGF2YWlsYWJsZUNodW5rc0NvbnRlbnQgPSBtYWluTWFuaWZlc3RDb250ZW50O1xuXG4gICAgY29uc3QgcGxheWxpc3RzID0gcGFyc2VQbGF5bGlzdFVybHMobWFpbk1hbmlmZXN0Q29udGVudCk7XG4gICAgaWYgKHBsYXlsaXN0cy5sZW5ndGggPiAwKSB7ICAgIFxuICAgICAgY29uc3QgY2hvc2VuUGxheWxpc3RVcmwgPSBuZXcgVVJMKHBsYXlsaXN0c1swXSwgdXJsKS50b1N0cmluZygpO1xuICAgICAgYXZhaWxhYmxlQ2h1bmtzQ29udGVudCA9IGF3YWl0IChhd2FpdCBmZXRjaChjaG9zZW5QbGF5bGlzdFVybCkpLnRleHQoKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWdtZW50ID0gcGFyc2VTZWdtZW50KGF2YWlsYWJsZUNodW5rc0NvbnRlbnQpO1xuICAgIGNvbnN0IGZvcm1hdCA9IGdldEZvcm1hdChzZWdtZW50KTtcbiAgICByZXR1cm4gZm9ybWF0XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHdoaWxlIHRyeWluZyB0byBwYXJzZSB0aGUgbWFuaWZlc3QgcGxheWxpc3QnLCBlcnIpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/castable-video/castable-utils.js\n");

/***/ })

};
;