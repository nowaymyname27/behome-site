"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-refractor";
exports.ids = ["vendor-chunks/react-refractor"];
exports.modules = {

/***/ "(ssr)/../node_modules/react-refractor/dist/index.js":
/*!*****************************************************!*\
  !*** ../node_modules/react-refractor/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Refractor: () => (/* binding */ Refractor),\n/* harmony export */   hasLanguage: () => (/* binding */ hasLanguage),\n/* harmony export */   registerLanguage: () => (/* binding */ registerLanguage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/../node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var refractor_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! refractor/core */ \"(ssr)/../node_modules/refractor/lib/core.js\");\n/* harmony import */ var unist_util_filter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! unist-util-filter */ \"(ssr)/../node_modules/unist-util-filter/lib/index.js\");\n/* harmony import */ var unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! unist-util-visit-parents */ \"(ssr)/../node_modules/unist-util-visit-parents/lib/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/../node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n\n\nvar __defProp$2 = Object.defineProperty, __defProps$2 = Object.defineProperties, __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$2 = Object.getOwnPropertySymbols, __hasOwnProp$2 = Object.prototype.hasOwnProperty, __propIsEnum$2 = Object.prototype.propertyIsEnumerable, __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {}))\n    __hasOwnProp$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(b))\n      __propIsEnum$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);\n  return a;\n}, __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));\nfunction addMarkers(ast, options) {\n  const markers = options.markers.map((marker) => typeof marker == \"number\" ? { line: marker } : marker).sort((nodeA, nodeB) => nodeA.line - nodeB.line), numbered = lineNumberify(ast.children).nodes;\n  return markers.length === 0 || numbered.length === 0 ? __spreadProps$2(__spreadValues$2({}, ast), { children: numbered }) : wrapLines(numbered, markers, options);\n}\nfunction lineNumberify(ast, context = { lineNumber: 1 }) {\n  const resultNodes = [];\n  return ast.reduce(\n    (result, node) => {\n      if (node.type === \"doctype\")\n        return result;\n      const lineStart = context.lineNumber;\n      if (node.type === \"text\") {\n        if (node.value.indexOf(`\n`) === -1)\n          return setLineInfo(node, lineStart, lineStart), result.nodes.push(node), result;\n        const lines = node.value.split(`\n`);\n        for (let i = 0; i < lines.length; i++) {\n          const lineNum = i === 0 ? context.lineNumber : ++context.lineNumber, text = {\n            type: \"text\",\n            value: i === lines.length - 1 ? lines[i] : `${lines[i]}\n`\n          }, withLineInfo = setLineInfo(text, lineNum, lineNum);\n          result.nodes.push(withLineInfo);\n        }\n        return result.lineNumber = context.lineNumber, result;\n      }\n      if (node.type === \"element\" && node.children) {\n        const processed = lineNumberify(node.children, context), firstChild = processed.nodes.find(isElementOrText), lastChild = processed.nodes.findLast(isElementOrText);\n        return setLineInfo(\n          node,\n          firstChild ? getLineStart(firstChild, lineStart) : lineStart,\n          lastChild ? getLineEnd(lastChild, lineStart) : lineStart\n        ), node.children = processed.nodes, result.lineNumber = processed.lineNumber, result.nodes.push(node), result;\n      }\n      return result.nodes.push(node), result;\n    },\n    { nodes: resultNodes, lineNumber: context.lineNumber }\n  );\n}\nfunction isElementOrText(node) {\n  return node.type === \"element\" || node.type === \"text\";\n}\nfunction getLineStart(node, fallbackLineStart = 1) {\n  return node.data && typeof node.data.lineStart == \"number\" ? node.data.lineStart : fallbackLineStart;\n}\nfunction getLineEnd(node, fallbackLineEnd = 1) {\n  return node.data && typeof node.data.lineEnd == \"number\" ? node.data.lineEnd : fallbackLineEnd;\n}\nfunction setLineInfo(node, lineStart, lineEnd) {\n  return node.data || (node.data = {}), node.data.lineStart = lineStart, node.data.lineEnd = lineEnd, node;\n}\nfunction unwrapLine(markerLine, nodes) {\n  const tree = { type: \"root\", children: nodes }, headMap = /* @__PURE__ */ new WeakMap(), lineMap = /* @__PURE__ */ new WeakMap(), tailMap = /* @__PURE__ */ new WeakMap(), cloned = [];\n  function addCopy(map, node, ancestors) {\n    cloned.push(node), ancestors.forEach((ancestor) => {\n      map.has(ancestor) || (map.set(ancestor, Object.assign({}, ancestor, { children: [] })), ancestor !== tree && cloned.push(ancestor));\n    });\n    let i = ancestors.length;\n    for (; i--; ) {\n      const ancestor = map.get(ancestors[i]);\n      if (!ancestor || !(\"children\" in ancestor))\n        continue;\n      const child = ancestors[i + 1], leaf = map.get(child) || node;\n      ancestor.children.indexOf(leaf) === -1 && ancestor.children.push(leaf);\n    }\n  }\n  (0,unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_2__.visitParents)(tree, (node, ancestors) => {\n    if (!(\"children\" in node || !isElementOrText(node))) {\n      if (getLineStart(node) < markerLine) {\n        addCopy(headMap, node, ancestors);\n        return;\n      }\n      if (getLineStart(node) === markerLine) {\n        addCopy(lineMap, node, ancestors);\n        return;\n      }\n      getLineEnd(node) > markerLine && cloned.some((clone) => ancestors.includes(clone)) && addCopy(tailMap, node, ancestors);\n    }\n  });\n  const filtered = (0,unist_util_filter__WEBPACK_IMPORTED_MODULE_3__.filter)(tree, (node) => cloned.indexOf(node) === -1), getChildren = (map) => {\n    const rootNode = map.get(tree);\n    return rootNode ? ((0,unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_2__.visitParents)(rootNode, (leaf, ancestors) => {\n      if (isElementOrText(leaf) && \"children\" in leaf) {\n        setLineInfo(leaf, 0, 0);\n        return;\n      }\n      ancestors.forEach((ancestor) => {\n        setLineInfo(\n          ancestor,\n          Math.max(getLineStart(ancestor), getLineStart(leaf)),\n          Math.max(getLineEnd(ancestor), getLineEnd(leaf))\n        );\n      });\n    }), rootNode.children) : [];\n  };\n  return [\n    ...getChildren(headMap),\n    ...getChildren(lineMap),\n    ...getChildren(tailMap),\n    ...filtered ? filtered.children : []\n  ];\n}\nfunction wrapBatch(children, marker, options) {\n  const className = marker.className || \"refractor-marker\", baseData = {\n    lineStart: marker.line,\n    lineEnd: getLineEnd(children[children.length - 1]),\n    isMarker: !0\n  };\n  return {\n    type: \"element\",\n    tagName: \"div\",\n    data: marker.component ? __spreadProps$2(__spreadValues$2({}, baseData), { component: marker.component, markerProperties: options }) : baseData,\n    properties: { className },\n    children\n  };\n}\nfunction wrapLines(treeNodes, markers, options) {\n  const ast = markers.reduce(\n    (acc, marker) => unwrapLine(marker.line, acc),\n    treeNodes\n  ), wrapped = [];\n  let astIndex = 0;\n  for (let m = 0; m < markers.length; m++) {\n    const marker = markers[m];\n    for (let node = ast[astIndex]; node && getLineEnd(node) < marker.line; node = ast[++astIndex])\n      wrapped.push(node);\n    const batch = [];\n    for (let node = ast[astIndex]; node && getLineEnd(node) === marker.line; node = ast[++astIndex])\n      node.type !== \"doctype\" && batch.push(node);\n    batch.length > 0 && wrapped.push(wrapBatch(batch, marker, options));\n  }\n  for (; astIndex < ast.length; )\n    wrapped.push(ast[astIndex++]);\n  return { type: \"root\", children: wrapped };\n}\nvar __defProp$1 = Object.defineProperty, __defProps$1 = Object.defineProperties, __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    __hasOwnProp$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b))\n      __propIsEnum$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);\n  return a;\n}, __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\nfunction mapWithDepth(depth) {\n  return function(child, i) {\n    return mapChild(child, i, depth);\n  };\n}\nfunction mapChild(child, i, depth) {\n  if (child.type === \"doctype\")\n    return null;\n  if (!(\"tagName\" in child))\n    return child.value;\n  let className = \"\";\n  typeof child.properties < \"u\" && (className = Array.isArray(child.properties.className) ? child.properties.className.join(\" \") : `${child.properties.className}`);\n  const key = `fract-${depth}-${i}`, children = child.children && child.children.map(mapWithDepth(depth + 1));\n  return isReactRefractorMarkerDataWithComponent(child.data) ? (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(\n    child.data.component,\n    __spreadProps$1(__spreadValues$1(__spreadValues$1({ key }, child.properties), child.data.markerProperties), { className }),\n    children\n  ) : (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(child.tagName, { key, className }, children);\n}\nfunction isReactRefractorMarkerDataWithComponent(data) {\n  return typeof data == \"object\" && data !== null && \"component\" in data && \"markerProperties\" in data;\n}\nvar __defProp = Object.defineProperty, __defProps = Object.defineProperties, __getOwnPropDescs = Object.getOwnPropertyDescriptors, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    __hasOwnProp.call(b, prop) && __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b))\n      __propIsEnum.call(b, prop) && __defNormalProp(a, prop, b[prop]);\n  return a;\n}, __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst DEFAULT_CLASSNAME = \"refractor\";\nfunction Refractor(props) {\n  const className = props.className || DEFAULT_CLASSNAME, langClassName = `language-${props.language}`, codeProps = { className: langClassName }, preClass = [className, langClassName].filter(Boolean).join(\" \");\n  if (props.inline && (codeProps.style = { display: \"inline\" }, codeProps.className = className), props.plainText) {\n    const code2 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"code\", __spreadProps(__spreadValues({}, codeProps), { children: props.value }));\n    return props.inline ? code2 : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"pre\", { className: preClass, children: code2 });\n  }\n  let ast = refractor_core__WEBPACK_IMPORTED_MODULE_4__.refractor.highlight(props.value, props.language);\n  props.markers && props.markers.length > 0 && (ast = addMarkers(ast, { markers: props.markers }));\n  const value = ast.children.length === 0 ? props.value : ast.children.map(mapWithDepth(0)), code = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"code\", __spreadProps(__spreadValues({}, codeProps), { children: value }));\n  return props.inline ? code : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"pre\", { className: preClass, children: code });\n}\nconst registerLanguage = (lang) => refractor_core__WEBPACK_IMPORTED_MODULE_4__.refractor.register(lang), hasLanguage = (lang) => refractor_core__WEBPACK_IMPORTED_MODULE_4__.refractor.registered(lang);\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZnJhY3Rvci9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXdDO0FBQ0c7QUFDQTtBQUNhO0FBQ2xCO0FBQ3RDLHVYQUF1WCx1REFBdUQ7QUFDOWEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxnRkFBZ0YsZUFBZTtBQUMvRiw0RkFBNEYsVUFBVSxvQkFBb0I7QUFDMUg7QUFDQSx3Q0FBd0MsZUFBZTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsaUJBQWlCLCtCQUErQjtBQUNoRDtBQUNBO0FBQ0EsOERBQThELGNBQWMsY0FBYztBQUMxRixLQUFLO0FBQ0w7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLHNFQUFZO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxtQkFBbUIseURBQU07QUFDekI7QUFDQSx1QkFBdUIsc0VBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsZUFBZSx3REFBd0Q7QUFDdkksa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBLG1DQUFtQyx3Q0FBd0M7QUFDM0U7QUFDQTtBQUNBLG1DQUFtQywwQ0FBMEM7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsU0FBUyx1QkFBdUI7QUFDaEM7QUFDQSxXQUFXO0FBQ1g7QUFDQSx1WEFBdVgsdURBQXVEO0FBQzlhLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzSUFBc0ksMkJBQTJCO0FBQ2pLLHVCQUF1QixNQUFNLEdBQUcsRUFBRTtBQUNsQywrREFBK0Qsb0RBQWE7QUFDNUU7QUFDQSx3REFBd0QsS0FBSyxxREFBcUQsV0FBVztBQUM3SDtBQUNBLE1BQU0sb0RBQWEsa0JBQWtCLGdCQUFnQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVXQUF1Vyx1REFBdUQ7QUFDOVosK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLHNGQUFzRixlQUFlLGlCQUFpQiwwQkFBMEI7QUFDaEosMkNBQTJDLG1CQUFtQjtBQUM5RCxrQ0FBa0Msc0RBQUcsd0NBQXdDLGdCQUFnQix1QkFBdUI7QUFDcEgsa0RBQWtELHNEQUFHLFVBQVUsc0NBQXNDO0FBQ3JHO0FBQ0EsWUFBWSxxREFBUztBQUNyQix3RUFBd0Usd0JBQXdCO0FBQ2hHLG9IQUFvSCxzREFBRyx3Q0FBd0MsZ0JBQWdCLGlCQUFpQjtBQUNoTSwrQ0FBK0Msc0RBQUcsVUFBVSxxQ0FBcUM7QUFDakc7QUFDQSxtQ0FBbUMscURBQVMseUNBQXlDLHFEQUFTO0FBSzVGO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9HYWxvY2svQ1MvYmVob21lLXNpdGUvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZnJhY3Rvci9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgcmVmcmFjdG9yIH0gZnJvbSBcInJlZnJhY3Rvci9jb3JlXCI7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tIFwidW5pc3QtdXRpbC1maWx0ZXJcIjtcbmltcG9ydCB7IHZpc2l0UGFyZW50cyB9IGZyb20gXCJ1bmlzdC11dGlsLXZpc2l0LXBhcmVudHNcIjtcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBfX2RlZlByb3AkMiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgX19kZWZQcm9wcyQyID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMsIF9fZ2V0T3duUHJvcERlc2NzJDIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycywgX19nZXRPd25Qcm9wU3ltYm9scyQyID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgX19oYXNPd25Qcm9wJDIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBfX3Byb3BJc0VudW0kMiA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUsIF9fZGVmTm9ybWFsUHJvcCQyID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQyKG9iaiwga2V5LCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZSwgX19zcHJlYWRWYWx1ZXMkMiA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBfX2hhc093blByb3AkMi5jYWxsKGIsIHByb3ApICYmIF9fZGVmTm9ybWFsUHJvcCQyKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scyQyKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyQyKGIpKVxuICAgICAgX19wcm9wSXNFbnVtJDIuY2FsbChiLCBwcm9wKSAmJiBfX2RlZk5vcm1hbFByb3AkMihhLCBwcm9wLCBiW3Byb3BdKTtcbiAgcmV0dXJuIGE7XG59LCBfX3NwcmVhZFByb3BzJDIgPSAoYSwgYikgPT4gX19kZWZQcm9wcyQyKGEsIF9fZ2V0T3duUHJvcERlc2NzJDIoYikpO1xuZnVuY3Rpb24gYWRkTWFya2Vycyhhc3QsIG9wdGlvbnMpIHtcbiAgY29uc3QgbWFya2VycyA9IG9wdGlvbnMubWFya2Vycy5tYXAoKG1hcmtlcikgPT4gdHlwZW9mIG1hcmtlciA9PSBcIm51bWJlclwiID8geyBsaW5lOiBtYXJrZXIgfSA6IG1hcmtlcikuc29ydCgobm9kZUEsIG5vZGVCKSA9PiBub2RlQS5saW5lIC0gbm9kZUIubGluZSksIG51bWJlcmVkID0gbGluZU51bWJlcmlmeShhc3QuY2hpbGRyZW4pLm5vZGVzO1xuICByZXR1cm4gbWFya2Vycy5sZW5ndGggPT09IDAgfHwgbnVtYmVyZWQubGVuZ3RoID09PSAwID8gX19zcHJlYWRQcm9wcyQyKF9fc3ByZWFkVmFsdWVzJDIoe30sIGFzdCksIHsgY2hpbGRyZW46IG51bWJlcmVkIH0pIDogd3JhcExpbmVzKG51bWJlcmVkLCBtYXJrZXJzLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGxpbmVOdW1iZXJpZnkoYXN0LCBjb250ZXh0ID0geyBsaW5lTnVtYmVyOiAxIH0pIHtcbiAgY29uc3QgcmVzdWx0Tm9kZXMgPSBbXTtcbiAgcmV0dXJuIGFzdC5yZWR1Y2UoXG4gICAgKHJlc3VsdCwgbm9kZSkgPT4ge1xuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJkb2N0eXBlXCIpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICBjb25zdCBsaW5lU3RhcnQgPSBjb250ZXh0LmxpbmVOdW1iZXI7XG4gICAgICBpZiAobm9kZS50eXBlID09PSBcInRleHRcIikge1xuICAgICAgICBpZiAobm9kZS52YWx1ZS5pbmRleE9mKGBcbmApID09PSAtMSlcbiAgICAgICAgICByZXR1cm4gc2V0TGluZUluZm8obm9kZSwgbGluZVN0YXJ0LCBsaW5lU3RhcnQpLCByZXN1bHQubm9kZXMucHVzaChub2RlKSwgcmVzdWx0O1xuICAgICAgICBjb25zdCBsaW5lcyA9IG5vZGUudmFsdWUuc3BsaXQoYFxuYCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBsaW5lTnVtID0gaSA9PT0gMCA/IGNvbnRleHQubGluZU51bWJlciA6ICsrY29udGV4dC5saW5lTnVtYmVyLCB0ZXh0ID0ge1xuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICB2YWx1ZTogaSA9PT0gbGluZXMubGVuZ3RoIC0gMSA/IGxpbmVzW2ldIDogYCR7bGluZXNbaV19XG5gXG4gICAgICAgICAgfSwgd2l0aExpbmVJbmZvID0gc2V0TGluZUluZm8odGV4dCwgbGluZU51bSwgbGluZU51bSk7XG4gICAgICAgICAgcmVzdWx0Lm5vZGVzLnB1c2god2l0aExpbmVJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmxpbmVOdW1iZXIgPSBjb250ZXh0LmxpbmVOdW1iZXIsIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiZWxlbWVudFwiICYmIG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gbGluZU51bWJlcmlmeShub2RlLmNoaWxkcmVuLCBjb250ZXh0KSwgZmlyc3RDaGlsZCA9IHByb2Nlc3NlZC5ub2Rlcy5maW5kKGlzRWxlbWVudE9yVGV4dCksIGxhc3RDaGlsZCA9IHByb2Nlc3NlZC5ub2Rlcy5maW5kTGFzdChpc0VsZW1lbnRPclRleHQpO1xuICAgICAgICByZXR1cm4gc2V0TGluZUluZm8oXG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBmaXJzdENoaWxkID8gZ2V0TGluZVN0YXJ0KGZpcnN0Q2hpbGQsIGxpbmVTdGFydCkgOiBsaW5lU3RhcnQsXG4gICAgICAgICAgbGFzdENoaWxkID8gZ2V0TGluZUVuZChsYXN0Q2hpbGQsIGxpbmVTdGFydCkgOiBsaW5lU3RhcnRcbiAgICAgICAgKSwgbm9kZS5jaGlsZHJlbiA9IHByb2Nlc3NlZC5ub2RlcywgcmVzdWx0LmxpbmVOdW1iZXIgPSBwcm9jZXNzZWQubGluZU51bWJlciwgcmVzdWx0Lm5vZGVzLnB1c2gobm9kZSksIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQubm9kZXMucHVzaChub2RlKSwgcmVzdWx0O1xuICAgIH0sXG4gICAgeyBub2RlczogcmVzdWx0Tm9kZXMsIGxpbmVOdW1iZXI6IGNvbnRleHQubGluZU51bWJlciB9XG4gICk7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnRPclRleHQobm9kZSkge1xuICByZXR1cm4gbm9kZS50eXBlID09PSBcImVsZW1lbnRcIiB8fCBub2RlLnR5cGUgPT09IFwidGV4dFwiO1xufVxuZnVuY3Rpb24gZ2V0TGluZVN0YXJ0KG5vZGUsIGZhbGxiYWNrTGluZVN0YXJ0ID0gMSkge1xuICByZXR1cm4gbm9kZS5kYXRhICYmIHR5cGVvZiBub2RlLmRhdGEubGluZVN0YXJ0ID09IFwibnVtYmVyXCIgPyBub2RlLmRhdGEubGluZVN0YXJ0IDogZmFsbGJhY2tMaW5lU3RhcnQ7XG59XG5mdW5jdGlvbiBnZXRMaW5lRW5kKG5vZGUsIGZhbGxiYWNrTGluZUVuZCA9IDEpIHtcbiAgcmV0dXJuIG5vZGUuZGF0YSAmJiB0eXBlb2Ygbm9kZS5kYXRhLmxpbmVFbmQgPT0gXCJudW1iZXJcIiA/IG5vZGUuZGF0YS5saW5lRW5kIDogZmFsbGJhY2tMaW5lRW5kO1xufVxuZnVuY3Rpb24gc2V0TGluZUluZm8obm9kZSwgbGluZVN0YXJ0LCBsaW5lRW5kKSB7XG4gIHJldHVybiBub2RlLmRhdGEgfHwgKG5vZGUuZGF0YSA9IHt9KSwgbm9kZS5kYXRhLmxpbmVTdGFydCA9IGxpbmVTdGFydCwgbm9kZS5kYXRhLmxpbmVFbmQgPSBsaW5lRW5kLCBub2RlO1xufVxuZnVuY3Rpb24gdW53cmFwTGluZShtYXJrZXJMaW5lLCBub2Rlcykge1xuICBjb25zdCB0cmVlID0geyB0eXBlOiBcInJvb3RcIiwgY2hpbGRyZW46IG5vZGVzIH0sIGhlYWRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgbGluZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCB0YWlsTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIGNsb25lZCA9IFtdO1xuICBmdW5jdGlvbiBhZGRDb3B5KG1hcCwgbm9kZSwgYW5jZXN0b3JzKSB7XG4gICAgY2xvbmVkLnB1c2gobm9kZSksIGFuY2VzdG9ycy5mb3JFYWNoKChhbmNlc3RvcikgPT4ge1xuICAgICAgbWFwLmhhcyhhbmNlc3RvcikgfHwgKG1hcC5zZXQoYW5jZXN0b3IsIE9iamVjdC5hc3NpZ24oe30sIGFuY2VzdG9yLCB7IGNoaWxkcmVuOiBbXSB9KSksIGFuY2VzdG9yICE9PSB0cmVlICYmIGNsb25lZC5wdXNoKGFuY2VzdG9yKSk7XG4gICAgfSk7XG4gICAgbGV0IGkgPSBhbmNlc3RvcnMubGVuZ3RoO1xuICAgIGZvciAoOyBpLS07ICkge1xuICAgICAgY29uc3QgYW5jZXN0b3IgPSBtYXAuZ2V0KGFuY2VzdG9yc1tpXSk7XG4gICAgICBpZiAoIWFuY2VzdG9yIHx8ICEoXCJjaGlsZHJlblwiIGluIGFuY2VzdG9yKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBjaGlsZCA9IGFuY2VzdG9yc1tpICsgMV0sIGxlYWYgPSBtYXAuZ2V0KGNoaWxkKSB8fCBub2RlO1xuICAgICAgYW5jZXN0b3IuY2hpbGRyZW4uaW5kZXhPZihsZWFmKSA9PT0gLTEgJiYgYW5jZXN0b3IuY2hpbGRyZW4ucHVzaChsZWFmKTtcbiAgICB9XG4gIH1cbiAgdmlzaXRQYXJlbnRzKHRyZWUsIChub2RlLCBhbmNlc3RvcnMpID0+IHtcbiAgICBpZiAoIShcImNoaWxkcmVuXCIgaW4gbm9kZSB8fCAhaXNFbGVtZW50T3JUZXh0KG5vZGUpKSkge1xuICAgICAgaWYgKGdldExpbmVTdGFydChub2RlKSA8IG1hcmtlckxpbmUpIHtcbiAgICAgICAgYWRkQ29weShoZWFkTWFwLCBub2RlLCBhbmNlc3RvcnMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZ2V0TGluZVN0YXJ0KG5vZGUpID09PSBtYXJrZXJMaW5lKSB7XG4gICAgICAgIGFkZENvcHkobGluZU1hcCwgbm9kZSwgYW5jZXN0b3JzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZ2V0TGluZUVuZChub2RlKSA+IG1hcmtlckxpbmUgJiYgY2xvbmVkLnNvbWUoKGNsb25lKSA9PiBhbmNlc3RvcnMuaW5jbHVkZXMoY2xvbmUpKSAmJiBhZGRDb3B5KHRhaWxNYXAsIG5vZGUsIGFuY2VzdG9ycyk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgZmlsdGVyZWQgPSBmaWx0ZXIodHJlZSwgKG5vZGUpID0+IGNsb25lZC5pbmRleE9mKG5vZGUpID09PSAtMSksIGdldENoaWxkcmVuID0gKG1hcCkgPT4ge1xuICAgIGNvbnN0IHJvb3ROb2RlID0gbWFwLmdldCh0cmVlKTtcbiAgICByZXR1cm4gcm9vdE5vZGUgPyAodmlzaXRQYXJlbnRzKHJvb3ROb2RlLCAobGVhZiwgYW5jZXN0b3JzKSA9PiB7XG4gICAgICBpZiAoaXNFbGVtZW50T3JUZXh0KGxlYWYpICYmIFwiY2hpbGRyZW5cIiBpbiBsZWFmKSB7XG4gICAgICAgIHNldExpbmVJbmZvKGxlYWYsIDAsIDApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhbmNlc3RvcnMuZm9yRWFjaCgoYW5jZXN0b3IpID0+IHtcbiAgICAgICAgc2V0TGluZUluZm8oXG4gICAgICAgICAgYW5jZXN0b3IsXG4gICAgICAgICAgTWF0aC5tYXgoZ2V0TGluZVN0YXJ0KGFuY2VzdG9yKSwgZ2V0TGluZVN0YXJ0KGxlYWYpKSxcbiAgICAgICAgICBNYXRoLm1heChnZXRMaW5lRW5kKGFuY2VzdG9yKSwgZ2V0TGluZUVuZChsZWFmKSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pLCByb290Tm9kZS5jaGlsZHJlbikgOiBbXTtcbiAgfTtcbiAgcmV0dXJuIFtcbiAgICAuLi5nZXRDaGlsZHJlbihoZWFkTWFwKSxcbiAgICAuLi5nZXRDaGlsZHJlbihsaW5lTWFwKSxcbiAgICAuLi5nZXRDaGlsZHJlbih0YWlsTWFwKSxcbiAgICAuLi5maWx0ZXJlZCA/IGZpbHRlcmVkLmNoaWxkcmVuIDogW11cbiAgXTtcbn1cbmZ1bmN0aW9uIHdyYXBCYXRjaChjaGlsZHJlbiwgbWFya2VyLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNsYXNzTmFtZSA9IG1hcmtlci5jbGFzc05hbWUgfHwgXCJyZWZyYWN0b3ItbWFya2VyXCIsIGJhc2VEYXRhID0ge1xuICAgIGxpbmVTdGFydDogbWFya2VyLmxpbmUsXG4gICAgbGluZUVuZDogZ2V0TGluZUVuZChjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXSksXG4gICAgaXNNYXJrZXI6ICEwXG4gIH07XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgdGFnTmFtZTogXCJkaXZcIixcbiAgICBkYXRhOiBtYXJrZXIuY29tcG9uZW50ID8gX19zcHJlYWRQcm9wcyQyKF9fc3ByZWFkVmFsdWVzJDIoe30sIGJhc2VEYXRhKSwgeyBjb21wb25lbnQ6IG1hcmtlci5jb21wb25lbnQsIG1hcmtlclByb3BlcnRpZXM6IG9wdGlvbnMgfSkgOiBiYXNlRGF0YSxcbiAgICBwcm9wZXJ0aWVzOiB7IGNsYXNzTmFtZSB9LFxuICAgIGNoaWxkcmVuXG4gIH07XG59XG5mdW5jdGlvbiB3cmFwTGluZXModHJlZU5vZGVzLCBtYXJrZXJzLCBvcHRpb25zKSB7XG4gIGNvbnN0IGFzdCA9IG1hcmtlcnMucmVkdWNlKFxuICAgIChhY2MsIG1hcmtlcikgPT4gdW53cmFwTGluZShtYXJrZXIubGluZSwgYWNjKSxcbiAgICB0cmVlTm9kZXNcbiAgKSwgd3JhcHBlZCA9IFtdO1xuICBsZXQgYXN0SW5kZXggPSAwO1xuICBmb3IgKGxldCBtID0gMDsgbSA8IG1hcmtlcnMubGVuZ3RoOyBtKyspIHtcbiAgICBjb25zdCBtYXJrZXIgPSBtYXJrZXJzW21dO1xuICAgIGZvciAobGV0IG5vZGUgPSBhc3RbYXN0SW5kZXhdOyBub2RlICYmIGdldExpbmVFbmQobm9kZSkgPCBtYXJrZXIubGluZTsgbm9kZSA9IGFzdFsrK2FzdEluZGV4XSlcbiAgICAgIHdyYXBwZWQucHVzaChub2RlKTtcbiAgICBjb25zdCBiYXRjaCA9IFtdO1xuICAgIGZvciAobGV0IG5vZGUgPSBhc3RbYXN0SW5kZXhdOyBub2RlICYmIGdldExpbmVFbmQobm9kZSkgPT09IG1hcmtlci5saW5lOyBub2RlID0gYXN0WysrYXN0SW5kZXhdKVxuICAgICAgbm9kZS50eXBlICE9PSBcImRvY3R5cGVcIiAmJiBiYXRjaC5wdXNoKG5vZGUpO1xuICAgIGJhdGNoLmxlbmd0aCA+IDAgJiYgd3JhcHBlZC5wdXNoKHdyYXBCYXRjaChiYXRjaCwgbWFya2VyLCBvcHRpb25zKSk7XG4gIH1cbiAgZm9yICg7IGFzdEluZGV4IDwgYXN0Lmxlbmd0aDsgKVxuICAgIHdyYXBwZWQucHVzaChhc3RbYXN0SW5kZXgrK10pO1xuICByZXR1cm4geyB0eXBlOiBcInJvb3RcIiwgY2hpbGRyZW46IHdyYXBwZWQgfTtcbn1cbnZhciBfX2RlZlByb3AkMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgX19kZWZQcm9wcyQxID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMsIF9fZ2V0T3duUHJvcERlc2NzJDEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycywgX19nZXRPd25Qcm9wU3ltYm9scyQxID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgX19oYXNPd25Qcm9wJDEgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBfX3Byb3BJc0VudW0kMSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUsIF9fZGVmTm9ybWFsUHJvcCQxID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQxKG9iaiwga2V5LCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZSwgX19zcHJlYWRWYWx1ZXMkMSA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBfX2hhc093blByb3AkMS5jYWxsKGIsIHByb3ApICYmIF9fZGVmTm9ybWFsUHJvcCQxKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scyQxKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyQxKGIpKVxuICAgICAgX19wcm9wSXNFbnVtJDEuY2FsbChiLCBwcm9wKSAmJiBfX2RlZk5vcm1hbFByb3AkMShhLCBwcm9wLCBiW3Byb3BdKTtcbiAgcmV0dXJuIGE7XG59LCBfX3NwcmVhZFByb3BzJDEgPSAoYSwgYikgPT4gX19kZWZQcm9wcyQxKGEsIF9fZ2V0T3duUHJvcERlc2NzJDEoYikpO1xuZnVuY3Rpb24gbWFwV2l0aERlcHRoKGRlcHRoKSB7XG4gIHJldHVybiBmdW5jdGlvbihjaGlsZCwgaSkge1xuICAgIHJldHVybiBtYXBDaGlsZChjaGlsZCwgaSwgZGVwdGgpO1xuICB9O1xufVxuZnVuY3Rpb24gbWFwQ2hpbGQoY2hpbGQsIGksIGRlcHRoKSB7XG4gIGlmIChjaGlsZC50eXBlID09PSBcImRvY3R5cGVcIilcbiAgICByZXR1cm4gbnVsbDtcbiAgaWYgKCEoXCJ0YWdOYW1lXCIgaW4gY2hpbGQpKVxuICAgIHJldHVybiBjaGlsZC52YWx1ZTtcbiAgbGV0IGNsYXNzTmFtZSA9IFwiXCI7XG4gIHR5cGVvZiBjaGlsZC5wcm9wZXJ0aWVzIDwgXCJ1XCIgJiYgKGNsYXNzTmFtZSA9IEFycmF5LmlzQXJyYXkoY2hpbGQucHJvcGVydGllcy5jbGFzc05hbWUpID8gY2hpbGQucHJvcGVydGllcy5jbGFzc05hbWUuam9pbihcIiBcIikgOiBgJHtjaGlsZC5wcm9wZXJ0aWVzLmNsYXNzTmFtZX1gKTtcbiAgY29uc3Qga2V5ID0gYGZyYWN0LSR7ZGVwdGh9LSR7aX1gLCBjaGlsZHJlbiA9IGNoaWxkLmNoaWxkcmVuICYmIGNoaWxkLmNoaWxkcmVuLm1hcChtYXBXaXRoRGVwdGgoZGVwdGggKyAxKSk7XG4gIHJldHVybiBpc1JlYWN0UmVmcmFjdG9yTWFya2VyRGF0YVdpdGhDb21wb25lbnQoY2hpbGQuZGF0YSkgPyBjcmVhdGVFbGVtZW50KFxuICAgIGNoaWxkLmRhdGEuY29tcG9uZW50LFxuICAgIF9fc3ByZWFkUHJvcHMkMShfX3NwcmVhZFZhbHVlcyQxKF9fc3ByZWFkVmFsdWVzJDEoeyBrZXkgfSwgY2hpbGQucHJvcGVydGllcyksIGNoaWxkLmRhdGEubWFya2VyUHJvcGVydGllcyksIHsgY2xhc3NOYW1lIH0pLFxuICAgIGNoaWxkcmVuXG4gICkgOiBjcmVhdGVFbGVtZW50KGNoaWxkLnRhZ05hbWUsIHsga2V5LCBjbGFzc05hbWUgfSwgY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gaXNSZWFjdFJlZnJhY3Rvck1hcmtlckRhdGFXaXRoQ29tcG9uZW50KGRhdGEpIHtcbiAgcmV0dXJuIHR5cGVvZiBkYXRhID09IFwib2JqZWN0XCIgJiYgZGF0YSAhPT0gbnVsbCAmJiBcImNvbXBvbmVudFwiIGluIGRhdGEgJiYgXCJtYXJrZXJQcm9wZXJ0aWVzXCIgaW4gZGF0YTtcbn1cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcywgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycywgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUsIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlLCBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSAmJiBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSlcbiAgICAgIF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApICYmIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgcmV0dXJuIGE7XG59LCBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xuY29uc3QgREVGQVVMVF9DTEFTU05BTUUgPSBcInJlZnJhY3RvclwiO1xuZnVuY3Rpb24gUmVmcmFjdG9yKHByb3BzKSB7XG4gIGNvbnN0IGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSB8fCBERUZBVUxUX0NMQVNTTkFNRSwgbGFuZ0NsYXNzTmFtZSA9IGBsYW5ndWFnZS0ke3Byb3BzLmxhbmd1YWdlfWAsIGNvZGVQcm9wcyA9IHsgY2xhc3NOYW1lOiBsYW5nQ2xhc3NOYW1lIH0sIHByZUNsYXNzID0gW2NsYXNzTmFtZSwgbGFuZ0NsYXNzTmFtZV0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpO1xuICBpZiAocHJvcHMuaW5saW5lICYmIChjb2RlUHJvcHMuc3R5bGUgPSB7IGRpc3BsYXk6IFwiaW5saW5lXCIgfSwgY29kZVByb3BzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZSksIHByb3BzLnBsYWluVGV4dCkge1xuICAgIGNvbnN0IGNvZGUyID0gLyogQF9fUFVSRV9fICovIGpzeChcImNvZGVcIiwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgY29kZVByb3BzKSwgeyBjaGlsZHJlbjogcHJvcHMudmFsdWUgfSkpO1xuICAgIHJldHVybiBwcm9wcy5pbmxpbmUgPyBjb2RlMiA6IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJwcmVcIiwgeyBjbGFzc05hbWU6IHByZUNsYXNzLCBjaGlsZHJlbjogY29kZTIgfSk7XG4gIH1cbiAgbGV0IGFzdCA9IHJlZnJhY3Rvci5oaWdobGlnaHQocHJvcHMudmFsdWUsIHByb3BzLmxhbmd1YWdlKTtcbiAgcHJvcHMubWFya2VycyAmJiBwcm9wcy5tYXJrZXJzLmxlbmd0aCA+IDAgJiYgKGFzdCA9IGFkZE1hcmtlcnMoYXN0LCB7IG1hcmtlcnM6IHByb3BzLm1hcmtlcnMgfSkpO1xuICBjb25zdCB2YWx1ZSA9IGFzdC5jaGlsZHJlbi5sZW5ndGggPT09IDAgPyBwcm9wcy52YWx1ZSA6IGFzdC5jaGlsZHJlbi5tYXAobWFwV2l0aERlcHRoKDApKSwgY29kZSA9IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJjb2RlXCIsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGNvZGVQcm9wcyksIHsgY2hpbGRyZW46IHZhbHVlIH0pKTtcbiAgcmV0dXJuIHByb3BzLmlubGluZSA/IGNvZGUgOiAvKiBAX19QVVJFX18gKi8ganN4KFwicHJlXCIsIHsgY2xhc3NOYW1lOiBwcmVDbGFzcywgY2hpbGRyZW46IGNvZGUgfSk7XG59XG5jb25zdCByZWdpc3Rlckxhbmd1YWdlID0gKGxhbmcpID0+IHJlZnJhY3Rvci5yZWdpc3RlcihsYW5nKSwgaGFzTGFuZ3VhZ2UgPSAobGFuZykgPT4gcmVmcmFjdG9yLnJlZ2lzdGVyZWQobGFuZyk7XG5leHBvcnQge1xuICBSZWZyYWN0b3IsXG4gIGhhc0xhbmd1YWdlLFxuICByZWdpc3Rlckxhbmd1YWdlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/react-refractor/dist/index.js\n");

/***/ })

};
;