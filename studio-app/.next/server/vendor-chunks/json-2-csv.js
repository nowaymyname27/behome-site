"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/json-2-csv";
exports.ids = ["vendor-chunks/json-2-csv"];
exports.modules = {

/***/ "(ssr)/../node_modules/json-2-csv/lib/constants.js":
/*!***************************************************!*\
  !*** ../node_modules/json-2-csv/lib/constants.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.excelBOM = exports.defaultCsv2JsonOptions = exports.defaultJson2CsvOptions = exports.errors = void 0;\nexports.errors = {\n    optionsRequired: 'Options were not passed and are required.',\n    json2csv: {\n        cannotCallOn: 'Cannot call json2csv on',\n        dataCheckFailure: 'Data provided was not an array of documents.',\n        notSameSchema: 'Not all documents have the same schema.'\n    },\n    csv2json: {\n        cannotCallOn: 'Cannot call csv2json on',\n        dataCheckFailure: 'CSV is not a string.'\n    }\n};\nexports.defaultJson2CsvOptions = {\n    arrayIndexesAsKeys: false,\n    checkSchemaDifferences: false,\n    delimiter: {\n        field: ',',\n        wrap: '\"',\n        eol: '\\n'\n    },\n    emptyFieldValue: undefined,\n    escapeHeaderNestedDots: true,\n    excelBOM: false,\n    excludeKeys: [],\n    expandNestedObjects: true,\n    expandArrayObjects: false,\n    prependHeader: true,\n    preventCsvInjection: false,\n    sortHeader: false,\n    trimFieldValues: false,\n    trimHeaderFields: false,\n    unwindArrays: false,\n    useDateIso8601Format: false,\n    useLocaleFormat: false,\n    wrapBooleans: false,\n};\nexports.defaultCsv2JsonOptions = {\n    delimiter: {\n        field: ',',\n        wrap: '\"',\n        eol: '\\n'\n    },\n    excelBOM: false,\n    preventCsvInjection: false,\n    trimFieldValues: false,\n    trimHeaderFields: false,\n};\nexports.excelBOM = '\\ufeff';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2pzb24tMi1jc3YvbGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyw4QkFBOEIsR0FBRyw4QkFBOEIsR0FBRyxjQUFjO0FBQ25HLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9HYWxvY2svQ1MvYmVob21lLXNpdGUvbm9kZV9tb2R1bGVzL2pzb24tMi1jc3YvbGliL2NvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4Y2VsQk9NID0gZXhwb3J0cy5kZWZhdWx0Q3N2Mkpzb25PcHRpb25zID0gZXhwb3J0cy5kZWZhdWx0SnNvbjJDc3ZPcHRpb25zID0gZXhwb3J0cy5lcnJvcnMgPSB2b2lkIDA7XG5leHBvcnRzLmVycm9ycyA9IHtcbiAgICBvcHRpb25zUmVxdWlyZWQ6ICdPcHRpb25zIHdlcmUgbm90IHBhc3NlZCBhbmQgYXJlIHJlcXVpcmVkLicsXG4gICAganNvbjJjc3Y6IHtcbiAgICAgICAgY2Fubm90Q2FsbE9uOiAnQ2Fubm90IGNhbGwganNvbjJjc3Ygb24nLFxuICAgICAgICBkYXRhQ2hlY2tGYWlsdXJlOiAnRGF0YSBwcm92aWRlZCB3YXMgbm90IGFuIGFycmF5IG9mIGRvY3VtZW50cy4nLFxuICAgICAgICBub3RTYW1lU2NoZW1hOiAnTm90IGFsbCBkb2N1bWVudHMgaGF2ZSB0aGUgc2FtZSBzY2hlbWEuJ1xuICAgIH0sXG4gICAgY3N2Mmpzb246IHtcbiAgICAgICAgY2Fubm90Q2FsbE9uOiAnQ2Fubm90IGNhbGwgY3N2Mmpzb24gb24nLFxuICAgICAgICBkYXRhQ2hlY2tGYWlsdXJlOiAnQ1NWIGlzIG5vdCBhIHN0cmluZy4nXG4gICAgfVxufTtcbmV4cG9ydHMuZGVmYXVsdEpzb24yQ3N2T3B0aW9ucyA9IHtcbiAgICBhcnJheUluZGV4ZXNBc0tleXM6IGZhbHNlLFxuICAgIGNoZWNrU2NoZW1hRGlmZmVyZW5jZXM6IGZhbHNlLFxuICAgIGRlbGltaXRlcjoge1xuICAgICAgICBmaWVsZDogJywnLFxuICAgICAgICB3cmFwOiAnXCInLFxuICAgICAgICBlb2w6ICdcXG4nXG4gICAgfSxcbiAgICBlbXB0eUZpZWxkVmFsdWU6IHVuZGVmaW5lZCxcbiAgICBlc2NhcGVIZWFkZXJOZXN0ZWREb3RzOiB0cnVlLFxuICAgIGV4Y2VsQk9NOiBmYWxzZSxcbiAgICBleGNsdWRlS2V5czogW10sXG4gICAgZXhwYW5kTmVzdGVkT2JqZWN0czogdHJ1ZSxcbiAgICBleHBhbmRBcnJheU9iamVjdHM6IGZhbHNlLFxuICAgIHByZXBlbmRIZWFkZXI6IHRydWUsXG4gICAgcHJldmVudENzdkluamVjdGlvbjogZmFsc2UsXG4gICAgc29ydEhlYWRlcjogZmFsc2UsXG4gICAgdHJpbUZpZWxkVmFsdWVzOiBmYWxzZSxcbiAgICB0cmltSGVhZGVyRmllbGRzOiBmYWxzZSxcbiAgICB1bndpbmRBcnJheXM6IGZhbHNlLFxuICAgIHVzZURhdGVJc284NjAxRm9ybWF0OiBmYWxzZSxcbiAgICB1c2VMb2NhbGVGb3JtYXQ6IGZhbHNlLFxuICAgIHdyYXBCb29sZWFuczogZmFsc2UsXG59O1xuZXhwb3J0cy5kZWZhdWx0Q3N2Mkpzb25PcHRpb25zID0ge1xuICAgIGRlbGltaXRlcjoge1xuICAgICAgICBmaWVsZDogJywnLFxuICAgICAgICB3cmFwOiAnXCInLFxuICAgICAgICBlb2w6ICdcXG4nXG4gICAgfSxcbiAgICBleGNlbEJPTTogZmFsc2UsXG4gICAgcHJldmVudENzdkluamVjdGlvbjogZmFsc2UsXG4gICAgdHJpbUZpZWxkVmFsdWVzOiBmYWxzZSxcbiAgICB0cmltSGVhZGVyRmllbGRzOiBmYWxzZSxcbn07XG5leHBvcnRzLmV4Y2VsQk9NID0gJ1xcdWZlZmYnO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/json-2-csv/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/json-2-csv/lib/converter.js":
/*!***************************************************!*\
  !*** ../node_modules/json-2-csv/lib/converter.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.csv2json = exports.json2csv = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/../node_modules/json-2-csv/lib/constants.js\");\nconst json2csv_1 = __webpack_require__(/*! ./json2csv */ \"(ssr)/../node_modules/json-2-csv/lib/json2csv.js\");\nconst csv2json_1 = __webpack_require__(/*! ./csv2json */ \"(ssr)/../node_modules/json-2-csv/lib/csv2json.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/../node_modules/json-2-csv/lib/utils.js\");\nfunction json2csv(data, options) {\n    const builtOptions = (0, utils_1.buildJ2COptions)(options ?? {});\n    // Validate the parameters before calling the converter's convert function\n    (0, utils_1.validate)(data, utils_1.isObject, constants_1.errors.json2csv);\n    return (0, json2csv_1.Json2Csv)(builtOptions).convert(data);\n}\nexports.json2csv = json2csv;\nfunction csv2json(data, options) {\n    const builtOptions = (0, utils_1.buildC2JOptions)(options ?? {});\n    // Validate the parameters before calling the converter's convert function\n    (0, utils_1.validate)(data, utils_1.isString, constants_1.errors.csv2json);\n    return (0, csv2json_1.Csv2Json)(builtOptions).convert(data);\n}\nexports.csv2json = csv2json;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2pzb24tMi1jc3YvbGliL2NvbnZlcnRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyxnQkFBZ0I7QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMsc0VBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsb0VBQVk7QUFDdkMsbUJBQW1CLG1CQUFPLENBQUMsb0VBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsOERBQVM7QUFDakM7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9HYWxvY2svQ1MvYmVob21lLXNpdGUvbm9kZV9tb2R1bGVzL2pzb24tMi1jc3YvbGliL2NvbnZlcnRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNzdjJqc29uID0gZXhwb3J0cy5qc29uMmNzdiA9IHZvaWQgMDtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QganNvbjJjc3ZfMSA9IHJlcXVpcmUoXCIuL2pzb24yY3N2XCIpO1xuY29uc3QgY3N2Mmpzb25fMSA9IHJlcXVpcmUoXCIuL2NzdjJqc29uXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZnVuY3Rpb24ganNvbjJjc3YoZGF0YSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGJ1aWx0T3B0aW9ucyA9ICgwLCB1dGlsc18xLmJ1aWxkSjJDT3B0aW9ucykob3B0aW9ucyA/PyB7fSk7XG4gICAgLy8gVmFsaWRhdGUgdGhlIHBhcmFtZXRlcnMgYmVmb3JlIGNhbGxpbmcgdGhlIGNvbnZlcnRlcidzIGNvbnZlcnQgZnVuY3Rpb25cbiAgICAoMCwgdXRpbHNfMS52YWxpZGF0ZSkoZGF0YSwgdXRpbHNfMS5pc09iamVjdCwgY29uc3RhbnRzXzEuZXJyb3JzLmpzb24yY3N2KTtcbiAgICByZXR1cm4gKDAsIGpzb24yY3N2XzEuSnNvbjJDc3YpKGJ1aWx0T3B0aW9ucykuY29udmVydChkYXRhKTtcbn1cbmV4cG9ydHMuanNvbjJjc3YgPSBqc29uMmNzdjtcbmZ1bmN0aW9uIGNzdjJqc29uKGRhdGEsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBidWlsdE9wdGlvbnMgPSAoMCwgdXRpbHNfMS5idWlsZEMySk9wdGlvbnMpKG9wdGlvbnMgPz8ge30pO1xuICAgIC8vIFZhbGlkYXRlIHRoZSBwYXJhbWV0ZXJzIGJlZm9yZSBjYWxsaW5nIHRoZSBjb252ZXJ0ZXIncyBjb252ZXJ0IGZ1bmN0aW9uXG4gICAgKDAsIHV0aWxzXzEudmFsaWRhdGUpKGRhdGEsIHV0aWxzXzEuaXNTdHJpbmcsIGNvbnN0YW50c18xLmVycm9ycy5jc3YyanNvbik7XG4gICAgcmV0dXJuICgwLCBjc3YyanNvbl8xLkNzdjJKc29uKShidWlsdE9wdGlvbnMpLmNvbnZlcnQoZGF0YSk7XG59XG5leHBvcnRzLmNzdjJqc29uID0gY3N2Mmpzb247XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/json-2-csv/lib/converter.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/json-2-csv/lib/csv2json.js":
/*!**************************************************!*\
  !*** ../node_modules/json-2-csv/lib/csv2json.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Csv2Json = void 0;\nconst doc_path_1 = __webpack_require__(/*! doc-path */ \"(ssr)/../node_modules/doc-path/lib/path.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/../node_modules/json-2-csv/lib/constants.js\");\nconst utils = __importStar(__webpack_require__(/*! ./utils */ \"(ssr)/../node_modules/json-2-csv/lib/utils.js\"));\nconst Csv2Json = function (options) {\n    const escapedWrapDelimiterRegex = new RegExp(options.delimiter.wrap + options.delimiter.wrap, 'g'), excelBOMRegex = new RegExp('^' + constants_1.excelBOM), valueParserFn = options.parseValue && typeof options.parseValue === 'function' ? options.parseValue : JSON.parse;\n    /**\n     * Trims the header key, if specified by the user via the provided options\n     */\n    function processHeaderKey(headerKey) {\n        headerKey = removeWrapDelimitersFromValue(headerKey);\n        if (options.trimHeaderFields) {\n            return headerKey.split('.')\n                .map((component) => component.trim())\n                .join('.');\n        }\n        return headerKey;\n    }\n    /**\n     * Generate the JSON heading from the CSV\n     */\n    function retrieveHeading(lines) {\n        let headerFields = [];\n        if (options.headerFields) {\n            headerFields = options.headerFields.map((headerField, index) => ({\n                value: processHeaderKey(headerField),\n                index\n            }));\n        }\n        else {\n            // Generate and return the heading keys\n            const headerRow = lines[0];\n            headerFields = headerRow.map((headerKey, index) => ({\n                value: processHeaderKey(headerKey),\n                index\n            }));\n            // If the user provided keys, filter the generated keys to just the user provided keys so we also have the key index\n            if (options.keys) {\n                const keys = options.keys; // TypeScript type checking work around to get it to recognize the option is not undefined\n                headerFields = headerFields.filter((headerKey) => keys.includes(headerKey.value));\n            }\n        }\n        return {\n            lines,\n            headerFields,\n            recordLines: [],\n        };\n    }\n    /**\n     * Removes the Excel BOM value, if specified by the options object\n     */\n    function stripExcelBOM(csv) {\n        if (options.excelBOM) {\n            return csv.replace(excelBOMRegex, '');\n        }\n        return csv;\n    }\n    /**\n     * Helper function that splits a line so that we can handle wrapped fields\n     */\n    function splitLines(csv) {\n        // Parse out the line...\n        const lines = [], lastCharacterIndex = csv.length - 1, eolDelimiterLength = options.delimiter.eol.length, stateVariables = {\n            insideWrapDelimiter: false,\n            parsingValue: true,\n            justParsedDoubleQuote: false,\n            startIndex: 0\n        };\n        let splitLine = [], character, charBefore, charAfter, nextNChar, index = 0;\n        // Loop through each character in the line to identify where to split the values\n        while (index < csv.length) {\n            // Current character\n            character = csv[index];\n            // Previous character\n            charBefore = index ? csv[index - 1] : '';\n            // Next character\n            charAfter = index < lastCharacterIndex ? csv[index + 1] : '';\n            // Next n characters, including the current character, where n = length(EOL delimiter)\n            // This allows for the checking of an EOL delimiter when if it is more than a single character (eg. '\\r\\n')\n            nextNChar = utils.getNCharacters(csv, index, eolDelimiterLength);\n            if ((nextNChar === options.delimiter.eol && !stateVariables.insideWrapDelimiter ||\n                index === lastCharacterIndex) && charBefore === options.delimiter.field) {\n                // If we reached an EOL delimiter or the end of the csv and the previous character is a field delimiter...\n                // If the start index is the current index (and since the previous character is a comma),\n                //   then the value being parsed is an empty value accordingly, add an empty string\n                if (nextNChar === options.delimiter.eol && stateVariables.startIndex === index) {\n                    splitLine.push('');\n                }\n                else if (character === options.delimiter.field) {\n                    // If we reached the end of the CSV, there's no new line, and the current character is a comma\n                    // then add an empty string for the current value\n                    splitLine.push('');\n                }\n                else {\n                    // Otherwise, there's a valid value, and the start index isn't the current index, grab the whole value\n                    splitLine.push(csv.substring(stateVariables.startIndex));\n                }\n                // Since the last character is a comma, there's still an additional implied field value trailing the comma.\n                //   Since this value is empty, we push an extra empty value\n                splitLine.push('');\n                // Finally, push the split line values into the lines array and clear the split line\n                lines.push(splitLine);\n                splitLine = [];\n                stateVariables.startIndex = index + eolDelimiterLength;\n                stateVariables.parsingValue = true;\n                stateVariables.insideWrapDelimiter = charAfter === options.delimiter.wrap;\n            }\n            else if (index === lastCharacterIndex && character === options.delimiter.field) {\n                // If we reach the end of the CSV and the current character is a field delimiter\n                // Parse the previously seen value and add it to the line\n                const parsedValue = csv.substring(stateVariables.startIndex, index);\n                splitLine.push(parsedValue);\n                // Then add an empty string to the line since the last character being a field delimiter indicates an empty field\n                splitLine.push('');\n                lines.push(splitLine);\n            }\n            else if (index === lastCharacterIndex || nextNChar === options.delimiter.eol &&\n                // if we aren't inside wrap delimiters or if we are but the character before was a wrap delimiter and we didn't just see two\n                (!stateVariables.insideWrapDelimiter ||\n                    stateVariables.insideWrapDelimiter && charBefore === options.delimiter.wrap && !stateVariables.justParsedDoubleQuote)) {\n                // Otherwise if we reached the end of the line or csv (and current character is not a field delimiter)\n                const toIndex = index !== lastCharacterIndex || charBefore === options.delimiter.wrap ? index : undefined;\n                // Retrieve the remaining value and add it to the split line list of values\n                splitLine.push(csv.substring(stateVariables.startIndex, toIndex));\n                // Finally, push the split line values into the lines array and clear the split line\n                lines.push(splitLine);\n                splitLine = [];\n                stateVariables.startIndex = index + eolDelimiterLength;\n                stateVariables.parsingValue = true;\n                stateVariables.insideWrapDelimiter = charAfter === options.delimiter.wrap;\n            }\n            else if (character === options.delimiter.wrap && charBefore === options.delimiter.field &&\n                !stateVariables.insideWrapDelimiter && !stateVariables.parsingValue) {\n                // If we reached a wrap delimiter after a comma and we aren't inside a wrap delimiter\n                stateVariables.startIndex = index;\n                stateVariables.insideWrapDelimiter = true;\n                stateVariables.parsingValue = true;\n                // If the next character(s) are an EOL delimiter, then skip them so we don't parse what we've seen as another value\n                if (utils.getNCharacters(csv, index + 1, eolDelimiterLength) === options.delimiter.eol) {\n                    index += options.delimiter.eol.length + 1; // Skip past EOL\n                }\n            }\n            else if (charBefore === options.delimiter.field && character === options.delimiter.wrap && charAfter === options.delimiter.eol) {\n                // We reached the start of a wrapped new field that begins with an EOL delimiter\n                // Retrieve the remaining value and add it to the split line list of values\n                splitLine.push(csv.substring(stateVariables.startIndex, index - 1));\n                stateVariables.startIndex = index;\n                stateVariables.parsingValue = true;\n                stateVariables.insideWrapDelimiter = true;\n                stateVariables.justParsedDoubleQuote = true;\n                index += 1;\n            }\n            else if ((charBefore !== options.delimiter.wrap || stateVariables.justParsedDoubleQuote && charBefore === options.delimiter.wrap) &&\n                character === options.delimiter.wrap && utils.getNCharacters(csv, index + 1, eolDelimiterLength) === options.delimiter.eol) {\n                // If we reach a wrap which is not preceded by a wrap delim and the next character is an EOL delim (ie. *\"\\n)\n                stateVariables.insideWrapDelimiter = false;\n                stateVariables.parsingValue = false;\n                // Next iteration will substring, add the value to the line, and push the line onto the array of lines\n            }\n            else if (character === options.delimiter.wrap && (index === 0 || utils.getNCharacters(csv, index - eolDelimiterLength, eolDelimiterLength) === options.delimiter.eol && !stateVariables.insideWrapDelimiter)) {\n                // If the line starts with a wrap delimiter (ie. \"*)\n                stateVariables.insideWrapDelimiter = true;\n                stateVariables.parsingValue = true;\n                stateVariables.startIndex = index;\n            }\n            else if (character === options.delimiter.wrap && charAfter === options.delimiter.field && stateVariables.insideWrapDelimiter) {\n                // If we reached a wrap delimiter with a field delimiter after it (ie. *\",)\n                splitLine.push(csv.substring(stateVariables.startIndex, index + 1));\n                stateVariables.startIndex = index + 2; // next value starts after the field delimiter\n                stateVariables.insideWrapDelimiter = false;\n                stateVariables.parsingValue = false;\n            }\n            else if (character === options.delimiter.wrap && charBefore === options.delimiter.field &&\n                !stateVariables.insideWrapDelimiter && stateVariables.parsingValue) {\n                // If we reached a wrap delimiter with a field delimiter after it (ie. ,\"*)\n                splitLine.push(csv.substring(stateVariables.startIndex, index - 1));\n                stateVariables.insideWrapDelimiter = true;\n                stateVariables.parsingValue = true;\n                stateVariables.startIndex = index;\n            }\n            else if (character === options.delimiter.wrap && charAfter === options.delimiter.wrap && index !== stateVariables.startIndex) {\n                // If we run into an escaped quote (ie. \"\") skip past the second quote\n                index += 2;\n                stateVariables.justParsedDoubleQuote = true;\n                continue;\n            }\n            else if (character === options.delimiter.field && charBefore !== options.delimiter.wrap &&\n                charAfter !== options.delimiter.wrap && !stateVariables.insideWrapDelimiter &&\n                stateVariables.parsingValue) {\n                // If we reached a field delimiter and are not inside the wrap delimiters (ie. *,*)\n                splitLine.push(csv.substring(stateVariables.startIndex, index));\n                stateVariables.startIndex = index + 1;\n            }\n            else if (character === options.delimiter.field && charBefore === options.delimiter.wrap &&\n                charAfter !== options.delimiter.wrap && !stateVariables.parsingValue) {\n                // If we reached a field delimiter, the previous character was a wrap delimiter, and the\n                //   next character is not a wrap delimiter (ie. \",*)\n                stateVariables.insideWrapDelimiter = false;\n                stateVariables.parsingValue = true;\n                stateVariables.startIndex = index + 1;\n            }\n            // Otherwise increment to the next character\n            index++;\n            // Reset the double quote state variable\n            stateVariables.justParsedDoubleQuote = false;\n        }\n        return lines;\n    }\n    /**\n     * Retrieves the record lines from the split CSV lines and sets it on the params object\n     */\n    function retrieveRecordLines(params) {\n        if (options.headerFields) { // This option is passed for instances where the CSV has no header line\n            params.recordLines = params.lines;\n        }\n        else { // All lines except for the header line\n            params.recordLines = params.lines.splice(1);\n        }\n        return params;\n    }\n    /**\n     * Retrieves the value for the record from the line at the provided key.\n     */\n    function retrieveRecordValueFromLine(headerField, line) {\n        // If there is a value at the key's index, use it; otherwise, null\n        const value = line[headerField.index];\n        // Perform any necessary value conversions on the record value\n        return processRecordValue(value);\n    }\n    /**\n     * Processes the record's value by parsing the data to ensure the CSV is\n     * converted to the JSON that created it.\n     */\n    function processRecordValue(fieldValue) {\n        // If the value is an array representation, convert it\n        const parsedJson = parseValue(fieldValue);\n        // If parsedJson is anything aside from an error, then we want to use the parsed value\n        // This allows us to interpret values like 'null' --> null, 'false' --> false\n        if (!utils.isError(parsedJson) && !utils.isInvalid(parsedJson)) {\n            return parsedJson;\n        }\n        else if (fieldValue === 'undefined') {\n            return undefined;\n        }\n        return fieldValue;\n    }\n    /**\n     * Trims the record value, if specified by the user via the options object\n     */\n    function trimRecordValue(fieldValue) {\n        if (options.trimFieldValues && fieldValue !== null) {\n            return fieldValue.trim();\n        }\n        return fieldValue;\n    }\n    /**\n     * Create a JSON document with the given keys (designated by the CSV header)\n     *   and the values (from the given line)\n     * @returns {Object} created json document\n     */\n    function createDocument(headerFields, line) {\n        // Reduce the keys into a JSON document representing the given line\n        return headerFields.reduce((document, headerField) => {\n            // If there is a value at the key's index in the line, set the value; otherwise null\n            const value = retrieveRecordValueFromLine(headerField, line);\n            try {\n                // Otherwise add the key and value to the document\n                return (0, doc_path_1.setPath)(document, headerField.value, value);\n            }\n            catch (error) {\n                // Catch any errors where key paths are null or '' and continue\n                return document;\n            }\n        }, {});\n    }\n    /**\n     * Removes the outermost wrap delimiters from a value, if they are present\n     * Otherwise, the non-wrapped value is returned as is\n     */\n    function removeWrapDelimitersFromValue(fieldValue) {\n        const firstChar = fieldValue[0], lastIndex = fieldValue.length - 1, lastChar = fieldValue[lastIndex];\n        // If the field starts and ends with a wrap delimiter\n        if (firstChar === options.delimiter.wrap && lastChar === options.delimiter.wrap) {\n            // Handle the case where the field is just a pair of wrap delimiters \n            return fieldValue.length <= 2 ? '' : fieldValue.substring(1, lastIndex);\n        }\n        return fieldValue;\n    }\n    /**\n     * Unescapes wrap delimiters by replacing duplicates with a single (eg. \"\" -> \")\n     * This is done in order to parse RFC 4180 compliant CSV back to JSON\n     */\n    function unescapeWrapDelimiterInField(fieldValue) {\n        return fieldValue.replace(escapedWrapDelimiterRegex, options.delimiter.wrap);\n    }\n    /**\n     * Main helper function to convert the CSV to the JSON document array\n     */\n    function transformRecordLines(params) {\n        // For each line, create the document and add it to the array of documents\n        return params.recordLines.reduce((generatedJsonObjects, line) => {\n            line = line.map((fieldValue) => {\n                // Perform the necessary operations on each line\n                fieldValue = removeWrapDelimitersFromValue(fieldValue);\n                fieldValue = unescapeWrapDelimiterInField(fieldValue);\n                fieldValue = trimRecordValue(fieldValue);\n                return fieldValue;\n            });\n            const generatedDocument = createDocument(params.headerFields, line);\n            return generatedJsonObjects.concat(generatedDocument);\n        }, []);\n    }\n    /**\n     * Attempts to parse the provided value. If it is not parsable, then an error is returned\n     */\n    function parseValue(value) {\n        try {\n            if (utils.isStringRepresentation(value, options) && !utils.isDateRepresentation(value)) {\n                return value;\n            }\n            const parsedJson = valueParserFn(value);\n            // If the parsed value is an array, then we also need to trim record values, if specified\n            if (Array.isArray(parsedJson)) {\n                return parsedJson.map(trimRecordValue);\n            }\n            return parsedJson;\n        }\n        catch (err) {\n            return err;\n        }\n    }\n    /**\n     * Internally exported csv2json function\n     */\n    function convert(data) {\n        // Split the CSV into lines using the specified EOL option\n        const stripped = stripExcelBOM(data);\n        const split = splitLines(stripped);\n        const heading = retrieveHeading(split); // Retrieve the headings from the CSV, unless the user specified the keys\n        const lines = retrieveRecordLines(heading); // Retrieve the record lines from the CSV\n        return transformRecordLines(lines); // Retrieve the JSON document array\n    }\n    return {\n        convert,\n    };\n};\nexports.Csv2Json = Csv2Json;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2pzb24tMi1jc3YvbGliL2NzdjJqc29uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsbUJBQW1CLG1CQUFPLENBQUMsNERBQVU7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMsc0VBQWE7QUFDekMsMkJBQTJCLG1CQUFPLENBQUMsOERBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsb0RBQW9EO0FBQ3BELDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCIiwic291cmNlcyI6WyIvVXNlcnMvR2Fsb2NrL0NTL2JlaG9tZS1zaXRlL25vZGVfbW9kdWxlcy9qc29uLTItY3N2L2xpYi9jc3YyanNvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ3N2Mkpzb24gPSB2b2lkIDA7XG5jb25zdCBkb2NfcGF0aF8xID0gcmVxdWlyZShcImRvYy1wYXRoXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsc1wiKSk7XG5jb25zdCBDc3YySnNvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgY29uc3QgZXNjYXBlZFdyYXBEZWxpbWl0ZXJSZWdleCA9IG5ldyBSZWdFeHAob3B0aW9ucy5kZWxpbWl0ZXIud3JhcCArIG9wdGlvbnMuZGVsaW1pdGVyLndyYXAsICdnJyksIGV4Y2VsQk9NUmVnZXggPSBuZXcgUmVnRXhwKCdeJyArIGNvbnN0YW50c18xLmV4Y2VsQk9NKSwgdmFsdWVQYXJzZXJGbiA9IG9wdGlvbnMucGFyc2VWYWx1ZSAmJiB0eXBlb2Ygb3B0aW9ucy5wYXJzZVZhbHVlID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5wYXJzZVZhbHVlIDogSlNPTi5wYXJzZTtcbiAgICAvKipcbiAgICAgKiBUcmltcyB0aGUgaGVhZGVyIGtleSwgaWYgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyIHZpYSB0aGUgcHJvdmlkZWQgb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NIZWFkZXJLZXkoaGVhZGVyS2V5KSB7XG4gICAgICAgIGhlYWRlcktleSA9IHJlbW92ZVdyYXBEZWxpbWl0ZXJzRnJvbVZhbHVlKGhlYWRlcktleSk7XG4gICAgICAgIGlmIChvcHRpb25zLnRyaW1IZWFkZXJGaWVsZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBoZWFkZXJLZXkuc3BsaXQoJy4nKVxuICAgICAgICAgICAgICAgIC5tYXAoKGNvbXBvbmVudCkgPT4gY29tcG9uZW50LnRyaW0oKSlcbiAgICAgICAgICAgICAgICAuam9pbignLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkZXJLZXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHRoZSBKU09OIGhlYWRpbmcgZnJvbSB0aGUgQ1NWXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV0cmlldmVIZWFkaW5nKGxpbmVzKSB7XG4gICAgICAgIGxldCBoZWFkZXJGaWVsZHMgPSBbXTtcbiAgICAgICAgaWYgKG9wdGlvbnMuaGVhZGVyRmllbGRzKSB7XG4gICAgICAgICAgICBoZWFkZXJGaWVsZHMgPSBvcHRpb25zLmhlYWRlckZpZWxkcy5tYXAoKGhlYWRlckZpZWxkLCBpbmRleCkgPT4gKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcHJvY2Vzc0hlYWRlcktleShoZWFkZXJGaWVsZCksXG4gICAgICAgICAgICAgICAgaW5kZXhcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIGFuZCByZXR1cm4gdGhlIGhlYWRpbmcga2V5c1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUm93ID0gbGluZXNbMF07XG4gICAgICAgICAgICBoZWFkZXJGaWVsZHMgPSBoZWFkZXJSb3cubWFwKChoZWFkZXJLZXksIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBwcm9jZXNzSGVhZGVyS2V5KGhlYWRlcktleSksXG4gICAgICAgICAgICAgICAgaW5kZXhcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIHByb3ZpZGVkIGtleXMsIGZpbHRlciB0aGUgZ2VuZXJhdGVkIGtleXMgdG8ganVzdCB0aGUgdXNlciBwcm92aWRlZCBrZXlzIHNvIHdlIGFsc28gaGF2ZSB0aGUga2V5IGluZGV4XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5rZXlzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IG9wdGlvbnMua2V5czsgLy8gVHlwZVNjcmlwdCB0eXBlIGNoZWNraW5nIHdvcmsgYXJvdW5kIHRvIGdldCBpdCB0byByZWNvZ25pemUgdGhlIG9wdGlvbiBpcyBub3QgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgaGVhZGVyRmllbGRzID0gaGVhZGVyRmllbGRzLmZpbHRlcigoaGVhZGVyS2V5KSA9PiBrZXlzLmluY2x1ZGVzKGhlYWRlcktleS52YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW5lcyxcbiAgICAgICAgICAgIGhlYWRlckZpZWxkcyxcbiAgICAgICAgICAgIHJlY29yZExpbmVzOiBbXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgRXhjZWwgQk9NIHZhbHVlLCBpZiBzcGVjaWZpZWQgYnkgdGhlIG9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RyaXBFeGNlbEJPTShjc3YpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuZXhjZWxCT00pIHtcbiAgICAgICAgICAgIHJldHVybiBjc3YucmVwbGFjZShleGNlbEJPTVJlZ2V4LCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNzdjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgc3BsaXRzIGEgbGluZSBzbyB0aGF0IHdlIGNhbiBoYW5kbGUgd3JhcHBlZCBmaWVsZHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzcGxpdExpbmVzKGNzdikge1xuICAgICAgICAvLyBQYXJzZSBvdXQgdGhlIGxpbmUuLi5cbiAgICAgICAgY29uc3QgbGluZXMgPSBbXSwgbGFzdENoYXJhY3RlckluZGV4ID0gY3N2Lmxlbmd0aCAtIDEsIGVvbERlbGltaXRlckxlbmd0aCA9IG9wdGlvbnMuZGVsaW1pdGVyLmVvbC5sZW5ndGgsIHN0YXRlVmFyaWFibGVzID0ge1xuICAgICAgICAgICAgaW5zaWRlV3JhcERlbGltaXRlcjogZmFsc2UsXG4gICAgICAgICAgICBwYXJzaW5nVmFsdWU6IHRydWUsXG4gICAgICAgICAgICBqdXN0UGFyc2VkRG91YmxlUXVvdGU6IGZhbHNlLFxuICAgICAgICAgICAgc3RhcnRJbmRleDogMFxuICAgICAgICB9O1xuICAgICAgICBsZXQgc3BsaXRMaW5lID0gW10sIGNoYXJhY3RlciwgY2hhckJlZm9yZSwgY2hhckFmdGVyLCBuZXh0TkNoYXIsIGluZGV4ID0gMDtcbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGVhY2ggY2hhcmFjdGVyIGluIHRoZSBsaW5lIHRvIGlkZW50aWZ5IHdoZXJlIHRvIHNwbGl0IHRoZSB2YWx1ZXNcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgY3N2Lmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gQ3VycmVudCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIGNoYXJhY3RlciA9IGNzdltpbmRleF07XG4gICAgICAgICAgICAvLyBQcmV2aW91cyBjaGFyYWN0ZXJcbiAgICAgICAgICAgIGNoYXJCZWZvcmUgPSBpbmRleCA/IGNzdltpbmRleCAtIDFdIDogJyc7XG4gICAgICAgICAgICAvLyBOZXh0IGNoYXJhY3RlclxuICAgICAgICAgICAgY2hhckFmdGVyID0gaW5kZXggPCBsYXN0Q2hhcmFjdGVySW5kZXggPyBjc3ZbaW5kZXggKyAxXSA6ICcnO1xuICAgICAgICAgICAgLy8gTmV4dCBuIGNoYXJhY3RlcnMsIGluY2x1ZGluZyB0aGUgY3VycmVudCBjaGFyYWN0ZXIsIHdoZXJlIG4gPSBsZW5ndGgoRU9MIGRlbGltaXRlcilcbiAgICAgICAgICAgIC8vIFRoaXMgYWxsb3dzIGZvciB0aGUgY2hlY2tpbmcgb2YgYW4gRU9MIGRlbGltaXRlciB3aGVuIGlmIGl0IGlzIG1vcmUgdGhhbiBhIHNpbmdsZSBjaGFyYWN0ZXIgKGVnLiAnXFxyXFxuJylcbiAgICAgICAgICAgIG5leHROQ2hhciA9IHV0aWxzLmdldE5DaGFyYWN0ZXJzKGNzdiwgaW5kZXgsIGVvbERlbGltaXRlckxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoKG5leHROQ2hhciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZW9sICYmICFzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyIHx8XG4gICAgICAgICAgICAgICAgaW5kZXggPT09IGxhc3RDaGFyYWN0ZXJJbmRleCkgJiYgY2hhckJlZm9yZSA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZmllbGQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGFuIEVPTCBkZWxpbWl0ZXIgb3IgdGhlIGVuZCBvZiB0aGUgY3N2IGFuZCB0aGUgcHJldmlvdXMgY2hhcmFjdGVyIGlzIGEgZmllbGQgZGVsaW1pdGVyLi4uXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHN0YXJ0IGluZGV4IGlzIHRoZSBjdXJyZW50IGluZGV4IChhbmQgc2luY2UgdGhlIHByZXZpb3VzIGNoYXJhY3RlciBpcyBhIGNvbW1hKSxcbiAgICAgICAgICAgICAgICAvLyAgIHRoZW4gdGhlIHZhbHVlIGJlaW5nIHBhcnNlZCBpcyBhbiBlbXB0eSB2YWx1ZSBhY2NvcmRpbmdseSwgYWRkIGFuIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgICAgIGlmIChuZXh0TkNoYXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmVvbCAmJiBzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4ID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBzcGxpdExpbmUucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBDU1YsIHRoZXJlJ3Mgbm8gbmV3IGxpbmUsIGFuZCB0aGUgY3VycmVudCBjaGFyYWN0ZXIgaXMgYSBjb21tYVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIGFkZCBhbiBlbXB0eSBzdHJpbmcgZm9yIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIHNwbGl0TGluZS5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdGhlcmUncyBhIHZhbGlkIHZhbHVlLCBhbmQgdGhlIHN0YXJ0IGluZGV4IGlzbid0IHRoZSBjdXJyZW50IGluZGV4LCBncmFiIHRoZSB3aG9sZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBzcGxpdExpbmUucHVzaChjc3Yuc3Vic3RyaW5nKHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlIGxhc3QgY2hhcmFjdGVyIGlzIGEgY29tbWEsIHRoZXJlJ3Mgc3RpbGwgYW4gYWRkaXRpb25hbCBpbXBsaWVkIGZpZWxkIHZhbHVlIHRyYWlsaW5nIHRoZSBjb21tYS5cbiAgICAgICAgICAgICAgICAvLyAgIFNpbmNlIHRoaXMgdmFsdWUgaXMgZW1wdHksIHdlIHB1c2ggYW4gZXh0cmEgZW1wdHkgdmFsdWVcbiAgICAgICAgICAgICAgICBzcGxpdExpbmUucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgLy8gRmluYWxseSwgcHVzaCB0aGUgc3BsaXQgbGluZSB2YWx1ZXMgaW50byB0aGUgbGluZXMgYXJyYXkgYW5kIGNsZWFyIHRoZSBzcGxpdCBsaW5lXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChzcGxpdExpbmUpO1xuICAgICAgICAgICAgICAgIHNwbGl0TGluZSA9IFtdO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXggPSBpbmRleCArIGVvbERlbGltaXRlckxlbmd0aDtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5wYXJzaW5nVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIgPSBjaGFyQWZ0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbmRleCA9PT0gbGFzdENoYXJhY3RlckluZGV4ICYmIGNoYXJhY3RlciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZmllbGQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaCB0aGUgZW5kIG9mIHRoZSBDU1YgYW5kIHRoZSBjdXJyZW50IGNoYXJhY3RlciBpcyBhIGZpZWxkIGRlbGltaXRlclxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBwcmV2aW91c2x5IHNlZW4gdmFsdWUgYW5kIGFkZCBpdCB0byB0aGUgbGluZVxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gY3N2LnN1YnN0cmluZyhzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgc3BsaXRMaW5lLnB1c2gocGFyc2VkVmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vIFRoZW4gYWRkIGFuIGVtcHR5IHN0cmluZyB0byB0aGUgbGluZSBzaW5jZSB0aGUgbGFzdCBjaGFyYWN0ZXIgYmVpbmcgYSBmaWVsZCBkZWxpbWl0ZXIgaW5kaWNhdGVzIGFuIGVtcHR5IGZpZWxkXG4gICAgICAgICAgICAgICAgc3BsaXRMaW5lLnB1c2goJycpO1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goc3BsaXRMaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4ID09PSBsYXN0Q2hhcmFjdGVySW5kZXggfHwgbmV4dE5DaGFyID09PSBvcHRpb25zLmRlbGltaXRlci5lb2wgJiZcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhcmVuJ3QgaW5zaWRlIHdyYXAgZGVsaW1pdGVycyBvciBpZiB3ZSBhcmUgYnV0IHRoZSBjaGFyYWN0ZXIgYmVmb3JlIHdhcyBhIHdyYXAgZGVsaW1pdGVyIGFuZCB3ZSBkaWRuJ3QganVzdCBzZWUgdHdvXG4gICAgICAgICAgICAgICAgKCFzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyIHx8XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIgJiYgY2hhckJlZm9yZSA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCAmJiAhc3RhdGVWYXJpYWJsZXMuanVzdFBhcnNlZERvdWJsZVF1b3RlKSkge1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpZiB3ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGxpbmUgb3IgY3N2IChhbmQgY3VycmVudCBjaGFyYWN0ZXIgaXMgbm90IGEgZmllbGQgZGVsaW1pdGVyKVxuICAgICAgICAgICAgICAgIGNvbnN0IHRvSW5kZXggPSBpbmRleCAhPT0gbGFzdENoYXJhY3RlckluZGV4IHx8IGNoYXJCZWZvcmUgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgPyBpbmRleCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAvLyBSZXRyaWV2ZSB0aGUgcmVtYWluaW5nIHZhbHVlIGFuZCBhZGQgaXQgdG8gdGhlIHNwbGl0IGxpbmUgbGlzdCBvZiB2YWx1ZXNcbiAgICAgICAgICAgICAgICBzcGxpdExpbmUucHVzaChjc3Yuc3Vic3RyaW5nKHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXgsIHRvSW5kZXgpKTtcbiAgICAgICAgICAgICAgICAvLyBGaW5hbGx5LCBwdXNoIHRoZSBzcGxpdCBsaW5lIHZhbHVlcyBpbnRvIHRoZSBsaW5lcyBhcnJheSBhbmQgY2xlYXIgdGhlIHNwbGl0IGxpbmVcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKHNwbGl0TGluZSk7XG4gICAgICAgICAgICAgICAgc3BsaXRMaW5lID0gW107XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCA9IGluZGV4ICsgZW9sRGVsaW1pdGVyTGVuZ3RoO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnBhcnNpbmdWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciA9IGNoYXJBZnRlciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCAmJiBjaGFyQmVmb3JlID09PSBvcHRpb25zLmRlbGltaXRlci5maWVsZCAmJlxuICAgICAgICAgICAgICAgICFzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyICYmICFzdGF0ZVZhcmlhYmxlcy5wYXJzaW5nVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgd3JhcCBkZWxpbWl0ZXIgYWZ0ZXIgYSBjb21tYSBhbmQgd2UgYXJlbid0IGluc2lkZSBhIHdyYXAgZGVsaW1pdGVyXG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnBhcnNpbmdWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5leHQgY2hhcmFjdGVyKHMpIGFyZSBhbiBFT0wgZGVsaW1pdGVyLCB0aGVuIHNraXAgdGhlbSBzbyB3ZSBkb24ndCBwYXJzZSB3aGF0IHdlJ3ZlIHNlZW4gYXMgYW5vdGhlciB2YWx1ZVxuICAgICAgICAgICAgICAgIGlmICh1dGlscy5nZXROQ2hhcmFjdGVycyhjc3YsIGluZGV4ICsgMSwgZW9sRGVsaW1pdGVyTGVuZ3RoKSA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZW9sKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IG9wdGlvbnMuZGVsaW1pdGVyLmVvbC5sZW5ndGggKyAxOyAvLyBTa2lwIHBhc3QgRU9MXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhckJlZm9yZSA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZmllbGQgJiYgY2hhcmFjdGVyID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwICYmIGNoYXJBZnRlciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZW9sKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgcmVhY2hlZCB0aGUgc3RhcnQgb2YgYSB3cmFwcGVkIG5ldyBmaWVsZCB0aGF0IGJlZ2lucyB3aXRoIGFuIEVPTCBkZWxpbWl0ZXJcbiAgICAgICAgICAgICAgICAvLyBSZXRyaWV2ZSB0aGUgcmVtYWluaW5nIHZhbHVlIGFuZCBhZGQgaXQgdG8gdGhlIHNwbGl0IGxpbmUgbGlzdCBvZiB2YWx1ZXNcbiAgICAgICAgICAgICAgICBzcGxpdExpbmUucHVzaChjc3Yuc3Vic3RyaW5nKHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXgsIGluZGV4IC0gMSkpO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5wYXJzaW5nVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLmp1c3RQYXJzZWREb3VibGVRdW90ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChjaGFyQmVmb3JlICE9PSBvcHRpb25zLmRlbGltaXRlci53cmFwIHx8IHN0YXRlVmFyaWFibGVzLmp1c3RQYXJzZWREb3VibGVRdW90ZSAmJiBjaGFyQmVmb3JlID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwKSAmJlxuICAgICAgICAgICAgICAgIGNoYXJhY3RlciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCAmJiB1dGlscy5nZXROQ2hhcmFjdGVycyhjc3YsIGluZGV4ICsgMSwgZW9sRGVsaW1pdGVyTGVuZ3RoKSA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZW9sKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2ggYSB3cmFwIHdoaWNoIGlzIG5vdCBwcmVjZWRlZCBieSBhIHdyYXAgZGVsaW0gYW5kIHRoZSBuZXh0IGNoYXJhY3RlciBpcyBhbiBFT0wgZGVsaW0gKGllLiAqXCJcXG4pXG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnBhcnNpbmdWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIE5leHQgaXRlcmF0aW9uIHdpbGwgc3Vic3RyaW5nLCBhZGQgdGhlIHZhbHVlIHRvIHRoZSBsaW5lLCBhbmQgcHVzaCB0aGUgbGluZSBvbnRvIHRoZSBhcnJheSBvZiBsaW5lc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwICYmIChpbmRleCA9PT0gMCB8fCB1dGlscy5nZXROQ2hhcmFjdGVycyhjc3YsIGluZGV4IC0gZW9sRGVsaW1pdGVyTGVuZ3RoLCBlb2xEZWxpbWl0ZXJMZW5ndGgpID09PSBvcHRpb25zLmRlbGltaXRlci5lb2wgJiYgIXN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGxpbmUgc3RhcnRzIHdpdGggYSB3cmFwIGRlbGltaXRlciAoaWUuIFwiKilcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5wYXJzaW5nVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCAmJiBjaGFyQWZ0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmZpZWxkICYmIHN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgd3JhcCBkZWxpbWl0ZXIgd2l0aCBhIGZpZWxkIGRlbGltaXRlciBhZnRlciBpdCAoaWUuICpcIiwpXG4gICAgICAgICAgICAgICAgc3BsaXRMaW5lLnB1c2goY3N2LnN1YnN0cmluZyhzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4LCBpbmRleCArIDEpKTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4ID0gaW5kZXggKyAyOyAvLyBuZXh0IHZhbHVlIHN0YXJ0cyBhZnRlciB0aGUgZmllbGQgZGVsaW1pdGVyXG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnBhcnNpbmdWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwICYmIGNoYXJCZWZvcmUgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmZpZWxkICYmXG4gICAgICAgICAgICAgICAgIXN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIgJiYgc3RhdGVWYXJpYWJsZXMucGFyc2luZ1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHdyYXAgZGVsaW1pdGVyIHdpdGggYSBmaWVsZCBkZWxpbWl0ZXIgYWZ0ZXIgaXQgKGllLiAsXCIqKVxuICAgICAgICAgICAgICAgIHNwbGl0TGluZS5wdXNoKGNzdi5zdWJzdHJpbmcoc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCwgaW5kZXggLSAxKSk7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMucGFyc2luZ1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiYgY2hhckFmdGVyID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwICYmIGluZGV4ICE9PSBzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcnVuIGludG8gYW4gZXNjYXBlZCBxdW90ZSAoaWUuIFwiXCIpIHNraXAgcGFzdCB0aGUgc2Vjb25kIHF1b3RlXG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5qdXN0UGFyc2VkRG91YmxlUXVvdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyID09PSBvcHRpb25zLmRlbGltaXRlci5maWVsZCAmJiBjaGFyQmVmb3JlICE9PSBvcHRpb25zLmRlbGltaXRlci53cmFwICYmXG4gICAgICAgICAgICAgICAgY2hhckFmdGVyICE9PSBvcHRpb25zLmRlbGltaXRlci53cmFwICYmICFzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyICYmXG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMucGFyc2luZ1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIGZpZWxkIGRlbGltaXRlciBhbmQgYXJlIG5vdCBpbnNpZGUgdGhlIHdyYXAgZGVsaW1pdGVycyAoaWUuICosKilcbiAgICAgICAgICAgICAgICBzcGxpdExpbmUucHVzaChjc3Yuc3Vic3RyaW5nKHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXgsIGluZGV4KSk7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZmllbGQgJiYgY2hhckJlZm9yZSA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCAmJlxuICAgICAgICAgICAgICAgIGNoYXJBZnRlciAhPT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCAmJiAhc3RhdGVWYXJpYWJsZXMucGFyc2luZ1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIGZpZWxkIGRlbGltaXRlciwgdGhlIHByZXZpb3VzIGNoYXJhY3RlciB3YXMgYSB3cmFwIGRlbGltaXRlciwgYW5kIHRoZVxuICAgICAgICAgICAgICAgIC8vICAgbmV4dCBjaGFyYWN0ZXIgaXMgbm90IGEgd3JhcCBkZWxpbWl0ZXIgKGllLiBcIiwqKVxuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5wYXJzaW5nVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IHRvIHRoZSBuZXh0IGNoYXJhY3RlclxuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBkb3VibGUgcXVvdGUgc3RhdGUgdmFyaWFibGVcbiAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLmp1c3RQYXJzZWREb3VibGVRdW90ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSByZWNvcmQgbGluZXMgZnJvbSB0aGUgc3BsaXQgQ1NWIGxpbmVzIGFuZCBzZXRzIGl0IG9uIHRoZSBwYXJhbXMgb2JqZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV0cmlldmVSZWNvcmRMaW5lcyhwYXJhbXMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaGVhZGVyRmllbGRzKSB7IC8vIFRoaXMgb3B0aW9uIGlzIHBhc3NlZCBmb3IgaW5zdGFuY2VzIHdoZXJlIHRoZSBDU1YgaGFzIG5vIGhlYWRlciBsaW5lXG4gICAgICAgICAgICBwYXJhbXMucmVjb3JkTGluZXMgPSBwYXJhbXMubGluZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIEFsbCBsaW5lcyBleGNlcHQgZm9yIHRoZSBoZWFkZXIgbGluZVxuICAgICAgICAgICAgcGFyYW1zLnJlY29yZExpbmVzID0gcGFyYW1zLmxpbmVzLnNwbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHZhbHVlIGZvciB0aGUgcmVjb3JkIGZyb20gdGhlIGxpbmUgYXQgdGhlIHByb3ZpZGVkIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXRyaWV2ZVJlY29yZFZhbHVlRnJvbUxpbmUoaGVhZGVyRmllbGQsIGxpbmUpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSB2YWx1ZSBhdCB0aGUga2V5J3MgaW5kZXgsIHVzZSBpdDsgb3RoZXJ3aXNlLCBudWxsXG4gICAgICAgIGNvbnN0IHZhbHVlID0gbGluZVtoZWFkZXJGaWVsZC5pbmRleF07XG4gICAgICAgIC8vIFBlcmZvcm0gYW55IG5lY2Vzc2FyeSB2YWx1ZSBjb252ZXJzaW9ucyBvbiB0aGUgcmVjb3JkIHZhbHVlXG4gICAgICAgIHJldHVybiBwcm9jZXNzUmVjb3JkVmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgdGhlIHJlY29yZCdzIHZhbHVlIGJ5IHBhcnNpbmcgdGhlIGRhdGEgdG8gZW5zdXJlIHRoZSBDU1YgaXNcbiAgICAgKiBjb252ZXJ0ZWQgdG8gdGhlIEpTT04gdGhhdCBjcmVhdGVkIGl0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NSZWNvcmRWYWx1ZShmaWVsZFZhbHVlKSB7XG4gICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBhbiBhcnJheSByZXByZXNlbnRhdGlvbiwgY29udmVydCBpdFxuICAgICAgICBjb25zdCBwYXJzZWRKc29uID0gcGFyc2VWYWx1ZShmaWVsZFZhbHVlKTtcbiAgICAgICAgLy8gSWYgcGFyc2VkSnNvbiBpcyBhbnl0aGluZyBhc2lkZSBmcm9tIGFuIGVycm9yLCB0aGVuIHdlIHdhbnQgdG8gdXNlIHRoZSBwYXJzZWQgdmFsdWVcbiAgICAgICAgLy8gVGhpcyBhbGxvd3MgdXMgdG8gaW50ZXJwcmV0IHZhbHVlcyBsaWtlICdudWxsJyAtLT4gbnVsbCwgJ2ZhbHNlJyAtLT4gZmFsc2VcbiAgICAgICAgaWYgKCF1dGlscy5pc0Vycm9yKHBhcnNlZEpzb24pICYmICF1dGlscy5pc0ludmFsaWQocGFyc2VkSnNvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWRKc29uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpZWxkVmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWVsZFZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmltcyB0aGUgcmVjb3JkIHZhbHVlLCBpZiBzcGVjaWZpZWQgYnkgdGhlIHVzZXIgdmlhIHRoZSBvcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1SZWNvcmRWYWx1ZShmaWVsZFZhbHVlKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnRyaW1GaWVsZFZhbHVlcyAmJiBmaWVsZFZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGRWYWx1ZS50cmltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIEpTT04gZG9jdW1lbnQgd2l0aCB0aGUgZ2l2ZW4ga2V5cyAoZGVzaWduYXRlZCBieSB0aGUgQ1NWIGhlYWRlcilcbiAgICAgKiAgIGFuZCB0aGUgdmFsdWVzIChmcm9tIHRoZSBnaXZlbiBsaW5lKVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGNyZWF0ZWQganNvbiBkb2N1bWVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50KGhlYWRlckZpZWxkcywgbGluZSkge1xuICAgICAgICAvLyBSZWR1Y2UgdGhlIGtleXMgaW50byBhIEpTT04gZG9jdW1lbnQgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBsaW5lXG4gICAgICAgIHJldHVybiBoZWFkZXJGaWVsZHMucmVkdWNlKChkb2N1bWVudCwgaGVhZGVyRmllbGQpID0+IHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgdmFsdWUgYXQgdGhlIGtleSdzIGluZGV4IGluIHRoZSBsaW5lLCBzZXQgdGhlIHZhbHVlOyBvdGhlcndpc2UgbnVsbFxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZXRyaWV2ZVJlY29yZFZhbHVlRnJvbUxpbmUoaGVhZGVyRmllbGQsIGxpbmUpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgYWRkIHRoZSBrZXkgYW5kIHZhbHVlIHRvIHRoZSBkb2N1bWVudFxuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgZG9jX3BhdGhfMS5zZXRQYXRoKShkb2N1bWVudCwgaGVhZGVyRmllbGQudmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIENhdGNoIGFueSBlcnJvcnMgd2hlcmUga2V5IHBhdGhzIGFyZSBudWxsIG9yICcnIGFuZCBjb250aW51ZVxuICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBvdXRlcm1vc3Qgd3JhcCBkZWxpbWl0ZXJzIGZyb20gYSB2YWx1ZSwgaWYgdGhleSBhcmUgcHJlc2VudFxuICAgICAqIE90aGVyd2lzZSwgdGhlIG5vbi13cmFwcGVkIHZhbHVlIGlzIHJldHVybmVkIGFzIGlzXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlV3JhcERlbGltaXRlcnNGcm9tVmFsdWUoZmllbGRWYWx1ZSkge1xuICAgICAgICBjb25zdCBmaXJzdENoYXIgPSBmaWVsZFZhbHVlWzBdLCBsYXN0SW5kZXggPSBmaWVsZFZhbHVlLmxlbmd0aCAtIDEsIGxhc3RDaGFyID0gZmllbGRWYWx1ZVtsYXN0SW5kZXhdO1xuICAgICAgICAvLyBJZiB0aGUgZmllbGQgc3RhcnRzIGFuZCBlbmRzIHdpdGggYSB3cmFwIGRlbGltaXRlclxuICAgICAgICBpZiAoZmlyc3RDaGFyID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwICYmIGxhc3RDaGFyID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIGZpZWxkIGlzIGp1c3QgYSBwYWlyIG9mIHdyYXAgZGVsaW1pdGVycyBcbiAgICAgICAgICAgIHJldHVybiBmaWVsZFZhbHVlLmxlbmd0aCA8PSAyID8gJycgOiBmaWVsZFZhbHVlLnN1YnN0cmluZygxLCBsYXN0SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWVsZFZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbmVzY2FwZXMgd3JhcCBkZWxpbWl0ZXJzIGJ5IHJlcGxhY2luZyBkdXBsaWNhdGVzIHdpdGggYSBzaW5nbGUgKGVnLiBcIlwiIC0+IFwiKVxuICAgICAqIFRoaXMgaXMgZG9uZSBpbiBvcmRlciB0byBwYXJzZSBSRkMgNDE4MCBjb21wbGlhbnQgQ1NWIGJhY2sgdG8gSlNPTlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlV3JhcERlbGltaXRlckluRmllbGQoZmllbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gZmllbGRWYWx1ZS5yZXBsYWNlKGVzY2FwZWRXcmFwRGVsaW1pdGVyUmVnZXgsIG9wdGlvbnMuZGVsaW1pdGVyLndyYXApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWluIGhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IHRoZSBDU1YgdG8gdGhlIEpTT04gZG9jdW1lbnQgYXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1SZWNvcmRMaW5lcyhwYXJhbXMpIHtcbiAgICAgICAgLy8gRm9yIGVhY2ggbGluZSwgY3JlYXRlIHRoZSBkb2N1bWVudCBhbmQgYWRkIGl0IHRvIHRoZSBhcnJheSBvZiBkb2N1bWVudHNcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5yZWNvcmRMaW5lcy5yZWR1Y2UoKGdlbmVyYXRlZEpzb25PYmplY3RzLCBsaW5lKSA9PiB7XG4gICAgICAgICAgICBsaW5lID0gbGluZS5tYXAoKGZpZWxkVmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIHRoZSBuZWNlc3Nhcnkgb3BlcmF0aW9ucyBvbiBlYWNoIGxpbmVcbiAgICAgICAgICAgICAgICBmaWVsZFZhbHVlID0gcmVtb3ZlV3JhcERlbGltaXRlcnNGcm9tVmFsdWUoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgZmllbGRWYWx1ZSA9IHVuZXNjYXBlV3JhcERlbGltaXRlckluRmllbGQoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgZmllbGRWYWx1ZSA9IHRyaW1SZWNvcmRWYWx1ZShmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmllbGRWYWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZ2VuZXJhdGVkRG9jdW1lbnQgPSBjcmVhdGVEb2N1bWVudChwYXJhbXMuaGVhZGVyRmllbGRzLCBsaW5lKTtcbiAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRKc29uT2JqZWN0cy5jb25jYXQoZ2VuZXJhdGVkRG9jdW1lbnQpO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIHBhcnNlIHRoZSBwcm92aWRlZCB2YWx1ZS4gSWYgaXQgaXMgbm90IHBhcnNhYmxlLCB0aGVuIGFuIGVycm9yIGlzIHJldHVybmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nUmVwcmVzZW50YXRpb24odmFsdWUsIG9wdGlvbnMpICYmICF1dGlscy5pc0RhdGVSZXByZXNlbnRhdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRKc29uID0gdmFsdWVQYXJzZXJGbih2YWx1ZSk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgcGFyc2VkIHZhbHVlIGlzIGFuIGFycmF5LCB0aGVuIHdlIGFsc28gbmVlZCB0byB0cmltIHJlY29yZCB2YWx1ZXMsIGlmIHNwZWNpZmllZFxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkSnNvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkSnNvbi5tYXAodHJpbVJlY29yZFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJzZWRKc29uO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWxseSBleHBvcnRlZCBjc3YyanNvbiBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnZlcnQoZGF0YSkge1xuICAgICAgICAvLyBTcGxpdCB0aGUgQ1NWIGludG8gbGluZXMgdXNpbmcgdGhlIHNwZWNpZmllZCBFT0wgb3B0aW9uXG4gICAgICAgIGNvbnN0IHN0cmlwcGVkID0gc3RyaXBFeGNlbEJPTShkYXRhKTtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSBzcGxpdExpbmVzKHN0cmlwcGVkKTtcbiAgICAgICAgY29uc3QgaGVhZGluZyA9IHJldHJpZXZlSGVhZGluZyhzcGxpdCk7IC8vIFJldHJpZXZlIHRoZSBoZWFkaW5ncyBmcm9tIHRoZSBDU1YsIHVubGVzcyB0aGUgdXNlciBzcGVjaWZpZWQgdGhlIGtleXNcbiAgICAgICAgY29uc3QgbGluZXMgPSByZXRyaWV2ZVJlY29yZExpbmVzKGhlYWRpbmcpOyAvLyBSZXRyaWV2ZSB0aGUgcmVjb3JkIGxpbmVzIGZyb20gdGhlIENTVlxuICAgICAgICByZXR1cm4gdHJhbnNmb3JtUmVjb3JkTGluZXMobGluZXMpOyAvLyBSZXRyaWV2ZSB0aGUgSlNPTiBkb2N1bWVudCBhcnJheVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjb252ZXJ0LFxuICAgIH07XG59O1xuZXhwb3J0cy5Dc3YySnNvbiA9IENzdjJKc29uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/json-2-csv/lib/csv2json.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/json-2-csv/lib/json2csv.js":
/*!**************************************************!*\
  !*** ../node_modules/json-2-csv/lib/json2csv.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Json2Csv = void 0;\nconst doc_path_1 = __webpack_require__(/*! doc-path */ \"(ssr)/../node_modules/doc-path/lib/path.js\");\nconst deeks_1 = __webpack_require__(/*! deeks */ \"(ssr)/../node_modules/deeks/lib/deeks.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/../node_modules/json-2-csv/lib/constants.js\");\nconst utils = __importStar(__webpack_require__(/*! ./utils */ \"(ssr)/../node_modules/json-2-csv/lib/utils.js\"));\nconst Json2Csv = function (options) {\n    const wrapDelimiterCheckRegex = new RegExp(options.delimiter.wrap, 'g'), crlfSearchRegex = /\\r?\\n|\\r/, customValueParser = options.parseValue && typeof options.parseValue === 'function' ? options.parseValue : null, expandingWithoutUnwinding = options.expandArrayObjects && !options.unwindArrays, deeksOptions = {\n        arrayIndexesAsKeys: options.arrayIndexesAsKeys,\n        expandNestedObjects: options.expandNestedObjects,\n        expandArrayObjects: expandingWithoutUnwinding,\n        ignoreEmptyArraysWhenExpanding: expandingWithoutUnwinding,\n        escapeNestedDots: true,\n    };\n    /** HEADER FIELD FUNCTIONS **/\n    /**\n     * Returns the list of data field names of all documents in the provided list\n     */\n    function getFieldNameList(data) {\n        // If keys weren't specified, then we'll use the list of keys generated by the deeks module\n        return (0, deeks_1.deepKeysFromList)(data, deeksOptions);\n    }\n    /**\n     * Processes the schemas by checking for schema differences, if so desired.\n     * If schema differences are not to be checked, then it resolves the unique\n     * list of field names.\n     */\n    function processSchemas(documentSchemas) {\n        // If there are no document schemas then there is nothing to diff and no unique fields to get\n        if (documentSchemas.length === 0) {\n            return [];\n        }\n        // If the user wants to check for the same schema (regardless of schema ordering)\n        if (options.checkSchemaDifferences) {\n            return checkSchemaDifferences(documentSchemas);\n        }\n        else {\n            // Otherwise, we do not care if the schemas are different, so we should get the unique list of keys\n            const uniqueFieldNames = utils.unique(utils.flatten(documentSchemas));\n            return uniqueFieldNames;\n        }\n    }\n    /**\n     * This function performs the schema difference check, if the user specifies that it should be checked.\n     * If there are no field names, then there are no differences.\n     * Otherwise, we get the first schema and the remaining list of schemas\n     */\n    function checkSchemaDifferences(documentSchemas) {\n        // have multiple documents - ensure only one schema (regardless of field ordering)\n        const firstDocSchema = documentSchemas[0], restOfDocumentSchemas = documentSchemas.slice(1), schemaDifferences = computeNumberOfSchemaDifferences(firstDocSchema, restOfDocumentSchemas);\n        // If there are schema inconsistencies, throw a schema not the same error\n        if (schemaDifferences) {\n            throw new Error(constants_1.errors.json2csv.notSameSchema);\n        }\n        return firstDocSchema;\n    }\n    /**\n     * Computes the number of schema differences\n     */\n    function computeNumberOfSchemaDifferences(firstDocSchema, restOfDocumentSchemas) {\n        return restOfDocumentSchemas.reduce((schemaDifferences, documentSchema) => {\n            // If there is a difference between the schemas, increment the counter of schema inconsistencies\n            const numberOfDifferences = utils.computeSchemaDifferences(firstDocSchema, documentSchema).length;\n            return numberOfDifferences > 0\n                ? schemaDifferences + 1\n                : schemaDifferences;\n        }, 0);\n    }\n    /**\n     * If so specified, this filters the detected key paths to exclude any keys that have been specified\n     */\n    function filterExcludedKeys(keyPaths) {\n        if (options.excludeKeys) {\n            return keyPaths.filter((keyPath) => {\n                for (const excludedKey of options.excludeKeys) {\n                    // Only match if the excludedKey appears at the beginning of the string so we don't accidentally match a key farther down in a key path\n                    const regex = excludedKey instanceof RegExp ? excludedKey : new RegExp(`^${excludedKey}`);\n                    if (excludedKey === keyPath || keyPath.match(regex)) {\n                        return false; // Exclude the key\n                    }\n                }\n                return true; // Otherwise, include the key\n            });\n        }\n        return keyPaths;\n    }\n    /**\n     * If so specified, this sorts the header field names alphabetically\n     */\n    function sortHeaderFields(fieldNames) {\n        if (options.sortHeader && typeof options.sortHeader === 'function') {\n            return fieldNames.sort(options.sortHeader);\n        }\n        else if (options.sortHeader) {\n            return fieldNames.sort();\n        }\n        return fieldNames;\n    }\n    /**\n     * Trims the header fields, if the user desires them to be trimmed.\n     */\n    function trimHeaderFields(params) {\n        if (options.trimHeaderFields) {\n            params.headerFields = params.headerFields.map((field) => field.split('.')\n                .map((component) => component.trim())\n                .join('.'));\n        }\n        return params;\n    }\n    /**\n     * Wrap the headings, if desired by the user.\n     */\n    function wrapHeaderFields(params) {\n        // only perform this if we are actually prepending the header\n        if (options.prependHeader) {\n            params.headerFields = params.headerFields.map(function (headingKey) {\n                return wrapFieldValueIfNecessary(headingKey);\n            });\n        }\n        return params;\n    }\n    /**\n     * Generates the CSV header string by joining the headerFields by the field delimiter\n     */\n    function generateCsvHeader(params) {\n        // #185 - generate a keys list to avoid finding native Map() methods\n        const fieldTitleMapKeys = Object.keys(options.fieldTitleMap);\n        params.header = params.headerFields\n            .map(function (field) {\n            let headerKey = field;\n            // If a custom field title was provided for this field, use that\n            if (fieldTitleMapKeys.includes(field)) {\n                headerKey = options.fieldTitleMap[field];\n            }\n            else if (!options.escapeHeaderNestedDots) {\n                // Otherwise, if the user doesn't want nested dots in keys to be escaped, then unescape them\n                headerKey = headerKey.replace(/\\\\\\./g, '.');\n            }\n            return headerKey;\n        })\n            .join(options.delimiter.field);\n        return params;\n    }\n    function convertKeysToHeaderFields() {\n        if (!options.keys)\n            return [];\n        return options.keys.map((key) => {\n            if (typeof key === 'object' && 'field' in key) {\n                options.fieldTitleMap[key.field] = key.title ?? key.field;\n                return key.field;\n            }\n            return key;\n        });\n    }\n    function extractWildcardMatchKeys() {\n        if (!options.keys)\n            return [];\n        return options.keys.flatMap(item => {\n            if (typeof item === 'string') {\n                // Exclude plain strings that were passed in options.keys\n                return [];\n            }\n            else if (item?.wildcardMatch) {\n                // Return \"field\" value for objects with wildcardMatch: true\n                return item.field;\n            }\n            // Exclude other objects\n            return [];\n        });\n    }\n    /**\n     * Retrieve the headings for all documents and return it.\n     * This checks that all documents have the same schema.\n     */\n    function retrieveHeaderFields(data) {\n        const wildcardMatchKeys = extractWildcardMatchKeys();\n        const keyStrings = convertKeysToHeaderFields();\n        const fieldNames = getFieldNameList(data);\n        const processed = processSchemas(fieldNames);\n        if (options.keys) {\n            options.keys = keyStrings;\n            const matchedKeys = keyStrings.flatMap((userProvidedKey) => {\n                // If this is not a wildcard matched key, then just return and include it in the resulting key list\n                if (!wildcardMatchKeys.includes(userProvidedKey)) {\n                    return userProvidedKey;\n                }\n                // Otherwise, identify all detected keys that match with the provided wildcard key:\n                const matches = [];\n                const regex = new RegExp(`^${userProvidedKey}`);\n                for (const detectedKey of processed) {\n                    if (userProvidedKey === detectedKey || detectedKey.match(regex)) {\n                        matches.push(detectedKey);\n                    }\n                }\n                return matches;\n            });\n            if (!options.unwindArrays) {\n                const filtered = filterExcludedKeys(matchedKeys);\n                return sortHeaderFields(filtered);\n            }\n        }\n        const filtered = filterExcludedKeys(processed);\n        return sortHeaderFields(filtered);\n    }\n    /** RECORD FIELD FUNCTIONS **/\n    function stillNeedsUnwind(params) {\n        for (const record of params.records) {\n            for (const field of params.headerFields) {\n                const value = (0, doc_path_1.evaluatePath)(record, field);\n                if (Array.isArray(value)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Unwinds objects in arrays within record objects if the user specifies the\n     * expandArrayObjects option. If not specified, this passes the params\n     * argument through to the next function in the promise chain.\n     *\n     * The `finalPass` parameter is used to trigger one last pass to ensure no more\n     * arrays need to be expanded\n     */\n    function unwindRecordsIfNecessary(params, finalPass = false) {\n        if (options.unwindArrays) {\n            // Unwind each document at each header field\n            params.headerFields.forEach((headerField) => {\n                params.records = utils.unwind(params.records, headerField);\n            });\n            params.headerFields = retrieveHeaderFields(params.records);\n            // Continue unwinding if any nested arrays remain\n            if (stillNeedsUnwind(params)) {\n                return unwindRecordsIfNecessary(params, finalPass);\n            }\n            // Run a final time in case the earlier unwinding exposed additional\n            // arrays to unwind...\n            if (!finalPass) {\n                return unwindRecordsIfNecessary(params, true);\n            }\n            // If keys were provided, set the headerFields back to the provided keys after unwinding:\n            if (options.keys) {\n                const userSelectedFields = convertKeysToHeaderFields();\n                params.headerFields = filterExcludedKeys(userSelectedFields);\n            }\n            return params;\n        }\n        return params;\n    }\n    /**\n     * Main function which handles the processing of a record, or document to be converted to CSV format\n     * This function specifies and performs the necessary operations in the necessary order\n     * in order to obtain the data and convert it to CSV form while maintaining RFC 4180 compliance.\n     * * Order of operations:\n     * - Get fields from provided key list (as array of actual values)\n     * - Convert the values to csv/string representation [possible option here for custom converters?]\n     * - Trim fields\n     * - Determine if they need to be wrapped (& wrap if necessary)\n     * - Combine values for each line (by joining by field delimiter)\n     */\n    function processRecords(params) {\n        params.recordString = params.records.map((record) => {\n            // Retrieve data for each of the headerFields from this record\n            const recordFieldData = retrieveRecordFieldData(record, params.headerFields), \n            // Process the data in this record and return the\n            processedRecordData = recordFieldData.map((fieldValue) => {\n                fieldValue = trimRecordFieldValue(fieldValue);\n                fieldValue = preventCsvInjection(fieldValue);\n                let stringified = customValueParser ? customValueParser(fieldValue, recordFieldValueToString) : recordFieldValueToString(fieldValue);\n                stringified = wrapFieldValueIfNecessary(stringified);\n                return stringified;\n            });\n            // Join the record data by the field delimiter\n            return generateCsvRowFromRecord(processedRecordData);\n        }).join(options.delimiter.eol);\n        return params;\n    }\n    /**\n     * Helper function intended to process *just* array values when the expandArrayObjects setting is set to true\n     */\n    function processRecordFieldDataForExpandedArrayObject(recordFieldValue) {\n        const filteredRecordFieldValue = utils.removeEmptyFields(recordFieldValue);\n        // If we have an array and it's either empty of full of empty values, then use an empty value representation\n        if (!recordFieldValue.length || !filteredRecordFieldValue.length) {\n            return options.emptyFieldValue || '';\n        }\n        else if (filteredRecordFieldValue.length === 1) {\n            // Otherwise, we have an array of actual values...\n            // Since we are expanding array objects, we will want to key in on values of objects.\n            return filteredRecordFieldValue[0]; // Extract the single value in the array\n        }\n        return recordFieldValue;\n    }\n    /**\n     * Gets all field values from a particular record for the given list of fields\n     */\n    function retrieveRecordFieldData(record, fields) {\n        const recordValues = [];\n        fields.forEach((field) => {\n            let recordFieldValue = (0, doc_path_1.evaluatePath)(record, field);\n            if (!utils.isUndefined(options.emptyFieldValue) && utils.isEmptyField(recordFieldValue)) {\n                recordFieldValue = options.emptyFieldValue;\n            }\n            else if (options.expandArrayObjects && Array.isArray(recordFieldValue)) {\n                recordFieldValue = processRecordFieldDataForExpandedArrayObject(recordFieldValue);\n            }\n            recordValues.push(recordFieldValue);\n        });\n        return recordValues;\n    }\n    /**\n     * Converts a record field value to its string representation\n     */\n    function recordFieldValueToString(fieldValue) {\n        const isDate = fieldValue instanceof Date; // store to avoid checking twice\n        if (fieldValue === null || Array.isArray(fieldValue) || typeof fieldValue === 'object' && !isDate) {\n            return JSON.stringify(fieldValue);\n        }\n        else if (typeof fieldValue === 'undefined') {\n            return 'undefined';\n        }\n        else if (isDate && options.useDateIso8601Format) {\n            return fieldValue.toISOString();\n        }\n        else {\n            return !options.useLocaleFormat ? fieldValue.toString() : fieldValue.toLocaleString();\n        }\n    }\n    /**\n     * Trims the record field value, if specified by the user's provided options\n     */\n    function trimRecordFieldValue(fieldValue) {\n        if (options.trimFieldValues) {\n            if (Array.isArray(fieldValue)) {\n                return fieldValue.map(trimRecordFieldValue);\n            }\n            else if (typeof fieldValue === 'string') {\n                return fieldValue.trim();\n            }\n            return fieldValue;\n        }\n        return fieldValue;\n    }\n    /**\n     * Prevent CSV injection on strings if specified by the user's provided options.\n     * Mitigation will be done by ensuring that the first character doesn't being with:\n     * Equals (=), Plus (+), Minus (-), At (@), Tab (0x09), Carriage return (0x0D).\n     * More info: https://owasp.org/www-community/attacks/CSV_Injection\n     */\n    function preventCsvInjection(fieldValue) {\n        if (options.preventCsvInjection) {\n            if (Array.isArray(fieldValue)) {\n                return fieldValue.map(preventCsvInjection);\n            }\n            else if (typeof fieldValue === 'string' && !utils.isNumber(fieldValue)) {\n                return fieldValue.replace(/^[=+\\-@\\t\\r]+/g, '');\n            }\n            return fieldValue;\n        }\n        return fieldValue;\n    }\n    /**\n     * Escapes quotation marks in the field value, if necessary, and appropriately\n     * wraps the record field value if it contains a comma (field delimiter),\n     * quotation mark (wrap delimiter), or a line break (CRLF)\n     */\n    function wrapFieldValueIfNecessary(fieldValue) {\n        const wrapDelimiter = options.delimiter.wrap;\n        // eg. includes quotation marks (default delimiter)\n        if (fieldValue.includes(options.delimiter.wrap)) {\n            // add an additional quotation mark before each quotation mark appearing in the field value\n            fieldValue = fieldValue.replace(wrapDelimiterCheckRegex, wrapDelimiter + wrapDelimiter);\n        }\n        // if the field contains a comma (field delimiter), quotation mark (wrap delimiter), line break, or CRLF\n        //   then enclose it in quotation marks (wrap delimiter)\n        if (fieldValue.includes(options.delimiter.field) ||\n            fieldValue.includes(options.delimiter.wrap) ||\n            fieldValue.match(crlfSearchRegex) ||\n            options.wrapBooleans && (fieldValue === 'true' || fieldValue === 'false')) {\n            // wrap the field's value in a wrap delimiter (quotation marks by default)\n            fieldValue = wrapDelimiter + fieldValue + wrapDelimiter;\n        }\n        return fieldValue;\n    }\n    /**\n     * Generates the CSV record string by joining the field values together by the field delimiter\n     */\n    function generateCsvRowFromRecord(recordFieldValues) {\n        return recordFieldValues.join(options.delimiter.field);\n    }\n    /** CSV COMPONENT COMBINER/FINAL PROCESSOR **/\n    /**\n     * Performs the final CSV construction by combining the fields in the appropriate\n     * order depending on the provided options values and sends the generated CSV\n     * back to the user\n     */\n    function generateCsvFromComponents(params) {\n        const header = params.header, records = params.recordString, \n        // If we are prepending the header, then add an EOL, otherwise just return the records\n        csv = (options.excelBOM ? constants_1.excelBOM : '') +\n            (options.prependHeader ? header + options.delimiter.eol : '') +\n            records;\n        return csv;\n    }\n    /** MAIN CONVERTER FUNCTION **/\n    /**\n     * Internally exported json2csv function\n     */\n    function convert(data) {\n        // Single document, not an array\n        if (!Array.isArray(data)) {\n            data = [data]; // Convert to an array of the given document\n        }\n        // Retrieve the heading and then generate the CSV with the keys that are identified\n        const headerFields = {\n            headerFields: retrieveHeaderFields(data),\n            records: data,\n            header: '',\n            recordString: '',\n        };\n        const unwinded = unwindRecordsIfNecessary(headerFields);\n        const processed = processRecords(unwinded);\n        const wrapped = wrapHeaderFields(processed);\n        const trimmed = trimHeaderFields(wrapped);\n        const generated = generateCsvHeader(trimmed);\n        return generateCsvFromComponents(generated);\n    }\n    return {\n        convert,\n    };\n};\nexports.Json2Csv = Json2Csv;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2pzb24tMi1jc3YvbGliL2pzb24yY3N2LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsbUJBQW1CLG1CQUFPLENBQUMsNERBQVU7QUFDckMsZ0JBQWdCLG1CQUFPLENBQUMsdURBQU87QUFDL0Isb0JBQW9CLG1CQUFPLENBQUMsc0VBQWE7QUFDekMsMkJBQTJCLG1CQUFPLENBQUMsOERBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixZQUFZO0FBQzNHO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGdCQUFnQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiIsInNvdXJjZXMiOlsiL1VzZXJzL0dhbG9jay9DUy9iZWhvbWUtc2l0ZS9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9saWIvanNvbjJjc3YuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkpzb24yQ3N2ID0gdm9pZCAwO1xuY29uc3QgZG9jX3BhdGhfMSA9IHJlcXVpcmUoXCJkb2MtcGF0aFwiKTtcbmNvbnN0IGRlZWtzXzEgPSByZXF1aXJlKFwiZGVla3NcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcbmNvbnN0IEpzb24yQ3N2ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBjb25zdCB3cmFwRGVsaW1pdGVyQ2hlY2tSZWdleCA9IG5ldyBSZWdFeHAob3B0aW9ucy5kZWxpbWl0ZXIud3JhcCwgJ2cnKSwgY3JsZlNlYXJjaFJlZ2V4ID0gL1xccj9cXG58XFxyLywgY3VzdG9tVmFsdWVQYXJzZXIgPSBvcHRpb25zLnBhcnNlVmFsdWUgJiYgdHlwZW9mIG9wdGlvbnMucGFyc2VWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMucGFyc2VWYWx1ZSA6IG51bGwsIGV4cGFuZGluZ1dpdGhvdXRVbndpbmRpbmcgPSBvcHRpb25zLmV4cGFuZEFycmF5T2JqZWN0cyAmJiAhb3B0aW9ucy51bndpbmRBcnJheXMsIGRlZWtzT3B0aW9ucyA9IHtcbiAgICAgICAgYXJyYXlJbmRleGVzQXNLZXlzOiBvcHRpb25zLmFycmF5SW5kZXhlc0FzS2V5cyxcbiAgICAgICAgZXhwYW5kTmVzdGVkT2JqZWN0czogb3B0aW9ucy5leHBhbmROZXN0ZWRPYmplY3RzLFxuICAgICAgICBleHBhbmRBcnJheU9iamVjdHM6IGV4cGFuZGluZ1dpdGhvdXRVbndpbmRpbmcsXG4gICAgICAgIGlnbm9yZUVtcHR5QXJyYXlzV2hlbkV4cGFuZGluZzogZXhwYW5kaW5nV2l0aG91dFVud2luZGluZyxcbiAgICAgICAgZXNjYXBlTmVzdGVkRG90czogdHJ1ZSxcbiAgICB9O1xuICAgIC8qKiBIRUFERVIgRklFTEQgRlVOQ1RJT05TICoqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgZGF0YSBmaWVsZCBuYW1lcyBvZiBhbGwgZG9jdW1lbnRzIGluIHRoZSBwcm92aWRlZCBsaXN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0RmllbGROYW1lTGlzdChkYXRhKSB7XG4gICAgICAgIC8vIElmIGtleXMgd2VyZW4ndCBzcGVjaWZpZWQsIHRoZW4gd2UnbGwgdXNlIHRoZSBsaXN0IG9mIGtleXMgZ2VuZXJhdGVkIGJ5IHRoZSBkZWVrcyBtb2R1bGVcbiAgICAgICAgcmV0dXJuICgwLCBkZWVrc18xLmRlZXBLZXlzRnJvbUxpc3QpKGRhdGEsIGRlZWtzT3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyB0aGUgc2NoZW1hcyBieSBjaGVja2luZyBmb3Igc2NoZW1hIGRpZmZlcmVuY2VzLCBpZiBzbyBkZXNpcmVkLlxuICAgICAqIElmIHNjaGVtYSBkaWZmZXJlbmNlcyBhcmUgbm90IHRvIGJlIGNoZWNrZWQsIHRoZW4gaXQgcmVzb2x2ZXMgdGhlIHVuaXF1ZVxuICAgICAqIGxpc3Qgb2YgZmllbGQgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1NjaGVtYXMoZG9jdW1lbnRTY2hlbWFzKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBkb2N1bWVudCBzY2hlbWFzIHRoZW4gdGhlcmUgaXMgbm90aGluZyB0byBkaWZmIGFuZCBubyB1bmlxdWUgZmllbGRzIHRvIGdldFxuICAgICAgICBpZiAoZG9jdW1lbnRTY2hlbWFzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIHdhbnRzIHRvIGNoZWNrIGZvciB0aGUgc2FtZSBzY2hlbWEgKHJlZ2FyZGxlc3Mgb2Ygc2NoZW1hIG9yZGVyaW5nKVxuICAgICAgICBpZiAob3B0aW9ucy5jaGVja1NjaGVtYURpZmZlcmVuY2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tTY2hlbWFEaWZmZXJlbmNlcyhkb2N1bWVudFNjaGVtYXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBkbyBub3QgY2FyZSBpZiB0aGUgc2NoZW1hcyBhcmUgZGlmZmVyZW50LCBzbyB3ZSBzaG91bGQgZ2V0IHRoZSB1bmlxdWUgbGlzdCBvZiBrZXlzXG4gICAgICAgICAgICBjb25zdCB1bmlxdWVGaWVsZE5hbWVzID0gdXRpbHMudW5pcXVlKHV0aWxzLmZsYXR0ZW4oZG9jdW1lbnRTY2hlbWFzKSk7XG4gICAgICAgICAgICByZXR1cm4gdW5pcXVlRmllbGROYW1lcztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHBlcmZvcm1zIHRoZSBzY2hlbWEgZGlmZmVyZW5jZSBjaGVjaywgaWYgdGhlIHVzZXIgc3BlY2lmaWVzIHRoYXQgaXQgc2hvdWxkIGJlIGNoZWNrZWQuXG4gICAgICogSWYgdGhlcmUgYXJlIG5vIGZpZWxkIG5hbWVzLCB0aGVuIHRoZXJlIGFyZSBubyBkaWZmZXJlbmNlcy5cbiAgICAgKiBPdGhlcndpc2UsIHdlIGdldCB0aGUgZmlyc3Qgc2NoZW1hIGFuZCB0aGUgcmVtYWluaW5nIGxpc3Qgb2Ygc2NoZW1hc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoZWNrU2NoZW1hRGlmZmVyZW5jZXMoZG9jdW1lbnRTY2hlbWFzKSB7XG4gICAgICAgIC8vIGhhdmUgbXVsdGlwbGUgZG9jdW1lbnRzIC0gZW5zdXJlIG9ubHkgb25lIHNjaGVtYSAocmVnYXJkbGVzcyBvZiBmaWVsZCBvcmRlcmluZylcbiAgICAgICAgY29uc3QgZmlyc3REb2NTY2hlbWEgPSBkb2N1bWVudFNjaGVtYXNbMF0sIHJlc3RPZkRvY3VtZW50U2NoZW1hcyA9IGRvY3VtZW50U2NoZW1hcy5zbGljZSgxKSwgc2NoZW1hRGlmZmVyZW5jZXMgPSBjb21wdXRlTnVtYmVyT2ZTY2hlbWFEaWZmZXJlbmNlcyhmaXJzdERvY1NjaGVtYSwgcmVzdE9mRG9jdW1lbnRTY2hlbWFzKTtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIHNjaGVtYSBpbmNvbnNpc3RlbmNpZXMsIHRocm93IGEgc2NoZW1hIG5vdCB0aGUgc2FtZSBlcnJvclxuICAgICAgICBpZiAoc2NoZW1hRGlmZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihjb25zdGFudHNfMS5lcnJvcnMuanNvbjJjc3Yubm90U2FtZVNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpcnN0RG9jU2NoZW1hO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbnVtYmVyIG9mIHNjaGVtYSBkaWZmZXJlbmNlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXB1dGVOdW1iZXJPZlNjaGVtYURpZmZlcmVuY2VzKGZpcnN0RG9jU2NoZW1hLCByZXN0T2ZEb2N1bWVudFNjaGVtYXMpIHtcbiAgICAgICAgcmV0dXJuIHJlc3RPZkRvY3VtZW50U2NoZW1hcy5yZWR1Y2UoKHNjaGVtYURpZmZlcmVuY2VzLCBkb2N1bWVudFNjaGVtYSkgPT4ge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHNjaGVtYXMsIGluY3JlbWVudCB0aGUgY291bnRlciBvZiBzY2hlbWEgaW5jb25zaXN0ZW5jaWVzXG4gICAgICAgICAgICBjb25zdCBudW1iZXJPZkRpZmZlcmVuY2VzID0gdXRpbHMuY29tcHV0ZVNjaGVtYURpZmZlcmVuY2VzKGZpcnN0RG9jU2NoZW1hLCBkb2N1bWVudFNjaGVtYSkubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlck9mRGlmZmVyZW5jZXMgPiAwXG4gICAgICAgICAgICAgICAgPyBzY2hlbWFEaWZmZXJlbmNlcyArIDFcbiAgICAgICAgICAgICAgICA6IHNjaGVtYURpZmZlcmVuY2VzO1xuICAgICAgICB9LCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgc28gc3BlY2lmaWVkLCB0aGlzIGZpbHRlcnMgdGhlIGRldGVjdGVkIGtleSBwYXRocyB0byBleGNsdWRlIGFueSBrZXlzIHRoYXQgaGF2ZSBiZWVuIHNwZWNpZmllZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbHRlckV4Y2x1ZGVkS2V5cyhrZXlQYXRocykge1xuICAgICAgICBpZiAob3B0aW9ucy5leGNsdWRlS2V5cykge1xuICAgICAgICAgICAgcmV0dXJuIGtleVBhdGhzLmZpbHRlcigoa2V5UGF0aCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZXhjbHVkZWRLZXkgb2Ygb3B0aW9ucy5leGNsdWRlS2V5cykge1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IG1hdGNoIGlmIHRoZSBleGNsdWRlZEtleSBhcHBlYXJzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHN0cmluZyBzbyB3ZSBkb24ndCBhY2NpZGVudGFsbHkgbWF0Y2ggYSBrZXkgZmFydGhlciBkb3duIGluIGEga2V5IHBhdGhcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBleGNsdWRlZEtleSBpbnN0YW5jZW9mIFJlZ0V4cCA/IGV4Y2x1ZGVkS2V5IDogbmV3IFJlZ0V4cChgXiR7ZXhjbHVkZWRLZXl9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleGNsdWRlZEtleSA9PT0ga2V5UGF0aCB8fCBrZXlQYXRoLm1hdGNoKHJlZ2V4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBFeGNsdWRlIHRoZSBrZXlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gT3RoZXJ3aXNlLCBpbmNsdWRlIHRoZSBrZXlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlQYXRocztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgc28gc3BlY2lmaWVkLCB0aGlzIHNvcnRzIHRoZSBoZWFkZXIgZmllbGQgbmFtZXMgYWxwaGFiZXRpY2FsbHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0SGVhZGVyRmllbGRzKGZpZWxkTmFtZXMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc29ydEhlYWRlciAmJiB0eXBlb2Ygb3B0aW9ucy5zb3J0SGVhZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGROYW1lcy5zb3J0KG9wdGlvbnMuc29ydEhlYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5zb3J0SGVhZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGROYW1lcy5zb3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkTmFtZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaW1zIHRoZSBoZWFkZXIgZmllbGRzLCBpZiB0aGUgdXNlciBkZXNpcmVzIHRoZW0gdG8gYmUgdHJpbW1lZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltSGVhZGVyRmllbGRzKHBhcmFtcykge1xuICAgICAgICBpZiAob3B0aW9ucy50cmltSGVhZGVyRmllbGRzKSB7XG4gICAgICAgICAgICBwYXJhbXMuaGVhZGVyRmllbGRzID0gcGFyYW1zLmhlYWRlckZpZWxkcy5tYXAoKGZpZWxkKSA9PiBmaWVsZC5zcGxpdCgnLicpXG4gICAgICAgICAgICAgICAgLm1hcCgoY29tcG9uZW50KSA9PiBjb21wb25lbnQudHJpbSgpKVxuICAgICAgICAgICAgICAgIC5qb2luKCcuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyYXAgdGhlIGhlYWRpbmdzLCBpZiBkZXNpcmVkIGJ5IHRoZSB1c2VyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBIZWFkZXJGaWVsZHMocGFyYW1zKSB7XG4gICAgICAgIC8vIG9ubHkgcGVyZm9ybSB0aGlzIGlmIHdlIGFyZSBhY3R1YWxseSBwcmVwZW5kaW5nIHRoZSBoZWFkZXJcbiAgICAgICAgaWYgKG9wdGlvbnMucHJlcGVuZEhlYWRlcikge1xuICAgICAgICAgICAgcGFyYW1zLmhlYWRlckZpZWxkcyA9IHBhcmFtcy5oZWFkZXJGaWVsZHMubWFwKGZ1bmN0aW9uIChoZWFkaW5nS2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBGaWVsZFZhbHVlSWZOZWNlc3NhcnkoaGVhZGluZ0tleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgdGhlIENTViBoZWFkZXIgc3RyaW5nIGJ5IGpvaW5pbmcgdGhlIGhlYWRlckZpZWxkcyBieSB0aGUgZmllbGQgZGVsaW1pdGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVDc3ZIZWFkZXIocGFyYW1zKSB7XG4gICAgICAgIC8vICMxODUgLSBnZW5lcmF0ZSBhIGtleXMgbGlzdCB0byBhdm9pZCBmaW5kaW5nIG5hdGl2ZSBNYXAoKSBtZXRob2RzXG4gICAgICAgIGNvbnN0IGZpZWxkVGl0bGVNYXBLZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucy5maWVsZFRpdGxlTWFwKTtcbiAgICAgICAgcGFyYW1zLmhlYWRlciA9IHBhcmFtcy5oZWFkZXJGaWVsZHNcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICBsZXQgaGVhZGVyS2V5ID0gZmllbGQ7XG4gICAgICAgICAgICAvLyBJZiBhIGN1c3RvbSBmaWVsZCB0aXRsZSB3YXMgcHJvdmlkZWQgZm9yIHRoaXMgZmllbGQsIHVzZSB0aGF0XG4gICAgICAgICAgICBpZiAoZmllbGRUaXRsZU1hcEtleXMuaW5jbHVkZXMoZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyS2V5ID0gb3B0aW9ucy5maWVsZFRpdGxlTWFwW2ZpZWxkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFvcHRpb25zLmVzY2FwZUhlYWRlck5lc3RlZERvdHMpIHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGlmIHRoZSB1c2VyIGRvZXNuJ3Qgd2FudCBuZXN0ZWQgZG90cyBpbiBrZXlzIHRvIGJlIGVzY2FwZWQsIHRoZW4gdW5lc2NhcGUgdGhlbVxuICAgICAgICAgICAgICAgIGhlYWRlcktleSA9IGhlYWRlcktleS5yZXBsYWNlKC9cXFxcXFwuL2csICcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGVhZGVyS2V5O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4ob3B0aW9ucy5kZWxpbWl0ZXIuZmllbGQpO1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb252ZXJ0S2V5c1RvSGVhZGVyRmllbGRzKCkge1xuICAgICAgICBpZiAoIW9wdGlvbnMua2V5cylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMua2V5cy5tYXAoKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnICYmICdmaWVsZCcgaW4ga2V5KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5maWVsZFRpdGxlTWFwW2tleS5maWVsZF0gPSBrZXkudGl0bGUgPz8ga2V5LmZpZWxkO1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXkuZmllbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXh0cmFjdFdpbGRjYXJkTWF0Y2hLZXlzKCkge1xuICAgICAgICBpZiAoIW9wdGlvbnMua2V5cylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMua2V5cy5mbGF0TWFwKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIEV4Y2x1ZGUgcGxhaW4gc3RyaW5ncyB0aGF0IHdlcmUgcGFzc2VkIGluIG9wdGlvbnMua2V5c1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0/LndpbGRjYXJkTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gXCJmaWVsZFwiIHZhbHVlIGZvciBvYmplY3RzIHdpdGggd2lsZGNhcmRNYXRjaDogdHJ1ZVxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmZpZWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRXhjbHVkZSBvdGhlciBvYmplY3RzXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgaGVhZGluZ3MgZm9yIGFsbCBkb2N1bWVudHMgYW5kIHJldHVybiBpdC5cbiAgICAgKiBUaGlzIGNoZWNrcyB0aGF0IGFsbCBkb2N1bWVudHMgaGF2ZSB0aGUgc2FtZSBzY2hlbWEuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV0cmlldmVIZWFkZXJGaWVsZHMoZGF0YSkge1xuICAgICAgICBjb25zdCB3aWxkY2FyZE1hdGNoS2V5cyA9IGV4dHJhY3RXaWxkY2FyZE1hdGNoS2V5cygpO1xuICAgICAgICBjb25zdCBrZXlTdHJpbmdzID0gY29udmVydEtleXNUb0hlYWRlckZpZWxkcygpO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gZ2V0RmllbGROYW1lTGlzdChkYXRhKTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gcHJvY2Vzc1NjaGVtYXMoZmllbGROYW1lcyk7XG4gICAgICAgIGlmIChvcHRpb25zLmtleXMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMua2V5cyA9IGtleVN0cmluZ3M7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVkS2V5cyA9IGtleVN0cmluZ3MuZmxhdE1hcCgodXNlclByb3ZpZGVkS2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgYSB3aWxkY2FyZCBtYXRjaGVkIGtleSwgdGhlbiBqdXN0IHJldHVybiBhbmQgaW5jbHVkZSBpdCBpbiB0aGUgcmVzdWx0aW5nIGtleSBsaXN0XG4gICAgICAgICAgICAgICAgaWYgKCF3aWxkY2FyZE1hdGNoS2V5cy5pbmNsdWRlcyh1c2VyUHJvdmlkZWRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1c2VyUHJvdmlkZWRLZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaWRlbnRpZnkgYWxsIGRldGVjdGVkIGtleXMgdGhhdCBtYXRjaCB3aXRoIHRoZSBwcm92aWRlZCB3aWxkY2FyZCBrZXk6XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXiR7dXNlclByb3ZpZGVkS2V5fWApO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZGV0ZWN0ZWRLZXkgb2YgcHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VyUHJvdmlkZWRLZXkgPT09IGRldGVjdGVkS2V5IHx8IGRldGVjdGVkS2V5Lm1hdGNoKHJlZ2V4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKGRldGVjdGVkS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnVud2luZEFycmF5cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkID0gZmlsdGVyRXhjbHVkZWRLZXlzKG1hdGNoZWRLZXlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc29ydEhlYWRlckZpZWxkcyhmaWx0ZXJlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBmaWx0ZXJFeGNsdWRlZEtleXMocHJvY2Vzc2VkKTtcbiAgICAgICAgcmV0dXJuIHNvcnRIZWFkZXJGaWVsZHMoZmlsdGVyZWQpO1xuICAgIH1cbiAgICAvKiogUkVDT1JEIEZJRUxEIEZVTkNUSU9OUyAqKi9cbiAgICBmdW5jdGlvbiBzdGlsbE5lZWRzVW53aW5kKHBhcmFtcykge1xuICAgICAgICBmb3IgKGNvbnN0IHJlY29yZCBvZiBwYXJhbXMucmVjb3Jkcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBwYXJhbXMuaGVhZGVyRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSAoMCwgZG9jX3BhdGhfMS5ldmFsdWF0ZVBhdGgpKHJlY29yZCwgZmllbGQpO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbndpbmRzIG9iamVjdHMgaW4gYXJyYXlzIHdpdGhpbiByZWNvcmQgb2JqZWN0cyBpZiB0aGUgdXNlciBzcGVjaWZpZXMgdGhlXG4gICAgICogZXhwYW5kQXJyYXlPYmplY3RzIG9wdGlvbi4gSWYgbm90IHNwZWNpZmllZCwgdGhpcyBwYXNzZXMgdGhlIHBhcmFtc1xuICAgICAqIGFyZ3VtZW50IHRocm91Z2ggdG8gdGhlIG5leHQgZnVuY3Rpb24gaW4gdGhlIHByb21pc2UgY2hhaW4uXG4gICAgICpcbiAgICAgKiBUaGUgYGZpbmFsUGFzc2AgcGFyYW1ldGVyIGlzIHVzZWQgdG8gdHJpZ2dlciBvbmUgbGFzdCBwYXNzIHRvIGVuc3VyZSBubyBtb3JlXG4gICAgICogYXJyYXlzIG5lZWQgdG8gYmUgZXhwYW5kZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bndpbmRSZWNvcmRzSWZOZWNlc3NhcnkocGFyYW1zLCBmaW5hbFBhc3MgPSBmYWxzZSkge1xuICAgICAgICBpZiAob3B0aW9ucy51bndpbmRBcnJheXMpIHtcbiAgICAgICAgICAgIC8vIFVud2luZCBlYWNoIGRvY3VtZW50IGF0IGVhY2ggaGVhZGVyIGZpZWxkXG4gICAgICAgICAgICBwYXJhbXMuaGVhZGVyRmllbGRzLmZvckVhY2goKGhlYWRlckZpZWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnJlY29yZHMgPSB1dGlscy51bndpbmQocGFyYW1zLnJlY29yZHMsIGhlYWRlckZpZWxkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGFyYW1zLmhlYWRlckZpZWxkcyA9IHJldHJpZXZlSGVhZGVyRmllbGRzKHBhcmFtcy5yZWNvcmRzKTtcbiAgICAgICAgICAgIC8vIENvbnRpbnVlIHVud2luZGluZyBpZiBhbnkgbmVzdGVkIGFycmF5cyByZW1haW5cbiAgICAgICAgICAgIGlmIChzdGlsbE5lZWRzVW53aW5kKHBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW53aW5kUmVjb3Jkc0lmTmVjZXNzYXJ5KHBhcmFtcywgZmluYWxQYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJ1biBhIGZpbmFsIHRpbWUgaW4gY2FzZSB0aGUgZWFybGllciB1bndpbmRpbmcgZXhwb3NlZCBhZGRpdGlvbmFsXG4gICAgICAgICAgICAvLyBhcnJheXMgdG8gdW53aW5kLi4uXG4gICAgICAgICAgICBpZiAoIWZpbmFsUGFzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bndpbmRSZWNvcmRzSWZOZWNlc3NhcnkocGFyYW1zLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGtleXMgd2VyZSBwcm92aWRlZCwgc2V0IHRoZSBoZWFkZXJGaWVsZHMgYmFjayB0byB0aGUgcHJvdmlkZWQga2V5cyBhZnRlciB1bndpbmRpbmc6XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5rZXlzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXNlclNlbGVjdGVkRmllbGRzID0gY29udmVydEtleXNUb0hlYWRlckZpZWxkcygpO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5oZWFkZXJGaWVsZHMgPSBmaWx0ZXJFeGNsdWRlZEtleXModXNlclNlbGVjdGVkRmllbGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFpbiBmdW5jdGlvbiB3aGljaCBoYW5kbGVzIHRoZSBwcm9jZXNzaW5nIG9mIGEgcmVjb3JkLCBvciBkb2N1bWVudCB0byBiZSBjb252ZXJ0ZWQgdG8gQ1NWIGZvcm1hdFxuICAgICAqIFRoaXMgZnVuY3Rpb24gc3BlY2lmaWVzIGFuZCBwZXJmb3JtcyB0aGUgbmVjZXNzYXJ5IG9wZXJhdGlvbnMgaW4gdGhlIG5lY2Vzc2FyeSBvcmRlclxuICAgICAqIGluIG9yZGVyIHRvIG9idGFpbiB0aGUgZGF0YSBhbmQgY29udmVydCBpdCB0byBDU1YgZm9ybSB3aGlsZSBtYWludGFpbmluZyBSRkMgNDE4MCBjb21wbGlhbmNlLlxuICAgICAqICogT3JkZXIgb2Ygb3BlcmF0aW9uczpcbiAgICAgKiAtIEdldCBmaWVsZHMgZnJvbSBwcm92aWRlZCBrZXkgbGlzdCAoYXMgYXJyYXkgb2YgYWN0dWFsIHZhbHVlcylcbiAgICAgKiAtIENvbnZlcnQgdGhlIHZhbHVlcyB0byBjc3Yvc3RyaW5nIHJlcHJlc2VudGF0aW9uIFtwb3NzaWJsZSBvcHRpb24gaGVyZSBmb3IgY3VzdG9tIGNvbnZlcnRlcnM/XVxuICAgICAqIC0gVHJpbSBmaWVsZHNcbiAgICAgKiAtIERldGVybWluZSBpZiB0aGV5IG5lZWQgdG8gYmUgd3JhcHBlZCAoJiB3cmFwIGlmIG5lY2Vzc2FyeSlcbiAgICAgKiAtIENvbWJpbmUgdmFsdWVzIGZvciBlYWNoIGxpbmUgKGJ5IGpvaW5pbmcgYnkgZmllbGQgZGVsaW1pdGVyKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NSZWNvcmRzKHBhcmFtcykge1xuICAgICAgICBwYXJhbXMucmVjb3JkU3RyaW5nID0gcGFyYW1zLnJlY29yZHMubWFwKChyZWNvcmQpID0+IHtcbiAgICAgICAgICAgIC8vIFJldHJpZXZlIGRhdGEgZm9yIGVhY2ggb2YgdGhlIGhlYWRlckZpZWxkcyBmcm9tIHRoaXMgcmVjb3JkXG4gICAgICAgICAgICBjb25zdCByZWNvcmRGaWVsZERhdGEgPSByZXRyaWV2ZVJlY29yZEZpZWxkRGF0YShyZWNvcmQsIHBhcmFtcy5oZWFkZXJGaWVsZHMpLCBcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIGRhdGEgaW4gdGhpcyByZWNvcmQgYW5kIHJldHVybiB0aGVcbiAgICAgICAgICAgIHByb2Nlc3NlZFJlY29yZERhdGEgPSByZWNvcmRGaWVsZERhdGEubWFwKChmaWVsZFZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgZmllbGRWYWx1ZSA9IHRyaW1SZWNvcmRGaWVsZFZhbHVlKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgICAgIGZpZWxkVmFsdWUgPSBwcmV2ZW50Q3N2SW5qZWN0aW9uKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgICAgIGxldCBzdHJpbmdpZmllZCA9IGN1c3RvbVZhbHVlUGFyc2VyID8gY3VzdG9tVmFsdWVQYXJzZXIoZmllbGRWYWx1ZSwgcmVjb3JkRmllbGRWYWx1ZVRvU3RyaW5nKSA6IHJlY29yZEZpZWxkVmFsdWVUb1N0cmluZyhmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgICAgICBzdHJpbmdpZmllZCA9IHdyYXBGaWVsZFZhbHVlSWZOZWNlc3Nhcnkoc3RyaW5naWZpZWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZmllZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gSm9pbiB0aGUgcmVjb3JkIGRhdGEgYnkgdGhlIGZpZWxkIGRlbGltaXRlclxuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlQ3N2Um93RnJvbVJlY29yZChwcm9jZXNzZWRSZWNvcmREYXRhKTtcbiAgICAgICAgfSkuam9pbihvcHRpb25zLmRlbGltaXRlci5lb2wpO1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gaW50ZW5kZWQgdG8gcHJvY2VzcyAqanVzdCogYXJyYXkgdmFsdWVzIHdoZW4gdGhlIGV4cGFuZEFycmF5T2JqZWN0cyBzZXR0aW5nIGlzIHNldCB0byB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1JlY29yZEZpZWxkRGF0YUZvckV4cGFuZGVkQXJyYXlPYmplY3QocmVjb3JkRmllbGRWYWx1ZSkge1xuICAgICAgICBjb25zdCBmaWx0ZXJlZFJlY29yZEZpZWxkVmFsdWUgPSB1dGlscy5yZW1vdmVFbXB0eUZpZWxkcyhyZWNvcmRGaWVsZFZhbHVlKTtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBhcnJheSBhbmQgaXQncyBlaXRoZXIgZW1wdHkgb2YgZnVsbCBvZiBlbXB0eSB2YWx1ZXMsIHRoZW4gdXNlIGFuIGVtcHR5IHZhbHVlIHJlcHJlc2VudGF0aW9uXG4gICAgICAgIGlmICghcmVjb3JkRmllbGRWYWx1ZS5sZW5ndGggfHwgIWZpbHRlcmVkUmVjb3JkRmllbGRWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmVtcHR5RmllbGRWYWx1ZSB8fCAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaWx0ZXJlZFJlY29yZEZpZWxkVmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlIGhhdmUgYW4gYXJyYXkgb2YgYWN0dWFsIHZhbHVlcy4uLlxuICAgICAgICAgICAgLy8gU2luY2Ugd2UgYXJlIGV4cGFuZGluZyBhcnJheSBvYmplY3RzLCB3ZSB3aWxsIHdhbnQgdG8ga2V5IGluIG9uIHZhbHVlcyBvZiBvYmplY3RzLlxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmVkUmVjb3JkRmllbGRWYWx1ZVswXTsgLy8gRXh0cmFjdCB0aGUgc2luZ2xlIHZhbHVlIGluIHRoZSBhcnJheVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWNvcmRGaWVsZFZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBmaWVsZCB2YWx1ZXMgZnJvbSBhIHBhcnRpY3VsYXIgcmVjb3JkIGZvciB0aGUgZ2l2ZW4gbGlzdCBvZiBmaWVsZHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXRyaWV2ZVJlY29yZEZpZWxkRGF0YShyZWNvcmQsIGZpZWxkcykge1xuICAgICAgICBjb25zdCByZWNvcmRWYWx1ZXMgPSBbXTtcbiAgICAgICAgZmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVjb3JkRmllbGRWYWx1ZSA9ICgwLCBkb2NfcGF0aF8xLmV2YWx1YXRlUGF0aCkocmVjb3JkLCBmaWVsZCk7XG4gICAgICAgICAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKG9wdGlvbnMuZW1wdHlGaWVsZFZhbHVlKSAmJiB1dGlscy5pc0VtcHR5RmllbGQocmVjb3JkRmllbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZWNvcmRGaWVsZFZhbHVlID0gb3B0aW9ucy5lbXB0eUZpZWxkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmV4cGFuZEFycmF5T2JqZWN0cyAmJiBBcnJheS5pc0FycmF5KHJlY29yZEZpZWxkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkRmllbGRWYWx1ZSA9IHByb2Nlc3NSZWNvcmRGaWVsZERhdGFGb3JFeHBhbmRlZEFycmF5T2JqZWN0KHJlY29yZEZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVjb3JkVmFsdWVzLnB1c2gocmVjb3JkRmllbGRWYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVjb3JkVmFsdWVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHJlY29yZCBmaWVsZCB2YWx1ZSB0byBpdHMgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVjb3JkRmllbGRWYWx1ZVRvU3RyaW5nKGZpZWxkVmFsdWUpIHtcbiAgICAgICAgY29uc3QgaXNEYXRlID0gZmllbGRWYWx1ZSBpbnN0YW5jZW9mIERhdGU7IC8vIHN0b3JlIHRvIGF2b2lkIGNoZWNraW5nIHR3aWNlXG4gICAgICAgIGlmIChmaWVsZFZhbHVlID09PSBudWxsIHx8IEFycmF5LmlzQXJyYXkoZmllbGRWYWx1ZSkgfHwgdHlwZW9mIGZpZWxkVmFsdWUgPT09ICdvYmplY3QnICYmICFpc0RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShmaWVsZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZmllbGRWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0RhdGUgJiYgb3B0aW9ucy51c2VEYXRlSXNvODYwMUZvcm1hdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWUudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAhb3B0aW9ucy51c2VMb2NhbGVGb3JtYXQgPyBmaWVsZFZhbHVlLnRvU3RyaW5nKCkgOiBmaWVsZFZhbHVlLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpbXMgdGhlIHJlY29yZCBmaWVsZCB2YWx1ZSwgaWYgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyJ3MgcHJvdmlkZWQgb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1SZWNvcmRGaWVsZFZhbHVlKGZpZWxkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMudHJpbUZpZWxkVmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWVsZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZFZhbHVlLm1hcCh0cmltUmVjb3JkRmllbGRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZmllbGRWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmllbGRWYWx1ZS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmllbGRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmllbGRWYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJldmVudCBDU1YgaW5qZWN0aW9uIG9uIHN0cmluZ3MgaWYgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyJ3MgcHJvdmlkZWQgb3B0aW9ucy5cbiAgICAgKiBNaXRpZ2F0aW9uIHdpbGwgYmUgZG9uZSBieSBlbnN1cmluZyB0aGF0IHRoZSBmaXJzdCBjaGFyYWN0ZXIgZG9lc24ndCBiZWluZyB3aXRoOlxuICAgICAqIEVxdWFscyAoPSksIFBsdXMgKCspLCBNaW51cyAoLSksIEF0IChAKSwgVGFiICgweDA5KSwgQ2FycmlhZ2UgcmV0dXJuICgweDBEKS5cbiAgICAgKiBNb3JlIGluZm86IGh0dHBzOi8vb3dhc3Aub3JnL3d3dy1jb21tdW5pdHkvYXR0YWNrcy9DU1ZfSW5qZWN0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJldmVudENzdkluamVjdGlvbihmaWVsZFZhbHVlKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnByZXZlbnRDc3ZJbmplY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpZWxkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWUubWFwKHByZXZlbnRDc3ZJbmplY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZpZWxkVmFsdWUgPT09ICdzdHJpbmcnICYmICF1dGlscy5pc051bWJlcihmaWVsZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZFZhbHVlLnJlcGxhY2UoL15bPStcXC1AXFx0XFxyXSsvZywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVzY2FwZXMgcXVvdGF0aW9uIG1hcmtzIGluIHRoZSBmaWVsZCB2YWx1ZSwgaWYgbmVjZXNzYXJ5LCBhbmQgYXBwcm9wcmlhdGVseVxuICAgICAqIHdyYXBzIHRoZSByZWNvcmQgZmllbGQgdmFsdWUgaWYgaXQgY29udGFpbnMgYSBjb21tYSAoZmllbGQgZGVsaW1pdGVyKSxcbiAgICAgKiBxdW90YXRpb24gbWFyayAod3JhcCBkZWxpbWl0ZXIpLCBvciBhIGxpbmUgYnJlYWsgKENSTEYpXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcEZpZWxkVmFsdWVJZk5lY2Vzc2FyeShmaWVsZFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHdyYXBEZWxpbWl0ZXIgPSBvcHRpb25zLmRlbGltaXRlci53cmFwO1xuICAgICAgICAvLyBlZy4gaW5jbHVkZXMgcXVvdGF0aW9uIG1hcmtzIChkZWZhdWx0IGRlbGltaXRlcilcbiAgICAgICAgaWYgKGZpZWxkVmFsdWUuaW5jbHVkZXMob3B0aW9ucy5kZWxpbWl0ZXIud3JhcCkpIHtcbiAgICAgICAgICAgIC8vIGFkZCBhbiBhZGRpdGlvbmFsIHF1b3RhdGlvbiBtYXJrIGJlZm9yZSBlYWNoIHF1b3RhdGlvbiBtYXJrIGFwcGVhcmluZyBpbiB0aGUgZmllbGQgdmFsdWVcbiAgICAgICAgICAgIGZpZWxkVmFsdWUgPSBmaWVsZFZhbHVlLnJlcGxhY2Uod3JhcERlbGltaXRlckNoZWNrUmVnZXgsIHdyYXBEZWxpbWl0ZXIgKyB3cmFwRGVsaW1pdGVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgZmllbGQgY29udGFpbnMgYSBjb21tYSAoZmllbGQgZGVsaW1pdGVyKSwgcXVvdGF0aW9uIG1hcmsgKHdyYXAgZGVsaW1pdGVyKSwgbGluZSBicmVhaywgb3IgQ1JMRlxuICAgICAgICAvLyAgIHRoZW4gZW5jbG9zZSBpdCBpbiBxdW90YXRpb24gbWFya3MgKHdyYXAgZGVsaW1pdGVyKVxuICAgICAgICBpZiAoZmllbGRWYWx1ZS5pbmNsdWRlcyhvcHRpb25zLmRlbGltaXRlci5maWVsZCkgfHxcbiAgICAgICAgICAgIGZpZWxkVmFsdWUuaW5jbHVkZXMob3B0aW9ucy5kZWxpbWl0ZXIud3JhcCkgfHxcbiAgICAgICAgICAgIGZpZWxkVmFsdWUubWF0Y2goY3JsZlNlYXJjaFJlZ2V4KSB8fFxuICAgICAgICAgICAgb3B0aW9ucy53cmFwQm9vbGVhbnMgJiYgKGZpZWxkVmFsdWUgPT09ICd0cnVlJyB8fCBmaWVsZFZhbHVlID09PSAnZmFsc2UnKSkge1xuICAgICAgICAgICAgLy8gd3JhcCB0aGUgZmllbGQncyB2YWx1ZSBpbiBhIHdyYXAgZGVsaW1pdGVyIChxdW90YXRpb24gbWFya3MgYnkgZGVmYXVsdClcbiAgICAgICAgICAgIGZpZWxkVmFsdWUgPSB3cmFwRGVsaW1pdGVyICsgZmllbGRWYWx1ZSArIHdyYXBEZWxpbWl0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB0aGUgQ1NWIHJlY29yZCBzdHJpbmcgYnkgam9pbmluZyB0aGUgZmllbGQgdmFsdWVzIHRvZ2V0aGVyIGJ5IHRoZSBmaWVsZCBkZWxpbWl0ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUNzdlJvd0Zyb21SZWNvcmQocmVjb3JkRmllbGRWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHJlY29yZEZpZWxkVmFsdWVzLmpvaW4ob3B0aW9ucy5kZWxpbWl0ZXIuZmllbGQpO1xuICAgIH1cbiAgICAvKiogQ1NWIENPTVBPTkVOVCBDT01CSU5FUi9GSU5BTCBQUk9DRVNTT1IgKiovXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIGZpbmFsIENTViBjb25zdHJ1Y3Rpb24gYnkgY29tYmluaW5nIHRoZSBmaWVsZHMgaW4gdGhlIGFwcHJvcHJpYXRlXG4gICAgICogb3JkZXIgZGVwZW5kaW5nIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zIHZhbHVlcyBhbmQgc2VuZHMgdGhlIGdlbmVyYXRlZCBDU1ZcbiAgICAgKiBiYWNrIHRvIHRoZSB1c2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVDc3ZGcm9tQ29tcG9uZW50cyhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gcGFyYW1zLmhlYWRlciwgcmVjb3JkcyA9IHBhcmFtcy5yZWNvcmRTdHJpbmcsIFxuICAgICAgICAvLyBJZiB3ZSBhcmUgcHJlcGVuZGluZyB0aGUgaGVhZGVyLCB0aGVuIGFkZCBhbiBFT0wsIG90aGVyd2lzZSBqdXN0IHJldHVybiB0aGUgcmVjb3Jkc1xuICAgICAgICBjc3YgPSAob3B0aW9ucy5leGNlbEJPTSA/IGNvbnN0YW50c18xLmV4Y2VsQk9NIDogJycpICtcbiAgICAgICAgICAgIChvcHRpb25zLnByZXBlbmRIZWFkZXIgPyBoZWFkZXIgKyBvcHRpb25zLmRlbGltaXRlci5lb2wgOiAnJykgK1xuICAgICAgICAgICAgcmVjb3JkcztcbiAgICAgICAgcmV0dXJuIGNzdjtcbiAgICB9XG4gICAgLyoqIE1BSU4gQ09OVkVSVEVSIEZVTkNUSU9OICoqL1xuICAgIC8qKlxuICAgICAqIEludGVybmFsbHkgZXhwb3J0ZWQganNvbjJjc3YgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb252ZXJ0KGRhdGEpIHtcbiAgICAgICAgLy8gU2luZ2xlIGRvY3VtZW50LCBub3QgYW4gYXJyYXlcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICBkYXRhID0gW2RhdGFdOyAvLyBDb252ZXJ0IHRvIGFuIGFycmF5IG9mIHRoZSBnaXZlbiBkb2N1bWVudFxuICAgICAgICB9XG4gICAgICAgIC8vIFJldHJpZXZlIHRoZSBoZWFkaW5nIGFuZCB0aGVuIGdlbmVyYXRlIHRoZSBDU1Ygd2l0aCB0aGUga2V5cyB0aGF0IGFyZSBpZGVudGlmaWVkXG4gICAgICAgIGNvbnN0IGhlYWRlckZpZWxkcyA9IHtcbiAgICAgICAgICAgIGhlYWRlckZpZWxkczogcmV0cmlldmVIZWFkZXJGaWVsZHMoZGF0YSksXG4gICAgICAgICAgICByZWNvcmRzOiBkYXRhLFxuICAgICAgICAgICAgaGVhZGVyOiAnJyxcbiAgICAgICAgICAgIHJlY29yZFN0cmluZzogJycsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHVud2luZGVkID0gdW53aW5kUmVjb3Jkc0lmTmVjZXNzYXJ5KGhlYWRlckZpZWxkcyk7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IHByb2Nlc3NSZWNvcmRzKHVud2luZGVkKTtcbiAgICAgICAgY29uc3Qgd3JhcHBlZCA9IHdyYXBIZWFkZXJGaWVsZHMocHJvY2Vzc2VkKTtcbiAgICAgICAgY29uc3QgdHJpbW1lZCA9IHRyaW1IZWFkZXJGaWVsZHMod3JhcHBlZCk7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRlZCA9IGdlbmVyYXRlQ3N2SGVhZGVyKHRyaW1tZWQpO1xuICAgICAgICByZXR1cm4gZ2VuZXJhdGVDc3ZGcm9tQ29tcG9uZW50cyhnZW5lcmF0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjb252ZXJ0LFxuICAgIH07XG59O1xuZXhwb3J0cy5Kc29uMkNzdiA9IEpzb24yQ3N2O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/json-2-csv/lib/json2csv.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/json-2-csv/lib/utils.js":
/*!***********************************************!*\
  !*** ../node_modules/json-2-csv/lib/utils.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isInvalid = exports.flatten = exports.unique = exports.arrayDifference = exports.isError = exports.isUndefined = exports.isNull = exports.isObject = exports.isString = exports.isNumber = exports.unwind = exports.getNCharacters = exports.removeEmptyFields = exports.isEmptyField = exports.computeSchemaDifferences = exports.isDateRepresentation = exports.isStringRepresentation = exports.deepCopy = exports.validate = exports.buildC2JOptions = exports.buildJ2COptions = void 0;\nconst doc_path_1 = __webpack_require__(/*! doc-path */ \"(ssr)/../node_modules/doc-path/lib/path.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/../node_modules/json-2-csv/lib/constants.js\");\nconst dateStringRegex = /\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.\\d{3}Z/, MAX_ARRAY_LENGTH = 100000;\n/**\n * Build the options to be passed to the appropriate function\n * If a user does not provide custom options, then we use our default\n * If options are provided, then we set each valid key that was passed\n */\nfunction buildJ2COptions(opts) {\n    return {\n        ...constants_1.defaultJson2CsvOptions,\n        ...opts,\n        delimiter: {\n            field: opts?.delimiter?.field ?? constants_1.defaultJson2CsvOptions.delimiter.field,\n            wrap: opts?.delimiter?.wrap || constants_1.defaultJson2CsvOptions.delimiter.wrap,\n            eol: opts?.delimiter?.eol || constants_1.defaultJson2CsvOptions.delimiter.eol,\n        },\n        fieldTitleMap: Object.create({}),\n    };\n}\nexports.buildJ2COptions = buildJ2COptions;\n/**\n * Build the options to be passed to the appropriate function\n * If a user does not provide custom options, then we use our default\n * If options are provided, then we set each valid key that was passed\n */\nfunction buildC2JOptions(opts) {\n    return {\n        ...constants_1.defaultCsv2JsonOptions,\n        ...opts,\n        delimiter: {\n            field: opts?.delimiter?.field ?? constants_1.defaultCsv2JsonOptions.delimiter.field,\n            wrap: opts?.delimiter?.wrap || constants_1.defaultCsv2JsonOptions.delimiter.wrap,\n            eol: opts?.delimiter?.eol || constants_1.defaultCsv2JsonOptions.delimiter.eol,\n        },\n    };\n}\nexports.buildC2JOptions = buildC2JOptions;\nfunction validate(data, validationFn, errorMessages) {\n    if (!data)\n        throw new Error(`${errorMessages.cannotCallOn} ${data}.`);\n    if (!validationFn(data))\n        throw new Error(errorMessages.dataCheckFailure);\n    return true;\n}\nexports.validate = validate;\n/**\n * Utility function to deep copy an object, used by the module tests\n */\nfunction deepCopy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\nexports.deepCopy = deepCopy;\n/**\n * Helper function that determines whether the provided value is a representation\n *   of a string. Given the RFC4180 requirements, that means that the value is\n *   wrapped in value wrap delimiters (usually a quotation mark on each side).\n */\nfunction isStringRepresentation(fieldValue, options) {\n    const firstChar = fieldValue[0], lastIndex = fieldValue.length - 1, lastChar = fieldValue[lastIndex];\n    // If the field starts and ends with a wrap delimiter\n    return firstChar === options.delimiter.wrap && lastChar === options.delimiter.wrap;\n}\nexports.isStringRepresentation = isStringRepresentation;\n/**\n * Helper function that determines whether the provided value is a representation\n *   of a date.\n */\nfunction isDateRepresentation(fieldValue) {\n    return dateStringRegex.test(fieldValue);\n}\nexports.isDateRepresentation = isDateRepresentation;\n/**\n * Helper function that determines the schema differences between two objects.\n */\nfunction computeSchemaDifferences(schemaA, schemaB) {\n    return arrayDifference(schemaA, schemaB)\n        .concat(arrayDifference(schemaB, schemaA));\n}\nexports.computeSchemaDifferences = computeSchemaDifferences;\n/**\n * Utility function to check if a field is considered empty so that the emptyFieldValue can be used instead\n */\nfunction isEmptyField(fieldValue) {\n    return isUndefined(fieldValue) || isNull(fieldValue) || fieldValue === '';\n}\nexports.isEmptyField = isEmptyField;\n/**\n * Helper function that removes empty field values from an array.\n */\nfunction removeEmptyFields(fields) {\n    return fields.filter((field) => !isEmptyField(field));\n}\nexports.removeEmptyFields = removeEmptyFields;\n/**\n * Helper function that retrieves the next n characters from the start index in\n *   the string including the character at the start index. This is used to\n *   check if are currently at an EOL value, since it could be multiple\n *   characters in length (eg. '\\r\\n')\n */\nfunction getNCharacters(str, start, n) {\n    return str.substring(start, start + n);\n}\nexports.getNCharacters = getNCharacters;\n/**\n * The following unwind functionality is a heavily modified version of @edwincen's\n * unwind extension for lodash. Since lodash is a large package to require in,\n * and all of the required functionality was already being imported, either\n * natively or with doc-path, I decided to rewrite the majority of the logic\n * so that an additional dependency would not be required. The original code\n * with the lodash dependency can be found here:\n *\n * https://github.com/edwincen/unwind/blob/master/index.js\n */\n/**\n * Core function that unwinds an item at the provided path\n */\nfunction unwindItem(accumulator, item, fieldPath) {\n    const valueToUnwind = (0, doc_path_1.evaluatePath)(item, fieldPath);\n    let cloned = deepCopy(item);\n    if (Array.isArray(valueToUnwind) && valueToUnwind.length) {\n        valueToUnwind.forEach((val) => {\n            cloned = deepCopy(item);\n            accumulator.push((0, doc_path_1.setPath)(cloned, fieldPath, val));\n        });\n    }\n    else if (Array.isArray(valueToUnwind) && valueToUnwind.length === 0) {\n        // Push an empty string so the value is empty since there are no values\n        (0, doc_path_1.setPath)(cloned, fieldPath, '');\n        accumulator.push(cloned);\n    }\n    else {\n        accumulator.push(cloned);\n    }\n}\n/**\n * Main unwind function which takes an array and a field to unwind.\n */\nfunction unwind(array, field) {\n    const result = [];\n    array.forEach((item) => {\n        unwindItem(result, item, field);\n    });\n    return result;\n}\nexports.unwind = unwind;\n/**\n * Checks whether value can be converted to a number\n */\nfunction isNumber(value) {\n    return !isNaN(Number(value));\n}\nexports.isNumber = isNumber;\n/*\n * Helper functions which were created to remove underscorejs from this package.\n */\nfunction isString(value) {\n    return typeof value === 'string';\n}\nexports.isString = isString;\nfunction isObject(value) {\n    return typeof value === 'object';\n}\nexports.isObject = isObject;\nfunction isNull(value) {\n    return value === null;\n}\nexports.isNull = isNull;\nfunction isUndefined(value) {\n    return typeof value === 'undefined';\n}\nexports.isUndefined = isUndefined;\nfunction isError(value) {\n    // TODO(mrodrig): test this possible change\n    // return value instanceof Error;\n    return Object.prototype.toString.call(value) === '[object Error]';\n}\nexports.isError = isError;\nfunction arrayDifference(a, b) {\n    return a.filter((x) => !b.includes(x));\n}\nexports.arrayDifference = arrayDifference;\nfunction unique(array) {\n    return [...new Set(array)];\n}\nexports.unique = unique;\nfunction flatten(array) {\n    // Node 11+ - use the native array flattening function\n    if (array.flat) {\n        return array.flat();\n    }\n    // #167 - allow browsers to flatten very long 200k+ element arrays\n    if (array.length > MAX_ARRAY_LENGTH) {\n        let safeArray = [];\n        for (let a = 0; a < array.length; a += MAX_ARRAY_LENGTH) {\n            safeArray = safeArray.concat(...array.slice(a, a + MAX_ARRAY_LENGTH));\n        }\n        return safeArray;\n    }\n    return array.reduce((accumulator, value) => accumulator.concat(value), []);\n}\nexports.flatten = flatten;\n/**\n * Used to help avoid incorrect values returned by JSON.parse when converting\n * CSV back to JSON, such as '39e1804' which JSON.parse converts to Infinity\n */\nfunction isInvalid(parsedJson) {\n    return parsedJson === Infinity ||\n        parsedJson === -Infinity;\n}\nexports.isInvalid = isInvalid;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2pzb24tMi1jc3YvbGliL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLGVBQWUsR0FBRyxjQUFjLEdBQUcsdUJBQXVCLEdBQUcsZUFBZSxHQUFHLG1CQUFtQixHQUFHLGNBQWMsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxjQUFjLEdBQUcsc0JBQXNCLEdBQUcseUJBQXlCLEdBQUcsb0JBQW9CLEdBQUcsZ0NBQWdDLEdBQUcsNEJBQTRCLEdBQUcsOEJBQThCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsdUJBQXVCLEdBQUcsdUJBQXVCO0FBQzFkLG1CQUFtQixtQkFBTyxDQUFDLDREQUFVO0FBQ3JDLG9CQUFvQixtQkFBTyxDQUFDLHNFQUFhO0FBQ3pDLDRCQUE0QixFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLDJCQUEyQiw0QkFBNEIsRUFBRSxLQUFLO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiIsInNvdXJjZXMiOlsiL1VzZXJzL0dhbG9jay9DUy9iZWhvbWUtc2l0ZS9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9saWIvdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0ludmFsaWQgPSBleHBvcnRzLmZsYXR0ZW4gPSBleHBvcnRzLnVuaXF1ZSA9IGV4cG9ydHMuYXJyYXlEaWZmZXJlbmNlID0gZXhwb3J0cy5pc0Vycm9yID0gZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGV4cG9ydHMuaXNOdWxsID0gZXhwb3J0cy5pc09iamVjdCA9IGV4cG9ydHMuaXNTdHJpbmcgPSBleHBvcnRzLmlzTnVtYmVyID0gZXhwb3J0cy51bndpbmQgPSBleHBvcnRzLmdldE5DaGFyYWN0ZXJzID0gZXhwb3J0cy5yZW1vdmVFbXB0eUZpZWxkcyA9IGV4cG9ydHMuaXNFbXB0eUZpZWxkID0gZXhwb3J0cy5jb21wdXRlU2NoZW1hRGlmZmVyZW5jZXMgPSBleHBvcnRzLmlzRGF0ZVJlcHJlc2VudGF0aW9uID0gZXhwb3J0cy5pc1N0cmluZ1JlcHJlc2VudGF0aW9uID0gZXhwb3J0cy5kZWVwQ29weSA9IGV4cG9ydHMudmFsaWRhdGUgPSBleHBvcnRzLmJ1aWxkQzJKT3B0aW9ucyA9IGV4cG9ydHMuYnVpbGRKMkNPcHRpb25zID0gdm9pZCAwO1xuY29uc3QgZG9jX3BhdGhfMSA9IHJlcXVpcmUoXCJkb2MtcGF0aFwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZGF0ZVN0cmluZ1JlZ2V4ID0gL1xcZHs0fS1cXGR7Mn0tXFxkezJ9VFxcZHsyfTpcXGR7Mn06XFxkezJ9LlxcZHszfVovLCBNQVhfQVJSQVlfTEVOR1RIID0gMTAwMDAwO1xuLyoqXG4gKiBCdWlsZCB0aGUgb3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gdGhlIGFwcHJvcHJpYXRlIGZ1bmN0aW9uXG4gKiBJZiBhIHVzZXIgZG9lcyBub3QgcHJvdmlkZSBjdXN0b20gb3B0aW9ucywgdGhlbiB3ZSB1c2Ugb3VyIGRlZmF1bHRcbiAqIElmIG9wdGlvbnMgYXJlIHByb3ZpZGVkLCB0aGVuIHdlIHNldCBlYWNoIHZhbGlkIGtleSB0aGF0IHdhcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gYnVpbGRKMkNPcHRpb25zKG9wdHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5jb25zdGFudHNfMS5kZWZhdWx0SnNvbjJDc3ZPcHRpb25zLFxuICAgICAgICAuLi5vcHRzLFxuICAgICAgICBkZWxpbWl0ZXI6IHtcbiAgICAgICAgICAgIGZpZWxkOiBvcHRzPy5kZWxpbWl0ZXI/LmZpZWxkID8/IGNvbnN0YW50c18xLmRlZmF1bHRKc29uMkNzdk9wdGlvbnMuZGVsaW1pdGVyLmZpZWxkLFxuICAgICAgICAgICAgd3JhcDogb3B0cz8uZGVsaW1pdGVyPy53cmFwIHx8IGNvbnN0YW50c18xLmRlZmF1bHRKc29uMkNzdk9wdGlvbnMuZGVsaW1pdGVyLndyYXAsXG4gICAgICAgICAgICBlb2w6IG9wdHM/LmRlbGltaXRlcj8uZW9sIHx8IGNvbnN0YW50c18xLmRlZmF1bHRKc29uMkNzdk9wdGlvbnMuZGVsaW1pdGVyLmVvbCxcbiAgICAgICAgfSxcbiAgICAgICAgZmllbGRUaXRsZU1hcDogT2JqZWN0LmNyZWF0ZSh7fSksXG4gICAgfTtcbn1cbmV4cG9ydHMuYnVpbGRKMkNPcHRpb25zID0gYnVpbGRKMkNPcHRpb25zO1xuLyoqXG4gKiBCdWlsZCB0aGUgb3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gdGhlIGFwcHJvcHJpYXRlIGZ1bmN0aW9uXG4gKiBJZiBhIHVzZXIgZG9lcyBub3QgcHJvdmlkZSBjdXN0b20gb3B0aW9ucywgdGhlbiB3ZSB1c2Ugb3VyIGRlZmF1bHRcbiAqIElmIG9wdGlvbnMgYXJlIHByb3ZpZGVkLCB0aGVuIHdlIHNldCBlYWNoIHZhbGlkIGtleSB0aGF0IHdhcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gYnVpbGRDMkpPcHRpb25zKG9wdHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5jb25zdGFudHNfMS5kZWZhdWx0Q3N2Mkpzb25PcHRpb25zLFxuICAgICAgICAuLi5vcHRzLFxuICAgICAgICBkZWxpbWl0ZXI6IHtcbiAgICAgICAgICAgIGZpZWxkOiBvcHRzPy5kZWxpbWl0ZXI/LmZpZWxkID8/IGNvbnN0YW50c18xLmRlZmF1bHRDc3YySnNvbk9wdGlvbnMuZGVsaW1pdGVyLmZpZWxkLFxuICAgICAgICAgICAgd3JhcDogb3B0cz8uZGVsaW1pdGVyPy53cmFwIHx8IGNvbnN0YW50c18xLmRlZmF1bHRDc3YySnNvbk9wdGlvbnMuZGVsaW1pdGVyLndyYXAsXG4gICAgICAgICAgICBlb2w6IG9wdHM/LmRlbGltaXRlcj8uZW9sIHx8IGNvbnN0YW50c18xLmRlZmF1bHRDc3YySnNvbk9wdGlvbnMuZGVsaW1pdGVyLmVvbCxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0cy5idWlsZEMySk9wdGlvbnMgPSBidWlsZEMySk9wdGlvbnM7XG5mdW5jdGlvbiB2YWxpZGF0ZShkYXRhLCB2YWxpZGF0aW9uRm4sIGVycm9yTWVzc2FnZXMpIHtcbiAgICBpZiAoIWRhdGEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtlcnJvck1lc3NhZ2VzLmNhbm5vdENhbGxPbn0gJHtkYXRhfS5gKTtcbiAgICBpZiAoIXZhbGlkYXRpb25GbihkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZXMuZGF0YUNoZWNrRmFpbHVyZSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGU7XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gZGVlcCBjb3B5IGFuIG9iamVjdCwgdXNlZCBieSB0aGUgbW9kdWxlIHRlc3RzXG4gKi9cbmZ1bmN0aW9uIGRlZXBDb3B5KG9iaikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xufVxuZXhwb3J0cy5kZWVwQ29weSA9IGRlZXBDb3B5O1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGEgcmVwcmVzZW50YXRpb25cbiAqICAgb2YgYSBzdHJpbmcuIEdpdmVuIHRoZSBSRkM0MTgwIHJlcXVpcmVtZW50cywgdGhhdCBtZWFucyB0aGF0IHRoZSB2YWx1ZSBpc1xuICogICB3cmFwcGVkIGluIHZhbHVlIHdyYXAgZGVsaW1pdGVycyAodXN1YWxseSBhIHF1b3RhdGlvbiBtYXJrIG9uIGVhY2ggc2lkZSkuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nUmVwcmVzZW50YXRpb24oZmllbGRWYWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZpcnN0Q2hhciA9IGZpZWxkVmFsdWVbMF0sIGxhc3RJbmRleCA9IGZpZWxkVmFsdWUubGVuZ3RoIC0gMSwgbGFzdENoYXIgPSBmaWVsZFZhbHVlW2xhc3RJbmRleF07XG4gICAgLy8gSWYgdGhlIGZpZWxkIHN0YXJ0cyBhbmQgZW5kcyB3aXRoIGEgd3JhcCBkZWxpbWl0ZXJcbiAgICByZXR1cm4gZmlyc3RDaGFyID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwICYmIGxhc3RDaGFyID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwO1xufVxuZXhwb3J0cy5pc1N0cmluZ1JlcHJlc2VudGF0aW9uID0gaXNTdHJpbmdSZXByZXNlbnRhdGlvbjtcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBhIHJlcHJlc2VudGF0aW9uXG4gKiAgIG9mIGEgZGF0ZS5cbiAqL1xuZnVuY3Rpb24gaXNEYXRlUmVwcmVzZW50YXRpb24oZmllbGRWYWx1ZSkge1xuICAgIHJldHVybiBkYXRlU3RyaW5nUmVnZXgudGVzdChmaWVsZFZhbHVlKTtcbn1cbmV4cG9ydHMuaXNEYXRlUmVwcmVzZW50YXRpb24gPSBpc0RhdGVSZXByZXNlbnRhdGlvbjtcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB0aGUgc2NoZW1hIGRpZmZlcmVuY2VzIGJldHdlZW4gdHdvIG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVTY2hlbWFEaWZmZXJlbmNlcyhzY2hlbWFBLCBzY2hlbWFCKSB7XG4gICAgcmV0dXJuIGFycmF5RGlmZmVyZW5jZShzY2hlbWFBLCBzY2hlbWFCKVxuICAgICAgICAuY29uY2F0KGFycmF5RGlmZmVyZW5jZShzY2hlbWFCLCBzY2hlbWFBKSk7XG59XG5leHBvcnRzLmNvbXB1dGVTY2hlbWFEaWZmZXJlbmNlcyA9IGNvbXB1dGVTY2hlbWFEaWZmZXJlbmNlcztcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0byBjaGVjayBpZiBhIGZpZWxkIGlzIGNvbnNpZGVyZWQgZW1wdHkgc28gdGhhdCB0aGUgZW1wdHlGaWVsZFZhbHVlIGNhbiBiZSB1c2VkIGluc3RlYWRcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eUZpZWxkKGZpZWxkVmFsdWUpIHtcbiAgICByZXR1cm4gaXNVbmRlZmluZWQoZmllbGRWYWx1ZSkgfHwgaXNOdWxsKGZpZWxkVmFsdWUpIHx8IGZpZWxkVmFsdWUgPT09ICcnO1xufVxuZXhwb3J0cy5pc0VtcHR5RmllbGQgPSBpc0VtcHR5RmllbGQ7XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IHJlbW92ZXMgZW1wdHkgZmllbGQgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUVtcHR5RmllbGRzKGZpZWxkcykge1xuICAgIHJldHVybiBmaWVsZHMuZmlsdGVyKChmaWVsZCkgPT4gIWlzRW1wdHlGaWVsZChmaWVsZCkpO1xufVxuZXhwb3J0cy5yZW1vdmVFbXB0eUZpZWxkcyA9IHJlbW92ZUVtcHR5RmllbGRzO1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCByZXRyaWV2ZXMgdGhlIG5leHQgbiBjaGFyYWN0ZXJzIGZyb20gdGhlIHN0YXJ0IGluZGV4IGluXG4gKiAgIHRoZSBzdHJpbmcgaW5jbHVkaW5nIHRoZSBjaGFyYWN0ZXIgYXQgdGhlIHN0YXJ0IGluZGV4LiBUaGlzIGlzIHVzZWQgdG9cbiAqICAgY2hlY2sgaWYgYXJlIGN1cnJlbnRseSBhdCBhbiBFT0wgdmFsdWUsIHNpbmNlIGl0IGNvdWxkIGJlIG11bHRpcGxlXG4gKiAgIGNoYXJhY3RlcnMgaW4gbGVuZ3RoIChlZy4gJ1xcclxcbicpXG4gKi9cbmZ1bmN0aW9uIGdldE5DaGFyYWN0ZXJzKHN0ciwgc3RhcnQsIG4pIHtcbiAgICByZXR1cm4gc3RyLnN1YnN0cmluZyhzdGFydCwgc3RhcnQgKyBuKTtcbn1cbmV4cG9ydHMuZ2V0TkNoYXJhY3RlcnMgPSBnZXROQ2hhcmFjdGVycztcbi8qKlxuICogVGhlIGZvbGxvd2luZyB1bndpbmQgZnVuY3Rpb25hbGl0eSBpcyBhIGhlYXZpbHkgbW9kaWZpZWQgdmVyc2lvbiBvZiBAZWR3aW5jZW4nc1xuICogdW53aW5kIGV4dGVuc2lvbiBmb3IgbG9kYXNoLiBTaW5jZSBsb2Rhc2ggaXMgYSBsYXJnZSBwYWNrYWdlIHRvIHJlcXVpcmUgaW4sXG4gKiBhbmQgYWxsIG9mIHRoZSByZXF1aXJlZCBmdW5jdGlvbmFsaXR5IHdhcyBhbHJlYWR5IGJlaW5nIGltcG9ydGVkLCBlaXRoZXJcbiAqIG5hdGl2ZWx5IG9yIHdpdGggZG9jLXBhdGgsIEkgZGVjaWRlZCB0byByZXdyaXRlIHRoZSBtYWpvcml0eSBvZiB0aGUgbG9naWNcbiAqIHNvIHRoYXQgYW4gYWRkaXRpb25hbCBkZXBlbmRlbmN5IHdvdWxkIG5vdCBiZSByZXF1aXJlZC4gVGhlIG9yaWdpbmFsIGNvZGVcbiAqIHdpdGggdGhlIGxvZGFzaCBkZXBlbmRlbmN5IGNhbiBiZSBmb3VuZCBoZXJlOlxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9lZHdpbmNlbi91bndpbmQvYmxvYi9tYXN0ZXIvaW5kZXguanNcbiAqL1xuLyoqXG4gKiBDb3JlIGZ1bmN0aW9uIHRoYXQgdW53aW5kcyBhbiBpdGVtIGF0IHRoZSBwcm92aWRlZCBwYXRoXG4gKi9cbmZ1bmN0aW9uIHVud2luZEl0ZW0oYWNjdW11bGF0b3IsIGl0ZW0sIGZpZWxkUGF0aCkge1xuICAgIGNvbnN0IHZhbHVlVG9VbndpbmQgPSAoMCwgZG9jX3BhdGhfMS5ldmFsdWF0ZVBhdGgpKGl0ZW0sIGZpZWxkUGF0aCk7XG4gICAgbGV0IGNsb25lZCA9IGRlZXBDb3B5KGl0ZW0pO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlVG9VbndpbmQpICYmIHZhbHVlVG9VbndpbmQubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlVG9VbndpbmQuZm9yRWFjaCgodmFsKSA9PiB7XG4gICAgICAgICAgICBjbG9uZWQgPSBkZWVwQ29weShpdGVtKTtcbiAgICAgICAgICAgIGFjY3VtdWxhdG9yLnB1c2goKDAsIGRvY19wYXRoXzEuc2V0UGF0aCkoY2xvbmVkLCBmaWVsZFBhdGgsIHZhbCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVRvVW53aW5kKSAmJiB2YWx1ZVRvVW53aW5kLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBQdXNoIGFuIGVtcHR5IHN0cmluZyBzbyB0aGUgdmFsdWUgaXMgZW1wdHkgc2luY2UgdGhlcmUgYXJlIG5vIHZhbHVlc1xuICAgICAgICAoMCwgZG9jX3BhdGhfMS5zZXRQYXRoKShjbG9uZWQsIGZpZWxkUGF0aCwgJycpO1xuICAgICAgICBhY2N1bXVsYXRvci5wdXNoKGNsb25lZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhY2N1bXVsYXRvci5wdXNoKGNsb25lZCk7XG4gICAgfVxufVxuLyoqXG4gKiBNYWluIHVud2luZCBmdW5jdGlvbiB3aGljaCB0YWtlcyBhbiBhcnJheSBhbmQgYSBmaWVsZCB0byB1bndpbmQuXG4gKi9cbmZ1bmN0aW9uIHVud2luZChhcnJheSwgZmllbGQpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBhcnJheS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIHVud2luZEl0ZW0ocmVzdWx0LCBpdGVtLCBmaWVsZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMudW53aW5kID0gdW53aW5kO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB2YWx1ZSBjYW4gYmUgY29udmVydGVkIHRvIGEgbnVtYmVyXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuICFpc05hTihOdW1iZXIodmFsdWUpKTtcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIHdoaWNoIHdlcmUgY3JlYXRlZCB0byByZW1vdmUgdW5kZXJzY29yZWpzIGZyb20gdGhpcyBwYWNrYWdlLlxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jztcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbmZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcbmZ1bmN0aW9uIGlzRXJyb3IodmFsdWUpIHtcbiAgICAvLyBUT0RPKG1yb2RyaWcpOiB0ZXN0IHRoaXMgcG9zc2libGUgY2hhbmdlXG4gICAgLy8gcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRXJyb3I7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEVycm9yXSc7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuZnVuY3Rpb24gYXJyYXlEaWZmZXJlbmNlKGEsIGIpIHtcbiAgICByZXR1cm4gYS5maWx0ZXIoKHgpID0+ICFiLmluY2x1ZGVzKHgpKTtcbn1cbmV4cG9ydHMuYXJyYXlEaWZmZXJlbmNlID0gYXJyYXlEaWZmZXJlbmNlO1xuZnVuY3Rpb24gdW5pcXVlKGFycmF5KSB7XG4gICAgcmV0dXJuIFsuLi5uZXcgU2V0KGFycmF5KV07XG59XG5leHBvcnRzLnVuaXF1ZSA9IHVuaXF1ZTtcbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcbiAgICAvLyBOb2RlIDExKyAtIHVzZSB0aGUgbmF0aXZlIGFycmF5IGZsYXR0ZW5pbmcgZnVuY3Rpb25cbiAgICBpZiAoYXJyYXkuZmxhdCkge1xuICAgICAgICByZXR1cm4gYXJyYXkuZmxhdCgpO1xuICAgIH1cbiAgICAvLyAjMTY3IC0gYWxsb3cgYnJvd3NlcnMgdG8gZmxhdHRlbiB2ZXJ5IGxvbmcgMjAwaysgZWxlbWVudCBhcnJheXNcbiAgICBpZiAoYXJyYXkubGVuZ3RoID4gTUFYX0FSUkFZX0xFTkdUSCkge1xuICAgICAgICBsZXQgc2FmZUFycmF5ID0gW107XG4gICAgICAgIGZvciAobGV0IGEgPSAwOyBhIDwgYXJyYXkubGVuZ3RoOyBhICs9IE1BWF9BUlJBWV9MRU5HVEgpIHtcbiAgICAgICAgICAgIHNhZmVBcnJheSA9IHNhZmVBcnJheS5jb25jYXQoLi4uYXJyYXkuc2xpY2UoYSwgYSArIE1BWF9BUlJBWV9MRU5HVEgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2FmZUFycmF5O1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXkucmVkdWNlKChhY2N1bXVsYXRvciwgdmFsdWUpID0+IGFjY3VtdWxhdG9yLmNvbmNhdCh2YWx1ZSksIFtdKTtcbn1cbmV4cG9ydHMuZmxhdHRlbiA9IGZsYXR0ZW47XG4vKipcbiAqIFVzZWQgdG8gaGVscCBhdm9pZCBpbmNvcnJlY3QgdmFsdWVzIHJldHVybmVkIGJ5IEpTT04ucGFyc2Ugd2hlbiBjb252ZXJ0aW5nXG4gKiBDU1YgYmFjayB0byBKU09OLCBzdWNoIGFzICczOWUxODA0JyB3aGljaCBKU09OLnBhcnNlIGNvbnZlcnRzIHRvIEluZmluaXR5XG4gKi9cbmZ1bmN0aW9uIGlzSW52YWxpZChwYXJzZWRKc29uKSB7XG4gICAgcmV0dXJuIHBhcnNlZEpzb24gPT09IEluZmluaXR5IHx8XG4gICAgICAgIHBhcnNlZEpzb24gPT09IC1JbmZpbml0eTtcbn1cbmV4cG9ydHMuaXNJbnZhbGlkID0gaXNJbnZhbGlkO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/json-2-csv/lib/utils.js\n");

/***/ })

};
;