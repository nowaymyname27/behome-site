"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/groq-js";
exports.ids = ["vendor-chunks/groq-js"];
exports.modules = {

/***/ "(ssr)/../node_modules/groq-js/dist/1.mjs":
/*!******************************************!*\
  !*** ../node_modules/groq-js/dist/1.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DateTime: () => (/* binding */ DateTime),\n/* harmony export */   Path: () => (/* binding */ Path),\n/* harmony export */   createReferenceTypeNode: () => (/* binding */ createReferenceTypeNode),\n/* harmony export */   evaluate: () => (/* binding */ evaluateQuery),\n/* harmony export */   evaluateSync: () => (/* binding */ evaluateQuerySync),\n/* harmony export */   isSelectorNested: () => (/* binding */ isSelectorNested),\n/* harmony export */   isSelectorNode: () => (/* binding */ isSelectorNode),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   toJS: () => (/* binding */ toJS),\n/* harmony export */   typeEvaluate: () => (/* binding */ typeEvaluate)\n/* harmony export */ });\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ \"(ssr)/../node_modules/debug/src/index.js\");\n\nfunction escapeRegExp(string2) {\n  return string2.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction pathRegExp(pattern) {\n  const re = [];\n  for (const part of pattern.split(\".\"))\n    part === \"*\" ? re.push(\"[^.]+\") : part === \"**\" ? re.push(\".*\") : re.push(escapeRegExp(part));\n  return new RegExp(`^${re.join(\".\")}$`);\n}\nclass Path {\n  pattern;\n  patternRe;\n  constructor(pattern) {\n    this.pattern = pattern, this.patternRe = pathRegExp(pattern);\n  }\n  matches(str) {\n    return this.patternRe.test(str);\n  }\n  toJSON() {\n    return this.pattern;\n  }\n}\nconst RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/;\nfunction parseRFC3339(str) {\n  return RFC3339_REGEX.test(str) ? new Date(str) : null;\n}\nfunction formatRFC3339(d) {\n  const year = addLeadingZero(d.getUTCFullYear(), 4), month = addLeadingZero(d.getUTCMonth() + 1, 2), day = addLeadingZero(d.getUTCDate(), 2), hour = addLeadingZero(d.getUTCHours(), 2), minute = addLeadingZero(d.getUTCMinutes(), 2), second = addLeadingZero(d.getUTCSeconds(), 2);\n  let fractionalSecond = \"\";\n  const millis = d.getMilliseconds();\n  return millis != 0 && (fractionalSecond = `.${addLeadingZero(millis, 3)}`), `${year}-${month}-${day}T${hour}:${minute}:${second}${fractionalSecond}Z`;\n}\nfunction addLeadingZero(num, targetLength) {\n  let str = num.toString();\n  for (; str.length < targetLength; )\n    str = `0${str}`;\n  return str;\n}\nclass StaticValue {\n  data;\n  type;\n  constructor(data, type) {\n    this.data = data, this.type = type;\n  }\n  isArray() {\n    return this.type === \"array\";\n  }\n  // eslint-disable-next-line require-await\n  async get() {\n    return this.data;\n  }\n  asStatic() {\n    return this;\n  }\n  [Symbol.asyncIterator]() {\n    if (Array.isArray(this.data))\n      return function* (data) {\n        for (const element of data)\n          yield fromJS(element);\n      }(this.data);\n    throw new Error(`Cannot iterate over: ${this.type}`);\n  }\n}\nconst NULL_VALUE = new StaticValue(null, \"null\"), TRUE_VALUE = new StaticValue(!0, \"boolean\"), FALSE_VALUE = new StaticValue(!1, \"boolean\");\nclass DateTime {\n  date;\n  constructor(date) {\n    this.date = date;\n  }\n  static parseToValue(str) {\n    const date = parseRFC3339(str);\n    return date ? new StaticValue(new DateTime(date), \"datetime\") : NULL_VALUE;\n  }\n  equals(other) {\n    return this.date.getTime() == other.date.getTime();\n  }\n  add(secs) {\n    const copy = new Date(this.date.getTime());\n    return copy.setTime(copy.getTime() + secs * 1e3), new DateTime(copy);\n  }\n  difference(other) {\n    return (this.date.getTime() - other.date.getTime()) / 1e3;\n  }\n  compareTo(other) {\n    return this.date.getTime() - other.date.getTime();\n  }\n  toString() {\n    return formatRFC3339(this.date);\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\nfunction fromNumber(num) {\n  return Number.isFinite(num) ? new StaticValue(num, \"number\") : NULL_VALUE;\n}\nfunction fromString(str) {\n  return new StaticValue(str, \"string\");\n}\nfunction fromDateTime(dt) {\n  return new StaticValue(dt, \"datetime\");\n}\nfunction fromPath(path) {\n  return new StaticValue(path, \"path\");\n}\nfunction isIterator(obj) {\n  return obj && typeof obj.next == \"function\";\n}\nfunction fromArray(val) {\n  return new StaticValue(val, \"array\");\n}\nfunction fromJS(val) {\n  return isIterator(val) ? new StreamValue(async function* () {\n    for await (const value of val)\n      yield fromJS(value);\n  }) : val == null ? NULL_VALUE : new StaticValue(val, getType(val));\n}\nfunction toJS(val) {\n  const normalized = maybeNormalize(val.data);\n  return normalized === void 0 ? val.data : normalized;\n}\nfunction maybeNormalize(data) {\n  if (!(data === null || typeof data > \"u\")) {\n    if (Array.isArray(data)) {\n      let result;\n      for (let i = 0; i < data.length; i++) {\n        let normalized = maybeNormalize(data[i]);\n        normalized !== void 0 && result === void 0 && (result = data.slice(0, i)), result !== void 0 && (normalized === void 0 && (normalized = data[i]), result.push(normalized));\n      }\n      return result;\n    }\n    if (typeof data == \"object\") {\n      if (\"toJSON\" in data && typeof data.toJSON == \"function\")\n        return data.toJSON();\n      const entries = Object.entries(data);\n      let result;\n      for (let i = 0; i < entries.length; i++) {\n        const [key, value] = entries[i];\n        let normalized = maybeNormalize(value);\n        normalized !== void 0 && result === void 0 && (result = Object.fromEntries(entries.slice(0, i))), result !== void 0 && (normalized === void 0 && (normalized = value), result[key] = normalized);\n      }\n      return result;\n    }\n  }\n}\nfunction getType(data) {\n  return data === null || typeof data > \"u\" ? \"null\" : Array.isArray(data) ? \"array\" : data instanceof Path ? \"path\" : data instanceof DateTime ? \"datetime\" : typeof data;\n}\nclass StreamValue {\n  type = \"stream\";\n  generator;\n  ticker;\n  isDone;\n  data;\n  constructor(generator) {\n    this.generator = generator, this.ticker = null, this.isDone = !1, this.data = [];\n  }\n  // eslint-disable-next-line class-methods-use-this\n  isArray() {\n    return !0;\n  }\n  async get() {\n    const result = [];\n    for await (const value of this)\n      result.push(await value.get());\n    return result;\n  }\n  async asStatic() {\n    return new StaticValue(await this.get(), \"array\");\n  }\n  async *[Symbol.asyncIterator]() {\n    let i = 0;\n    for (; ; ) {\n      for (; i < this.data.length; i++)\n        yield this.data[i];\n      if (this.isDone)\n        return;\n      await this._nextTick();\n    }\n  }\n  _nextTick() {\n    if (this.ticker)\n      return this.ticker;\n    let currentResolver, currentRejector;\n    const setupTicker = () => {\n      this.ticker = new Promise((resolve, reject) => {\n        currentResolver = resolve, currentRejector = reject;\n      });\n    }, tick = () => {\n      currentResolver(), setupTicker();\n    }, fetch = async () => {\n      try {\n        for await (const value of this.generator())\n          this.data.push(value), tick();\n        this.isDone = !0, tick();\n      } catch (error) {\n        currentRejector(error);\n      }\n    };\n    return setupTicker(), fetch(), this.ticker;\n  }\n}\nfunction isEqual(a, b) {\n  return a.type === \"string\" && b.type === \"string\" || a.type === \"boolean\" && b.type === \"boolean\" || a.type === \"null\" && b.type === \"null\" || a.type === \"number\" && b.type === \"number\" ? a.data === b.data : a.type === \"datetime\" && b.type === \"datetime\" ? a.data.equals(b.data) : !1;\n}\nfunction deepEqual(a, b) {\n  if (a === null || b === null) return a === b;\n  const typeOfA = typeof a, typeOfB = typeof b;\n  if (typeOfA === \"undefined\" && typeOfB === \"undefined\") return !0;\n  if (typeOfA === \"function\" && typeOfB === \"function\") return a === b;\n  if (typeOfA === \"object\" && typeOfB === \"object\") {\n    const keysOfA = Object.keys(a), keysOfB = Object.keys(b);\n    if (keysOfA.length !== keysOfB.length) return !1;\n    for (const key of keysOfA)\n      if (!deepEqual(a[key], b[key])) return !1;\n    return !0;\n  }\n  return a === b;\n}\nconst CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g, CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g, EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g;\nfunction matchText(tokens, patterns) {\n  return tokens.length === 0 || patterns.length === 0 ? !1 : patterns.every((pattern) => pattern(tokens));\n}\nfunction matchTokenize(text2) {\n  return text2.replace(EDGE_CHARS, \"\").match(CHARS) || [];\n}\nfunction matchAnalyzePattern(text2) {\n  return matchPatternRegex(text2).map((re) => (tokens) => tokens.some((token) => re.test(token)));\n}\nfunction matchPatternRegex(text2) {\n  return (text2.replace(EDGE_CHARS, \"\").match(CHARS_WITH_WILDCARD) || []).map(\n    (term) => new RegExp(`^${term.slice(0, 1024).replace(/\\*/g, \".*\")}$`, \"i\")\n  );\n}\nfunction gatherText(value, flatMap2) {\n  if (value.type === \"string\")\n    return { parts: flatMap2(value.data), success: !0 };\n  if (value.type === \"array\") {\n    let success = !0;\n    const parts = [];\n    for (const part of value.data)\n      typeof part == \"string\" ? parts.push(...flatMap2(part)) : success = !1;\n    return { parts, success };\n  }\n  return value.type === \"stream\" ? (async () => {\n    let success = !0;\n    const parts = [];\n    for await (const part of value)\n      part.type === \"string\" ? parts.push(...flatMap2(part.data)) : success = !1;\n    return { parts, success };\n  })() : { parts: [], success: !1 };\n}\nconst TYPE_ORDER = {\n  datetime: 1,\n  number: 2,\n  string: 3,\n  boolean: 4\n};\nfunction partialCompare(a, b) {\n  const aType = getType(a), bType = getType(b);\n  if (aType !== bType)\n    return null;\n  switch (aType) {\n    case \"number\":\n    case \"boolean\":\n      return a - b;\n    case \"string\":\n      return a < b ? -1 : a > b ? 1 : 0;\n    case \"datetime\":\n      return a.compareTo(b);\n    default:\n      return null;\n  }\n}\nfunction totalCompare(a, b) {\n  const aType = getType(a), bType = getType(b), aTypeOrder = TYPE_ORDER[aType] || 100, bTypeOrder = TYPE_ORDER[bType] || 100;\n  if (aTypeOrder !== bTypeOrder)\n    return aTypeOrder - bTypeOrder;\n  let result = partialCompare(a, b);\n  return result === null && (result = 0), result;\n}\nconst operators = {\n  \"==\": function(left, right) {\n    return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"!=\": function(left, right) {\n    return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE;\n  },\n  \">\": function(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    return result === null ? NULL_VALUE : result > 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \">=\": function(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    return result === null ? NULL_VALUE : result >= 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"<\": function(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    return result === null ? NULL_VALUE : result < 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"<=\": function(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    return result === null ? NULL_VALUE : result <= 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  // eslint-disable-next-line func-name-matching\n  in: function(left, right) {\n    if (right.type === \"path\")\n      return left.type !== \"string\" ? NULL_VALUE : right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE;\n    if (right.type === \"array\") {\n      for (const b of right.data)\n        if (isEqual(left, fromJS(b)))\n          return TRUE_VALUE;\n      return FALSE_VALUE;\n    }\n    return right.type === \"stream\" ? (async () => {\n      for await (const b of right)\n        if (isEqual(left, b))\n          return TRUE_VALUE;\n      return FALSE_VALUE;\n    })() : NULL_VALUE;\n  },\n  match: function(left, right) {\n    const tokens = gatherText(left, (part) => matchTokenize(part)), patterns = gatherText(right, (part) => matchAnalyzePattern(part)), process = (tokens2, patterns2) => patterns2.success && matchText(tokens2.parts, patterns2.parts) ? TRUE_VALUE : FALSE_VALUE;\n    return \"then\" in tokens || \"then\" in patterns ? (async () => process(await tokens, await patterns))() : process(tokens, patterns);\n  },\n  \"+\": function(left, right) {\n    return left.type === \"datetime\" && right.type === \"number\" ? fromDateTime(left.data.add(right.data)) : left.type === \"number\" && right.type === \"number\" ? fromNumber(left.data + right.data) : left.type === \"string\" && right.type === \"string\" ? fromString(left.data + right.data) : left.type === \"object\" && right.type === \"object\" ? fromJS({ ...left.data, ...right.data }) : left.type === \"array\" && right.type === \"array\" ? fromJS(left.data.concat(right.data)) : left.isArray() && right.isArray() ? new StreamValue(async function* () {\n      for await (const val of left)\n        yield val;\n      for await (const val of right)\n        yield val;\n    }) : NULL_VALUE;\n  },\n  \"-\": function(left, right) {\n    return left.type === \"datetime\" && right.type === \"number\" ? fromDateTime(left.data.add(-right.data)) : left.type === \"datetime\" && right.type === \"datetime\" ? fromNumber(left.data.difference(right.data)) : left.type === \"number\" && right.type === \"number\" ? fromNumber(left.data - right.data) : NULL_VALUE;\n  },\n  \"*\": numericOperator((a, b) => a * b),\n  \"/\": numericOperator((a, b) => a / b),\n  \"%\": numericOperator((a, b) => a % b),\n  \"**\": numericOperator((a, b) => Math.pow(a, b))\n};\nfunction numericOperator(impl) {\n  return function(left, right) {\n    if (left.type === \"number\" && right.type === \"number\") {\n      const result = impl(left.data, right.data);\n      return fromNumber(result);\n    }\n    return NULL_VALUE;\n  };\n}\nlet Scope$1 = class Scope {\n  params;\n  source;\n  value;\n  parent;\n  context;\n  isHidden = !1;\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  constructor(params, source, value, context, parent) {\n    this.params = params, this.source = source, this.value = value, this.context = context, this.parent = parent;\n  }\n  createNested(value) {\n    return this.isHidden ? new Scope(this.params, this.source, value, this.context, this.parent) : new Scope(this.params, this.source, value, this.context, this);\n  }\n  createHidden(value) {\n    const result = this.createNested(value);\n    return result.isHidden = !0, result;\n  }\n};\nfunction evaluate(node, scope) {\n  return executeAsync(node, scope);\n}\nfunction executeSync(node, scope) {\n  return EXECUTORS[node.type].executeSync(node, scope);\n}\nfunction executeAsync(node, scope) {\n  return EXECUTORS[node.type].executeAsync(node, scope);\n}\nfunction asyncOnlyExecutor(executeAsync2) {\n  return {\n    executeSync() {\n      throw new Error(\"executeSync not supported\");\n    },\n    executeAsync: executeAsync2\n  };\n}\nfunction constantExecutor(fn) {\n  return {\n    executeSync(node, scope) {\n      const value = fn(node, scope);\n      if (value.type === \"stream\") throw new Error(\"Stream encountered in evaluateSync\");\n      return value;\n    },\n    async executeAsync(node, scope) {\n      return fn(node, scope);\n    }\n  };\n}\nfunction mappedExecutor(map2, reduce) {\n  return {\n    executeSync(node, scope) {\n      const values = map2(node).map((node2) => executeSync(node2, scope)), value = reduce(node, ...values);\n      if (value.type === \"stream\")\n        throw new Error(\"Stream/iterator not supported in synchronous mode\");\n      return value;\n    },\n    async executeAsync(node, scope) {\n      const nodes = map2(node), values = await Promise.all(\n        nodes.map((node2) => executeAsync(node2, scope).then((value) => value.asStatic()))\n      );\n      return reduce(node, ...values);\n    }\n  };\n}\nconst STOP_ITERATOR = Symbol();\nfunction arrayReducerExecutor(map2, init, reduce, wrap) {\n  return {\n    executeSync(node, scope) {\n      const { array: arrayNode, args: argNodes = [] } = map2(node), arr = executeSync(arrayNode, scope);\n      if (arr.type !== \"array\") return NULL_VALUE;\n      const args = argNodes.map((node2) => executeSync(node2, scope));\n      let state = init(node, ...args);\n      for (const item of arr.data) {\n        const result = reduce(node, state, item, ...args);\n        if (result === STOP_ITERATOR) return NULL_VALUE;\n        state = result;\n      }\n      return wrap(state);\n    },\n    async executeAsync(node, scope) {\n      const { array: arrayNode, args: argNodes = [] } = map2(node), arr = await executeAsync(arrayNode, scope);\n      if (arr.type !== \"array\" && arr.type !== \"stream\") return NULL_VALUE;\n      const args = await Promise.all(\n        argNodes.map((node2) => executeAsync(node2, scope).then((v) => v.asStatic()))\n      );\n      let state = init(node, ...args);\n      if (arr.type === \"stream\")\n        for await (const item of arr) {\n          const result = reduce(node, state, await item.get(), ...args);\n          if (result === STOP_ITERATOR) return NULL_VALUE;\n          state = result;\n        }\n      else\n        for (const item of arr.data) {\n          const result = reduce(node, state, item, ...args);\n          if (result === STOP_ITERATOR) return NULL_VALUE;\n          state = result;\n        }\n      return wrap(state);\n    }\n  };\n}\nfunction arrayExecutor(map2, reduce, { hidden = !1 } = {}) {\n  return {\n    executeSync(node, scope) {\n      const mapping = map2(node), arr = executeSync(mapping.array, scope);\n      if (arr.type !== \"array\") return NULL_VALUE;\n      const result = [];\n      for (const item of arr.data) {\n        let inner;\n        if (mapping.inner) {\n          const newScope = hidden ? scope.createHidden(fromJS(item)) : scope.createNested(fromJS(item));\n          inner = executeSync(mapping.inner, newScope).data;\n        }\n        for (const entry of reduce(node, item, inner, mapping.state))\n          result.push(entry);\n      }\n      return fromArray(result);\n    },\n    async executeAsync(node, scope) {\n      const mapping = map2(node), arr = await executeAsync(mapping.array, scope);\n      return arr.isArray() ? new StreamValue(async function* () {\n        for await (const item of arr) {\n          let inner;\n          if (mapping.inner) {\n            const newScope = hidden ? scope.createHidden(item) : scope.createNested(item);\n            inner = await (await executeAsync(mapping.inner, newScope)).get();\n          }\n          for (const entry of reduce(node, await item.get(), inner, mapping.state))\n            yield fromJS(entry);\n        }\n      }) : NULL_VALUE;\n    }\n  };\n}\nconst EXECUTORS = {\n  This: constantExecutor((_, scope) => scope.value),\n  SelectorNested: constantExecutor(() => {\n    throw new Error(\"Unexpected node type: SelectorNested\");\n  }),\n  SelectorFuncCall: constantExecutor(() => {\n    throw new Error(\"Unexpected node type: SelectorFuncCall\");\n  }),\n  Everything: constantExecutor((_, scope) => scope.source),\n  Parameter: constantExecutor(({ name }, scope) => fromJS(scope.params[name])),\n  Context: constantExecutor(({ key }, scope) => {\n    if (key === \"before\" || key === \"after\")\n      return scope.context[key] || NULL_VALUE;\n    throw new Error(`unknown context key: ${key}`);\n  }),\n  Parent: constantExecutor(({ n }, scope) => {\n    let current = scope;\n    for (let i = 0; i < n; i++) {\n      if (!current.parent)\n        return NULL_VALUE;\n      current = current.parent;\n    }\n    return current.value;\n  }),\n  OpCall: {\n    async executeAsync({ op, left, right }, scope) {\n      const func = operators[op];\n      if (!func)\n        throw new Error(`Unknown operator: ${op}`);\n      const leftValue = await executeAsync(left, scope), rightValue = await executeAsync(right, scope);\n      return func(leftValue, rightValue);\n    },\n    executeSync({ op, left, right }, scope) {\n      const func = operators[op];\n      if (!func)\n        throw new Error(`Unknown operator: ${op}`);\n      const leftValue = executeSync(left, scope), rightValue = executeSync(right, scope), result = func(leftValue, rightValue);\n      if (\"then\" in result || result.type === \"stream\")\n        throw new Error(`Operator ${op} not possible in evaluteSync`);\n      return result;\n    }\n  },\n  Select: {\n    executeSync({ alternatives, fallback }, scope) {\n      for (const alt of alternatives) {\n        const altCond = executeSync(alt.condition, scope);\n        if (altCond.type === \"boolean\" && altCond.data === !0)\n          return executeSync(alt.value, scope);\n      }\n      return fallback ? executeSync(fallback, scope) : NULL_VALUE;\n    },\n    async executeAsync({ alternatives, fallback }, scope) {\n      for (const alt of alternatives) {\n        const altCond = await executeAsync(alt.condition, scope);\n        if (altCond.type === \"boolean\" && altCond.data === !0)\n          return executeAsync(alt.value, scope);\n      }\n      return fallback ? executeAsync(fallback, scope) : NULL_VALUE;\n    }\n  },\n  InRange: mappedExecutor(\n    ({ base, left, right }) => [base, left, right],\n    ({ isInclusive }, value, leftValue, rightValue) => {\n      const leftCmp = partialCompare(value.data, leftValue.data);\n      if (leftCmp === null)\n        return NULL_VALUE;\n      const rightCmp = partialCompare(value.data, rightValue.data);\n      return rightCmp === null ? NULL_VALUE : isInclusive ? leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE : leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE;\n    }\n  ),\n  Filter: arrayExecutor(\n    ({ base, expr }) => ({ array: base, inner: expr }),\n    function* (_, elem, inner) {\n      inner === !0 && (yield elem);\n    }\n  ),\n  Projection: {\n    executeSync({ base, expr }, scope) {\n      const baseValue = executeSync(base, scope);\n      if (baseValue.type !== \"object\")\n        return NULL_VALUE;\n      const newScope = scope.createNested(baseValue);\n      return executeSync(expr, newScope);\n    },\n    async executeAsync({ base, expr }, scope) {\n      const baseValue = await executeAsync(base, scope);\n      if (baseValue.type !== \"object\")\n        return NULL_VALUE;\n      const newScope = scope.createNested(baseValue);\n      return executeAsync(expr, newScope);\n    }\n  },\n  FuncCall: {\n    executeAsync({ func, args }, scope) {\n      return func.executeAsync(args, scope);\n    },\n    executeSync({ func, args }, scope) {\n      return func.executeSync(args, scope);\n    }\n  },\n  PipeFuncCall: {\n    async executeAsync({ func, base, args }, scope) {\n      const baseValue = await executeAsync(base, scope);\n      return baseValue.type !== \"stream\" && baseValue.type !== \"array\" ? NULL_VALUE : func.executeAsync({ base: baseValue, args }, scope);\n    },\n    executeSync({ func, base, args }, scope) {\n      const baseValue = executeSync(base, scope);\n      return baseValue.type !== \"array\" ? NULL_VALUE : func.executeSync({ base: baseValue, args }, scope);\n    }\n  },\n  AccessAttribute: mappedExecutor(\n    ({ base }) => [base || { type: \"This\" }],\n    ({ name }, value) => value.type === \"object\" && value.data.hasOwnProperty(name) ? fromJS(value.data[name]) : NULL_VALUE\n  ),\n  AccessElement: mappedExecutor(\n    ({ base }) => [base],\n    ({ index }, baseValue) => {\n      if (baseValue.type !== \"array\") return NULL_VALUE;\n      const data = baseValue.data, finalIndex = index < 0 ? index + data.length : index;\n      return fromJS(data[finalIndex]);\n    }\n  ),\n  Slice: mappedExecutor(\n    ({ base }) => [base],\n    ({ left, right, isInclusive }, baseValue) => {\n      if (baseValue.type !== \"array\")\n        return NULL_VALUE;\n      const array2 = baseValue.data;\n      let leftIdx = left, rightIdx = right;\n      return leftIdx < 0 && (leftIdx = array2.length + leftIdx), rightIdx < 0 && (rightIdx = array2.length + rightIdx), isInclusive && rightIdx++, leftIdx < 0 && (leftIdx = 0), rightIdx < 0 && (rightIdx = 0), fromArray(array2.slice(leftIdx, rightIdx));\n    }\n  ),\n  Deref: {\n    executeSync({ base }, scope) {\n      const value = executeSync(base, scope);\n      if (value.type !== \"object\")\n        return NULL_VALUE;\n      const id = value.data._ref;\n      if (typeof id != \"string\")\n        return NULL_VALUE;\n      if (scope.context.dereference) {\n        const value2 = scope.context.dereference({ _ref: id });\n        if (value2 && typeof value2 == \"object\" && \"then\" in value2)\n          throw new Error(\"Dereference returned promise in synchronous mode\");\n        return fromJS(value2);\n      }\n      if (scope.source.type !== \"array\")\n        return NULL_VALUE;\n      for (const doc of scope.source.data)\n        if (doc && typeof doc == \"object\" && \"_id\" in doc && id === doc._id)\n          return fromJS(doc);\n      return NULL_VALUE;\n    },\n    async executeAsync({ base }, scope) {\n      const value = await executeAsync(base, scope);\n      if (!scope.source.isArray() || value.type !== \"object\")\n        return NULL_VALUE;\n      const id = value.data._ref;\n      if (typeof id != \"string\")\n        return NULL_VALUE;\n      if (scope.context.dereference)\n        return fromJS(await scope.context.dereference({ _ref: id }));\n      for await (const doc of scope.source)\n        if (doc.type === \"object\" && id === doc.data._id)\n          return doc;\n      return NULL_VALUE;\n    }\n  },\n  Value: constantExecutor(({ value }) => fromJS(value)),\n  Group: {\n    executeSync({ base }, scope) {\n      return executeSync(base, scope);\n    },\n    executeAsync({ base }, scope) {\n      return executeAsync(base, scope);\n    }\n  },\n  Object: {\n    executeSync({ attributes }, scope) {\n      const result = {};\n      for (const attr of attributes) {\n        const attrType = attr.type;\n        switch (attr.type) {\n          case \"ObjectAttributeValue\": {\n            const value = executeSync(attr.value, scope);\n            result[attr.name] = value.data;\n            break;\n          }\n          case \"ObjectConditionalSplat\": {\n            const cond = executeSync(attr.condition, scope);\n            if (cond.type !== \"boolean\" || cond.data === !1)\n              continue;\n            const value = executeSync(attr.value, scope);\n            value.type === \"object\" && Object.assign(result, value.data);\n            break;\n          }\n          case \"ObjectSplat\": {\n            const value = executeSync(attr.value, scope);\n            value.type === \"object\" && Object.assign(result, value.data);\n            break;\n          }\n          default:\n            throw new Error(`Unknown node type: ${attrType}`);\n        }\n      }\n      return fromJS(result);\n    },\n    async executeAsync({ attributes }, scope) {\n      const result = {};\n      for (const attr of attributes) {\n        const attrType = attr.type;\n        switch (attr.type) {\n          case \"ObjectAttributeValue\": {\n            const value = await executeAsync(attr.value, scope);\n            result[attr.name] = await value.get();\n            break;\n          }\n          case \"ObjectConditionalSplat\": {\n            const cond = await executeAsync(attr.condition, scope);\n            if (cond.type !== \"boolean\" || cond.data === !1)\n              continue;\n            const value = await executeAsync(attr.value, scope);\n            value.type === \"object\" && Object.assign(result, value.data);\n            break;\n          }\n          case \"ObjectSplat\": {\n            const value = await executeAsync(attr.value, scope);\n            value.type === \"object\" && Object.assign(result, value.data);\n            break;\n          }\n          default:\n            throw new Error(`Unknown node type: ${attrType}`);\n        }\n      }\n      return fromJS(result);\n    }\n  },\n  Array: {\n    executeSync({ elements }, scope) {\n      const result = [];\n      for (const element of elements) {\n        const value = executeSync(element.value, scope);\n        if (element.isSplat) {\n          if (value.type === \"array\")\n            for (const v of value.data)\n              result.push(v);\n        } else\n          result.push(value.data);\n      }\n      return fromArray(result);\n    },\n    async executeAsync({ elements }, scope) {\n      return new StreamValue(async function* () {\n        for (const element of elements) {\n          const value = await executeAsync(element.value, scope);\n          if (element.isSplat) {\n            if (value.isArray())\n              for await (const v of value)\n                yield v;\n          } else\n            yield value;\n        }\n      });\n    }\n  },\n  Tuple: constantExecutor(() => {\n    throw new Error(\"tuples can not be evaluated\");\n  }),\n  Or: mappedExecutor(\n    ({ left, right }) => [left, right],\n    (_, leftValue, rightValue) => leftValue.type === \"boolean\" && leftValue.data === !0 || rightValue.type === \"boolean\" && rightValue.data === !0 ? TRUE_VALUE : leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\" ? NULL_VALUE : FALSE_VALUE\n  ),\n  And: mappedExecutor(\n    ({ left, right }) => [left, right],\n    (_, leftValue, rightValue) => leftValue.type === \"boolean\" && leftValue.data === !1 || rightValue.type === \"boolean\" && rightValue.data === !1 ? FALSE_VALUE : leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\" ? NULL_VALUE : TRUE_VALUE\n  ),\n  Not: mappedExecutor(\n    ({ base }) => [base],\n    (_, value) => value.type !== \"boolean\" ? NULL_VALUE : value.data ? FALSE_VALUE : TRUE_VALUE\n  ),\n  Neg: mappedExecutor(\n    ({ base }) => [base],\n    (_, value) => value.type !== \"number\" ? NULL_VALUE : fromNumber(-value.data)\n  ),\n  Pos: mappedExecutor(\n    ({ base }) => [base],\n    (_, value) => value.type !== \"number\" ? NULL_VALUE : fromNumber(value.data)\n  ),\n  Asc: constantExecutor(() => NULL_VALUE),\n  Desc: constantExecutor(() => NULL_VALUE),\n  ArrayCoerce: {\n    executeSync({ base }, scope) {\n      const value = executeSync(base, scope);\n      return value.isArray() ? value : NULL_VALUE;\n    },\n    async executeAsync({ base }, scope) {\n      const value = await executeAsync(base, scope);\n      return value.isArray() ? value : NULL_VALUE;\n    }\n  },\n  Map: arrayExecutor(\n    ({ base, expr }) => ({ array: base, inner: expr }),\n    function* (_, _item, inner) {\n      yield inner;\n    },\n    { hidden: !0 }\n  ),\n  FlatMap: arrayExecutor(\n    ({ base, expr }) => ({ array: base, inner: expr }),\n    function* (_, _item, inner) {\n      if (Array.isArray(inner))\n        for (const innerInner of inner)\n          yield innerInner;\n      else\n        yield inner;\n    },\n    { hidden: !0 }\n  )\n};\nfunction evaluateQuery(tree, options = {}) {\n  return executeAsync(tree, scopeFromOptions(options));\n}\nfunction evaluateQuerySync(tree, options = {}) {\n  return executeSync(tree, scopeFromOptions(options));\n}\nfunction scopeFromOptions(options) {\n  const root = fromJS(options.root), dataset = fromJS(options.dataset), params = { ...options.params };\n  return new Scope$1(\n    params,\n    dataset,\n    root,\n    {\n      timestamp: options.timestamp || /* @__PURE__ */ new Date(),\n      identity: options.identity === void 0 ? \"me\" : options.identity,\n      sanity: options.sanity,\n      after: options.after ? fromJS(options.after) : null,\n      before: options.before ? fromJS(options.before) : null,\n      dereference: options.dereference\n    },\n    null\n  );\n}\nfunction canConstantEvaluate(node) {\n  switch (node.type) {\n    case \"Group\":\n      return canConstantEvaluate(node.base);\n    case \"Value\":\n    case \"Parameter\":\n      return !0;\n    case \"Pos\":\n    case \"Neg\":\n      return canConstantEvaluate(node.base);\n    case \"OpCall\":\n      switch (node.op) {\n        case \"+\":\n        case \"-\":\n        case \"*\":\n        case \"/\":\n        case \"%\":\n        case \"**\":\n          return canConstantEvaluate(node.left) && canConstantEvaluate(node.right);\n        default:\n          return !1;\n      }\n    default:\n      return !1;\n  }\n}\nconst DUMMY_SCOPE = new Scope$1(\n  {},\n  NULL_VALUE,\n  NULL_VALUE,\n  { timestamp: /* @__PURE__ */ new Date(0), identity: \"me\", before: null, after: null },\n  null\n);\nfunction tryConstantEvaluate(node) {\n  return canConstantEvaluate(node) ? constantEvaluate(node) : null;\n}\nfunction constantEvaluate(node) {\n  return executeSync(node, DUMMY_SCOPE);\n}\nfunction isSelectorNode(node) {\n  return [\n    \"AccessAttribute\",\n    \"SelectorFuncCall\",\n    \"Group\",\n    \"Tuple\",\n    \"ArrayCoerce\",\n    \"Filter\",\n    \"SelectorNested\"\n  ].includes(node.type);\n}\nfunction isSelectorNested(node) {\n  return [\"AccessAttribute\", \"ArrayCoerce\", \"Filter\", \"Group\", \"Tuple\", \"SelectorNested\"].includes(\n    node.type\n  );\n}\nconst array = {};\narray.join = mappedExecutor(\n  (args) => args,\n  (_, arr, sep) => {\n    if (arr.type !== \"array\" || sep.type !== \"string\")\n      return NULL_VALUE;\n    let buf = \"\", needSep = !1;\n    for (const elem of arr.data) {\n      switch (needSep && (buf += sep.data), getType(elem)) {\n        case \"number\":\n        case \"string\":\n        case \"boolean\":\n        case \"datetime\":\n          buf += `${elem}`;\n          break;\n        default:\n          return NULL_VALUE;\n      }\n      needSep = !0;\n    }\n    return fromString(buf);\n  }\n);\narray.join.arity = 2;\narray.compact = arrayExecutor(\n  ([array2]) => ({ array: array2 }),\n  function* (_, item) {\n    item !== null && (yield item);\n  }\n);\narray.compact.arity = 1;\narray.unique = arrayExecutor(\n  (args) => ({ array: args[0], state: /* @__PURE__ */ new Set() }),\n  function* (_node, iter, _inner, added) {\n    switch (getType(iter)) {\n      case \"number\":\n      case \"string\":\n      case \"boolean\":\n      case \"datetime\":\n        added.has(iter) || (added.add(iter), yield iter);\n        break;\n      default:\n        yield iter;\n    }\n  }\n);\narray.unique.arity = 1;\narray.intersects = mappedExecutor(\n  (args) => args,\n  (_, arr1, arr2) => {\n    if (arr1.type !== \"array\" || arr2.type !== \"array\")\n      return NULL_VALUE;\n    for (const v1 of arr1.data)\n      for (const v2 of arr2.data)\n        if (isEqual(fromJS(v1), fromJS(v2)))\n          return TRUE_VALUE;\n    return FALSE_VALUE;\n  }\n);\narray.intersects.arity = 2;\nconst dateTime = {};\ndateTime.now = constantExecutor(\n  (_, scope) => fromDateTime(new DateTime(scope.context.timestamp))\n);\ndateTime.now.arity = 0;\nasync function valueAtPath(arg, keyPath) {\n  function tryAccessor(arg2, accessor) {\n    try {\n      return arg2[accessor];\n    } catch {\n      return;\n    }\n  }\n  let current = await arg.get();\n  for (const part of keyPath)\n    if (current = tryAccessor(current, part), !current) break;\n  return current;\n}\nfunction startsWith(keyPath, prefix) {\n  return prefix.every((item, index) => keyPath[index] === item);\n}\nasync function* diffKeyPaths(before, after) {\n  const currPaths = [[]];\n  for (; currPaths.length > 0; ) {\n    const currPath = currPaths.shift() || [], b = fromJS(await valueAtPath(before, currPath)), a = fromJS(await valueAtPath(after, currPath));\n    if (a.type !== b.type)\n      yield currPath;\n    else if (a.type === \"string\" && b.type === \"string\" || a.type === \"boolean\" && b.type === \"boolean\" || a.type === \"null\" && b.type === \"null\" || a.type === \"number\" && b.type === \"number\")\n      a.data !== b.data && (yield currPath);\n    else if (a.type === \"datetime\" && b.type === \"datetime\")\n      a.data.equals(b.data) || (yield currPath);\n    else if (a.type === \"object\" && b.type === \"object\") {\n      if (!deepEqual(a.data, b.data)) {\n        const aKeys = Object.keys(a.data), bKeys = Object.keys(b.data);\n        new Set(aKeys.concat(bKeys)).forEach((key) => {\n          currPaths.push([...currPath, key]);\n        });\n      }\n    } else if (a.type === \"array\" && b.type === \"array\") {\n      if (a.data.length !== b.data.length)\n        yield currPath;\n      else if (!deepEqual(a.data, b.data))\n        for (let i = 0; i < b.data.length; i++)\n          currPaths.push([...currPath, i]);\n    } else if (a.type === \"stream\" && b.type === \"stream\") {\n      const arrayA = await a.get(), arrayB = await b.get();\n      if (arrayA.length !== arrayB.length)\n        yield currPath;\n      else if (!deepEqual(arrayA, arrayB))\n        for (let i = 0; i < arrayB.length; i++)\n          currPaths.push([...currPath, i]);\n    }\n  }\n}\nasync function evaluateSelector(node, value, scope) {\n  switch (node.type) {\n    case \"Group\":\n      return await evaluateSelector(node.base, value, scope);\n    case \"Tuple\":\n      const tuplePaths = [];\n      for (const member of node.members) {\n        const memberPaths = await evaluateSelector(member, value, scope);\n        tuplePaths.push(...memberPaths);\n      }\n      return tuplePaths;\n    case \"AccessAttribute\":\n      return node.base ? (await evaluateSelector(node.base, value, scope)).map((path) => [...path, node.name]) : [[node.name]];\n    case \"ArrayCoerce\": {\n      const paths = await evaluateSelector(node.base, value, scope), arrayPaths = [];\n      for (const keyPath of paths) {\n        const innerValue = await valueAtPath(value, keyPath);\n        if (Array.isArray(innerValue))\n          for (let i = 0; i < innerValue.length; i++)\n            arrayPaths.push([...keyPath, i]);\n      }\n      return arrayPaths;\n    }\n    case \"Filter\": {\n      const paths = await evaluateSelector(node.base, value, scope), filter = {\n        ...node,\n        base: { type: \"This\" }\n      }, arrayPaths = [];\n      for (const keyPath of paths) {\n        const innerValue = await valueAtPath(value, keyPath);\n        if (Array.isArray(innerValue))\n          for (let i = 0; i < innerValue.length; i++) {\n            const item = innerValue[i], nestedScope = scope.createNested(fromJS([item]));\n            (await (await evaluate(filter, nestedScope)).get()).length > 0 && arrayPaths.push([...keyPath, i]);\n          }\n      }\n      return arrayPaths;\n    }\n    case \"SelectorFuncCall\":\n      return anywhere(node.arg, scope.createHidden(value));\n    case \"SelectorNested\": {\n      const { base, nested: expr } = node, paths = await evaluateSelector(base, value, scope), nestedPaths = [];\n      for (const keyPath of paths) {\n        const innerValue = await valueAtPath(value, keyPath);\n        switch (expr.type) {\n          case \"AccessAttribute\":\n          case \"ArrayCoerce\":\n          case \"Filter\":\n            const accessPaths = await evaluateSelector(expr, fromJS(innerValue), scope);\n            for (let i = 0; i < accessPaths.length; i++)\n              nestedPaths.push([...keyPath, ...accessPaths[i]]);\n            break;\n          case \"Group\":\n            const innerResult = await evaluateSelector(expr.base, fromJS(innerValue), scope);\n            for (const innerKeyPath of innerResult)\n              nestedPaths.push([...keyPath, ...innerKeyPath]);\n            break;\n          case \"Tuple\":\n            for (const inner of expr.members) {\n              const innerResult2 = await evaluateSelector(inner, fromJS(innerValue), scope);\n              for (const innerKeyPath of innerResult2)\n                nestedPaths.push([...keyPath, ...innerKeyPath]);\n            }\n        }\n      }\n      return nestedPaths;\n    }\n  }\n}\nasync function anywhere(expr, scope, base = []) {\n  const value = scope.value, pathList = [];\n  if (value.isArray()) {\n    const arr = await value.get();\n    for (let i = 0; i < arr.length; i++) {\n      const subPaths = await anywhere(expr, scope.createHidden(fromJS(arr[i])), [...base, i]);\n      pathList.push(...subPaths);\n    }\n  } else if (value.type === \"object\") {\n    const result = await evaluate(expr, scope);\n    result.type === \"boolean\" && result.data === !0 && pathList.push(base);\n    for (const key of Object.keys(value.data)) {\n      const subPaths = await anywhere(expr, scope.createHidden(fromJS(value.data[key])), [\n        ...base,\n        key\n      ]);\n      pathList.push(...subPaths);\n    }\n  }\n  return pathList;\n}\nasync function changedAny(before, after, selector, scope) {\n  const beforeSelectorScope = scope.createHidden(before), beforePaths = await evaluateSelector(\n    selector,\n    beforeSelectorScope.value,\n    beforeSelectorScope\n  ), afterSelectorScope = scope.createHidden(after), afterPaths = await evaluateSelector(selector, afterSelectorScope.value, afterSelectorScope);\n  if (beforePaths.length !== afterPaths.length)\n    return TRUE_VALUE;\n  for (const path of beforePaths) {\n    for (let i = 0; i < path.length; i++)\n      if (typeof path[i] == \"number\") {\n        const slice = path.slice(0, i), beforeArr = await valueAtPath(before, slice), afterArr = await valueAtPath(after, slice);\n        if (!Array.isArray(beforeArr) || !Array.isArray(afterArr) || beforeArr.length !== afterArr.length)\n          return TRUE_VALUE;\n      }\n    const beforeValue = await valueAtPath(before, path), afterValue = await valueAtPath(after, path);\n    if (!deepEqual(beforeValue, afterValue))\n      return TRUE_VALUE;\n  }\n  return FALSE_VALUE;\n}\nasync function changedOnly(before, after, selector, scope) {\n  const beforeSelectorScope = scope.createHidden(before), selectedPaths = await evaluateSelector(\n    selector,\n    beforeSelectorScope.value,\n    beforeSelectorScope\n  );\n  for await (const diffPath of diffKeyPaths(before, after)) {\n    let found = !1;\n    for (const selectedPath of selectedPaths)\n      if (startsWith(diffPath, selectedPath)) {\n        found = !0;\n        break;\n      }\n    if (!found)\n      return FALSE_VALUE;\n  }\n  return TRUE_VALUE;\n}\nconst diff = {};\ndiff.changedAny = asyncOnlyExecutor(async (args, scope) => {\n  const lhs = args[0], rhs = args[1], selector = args[2];\n  if (!isSelectorNode(selector)) throw new Error(\"changedAny third argument must be a selector\");\n  const before = await executeAsync(lhs, scope), after = await executeAsync(rhs, scope);\n  return changedAny(before, after, selector, scope);\n});\ndiff.changedAny.arity = 3;\ndiff.changedOnly = asyncOnlyExecutor(async (args, scope) => {\n  const lhs = args[0], rhs = args[1], selector = args[2];\n  if (!isSelectorNode(selector)) throw new Error(\"changedOnly third argument must be a selector\");\n  const before = await executeAsync(lhs, scope), after = await executeAsync(rhs, scope);\n  return changedOnly(before, after, selector, scope);\n});\ndiff.changedOnly.arity = 3;\nconst delta = {};\ndelta.operation = constantExecutor((_, scope) => {\n  const hasBefore = scope.context.before !== null, hasAfter = scope.context.after !== null;\n  return hasBefore && hasAfter ? fromString(\"update\") : hasAfter ? fromString(\"create\") : hasBefore ? fromString(\"delete\") : NULL_VALUE;\n});\ndelta.changedAny = asyncOnlyExecutor(async (args, scope) => {\n  const before = scope.context.before || NULL_VALUE, after = scope.context.after || NULL_VALUE, selector = args[0];\n  if (!isSelectorNode(selector)) throw new Error(\"changedAny first argument must be a selector\");\n  return changedAny(before, after, selector, scope);\n});\ndelta.changedAny.arity = 1;\ndelta.changedAny.mode = \"delta\";\ndelta.changedOnly = asyncOnlyExecutor(async (args, scope) => {\n  const before = scope.context.before || NULL_VALUE, after = scope.context.after || NULL_VALUE, selector = args[0];\n  if (!isSelectorNode(selector)) throw new Error(\"changedOnly first argument must be a selector\");\n  return changedOnly(before, after, selector, scope);\n});\ndelta.changedOnly.arity = 1;\ndelta.changedOnly.mode = \"delta\";\nconst documents = {};\ndocuments.get = constantExecutor(() => {\n  throw new Error(\"not implemented\");\n});\nconst geo = {};\ngeo.latLng = constantExecutor(() => {\n  throw new Error(\"not implemented\");\n});\ngeo.contains = constantExecutor(() => {\n  throw new Error(\"not implemented\");\n});\ngeo.intersects = constantExecutor(() => {\n  throw new Error(\"not implemented\");\n});\ngeo.distance = constantExecutor(() => {\n  throw new Error(\"not implemented\");\n});\nconst string = {};\nstring.lower = mappedExecutor(\n  (args) => args,\n  (_, value) => value.type !== \"string\" ? NULL_VALUE : fromString(value.data.toLowerCase())\n);\nstring.lower.arity = 1;\nstring.upper = mappedExecutor(\n  (args) => args,\n  (_, value) => value.type !== \"string\" ? NULL_VALUE : fromString(value.data.toUpperCase())\n);\nstring.upper.arity = 1;\nstring.split = mappedExecutor(\n  (args) => args,\n  (_, str, sep) => str.type !== \"string\" || sep.type !== \"string\" ? NULL_VALUE : str.data.length === 0 ? fromArray([]) : sep.data.length === 0 ? fromArray(Array.from(str.data)) : fromArray(str.data.split(sep.data))\n);\nstring.split.arity = 2;\nstring.startsWith = mappedExecutor(\n  (args) => args,\n  (_, str, prefix) => str.type !== \"string\" || prefix.type !== \"string\" ? NULL_VALUE : str.data.startsWith(prefix.data) ? TRUE_VALUE : FALSE_VALUE\n);\nstring.startsWith.arity = 2;\nconst _global = {};\n_global.anywhere = constantExecutor(() => {\n  throw new Error(\"not implemented\");\n});\n_global.anywhere.arity = 1;\n_global.coalesce = {\n  async executeAsync(args, scope) {\n    for (const arg of args) {\n      const value = await executeAsync(arg, scope);\n      if (value.type !== \"null\")\n        return value;\n    }\n    return NULL_VALUE;\n  },\n  executeSync(args, scope) {\n    for (const arg of args) {\n      const value = executeSync(arg, scope);\n      if (value.type !== \"null\")\n        return value;\n    }\n    return NULL_VALUE;\n  }\n};\n_global.count = arrayReducerExecutor(\n  (args) => ({ array: args[0] }),\n  () => 0,\n  (_, count) => count + 1,\n  fromNumber\n);\n_global.count.arity = 1;\n_global.dateTime = mappedExecutor(\n  (args) => args,\n  (_, val) => val.type === \"datetime\" ? val : val.type !== \"string\" ? NULL_VALUE : DateTime.parseToValue(val.data)\n);\n_global.dateTime.arity = 1;\n_global.defined = mappedExecutor(\n  (args) => args,\n  (_, inner) => inner.type === \"null\" ? FALSE_VALUE : TRUE_VALUE\n);\n_global.defined.arity = 1;\n_global.identity = constantExecutor((_args, scope) => fromString(scope.context.identity));\n_global.identity.arity = 0;\n_global.length = mappedExecutor(\n  (args) => args,\n  (_, inner) => inner.type === \"string\" ? fromNumber(countUTF8(inner.data)) : inner.type === \"array\" ? fromNumber(inner.data.length) : NULL_VALUE\n);\n_global.length.arity = 1;\n_global.path = mappedExecutor(\n  (args) => args,\n  (_, inner) => inner.type !== \"string\" ? NULL_VALUE : fromPath(new Path(inner.data))\n);\n_global.path.arity = 1;\n_global.string = mappedExecutor(\n  (args) => args,\n  (_, value) => {\n    switch (value.type) {\n      case \"number\":\n      case \"string\":\n      case \"boolean\":\n      case \"datetime\":\n        return fromString(`${value.data}`);\n      default:\n        return NULL_VALUE;\n    }\n  }\n);\n_global.string.arity = 1;\n_global.references = mappedExecutor(\n  (args) => [{ type: \"This\" }, ...args],\n  (_, scopeValue, ...args) => {\n    const pathSet = /* @__PURE__ */ new Set();\n    for (const path of args)\n      if (path.type === \"string\")\n        pathSet.add(path.data);\n      else if (path.type === \"array\")\n        for (const elem of path.data)\n          typeof elem == \"string\" && pathSet.add(elem);\n    return pathSet.size === 0 ? FALSE_VALUE : hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE;\n  }\n);\n_global.references.arity = (c) => c >= 1;\n_global.round = mappedExecutor(\n  (args) => args,\n  (_, value, precValue) => {\n    if (value.type !== \"number\")\n      return NULL_VALUE;\n    const num = value.data;\n    let prec = 0;\n    if (precValue) {\n      if (precValue.type !== \"number\" || precValue.data < 0 || !Number.isInteger(precValue.data))\n        return NULL_VALUE;\n      prec = precValue.data;\n    }\n    return prec === 0 ? num < 0 ? fromNumber(-Math.round(-num)) : fromNumber(Math.round(num)) : fromNumber(Number(num.toFixed(prec)));\n  }\n);\n_global.round.arity = (count) => count >= 1 && count <= 2;\n_global.now = constantExecutor((_args, scope) => fromString(scope.context.timestamp.toISOString()));\n_global.now.arity = 0;\n_global.boost = constantExecutor(() => {\n  throw new Error(\"unexpected boost call\");\n});\n_global.boost.arity = 2;\n_global.lower = string.lower;\n_global.upper = string.upper;\nfunction countUTF8(str) {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n    code >= 55296 && code <= 56319 || count++;\n  }\n  return count;\n}\nfunction hasReference(value, pathSet) {\n  switch (getType(value)) {\n    case \"array\":\n      for (const v of value)\n        if (hasReference(v, pathSet))\n          return !0;\n      break;\n    case \"object\":\n      if (value._ref)\n        return pathSet.has(value._ref);\n      for (const v of Object.values(value))\n        if (hasReference(v, pathSet))\n          return !0;\n      break;\n  }\n  return !1;\n}\nconst math = {};\nmath.min = arrayReducerExecutor(\n  (args) => ({ array: args[0] }),\n  () => {\n  },\n  (_, n, item) => item === null ? n : typeof item != \"number\" ? STOP_ITERATOR : n === void 0 || item < n ? item : n,\n  (n) => n === void 0 ? NULL_VALUE : fromNumber(n)\n);\nmath.min.arity = 1;\nmath.max = arrayReducerExecutor(\n  (args) => ({ array: args[0] }),\n  () => {\n  },\n  (_, n, item) => item === null ? n : typeof item != \"number\" ? STOP_ITERATOR : n === void 0 || item > n ? item : n,\n  (n) => n === void 0 ? NULL_VALUE : fromNumber(n)\n);\nmath.max.arity = 1;\nmath.sum = arrayReducerExecutor(\n  (args) => ({ array: args[0] }),\n  () => 0,\n  (_, n, item) => item === null ? n : typeof item != \"number\" ? STOP_ITERATOR : n + item,\n  fromNumber\n);\nmath.sum.arity = 1;\nmath.avg = arrayReducerExecutor(\n  (args) => ({ array: args[0] }),\n  () => ({ count: 0, sum: 0 }),\n  (_, { count, sum }, item) => item === null ? { count, sum } : typeof item != \"number\" ? STOP_ITERATOR : { count: count + 1, sum: sum + item },\n  ({ count, sum }) => count === 0 ? NULL_VALUE : fromNumber(sum / count)\n);\nmath.avg.arity = 1;\nfunction portableTextContent(value) {\n  if (value.type === \"object\")\n    return blockText(value.data);\n  if (value.type === \"array\") {\n    const texts = arrayText(value.data);\n    if (texts.length > 0)\n      return texts.join(`\n\n`);\n  }\n  return null;\n}\nfunction arrayText(value, result = []) {\n  for (const block of value)\n    if (Array.isArray(block))\n      arrayText(block, result);\n    else if (typeof block == \"object\" && block) {\n      const text2 = blockText(block);\n      text2 !== null && result.push(text2);\n    }\n  return result;\n}\nfunction blockText(obj) {\n  if (typeof obj._type != \"string\") return null;\n  const children = obj.children;\n  if (!Array.isArray(children)) return null;\n  let result = \"\";\n  for (const child of children)\n    child && typeof child == \"object\" && typeof child._type == \"string\" && child._type === \"span\" && typeof child.text == \"string\" && (result += child.text);\n  return result;\n}\nconst pt = {};\npt.text = mappedExecutor(\n  (args) => args,\n  function(_, value) {\n    const text2 = portableTextContent(value);\n    return text2 === null ? NULL_VALUE : fromString(text2);\n  }\n);\npt.text.arity = 1;\nconst releases = {};\nreleases.all = arrayExecutor(\n  () => ({ array: { type: \"Everything\" } }),\n  function* (_, value) {\n    typeof value == \"object\" && value && \"_type\" in value && value._type === \"system.release\" && (yield value);\n  }\n);\nreleases.all.arity = 0;\nconst sanity = {};\nsanity.projectId = constantExecutor((_, scope) => scope.context.sanity ? fromString(scope.context.sanity.projectId) : NULL_VALUE);\nsanity.dataset = constantExecutor((_, scope) => scope.context.sanity ? fromString(scope.context.sanity.dataset) : NULL_VALUE);\nsanity.versionOf = mappedExecutor(\n  ([value]) => [value, { type: \"This\" }],\n  (_, value, val) => {\n    if (value.type !== \"string\") return NULL_VALUE;\n    const baseId = value.data;\n    if (val.type !== \"object\" || typeof val.data._id != \"string\") return NULL_VALUE;\n    if (val.data._id === baseId) return TRUE_VALUE;\n    const components = val.data._id.split(\".\");\n    return components.length >= 2 && components[0] === \"drafts\" && components.slice(1).join(\".\") === baseId || components.length >= 3 && components[0] === \"versions\" && components.slice(2).join(\".\") === baseId ? TRUE_VALUE : FALSE_VALUE;\n  }\n);\nsanity.versionOf.arity = 1;\nsanity.partOfRelease = mappedExecutor(\n  (args) => [args[0], { type: \"This\" }],\n  (_, value, val) => {\n    if (value.type !== \"string\") return NULL_VALUE;\n    const baseId = value.data;\n    if (val.type !== \"object\" || typeof val.data._id != \"string\") return NULL_VALUE;\n    const components = val.data._id.split(\".\");\n    return components.length >= 3 && components[0] === \"versions\" && components[1] === baseId ? TRUE_VALUE : FALSE_VALUE;\n  }\n);\nsanity.partOfRelease.arity = 1;\nconst text = {};\ntext.query = constantExecutor(() => {\n  throw new Error(\"not implemented\");\n});\ntext.query.arity = 1;\nconst BM25k = 1.2;\nasync function evaluateScoreAsync(node, scope) {\n  if (node.type === \"OpCall\" && node.op === \"match\")\n    return evaluateMatchScoreAsync(node.left, node.right, scope);\n  if (node.type === \"FuncCall\" && node.name === \"boost\") {\n    const innerScore = await evaluateScoreAsync(node.args[0], scope), boost = await executeAsync(node.args[1], scope);\n    return boost.type === \"number\" && innerScore > 0 ? innerScore + boost.data : 0;\n  }\n  switch (node.type) {\n    case \"Or\": {\n      const leftScore = await evaluateScoreAsync(node.left, scope), rightScore = await evaluateScoreAsync(node.right, scope);\n      return leftScore + rightScore;\n    }\n    case \"And\": {\n      const leftScore = await evaluateScoreAsync(node.left, scope), rightScore = await evaluateScoreAsync(node.right, scope);\n      return leftScore === 0 || rightScore === 0 ? 0 : leftScore + rightScore;\n    }\n    default: {\n      const res = await executeAsync(node, scope);\n      return res.type === \"boolean\" && res.data === !0 ? 1 : 0;\n    }\n  }\n}\nfunction evaluateScoreSync(node, scope) {\n  if (node.type === \"OpCall\" && node.op === \"match\")\n    return evaluateMatchScoreSync(node.left, node.right, scope);\n  if (node.type === \"FuncCall\" && node.name === \"boost\") {\n    const innerScore = evaluateScoreSync(node.args[0], scope), boost = executeSync(node.args[1], scope);\n    return boost.type === \"number\" && innerScore > 0 ? innerScore + boost.data : 0;\n  }\n  switch (node.type) {\n    case \"Or\": {\n      const leftScore = evaluateScoreSync(node.left, scope), rightScore = evaluateScoreSync(node.right, scope);\n      return leftScore + rightScore;\n    }\n    case \"And\": {\n      const leftScore = evaluateScoreSync(node.left, scope), rightScore = evaluateScoreSync(node.right, scope);\n      return leftScore === 0 || rightScore === 0 ? 0 : leftScore + rightScore;\n    }\n    default: {\n      const res = executeSync(node, scope);\n      return res.type === \"boolean\" && res.data === !0 ? 1 : 0;\n    }\n  }\n}\nfunction evaluateMatchScoreSync(left, right, scope) {\n  const text2 = executeSync(left, scope), pattern = executeSync(right, scope), result = processMatchScore(text2, pattern);\n  if (typeof result == \"number\") return result;\n  throw new Error(\"Found synchronous value in match()\");\n}\nasync function evaluateMatchScoreAsync(left, right, scope) {\n  const text2 = await executeAsync(left, scope), pattern = await executeAsync(right, scope);\n  return processMatchScore(text2, pattern);\n}\nfunction processMatchScore(text2, pattern) {\n  const tokens = gatherText(text2, (part) => matchTokenize(part)), terms = gatherText(pattern, (part) => matchPatternRegex(part)), process = (tokens2, terms2) => {\n    if (!terms2.success || tokens2.parts.length === 0 || terms2.parts.length === 0)\n      return 0;\n    let score = 0;\n    for (const re of terms2.parts) {\n      const freq = tokens2.parts.reduce((c, token) => c + (re.test(token) ? 1 : 0), 0);\n      score += freq * (BM25k + 1) / (freq + BM25k);\n    }\n    return score;\n  };\n  return \"then\" in tokens || \"then\" in terms ? (async () => process(await tokens, await terms))() : process(tokens, terms);\n}\nfunction extractOrderArgs(args) {\n  const mappers = [], directions = [];\n  for (let mapper of args) {\n    let direction = \"asc\";\n    mapper.type === \"Desc\" ? (direction = \"desc\", mapper = mapper.base) : mapper.type === \"Asc\" && (mapper = mapper.base), mappers.push(mapper), directions.push(direction);\n  }\n  return { mappers, directions };\n}\nfunction sortArray(aux, directions) {\n  return aux.sort((aTuple, bTuple) => {\n    for (let i = 0; i < directions.length; i++) {\n      let c = totalCompare(aTuple[i + 2], bTuple[i + 2]);\n      if (directions[i] === \"desc\" && (c = -c), c !== 0)\n        return c;\n    }\n    return aTuple[1] - bTuple[1];\n  }), aux.map((v) => v[0]);\n}\nconst pipeFunctions = {};\npipeFunctions.order = {\n  executeSync({ base, args }, scope) {\n    const { mappers, directions } = extractOrderArgs(args), aux = [];\n    let idx = 0;\n    const n = directions.length;\n    for (const value of base.data) {\n      const newScope = scope.createNested(fromJS(value)), tuple = [value, idx];\n      for (let i = 0; i < n; i++) {\n        const result = executeSync(mappers[i], newScope);\n        tuple.push(result.data);\n      }\n      aux.push(tuple), idx++;\n    }\n    return fromArray(sortArray(aux, directions));\n  },\n  async executeAsync({ base, args }, scope) {\n    const { mappers, directions } = extractOrderArgs(args), aux = [];\n    let idx = 0;\n    const n = directions.length;\n    for await (const value of base) {\n      const newScope = scope.createNested(value), tuple = [await value.get(), idx];\n      for (let i = 0; i < n; i++) {\n        const result = await executeAsync(mappers[i], newScope);\n        tuple.push(await result.get());\n      }\n      aux.push(tuple), idx++;\n    }\n    return fromArray(sortArray(aux, directions));\n  }\n};\npipeFunctions.order.arity = (count) => count >= 1;\npipeFunctions.score = {\n  async executeAsync({ base, args }, scope) {\n    const unknown = [], scored = [];\n    for await (const value of base) {\n      if (value.type !== \"object\") {\n        unknown.push(await value.get());\n        continue;\n      }\n      const newScope = scope.createNested(value);\n      let valueScore = typeof value.data._score == \"number\" ? value.data._score : 0;\n      for (const arg of args)\n        valueScore += await evaluateScoreAsync(arg, newScope);\n      const newObject = Object.assign({}, value.data, { _score: valueScore });\n      scored.push(newObject);\n    }\n    return scored.sort((a, b) => b._score - a._score), fromJS(scored);\n  },\n  executeSync({ base, args }, scope) {\n    const scored = [];\n    for (const value of base.data) {\n      if (getType(value) !== \"object\")\n        continue;\n      const valueObj = value, newScope = scope.createNested(fromJS(value));\n      let valueScore = typeof valueObj._score == \"number\" ? valueObj._score : 0;\n      for (const arg of args)\n        valueScore += evaluateScoreSync(arg, newScope);\n      const newObject = Object.assign({}, valueObj, { _score: valueScore });\n      scored.push(newObject);\n    }\n    return scored.sort((a, b) => b._score - a._score), fromArray(scored);\n  }\n};\npipeFunctions.score.arity = (count) => count >= 1;\nconst namespaces = {\n  global: _global,\n  string,\n  array,\n  pt,\n  delta,\n  diff,\n  sanity,\n  math,\n  dateTime,\n  releases,\n  text,\n  geo,\n  documents\n};\nclass MarkProcessor {\n  string;\n  marks;\n  index;\n  parseOptions;\n  allowBoost = !1;\n  constructor(string2, marks, parseOptions) {\n    this.string = string2, this.marks = marks, this.index = 0, this.parseOptions = parseOptions;\n  }\n  hasMark(pos = 0) {\n    return this.index + pos < this.marks.length;\n  }\n  getMark(pos = 0) {\n    return this.marks[this.index + pos];\n  }\n  shift() {\n    this.index += 1;\n  }\n  process(visitor) {\n    const mark = this.marks[this.index];\n    this.shift();\n    const func = visitor[mark.name];\n    if (!func)\n      throw new Error(`Unknown handler: ${mark.name}`);\n    return func.call(visitor, this, mark);\n  }\n  processString() {\n    return this.shift(), this.processStringEnd();\n  }\n  processStringEnd() {\n    const prev = this.marks[this.index - 1], curr = this.marks[this.index];\n    return this.shift(), this.string.slice(prev.position, curr.position);\n  }\n  slice(len) {\n    const pos = this.marks[this.index].position;\n    return this.string.slice(pos, pos + len);\n  }\n}\nconst WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/, NUM = /^\\d+/, IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/;\nfunction parse$1(str) {\n  let pos = 0;\n  pos = skipWS(str, pos);\n  let result = parseExpr(str, pos, 0);\n  return result.type === \"error\" ? result : (pos = skipWS(str, result.position), pos !== str.length ? (result.failPosition && (pos = result.failPosition - 1), { type: \"error\", message: \"Unexpected end of query\", position: pos }) : (delete result.position, delete result.failPosition, result));\n}\nfunction parseExpr(str, pos, level) {\n  let startPos = pos, token = str[pos], marks;\n  switch (token) {\n    case \"+\": {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 10);\n      if (rhs.type === \"error\") return rhs;\n      marks = [{ name: \"pos\", position: startPos }].concat(rhs.marks), pos = rhs.position;\n      break;\n    }\n    case \"-\": {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 8);\n      if (rhs.type === \"error\") return rhs;\n      marks = [{ name: \"neg\", position: startPos }].concat(rhs.marks), pos = rhs.position;\n      break;\n    }\n    case \"(\": {\n      let result = parseGroupOrTuple(str, pos);\n      if (result.type === \"error\") return result;\n      pos = result.position, marks = result.marks;\n      break;\n    }\n    case \"!\": {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 10);\n      if (rhs.type === \"error\") return rhs;\n      marks = [{ name: \"not\", position: startPos }].concat(rhs.marks), pos = rhs.position;\n      break;\n    }\n    case \"{\": {\n      let result = parseObject(str, pos);\n      if (result.type === \"error\") return result;\n      marks = result.marks, pos = result.position;\n      break;\n    }\n    case \"[\":\n      if (marks = [{ name: \"array\", position: pos }], pos = skipWS(str, pos + 1), str[pos] !== \"]\")\n        for (; ; ) {\n          str.slice(pos, pos + 3) === \"...\" && (marks.push({ name: \"array_splat\", position: pos }), pos = skipWS(str, pos + 3));\n          let res = parseExpr(str, pos, 0);\n          if (res.type === \"error\") return res;\n          if (marks = marks.concat(res.marks), pos = res.position, pos = skipWS(str, pos), str[pos] !== \",\" || (pos = skipWS(str, pos + 1), str[pos] === \"]\")) break;\n        }\n      if (str[pos] === \"]\")\n        pos++, marks.push({ name: \"array_end\", position: pos });\n      else\n        return { type: \"error\", message: 'Expected \"]\" after array expression', position: pos };\n      break;\n    case \"'\":\n    case '\"': {\n      let result = parseString(str, pos);\n      if (result.type === \"error\") return result;\n      marks = result.marks, pos = result.position;\n      break;\n    }\n    case \"^\": {\n      for (pos++, marks = []; str[pos] === \".\" && str[pos + 1] === \"^\"; )\n        marks.push({ name: \"dblparent\", position: startPos }), pos += 2;\n      marks.push({ name: \"parent\", position: startPos });\n      break;\n    }\n    case \"@\":\n      marks = [{ name: \"this\", position: startPos }], pos++;\n      break;\n    case \"*\":\n      marks = [{ name: \"everything\", position: startPos }], pos++;\n      break;\n    case \"$\": {\n      let identLen = parseRegex(str, pos + 1, IDENT);\n      identLen && (pos += 1 + identLen, marks = [\n        { name: \"param\", position: startPos },\n        { name: \"ident\", position: startPos + 1 },\n        { name: \"ident_end\", position: pos }\n      ]);\n      break;\n    }\n    default: {\n      let numLen = parseRegex(str, pos, NUM);\n      if (numLen) {\n        pos += numLen;\n        let name = \"integer\";\n        if (str[pos] === \".\") {\n          let fracLen = parseRegex(str, pos + 1, NUM);\n          fracLen && (name = \"float\", pos += 1 + fracLen);\n        }\n        if (str[pos] === \"e\" || str[pos] === \"E\") {\n          name = \"sci\", pos++, (str[pos] === \"+\" || str[pos] === \"-\") && pos++;\n          let expLen = parseRegex(str, pos, NUM);\n          if (!expLen) return { type: \"error\", message: \"Exponent must be a number\", position: pos };\n          pos += expLen;\n        }\n        marks = [\n          { name, position: startPos },\n          { name: name + \"_end\", position: pos }\n        ];\n        break;\n      }\n      let identLen = parseRegex(str, pos, IDENT);\n      if (identLen) {\n        switch (pos += identLen, str[pos]) {\n          case \":\":\n          case \"(\": {\n            let result = parseFuncCall(str, startPos, pos);\n            if (result.type === \"error\") return result;\n            marks = result.marks, pos = result.position;\n            break;\n          }\n          default:\n            marks = [\n              { name: \"this_attr\", position: startPos },\n              { name: \"ident\", position: startPos },\n              { name: \"ident_end\", position: pos }\n            ];\n        }\n        break;\n      }\n    }\n  }\n  if (!marks)\n    return { type: \"error\", message: \"Expected expression\", position: pos };\n  let lhsLevel = 12, trav;\n  loop: for (; ; ) {\n    let innerPos = skipWS(str, pos);\n    if (innerPos === str.length) {\n      pos = innerPos;\n      break;\n    }\n    if (trav = parseTraversal(str, innerPos), trav.type === \"success\") {\n      for (marks.unshift({ name: \"traverse\", position: startPos }); trav.type === \"success\"; )\n        marks = marks.concat(trav.marks), pos = trav.position, trav = parseTraversal(str, skipWS(str, pos));\n      marks.push({ name: \"traversal_end\", position: pos });\n      continue;\n    }\n    switch (str[innerPos]) {\n      case \"=\": {\n        switch (str[innerPos + 1]) {\n          case \">\": {\n            if (level > 1 || lhsLevel <= 1) break loop;\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), 1);\n            if (rhs.type === \"error\") return rhs;\n            marks = marks.concat(rhs.marks), marks.unshift({ name: \"pair\", position: startPos }), pos = rhs.position, lhsLevel = 1;\n            break;\n          }\n          case \"=\": {\n            if (level > 4 || lhsLevel <= 4) break loop;\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5);\n            if (rhs.type === \"error\") return rhs;\n            marks.unshift({ name: \"comp\", position: startPos }), marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 2 }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n            break;\n          }\n          default:\n            break loop;\n        }\n        break;\n      }\n      case \"+\": {\n        if (level > 6 || lhsLevel < 6) break loop;\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), 7);\n        if (rhs.type === \"error\") return rhs;\n        marks = marks.concat(rhs.marks), marks.unshift({ name: \"add\", position: startPos }), pos = rhs.position, lhsLevel = 6;\n        break;\n      }\n      case \"-\": {\n        if (level > 6 || lhsLevel < 6) break loop;\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), 7);\n        if (rhs.type === \"error\") return rhs;\n        marks = marks.concat(rhs.marks), marks.unshift({ name: \"sub\", position: startPos }), pos = rhs.position, lhsLevel = 6;\n        break;\n      }\n      case \"*\": {\n        if (str[innerPos + 1] === \"*\") {\n          if (level > 8 || lhsLevel <= 8) break loop;\n          let rhs2 = parseExpr(str, skipWS(str, innerPos + 2), 8);\n          if (rhs2.type === \"error\") return rhs2;\n          marks = marks.concat(rhs2.marks), marks.unshift({ name: \"pow\", position: startPos }), pos = rhs2.position, lhsLevel = 8;\n          break;\n        }\n        if (level > 7 || lhsLevel < 7) break loop;\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), 8);\n        if (rhs.type === \"error\") return rhs;\n        marks = marks.concat(rhs.marks), marks.unshift({ name: \"mul\", position: startPos }), pos = rhs.position, lhsLevel = 7;\n        break;\n      }\n      case \"/\": {\n        if (level > 7 || lhsLevel < 7) break loop;\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), 8);\n        if (rhs.type === \"error\") return rhs;\n        marks = marks.concat(rhs.marks), marks.unshift({ name: \"div\", position: startPos }), pos = rhs.position, lhsLevel = 7;\n        break;\n      }\n      case \"%\": {\n        if (level > 7 || lhsLevel < 7) break loop;\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), 8);\n        if (rhs.type === \"error\") return rhs;\n        marks = marks.concat(rhs.marks), marks.unshift({ name: \"mod\", position: startPos }), pos = rhs.position, lhsLevel = 7;\n        break;\n      }\n      case \"<\":\n      case \">\": {\n        if (level > 4 || lhsLevel <= 4) break loop;\n        let nextPos = innerPos + 1;\n        str[nextPos] === \"=\" && nextPos++;\n        let rhs = parseExpr(str, skipWS(str, nextPos), 5);\n        if (rhs.type === \"error\") return rhs;\n        marks.unshift({ name: \"comp\", position: startPos }), marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: nextPos }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n        break;\n      }\n      case \"|\": {\n        if (str[innerPos + 1] === \"|\") {\n          if (level > 2 || lhsLevel < 2) break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), 3);\n          if (rhs.type === \"error\") return rhs;\n          marks = marks.concat(rhs.marks), marks.unshift({ name: \"or\", position: startPos }), pos = rhs.position, lhsLevel = 2;\n        } else {\n          if (level > 11 || lhsLevel < 11) break loop;\n          let identPos = skipWS(str, innerPos + 1), identLen = parseRegex(str, identPos, IDENT);\n          if (!identLen) return { type: \"error\", message: \"Expected identifier\", position: identPos };\n          if (pos = identPos + identLen, str[pos] === \"(\" || str[pos] === \":\") {\n            let result = parseFuncCall(str, identPos, pos);\n            if (result.type === \"error\") return result;\n            marks = marks.concat(result.marks), marks.unshift({ name: \"pipecall\", position: startPos }), pos = result.position, lhsLevel = 11;\n          }\n        }\n        break;\n      }\n      case \"&\": {\n        if (str[innerPos + 1] != \"&\" || level > 3 || lhsLevel < 3) break loop;\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), 4);\n        if (rhs.type === \"error\") return rhs;\n        marks = marks.concat(rhs.marks), marks.unshift({ name: \"and\", position: startPos }), pos = rhs.position, lhsLevel = 3;\n        break;\n      }\n      case \"!\": {\n        if (str[innerPos + 1] !== \"=\" || level > 4 || lhsLevel <= 4) break loop;\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5);\n        if (rhs.type === \"error\") return rhs;\n        marks.unshift({ name: \"comp\", position: startPos }), marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 2 }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n        break;\n      }\n      case \"d\": {\n        if (str.slice(innerPos, innerPos + 4) !== \"desc\" || level > 4 || lhsLevel < 4) break loop;\n        marks.unshift({ name: \"desc\", position: startPos }), pos = innerPos + 4, lhsLevel = 4;\n        break;\n      }\n      case \"a\": {\n        if (str.slice(innerPos, innerPos + 3) !== \"asc\" || level > 4 || lhsLevel < 4) break loop;\n        marks.unshift({ name: \"asc\", position: startPos }), pos = innerPos + 3, lhsLevel = 4;\n        break;\n      }\n      default:\n        switch (parseRegexStr(str, innerPos, IDENT)) {\n          case \"in\": {\n            if (level > 4 || lhsLevel <= 4) break loop;\n            pos = skipWS(str, innerPos + 2);\n            let isGroup = !1;\n            str[pos] === \"(\" && (isGroup = !0, pos = skipWS(str, pos + 1));\n            let rangePos = pos, result = parseExpr(str, pos, 5);\n            if (result.type === \"error\") return result;\n            if (pos = skipWS(str, result.position), str[pos] === \".\" && str[pos + 1] === \".\") {\n              let type = \"inc_range\";\n              str[pos + 2] === \".\" ? (type = \"exc_range\", pos = skipWS(str, pos + 3)) : pos = skipWS(str, pos + 2);\n              let rhs = parseExpr(str, pos, 5);\n              if (rhs.type === \"error\") return rhs;\n              marks.unshift({ name: \"in_range\", position: startPos }), marks = marks.concat({ name: type, position: rangePos }, result.marks, rhs.marks), pos = rhs.position;\n            } else\n              marks.unshift({ name: \"comp\", position: startPos }), marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 2 }), marks = marks.concat(result.marks);\n            if (isGroup) {\n              if (pos = skipWS(str, pos), str[pos] !== \")\")\n                return { type: \"error\", message: 'Expected \")\" in group', position: pos };\n              pos++;\n            }\n            lhsLevel = 4;\n            break;\n          }\n          case \"match\": {\n            if (level > 4 || lhsLevel <= 4) break loop;\n            let rhs = parseExpr(str, skipWS(str, innerPos + 5), 5);\n            if (rhs.type === \"error\") return rhs;\n            marks.unshift({ name: \"comp\", position: startPos }), marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 5 }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n            break;\n          }\n          default:\n            break loop;\n        }\n    }\n  }\n  let failPosition = trav?.type === \"error\" && trav.position;\n  return { type: \"success\", marks, position: pos, failPosition };\n}\nfunction parseGroupOrTuple(str, pos) {\n  const startPos = pos;\n  let marks, rhs = parseExpr(str, skipWS(str, pos + 1), 0);\n  if (rhs.type === \"error\") return rhs;\n  switch (pos = skipWS(str, rhs.position), str[pos]) {\n    case \",\": {\n      for (marks = [{ name: \"tuple\", position: startPos }].concat(rhs.marks), pos = skipWS(str, pos + 1); ; ) {\n        if (rhs = parseExpr(str, pos, 0), rhs.type === \"error\") return rhs;\n        if (marks.push(...rhs.marks), pos = skipWS(str, rhs.position), str[pos] !== \",\") break;\n        pos = skipWS(str, pos + 1);\n      }\n      if (str[pos] !== \")\")\n        return { type: \"error\", message: 'Expected \")\" after tuple expression', position: pos };\n      pos++, marks.push({ name: \"tuple_end\", position: pos });\n      break;\n    }\n    case \")\": {\n      pos++, marks = [{ name: \"group\", position: startPos }].concat(rhs.marks);\n      break;\n    }\n    default:\n      return { type: \"error\", message: `Unexpected character \"${str[pos]}\"`, position: pos };\n  }\n  return { type: \"success\", marks, position: pos };\n}\nfunction parseTraversal(str, pos) {\n  let startPos = pos;\n  switch (str[pos]) {\n    case \".\": {\n      if (pos = skipWS(str, pos + 1), str[pos] === \"(\")\n        return parseGroupOrTuple(str, pos);\n      let identStart = pos, identLen2 = parseRegex(str, pos, IDENT);\n      return identLen2 ? (pos += identLen2, {\n        type: \"success\",\n        marks: [\n          { name: \"attr_access\", position: startPos },\n          { name: \"ident\", position: identStart },\n          { name: \"ident_end\", position: pos }\n        ],\n        position: pos\n      }) : { type: \"error\", message: 'Expected identifier after \".\"', position: pos };\n    }\n    case \"-\":\n      if (str[pos + 1] !== \">\")\n        return { type: \"error\", message: 'Expected \">\" in reference', position: pos };\n      let marks = [{ name: \"deref\", position: startPos }];\n      pos += 2;\n      let identPos = skipWS(str, pos), identLen = parseRegex(str, identPos, IDENT);\n      return identLen && (pos = identPos + identLen, marks.push(\n        { name: \"deref_attr\", position: identPos },\n        { name: \"ident\", position: identPos },\n        { name: \"ident_end\", position: pos }\n      )), {\n        type: \"success\",\n        marks,\n        position: pos\n      };\n    case \"[\": {\n      if (pos = skipWS(str, pos + 1), str[pos] === \"]\")\n        return {\n          type: \"success\",\n          marks: [{ name: \"array_postfix\", position: startPos }],\n          position: pos + 1\n        };\n      let rangePos = pos, result = parseExpr(str, pos, 0);\n      if (result.type === \"error\") return result;\n      if (pos = skipWS(str, result.position), str[pos] === \".\" && str[pos + 1] === \".\") {\n        let type = \"inc_range\";\n        str[pos + 2] === \".\" ? (type = \"exc_range\", pos += 3) : pos += 2, pos = skipWS(str, pos);\n        let rhs = parseExpr(str, pos, 0);\n        return rhs.type === \"error\" ? rhs : (pos = skipWS(str, rhs.position), str[pos] !== \"]\" ? { type: \"error\", message: 'Expected \"]\" after array expression', position: pos } : {\n          type: \"success\",\n          marks: [\n            { name: \"slice\", position: startPos },\n            { name: type, position: rangePos }\n          ].concat(result.marks, rhs.marks),\n          position: pos + 1\n        });\n      }\n      return str[pos] !== \"]\" ? { type: \"error\", message: 'Expected \"]\" after array expression', position: pos } : {\n        type: \"success\",\n        marks: [{ name: \"square_bracket\", position: startPos }].concat(result.marks),\n        position: pos + 1\n      };\n    }\n    case \"|\": {\n      if (pos = skipWS(str, pos + 1), str[pos] === \"{\") {\n        let result = parseObject(str, pos);\n        return result.type === \"error\" || result.marks.unshift({ name: \"projection\", position: startPos }), result;\n      }\n      break;\n    }\n    case \"{\": {\n      let result = parseObject(str, pos);\n      return result.type === \"error\" || result.marks.unshift({ name: \"projection\", position: startPos }), result;\n    }\n  }\n  return { type: \"error\", message: \"Unexpected character in traversal\", position: pos };\n}\nfunction parseFuncCall(str, startPos, pos) {\n  let marks = [];\n  if (marks.push({ name: \"func_call\", position: startPos }), str[pos] === \":\" && str[pos + 1] === \":\") {\n    marks.push({ name: \"namespace\", position: startPos }), marks.push({ name: \"ident\", position: startPos }, { name: \"ident_end\", position: pos }), pos = skipWS(str, pos + 2);\n    let nameLen = parseRegex(str, pos, IDENT);\n    if (!nameLen) return { type: \"error\", message: \"Expected function name\", position: pos };\n    if (marks.push({ name: \"ident\", position: pos }, { name: \"ident_end\", position: pos + nameLen }), pos = skipWS(str, pos + nameLen), str[pos] !== \"(\")\n      return { type: \"error\", message: 'Expected \"(\" after function name', position: pos };\n    pos++, pos = skipWS(str, pos);\n  } else\n    marks.push({ name: \"ident\", position: startPos }, { name: \"ident_end\", position: pos }), pos = skipWS(str, pos + 1);\n  let lastPos = pos;\n  if (str[pos] !== \")\")\n    for (; ; ) {\n      let result = parseExpr(str, pos, 0);\n      if (result.type === \"error\") return result;\n      if (marks = marks.concat(result.marks), lastPos = result.position, pos = skipWS(str, result.position), str[pos] !== \",\" || (pos = skipWS(str, pos + 1), str[pos] === \")\")) break;\n    }\n  return str[pos] !== \")\" ? { type: \"error\", message: 'Expected \")\" after function arguments', position: pos } : (marks.push({ name: \"func_args_end\", position: lastPos }), {\n    type: \"success\",\n    marks,\n    position: pos + 1\n  });\n}\nfunction parseObject(str, pos) {\n  let marks = [{ name: \"object\", position: pos }];\n  for (pos = skipWS(str, pos + 1); str[pos] !== \"}\"; ) {\n    let pairPos = pos;\n    if (str.slice(pos, pos + 3) === \"...\")\n      if (pos = skipWS(str, pos + 3), str[pos] !== \"}\" && str[pos] !== \",\") {\n        let expr = parseExpr(str, pos, 0);\n        if (expr.type === \"error\") return expr;\n        marks.push({ name: \"object_splat\", position: pairPos }), marks = marks.concat(expr.marks), pos = expr.position;\n      } else\n        marks.push({ name: \"object_splat_this\", position: pairPos });\n    else {\n      let expr = parseExpr(str, pos, 0);\n      if (expr.type === \"error\") return expr;\n      let nextPos = skipWS(str, expr.position);\n      if (expr.marks[0].name === \"str\" && str[nextPos] === \":\") {\n        let value = parseExpr(str, skipWS(str, nextPos + 1), 0);\n        if (value.type === \"error\") return value;\n        marks.push({ name: \"object_pair\", position: pairPos }), marks = marks.concat(expr.marks, value.marks), pos = value.position;\n      } else\n        marks = marks.concat({ name: \"object_expr\", position: pos }, expr.marks), pos = expr.position;\n    }\n    if (pos = skipWS(str, pos), str[pos] !== \",\") break;\n    pos = skipWS(str, pos + 1);\n  }\n  return str[pos] !== \"}\" ? { type: \"error\", message: 'Expected \"}\" after object', position: pos } : (pos++, marks.push({ name: \"object_end\", position: pos }), { type: \"success\", marks, position: pos });\n}\nfunction parseString(str, pos) {\n  let token = str[pos];\n  pos = pos + 1;\n  const marks = [{ name: \"str\", position: pos }];\n  str: for (; ; pos++) {\n    if (pos > str.length) return { type: \"error\", message: \"Unexpected end of query\", position: pos };\n    switch (str[pos]) {\n      case token: {\n        marks.push({ name: \"str_end\", position: pos }), pos++;\n        break str;\n      }\n      case \"\\\\\":\n        marks.push({ name: \"str_pause\", position: pos }), str[pos + 1] === \"u\" ? str[pos + 2] === \"{\" ? (marks.push({ name: \"unicode_hex\", position: pos + 3 }), pos = str.indexOf(\"}\", pos + 3), marks.push({ name: \"unicode_hex_end\", position: pos })) : (marks.push({ name: \"unicode_hex\", position: pos + 2 }), marks.push({ name: \"unicode_hex_end\", position: pos + 6 }), pos += 5) : (marks.push({ name: \"single_escape\", position: pos + 1 }), pos += 1), marks.push({ name: \"str_start\", position: pos + 1 });\n    }\n  }\n  return { type: \"success\", marks, position: pos };\n}\nfunction skipWS(str, pos) {\n  return pos + parseRegex(str, pos, WS);\n}\nfunction parseRegex(str, pos, re) {\n  let m = re.exec(str.slice(pos));\n  return m ? m[0].length : 0;\n}\nfunction parseRegexStr(str, pos, re) {\n  let m = re.exec(str.slice(pos));\n  return m ? m[0] : null;\n}\nfunction join(a, b) {\n  return (base) => b(a(base));\n}\nfunction map(inner) {\n  return (base) => ({ type: \"Map\", base, expr: inner({ type: \"This\" }) });\n}\nfunction flatMap(inner) {\n  return (base) => ({ type: \"FlatMap\", base, expr: inner({ type: \"This\" }) });\n}\nfunction traverseArray(build, right) {\n  if (!right)\n    return {\n      type: \"a-a\",\n      build\n    };\n  switch (right.type) {\n    case \"a-a\":\n      return {\n        type: \"a-a\",\n        build: join(build, right.build)\n      };\n    case \"a-b\":\n      return {\n        type: \"a-b\",\n        build: join(build, right.build)\n      };\n    case \"b-b\":\n      return {\n        type: \"a-a\",\n        build: join(build, map(right.build))\n      };\n    case \"b-a\":\n      return {\n        type: \"a-a\",\n        build: join(build, flatMap(right.build))\n      };\n    default:\n      throw new Error(`unknown type: ${right.type}`);\n  }\n}\nfunction traversePlain(mapper, right) {\n  if (!right)\n    return {\n      type: \"b-b\",\n      build: mapper\n    };\n  switch (right.type) {\n    case \"a-a\":\n    case \"b-a\":\n      return {\n        type: \"b-a\",\n        build: join(mapper, right.build)\n      };\n    case \"a-b\":\n    case \"b-b\":\n      return {\n        type: \"b-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(`unknown type: ${right.type}`);\n  }\n}\nfunction traverseElement(mapper, right) {\n  if (!right)\n    return {\n      type: \"a-b\",\n      build: mapper\n    };\n  switch (right.type) {\n    case \"a-a\":\n    case \"b-a\":\n      return {\n        type: \"a-a\",\n        build: join(mapper, right.build)\n      };\n    case \"a-b\":\n    case \"b-b\":\n      return {\n        type: \"a-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(`unknown type: ${right.type}`);\n  }\n}\nfunction traverseProjection(mapper, right) {\n  if (!right)\n    return {\n      type: \"b-b\",\n      build: mapper\n    };\n  switch (right.type) {\n    case \"a-a\":\n      return {\n        type: \"a-a\",\n        build: join(map(mapper), right.build)\n      };\n    case \"a-b\":\n      return {\n        type: \"a-b\",\n        build: join(map(mapper), right.build)\n      };\n    case \"b-a\":\n      return {\n        type: \"b-a\",\n        build: join(mapper, right.build)\n      };\n    case \"b-b\":\n      return {\n        type: \"b-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(`unknown type: ${right.type}`);\n  }\n}\nconst ESCAPE_SEQUENCE = {\n  \"'\": \"'\",\n  '\"': '\"',\n  \"\\\\\": \"\\\\\",\n  \"/\": \"/\",\n  b: \"\\b\",\n  f: \"\\f\",\n  n: `\n`,\n  r: \"\\r\",\n  t: \"\t\"\n};\nfunction expandHex(str) {\n  const charCode = parseInt(str, 16);\n  return String.fromCharCode(charCode);\n}\nclass GroqQueryError extends Error {\n  name = \"GroqQueryError\";\n}\nconst EXPR_BUILDER = {\n  group(p) {\n    return {\n      type: \"Group\",\n      base: p.process(EXPR_BUILDER)\n    };\n  },\n  everything() {\n    return { type: \"Everything\" };\n  },\n  this() {\n    return { type: \"This\" };\n  },\n  parent() {\n    return {\n      type: \"Parent\",\n      n: 1\n    };\n  },\n  dblparent(p) {\n    return {\n      type: \"Parent\",\n      n: p.process(EXPR_BUILDER).n + 1\n    };\n  },\n  traverse(p) {\n    const base = p.process(EXPR_BUILDER), traversalList = [];\n    for (; p.getMark().name !== \"traversal_end\"; )\n      traversalList.push(p.process(TRAVERSE_BUILDER));\n    p.shift();\n    let traversal = null;\n    for (let i = traversalList.length - 1; i >= 0; i--)\n      traversal = traversalList[i](traversal);\n    if ((base.type === \"Everything\" || base.type === \"Array\" || base.type === \"PipeFuncCall\") && (traversal = traverseArray((val) => val, traversal)), traversal === null) throw new Error(\"BUG: unexpected empty traversal\");\n    return traversal.build(base);\n  },\n  this_attr(p) {\n    const name = p.processString();\n    return name === \"null\" ? { type: \"Value\", value: null } : name === \"true\" ? { type: \"Value\", value: !0 } : name === \"false\" ? { type: \"Value\", value: !1 } : {\n      type: \"AccessAttribute\",\n      name\n    };\n  },\n  neg(p) {\n    return {\n      type: \"Neg\",\n      base: p.process(EXPR_BUILDER)\n    };\n  },\n  pos(p) {\n    return {\n      type: \"Pos\",\n      base: p.process(EXPR_BUILDER)\n    };\n  },\n  add(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"+\",\n      left,\n      right\n    };\n  },\n  sub(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"-\",\n      left,\n      right\n    };\n  },\n  mul(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"*\",\n      left,\n      right\n    };\n  },\n  div(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"/\",\n      left,\n      right\n    };\n  },\n  mod(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"%\",\n      left,\n      right\n    };\n  },\n  pow(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"**\",\n      left,\n      right\n    };\n  },\n  comp(p) {\n    const left = p.process(EXPR_BUILDER), op = p.processString(), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op,\n      left,\n      right\n    };\n  },\n  in_range(p) {\n    const base = p.process(EXPR_BUILDER), isInclusive = p.getMark().name === \"inc_range\";\n    p.shift();\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"InRange\",\n      base,\n      left,\n      right,\n      isInclusive\n    };\n  },\n  str(p) {\n    let value = \"\";\n    loop: for (; p.hasMark(); ) {\n      const mark = p.getMark();\n      switch (mark.name) {\n        case \"str_end\":\n          value += p.processStringEnd();\n          break loop;\n        case \"str_pause\":\n          value += p.processStringEnd();\n          break;\n        case \"str_start\":\n          p.shift();\n          break;\n        case \"single_escape\": {\n          const char = p.slice(1);\n          p.shift(), value += ESCAPE_SEQUENCE[char];\n          break;\n        }\n        case \"unicode_hex\":\n          p.shift(), value += expandHex(p.processStringEnd());\n          break;\n        default:\n          throw new Error(`unexpected mark: ${mark.name}`);\n      }\n    }\n    return { type: \"Value\", value };\n  },\n  integer(p) {\n    const strValue = p.processStringEnd();\n    return {\n      type: \"Value\",\n      value: Number(strValue)\n    };\n  },\n  float(p) {\n    const strValue = p.processStringEnd();\n    return {\n      type: \"Value\",\n      value: Number(strValue)\n    };\n  },\n  sci(p) {\n    const strValue = p.processStringEnd();\n    return {\n      type: \"Value\",\n      value: Number(strValue)\n    };\n  },\n  object(p) {\n    const attributes = [];\n    for (; p.getMark().name !== \"object_end\"; )\n      attributes.push(p.process(OBJECT_BUILDER));\n    return p.shift(), {\n      type: \"Object\",\n      attributes\n    };\n  },\n  array(p) {\n    const elements = [];\n    for (; p.getMark().name !== \"array_end\"; ) {\n      let isSplat = !1;\n      p.getMark().name === \"array_splat\" && (isSplat = !0, p.shift());\n      const value = p.process(EXPR_BUILDER);\n      elements.push({\n        type: \"ArrayElement\",\n        value,\n        isSplat\n      });\n    }\n    return p.shift(), {\n      type: \"Array\",\n      elements\n    };\n  },\n  tuple(p) {\n    const members = [];\n    for (; p.getMark().name !== \"tuple_end\"; )\n      members.push(p.process(EXPR_BUILDER));\n    return p.shift(), {\n      type: \"Tuple\",\n      members\n    };\n  },\n  func_call(p) {\n    let namespace = \"global\";\n    p.getMark().name === \"namespace\" && (p.shift(), namespace = p.processString());\n    const name = p.processString();\n    if (namespace === \"global\" && name === \"select\") {\n      const result = {\n        type: \"Select\",\n        alternatives: []\n      };\n      for (; p.getMark().name !== \"func_args_end\"; )\n        if (p.getMark().name === \"pair\") {\n          if (result.fallback) throw new GroqQueryError(\"unexpected argument to select()\");\n          p.shift();\n          const condition = p.process(EXPR_BUILDER), value = p.process(EXPR_BUILDER);\n          result.alternatives.push({\n            type: \"SelectAlternative\",\n            condition,\n            value\n          });\n        } else {\n          if (result.fallback) throw new GroqQueryError(\"unexpected argument to select()\");\n          const value = p.process(EXPR_BUILDER);\n          result.fallback = value;\n        }\n      return p.shift(), result;\n    }\n    const args = [];\n    for (; p.getMark().name !== \"func_args_end\"; )\n      argumentShouldBeSelector(namespace, name, args.length) ? args.push(p.process(SELECTOR_BUILDER)) : args.push(p.process(EXPR_BUILDER));\n    if (p.shift(), namespace === \"global\" && (name === \"before\" || name === \"after\") && p.parseOptions.mode === \"delta\")\n      return {\n        type: \"Context\",\n        key: name\n      };\n    if (namespace === \"global\" && name === \"boost\" && !p.allowBoost)\n      throw new GroqQueryError(\"unexpected boost\");\n    const funcs = namespaces[namespace];\n    if (!funcs)\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`);\n    const func = funcs[name];\n    if (!func)\n      throw new GroqQueryError(`Undefined function: ${name}`);\n    if (func.arity !== void 0 && validateArity(name, func.arity, args.length), func.mode !== void 0 && func.mode !== p.parseOptions.mode)\n      throw new GroqQueryError(`Undefined function: ${name}`);\n    return {\n      type: \"FuncCall\",\n      func,\n      namespace,\n      name,\n      args\n    };\n  },\n  pipecall(p) {\n    const base = p.process(EXPR_BUILDER);\n    p.shift();\n    let namespace = \"global\";\n    if (p.getMark().name === \"namespace\" && (p.shift(), namespace = p.processString()), namespace !== \"global\")\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`);\n    const name = p.processString(), args = [], oldAllowBoost = p.allowBoost;\n    for (name === \"score\" && (p.allowBoost = !0); ; ) {\n      const markName = p.getMark().name;\n      if (markName === \"func_args_end\")\n        break;\n      if (name === \"order\") {\n        if (markName === \"asc\") {\n          p.shift(), args.push({ type: \"Asc\", base: p.process(EXPR_BUILDER) });\n          continue;\n        } else if (markName === \"desc\") {\n          p.shift(), args.push({ type: \"Desc\", base: p.process(EXPR_BUILDER) });\n          continue;\n        }\n      }\n      args.push(p.process(EXPR_BUILDER));\n    }\n    p.shift(), p.allowBoost = oldAllowBoost;\n    const func = pipeFunctions[name];\n    if (!func)\n      throw new GroqQueryError(`Undefined pipe function: ${name}`);\n    return func.arity && validateArity(name, func.arity, args.length), {\n      type: \"PipeFuncCall\",\n      func,\n      base,\n      name,\n      args\n    };\n  },\n  pair() {\n    throw new GroqQueryError(\"unexpected =>\");\n  },\n  and(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"And\",\n      left,\n      right\n    };\n  },\n  or(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"Or\",\n      left,\n      right\n    };\n  },\n  not(p) {\n    return {\n      type: \"Not\",\n      base: p.process(EXPR_BUILDER)\n    };\n  },\n  asc() {\n    throw new GroqQueryError(\"unexpected asc\");\n  },\n  desc() {\n    throw new GroqQueryError(\"unexpected desc\");\n  },\n  param(p) {\n    const name = p.processString();\n    return p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name) ? {\n      type: \"Value\",\n      value: p.parseOptions.params[name]\n    } : {\n      type: \"Parameter\",\n      name\n    };\n  }\n}, OBJECT_BUILDER = {\n  object_expr(p) {\n    if (p.getMark().name === \"pair\") {\n      p.shift();\n      const condition = p.process(EXPR_BUILDER), value2 = p.process(EXPR_BUILDER);\n      return {\n        type: \"ObjectConditionalSplat\",\n        condition,\n        value: value2\n      };\n    }\n    const value = p.process(EXPR_BUILDER);\n    return {\n      type: \"ObjectAttributeValue\",\n      name: extractPropertyKey(value),\n      value\n    };\n  },\n  object_pair(p) {\n    const name = p.process(EXPR_BUILDER);\n    if (name.type !== \"Value\") throw new Error(\"name must be string\");\n    const value = p.process(EXPR_BUILDER);\n    return {\n      type: \"ObjectAttributeValue\",\n      name: name.value,\n      value\n    };\n  },\n  object_splat(p) {\n    return {\n      type: \"ObjectSplat\",\n      value: p.process(EXPR_BUILDER)\n    };\n  },\n  object_splat_this() {\n    return {\n      type: \"ObjectSplat\",\n      value: { type: \"This\" }\n    };\n  }\n}, TRAVERSE_BUILDER = {\n  square_bracket(p) {\n    const expr = p.process(EXPR_BUILDER), value = tryConstantEvaluate(expr);\n    return value && value.type === \"number\" ? (right) => traverseElement((base) => ({ type: \"AccessElement\", base, index: value.data }), right) : value && value.type === \"string\" ? (right) => traversePlain((base) => ({ type: \"AccessAttribute\", base, name: value.data }), right) : (right) => traverseArray(\n      (base) => ({\n        type: \"Filter\",\n        base,\n        expr\n      }),\n      right\n    );\n  },\n  slice(p) {\n    const isInclusive = p.getMark().name === \"inc_range\";\n    p.shift();\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER), leftValue = tryConstantEvaluate(left), rightValue = tryConstantEvaluate(right);\n    if (!leftValue || !rightValue || leftValue.type !== \"number\" || rightValue.type !== \"number\")\n      throw new GroqQueryError(\"slicing must use constant numbers\");\n    return (rhs) => traverseArray(\n      (base) => ({\n        type: \"Slice\",\n        base,\n        left: leftValue.data,\n        right: rightValue.data,\n        isInclusive\n      }),\n      rhs\n    );\n  },\n  projection(p) {\n    const obj = p.process(EXPR_BUILDER);\n    return (right) => traverseProjection((base) => ({ type: \"Projection\", base, expr: obj }), right);\n  },\n  attr_access(p) {\n    const name = p.processString();\n    return (right) => traversePlain((base) => ({ type: \"AccessAttribute\", base, name }), right);\n  },\n  deref(p) {\n    let attr = null;\n    p.getMark().name === \"deref_attr\" && (p.shift(), attr = p.processString());\n    const wrap = (base) => attr ? { type: \"AccessAttribute\", base, name: attr } : base;\n    return (right) => traversePlain(\n      (base) => wrap({\n        type: \"Deref\",\n        base\n      }),\n      right\n    );\n  },\n  array_postfix() {\n    return (right) => traverseArray((base) => ({ type: \"ArrayCoerce\", base }), right);\n  }\n}, SELECTOR_BUILDER = {\n  group(p) {\n    return p.process(SELECTOR_BUILDER);\n  },\n  everything() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  this() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  parent() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  dblparent() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  traverse(p) {\n    let node = p.process(SELECTOR_BUILDER);\n    for (; p.getMark().name !== \"traversal_end\"; )\n      if (p.getMark().name === \"array_postfix\")\n        p.shift(), node = { type: \"ArrayCoerce\", base: node };\n      else if (p.getMark().name === \"square_bracket\") {\n        p.shift();\n        const expr = p.process(EXPR_BUILDER), value = tryConstantEvaluate(expr);\n        if (value && value.type === \"number\")\n          throw new Error(\"Invalid array access expression\");\n        value && value.type === \"string\" ? node = { type: \"AccessAttribute\", base: node, name: value.data } : node = { type: \"Filter\", base: node, expr };\n      } else if (p.getMark().name === \"attr_access\") {\n        p.shift();\n        const name = p.processString();\n        node = { type: \"AccessAttribute\", base: node, name };\n      } else if (p.getMark().name === \"tuple\" || p.getMark().name === \"group\") {\n        const selector = p.process(SELECTOR_BUILDER);\n        if (!isSelectorNested(selector))\n          throw new Error(`Unexpected result parsing nested selector: ${selector.type}`);\n        node = { type: \"SelectorNested\", base: node, nested: selector };\n      } else\n        throw new Error(\"Invalid selector syntax\");\n    return p.shift(), node;\n  },\n  this_attr(p) {\n    return { type: \"AccessAttribute\", name: p.processString() };\n  },\n  attr_access() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  neg() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  pos() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  add() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  sub() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  mul() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  div() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  mod() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  pow() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  comp() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  in_range() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  str() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  integer() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  float() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  sci() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  object() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  array() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  tuple(p) {\n    const selectors = [];\n    for (; p.getMark().name !== \"tuple_end\"; )\n      selectors.push(p.process(SELECTOR_BUILDER));\n    return p.shift(), { type: \"Tuple\", members: selectors };\n  },\n  func_call(p, mark) {\n    const func = EXPR_BUILDER.func_call(p, mark);\n    if (func.name === \"anywhere\" && func.args.length === 1)\n      return {\n        type: \"SelectorFuncCall\",\n        name: \"anywhere\",\n        arg: func.args[0]\n      };\n    throw new Error(\"Invalid selector syntax\");\n  },\n  pipecall() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  pair() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  and() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  or() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  not() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  asc() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  desc() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  param() {\n    throw new Error(\"Invalid selector syntax\");\n  }\n};\nfunction extractPropertyKey(node) {\n  if (node.type === \"AccessAttribute\" && !node.base)\n    return node.name;\n  if (node.type === \"PipeFuncCall\" || node.type === \"Deref\" || node.type === \"Map\" || node.type === \"Projection\" || node.type === \"Slice\" || node.type === \"Filter\" || node.type === \"AccessElement\" || node.type === \"ArrayCoerce\" || node.type === \"Group\")\n    return extractPropertyKey(node.base);\n  throw new GroqQueryError(`Cannot determine property key for type: ${node.type}`);\n}\nfunction validateArity(name, arity, count) {\n  if (typeof arity == \"number\") {\n    if (count !== arity)\n      throw new GroqQueryError(\n        `Incorrect number of arguments to function ${name}(). Expected ${arity}, got ${count}.`\n      );\n  } else if (arity && !arity(count))\n    throw new GroqQueryError(`Incorrect number of arguments to function ${name}().`);\n}\nfunction argumentShouldBeSelector(namespace, functionName, argCount) {\n  const functionsRequiringSelectors = [\"changedAny\", \"changedOnly\"];\n  return namespace == \"diff\" && argCount == 2 && functionsRequiringSelectors.includes(functionName);\n}\nclass GroqSyntaxError extends Error {\n  position;\n  name = \"GroqSyntaxError\";\n  constructor(position, detail) {\n    super(`Syntax error in GROQ query at position ${position}${detail ? \": \" + detail : \"\"}`), this.position = position;\n  }\n}\nfunction parse(input, options = {}) {\n  const result = parse$1(input);\n  if (result.type === \"error\")\n    throw new GroqSyntaxError(result.position, result.message);\n  return new MarkProcessor(input, result.marks, options).process(EXPR_BUILDER);\n}\nconst { compare } = new Intl.Collator(\"en\");\nfunction typeNodesSorter(a, b) {\n  return a.type === \"null\" ? 1 : compare(hashField(a), hashField(b));\n}\nconst hashCache = /* @__PURE__ */ new WeakMap();\nfunction hashField(field) {\n  if (hashCache.has(field))\n    return hashCache.get(field);\n  const hash = calculateFieldHash(field);\n  return hashCache.set(field, hash), hash;\n}\nfunction calculateFieldHash(field) {\n  switch (field.type) {\n    case \"string\":\n    case \"number\":\n    case \"boolean\":\n      return field.value !== void 0 ? `${field.type}(${field.value})` : `${field.type}`;\n    case \"null\":\n    case \"unknown\":\n      return field.type;\n    case \"array\":\n      return `${field.type}(${hashField(field.of)})`;\n    case \"object\": {\n      const attributes = Object.entries(field.attributes);\n      return attributes.sort(([a], [b]) => compare(a, b)), `${field.type}:(${attributes.map(\n        ([key, value]) => `${key}:${hashField(value.value)}(${value.optional ? \"optional\" : \"non-optional\"})`\n      ).join(\",\")}):ref-${field.dereferencesTo}:${field.rest ? hashField(field.rest) : \"no-rest\"}`;\n    }\n    case \"union\": {\n      const sorted = [...field.of];\n      return sorted.sort(typeNodesSorter), `${field.type}(${sorted.map(hashField).join(\",\")})`;\n    }\n    case \"inline\":\n      return `${field.type}(${field.name})`;\n    default:\n      return field.type;\n  }\n}\nfunction removeDuplicateTypeNodes(typeNodes) {\n  const seenTypes = /* @__PURE__ */ new Set(), newTypeNodes = [], sortedTypeNodes = [...typeNodes];\n  sortedTypeNodes.sort(typeNodesSorter);\n  for (const typeNode of sortedTypeNodes) {\n    const hash = hashField(typeNode);\n    if (hash === null) {\n      newTypeNodes.push(typeNode);\n      continue;\n    }\n    seenTypes.has(hash) || (seenTypes.add(hash), newTypeNodes.push(typeNode));\n  }\n  return newTypeNodes;\n}\nfunction optimizeUnions(field) {\n  if (field.type === \"union\") {\n    if (field.of.length === 0)\n      return field;\n    if (field.of = removeDuplicateTypeNodes(field.of), field.of.length === 1)\n      return optimizeUnions(field.of[0]);\n    for (let idx = 0; field.of.length > idx; idx++) {\n      const subField = field.of[idx];\n      if (subField.type === \"union\") {\n        field.of.splice(idx, 1, ...subField.of), idx--;\n        continue;\n      }\n      field.of[idx] = optimizeUnions(subField);\n    }\n    return field.of.sort((a, b) => a.type === \"null\" ? 1 : compare(hashField(a), hashField(b))), field;\n  }\n  if (field.type === \"array\")\n    return field.of = optimizeUnions(field.of), field;\n  if (field.type === \"object\") {\n    for (const idx in field.attributes)\n      Object.hasOwn(field.attributes, idx) && (field.attributes[idx].value = optimizeUnions(field.attributes[idx].value));\n    return field;\n  }\n  return field;\n}\nfunction createReferenceTypeNode(name, inArray = !1) {\n  const attributes = {\n    _ref: {\n      type: \"objectAttribute\",\n      value: {\n        type: \"string\"\n      }\n    },\n    _type: {\n      type: \"objectAttribute\",\n      value: {\n        type: \"string\",\n        value: \"reference\"\n      }\n    },\n    _weak: {\n      type: \"objectAttribute\",\n      value: {\n        type: \"boolean\"\n      },\n      optional: !0\n    }\n  };\n  return inArray && (attributes._key = {\n    type: \"objectAttribute\",\n    value: {\n      type: \"string\"\n    }\n  }), {\n    type: \"object\",\n    attributes,\n    dereferencesTo: name\n  };\n}\nfunction nullUnion(node) {\n  return node.type === \"union\" ? unionOf(...node.of, { type: \"null\" }) : unionOf(node, { type: \"null\" });\n}\nfunction unionOf(...nodes) {\n  return {\n    type: \"union\",\n    of: nodes\n  };\n}\nfunction resolveInline(node, scope) {\n  if (node.type === \"inline\") {\n    const resolvedInline = scope.context.lookupTypeDeclaration(node);\n    return resolveInline(resolvedInline, scope);\n  }\n  return node;\n}\nfunction mapNode(node, scope, mapper, mergeUnions = (nodes) => optimizeUnions({ type: \"union\", of: nodes })) {\n  switch (node.type) {\n    case \"boolean\":\n    case \"array\":\n    case \"null\":\n    case \"object\":\n    case \"string\":\n    case \"number\":\n    case \"unknown\":\n      return mapper(node);\n    case \"union\":\n      return mergeUnions(node.of.map((inner) => mapNode(inner, scope, mapper), mergeUnions));\n    case \"inline\": {\n      const resolvedInline = resolveInline(node, scope);\n      return mapNode(resolvedInline, scope, mapper, mergeUnions);\n    }\n    default:\n      throw new Error(`Unknown type: ${node.type}`);\n  }\n}\nfunction isFuncCall(node, name) {\n  return node.type === \"Group\" ? isFuncCall(node.base, name) : node.type === \"FuncCall\" && `${node.namespace}::${node.name}` === name;\n}\nfunction createGeoJson(type = \"Point\") {\n  let coordinateAttribute = {\n    type: \"array\",\n    of: {\n      type: \"number\"\n    }\n  };\n  return type === \"LineString\" && (coordinateAttribute = {\n    type: \"array\",\n    of: {\n      type: \"array\",\n      of: {\n        type: \"number\"\n      }\n    }\n  }), type === \"Polygon\" && (coordinateAttribute = {\n    type: \"array\",\n    of: {\n      type: \"array\",\n      of: {\n        type: \"array\",\n        of: {\n          type: \"number\"\n        }\n      }\n    }\n  }), {\n    type: \"object\",\n    attributes: {\n      type: {\n        type: \"objectAttribute\",\n        value: {\n          type: \"string\",\n          value: type\n        }\n      },\n      coordinates: {\n        type: \"objectAttribute\",\n        value: coordinateAttribute\n      }\n    }\n  };\n}\nfunction booleanValue(node, scope) {\n  switch (node.type) {\n    case \"unknown\":\n      return { canBeTrue: !0, canBeFalse: !0, canBeNull: !0 };\n    case \"boolean\":\n      return node.value === !0 ? { canBeTrue: !0, canBeFalse: !1, canBeNull: !1 } : node.value === !1 ? { canBeTrue: !1, canBeFalse: !0, canBeNull: !1 } : { canBeTrue: !0, canBeFalse: !0, canBeNull: !1 };\n    case \"union\": {\n      const value = { canBeTrue: !1, canBeFalse: !1, canBeNull: !1 };\n      for (const sub of node.of) {\n        const match2 = booleanValue(sub, scope);\n        match2.canBeNull && (value.canBeNull = !0), match2.canBeTrue && (value.canBeTrue = !0), match2.canBeFalse && (value.canBeFalse = !0);\n      }\n      return value;\n    }\n    case \"inline\": {\n      const resolved = resolveInline(node, scope);\n      return booleanValue(resolved, scope);\n    }\n    case \"null\":\n    case \"string\":\n    case \"number\":\n    case \"object\":\n    case \"array\":\n      return { canBeTrue: !1, canBeFalse: !1, canBeNull: !0 };\n    default:\n      throw new Error(`unknown node type ${node.type}`);\n  }\n}\nfunction booleanOr(left, right) {\n  return left.canBeTrue && !left.canBeFalse && !left.canBeNull ? left : right.canBeTrue && !right.canBeFalse && !right.canBeNull ? right : {\n    // Either side can be true for the expression to be true\n    canBeTrue: left.canBeTrue || right.canBeTrue,\n    // Both sides must be false for the expression to be false\n    canBeFalse: left.canBeFalse && right.canBeFalse,\n    // if either side can be null, the expression can be null if the other side can't only be true\n    canBeNull: left.canBeNull || right.canBeNull\n  };\n}\nfunction booleanAnd(left, right) {\n  return left.canBeFalse && !left.canBeTrue && !left.canBeNull ? left : right.canBeFalse && !right.canBeTrue && !right.canBeNull ? right : {\n    // Both sides must be true for the expression to be true\n    canBeTrue: left.canBeTrue && right.canBeTrue,\n    // if either side can be false, the expression can be false\n    canBeFalse: left.canBeFalse || right.canBeFalse,\n    // if either side can be null, the expression can be null\n    canBeNull: left.canBeNull || right.canBeNull\n  };\n}\nfunction booleanInterpretationToTypeNode(bool) {\n  return bool.canBeTrue ? bool.canBeFalse ? bool.canBeNull ? nullUnion({ type: \"boolean\" }) : { type: \"boolean\" } : bool.canBeNull ? nullUnion({ type: \"boolean\", value: !0 }) : { type: \"boolean\", value: !0 } : bool.canBeFalse ? bool.canBeNull ? nullUnion({ type: \"boolean\", value: !1 }) : { type: \"boolean\", value: !1 } : { type: \"null\" };\n}\nfunction unionWithoutNull(unionTypeNode) {\n  return unionTypeNode.type === \"union\" ? {\n    type: \"union\",\n    of: unionTypeNode.of.filter((type) => type.type !== \"null\")\n  } : unionTypeNode;\n}\nfunction handleFuncCallNode(node, scope) {\n  switch (`${node.namespace}.${node.name}`) {\n    case \"array.compact\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => {\n        if (arg2.type === \"unknown\")\n          return nullUnion({ type: \"array\", of: { type: \"unknown\" } });\n        if (arg2.type !== \"array\")\n          return { type: \"null\" };\n        const of = mapNode(arg2.of, scope, (of2) => of2);\n        return {\n          type: \"array\",\n          of: unionWithoutNull(of)\n        };\n      });\n    }\n    case \"array.join\": {\n      const arrayArg = walk({ node: node.args[0], scope }), sepArg = walk({ node: node.args[1], scope });\n      return mapNode(\n        arrayArg,\n        scope,\n        (arrayArg2) => mapNode(sepArg, scope, (sepArg2) => arrayArg2.type === \"unknown\" || sepArg2.type === \"unknown\" ? nullUnion({ type: \"string\" }) : arrayArg2.type !== \"array\" || sepArg2.type !== \"string\" ? { type: \"null\" } : mapNode(arrayArg2.of, scope, (of) => of.type === \"unknown\" ? nullUnion({ type: \"string\" }) : of.type !== \"string\" && of.type !== \"number\" && of.type !== \"boolean\" ? { type: \"null\" } : { type: \"string\" }))\n      );\n    }\n    case \"array.unique\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => arg2.type === \"unknown\" ? nullUnion({ type: \"array\", of: { type: \"unknown\" } }) : arg2.type !== \"array\" ? { type: \"null\" } : arg2);\n    }\n    case \"array.intersects\": {\n      const arg1 = walk({ node: node.args[0], scope }), arg2 = walk({ node: node.args[1], scope });\n      return mapNode(\n        arg1,\n        scope,\n        (arg12) => mapNode(arg2, scope, (arg22) => arg12.type !== \"array\" ? { type: \"null\" } : arg22.type !== \"array\" ? { type: \"null\" } : { type: \"boolean\" })\n      );\n    }\n    case \"global.lower\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => arg2.type === \"unknown\" ? nullUnion({ type: \"string\" }) : arg2.type !== \"string\" ? { type: \"null\" } : arg2.value !== void 0 ? {\n        type: \"string\",\n        value: arg2.value.toLowerCase()\n      } : { type: \"string\" });\n    }\n    case \"global.upper\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => arg2.type === \"unknown\" ? nullUnion({ type: \"string\" }) : arg2.type !== \"string\" ? { type: \"null\" } : arg2.value !== void 0 ? {\n        type: \"string\",\n        value: arg2.value.toUpperCase()\n      } : { type: \"string\" });\n    }\n    case \"dateTime.now\":\n      return { type: \"string\" };\n    case \"global.now\":\n      return { type: \"string\" };\n    case \"global.defined\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (node2) => node2.type === \"unknown\" ? { type: \"boolean\" } : { type: \"boolean\", value: node2.type !== \"null\" });\n    }\n    case \"global.path\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => arg2.type === \"unknown\" ? nullUnion({ type: \"string\" }) : arg2.type === \"string\" ? { type: \"string\" } : { type: \"null\" });\n    }\n    case \"global.coalesce\": {\n      if (node.args.length === 0)\n        return { type: \"null\" };\n      const typeNodes = [];\n      let canBeNull = !0;\n      for (const arg of node.args) {\n        const argNode = optimizeUnions(walk({ node: arg, scope })), allNull = argNode.type === \"null\" || argNode.type === \"union\" && argNode.of.every((t) => t.type === \"null\");\n        if (canBeNull = allNull || argNode.type === \"unknown\" || argNode.type === \"union\" && argNode.of.some((t) => t.type === \"null\" || t.type === \"unknown\"), allNull || typeNodes.push(unionWithoutNull(argNode)), !canBeNull)\n          break;\n      }\n      return canBeNull && typeNodes.push({ type: \"null\" }), {\n        type: \"union\",\n        of: typeNodes\n      };\n    }\n    case \"global.count\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => arg2.type === \"unknown\" ? nullUnion({ type: \"string\" }) : arg2.type === \"array\" ? { type: \"number\" } : { type: \"null\" });\n    }\n    case \"global.dateTime\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => arg2.type === \"unknown\" ? nullUnion({ type: \"string\" }) : arg2.type === \"string\" ? nullUnion({ type: \"string\" }) : { type: \"null\" });\n    }\n    case \"global.length\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => arg2.type === \"unknown\" ? nullUnion({ type: \"number\" }) : arg2.type === \"array\" || arg2.type === \"string\" ? { type: \"number\" } : { type: \"null\" });\n    }\n    case \"global.references\":\n      return { type: \"boolean\" };\n    case \"global.round\": {\n      const numNode = walk({ node: node.args[0], scope });\n      return mapNode(numNode, scope, (num) => {\n        if (num.type === \"unknown\")\n          return nullUnion({ type: \"number\" });\n        if (num.type !== \"number\")\n          return { type: \"null\" };\n        if (node.args.length === 2) {\n          const precisionNode = walk({ node: node.args[1], scope });\n          return mapNode(precisionNode, scope, (precision) => precision.type === \"unknown\" ? nullUnion({ type: \"number\" }) : precision.type !== \"number\" ? { type: \"null\" } : { type: \"number\" });\n        }\n        return { type: \"number\" };\n      });\n    }\n    case \"global.string\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (node2) => node2.type === \"unknown\" ? nullUnion({ type: \"string\" }) : node2.type === \"string\" || node2.type === \"number\" || node2.type === \"boolean\" ? node2.value ? {\n        type: \"string\",\n        value: node2.value.toString()\n      } : {\n        type: \"string\"\n      } : { type: \"null\" });\n    }\n    case \"math.sum\": {\n      const values = walk({ node: node.args[0], scope });\n      return mapNode(values, scope, (node2) => node2.type === \"unknown\" ? nullUnion({ type: \"number\" }) : node2.type !== \"array\" ? { type: \"null\" } : mapNode(node2.of, scope, (node3) => node3.type === \"unknown\" ? nullUnion({ type: \"number\" }) : node3.type === \"number\" || node3.type === \"null\" ? { type: \"number\" } : { type: \"null\" }));\n    }\n    case \"math.avg\": {\n      const values = walk({ node: node.args[0], scope });\n      return mapNode(values, scope, (node2) => node2.type === \"unknown\" ? nullUnion({ type: \"number\" }) : node2.type !== \"array\" ? { type: \"null\" } : mapNode(node2.of, scope, (node3) => node3.type === \"unknown\" ? nullUnion({ type: \"number\" }) : node3.type === \"number\" ? { type: \"number\" } : { type: \"null\" }));\n    }\n    case \"math.max\":\n    case \"math.min\": {\n      const values = walk({ node: node.args[0], scope });\n      return mapNode(values, scope, (node2) => node2.type === \"unknown\" ? nullUnion({ type: \"number\" }) : node2.type !== \"array\" ? { type: \"null\" } : mapNode(node2.of, scope, (node3) => node3.type === \"unknown\" ? nullUnion({ type: \"number\" }) : node3.type === \"number\" ? node3 : { type: \"null\" }));\n    }\n    case \"pt.text\":\n      return node.args.length === 0 ? { type: \"null\" } : {\n        type: \"string\"\n      };\n    case \"string.startsWith\": {\n      const strTypeNode = walk({ node: node.args[0], scope }), prefixTypeNode = walk({ node: node.args[1], scope });\n      return mapNode(strTypeNode, scope, (strNode) => mapNode(prefixTypeNode, scope, (prefixNode) => strNode.type === \"unknown\" || prefixNode.type === \"unknown\" ? nullUnion({ type: \"boolean\" }) : strNode.type !== \"string\" || prefixNode.type !== \"string\" ? { type: \"null\" } : { type: \"boolean\" }));\n    }\n    case \"string.split\": {\n      const strTypeNode = walk({ node: node.args[0], scope }), sepTypeNode = walk({ node: node.args[1], scope });\n      return mapNode(strTypeNode, scope, (strNode) => mapNode(sepTypeNode, scope, (sepNode) => strNode.type === \"unknown\" || sepNode.type === \"unknown\" ? nullUnion({ type: \"array\", of: { type: \"string\" } }) : strNode.type !== \"string\" || sepNode.type !== \"string\" ? { type: \"null\" } : { type: \"array\", of: { type: \"string\" } }));\n    }\n    case \"geo.latLng\": {\n      const latTypeNode = walk({ node: node.args[0], scope }), lngTypeNode = walk({ node: node.args[1], scope });\n      return mapNode(latTypeNode, scope, (latNode) => mapNode(lngTypeNode, scope, (lngNode) => latNode.type == \"unknown\" || lngNode.type == \"unknown\" ? nullUnion(createGeoJson()) : latNode.type !== \"number\" || lngNode.type !== \"number\" ? { type: \"null\" } : nullUnion(createGeoJson())));\n    }\n    case \"geo.contains\":\n      return nullUnion({ type: \"boolean\" });\n    case \"geo.intersects\":\n      return nullUnion({ type: \"boolean\" });\n    case \"geo.distance\":\n      return nullUnion({ type: \"number\" });\n    case \"sanity.versionOf\": {\n      const typeNode = walk({ node: node.args[0], scope });\n      return mapNode(typeNode, scope, (typeNode2) => typeNode2.type === \"unknown\" ? nullUnion({ type: \"boolean\" }) : typeNode2.type !== \"string\" ? { type: \"null\" } : { type: \"boolean\" });\n    }\n    case \"sanity.partOfRelease\": {\n      const typeNode = walk({ node: node.args[0], scope });\n      return mapNode(typeNode, scope, (typeNode2) => typeNode2.type === \"unknown\" ? nullUnion({ type: \"boolean\" }) : typeNode2.type !== \"string\" ? { type: \"null\" } : { type: \"boolean\" });\n    }\n    case \"documents.get\": {\n      const typeNode = walk({ node: node.args[0], scope });\n      return mapNode(typeNode, scope, (typeNode2) => typeNode2.type === \"unknown\" ? typeNode2 : typeNode2.type !== \"object\" ? { type: \"null\" } : { type: \"unknown\" });\n    }\n    default:\n      return { type: \"unknown\" };\n  }\n}\nfunction match(left, right) {\n  let tokens = [], patterns = [];\n  if (left.type === \"string\") {\n    if (left.value === void 0)\n      return;\n    tokens = tokens.concat(matchTokenize(left.value));\n  }\n  if (left.type === \"array\") {\n    if (left.of.type === \"unknown\")\n      return;\n    if (left.of.type === \"string\") {\n      if (left.of.value === void 0)\n        return;\n      tokens = tokens.concat(matchTokenize(left.of.value));\n    }\n    if (left.of.type === \"union\")\n      for (const node of left.of.of)\n        node.type === \"string\" && node.value !== void 0 && (tokens = tokens.concat(matchTokenize(node.value)));\n  }\n  if (right.type === \"string\") {\n    if (right.value === void 0)\n      return;\n    patterns = patterns.concat(matchAnalyzePattern(right.value));\n  }\n  if (right.type === \"array\") {\n    if (right.of.type === \"unknown\")\n      return;\n    if (right.of.type === \"string\") {\n      if (right.of.value === void 0)\n        return;\n      patterns = patterns.concat(matchAnalyzePattern(right.of.value));\n    }\n    if (right.of.type === \"union\")\n      for (const node of right.of.of) {\n        if (node.type === \"string\") {\n          if (node.value === void 0)\n            return;\n          patterns = patterns.concat(matchAnalyzePattern(node.value));\n        }\n        if (node.type !== \"string\")\n          return !1;\n      }\n  }\n  return matchText(tokens, patterns);\n}\nconst $trace$1 = debug__WEBPACK_IMPORTED_MODULE_0__(\"typeEvaluator:scope:trace\");\n$trace$1.log = console.log.bind(console);\nclass Context {\n  schema;\n  constructor(schema) {\n    this.schema = schema;\n  }\n  lookupRef(refTo) {\n    for (const val of this.schema)\n      if (val.type === \"document\" && val.name === refTo)\n        return {\n          type: \"object\",\n          attributes: val.attributes\n        };\n    return { type: \"null\" };\n  }\n  lookupTypeDeclaration(alias) {\n    for (const val of this.schema)\n      if (val.type === \"type\" && val.name === alias.name)\n        return val.value;\n    return { type: \"null\" };\n  }\n}\nclass Scope2 {\n  value;\n  parent;\n  context;\n  isHidden;\n  constructor(value, parent, context) {\n    this.value = { type: \"union\", of: value }, this.parent = parent, this.context = context || parent?.context || new Context([]), this.isHidden = !1;\n  }\n  createNested(value) {\n    return this.isHidden ? new Scope2(value, this.parent, this.context) : new Scope2(value, this, this.context);\n  }\n  createHidden(value) {\n    const result = this.createNested(value);\n    return result.isHidden = !0, result;\n  }\n}\nconst $trace = debug__WEBPACK_IMPORTED_MODULE_0__(\"typeEvaluator:evaluate:trace\");\n$trace.log = console.log.bind(console);\nconst $debug = debug__WEBPACK_IMPORTED_MODULE_0__(\"typeEvaluator:evaluate:debug\");\n$debug.log = console.log.bind(console);\nconst $warn = debug__WEBPACK_IMPORTED_MODULE_0__(\"typeEvaluator:evaluate:warn\");\nfunction typeEvaluate(ast, schema) {\n  $debug(\"evaluateQueryType.ast %O\", ast), $debug(\"evaluateQueryType.schema %O\", schema);\n  const parsed = walk({\n    node: ast,\n    scope: new Scope2([], void 0, new Context(schema))\n  });\n  $trace(\"evaluateQueryType.parsed %O\", parsed);\n  const optimized = optimizeUnions(parsed);\n  return $debug(\"evaluateQueryType.optimized %O\", optimized), optimized;\n}\nfunction mapDeref(node, scope) {\n  return mapNode(node, scope, (base) => {\n    if (base.type === \"array\")\n      return {\n        type: \"array\",\n        of: mapDeref(base.of, scope)\n      };\n    if (base.type === \"object\") {\n      if (base.dereferencesTo !== void 0)\n        return scope.context.lookupRef(base.dereferencesTo);\n      if (base.rest !== void 0)\n        return mapDeref(resolveInline(base.rest, scope), scope);\n    }\n    return { type: \"null\" };\n  });\n}\nfunction handleDerefNode(node, scope) {\n  $trace(\"deref.node %O\", node);\n  const derefedNode = mapDeref(walk({ node: node.base, scope }), scope);\n  return $trace(\"deref.derefedNode %O\", derefedNode), derefedNode;\n}\nfunction handleObjectSplatNode(attr, scope) {\n  const value = walk({ node: attr.value, scope });\n  return $trace(\"object.splat.value %O\", value), mapNode(value, scope, (node) => {\n    if (node.type === \"unknown\")\n      return { type: \"unknown\" };\n    if (node.type !== \"object\")\n      return { type: \"object\", attributes: {} };\n    const attributes = {};\n    for (const name in node.attributes)\n      node.attributes.hasOwnProperty(name) && (attributes[name] = node.attributes[name]);\n    if (node.rest !== void 0) {\n      const resolvedRest = resolveInline(node.rest, scope);\n      if (resolvedRest.type === \"unknown\")\n        return { type: \"unknown\" };\n      if (resolvedRest.type !== \"object\")\n        return { type: \"null\" };\n      for (const name in resolvedRest.attributes)\n        resolvedRest.attributes.hasOwnProperty(name) && (attributes[name] = resolvedRest.attributes[name]);\n    }\n    return { type: \"object\", attributes };\n  });\n}\nfunction handleObjectNode(node, scope) {\n  if ($trace(\"object.node %O\", node), node.attributes.length === 0)\n    return {\n      type: \"object\",\n      attributes: {}\n    };\n  const objectAttributes = [], splatVariants = [], conditionalVariants = [];\n  for (const [idx, attr] of node.attributes.entries()) {\n    if (attr.type === \"ObjectAttributeValue\") {\n      const attributeNode = walk({ node: attr.value, scope });\n      objectAttributes.push([\n        idx,\n        attr.name,\n        {\n          type: \"objectAttribute\",\n          value: attributeNode\n        }\n      ]);\n      continue;\n    }\n    if (attr.type === \"ObjectSplat\") {\n      const attributeNode = handleObjectSplatNode(attr, scope);\n      switch ($trace(\"object.splat.result %O\", attributeNode), attributeNode.type) {\n        case \"object\": {\n          splatVariants.push([idx, attributeNode]);\n          continue;\n        }\n        case \"union\": {\n          for (const node2 of attributeNode.of)\n            if (node2.type === \"unknown\")\n              return node2;\n          splatVariants.push([idx, attributeNode]);\n          continue;\n        }\n        default:\n          return { type: \"unknown\" };\n      }\n    }\n    if (attr.type === \"ObjectConditionalSplat\") {\n      const condition = booleanValue(walk({ node: attr.condition, scope }), scope);\n      if ($trace(\"object.conditional.splat.condition %O\", condition), condition.canBeTrue === !1)\n        continue;\n      const attributeNode = handleObjectSplatNode(attr, scope);\n      if ($trace(\"object.conditional.splat.result %O\", attributeNode), condition.canBeFalse === !1 && condition.canBeNull === !1)\n        switch (attributeNode.type) {\n          case \"object\": {\n            splatVariants.push([idx, attributeNode]);\n            continue;\n          }\n          case \"union\": {\n            for (const node2 of attributeNode.of)\n              if (node2.type !== \"object\")\n                return { type: \"unknown\" };\n            splatVariants.push([idx, attributeNode]);\n            continue;\n          }\n          default:\n            return { type: \"unknown\" };\n        }\n      const variant = mapNode(attributeNode, scope, (attributeNode2) => ($trace(\"object.conditional.splat.result.concrete %O\", attributeNode2), attributeNode2.type !== \"object\" ? { type: \"unknown\" } : {\n        type: \"object\",\n        attributes: attributeNode2.attributes\n      }));\n      if (variant.type === \"union\") {\n        for (const node2 of variant.of)\n          if (node2.type !== \"object\")\n            return { type: \"unknown\" };\n        variant.of.push({ type: \"object\", attributes: {} }), conditionalVariants.push([idx, variant]);\n        continue;\n      }\n      if (variant.type !== \"object\")\n        return { type: \"unknown\" };\n      conditionalVariants.push([\n        idx,\n        {\n          type: \"union\",\n          of: [{ type: \"object\", attributes: {} }, variant]\n        }\n      ]);\n      continue;\n    }\n    throw new Error(`Unknown object attribute type: ${attr.type}`);\n  }\n  const guaranteedAttributes = [];\n  guaranteedAttributes.push(...objectAttributes);\n  for (const [idx, splatNode] of splatVariants) {\n    if (splatNode.type === \"object\") {\n      for (const name in splatNode.attributes) {\n        if (!splatNode.attributes.hasOwnProperty(name))\n          continue;\n        const attribute = splatNode.attributes[name];\n        guaranteedAttributes.push([idx, name, attribute]);\n      }\n      continue;\n    }\n    conditionalVariants.push([idx, splatNode]);\n  }\n  if (guaranteedAttributes.sort(([a], [b]) => a - b), conditionalVariants.length === 0)\n    return {\n      type: \"object\",\n      attributes: Object.fromEntries(\n        guaranteedAttributes.map(([, name, attribute]) => [name, attribute])\n      )\n    };\n  const matrix = [];\n  for (const [unionIdx, union] of conditionalVariants) {\n    const unionGuaranteedBefore = [], unionGuaranteedAfter = [];\n    for (const [guaranteedIndex, name, attribute] of guaranteedAttributes)\n      guaranteedIndex < unionIdx && unionGuaranteedBefore.push([guaranteedIndex, name, attribute]), guaranteedIndex > unionIdx && unionGuaranteedAfter.push([guaranteedIndex, name, attribute]);\n    const allVariantsAttributes = [];\n    for (const [conditionalVariantIdx, otherUnion] of conditionalVariants) {\n      const variantAttributes = [];\n      for (const node2 of otherUnion.of)\n        variantAttributes.push(node2.attributes);\n      allVariantsAttributes.push([conditionalVariantIdx, variantAttributes]);\n    }\n    for (const node2 of union.of) {\n      matrix.push({\n        type: \"object\",\n        attributes: {\n          ...Object.fromEntries(\n            unionGuaranteedBefore.map(([, name, attribute]) => [name, attribute])\n          ),\n          ...node2.attributes,\n          ...Object.fromEntries(\n            unionGuaranteedAfter.map(([, name, attribute]) => [name, attribute])\n          )\n        }\n      });\n      for (const [outerIdx, outerAttributes] of allVariantsAttributes)\n        for (const outer of outerAttributes)\n          for (const [innerIdx, innerAttributes] of allVariantsAttributes)\n            if (outerIdx !== innerIdx)\n              for (const inner of innerAttributes) {\n                const _before = [...unionGuaranteedBefore], _after = [...unionGuaranteedAfter];\n                for (const name in outer)\n                  outer.hasOwnProperty(name) && outerIdx !== unionIdx && (outerIdx < unionIdx && _before.push([outerIdx, name, outer[name]]), outerIdx > unionIdx && _after.push([outerIdx, name, outer[name]]));\n                for (const name in inner)\n                  inner.hasOwnProperty(name) && outerIdx !== unionIdx && (innerIdx < unionIdx && _before.push([innerIdx, name, inner[name]]), innerIdx > unionIdx && _after.push([innerIdx, name, inner[name]]));\n                _before.sort(([a], [b]) => a - b), _after.sort(([a], [b]) => a - b);\n                const before = Object.fromEntries(\n                  _before.map(([, name, attribute]) => [name, attribute])\n                ), after = Object.fromEntries(\n                  _after.map(([, name, attribute]) => [name, attribute])\n                );\n                matrix.push({\n                  type: \"object\",\n                  attributes: {\n                    ...before,\n                    ...node2.attributes,\n                    ...after\n                  }\n                });\n              }\n    }\n  }\n  return optimizeUnions({\n    type: \"union\",\n    of: matrix\n  });\n}\nfunction handleOpCallNode(node, scope) {\n  $trace(\"opcall.node %O\", node);\n  const lhs = walk({ node: node.left, scope }), rhs = walk({ node: node.right, scope });\n  return mapNode(\n    lhs,\n    scope,\n    (left) => (\n      // eslint-disable-next-line complexity, max-statements\n      mapNode(rhs, scope, (right) => {\n        switch ($trace('opcall.node.concrete \"%s\" %O', node.op, { left, right }), node.op) {\n          case \"==\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? { type: \"boolean\" } : left.type !== right.type ? {\n              type: \"boolean\",\n              value: !1\n            } : left.type === \"null\" ? {\n              type: \"boolean\",\n              value: !0\n            } : !isPrimitiveTypeNode(left) || !isPrimitiveTypeNode(right) ? {\n              type: \"boolean\",\n              value: !1\n            } : {\n              type: \"boolean\",\n              value: evaluateComparison(node.op, left, right)\n            };\n          case \"!=\": {\n            if (left.type === \"unknown\" || right.type === \"unknown\")\n              return { type: \"boolean\" };\n            if (left.type !== right.type)\n              return {\n                type: \"boolean\",\n                value: !0\n              };\n            if (left.type === \"null\")\n              return {\n                type: \"boolean\",\n                value: !1\n              };\n            if (!isPrimitiveTypeNode(left) || !isPrimitiveTypeNode(right))\n              return {\n                type: \"boolean\",\n                value: !0\n              };\n            let value = evaluateComparison(\"==\", left, right);\n            return value !== void 0 && (value = !value), {\n              type: \"boolean\",\n              value\n            };\n          }\n          case \">\":\n          case \">=\":\n          case \"<\":\n          case \"<=\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({ type: \"boolean\" }) : left.type !== right.type ? { type: \"null\" } : !isPrimitiveTypeNode(left) || !isPrimitiveTypeNode(right) ? { type: \"null\" } : {\n              type: \"boolean\",\n              value: evaluateComparison(node.op, left, right)\n            };\n          case \"in\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({ type: \"boolean\" }) : right.type !== \"array\" ? isFuncCall(node.right, \"global::path\") ? { type: \"boolean\" } : { type: \"null\" } : !isPrimitiveTypeNode(left) && left.type !== \"null\" ? {\n              type: \"boolean\",\n              value: !1\n            } : mapNode(right.of, scope, (arrayTypeNode) => arrayTypeNode.type === \"unknown\" ? nullUnion({ type: \"boolean\" }) : left.type === \"null\" ? {\n              type: \"boolean\",\n              value: arrayTypeNode.type === \"null\"\n            } : left.value === void 0 ? {\n              type: \"boolean\"\n            } : isPrimitiveTypeNode(arrayTypeNode) ? arrayTypeNode.value === void 0 ? {\n              type: \"boolean\"\n            } : {\n              type: \"boolean\",\n              value: left.value === arrayTypeNode.value\n            } : {\n              type: \"boolean\",\n              value: !1\n            });\n          case \"match\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? { type: \"boolean\" } : {\n              type: \"boolean\",\n              value: match(left, right)\n            };\n          case \"+\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? { type: \"unknown\" } : left.type === \"string\" && right.type === \"string\" ? {\n              type: \"string\",\n              value: left.value !== void 0 && right.value !== void 0 ? left.value + right.value : void 0\n            } : left.type === \"number\" && right.type === \"number\" ? {\n              type: \"number\",\n              value: left.value !== void 0 && right.value !== void 0 ? left.value + right.value : void 0\n            } : left.type === \"array\" && right.type === \"array\" ? {\n              type: \"array\",\n              of: {\n                type: \"union\",\n                of: [left.of, right.of]\n              }\n            } : left.type === \"object\" && right.type === \"object\" ? {\n              type: \"object\",\n              attributes: { ...left.attributes, ...right.attributes }\n            } : { type: \"null\" };\n          case \"-\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({ type: \"number\" }) : left.type === \"number\" && right.type === \"number\" ? {\n              type: \"number\",\n              value: left.value !== void 0 && right.value !== void 0 ? left.value - right.value : void 0\n            } : { type: \"null\" };\n          case \"*\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({ type: \"number\" }) : left.type === \"number\" && right.type === \"number\" ? {\n              type: \"number\",\n              value: left.value !== void 0 && right.value !== void 0 ? left.value * right.value : void 0\n            } : { type: \"null\" };\n          case \"/\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({ type: \"number\" }) : left.type === \"number\" && right.type === \"number\" ? {\n              type: \"number\",\n              value: left.value !== void 0 && right.value !== void 0 ? left.value / right.value : void 0\n            } : { type: \"null\" };\n          case \"**\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({ type: \"number\" }) : left.type === \"number\" && right.type === \"number\" ? {\n              type: \"number\",\n              value: left.value !== void 0 && right.value !== void 0 ? left.value ** right.value : void 0\n            } : { type: \"null\" };\n          case \"%\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({ type: \"number\" }) : left.type === \"number\" && right.type === \"number\" ? {\n              type: \"number\",\n              value: left.value !== void 0 && right.value !== void 0 ? left.value % right.value : void 0\n            } : { type: \"null\" };\n          default:\n            return {\n              type: \"unknown\"\n            };\n        }\n      })\n    )\n  );\n}\nfunction handleSelectNode(node, scope) {\n  const values = [];\n  let guaranteed = !1;\n  for (const alternative of node.alternatives) {\n    const conditionValue = walk({ node: alternative.condition, scope }), conditionScope = resolveFilter(alternative.condition, scope);\n    conditionScope.type === \"union\" && conditionScope.of.length > 0 && values.push(walk({ node: alternative.value, scope: scope.createHidden(conditionScope.of) })), conditionValue.type === \"boolean\" && conditionValue.value === !0 && (guaranteed = !0);\n  }\n  return node.fallback && !guaranteed && values.push(walk({ node: node.fallback, scope })), values.length === 0 ? { type: \"null\" } : {\n    type: \"union\",\n    of: values\n  };\n}\nfunction handleArrayCoerceNode(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return $trace(\"arrayCoerce.base %O\", base), mapArray(base, scope, (base2) => base2);\n}\nfunction handleFlatMap(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return mapArray(base, scope, (base2) => {\n    const inner = walk({ node: node.expr, scope: scope.createHidden([base2.of]) });\n    return mapNode(\n      inner,\n      scope,\n      (inner2) => inner2.type === \"array\" ? inner2 : { type: \"array\", of: inner2 },\n      (nodes) => {\n        const inner2 = [];\n        for (const node2 of nodes) {\n          if (node2.type === \"unknown\") return { type: \"array\", of: node2 };\n          if (node2.type !== \"array\") throw new Error(`Unexpected type: ${node2.type}`);\n          inner2.push(node2.of);\n        }\n        return {\n          type: \"array\",\n          of: optimizeUnions({ type: \"union\", of: inner2 })\n        };\n      }\n    );\n  });\n}\nfunction handleMap(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return $trace(\"map.base %O\", base), mapArray(base, scope, (base2) => ({\n    type: \"array\",\n    of: walk({ node: node.expr, scope: scope.createHidden([base2.of]) })\n  }));\n}\nfunction handleProjectionNode(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return $trace(\"projection.base %O\", base), mapObject(\n    base,\n    scope,\n    (base2) => walk({ node: node.expr, scope: scope.createNested([base2]) })\n  );\n}\nfunction createFilterScope(base, scope) {\n  return base.type === \"array\" ? base.of.type === \"union\" ? scope.createNested(base.of.of) : scope.createNested([base.of]) : scope.createNested([base]);\n}\nfunction handleFilterNode(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return $trace(\"filter.base %O\", base), mapNode(base, scope, (base2) => {\n    if ($trace(\"filter.resolving %O\", base2), base2.type === \"null\")\n      return base2;\n    const resolved = resolveFilter(node.expr, createFilterScope(base2, scope));\n    return $trace(\"filter.resolved %O\", resolved), {\n      type: \"array\",\n      of: resolved\n    };\n  });\n}\nfunction handleAccessAttributeNode(node, scope) {\n  let attributeBase = scope.value;\n  return node.base && (attributeBase = walk({ node: node.base, scope })), $trace(\"accessAttribute.base %s %O\", node.name, attributeBase), handleAccessAttributeBase(attributeBase, node.name, scope);\n}\nfunction handleAccessAttributeBase(base, name, scope) {\n  return mapObject(base, scope, (base2) => {\n    $trace('Looking for attribute \"%s\" in object %O', name, base2);\n    const attribute = base2.attributes[name];\n    return attribute !== void 0 ? ($debug(`accessAttribute.attribute found ${name} %O`, attribute), attribute.optional ? nullUnion(attribute.value) : attribute.value) : base2.rest ? handleAccessAttributeBase(base2.rest, name, scope) : ($warn(`attribute \"${name}\" not found in object`), { type: \"null\" });\n  });\n}\nfunction handleAccessElementNode(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return $trace(\"accessElement.base %O\", base), mapArray(base, scope, (base2) => nullUnion(base2.of));\n}\nfunction handleArrayNode(node, scope) {\n  const of = [];\n  for (const el of node.elements) {\n    const node2 = walk({ node: el.value, scope });\n    node2 !== null && of.push(node2);\n  }\n  return {\n    type: \"array\",\n    of: {\n      type: \"union\",\n      of\n    }\n  };\n}\nfunction handleValueNode(node, scope) {\n  if (node.value === null)\n    return { type: \"null\" };\n  switch (typeof node.value) {\n    case \"string\":\n      return {\n        type: \"string\",\n        value: node.value\n      };\n    case \"number\":\n      return {\n        type: \"number\",\n        value: node.value\n      };\n    case \"boolean\":\n      return {\n        type: \"boolean\",\n        value: node.value\n      };\n    case \"object\":\n      return node.value === null ? { type: \"null\" } : Array.isArray(node.value) ? {\n        type: \"array\",\n        of: {\n          type: \"union\",\n          of: node.value.map((value) => walk({ node: { type: \"Value\", value }, scope }))\n        }\n      } : {\n        type: \"object\",\n        attributes: Object.fromEntries(\n          Object.entries(node.value).map(([key, value]) => [\n            key,\n            {\n              type: \"objectAttribute\",\n              value: walk({ node: { type: \"Value\", value }, scope })\n            }\n          ])\n        )\n      };\n    default:\n      return { type: \"unknown\" };\n  }\n}\nfunction handleSlice(node, scope) {\n  $trace(\"slice.node %O\", node);\n  const base = walk({ node: node.base, scope });\n  return mapArray(base, scope, (base2) => base2);\n}\nfunction handleParentNode({ n }, scope) {\n  $trace(\"handle.parent.currentScope %d %O\", n, scope);\n  let current = scope;\n  for (let i = 0; i < n; i++) {\n    for (; current?.isHidden; )\n      current = current.parent;\n    current = current?.parent;\n  }\n  return $trace(\"handle.parent.newScope %d %O\", n, current), current ? current.value.of.length === 0 ? { type: \"null\" } : current.value : { type: \"null\" };\n}\nfunction handleNotNode(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return mapNode(base, scope, (base2) => base2.type === \"unknown\" ? nullUnion({ type: \"boolean\" }) : base2.type === \"boolean\" ? base2.value !== void 0 ? { type: \"boolean\", value: base2.value === !1 } : { type: \"boolean\" } : { type: \"null\" });\n}\nfunction handleNegNode(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return mapNode(base, scope, (base2) => base2.type === \"unknown\" ? nullUnion({ type: \"number\" }) : base2.type !== \"number\" ? { type: \"null\" } : base2.value !== void 0 ? { type: \"number\", value: -base2.value } : base2);\n}\nfunction handlePosNode(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return mapNode(base, scope, (base2) => base2.type === \"unknown\" ? nullUnion({ type: \"number\" }) : base2.type !== \"number\" ? { type: \"null\" } : base2);\n}\nfunction handleEverythingNode(_, scope) {\n  return {\n    type: \"array\",\n    of: {\n      type: \"union\",\n      of: scope.context.schema.filter((obj) => obj.type === \"document\").map((doc) => ({\n        type: \"object\",\n        attributes: doc.attributes\n      }))\n    }\n  };\n}\nfunction handleAndNode(node, scope) {\n  const left = walk({ node: node.left, scope }), right = walk({ node: node.right, scope });\n  return mapNode(\n    left,\n    scope,\n    (lhs) => mapNode(right, scope, (rhs) => {\n      const value = booleanAnd(booleanValue(lhs, scope), booleanValue(rhs, scope));\n      return booleanInterpretationToTypeNode(value);\n    })\n  );\n}\nfunction handleOrNode(node, scope) {\n  const left = walk({ node: node.left, scope }), right = walk({ node: node.right, scope });\n  return mapNode(\n    left,\n    scope,\n    (lhs) => mapNode(right, scope, (rhs) => {\n      const value = booleanOr(booleanValue(lhs, scope), booleanValue(rhs, scope));\n      return booleanInterpretationToTypeNode(value);\n    })\n  );\n}\nconst OVERRIDE_TYPE_SYMBOL = Symbol(\"groq-js.type\");\nfunction walk({ node, scope }) {\n  if (OVERRIDE_TYPE_SYMBOL in node)\n    return node[OVERRIDE_TYPE_SYMBOL];\n  switch (node.type) {\n    // Filtering, traversal & projections\n    case \"Map\":\n      return handleMap(node, scope);\n    case \"Projection\":\n      return handleProjectionNode(node, scope);\n    case \"Filter\":\n      return handleFilterNode(node, scope);\n    case \"AccessAttribute\":\n      return optimizeUnions(handleAccessAttributeNode(node, scope));\n    case \"AccessElement\":\n      return handleAccessElementNode(node, scope);\n    case \"ArrayCoerce\":\n      return handleArrayCoerceNode(node, scope);\n    case \"FlatMap\":\n      return handleFlatMap(node, scope);\n    // Operations\n    case \"OpCall\":\n      return handleOpCallNode(node, scope);\n    case \"And\":\n      return handleAndNode(node, scope);\n    case \"Or\":\n      return handleOrNode(node, scope);\n    case \"Select\":\n      return handleSelectNode(node, scope);\n    case \"PipeFuncCall\":\n      return walk({ node: node.base, scope });\n    // Values\n    case \"Deref\":\n      return handleDerefNode(node, scope);\n    case \"Object\":\n      return handleObjectNode(node, scope);\n    case \"Value\":\n      return handleValueNode(node, scope);\n    case \"Array\":\n      return handleArrayNode(node, scope);\n    // Special cases\n    case \"Everything\":\n      return handleEverythingNode(node, scope);\n    case \"This\":\n      return $trace(\"this %O\", scope.value), scope.value;\n    case \"Parent\":\n      return handleParentNode(node, scope);\n    case \"FuncCall\":\n      return handleFuncCallNode(node, scope);\n    case \"Group\":\n      return walk({ node: node.base, scope });\n    case \"Not\":\n      return handleNotNode(node, scope);\n    case \"Parameter\":\n      return {\n        type: \"unknown\"\n      };\n    case \"Slice\":\n      return handleSlice(node, scope);\n    case \"Neg\":\n      return handleNegNode(node, scope);\n    case \"Pos\":\n      return handlePosNode(node, scope);\n    // everything else\n    case \"Asc\":\n    case \"Desc\":\n    case \"Context\":\n    case \"Tuple\":\n    case \"SelectorFuncCall\":\n    case \"SelectorNested\":\n    case \"InRange\":\n      return { type: \"unknown\" };\n    default:\n      throw new Error(`unknown node type ${node.type}`);\n  }\n}\nfunction isPrimitiveTypeNode(node) {\n  return node.type === \"string\" || node.type === \"number\" || node.type === \"boolean\";\n}\nfunction evaluateComparison(opcall, left, right) {\n  if (!(left.value === void 0 || right.value === void 0))\n    switch (opcall) {\n      case \"==\":\n        return left.value === right.value;\n      case \"<\":\n        return left.value < right.value;\n      case \"<=\":\n        return left.value <= right.value;\n      case \">\":\n        return left.value > right.value;\n      case \">=\":\n        return left.value >= right.value;\n      default:\n        throw new Error(`unknown comparison operator ${opcall}`);\n    }\n}\nfunction resolveFilter(expr, scope) {\n  $trace(\"resolveFilter.expr %O\", expr);\n  const filtered = scope.value.of.filter((node) => {\n    const subScope = scope.createHidden([node]), cond = walk({ node: expr, scope: subScope });\n    return booleanValue(cond, subScope).canBeTrue;\n  });\n  return $trace(\n    `resolveFilter ${expr.type === \"OpCall\" ? `${expr.type}/${expr.op}` : expr.type} %O`,\n    filtered\n  ), { type: \"union\", of: filtered };\n}\nfunction mapArray(node, scope, mapper) {\n  return mapNode(node, scope, (base) => base.type === \"unknown\" ? base : base.type === \"array\" ? mapper(base) : { type: \"null\" });\n}\nfunction mapObject(node, scope, mapper) {\n  return mapNode(node, scope, (base) => base.type === \"unknown\" ? base : base.type === \"object\" ? mapper(base) : { type: \"null\" });\n}\n\n//# sourceMappingURL=1.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2dyb3EtanMvZGlzdC8xLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUEwQjtBQUMxQjtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsbUJBQW1CLEVBQUUsSUFBSSxFQUFFO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDBCQUEwQixPQUFPLEtBQUssR0FBRyxNQUFNLEdBQUcsSUFBSSxHQUFHLEtBQUssR0FBRyxPQUFPLEdBQUcsT0FBTyxFQUFFLGlCQUFpQjtBQUNySjtBQUNBO0FBQ0E7QUFDQSxTQUFTLDJCQUEyQjtBQUNwQyxjQUFjLElBQUk7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixhQUFhLHNCQUFzQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxHQUFHLDJEQUEyRCxHQUFHO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIseUNBQXlDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEdBQUcsUUFBUTtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsMFZBQTBWLDZCQUE2QjtBQUN2WDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0NBQXdDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsd0NBQXdDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxjQUFjLElBQUk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkMsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBLDRDQUE0QyxJQUFJO0FBQ2hELEdBQUc7QUFDSCw4QkFBOEIsR0FBRztBQUNqQztBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQSw2Q0FBNkMsR0FBRztBQUNoRDtBQUNBO0FBQ0EsS0FBSztBQUNMLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBLDZDQUE2QyxHQUFHO0FBQ2hEO0FBQ0E7QUFDQSxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wseUJBQXlCLHdCQUF3QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLE9BQU8sbUJBQW1CO0FBQzFCLE9BQU8sYUFBYTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxZQUFZLFFBQVEsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHlCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0EsS0FBSztBQUNMLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0EsMEdBQTBHLHVCQUF1QjtBQUNqSSxLQUFLO0FBQ0wsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBLDBFQUEwRSx1QkFBdUI7QUFDakc7QUFDQSxHQUFHO0FBQ0g7QUFDQSxPQUFPLE1BQU0sZ0JBQWdCLGNBQWM7QUFDM0MsT0FBTyxNQUFNO0FBQ2I7QUFDQTtBQUNBLE9BQU8sTUFBTTtBQUNiLE9BQU8sT0FBTztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sTUFBTTtBQUNiLE9BQU8sMEJBQTBCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxVQUFVO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFVBQVU7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCw2QkFBNkIsT0FBTztBQUNwQztBQUNBLGtCQUFrQixNQUFNO0FBQ3hCO0FBQ0EsS0FBSztBQUNMLG1CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFNBQVM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHlCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxPQUFPLGFBQWE7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsT0FBTyxhQUFhO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLE9BQU8sTUFBTTtBQUNiO0FBQ0E7QUFDQTtBQUNBLE9BQU8sTUFBTTtBQUNiO0FBQ0E7QUFDQTtBQUNBLE9BQU8sTUFBTTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBO0FBQ0EsS0FBSztBQUNMLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLE9BQU8sWUFBWSxRQUFRLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0EsS0FBSztBQUNMLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTyxZQUFZLFFBQVEsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNO0FBQ047QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSSxtRkFBbUY7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrREFBa0Q7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzQkFBc0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFCQUFxQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSwyQ0FBMkMsVUFBVTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsNkJBQTZCO0FBQzVGO0FBQ0EsR0FBRztBQUNIO0FBQ0EscUJBQXFCLDRCQUE0QixVQUFVLEdBQUcsUUFBUSxlQUFlO0FBQ3JGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxrSEFBa0gsY0FBYztBQUNoSTtBQUNBO0FBQ0EsbUhBQW1ILGNBQWM7QUFDakk7QUFZRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvR2Fsb2NrL0NTL2JlaG9tZS1zaXRlL25vZGVfbW9kdWxlcy9ncm9xLWpzL2Rpc3QvMS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGRlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZzIpIHtcbiAgcmV0dXJuIHN0cmluZzIucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpO1xufVxuZnVuY3Rpb24gcGF0aFJlZ0V4cChwYXR0ZXJuKSB7XG4gIGNvbnN0IHJlID0gW107XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXR0ZXJuLnNwbGl0KFwiLlwiKSlcbiAgICBwYXJ0ID09PSBcIipcIiA/IHJlLnB1c2goXCJbXi5dK1wiKSA6IHBhcnQgPT09IFwiKipcIiA/IHJlLnB1c2goXCIuKlwiKSA6IHJlLnB1c2goZXNjYXBlUmVnRXhwKHBhcnQpKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3JlLmpvaW4oXCIuXCIpfSRgKTtcbn1cbmNsYXNzIFBhdGgge1xuICBwYXR0ZXJuO1xuICBwYXR0ZXJuUmU7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuLCB0aGlzLnBhdHRlcm5SZSA9IHBhdGhSZWdFeHAocGF0dGVybik7XG4gIH1cbiAgbWF0Y2hlcyhzdHIpIHtcbiAgICByZXR1cm4gdGhpcy5wYXR0ZXJuUmUudGVzdChzdHIpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5wYXR0ZXJuO1xuICB9XG59XG5jb25zdCBSRkMzMzM5X1JFR0VYID0gL15cXGR7NH0tXFxkezJ9LVxcZHsyfVRcXGR7Mn06XFxkezJ9OlxcZHsyfShcXC5cXGQrKT8oWnwoWy0rXVxcZHsyfTpcXGR7Mn0pKSQvO1xuZnVuY3Rpb24gcGFyc2VSRkMzMzM5KHN0cikge1xuICByZXR1cm4gUkZDMzMzOV9SRUdFWC50ZXN0KHN0cikgPyBuZXcgRGF0ZShzdHIpIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGZvcm1hdFJGQzMzMzkoZCkge1xuICBjb25zdCB5ZWFyID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENGdWxsWWVhcigpLCA0KSwgbW9udGggPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ01vbnRoKCkgKyAxLCAyKSwgZGF5ID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENEYXRlKCksIDIpLCBob3VyID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENIb3VycygpLCAyKSwgbWludXRlID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENNaW51dGVzKCksIDIpLCBzZWNvbmQgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ1NlY29uZHMoKSwgMik7XG4gIGxldCBmcmFjdGlvbmFsU2Vjb25kID0gXCJcIjtcbiAgY29uc3QgbWlsbGlzID0gZC5nZXRNaWxsaXNlY29uZHMoKTtcbiAgcmV0dXJuIG1pbGxpcyAhPSAwICYmIChmcmFjdGlvbmFsU2Vjb25kID0gYC4ke2FkZExlYWRpbmdaZXJvKG1pbGxpcywgMyl9YCksIGAke3llYXJ9LSR7bW9udGh9LSR7ZGF5fVQke2hvdXJ9OiR7bWludXRlfToke3NlY29uZH0ke2ZyYWN0aW9uYWxTZWNvbmR9WmA7XG59XG5mdW5jdGlvbiBhZGRMZWFkaW5nWmVybyhudW0sIHRhcmdldExlbmd0aCkge1xuICBsZXQgc3RyID0gbnVtLnRvU3RyaW5nKCk7XG4gIGZvciAoOyBzdHIubGVuZ3RoIDwgdGFyZ2V0TGVuZ3RoOyApXG4gICAgc3RyID0gYDAke3N0cn1gO1xuICByZXR1cm4gc3RyO1xufVxuY2xhc3MgU3RhdGljVmFsdWUge1xuICBkYXRhO1xuICB0eXBlO1xuICBjb25zdHJ1Y3RvcihkYXRhLCB0eXBlKSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YSwgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxuICBpc0FycmF5KCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IFwiYXJyYXlcIjtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hd2FpdFxuICBhc3luYyBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgfVxuICBhc1N0YXRpYygpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZGF0YSkpXG4gICAgICByZXR1cm4gZnVuY3Rpb24qIChkYXRhKSB7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBkYXRhKVxuICAgICAgICAgIHlpZWxkIGZyb21KUyhlbGVtZW50KTtcbiAgICAgIH0odGhpcy5kYXRhKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBpdGVyYXRlIG92ZXI6ICR7dGhpcy50eXBlfWApO1xuICB9XG59XG5jb25zdCBOVUxMX1ZBTFVFID0gbmV3IFN0YXRpY1ZhbHVlKG51bGwsIFwibnVsbFwiKSwgVFJVRV9WQUxVRSA9IG5ldyBTdGF0aWNWYWx1ZSghMCwgXCJib29sZWFuXCIpLCBGQUxTRV9WQUxVRSA9IG5ldyBTdGF0aWNWYWx1ZSghMSwgXCJib29sZWFuXCIpO1xuY2xhc3MgRGF0ZVRpbWUge1xuICBkYXRlO1xuICBjb25zdHJ1Y3RvcihkYXRlKSB7XG4gICAgdGhpcy5kYXRlID0gZGF0ZTtcbiAgfVxuICBzdGF0aWMgcGFyc2VUb1ZhbHVlKHN0cikge1xuICAgIGNvbnN0IGRhdGUgPSBwYXJzZVJGQzMzMzkoc3RyKTtcbiAgICByZXR1cm4gZGF0ZSA/IG5ldyBTdGF0aWNWYWx1ZShuZXcgRGF0ZVRpbWUoZGF0ZSksIFwiZGF0ZXRpbWVcIikgOiBOVUxMX1ZBTFVFO1xuICB9XG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmRhdGUuZ2V0VGltZSgpID09IG90aGVyLmRhdGUuZ2V0VGltZSgpO1xuICB9XG4gIGFkZChzZWNzKSB7XG4gICAgY29uc3QgY29weSA9IG5ldyBEYXRlKHRoaXMuZGF0ZS5nZXRUaW1lKCkpO1xuICAgIHJldHVybiBjb3B5LnNldFRpbWUoY29weS5nZXRUaW1lKCkgKyBzZWNzICogMWUzKSwgbmV3IERhdGVUaW1lKGNvcHkpO1xuICB9XG4gIGRpZmZlcmVuY2Uob3RoZXIpIHtcbiAgICByZXR1cm4gKHRoaXMuZGF0ZS5nZXRUaW1lKCkgLSBvdGhlci5kYXRlLmdldFRpbWUoKSkgLyAxZTM7XG4gIH1cbiAgY29tcGFyZVRvKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0ZS5nZXRUaW1lKCkgLSBvdGhlci5kYXRlLmdldFRpbWUoKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gZm9ybWF0UkZDMzMzOSh0aGlzLmRhdGUpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9XG59XG5mdW5jdGlvbiBmcm9tTnVtYmVyKG51bSkge1xuICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKG51bSkgPyBuZXcgU3RhdGljVmFsdWUobnVtLCBcIm51bWJlclwiKSA6IE5VTExfVkFMVUU7XG59XG5mdW5jdGlvbiBmcm9tU3RyaW5nKHN0cikge1xuICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKHN0ciwgXCJzdHJpbmdcIik7XG59XG5mdW5jdGlvbiBmcm9tRGF0ZVRpbWUoZHQpIHtcbiAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShkdCwgXCJkYXRldGltZVwiKTtcbn1cbmZ1bmN0aW9uIGZyb21QYXRoKHBhdGgpIHtcbiAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShwYXRoLCBcInBhdGhcIik7XG59XG5mdW5jdGlvbiBpc0l0ZXJhdG9yKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBvYmoubmV4dCA9PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBmcm9tQXJyYXkodmFsKSB7XG4gIHJldHVybiBuZXcgU3RhdGljVmFsdWUodmFsLCBcImFycmF5XCIpO1xufVxuZnVuY3Rpb24gZnJvbUpTKHZhbCkge1xuICByZXR1cm4gaXNJdGVyYXRvcih2YWwpID8gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiB2YWwpXG4gICAgICB5aWVsZCBmcm9tSlModmFsdWUpO1xuICB9KSA6IHZhbCA9PSBudWxsID8gTlVMTF9WQUxVRSA6IG5ldyBTdGF0aWNWYWx1ZSh2YWwsIGdldFR5cGUodmFsKSk7XG59XG5mdW5jdGlvbiB0b0pTKHZhbCkge1xuICBjb25zdCBub3JtYWxpemVkID0gbWF5YmVOb3JtYWxpemUodmFsLmRhdGEpO1xuICByZXR1cm4gbm9ybWFsaXplZCA9PT0gdm9pZCAwID8gdmFsLmRhdGEgOiBub3JtYWxpemVkO1xufVxuZnVuY3Rpb24gbWF5YmVOb3JtYWxpemUoZGF0YSkge1xuICBpZiAoIShkYXRhID09PSBudWxsIHx8IHR5cGVvZiBkYXRhID4gXCJ1XCIpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIGxldCByZXN1bHQ7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5vcm1hbGl6ZWQgPSBtYXliZU5vcm1hbGl6ZShkYXRhW2ldKTtcbiAgICAgICAgbm9ybWFsaXplZCAhPT0gdm9pZCAwICYmIHJlc3VsdCA9PT0gdm9pZCAwICYmIChyZXN1bHQgPSBkYXRhLnNsaWNlKDAsIGkpKSwgcmVzdWx0ICE9PSB2b2lkIDAgJiYgKG5vcm1hbGl6ZWQgPT09IHZvaWQgMCAmJiAobm9ybWFsaXplZCA9IGRhdGFbaV0pLCByZXN1bHQucHVzaChub3JtYWxpemVkKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEgPT0gXCJvYmplY3RcIikge1xuICAgICAgaWYgKFwidG9KU09OXCIgaW4gZGF0YSAmJiB0eXBlb2YgZGF0YS50b0pTT04gPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gZGF0YS50b0pTT04oKTtcbiAgICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhkYXRhKTtcbiAgICAgIGxldCByZXN1bHQ7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gZW50cmllc1tpXTtcbiAgICAgICAgbGV0IG5vcm1hbGl6ZWQgPSBtYXliZU5vcm1hbGl6ZSh2YWx1ZSk7XG4gICAgICAgIG5vcm1hbGl6ZWQgIT09IHZvaWQgMCAmJiByZXN1bHQgPT09IHZvaWQgMCAmJiAocmVzdWx0ID0gT2JqZWN0LmZyb21FbnRyaWVzKGVudHJpZXMuc2xpY2UoMCwgaSkpKSwgcmVzdWx0ICE9PSB2b2lkIDAgJiYgKG5vcm1hbGl6ZWQgPT09IHZvaWQgMCAmJiAobm9ybWFsaXplZCA9IHZhbHVlKSwgcmVzdWx0W2tleV0gPSBub3JtYWxpemVkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRUeXBlKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgPT09IG51bGwgfHwgdHlwZW9mIGRhdGEgPiBcInVcIiA/IFwibnVsbFwiIDogQXJyYXkuaXNBcnJheShkYXRhKSA/IFwiYXJyYXlcIiA6IGRhdGEgaW5zdGFuY2VvZiBQYXRoID8gXCJwYXRoXCIgOiBkYXRhIGluc3RhbmNlb2YgRGF0ZVRpbWUgPyBcImRhdGV0aW1lXCIgOiB0eXBlb2YgZGF0YTtcbn1cbmNsYXNzIFN0cmVhbVZhbHVlIHtcbiAgdHlwZSA9IFwic3RyZWFtXCI7XG4gIGdlbmVyYXRvcjtcbiAgdGlja2VyO1xuICBpc0RvbmU7XG4gIGRhdGE7XG4gIGNvbnN0cnVjdG9yKGdlbmVyYXRvcikge1xuICAgIHRoaXMuZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLCB0aGlzLnRpY2tlciA9IG51bGwsIHRoaXMuaXNEb25lID0gITEsIHRoaXMuZGF0YSA9IFtdO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gIGlzQXJyYXkoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIGFzeW5jIGdldCgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIHRoaXMpXG4gICAgICByZXN1bHQucHVzaChhd2FpdCB2YWx1ZS5nZXQoKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhc3luYyBhc1N0YXRpYygpIHtcbiAgICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKGF3YWl0IHRoaXMuZ2V0KCksIFwiYXJyYXlcIik7XG4gIH1cbiAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoOyA7ICkge1xuICAgICAgZm9yICg7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspXG4gICAgICAgIHlpZWxkIHRoaXMuZGF0YVtpXTtcbiAgICAgIGlmICh0aGlzLmlzRG9uZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgYXdhaXQgdGhpcy5fbmV4dFRpY2soKTtcbiAgICB9XG4gIH1cbiAgX25leHRUaWNrKCkge1xuICAgIGlmICh0aGlzLnRpY2tlcilcbiAgICAgIHJldHVybiB0aGlzLnRpY2tlcjtcbiAgICBsZXQgY3VycmVudFJlc29sdmVyLCBjdXJyZW50UmVqZWN0b3I7XG4gICAgY29uc3Qgc2V0dXBUaWNrZXIgPSAoKSA9PiB7XG4gICAgICB0aGlzLnRpY2tlciA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY3VycmVudFJlc29sdmVyID0gcmVzb2x2ZSwgY3VycmVudFJlamVjdG9yID0gcmVqZWN0O1xuICAgICAgfSk7XG4gICAgfSwgdGljayA9ICgpID0+IHtcbiAgICAgIGN1cnJlbnRSZXNvbHZlcigpLCBzZXR1cFRpY2tlcigpO1xuICAgIH0sIGZldGNoID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiB0aGlzLmdlbmVyYXRvcigpKVxuICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKHZhbHVlKSwgdGljaygpO1xuICAgICAgICB0aGlzLmlzRG9uZSA9ICEwLCB0aWNrKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjdXJyZW50UmVqZWN0b3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHNldHVwVGlja2VyKCksIGZldGNoKCksIHRoaXMudGlja2VyO1xuICB9XG59XG5mdW5jdGlvbiBpc0VxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEudHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBiLnR5cGUgPT09IFwic3RyaW5nXCIgfHwgYS50eXBlID09PSBcImJvb2xlYW5cIiAmJiBiLnR5cGUgPT09IFwiYm9vbGVhblwiIHx8IGEudHlwZSA9PT0gXCJudWxsXCIgJiYgYi50eXBlID09PSBcIm51bGxcIiB8fCBhLnR5cGUgPT09IFwibnVtYmVyXCIgJiYgYi50eXBlID09PSBcIm51bWJlclwiID8gYS5kYXRhID09PSBiLmRhdGEgOiBhLnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiBiLnR5cGUgPT09IFwiZGF0ZXRpbWVcIiA/IGEuZGF0YS5lcXVhbHMoYi5kYXRhKSA6ICExO1xufVxuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IG51bGwgfHwgYiA9PT0gbnVsbCkgcmV0dXJuIGEgPT09IGI7XG4gIGNvbnN0IHR5cGVPZkEgPSB0eXBlb2YgYSwgdHlwZU9mQiA9IHR5cGVvZiBiO1xuICBpZiAodHlwZU9mQSA9PT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlT2ZCID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gITA7XG4gIGlmICh0eXBlT2ZBID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZU9mQiA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gYSA9PT0gYjtcbiAgaWYgKHR5cGVPZkEgPT09IFwib2JqZWN0XCIgJiYgdHlwZU9mQiA9PT0gXCJvYmplY3RcIikge1xuICAgIGNvbnN0IGtleXNPZkEgPSBPYmplY3Qua2V5cyhhKSwga2V5c09mQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgIGlmIChrZXlzT2ZBLmxlbmd0aCAhPT0ga2V5c09mQi5sZW5ndGgpIHJldHVybiAhMTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzT2ZBKVxuICAgICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gITE7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIHJldHVybiBhID09PSBiO1xufVxuY29uc3QgQ0hBUlMgPSAvKFteIUAjJCVeJiooKSxcXFxcLz9cIjs6e318W1xcXSs8Plxccy1dKSsvZywgQ0hBUlNfV0lUSF9XSUxEQ0FSRCA9IC8oW14hQCMkJV4mKCksXFxcXC8/XCI7Ont9fFtcXF0rPD5cXHMtXSkrL2csIEVER0VfQ0hBUlMgPSAvKFxcYlxcLit8XFwuK1xcYikvZztcbmZ1bmN0aW9uIG1hdGNoVGV4dCh0b2tlbnMsIHBhdHRlcm5zKSB7XG4gIHJldHVybiB0b2tlbnMubGVuZ3RoID09PSAwIHx8IHBhdHRlcm5zLmxlbmd0aCA9PT0gMCA/ICExIDogcGF0dGVybnMuZXZlcnkoKHBhdHRlcm4pID0+IHBhdHRlcm4odG9rZW5zKSk7XG59XG5mdW5jdGlvbiBtYXRjaFRva2VuaXplKHRleHQyKSB7XG4gIHJldHVybiB0ZXh0Mi5yZXBsYWNlKEVER0VfQ0hBUlMsIFwiXCIpLm1hdGNoKENIQVJTKSB8fCBbXTtcbn1cbmZ1bmN0aW9uIG1hdGNoQW5hbHl6ZVBhdHRlcm4odGV4dDIpIHtcbiAgcmV0dXJuIG1hdGNoUGF0dGVyblJlZ2V4KHRleHQyKS5tYXAoKHJlKSA9PiAodG9rZW5zKSA9PiB0b2tlbnMuc29tZSgodG9rZW4pID0+IHJlLnRlc3QodG9rZW4pKSk7XG59XG5mdW5jdGlvbiBtYXRjaFBhdHRlcm5SZWdleCh0ZXh0Mikge1xuICByZXR1cm4gKHRleHQyLnJlcGxhY2UoRURHRV9DSEFSUywgXCJcIikubWF0Y2goQ0hBUlNfV0lUSF9XSUxEQ0FSRCkgfHwgW10pLm1hcChcbiAgICAodGVybSkgPT4gbmV3IFJlZ0V4cChgXiR7dGVybS5zbGljZSgwLCAxMDI0KS5yZXBsYWNlKC9cXCovZywgXCIuKlwiKX0kYCwgXCJpXCIpXG4gICk7XG59XG5mdW5jdGlvbiBnYXRoZXJUZXh0KHZhbHVlLCBmbGF0TWFwMikge1xuICBpZiAodmFsdWUudHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4geyBwYXJ0czogZmxhdE1hcDIodmFsdWUuZGF0YSksIHN1Y2Nlc3M6ICEwIH07XG4gIGlmICh2YWx1ZS50eXBlID09PSBcImFycmF5XCIpIHtcbiAgICBsZXQgc3VjY2VzcyA9ICEwO1xuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIHZhbHVlLmRhdGEpXG4gICAgICB0eXBlb2YgcGFydCA9PSBcInN0cmluZ1wiID8gcGFydHMucHVzaCguLi5mbGF0TWFwMihwYXJ0KSkgOiBzdWNjZXNzID0gITE7XG4gICAgcmV0dXJuIHsgcGFydHMsIHN1Y2Nlc3MgfTtcbiAgfVxuICByZXR1cm4gdmFsdWUudHlwZSA9PT0gXCJzdHJlYW1cIiA/IChhc3luYyAoKSA9PiB7XG4gICAgbGV0IHN1Y2Nlc3MgPSAhMDtcbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgIGZvciBhd2FpdCAoY29uc3QgcGFydCBvZiB2YWx1ZSlcbiAgICAgIHBhcnQudHlwZSA9PT0gXCJzdHJpbmdcIiA/IHBhcnRzLnB1c2goLi4uZmxhdE1hcDIocGFydC5kYXRhKSkgOiBzdWNjZXNzID0gITE7XG4gICAgcmV0dXJuIHsgcGFydHMsIHN1Y2Nlc3MgfTtcbiAgfSkoKSA6IHsgcGFydHM6IFtdLCBzdWNjZXNzOiAhMSB9O1xufVxuY29uc3QgVFlQRV9PUkRFUiA9IHtcbiAgZGF0ZXRpbWU6IDEsXG4gIG51bWJlcjogMixcbiAgc3RyaW5nOiAzLFxuICBib29sZWFuOiA0XG59O1xuZnVuY3Rpb24gcGFydGlhbENvbXBhcmUoYSwgYikge1xuICBjb25zdCBhVHlwZSA9IGdldFR5cGUoYSksIGJUeXBlID0gZ2V0VHlwZShiKTtcbiAgaWYgKGFUeXBlICE9PSBiVHlwZSlcbiAgICByZXR1cm4gbnVsbDtcbiAgc3dpdGNoIChhVHlwZSkge1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgcmV0dXJuIGEgLSBiO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbiAgICBjYXNlIFwiZGF0ZXRpbWVcIjpcbiAgICAgIHJldHVybiBhLmNvbXBhcmVUbyhiKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvdGFsQ29tcGFyZShhLCBiKSB7XG4gIGNvbnN0IGFUeXBlID0gZ2V0VHlwZShhKSwgYlR5cGUgPSBnZXRUeXBlKGIpLCBhVHlwZU9yZGVyID0gVFlQRV9PUkRFUlthVHlwZV0gfHwgMTAwLCBiVHlwZU9yZGVyID0gVFlQRV9PUkRFUltiVHlwZV0gfHwgMTAwO1xuICBpZiAoYVR5cGVPcmRlciAhPT0gYlR5cGVPcmRlcilcbiAgICByZXR1cm4gYVR5cGVPcmRlciAtIGJUeXBlT3JkZXI7XG4gIGxldCByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShhLCBiKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gbnVsbCAmJiAocmVzdWx0ID0gMCksIHJlc3VsdDtcbn1cbmNvbnN0IG9wZXJhdG9ycyA9IHtcbiAgXCI9PVwiOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiBpc0VxdWFsKGxlZnQsIHJpZ2h0KSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgXCIhPVwiOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiBpc0VxdWFsKGxlZnQsIHJpZ2h0KSA/IEZBTFNFX1ZBTFVFIDogVFJVRV9WQUxVRTtcbiAgfSxcbiAgXCI+XCI6IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJzdHJlYW1cIiB8fCByaWdodC50eXBlID09PSBcInN0cmVhbVwiKSByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgIHJldHVybiByZXN1bHQgPT09IG51bGwgPyBOVUxMX1ZBTFVFIDogcmVzdWx0ID4gMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgXCI+PVwiOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBudWxsID8gTlVMTF9WQUxVRSA6IHJlc3VsdCA+PSAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBcIjxcIjogZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmVhbVwiIHx8IHJpZ2h0LnR5cGUgPT09IFwic3RyZWFtXCIpIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gbnVsbCA/IE5VTExfVkFMVUUgOiByZXN1bHQgPCAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBcIjw9XCI6IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJzdHJlYW1cIiB8fCByaWdodC50eXBlID09PSBcInN0cmVhbVwiKSByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgIHJldHVybiByZXN1bHQgPT09IG51bGwgPyBOVUxMX1ZBTFVFIDogcmVzdWx0IDw9IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWUtbWF0Y2hpbmdcbiAgaW46IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKHJpZ2h0LnR5cGUgPT09IFwicGF0aFwiKVxuICAgICAgcmV0dXJuIGxlZnQudHlwZSAhPT0gXCJzdHJpbmdcIiA/IE5VTExfVkFMVUUgOiByaWdodC5kYXRhLm1hdGNoZXMobGVmdC5kYXRhKSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgICBpZiAocmlnaHQudHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICBmb3IgKGNvbnN0IGIgb2YgcmlnaHQuZGF0YSlcbiAgICAgICAgaWYgKGlzRXF1YWwobGVmdCwgZnJvbUpTKGIpKSlcbiAgICAgICAgICByZXR1cm4gVFJVRV9WQUxVRTtcbiAgICAgIHJldHVybiBGQUxTRV9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIHJpZ2h0LnR5cGUgPT09IFwic3RyZWFtXCIgPyAoYXN5bmMgKCkgPT4ge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBiIG9mIHJpZ2h0KVxuICAgICAgICBpZiAoaXNFcXVhbChsZWZ0LCBiKSlcbiAgICAgICAgICByZXR1cm4gVFJVRV9WQUxVRTtcbiAgICAgIHJldHVybiBGQUxTRV9WQUxVRTtcbiAgICB9KSgpIDogTlVMTF9WQUxVRTtcbiAgfSxcbiAgbWF0Y2g6IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgY29uc3QgdG9rZW5zID0gZ2F0aGVyVGV4dChsZWZ0LCAocGFydCkgPT4gbWF0Y2hUb2tlbml6ZShwYXJ0KSksIHBhdHRlcm5zID0gZ2F0aGVyVGV4dChyaWdodCwgKHBhcnQpID0+IG1hdGNoQW5hbHl6ZVBhdHRlcm4ocGFydCkpLCBwcm9jZXNzID0gKHRva2VuczIsIHBhdHRlcm5zMikgPT4gcGF0dGVybnMyLnN1Y2Nlc3MgJiYgbWF0Y2hUZXh0KHRva2VuczIucGFydHMsIHBhdHRlcm5zMi5wYXJ0cykgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gICAgcmV0dXJuIFwidGhlblwiIGluIHRva2VucyB8fCBcInRoZW5cIiBpbiBwYXR0ZXJucyA/IChhc3luYyAoKSA9PiBwcm9jZXNzKGF3YWl0IHRva2VucywgYXdhaXQgcGF0dGVybnMpKSgpIDogcHJvY2Vzcyh0b2tlbnMsIHBhdHRlcm5zKTtcbiAgfSxcbiAgXCIrXCI6IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIGxlZnQudHlwZSA9PT0gXCJkYXRldGltZVwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIgPyBmcm9tRGF0ZVRpbWUobGVmdC5kYXRhLmFkZChyaWdodC5kYXRhKSkgOiBsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIiA/IGZyb21OdW1iZXIobGVmdC5kYXRhICsgcmlnaHQuZGF0YSkgOiBsZWZ0LnR5cGUgPT09IFwic3RyaW5nXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJzdHJpbmdcIiA/IGZyb21TdHJpbmcobGVmdC5kYXRhICsgcmlnaHQuZGF0YSkgOiBsZWZ0LnR5cGUgPT09IFwib2JqZWN0XCIgJiYgcmlnaHQudHlwZSA9PT0gXCJvYmplY3RcIiA/IGZyb21KUyh7IC4uLmxlZnQuZGF0YSwgLi4ucmlnaHQuZGF0YSB9KSA6IGxlZnQudHlwZSA9PT0gXCJhcnJheVwiICYmIHJpZ2h0LnR5cGUgPT09IFwiYXJyYXlcIiA/IGZyb21KUyhsZWZ0LmRhdGEuY29uY2F0KHJpZ2h0LmRhdGEpKSA6IGxlZnQuaXNBcnJheSgpICYmIHJpZ2h0LmlzQXJyYXkoKSA/IG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWwgb2YgbGVmdClcbiAgICAgICAgeWllbGQgdmFsO1xuICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWwgb2YgcmlnaHQpXG4gICAgICAgIHlpZWxkIHZhbDtcbiAgICB9KSA6IE5VTExfVkFMVUU7XG4gIH0sXG4gIFwiLVwiOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiBsZWZ0LnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiID8gZnJvbURhdGVUaW1lKGxlZnQuZGF0YS5hZGQoLXJpZ2h0LmRhdGEpKSA6IGxlZnQudHlwZSA9PT0gXCJkYXRldGltZVwiICYmIHJpZ2h0LnR5cGUgPT09IFwiZGF0ZXRpbWVcIiA/IGZyb21OdW1iZXIobGVmdC5kYXRhLmRpZmZlcmVuY2UocmlnaHQuZGF0YSkpIDogbGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIgPyBmcm9tTnVtYmVyKGxlZnQuZGF0YSAtIHJpZ2h0LmRhdGEpIDogTlVMTF9WQUxVRTtcbiAgfSxcbiAgXCIqXCI6IG51bWVyaWNPcGVyYXRvcigoYSwgYikgPT4gYSAqIGIpLFxuICBcIi9cIjogbnVtZXJpY09wZXJhdG9yKChhLCBiKSA9PiBhIC8gYiksXG4gIFwiJVwiOiBudW1lcmljT3BlcmF0b3IoKGEsIGIpID0+IGEgJSBiKSxcbiAgXCIqKlwiOiBudW1lcmljT3BlcmF0b3IoKGEsIGIpID0+IE1hdGgucG93KGEsIGIpKVxufTtcbmZ1bmN0aW9uIG51bWVyaWNPcGVyYXRvcihpbXBsKSB7XG4gIHJldHVybiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgY29uc3QgcmVzdWx0ID0gaW1wbChsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgICAgcmV0dXJuIGZyb21OdW1iZXIocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH07XG59XG5sZXQgU2NvcGUkMSA9IGNsYXNzIFNjb3BlIHtcbiAgcGFyYW1zO1xuICBzb3VyY2U7XG4gIHZhbHVlO1xuICBwYXJlbnQ7XG4gIGNvbnRleHQ7XG4gIGlzSGlkZGVuID0gITE7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG4gIGNvbnN0cnVjdG9yKHBhcmFtcywgc291cmNlLCB2YWx1ZSwgY29udGV4dCwgcGFyZW50KSB7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXMsIHRoaXMuc291cmNlID0gc291cmNlLCB0aGlzLnZhbHVlID0gdmFsdWUsIHRoaXMuY29udGV4dCA9IGNvbnRleHQsIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB9XG4gIGNyZWF0ZU5lc3RlZCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmlzSGlkZGVuID8gbmV3IFNjb3BlKHRoaXMucGFyYW1zLCB0aGlzLnNvdXJjZSwgdmFsdWUsIHRoaXMuY29udGV4dCwgdGhpcy5wYXJlbnQpIDogbmV3IFNjb3BlKHRoaXMucGFyYW1zLCB0aGlzLnNvdXJjZSwgdmFsdWUsIHRoaXMuY29udGV4dCwgdGhpcyk7XG4gIH1cbiAgY3JlYXRlSGlkZGVuKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jcmVhdGVOZXN0ZWQodmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQuaXNIaWRkZW4gPSAhMCwgcmVzdWx0O1xuICB9XG59O1xuZnVuY3Rpb24gZXZhbHVhdGUobm9kZSwgc2NvcGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVBc3luYyhub2RlLCBzY29wZSk7XG59XG5mdW5jdGlvbiBleGVjdXRlU3luYyhub2RlLCBzY29wZSkge1xuICByZXR1cm4gRVhFQ1VUT1JTW25vZGUudHlwZV0uZXhlY3V0ZVN5bmMobm9kZSwgc2NvcGUpO1xufVxuZnVuY3Rpb24gZXhlY3V0ZUFzeW5jKG5vZGUsIHNjb3BlKSB7XG4gIHJldHVybiBFWEVDVVRPUlNbbm9kZS50eXBlXS5leGVjdXRlQXN5bmMobm9kZSwgc2NvcGUpO1xufVxuZnVuY3Rpb24gYXN5bmNPbmx5RXhlY3V0b3IoZXhlY3V0ZUFzeW5jMikge1xuICByZXR1cm4ge1xuICAgIGV4ZWN1dGVTeW5jKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXhlY3V0ZVN5bmMgbm90IHN1cHBvcnRlZFwiKTtcbiAgICB9LFxuICAgIGV4ZWN1dGVBc3luYzogZXhlY3V0ZUFzeW5jMlxuICB9O1xufVxuZnVuY3Rpb24gY29uc3RhbnRFeGVjdXRvcihmbikge1xuICByZXR1cm4ge1xuICAgIGV4ZWN1dGVTeW5jKG5vZGUsIHNjb3BlKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGZuKG5vZGUsIHNjb3BlKTtcbiAgICAgIGlmICh2YWx1ZS50eXBlID09PSBcInN0cmVhbVwiKSB0aHJvdyBuZXcgRXJyb3IoXCJTdHJlYW0gZW5jb3VudGVyZWQgaW4gZXZhbHVhdGVTeW5jXCIpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgYXN5bmMgZXhlY3V0ZUFzeW5jKG5vZGUsIHNjb3BlKSB7XG4gICAgICByZXR1cm4gZm4obm9kZSwgc2NvcGUpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG1hcHBlZEV4ZWN1dG9yKG1hcDIsIHJlZHVjZSkge1xuICByZXR1cm4ge1xuICAgIGV4ZWN1dGVTeW5jKG5vZGUsIHNjb3BlKSB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBtYXAyKG5vZGUpLm1hcCgobm9kZTIpID0+IGV4ZWN1dGVTeW5jKG5vZGUyLCBzY29wZSkpLCB2YWx1ZSA9IHJlZHVjZShub2RlLCAuLi52YWx1ZXMpO1xuICAgICAgaWYgKHZhbHVlLnR5cGUgPT09IFwic3RyZWFtXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmVhbS9pdGVyYXRvciBub3Qgc3VwcG9ydGVkIGluIHN5bmNocm9ub3VzIG1vZGVcIik7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBhc3luYyBleGVjdXRlQXN5bmMobm9kZSwgc2NvcGUpIHtcbiAgICAgIGNvbnN0IG5vZGVzID0gbWFwMihub2RlKSwgdmFsdWVzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIG5vZGVzLm1hcCgobm9kZTIpID0+IGV4ZWN1dGVBc3luYyhub2RlMiwgc2NvcGUpLnRoZW4oKHZhbHVlKSA9PiB2YWx1ZS5hc1N0YXRpYygpKSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gcmVkdWNlKG5vZGUsIC4uLnZhbHVlcyk7XG4gICAgfVxuICB9O1xufVxuY29uc3QgU1RPUF9JVEVSQVRPUiA9IFN5bWJvbCgpO1xuZnVuY3Rpb24gYXJyYXlSZWR1Y2VyRXhlY3V0b3IobWFwMiwgaW5pdCwgcmVkdWNlLCB3cmFwKSB7XG4gIHJldHVybiB7XG4gICAgZXhlY3V0ZVN5bmMobm9kZSwgc2NvcGUpIHtcbiAgICAgIGNvbnN0IHsgYXJyYXk6IGFycmF5Tm9kZSwgYXJnczogYXJnTm9kZXMgPSBbXSB9ID0gbWFwMihub2RlKSwgYXJyID0gZXhlY3V0ZVN5bmMoYXJyYXlOb2RlLCBzY29wZSk7XG4gICAgICBpZiAoYXJyLnR5cGUgIT09IFwiYXJyYXlcIikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICBjb25zdCBhcmdzID0gYXJnTm9kZXMubWFwKChub2RlMikgPT4gZXhlY3V0ZVN5bmMobm9kZTIsIHNjb3BlKSk7XG4gICAgICBsZXQgc3RhdGUgPSBpbml0KG5vZGUsIC4uLmFyZ3MpO1xuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGFyci5kYXRhKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZHVjZShub2RlLCBzdGF0ZSwgaXRlbSwgLi4uYXJncyk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IFNUT1BfSVRFUkFUT1IpIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgICBzdGF0ZSA9IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwKHN0YXRlKTtcbiAgICB9LFxuICAgIGFzeW5jIGV4ZWN1dGVBc3luYyhub2RlLCBzY29wZSkge1xuICAgICAgY29uc3QgeyBhcnJheTogYXJyYXlOb2RlLCBhcmdzOiBhcmdOb2RlcyA9IFtdIH0gPSBtYXAyKG5vZGUpLCBhcnIgPSBhd2FpdCBleGVjdXRlQXN5bmMoYXJyYXlOb2RlLCBzY29wZSk7XG4gICAgICBpZiAoYXJyLnR5cGUgIT09IFwiYXJyYXlcIiAmJiBhcnIudHlwZSAhPT0gXCJzdHJlYW1cIikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICBjb25zdCBhcmdzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIGFyZ05vZGVzLm1hcCgobm9kZTIpID0+IGV4ZWN1dGVBc3luYyhub2RlMiwgc2NvcGUpLnRoZW4oKHYpID0+IHYuYXNTdGF0aWMoKSkpXG4gICAgICApO1xuICAgICAgbGV0IHN0YXRlID0gaW5pdChub2RlLCAuLi5hcmdzKTtcbiAgICAgIGlmIChhcnIudHlwZSA9PT0gXCJzdHJlYW1cIilcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIGFycikge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZHVjZShub2RlLCBzdGF0ZSwgYXdhaXQgaXRlbS5nZXQoKSwgLi4uYXJncyk7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gU1RPUF9JVEVSQVRPUikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICAgICAgc3RhdGUgPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGFyci5kYXRhKSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVkdWNlKG5vZGUsIHN0YXRlLCBpdGVtLCAuLi5hcmdzKTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSBTVE9QX0lURVJBVE9SKSByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgICAgICBzdGF0ZSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXAoc3RhdGUpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGFycmF5RXhlY3V0b3IobWFwMiwgcmVkdWNlLCB7IGhpZGRlbiA9ICExIH0gPSB7fSkge1xuICByZXR1cm4ge1xuICAgIGV4ZWN1dGVTeW5jKG5vZGUsIHNjb3BlKSB7XG4gICAgICBjb25zdCBtYXBwaW5nID0gbWFwMihub2RlKSwgYXJyID0gZXhlY3V0ZVN5bmMobWFwcGluZy5hcnJheSwgc2NvcGUpO1xuICAgICAgaWYgKGFyci50eXBlICE9PSBcImFycmF5XCIpIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyLmRhdGEpIHtcbiAgICAgICAgbGV0IGlubmVyO1xuICAgICAgICBpZiAobWFwcGluZy5pbm5lcikge1xuICAgICAgICAgIGNvbnN0IG5ld1Njb3BlID0gaGlkZGVuID8gc2NvcGUuY3JlYXRlSGlkZGVuKGZyb21KUyhpdGVtKSkgOiBzY29wZS5jcmVhdGVOZXN0ZWQoZnJvbUpTKGl0ZW0pKTtcbiAgICAgICAgICBpbm5lciA9IGV4ZWN1dGVTeW5jKG1hcHBpbmcuaW5uZXIsIG5ld1Njb3BlKS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgcmVkdWNlKG5vZGUsIGl0ZW0sIGlubmVyLCBtYXBwaW5nLnN0YXRlKSlcbiAgICAgICAgICByZXN1bHQucHVzaChlbnRyeSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5KHJlc3VsdCk7XG4gICAgfSxcbiAgICBhc3luYyBleGVjdXRlQXN5bmMobm9kZSwgc2NvcGUpIHtcbiAgICAgIGNvbnN0IG1hcHBpbmcgPSBtYXAyKG5vZGUpLCBhcnIgPSBhd2FpdCBleGVjdXRlQXN5bmMobWFwcGluZy5hcnJheSwgc2NvcGUpO1xuICAgICAgcmV0dXJuIGFyci5pc0FycmF5KCkgPyBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIGFycikge1xuICAgICAgICAgIGxldCBpbm5lcjtcbiAgICAgICAgICBpZiAobWFwcGluZy5pbm5lcikge1xuICAgICAgICAgICAgY29uc3QgbmV3U2NvcGUgPSBoaWRkZW4gPyBzY29wZS5jcmVhdGVIaWRkZW4oaXRlbSkgOiBzY29wZS5jcmVhdGVOZXN0ZWQoaXRlbSk7XG4gICAgICAgICAgICBpbm5lciA9IGF3YWl0IChhd2FpdCBleGVjdXRlQXN5bmMobWFwcGluZy5pbm5lciwgbmV3U2NvcGUpKS5nZXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiByZWR1Y2Uobm9kZSwgYXdhaXQgaXRlbS5nZXQoKSwgaW5uZXIsIG1hcHBpbmcuc3RhdGUpKVxuICAgICAgICAgICAgeWllbGQgZnJvbUpTKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgfSkgOiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IEVYRUNVVE9SUyA9IHtcbiAgVGhpczogY29uc3RhbnRFeGVjdXRvcigoXywgc2NvcGUpID0+IHNjb3BlLnZhbHVlKSxcbiAgU2VsZWN0b3JOZXN0ZWQ6IGNvbnN0YW50RXhlY3V0b3IoKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgbm9kZSB0eXBlOiBTZWxlY3Rvck5lc3RlZFwiKTtcbiAgfSksXG4gIFNlbGVjdG9yRnVuY0NhbGw6IGNvbnN0YW50RXhlY3V0b3IoKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgbm9kZSB0eXBlOiBTZWxlY3RvckZ1bmNDYWxsXCIpO1xuICB9KSxcbiAgRXZlcnl0aGluZzogY29uc3RhbnRFeGVjdXRvcigoXywgc2NvcGUpID0+IHNjb3BlLnNvdXJjZSksXG4gIFBhcmFtZXRlcjogY29uc3RhbnRFeGVjdXRvcigoeyBuYW1lIH0sIHNjb3BlKSA9PiBmcm9tSlMoc2NvcGUucGFyYW1zW25hbWVdKSksXG4gIENvbnRleHQ6IGNvbnN0YW50RXhlY3V0b3IoKHsga2V5IH0sIHNjb3BlKSA9PiB7XG4gICAgaWYgKGtleSA9PT0gXCJiZWZvcmVcIiB8fCBrZXkgPT09IFwiYWZ0ZXJcIilcbiAgICAgIHJldHVybiBzY29wZS5jb250ZXh0W2tleV0gfHwgTlVMTF9WQUxVRTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gY29udGV4dCBrZXk6ICR7a2V5fWApO1xuICB9KSxcbiAgUGFyZW50OiBjb25zdGFudEV4ZWN1dG9yKCh7IG4gfSwgc2NvcGUpID0+IHtcbiAgICBsZXQgY3VycmVudCA9IHNjb3BlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBpZiAoIWN1cnJlbnQucGFyZW50KVxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQudmFsdWU7XG4gIH0pLFxuICBPcENhbGw6IHtcbiAgICBhc3luYyBleGVjdXRlQXN5bmMoeyBvcCwgbGVmdCwgcmlnaHQgfSwgc2NvcGUpIHtcbiAgICAgIGNvbnN0IGZ1bmMgPSBvcGVyYXRvcnNbb3BdO1xuICAgICAgaWYgKCFmdW5jKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gb3BlcmF0b3I6ICR7b3B9YCk7XG4gICAgICBjb25zdCBsZWZ0VmFsdWUgPSBhd2FpdCBleGVjdXRlQXN5bmMobGVmdCwgc2NvcGUpLCByaWdodFZhbHVlID0gYXdhaXQgZXhlY3V0ZUFzeW5jKHJpZ2h0LCBzY29wZSk7XG4gICAgICByZXR1cm4gZnVuYyhsZWZ0VmFsdWUsIHJpZ2h0VmFsdWUpO1xuICAgIH0sXG4gICAgZXhlY3V0ZVN5bmMoeyBvcCwgbGVmdCwgcmlnaHQgfSwgc2NvcGUpIHtcbiAgICAgIGNvbnN0IGZ1bmMgPSBvcGVyYXRvcnNbb3BdO1xuICAgICAgaWYgKCFmdW5jKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gb3BlcmF0b3I6ICR7b3B9YCk7XG4gICAgICBjb25zdCBsZWZ0VmFsdWUgPSBleGVjdXRlU3luYyhsZWZ0LCBzY29wZSksIHJpZ2h0VmFsdWUgPSBleGVjdXRlU3luYyhyaWdodCwgc2NvcGUpLCByZXN1bHQgPSBmdW5jKGxlZnRWYWx1ZSwgcmlnaHRWYWx1ZSk7XG4gICAgICBpZiAoXCJ0aGVuXCIgaW4gcmVzdWx0IHx8IHJlc3VsdC50eXBlID09PSBcInN0cmVhbVwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9wZXJhdG9yICR7b3B9IG5vdCBwb3NzaWJsZSBpbiBldmFsdXRlU3luY2ApO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0sXG4gIFNlbGVjdDoge1xuICAgIGV4ZWN1dGVTeW5jKHsgYWx0ZXJuYXRpdmVzLCBmYWxsYmFjayB9LCBzY29wZSkge1xuICAgICAgZm9yIChjb25zdCBhbHQgb2YgYWx0ZXJuYXRpdmVzKSB7XG4gICAgICAgIGNvbnN0IGFsdENvbmQgPSBleGVjdXRlU3luYyhhbHQuY29uZGl0aW9uLCBzY29wZSk7XG4gICAgICAgIGlmIChhbHRDb25kLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIGFsdENvbmQuZGF0YSA9PT0gITApXG4gICAgICAgICAgcmV0dXJuIGV4ZWN1dGVTeW5jKGFsdC52YWx1ZSwgc2NvcGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbGxiYWNrID8gZXhlY3V0ZVN5bmMoZmFsbGJhY2ssIHNjb3BlKSA6IE5VTExfVkFMVUU7XG4gICAgfSxcbiAgICBhc3luYyBleGVjdXRlQXN5bmMoeyBhbHRlcm5hdGl2ZXMsIGZhbGxiYWNrIH0sIHNjb3BlKSB7XG4gICAgICBmb3IgKGNvbnN0IGFsdCBvZiBhbHRlcm5hdGl2ZXMpIHtcbiAgICAgICAgY29uc3QgYWx0Q29uZCA9IGF3YWl0IGV4ZWN1dGVBc3luYyhhbHQuY29uZGl0aW9uLCBzY29wZSk7XG4gICAgICAgIGlmIChhbHRDb25kLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIGFsdENvbmQuZGF0YSA9PT0gITApXG4gICAgICAgICAgcmV0dXJuIGV4ZWN1dGVBc3luYyhhbHQudmFsdWUsIHNjb3BlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxsYmFjayA/IGV4ZWN1dGVBc3luYyhmYWxsYmFjaywgc2NvcGUpIDogTlVMTF9WQUxVRTtcbiAgICB9XG4gIH0sXG4gIEluUmFuZ2U6IG1hcHBlZEV4ZWN1dG9yKFxuICAgICh7IGJhc2UsIGxlZnQsIHJpZ2h0IH0pID0+IFtiYXNlLCBsZWZ0LCByaWdodF0sXG4gICAgKHsgaXNJbmNsdXNpdmUgfSwgdmFsdWUsIGxlZnRWYWx1ZSwgcmlnaHRWYWx1ZSkgPT4ge1xuICAgICAgY29uc3QgbGVmdENtcCA9IHBhcnRpYWxDb21wYXJlKHZhbHVlLmRhdGEsIGxlZnRWYWx1ZS5kYXRhKTtcbiAgICAgIGlmIChsZWZ0Q21wID09PSBudWxsKVxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIGNvbnN0IHJpZ2h0Q21wID0gcGFydGlhbENvbXBhcmUodmFsdWUuZGF0YSwgcmlnaHRWYWx1ZS5kYXRhKTtcbiAgICAgIHJldHVybiByaWdodENtcCA9PT0gbnVsbCA/IE5VTExfVkFMVUUgOiBpc0luY2x1c2l2ZSA/IGxlZnRDbXAgPj0gMCAmJiByaWdodENtcCA8PSAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFIDogbGVmdENtcCA+PSAwICYmIHJpZ2h0Q21wIDwgMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgICB9XG4gICksXG4gIEZpbHRlcjogYXJyYXlFeGVjdXRvcihcbiAgICAoeyBiYXNlLCBleHByIH0pID0+ICh7IGFycmF5OiBiYXNlLCBpbm5lcjogZXhwciB9KSxcbiAgICBmdW5jdGlvbiogKF8sIGVsZW0sIGlubmVyKSB7XG4gICAgICBpbm5lciA9PT0gITAgJiYgKHlpZWxkIGVsZW0pO1xuICAgIH1cbiAgKSxcbiAgUHJvamVjdGlvbjoge1xuICAgIGV4ZWN1dGVTeW5jKHsgYmFzZSwgZXhwciB9LCBzY29wZSkge1xuICAgICAgY29uc3QgYmFzZVZhbHVlID0gZXhlY3V0ZVN5bmMoYmFzZSwgc2NvcGUpO1xuICAgICAgaWYgKGJhc2VWYWx1ZS50eXBlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKGJhc2VWYWx1ZSk7XG4gICAgICByZXR1cm4gZXhlY3V0ZVN5bmMoZXhwciwgbmV3U2NvcGUpO1xuICAgIH0sXG4gICAgYXN5bmMgZXhlY3V0ZUFzeW5jKHsgYmFzZSwgZXhwciB9LCBzY29wZSkge1xuICAgICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZUFzeW5jKGJhc2UsIHNjb3BlKTtcbiAgICAgIGlmIChiYXNlVmFsdWUudHlwZSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZChiYXNlVmFsdWUpO1xuICAgICAgcmV0dXJuIGV4ZWN1dGVBc3luYyhleHByLCBuZXdTY29wZSk7XG4gICAgfVxuICB9LFxuICBGdW5jQ2FsbDoge1xuICAgIGV4ZWN1dGVBc3luYyh7IGZ1bmMsIGFyZ3MgfSwgc2NvcGUpIHtcbiAgICAgIHJldHVybiBmdW5jLmV4ZWN1dGVBc3luYyhhcmdzLCBzY29wZSk7XG4gICAgfSxcbiAgICBleGVjdXRlU3luYyh7IGZ1bmMsIGFyZ3MgfSwgc2NvcGUpIHtcbiAgICAgIHJldHVybiBmdW5jLmV4ZWN1dGVTeW5jKGFyZ3MsIHNjb3BlKTtcbiAgICB9XG4gIH0sXG4gIFBpcGVGdW5jQ2FsbDoge1xuICAgIGFzeW5jIGV4ZWN1dGVBc3luYyh7IGZ1bmMsIGJhc2UsIGFyZ3MgfSwgc2NvcGUpIHtcbiAgICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGF3YWl0IGV4ZWN1dGVBc3luYyhiYXNlLCBzY29wZSk7XG4gICAgICByZXR1cm4gYmFzZVZhbHVlLnR5cGUgIT09IFwic3RyZWFtXCIgJiYgYmFzZVZhbHVlLnR5cGUgIT09IFwiYXJyYXlcIiA/IE5VTExfVkFMVUUgOiBmdW5jLmV4ZWN1dGVBc3luYyh7IGJhc2U6IGJhc2VWYWx1ZSwgYXJncyB9LCBzY29wZSk7XG4gICAgfSxcbiAgICBleGVjdXRlU3luYyh7IGZ1bmMsIGJhc2UsIGFyZ3MgfSwgc2NvcGUpIHtcbiAgICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGV4ZWN1dGVTeW5jKGJhc2UsIHNjb3BlKTtcbiAgICAgIHJldHVybiBiYXNlVmFsdWUudHlwZSAhPT0gXCJhcnJheVwiID8gTlVMTF9WQUxVRSA6IGZ1bmMuZXhlY3V0ZVN5bmMoeyBiYXNlOiBiYXNlVmFsdWUsIGFyZ3MgfSwgc2NvcGUpO1xuICAgIH1cbiAgfSxcbiAgQWNjZXNzQXR0cmlidXRlOiBtYXBwZWRFeGVjdXRvcihcbiAgICAoeyBiYXNlIH0pID0+IFtiYXNlIHx8IHsgdHlwZTogXCJUaGlzXCIgfV0sXG4gICAgKHsgbmFtZSB9LCB2YWx1ZSkgPT4gdmFsdWUudHlwZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZS5kYXRhLmhhc093blByb3BlcnR5KG5hbWUpID8gZnJvbUpTKHZhbHVlLmRhdGFbbmFtZV0pIDogTlVMTF9WQUxVRVxuICApLFxuICBBY2Nlc3NFbGVtZW50OiBtYXBwZWRFeGVjdXRvcihcbiAgICAoeyBiYXNlIH0pID0+IFtiYXNlXSxcbiAgICAoeyBpbmRleCB9LCBiYXNlVmFsdWUpID0+IHtcbiAgICAgIGlmIChiYXNlVmFsdWUudHlwZSAhPT0gXCJhcnJheVwiKSByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIGNvbnN0IGRhdGEgPSBiYXNlVmFsdWUuZGF0YSwgZmluYWxJbmRleCA9IGluZGV4IDwgMCA/IGluZGV4ICsgZGF0YS5sZW5ndGggOiBpbmRleDtcbiAgICAgIHJldHVybiBmcm9tSlMoZGF0YVtmaW5hbEluZGV4XSk7XG4gICAgfVxuICApLFxuICBTbGljZTogbWFwcGVkRXhlY3V0b3IoXG4gICAgKHsgYmFzZSB9KSA9PiBbYmFzZV0sXG4gICAgKHsgbGVmdCwgcmlnaHQsIGlzSW5jbHVzaXZlIH0sIGJhc2VWYWx1ZSkgPT4ge1xuICAgICAgaWYgKGJhc2VWYWx1ZS50eXBlICE9PSBcImFycmF5XCIpXG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgY29uc3QgYXJyYXkyID0gYmFzZVZhbHVlLmRhdGE7XG4gICAgICBsZXQgbGVmdElkeCA9IGxlZnQsIHJpZ2h0SWR4ID0gcmlnaHQ7XG4gICAgICByZXR1cm4gbGVmdElkeCA8IDAgJiYgKGxlZnRJZHggPSBhcnJheTIubGVuZ3RoICsgbGVmdElkeCksIHJpZ2h0SWR4IDwgMCAmJiAocmlnaHRJZHggPSBhcnJheTIubGVuZ3RoICsgcmlnaHRJZHgpLCBpc0luY2x1c2l2ZSAmJiByaWdodElkeCsrLCBsZWZ0SWR4IDwgMCAmJiAobGVmdElkeCA9IDApLCByaWdodElkeCA8IDAgJiYgKHJpZ2h0SWR4ID0gMCksIGZyb21BcnJheShhcnJheTIuc2xpY2UobGVmdElkeCwgcmlnaHRJZHgpKTtcbiAgICB9XG4gICksXG4gIERlcmVmOiB7XG4gICAgZXhlY3V0ZVN5bmMoeyBiYXNlIH0sIHNjb3BlKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGV4ZWN1dGVTeW5jKGJhc2UsIHNjb3BlKTtcbiAgICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIGNvbnN0IGlkID0gdmFsdWUuZGF0YS5fcmVmO1xuICAgICAgaWYgKHR5cGVvZiBpZCAhPSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIGlmIChzY29wZS5jb250ZXh0LmRlcmVmZXJlbmNlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlMiA9IHNjb3BlLmNvbnRleHQuZGVyZWZlcmVuY2UoeyBfcmVmOiBpZCB9KTtcbiAgICAgICAgaWYgKHZhbHVlMiAmJiB0eXBlb2YgdmFsdWUyID09IFwib2JqZWN0XCIgJiYgXCJ0aGVuXCIgaW4gdmFsdWUyKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlcmVmZXJlbmNlIHJldHVybmVkIHByb21pc2UgaW4gc3luY2hyb25vdXMgbW9kZVwiKTtcbiAgICAgICAgcmV0dXJuIGZyb21KUyh2YWx1ZTIpO1xuICAgICAgfVxuICAgICAgaWYgKHNjb3BlLnNvdXJjZS50eXBlICE9PSBcImFycmF5XCIpXG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgZm9yIChjb25zdCBkb2Mgb2Ygc2NvcGUuc291cmNlLmRhdGEpXG4gICAgICAgIGlmIChkb2MgJiYgdHlwZW9mIGRvYyA9PSBcIm9iamVjdFwiICYmIFwiX2lkXCIgaW4gZG9jICYmIGlkID09PSBkb2MuX2lkKVxuICAgICAgICAgIHJldHVybiBmcm9tSlMoZG9jKTtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH0sXG4gICAgYXN5bmMgZXhlY3V0ZUFzeW5jKHsgYmFzZSB9LCBzY29wZSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlQXN5bmMoYmFzZSwgc2NvcGUpO1xuICAgICAgaWYgKCFzY29wZS5zb3VyY2UuaXNBcnJheSgpIHx8IHZhbHVlLnR5cGUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgY29uc3QgaWQgPSB2YWx1ZS5kYXRhLl9yZWY7XG4gICAgICBpZiAodHlwZW9mIGlkICE9IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgaWYgKHNjb3BlLmNvbnRleHQuZGVyZWZlcmVuY2UpXG4gICAgICAgIHJldHVybiBmcm9tSlMoYXdhaXQgc2NvcGUuY29udGV4dC5kZXJlZmVyZW5jZSh7IF9yZWY6IGlkIH0pKTtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgZG9jIG9mIHNjb3BlLnNvdXJjZSlcbiAgICAgICAgaWYgKGRvYy50eXBlID09PSBcIm9iamVjdFwiICYmIGlkID09PSBkb2MuZGF0YS5faWQpXG4gICAgICAgICAgcmV0dXJuIGRvYztcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgfSxcbiAgVmFsdWU6IGNvbnN0YW50RXhlY3V0b3IoKHsgdmFsdWUgfSkgPT4gZnJvbUpTKHZhbHVlKSksXG4gIEdyb3VwOiB7XG4gICAgZXhlY3V0ZVN5bmMoeyBiYXNlIH0sIHNjb3BlKSB7XG4gICAgICByZXR1cm4gZXhlY3V0ZVN5bmMoYmFzZSwgc2NvcGUpO1xuICAgIH0sXG4gICAgZXhlY3V0ZUFzeW5jKHsgYmFzZSB9LCBzY29wZSkge1xuICAgICAgcmV0dXJuIGV4ZWN1dGVBc3luYyhiYXNlLCBzY29wZSk7XG4gICAgfVxuICB9LFxuICBPYmplY3Q6IHtcbiAgICBleGVjdXRlU3luYyh7IGF0dHJpYnV0ZXMgfSwgc2NvcGUpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBhdHRyIG9mIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgY29uc3QgYXR0clR5cGUgPSBhdHRyLnR5cGU7XG4gICAgICAgIHN3aXRjaCAoYXR0ci50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIk9iamVjdEF0dHJpYnV0ZVZhbHVlXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZXhlY3V0ZVN5bmMoYXR0ci52YWx1ZSwgc2NvcGUpO1xuICAgICAgICAgICAgcmVzdWx0W2F0dHIubmFtZV0gPSB2YWx1ZS5kYXRhO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJPYmplY3RDb25kaXRpb25hbFNwbGF0XCI6IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmQgPSBleGVjdXRlU3luYyhhdHRyLmNvbmRpdGlvbiwgc2NvcGUpO1xuICAgICAgICAgICAgaWYgKGNvbmQudHlwZSAhPT0gXCJib29sZWFuXCIgfHwgY29uZC5kYXRhID09PSAhMSlcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGV4ZWN1dGVTeW5jKGF0dHIudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgICAgIHZhbHVlLnR5cGUgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHZhbHVlLmRhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJPYmplY3RTcGxhdFwiOiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGV4ZWN1dGVTeW5jKGF0dHIudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgICAgIHZhbHVlLnR5cGUgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHZhbHVlLmRhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbm9kZSB0eXBlOiAke2F0dHJUeXBlfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUpTKHJlc3VsdCk7XG4gICAgfSxcbiAgICBhc3luYyBleGVjdXRlQXN5bmMoeyBhdHRyaWJ1dGVzIH0sIHNjb3BlKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGNvbnN0IGF0dHJUeXBlID0gYXR0ci50eXBlO1xuICAgICAgICBzd2l0Y2ggKGF0dHIudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJPYmplY3RBdHRyaWJ1dGVWYWx1ZVwiOiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGVBc3luYyhhdHRyLnZhbHVlLCBzY29wZSk7XG4gICAgICAgICAgICByZXN1bHRbYXR0ci5uYW1lXSA9IGF3YWl0IHZhbHVlLmdldCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJPYmplY3RDb25kaXRpb25hbFNwbGF0XCI6IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmQgPSBhd2FpdCBleGVjdXRlQXN5bmMoYXR0ci5jb25kaXRpb24sIHNjb3BlKTtcbiAgICAgICAgICAgIGlmIChjb25kLnR5cGUgIT09IFwiYm9vbGVhblwiIHx8IGNvbmQuZGF0YSA9PT0gITEpXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlQXN5bmMoYXR0ci52YWx1ZSwgc2NvcGUpO1xuICAgICAgICAgICAgdmFsdWUudHlwZSA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3QuYXNzaWduKHJlc3VsdCwgdmFsdWUuZGF0YSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIk9iamVjdFNwbGF0XCI6IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZUFzeW5jKGF0dHIudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgICAgIHZhbHVlLnR5cGUgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHZhbHVlLmRhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbm9kZSB0eXBlOiAke2F0dHJUeXBlfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUpTKHJlc3VsdCk7XG4gICAgfVxuICB9LFxuICBBcnJheToge1xuICAgIGV4ZWN1dGVTeW5jKHsgZWxlbWVudHMgfSwgc2NvcGUpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZXhlY3V0ZVN5bmMoZWxlbWVudC52YWx1ZSwgc2NvcGUpO1xuICAgICAgICBpZiAoZWxlbWVudC5pc1NwbGF0KSB7XG4gICAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09IFwiYXJyYXlcIilcbiAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZS5kYXRhKVxuICAgICAgICAgICAgICByZXN1bHQucHVzaCh2KTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUuZGF0YSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5KHJlc3VsdCk7XG4gICAgfSxcbiAgICBhc3luYyBleGVjdXRlQXN5bmMoeyBlbGVtZW50cyB9LCBzY29wZSkge1xuICAgICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGVBc3luYyhlbGVtZW50LnZhbHVlLCBzY29wZSk7XG4gICAgICAgICAgaWYgKGVsZW1lbnQuaXNTcGxhdCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmlzQXJyYXkoKSlcbiAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCB2IG9mIHZhbHVlKVxuICAgICAgICAgICAgICAgIHlpZWxkIHY7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBUdXBsZTogY29uc3RhbnRFeGVjdXRvcigoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidHVwbGVzIGNhbiBub3QgYmUgZXZhbHVhdGVkXCIpO1xuICB9KSxcbiAgT3I6IG1hcHBlZEV4ZWN1dG9yKFxuICAgICh7IGxlZnQsIHJpZ2h0IH0pID0+IFtsZWZ0LCByaWdodF0sXG4gICAgKF8sIGxlZnRWYWx1ZSwgcmlnaHRWYWx1ZSkgPT4gbGVmdFZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIGxlZnRWYWx1ZS5kYXRhID09PSAhMCB8fCByaWdodFZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIHJpZ2h0VmFsdWUuZGF0YSA9PT0gITAgPyBUUlVFX1ZBTFVFIDogbGVmdFZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiIHx8IHJpZ2h0VmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIgPyBOVUxMX1ZBTFVFIDogRkFMU0VfVkFMVUVcbiAgKSxcbiAgQW5kOiBtYXBwZWRFeGVjdXRvcihcbiAgICAoeyBsZWZ0LCByaWdodCB9KSA9PiBbbGVmdCwgcmlnaHRdLFxuICAgIChfLCBsZWZ0VmFsdWUsIHJpZ2h0VmFsdWUpID0+IGxlZnRWYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIiAmJiBsZWZ0VmFsdWUuZGF0YSA9PT0gITEgfHwgcmlnaHRWYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIiAmJiByaWdodFZhbHVlLmRhdGEgPT09ICExID8gRkFMU0VfVkFMVUUgOiBsZWZ0VmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIgfHwgcmlnaHRWYWx1ZS50eXBlICE9PSBcImJvb2xlYW5cIiA/IE5VTExfVkFMVUUgOiBUUlVFX1ZBTFVFXG4gICksXG4gIE5vdDogbWFwcGVkRXhlY3V0b3IoXG4gICAgKHsgYmFzZSB9KSA9PiBbYmFzZV0sXG4gICAgKF8sIHZhbHVlKSA9PiB2YWx1ZS50eXBlICE9PSBcImJvb2xlYW5cIiA/IE5VTExfVkFMVUUgOiB2YWx1ZS5kYXRhID8gRkFMU0VfVkFMVUUgOiBUUlVFX1ZBTFVFXG4gICksXG4gIE5lZzogbWFwcGVkRXhlY3V0b3IoXG4gICAgKHsgYmFzZSB9KSA9PiBbYmFzZV0sXG4gICAgKF8sIHZhbHVlKSA9PiB2YWx1ZS50eXBlICE9PSBcIm51bWJlclwiID8gTlVMTF9WQUxVRSA6IGZyb21OdW1iZXIoLXZhbHVlLmRhdGEpXG4gICksXG4gIFBvczogbWFwcGVkRXhlY3V0b3IoXG4gICAgKHsgYmFzZSB9KSA9PiBbYmFzZV0sXG4gICAgKF8sIHZhbHVlKSA9PiB2YWx1ZS50eXBlICE9PSBcIm51bWJlclwiID8gTlVMTF9WQUxVRSA6IGZyb21OdW1iZXIodmFsdWUuZGF0YSlcbiAgKSxcbiAgQXNjOiBjb25zdGFudEV4ZWN1dG9yKCgpID0+IE5VTExfVkFMVUUpLFxuICBEZXNjOiBjb25zdGFudEV4ZWN1dG9yKCgpID0+IE5VTExfVkFMVUUpLFxuICBBcnJheUNvZXJjZToge1xuICAgIGV4ZWN1dGVTeW5jKHsgYmFzZSB9LCBzY29wZSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBleGVjdXRlU3luYyhiYXNlLCBzY29wZSk7XG4gICAgICByZXR1cm4gdmFsdWUuaXNBcnJheSgpID8gdmFsdWUgOiBOVUxMX1ZBTFVFO1xuICAgIH0sXG4gICAgYXN5bmMgZXhlY3V0ZUFzeW5jKHsgYmFzZSB9LCBzY29wZSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlQXN5bmMoYmFzZSwgc2NvcGUpO1xuICAgICAgcmV0dXJuIHZhbHVlLmlzQXJyYXkoKSA/IHZhbHVlIDogTlVMTF9WQUxVRTtcbiAgICB9XG4gIH0sXG4gIE1hcDogYXJyYXlFeGVjdXRvcihcbiAgICAoeyBiYXNlLCBleHByIH0pID0+ICh7IGFycmF5OiBiYXNlLCBpbm5lcjogZXhwciB9KSxcbiAgICBmdW5jdGlvbiogKF8sIF9pdGVtLCBpbm5lcikge1xuICAgICAgeWllbGQgaW5uZXI7XG4gICAgfSxcbiAgICB7IGhpZGRlbjogITAgfVxuICApLFxuICBGbGF0TWFwOiBhcnJheUV4ZWN1dG9yKFxuICAgICh7IGJhc2UsIGV4cHIgfSkgPT4gKHsgYXJyYXk6IGJhc2UsIGlubmVyOiBleHByIH0pLFxuICAgIGZ1bmN0aW9uKiAoXywgX2l0ZW0sIGlubmVyKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpbm5lcikpXG4gICAgICAgIGZvciAoY29uc3QgaW5uZXJJbm5lciBvZiBpbm5lcilcbiAgICAgICAgICB5aWVsZCBpbm5lcklubmVyO1xuICAgICAgZWxzZVxuICAgICAgICB5aWVsZCBpbm5lcjtcbiAgICB9LFxuICAgIHsgaGlkZGVuOiAhMCB9XG4gIClcbn07XG5mdW5jdGlvbiBldmFsdWF0ZVF1ZXJ5KHRyZWUsIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gZXhlY3V0ZUFzeW5jKHRyZWUsIHNjb3BlRnJvbU9wdGlvbnMob3B0aW9ucykpO1xufVxuZnVuY3Rpb24gZXZhbHVhdGVRdWVyeVN5bmModHJlZSwgb3B0aW9ucyA9IHt9KSB7XG4gIHJldHVybiBleGVjdXRlU3luYyh0cmVlLCBzY29wZUZyb21PcHRpb25zKG9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIHNjb3BlRnJvbU9wdGlvbnMob3B0aW9ucykge1xuICBjb25zdCByb290ID0gZnJvbUpTKG9wdGlvbnMucm9vdCksIGRhdGFzZXQgPSBmcm9tSlMob3B0aW9ucy5kYXRhc2V0KSwgcGFyYW1zID0geyAuLi5vcHRpb25zLnBhcmFtcyB9O1xuICByZXR1cm4gbmV3IFNjb3BlJDEoXG4gICAgcGFyYW1zLFxuICAgIGRhdGFzZXQsXG4gICAgcm9vdCxcbiAgICB7XG4gICAgICB0aW1lc3RhbXA6IG9wdGlvbnMudGltZXN0YW1wIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgaWRlbnRpdHk6IG9wdGlvbnMuaWRlbnRpdHkgPT09IHZvaWQgMCA/IFwibWVcIiA6IG9wdGlvbnMuaWRlbnRpdHksXG4gICAgICBzYW5pdHk6IG9wdGlvbnMuc2FuaXR5LFxuICAgICAgYWZ0ZXI6IG9wdGlvbnMuYWZ0ZXIgPyBmcm9tSlMob3B0aW9ucy5hZnRlcikgOiBudWxsLFxuICAgICAgYmVmb3JlOiBvcHRpb25zLmJlZm9yZSA/IGZyb21KUyhvcHRpb25zLmJlZm9yZSkgOiBudWxsLFxuICAgICAgZGVyZWZlcmVuY2U6IG9wdGlvbnMuZGVyZWZlcmVuY2VcbiAgICB9LFxuICAgIG51bGxcbiAgKTtcbn1cbmZ1bmN0aW9uIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZSkge1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJHcm91cFwiOlxuICAgICAgcmV0dXJuIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZS5iYXNlKTtcbiAgICBjYXNlIFwiVmFsdWVcIjpcbiAgICBjYXNlIFwiUGFyYW1ldGVyXCI6XG4gICAgICByZXR1cm4gITA7XG4gICAgY2FzZSBcIlBvc1wiOlxuICAgIGNhc2UgXCJOZWdcIjpcbiAgICAgIHJldHVybiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUuYmFzZSk7XG4gICAgY2FzZSBcIk9wQ2FsbFwiOlxuICAgICAgc3dpdGNoIChub2RlLm9wKSB7XG4gICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgIGNhc2UgXCIvXCI6XG4gICAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgIGNhc2UgXCIqKlwiOlxuICAgICAgICAgIHJldHVybiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUubGVmdCkgJiYgY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlLnJpZ2h0KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAhMTtcbiAgfVxufVxuY29uc3QgRFVNTVlfU0NPUEUgPSBuZXcgU2NvcGUkMShcbiAge30sXG4gIE5VTExfVkFMVUUsXG4gIE5VTExfVkFMVUUsXG4gIHsgdGltZXN0YW1wOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoMCksIGlkZW50aXR5OiBcIm1lXCIsIGJlZm9yZTogbnVsbCwgYWZ0ZXI6IG51bGwgfSxcbiAgbnVsbFxuKTtcbmZ1bmN0aW9uIHRyeUNvbnN0YW50RXZhbHVhdGUobm9kZSkge1xuICByZXR1cm4gY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlKSA/IGNvbnN0YW50RXZhbHVhdGUobm9kZSkgOiBudWxsO1xufVxuZnVuY3Rpb24gY29uc3RhbnRFdmFsdWF0ZShub2RlKSB7XG4gIHJldHVybiBleGVjdXRlU3luYyhub2RlLCBEVU1NWV9TQ09QRSk7XG59XG5mdW5jdGlvbiBpc1NlbGVjdG9yTm9kZShub2RlKSB7XG4gIHJldHVybiBbXG4gICAgXCJBY2Nlc3NBdHRyaWJ1dGVcIixcbiAgICBcIlNlbGVjdG9yRnVuY0NhbGxcIixcbiAgICBcIkdyb3VwXCIsXG4gICAgXCJUdXBsZVwiLFxuICAgIFwiQXJyYXlDb2VyY2VcIixcbiAgICBcIkZpbHRlclwiLFxuICAgIFwiU2VsZWN0b3JOZXN0ZWRcIlxuICBdLmluY2x1ZGVzKG5vZGUudHlwZSk7XG59XG5mdW5jdGlvbiBpc1NlbGVjdG9yTmVzdGVkKG5vZGUpIHtcbiAgcmV0dXJuIFtcIkFjY2Vzc0F0dHJpYnV0ZVwiLCBcIkFycmF5Q29lcmNlXCIsIFwiRmlsdGVyXCIsIFwiR3JvdXBcIiwgXCJUdXBsZVwiLCBcIlNlbGVjdG9yTmVzdGVkXCJdLmluY2x1ZGVzKFxuICAgIG5vZGUudHlwZVxuICApO1xufVxuY29uc3QgYXJyYXkgPSB7fTtcbmFycmF5LmpvaW4gPSBtYXBwZWRFeGVjdXRvcihcbiAgKGFyZ3MpID0+IGFyZ3MsXG4gIChfLCBhcnIsIHNlcCkgPT4ge1xuICAgIGlmIChhcnIudHlwZSAhPT0gXCJhcnJheVwiIHx8IHNlcC50eXBlICE9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgbGV0IGJ1ZiA9IFwiXCIsIG5lZWRTZXAgPSAhMTtcbiAgICBmb3IgKGNvbnN0IGVsZW0gb2YgYXJyLmRhdGEpIHtcbiAgICAgIHN3aXRjaCAobmVlZFNlcCAmJiAoYnVmICs9IHNlcC5kYXRhKSwgZ2V0VHlwZShlbGVtKSkge1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgY2FzZSBcImRhdGV0aW1lXCI6XG4gICAgICAgICAgYnVmICs9IGAke2VsZW19YDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIH1cbiAgICAgIG5lZWRTZXAgPSAhMDtcbiAgICB9XG4gICAgcmV0dXJuIGZyb21TdHJpbmcoYnVmKTtcbiAgfVxuKTtcbmFycmF5LmpvaW4uYXJpdHkgPSAyO1xuYXJyYXkuY29tcGFjdCA9IGFycmF5RXhlY3V0b3IoXG4gIChbYXJyYXkyXSkgPT4gKHsgYXJyYXk6IGFycmF5MiB9KSxcbiAgZnVuY3Rpb24qIChfLCBpdGVtKSB7XG4gICAgaXRlbSAhPT0gbnVsbCAmJiAoeWllbGQgaXRlbSk7XG4gIH1cbik7XG5hcnJheS5jb21wYWN0LmFyaXR5ID0gMTtcbmFycmF5LnVuaXF1ZSA9IGFycmF5RXhlY3V0b3IoXG4gIChhcmdzKSA9PiAoeyBhcnJheTogYXJnc1swXSwgc3RhdGU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkgfSksXG4gIGZ1bmN0aW9uKiAoX25vZGUsIGl0ZXIsIF9pbm5lciwgYWRkZWQpIHtcbiAgICBzd2l0Y2ggKGdldFR5cGUoaXRlcikpIHtcbiAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICBjYXNlIFwiZGF0ZXRpbWVcIjpcbiAgICAgICAgYWRkZWQuaGFzKGl0ZXIpIHx8IChhZGRlZC5hZGQoaXRlciksIHlpZWxkIGl0ZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHlpZWxkIGl0ZXI7XG4gICAgfVxuICB9XG4pO1xuYXJyYXkudW5pcXVlLmFyaXR5ID0gMTtcbmFycmF5LmludGVyc2VjdHMgPSBtYXBwZWRFeGVjdXRvcihcbiAgKGFyZ3MpID0+IGFyZ3MsXG4gIChfLCBhcnIxLCBhcnIyKSA9PiB7XG4gICAgaWYgKGFycjEudHlwZSAhPT0gXCJhcnJheVwiIHx8IGFycjIudHlwZSAhPT0gXCJhcnJheVwiKVxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgZm9yIChjb25zdCB2MSBvZiBhcnIxLmRhdGEpXG4gICAgICBmb3IgKGNvbnN0IHYyIG9mIGFycjIuZGF0YSlcbiAgICAgICAgaWYgKGlzRXF1YWwoZnJvbUpTKHYxKSwgZnJvbUpTKHYyKSkpXG4gICAgICAgICAgcmV0dXJuIFRSVUVfVkFMVUU7XG4gICAgcmV0dXJuIEZBTFNFX1ZBTFVFO1xuICB9XG4pO1xuYXJyYXkuaW50ZXJzZWN0cy5hcml0eSA9IDI7XG5jb25zdCBkYXRlVGltZSA9IHt9O1xuZGF0ZVRpbWUubm93ID0gY29uc3RhbnRFeGVjdXRvcihcbiAgKF8sIHNjb3BlKSA9PiBmcm9tRGF0ZVRpbWUobmV3IERhdGVUaW1lKHNjb3BlLmNvbnRleHQudGltZXN0YW1wKSlcbik7XG5kYXRlVGltZS5ub3cuYXJpdHkgPSAwO1xuYXN5bmMgZnVuY3Rpb24gdmFsdWVBdFBhdGgoYXJnLCBrZXlQYXRoKSB7XG4gIGZ1bmN0aW9uIHRyeUFjY2Vzc29yKGFyZzIsIGFjY2Vzc29yKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhcmcyW2FjY2Vzc29yXTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgbGV0IGN1cnJlbnQgPSBhd2FpdCBhcmcuZ2V0KCk7XG4gIGZvciAoY29uc3QgcGFydCBvZiBrZXlQYXRoKVxuICAgIGlmIChjdXJyZW50ID0gdHJ5QWNjZXNzb3IoY3VycmVudCwgcGFydCksICFjdXJyZW50KSBicmVhaztcbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG5mdW5jdGlvbiBzdGFydHNXaXRoKGtleVBhdGgsIHByZWZpeCkge1xuICByZXR1cm4gcHJlZml4LmV2ZXJ5KChpdGVtLCBpbmRleCkgPT4ga2V5UGF0aFtpbmRleF0gPT09IGl0ZW0pO1xufVxuYXN5bmMgZnVuY3Rpb24qIGRpZmZLZXlQYXRocyhiZWZvcmUsIGFmdGVyKSB7XG4gIGNvbnN0IGN1cnJQYXRocyA9IFtbXV07XG4gIGZvciAoOyBjdXJyUGF0aHMubGVuZ3RoID4gMDsgKSB7XG4gICAgY29uc3QgY3VyclBhdGggPSBjdXJyUGF0aHMuc2hpZnQoKSB8fCBbXSwgYiA9IGZyb21KUyhhd2FpdCB2YWx1ZUF0UGF0aChiZWZvcmUsIGN1cnJQYXRoKSksIGEgPSBmcm9tSlMoYXdhaXQgdmFsdWVBdFBhdGgoYWZ0ZXIsIGN1cnJQYXRoKSk7XG4gICAgaWYgKGEudHlwZSAhPT0gYi50eXBlKVxuICAgICAgeWllbGQgY3VyclBhdGg7XG4gICAgZWxzZSBpZiAoYS50eXBlID09PSBcInN0cmluZ1wiICYmIGIudHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBhLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIGIudHlwZSA9PT0gXCJib29sZWFuXCIgfHwgYS50eXBlID09PSBcIm51bGxcIiAmJiBiLnR5cGUgPT09IFwibnVsbFwiIHx8IGEudHlwZSA9PT0gXCJudW1iZXJcIiAmJiBiLnR5cGUgPT09IFwibnVtYmVyXCIpXG4gICAgICBhLmRhdGEgIT09IGIuZGF0YSAmJiAoeWllbGQgY3VyclBhdGgpO1xuICAgIGVsc2UgaWYgKGEudHlwZSA9PT0gXCJkYXRldGltZVwiICYmIGIudHlwZSA9PT0gXCJkYXRldGltZVwiKVxuICAgICAgYS5kYXRhLmVxdWFscyhiLmRhdGEpIHx8ICh5aWVsZCBjdXJyUGF0aCk7XG4gICAgZWxzZSBpZiAoYS50eXBlID09PSBcIm9iamVjdFwiICYmIGIudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgaWYgKCFkZWVwRXF1YWwoYS5kYXRhLCBiLmRhdGEpKSB7XG4gICAgICAgIGNvbnN0IGFLZXlzID0gT2JqZWN0LmtleXMoYS5kYXRhKSwgYktleXMgPSBPYmplY3Qua2V5cyhiLmRhdGEpO1xuICAgICAgICBuZXcgU2V0KGFLZXlzLmNvbmNhdChiS2V5cykpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgIGN1cnJQYXRocy5wdXNoKFsuLi5jdXJyUGF0aCwga2V5XSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYS50eXBlID09PSBcImFycmF5XCIgJiYgYi50eXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgIGlmIChhLmRhdGEubGVuZ3RoICE9PSBiLmRhdGEubGVuZ3RoKVxuICAgICAgICB5aWVsZCBjdXJyUGF0aDtcbiAgICAgIGVsc2UgaWYgKCFkZWVwRXF1YWwoYS5kYXRhLCBiLmRhdGEpKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGIuZGF0YS5sZW5ndGg7IGkrKylcbiAgICAgICAgICBjdXJyUGF0aHMucHVzaChbLi4uY3VyclBhdGgsIGldKTtcbiAgICB9IGVsc2UgaWYgKGEudHlwZSA9PT0gXCJzdHJlYW1cIiAmJiBiLnR5cGUgPT09IFwic3RyZWFtXCIpIHtcbiAgICAgIGNvbnN0IGFycmF5QSA9IGF3YWl0IGEuZ2V0KCksIGFycmF5QiA9IGF3YWl0IGIuZ2V0KCk7XG4gICAgICBpZiAoYXJyYXlBLmxlbmd0aCAhPT0gYXJyYXlCLmxlbmd0aClcbiAgICAgICAgeWllbGQgY3VyclBhdGg7XG4gICAgICBlbHNlIGlmICghZGVlcEVxdWFsKGFycmF5QSwgYXJyYXlCKSlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheUIubGVuZ3RoOyBpKyspXG4gICAgICAgICAgY3VyclBhdGhzLnB1c2goWy4uLmN1cnJQYXRoLCBpXSk7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBldmFsdWF0ZVNlbGVjdG9yKG5vZGUsIHZhbHVlLCBzY29wZSkge1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJHcm91cFwiOlxuICAgICAgcmV0dXJuIGF3YWl0IGV2YWx1YXRlU2VsZWN0b3Iobm9kZS5iYXNlLCB2YWx1ZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJUdXBsZVwiOlxuICAgICAgY29uc3QgdHVwbGVQYXRocyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2Ygbm9kZS5tZW1iZXJzKSB7XG4gICAgICAgIGNvbnN0IG1lbWJlclBhdGhzID0gYXdhaXQgZXZhbHVhdGVTZWxlY3RvcihtZW1iZXIsIHZhbHVlLCBzY29wZSk7XG4gICAgICAgIHR1cGxlUGF0aHMucHVzaCguLi5tZW1iZXJQYXRocyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHVwbGVQYXRocztcbiAgICBjYXNlIFwiQWNjZXNzQXR0cmlidXRlXCI6XG4gICAgICByZXR1cm4gbm9kZS5iYXNlID8gKGF3YWl0IGV2YWx1YXRlU2VsZWN0b3Iobm9kZS5iYXNlLCB2YWx1ZSwgc2NvcGUpKS5tYXAoKHBhdGgpID0+IFsuLi5wYXRoLCBub2RlLm5hbWVdKSA6IFtbbm9kZS5uYW1lXV07XG4gICAgY2FzZSBcIkFycmF5Q29lcmNlXCI6IHtcbiAgICAgIGNvbnN0IHBhdGhzID0gYXdhaXQgZXZhbHVhdGVTZWxlY3Rvcihub2RlLmJhc2UsIHZhbHVlLCBzY29wZSksIGFycmF5UGF0aHMgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qga2V5UGF0aCBvZiBwYXRocykge1xuICAgICAgICBjb25zdCBpbm5lclZhbHVlID0gYXdhaXQgdmFsdWVBdFBhdGgodmFsdWUsIGtleVBhdGgpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbm5lclZhbHVlKSlcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlubmVyVmFsdWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBhcnJheVBhdGhzLnB1c2goWy4uLmtleVBhdGgsIGldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheVBhdGhzO1xuICAgIH1cbiAgICBjYXNlIFwiRmlsdGVyXCI6IHtcbiAgICAgIGNvbnN0IHBhdGhzID0gYXdhaXQgZXZhbHVhdGVTZWxlY3Rvcihub2RlLmJhc2UsIHZhbHVlLCBzY29wZSksIGZpbHRlciA9IHtcbiAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgYmFzZTogeyB0eXBlOiBcIlRoaXNcIiB9XG4gICAgICB9LCBhcnJheVBhdGhzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGtleVBhdGggb2YgcGF0aHMpIHtcbiAgICAgICAgY29uc3QgaW5uZXJWYWx1ZSA9IGF3YWl0IHZhbHVlQXRQYXRoKHZhbHVlLCBrZXlQYXRoKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5uZXJWYWx1ZSkpXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbm5lclZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gaW5uZXJWYWx1ZVtpXSwgbmVzdGVkU2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQoZnJvbUpTKFtpdGVtXSkpO1xuICAgICAgICAgICAgKGF3YWl0IChhd2FpdCBldmFsdWF0ZShmaWx0ZXIsIG5lc3RlZFNjb3BlKSkuZ2V0KCkpLmxlbmd0aCA+IDAgJiYgYXJyYXlQYXRocy5wdXNoKFsuLi5rZXlQYXRoLCBpXSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5UGF0aHM7XG4gICAgfVxuICAgIGNhc2UgXCJTZWxlY3RvckZ1bmNDYWxsXCI6XG4gICAgICByZXR1cm4gYW55d2hlcmUobm9kZS5hcmcsIHNjb3BlLmNyZWF0ZUhpZGRlbih2YWx1ZSkpO1xuICAgIGNhc2UgXCJTZWxlY3Rvck5lc3RlZFwiOiB7XG4gICAgICBjb25zdCB7IGJhc2UsIG5lc3RlZDogZXhwciB9ID0gbm9kZSwgcGF0aHMgPSBhd2FpdCBldmFsdWF0ZVNlbGVjdG9yKGJhc2UsIHZhbHVlLCBzY29wZSksIG5lc3RlZFBhdGhzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGtleVBhdGggb2YgcGF0aHMpIHtcbiAgICAgICAgY29uc3QgaW5uZXJWYWx1ZSA9IGF3YWl0IHZhbHVlQXRQYXRoKHZhbHVlLCBrZXlQYXRoKTtcbiAgICAgICAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiQWNjZXNzQXR0cmlidXRlXCI6XG4gICAgICAgICAgY2FzZSBcIkFycmF5Q29lcmNlXCI6XG4gICAgICAgICAgY2FzZSBcIkZpbHRlclwiOlxuICAgICAgICAgICAgY29uc3QgYWNjZXNzUGF0aHMgPSBhd2FpdCBldmFsdWF0ZVNlbGVjdG9yKGV4cHIsIGZyb21KUyhpbm5lclZhbHVlKSwgc2NvcGUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY2Nlc3NQYXRocy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgbmVzdGVkUGF0aHMucHVzaChbLi4ua2V5UGF0aCwgLi4uYWNjZXNzUGF0aHNbaV1dKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJHcm91cFwiOlxuICAgICAgICAgICAgY29uc3QgaW5uZXJSZXN1bHQgPSBhd2FpdCBldmFsdWF0ZVNlbGVjdG9yKGV4cHIuYmFzZSwgZnJvbUpTKGlubmVyVmFsdWUpLCBzY29wZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlubmVyS2V5UGF0aCBvZiBpbm5lclJlc3VsdClcbiAgICAgICAgICAgICAgbmVzdGVkUGF0aHMucHVzaChbLi4ua2V5UGF0aCwgLi4uaW5uZXJLZXlQYXRoXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiVHVwbGVcIjpcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5uZXIgb2YgZXhwci5tZW1iZXJzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGlubmVyUmVzdWx0MiA9IGF3YWl0IGV2YWx1YXRlU2VsZWN0b3IoaW5uZXIsIGZyb21KUyhpbm5lclZhbHVlKSwgc2NvcGUpO1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlubmVyS2V5UGF0aCBvZiBpbm5lclJlc3VsdDIpXG4gICAgICAgICAgICAgICAgbmVzdGVkUGF0aHMucHVzaChbLi4ua2V5UGF0aCwgLi4uaW5uZXJLZXlQYXRoXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXN0ZWRQYXRocztcbiAgICB9XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGFueXdoZXJlKGV4cHIsIHNjb3BlLCBiYXNlID0gW10pIHtcbiAgY29uc3QgdmFsdWUgPSBzY29wZS52YWx1ZSwgcGF0aExpc3QgPSBbXTtcbiAgaWYgKHZhbHVlLmlzQXJyYXkoKSkge1xuICAgIGNvbnN0IGFyciA9IGF3YWl0IHZhbHVlLmdldCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdWJQYXRocyA9IGF3YWl0IGFueXdoZXJlKGV4cHIsIHNjb3BlLmNyZWF0ZUhpZGRlbihmcm9tSlMoYXJyW2ldKSksIFsuLi5iYXNlLCBpXSk7XG4gICAgICBwYXRoTGlzdC5wdXNoKC4uLnN1YlBhdGhzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodmFsdWUudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV2YWx1YXRlKGV4cHIsIHNjb3BlKTtcbiAgICByZXN1bHQudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgcmVzdWx0LmRhdGEgPT09ICEwICYmIHBhdGhMaXN0LnB1c2goYmFzZSk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModmFsdWUuZGF0YSkpIHtcbiAgICAgIGNvbnN0IHN1YlBhdGhzID0gYXdhaXQgYW55d2hlcmUoZXhwciwgc2NvcGUuY3JlYXRlSGlkZGVuKGZyb21KUyh2YWx1ZS5kYXRhW2tleV0pKSwgW1xuICAgICAgICAuLi5iYXNlLFxuICAgICAgICBrZXlcbiAgICAgIF0pO1xuICAgICAgcGF0aExpc3QucHVzaCguLi5zdWJQYXRocyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXRoTGlzdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNoYW5nZWRBbnkoYmVmb3JlLCBhZnRlciwgc2VsZWN0b3IsIHNjb3BlKSB7XG4gIGNvbnN0IGJlZm9yZVNlbGVjdG9yU2NvcGUgPSBzY29wZS5jcmVhdGVIaWRkZW4oYmVmb3JlKSwgYmVmb3JlUGF0aHMgPSBhd2FpdCBldmFsdWF0ZVNlbGVjdG9yKFxuICAgIHNlbGVjdG9yLFxuICAgIGJlZm9yZVNlbGVjdG9yU2NvcGUudmFsdWUsXG4gICAgYmVmb3JlU2VsZWN0b3JTY29wZVxuICApLCBhZnRlclNlbGVjdG9yU2NvcGUgPSBzY29wZS5jcmVhdGVIaWRkZW4oYWZ0ZXIpLCBhZnRlclBhdGhzID0gYXdhaXQgZXZhbHVhdGVTZWxlY3RvcihzZWxlY3RvciwgYWZ0ZXJTZWxlY3RvclNjb3BlLnZhbHVlLCBhZnRlclNlbGVjdG9yU2NvcGUpO1xuICBpZiAoYmVmb3JlUGF0aHMubGVuZ3RoICE9PSBhZnRlclBhdGhzLmxlbmd0aClcbiAgICByZXR1cm4gVFJVRV9WQUxVRTtcbiAgZm9yIChjb25zdCBwYXRoIG9mIGJlZm9yZVBhdGhzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKVxuICAgICAgaWYgKHR5cGVvZiBwYXRoW2ldID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgY29uc3Qgc2xpY2UgPSBwYXRoLnNsaWNlKDAsIGkpLCBiZWZvcmVBcnIgPSBhd2FpdCB2YWx1ZUF0UGF0aChiZWZvcmUsIHNsaWNlKSwgYWZ0ZXJBcnIgPSBhd2FpdCB2YWx1ZUF0UGF0aChhZnRlciwgc2xpY2UpO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYmVmb3JlQXJyKSB8fCAhQXJyYXkuaXNBcnJheShhZnRlckFycikgfHwgYmVmb3JlQXJyLmxlbmd0aCAhPT0gYWZ0ZXJBcnIubGVuZ3RoKVxuICAgICAgICAgIHJldHVybiBUUlVFX1ZBTFVFO1xuICAgICAgfVxuICAgIGNvbnN0IGJlZm9yZVZhbHVlID0gYXdhaXQgdmFsdWVBdFBhdGgoYmVmb3JlLCBwYXRoKSwgYWZ0ZXJWYWx1ZSA9IGF3YWl0IHZhbHVlQXRQYXRoKGFmdGVyLCBwYXRoKTtcbiAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmVWYWx1ZSwgYWZ0ZXJWYWx1ZSkpXG4gICAgICByZXR1cm4gVFJVRV9WQUxVRTtcbiAgfVxuICByZXR1cm4gRkFMU0VfVkFMVUU7XG59XG5hc3luYyBmdW5jdGlvbiBjaGFuZ2VkT25seShiZWZvcmUsIGFmdGVyLCBzZWxlY3Rvciwgc2NvcGUpIHtcbiAgY29uc3QgYmVmb3JlU2VsZWN0b3JTY29wZSA9IHNjb3BlLmNyZWF0ZUhpZGRlbihiZWZvcmUpLCBzZWxlY3RlZFBhdGhzID0gYXdhaXQgZXZhbHVhdGVTZWxlY3RvcihcbiAgICBzZWxlY3RvcixcbiAgICBiZWZvcmVTZWxlY3RvclNjb3BlLnZhbHVlLFxuICAgIGJlZm9yZVNlbGVjdG9yU2NvcGVcbiAgKTtcbiAgZm9yIGF3YWl0IChjb25zdCBkaWZmUGF0aCBvZiBkaWZmS2V5UGF0aHMoYmVmb3JlLCBhZnRlcikpIHtcbiAgICBsZXQgZm91bmQgPSAhMTtcbiAgICBmb3IgKGNvbnN0IHNlbGVjdGVkUGF0aCBvZiBzZWxlY3RlZFBhdGhzKVxuICAgICAgaWYgKHN0YXJ0c1dpdGgoZGlmZlBhdGgsIHNlbGVjdGVkUGF0aCkpIHtcbiAgICAgICAgZm91bmQgPSAhMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgaWYgKCFmb3VuZClcbiAgICAgIHJldHVybiBGQUxTRV9WQUxVRTtcbiAgfVxuICByZXR1cm4gVFJVRV9WQUxVRTtcbn1cbmNvbnN0IGRpZmYgPSB7fTtcbmRpZmYuY2hhbmdlZEFueSA9IGFzeW5jT25seUV4ZWN1dG9yKGFzeW5jIChhcmdzLCBzY29wZSkgPT4ge1xuICBjb25zdCBsaHMgPSBhcmdzWzBdLCByaHMgPSBhcmdzWzFdLCBzZWxlY3RvciA9IGFyZ3NbMl07XG4gIGlmICghaXNTZWxlY3Rvck5vZGUoc2VsZWN0b3IpKSB0aHJvdyBuZXcgRXJyb3IoXCJjaGFuZ2VkQW55IHRoaXJkIGFyZ3VtZW50IG11c3QgYmUgYSBzZWxlY3RvclwiKTtcbiAgY29uc3QgYmVmb3JlID0gYXdhaXQgZXhlY3V0ZUFzeW5jKGxocywgc2NvcGUpLCBhZnRlciA9IGF3YWl0IGV4ZWN1dGVBc3luYyhyaHMsIHNjb3BlKTtcbiAgcmV0dXJuIGNoYW5nZWRBbnkoYmVmb3JlLCBhZnRlciwgc2VsZWN0b3IsIHNjb3BlKTtcbn0pO1xuZGlmZi5jaGFuZ2VkQW55LmFyaXR5ID0gMztcbmRpZmYuY2hhbmdlZE9ubHkgPSBhc3luY09ubHlFeGVjdXRvcihhc3luYyAoYXJncywgc2NvcGUpID0+IHtcbiAgY29uc3QgbGhzID0gYXJnc1swXSwgcmhzID0gYXJnc1sxXSwgc2VsZWN0b3IgPSBhcmdzWzJdO1xuICBpZiAoIWlzU2VsZWN0b3JOb2RlKHNlbGVjdG9yKSkgdGhyb3cgbmV3IEVycm9yKFwiY2hhbmdlZE9ubHkgdGhpcmQgYXJndW1lbnQgbXVzdCBiZSBhIHNlbGVjdG9yXCIpO1xuICBjb25zdCBiZWZvcmUgPSBhd2FpdCBleGVjdXRlQXN5bmMobGhzLCBzY29wZSksIGFmdGVyID0gYXdhaXQgZXhlY3V0ZUFzeW5jKHJocywgc2NvcGUpO1xuICByZXR1cm4gY2hhbmdlZE9ubHkoYmVmb3JlLCBhZnRlciwgc2VsZWN0b3IsIHNjb3BlKTtcbn0pO1xuZGlmZi5jaGFuZ2VkT25seS5hcml0eSA9IDM7XG5jb25zdCBkZWx0YSA9IHt9O1xuZGVsdGEub3BlcmF0aW9uID0gY29uc3RhbnRFeGVjdXRvcigoXywgc2NvcGUpID0+IHtcbiAgY29uc3QgaGFzQmVmb3JlID0gc2NvcGUuY29udGV4dC5iZWZvcmUgIT09IG51bGwsIGhhc0FmdGVyID0gc2NvcGUuY29udGV4dC5hZnRlciAhPT0gbnVsbDtcbiAgcmV0dXJuIGhhc0JlZm9yZSAmJiBoYXNBZnRlciA/IGZyb21TdHJpbmcoXCJ1cGRhdGVcIikgOiBoYXNBZnRlciA/IGZyb21TdHJpbmcoXCJjcmVhdGVcIikgOiBoYXNCZWZvcmUgPyBmcm9tU3RyaW5nKFwiZGVsZXRlXCIpIDogTlVMTF9WQUxVRTtcbn0pO1xuZGVsdGEuY2hhbmdlZEFueSA9IGFzeW5jT25seUV4ZWN1dG9yKGFzeW5jIChhcmdzLCBzY29wZSkgPT4ge1xuICBjb25zdCBiZWZvcmUgPSBzY29wZS5jb250ZXh0LmJlZm9yZSB8fCBOVUxMX1ZBTFVFLCBhZnRlciA9IHNjb3BlLmNvbnRleHQuYWZ0ZXIgfHwgTlVMTF9WQUxVRSwgc2VsZWN0b3IgPSBhcmdzWzBdO1xuICBpZiAoIWlzU2VsZWN0b3JOb2RlKHNlbGVjdG9yKSkgdGhyb3cgbmV3IEVycm9yKFwiY2hhbmdlZEFueSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc2VsZWN0b3JcIik7XG4gIHJldHVybiBjaGFuZ2VkQW55KGJlZm9yZSwgYWZ0ZXIsIHNlbGVjdG9yLCBzY29wZSk7XG59KTtcbmRlbHRhLmNoYW5nZWRBbnkuYXJpdHkgPSAxO1xuZGVsdGEuY2hhbmdlZEFueS5tb2RlID0gXCJkZWx0YVwiO1xuZGVsdGEuY2hhbmdlZE9ubHkgPSBhc3luY09ubHlFeGVjdXRvcihhc3luYyAoYXJncywgc2NvcGUpID0+IHtcbiAgY29uc3QgYmVmb3JlID0gc2NvcGUuY29udGV4dC5iZWZvcmUgfHwgTlVMTF9WQUxVRSwgYWZ0ZXIgPSBzY29wZS5jb250ZXh0LmFmdGVyIHx8IE5VTExfVkFMVUUsIHNlbGVjdG9yID0gYXJnc1swXTtcbiAgaWYgKCFpc1NlbGVjdG9yTm9kZShzZWxlY3RvcikpIHRocm93IG5ldyBFcnJvcihcImNoYW5nZWRPbmx5IGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzZWxlY3RvclwiKTtcbiAgcmV0dXJuIGNoYW5nZWRPbmx5KGJlZm9yZSwgYWZ0ZXIsIHNlbGVjdG9yLCBzY29wZSk7XG59KTtcbmRlbHRhLmNoYW5nZWRPbmx5LmFyaXR5ID0gMTtcbmRlbHRhLmNoYW5nZWRPbmx5Lm1vZGUgPSBcImRlbHRhXCI7XG5jb25zdCBkb2N1bWVudHMgPSB7fTtcbmRvY3VtZW50cy5nZXQgPSBjb25zdGFudEV4ZWN1dG9yKCgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufSk7XG5jb25zdCBnZW8gPSB7fTtcbmdlby5sYXRMbmcgPSBjb25zdGFudEV4ZWN1dG9yKCgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufSk7XG5nZW8uY29udGFpbnMgPSBjb25zdGFudEV4ZWN1dG9yKCgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufSk7XG5nZW8uaW50ZXJzZWN0cyA9IGNvbnN0YW50RXhlY3V0b3IoKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG59KTtcbmdlby5kaXN0YW5jZSA9IGNvbnN0YW50RXhlY3V0b3IoKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG59KTtcbmNvbnN0IHN0cmluZyA9IHt9O1xuc3RyaW5nLmxvd2VyID0gbWFwcGVkRXhlY3V0b3IoXG4gIChhcmdzKSA9PiBhcmdzLFxuICAoXywgdmFsdWUpID0+IHZhbHVlLnR5cGUgIT09IFwic3RyaW5nXCIgPyBOVUxMX1ZBTFVFIDogZnJvbVN0cmluZyh2YWx1ZS5kYXRhLnRvTG93ZXJDYXNlKCkpXG4pO1xuc3RyaW5nLmxvd2VyLmFyaXR5ID0gMTtcbnN0cmluZy51cHBlciA9IG1hcHBlZEV4ZWN1dG9yKFxuICAoYXJncykgPT4gYXJncyxcbiAgKF8sIHZhbHVlKSA9PiB2YWx1ZS50eXBlICE9PSBcInN0cmluZ1wiID8gTlVMTF9WQUxVRSA6IGZyb21TdHJpbmcodmFsdWUuZGF0YS50b1VwcGVyQ2FzZSgpKVxuKTtcbnN0cmluZy51cHBlci5hcml0eSA9IDE7XG5zdHJpbmcuc3BsaXQgPSBtYXBwZWRFeGVjdXRvcihcbiAgKGFyZ3MpID0+IGFyZ3MsXG4gIChfLCBzdHIsIHNlcCkgPT4gc3RyLnR5cGUgIT09IFwic3RyaW5nXCIgfHwgc2VwLnR5cGUgIT09IFwic3RyaW5nXCIgPyBOVUxMX1ZBTFVFIDogc3RyLmRhdGEubGVuZ3RoID09PSAwID8gZnJvbUFycmF5KFtdKSA6IHNlcC5kYXRhLmxlbmd0aCA9PT0gMCA/IGZyb21BcnJheShBcnJheS5mcm9tKHN0ci5kYXRhKSkgOiBmcm9tQXJyYXkoc3RyLmRhdGEuc3BsaXQoc2VwLmRhdGEpKVxuKTtcbnN0cmluZy5zcGxpdC5hcml0eSA9IDI7XG5zdHJpbmcuc3RhcnRzV2l0aCA9IG1hcHBlZEV4ZWN1dG9yKFxuICAoYXJncykgPT4gYXJncyxcbiAgKF8sIHN0ciwgcHJlZml4KSA9PiBzdHIudHlwZSAhPT0gXCJzdHJpbmdcIiB8fCBwcmVmaXgudHlwZSAhPT0gXCJzdHJpbmdcIiA/IE5VTExfVkFMVUUgOiBzdHIuZGF0YS5zdGFydHNXaXRoKHByZWZpeC5kYXRhKSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRVxuKTtcbnN0cmluZy5zdGFydHNXaXRoLmFyaXR5ID0gMjtcbmNvbnN0IF9nbG9iYWwgPSB7fTtcbl9nbG9iYWwuYW55d2hlcmUgPSBjb25zdGFudEV4ZWN1dG9yKCgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufSk7XG5fZ2xvYmFsLmFueXdoZXJlLmFyaXR5ID0gMTtcbl9nbG9iYWwuY29hbGVzY2UgPSB7XG4gIGFzeW5jIGV4ZWN1dGVBc3luYyhhcmdzLCBzY29wZSkge1xuICAgIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZUFzeW5jKGFyZywgc2NvcGUpO1xuICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IFwibnVsbFwiKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9LFxuICBleGVjdXRlU3luYyhhcmdzLCBzY29wZSkge1xuICAgIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZXhlY3V0ZVN5bmMoYXJnLCBzY29wZSk7XG4gICAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJudWxsXCIpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbn07XG5fZ2xvYmFsLmNvdW50ID0gYXJyYXlSZWR1Y2VyRXhlY3V0b3IoXG4gIChhcmdzKSA9PiAoeyBhcnJheTogYXJnc1swXSB9KSxcbiAgKCkgPT4gMCxcbiAgKF8sIGNvdW50KSA9PiBjb3VudCArIDEsXG4gIGZyb21OdW1iZXJcbik7XG5fZ2xvYmFsLmNvdW50LmFyaXR5ID0gMTtcbl9nbG9iYWwuZGF0ZVRpbWUgPSBtYXBwZWRFeGVjdXRvcihcbiAgKGFyZ3MpID0+IGFyZ3MsXG4gIChfLCB2YWwpID0+IHZhbC50eXBlID09PSBcImRhdGV0aW1lXCIgPyB2YWwgOiB2YWwudHlwZSAhPT0gXCJzdHJpbmdcIiA/IE5VTExfVkFMVUUgOiBEYXRlVGltZS5wYXJzZVRvVmFsdWUodmFsLmRhdGEpXG4pO1xuX2dsb2JhbC5kYXRlVGltZS5hcml0eSA9IDE7XG5fZ2xvYmFsLmRlZmluZWQgPSBtYXBwZWRFeGVjdXRvcihcbiAgKGFyZ3MpID0+IGFyZ3MsXG4gIChfLCBpbm5lcikgPT4gaW5uZXIudHlwZSA9PT0gXCJudWxsXCIgPyBGQUxTRV9WQUxVRSA6IFRSVUVfVkFMVUVcbik7XG5fZ2xvYmFsLmRlZmluZWQuYXJpdHkgPSAxO1xuX2dsb2JhbC5pZGVudGl0eSA9IGNvbnN0YW50RXhlY3V0b3IoKF9hcmdzLCBzY29wZSkgPT4gZnJvbVN0cmluZyhzY29wZS5jb250ZXh0LmlkZW50aXR5KSk7XG5fZ2xvYmFsLmlkZW50aXR5LmFyaXR5ID0gMDtcbl9nbG9iYWwubGVuZ3RoID0gbWFwcGVkRXhlY3V0b3IoXG4gIChhcmdzKSA9PiBhcmdzLFxuICAoXywgaW5uZXIpID0+IGlubmVyLnR5cGUgPT09IFwic3RyaW5nXCIgPyBmcm9tTnVtYmVyKGNvdW50VVRGOChpbm5lci5kYXRhKSkgOiBpbm5lci50eXBlID09PSBcImFycmF5XCIgPyBmcm9tTnVtYmVyKGlubmVyLmRhdGEubGVuZ3RoKSA6IE5VTExfVkFMVUVcbik7XG5fZ2xvYmFsLmxlbmd0aC5hcml0eSA9IDE7XG5fZ2xvYmFsLnBhdGggPSBtYXBwZWRFeGVjdXRvcihcbiAgKGFyZ3MpID0+IGFyZ3MsXG4gIChfLCBpbm5lcikgPT4gaW5uZXIudHlwZSAhPT0gXCJzdHJpbmdcIiA/IE5VTExfVkFMVUUgOiBmcm9tUGF0aChuZXcgUGF0aChpbm5lci5kYXRhKSlcbik7XG5fZ2xvYmFsLnBhdGguYXJpdHkgPSAxO1xuX2dsb2JhbC5zdHJpbmcgPSBtYXBwZWRFeGVjdXRvcihcbiAgKGFyZ3MpID0+IGFyZ3MsXG4gIChfLCB2YWx1ZSkgPT4ge1xuICAgIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIGNhc2UgXCJkYXRldGltZVwiOlxuICAgICAgICByZXR1cm4gZnJvbVN0cmluZyhgJHt2YWx1ZS5kYXRhfWApO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICB9XG4pO1xuX2dsb2JhbC5zdHJpbmcuYXJpdHkgPSAxO1xuX2dsb2JhbC5yZWZlcmVuY2VzID0gbWFwcGVkRXhlY3V0b3IoXG4gIChhcmdzKSA9PiBbeyB0eXBlOiBcIlRoaXNcIiB9LCAuLi5hcmdzXSxcbiAgKF8sIHNjb3BlVmFsdWUsIC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBwYXRoU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgYXJncylcbiAgICAgIGlmIChwYXRoLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgIHBhdGhTZXQuYWRkKHBhdGguZGF0YSk7XG4gICAgICBlbHNlIGlmIChwYXRoLnR5cGUgPT09IFwiYXJyYXlcIilcbiAgICAgICAgZm9yIChjb25zdCBlbGVtIG9mIHBhdGguZGF0YSlcbiAgICAgICAgICB0eXBlb2YgZWxlbSA9PSBcInN0cmluZ1wiICYmIHBhdGhTZXQuYWRkKGVsZW0pO1xuICAgIHJldHVybiBwYXRoU2V0LnNpemUgPT09IDAgPyBGQUxTRV9WQUxVRSA6IGhhc1JlZmVyZW5jZShzY29wZVZhbHVlLCBwYXRoU2V0KSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfVxuKTtcbl9nbG9iYWwucmVmZXJlbmNlcy5hcml0eSA9IChjKSA9PiBjID49IDE7XG5fZ2xvYmFsLnJvdW5kID0gbWFwcGVkRXhlY3V0b3IoXG4gIChhcmdzKSA9PiBhcmdzLFxuICAoXywgdmFsdWUsIHByZWNWYWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgbnVtID0gdmFsdWUuZGF0YTtcbiAgICBsZXQgcHJlYyA9IDA7XG4gICAgaWYgKHByZWNWYWx1ZSkge1xuICAgICAgaWYgKHByZWNWYWx1ZS50eXBlICE9PSBcIm51bWJlclwiIHx8IHByZWNWYWx1ZS5kYXRhIDwgMCB8fCAhTnVtYmVyLmlzSW50ZWdlcihwcmVjVmFsdWUuZGF0YSkpXG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgcHJlYyA9IHByZWNWYWx1ZS5kYXRhO1xuICAgIH1cbiAgICByZXR1cm4gcHJlYyA9PT0gMCA/IG51bSA8IDAgPyBmcm9tTnVtYmVyKC1NYXRoLnJvdW5kKC1udW0pKSA6IGZyb21OdW1iZXIoTWF0aC5yb3VuZChudW0pKSA6IGZyb21OdW1iZXIoTnVtYmVyKG51bS50b0ZpeGVkKHByZWMpKSk7XG4gIH1cbik7XG5fZ2xvYmFsLnJvdW5kLmFyaXR5ID0gKGNvdW50KSA9PiBjb3VudCA+PSAxICYmIGNvdW50IDw9IDI7XG5fZ2xvYmFsLm5vdyA9IGNvbnN0YW50RXhlY3V0b3IoKF9hcmdzLCBzY29wZSkgPT4gZnJvbVN0cmluZyhzY29wZS5jb250ZXh0LnRpbWVzdGFtcC50b0lTT1N0cmluZygpKSk7XG5fZ2xvYmFsLm5vdy5hcml0eSA9IDA7XG5fZ2xvYmFsLmJvb3N0ID0gY29uc3RhbnRFeGVjdXRvcigoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWQgYm9vc3QgY2FsbFwiKTtcbn0pO1xuX2dsb2JhbC5ib29zdC5hcml0eSA9IDI7XG5fZ2xvYmFsLmxvd2VyID0gc3RyaW5nLmxvd2VyO1xuX2dsb2JhbC51cHBlciA9IHN0cmluZy51cHBlcjtcbmZ1bmN0aW9uIGNvdW50VVRGOChzdHIpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgY29kZSA+PSA1NTI5NiAmJiBjb2RlIDw9IDU2MzE5IHx8IGNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufVxuZnVuY3Rpb24gaGFzUmVmZXJlbmNlKHZhbHVlLCBwYXRoU2V0KSB7XG4gIHN3aXRjaCAoZ2V0VHlwZSh2YWx1ZSkpIHtcbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZSlcbiAgICAgICAgaWYgKGhhc1JlZmVyZW5jZSh2LCBwYXRoU2V0KSlcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICBpZiAodmFsdWUuX3JlZilcbiAgICAgICAgcmV0dXJuIHBhdGhTZXQuaGFzKHZhbHVlLl9yZWYpO1xuICAgICAgZm9yIChjb25zdCB2IG9mIE9iamVjdC52YWx1ZXModmFsdWUpKVxuICAgICAgICBpZiAoaGFzUmVmZXJlbmNlKHYsIHBhdGhTZXQpKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmNvbnN0IG1hdGggPSB7fTtcbm1hdGgubWluID0gYXJyYXlSZWR1Y2VyRXhlY3V0b3IoXG4gIChhcmdzKSA9PiAoeyBhcnJheTogYXJnc1swXSB9KSxcbiAgKCkgPT4ge1xuICB9LFxuICAoXywgbiwgaXRlbSkgPT4gaXRlbSA9PT0gbnVsbCA/IG4gOiB0eXBlb2YgaXRlbSAhPSBcIm51bWJlclwiID8gU1RPUF9JVEVSQVRPUiA6IG4gPT09IHZvaWQgMCB8fCBpdGVtIDwgbiA/IGl0ZW0gOiBuLFxuICAobikgPT4gbiA9PT0gdm9pZCAwID8gTlVMTF9WQUxVRSA6IGZyb21OdW1iZXIobilcbik7XG5tYXRoLm1pbi5hcml0eSA9IDE7XG5tYXRoLm1heCA9IGFycmF5UmVkdWNlckV4ZWN1dG9yKFxuICAoYXJncykgPT4gKHsgYXJyYXk6IGFyZ3NbMF0gfSksXG4gICgpID0+IHtcbiAgfSxcbiAgKF8sIG4sIGl0ZW0pID0+IGl0ZW0gPT09IG51bGwgPyBuIDogdHlwZW9mIGl0ZW0gIT0gXCJudW1iZXJcIiA/IFNUT1BfSVRFUkFUT1IgOiBuID09PSB2b2lkIDAgfHwgaXRlbSA+IG4gPyBpdGVtIDogbixcbiAgKG4pID0+IG4gPT09IHZvaWQgMCA/IE5VTExfVkFMVUUgOiBmcm9tTnVtYmVyKG4pXG4pO1xubWF0aC5tYXguYXJpdHkgPSAxO1xubWF0aC5zdW0gPSBhcnJheVJlZHVjZXJFeGVjdXRvcihcbiAgKGFyZ3MpID0+ICh7IGFycmF5OiBhcmdzWzBdIH0pLFxuICAoKSA9PiAwLFxuICAoXywgbiwgaXRlbSkgPT4gaXRlbSA9PT0gbnVsbCA/IG4gOiB0eXBlb2YgaXRlbSAhPSBcIm51bWJlclwiID8gU1RPUF9JVEVSQVRPUiA6IG4gKyBpdGVtLFxuICBmcm9tTnVtYmVyXG4pO1xubWF0aC5zdW0uYXJpdHkgPSAxO1xubWF0aC5hdmcgPSBhcnJheVJlZHVjZXJFeGVjdXRvcihcbiAgKGFyZ3MpID0+ICh7IGFycmF5OiBhcmdzWzBdIH0pLFxuICAoKSA9PiAoeyBjb3VudDogMCwgc3VtOiAwIH0pLFxuICAoXywgeyBjb3VudCwgc3VtIH0sIGl0ZW0pID0+IGl0ZW0gPT09IG51bGwgPyB7IGNvdW50LCBzdW0gfSA6IHR5cGVvZiBpdGVtICE9IFwibnVtYmVyXCIgPyBTVE9QX0lURVJBVE9SIDogeyBjb3VudDogY291bnQgKyAxLCBzdW06IHN1bSArIGl0ZW0gfSxcbiAgKHsgY291bnQsIHN1bSB9KSA9PiBjb3VudCA9PT0gMCA/IE5VTExfVkFMVUUgOiBmcm9tTnVtYmVyKHN1bSAvIGNvdW50KVxuKTtcbm1hdGguYXZnLmFyaXR5ID0gMTtcbmZ1bmN0aW9uIHBvcnRhYmxlVGV4dENvbnRlbnQodmFsdWUpIHtcbiAgaWYgKHZhbHVlLnR5cGUgPT09IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuIGJsb2NrVGV4dCh2YWx1ZS5kYXRhKTtcbiAgaWYgKHZhbHVlLnR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgIGNvbnN0IHRleHRzID0gYXJyYXlUZXh0KHZhbHVlLmRhdGEpO1xuICAgIGlmICh0ZXh0cy5sZW5ndGggPiAwKVxuICAgICAgcmV0dXJuIHRleHRzLmpvaW4oYFxuXG5gKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGFycmF5VGV4dCh2YWx1ZSwgcmVzdWx0ID0gW10pIHtcbiAgZm9yIChjb25zdCBibG9jayBvZiB2YWx1ZSlcbiAgICBpZiAoQXJyYXkuaXNBcnJheShibG9jaykpXG4gICAgICBhcnJheVRleHQoYmxvY2ssIHJlc3VsdCk7XG4gICAgZWxzZSBpZiAodHlwZW9mIGJsb2NrID09IFwib2JqZWN0XCIgJiYgYmxvY2spIHtcbiAgICAgIGNvbnN0IHRleHQyID0gYmxvY2tUZXh0KGJsb2NrKTtcbiAgICAgIHRleHQyICE9PSBudWxsICYmIHJlc3VsdC5wdXNoKHRleHQyKTtcbiAgICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBibG9ja1RleHQob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqLl90eXBlICE9IFwic3RyaW5nXCIpIHJldHVybiBudWxsO1xuICBjb25zdCBjaGlsZHJlbiA9IG9iai5jaGlsZHJlbjtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkgcmV0dXJuIG51bGw7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKVxuICAgIGNoaWxkICYmIHR5cGVvZiBjaGlsZCA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBjaGlsZC5fdHlwZSA9PSBcInN0cmluZ1wiICYmIGNoaWxkLl90eXBlID09PSBcInNwYW5cIiAmJiB0eXBlb2YgY2hpbGQudGV4dCA9PSBcInN0cmluZ1wiICYmIChyZXN1bHQgKz0gY2hpbGQudGV4dCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBwdCA9IHt9O1xucHQudGV4dCA9IG1hcHBlZEV4ZWN1dG9yKFxuICAoYXJncykgPT4gYXJncyxcbiAgZnVuY3Rpb24oXywgdmFsdWUpIHtcbiAgICBjb25zdCB0ZXh0MiA9IHBvcnRhYmxlVGV4dENvbnRlbnQodmFsdWUpO1xuICAgIHJldHVybiB0ZXh0MiA9PT0gbnVsbCA/IE5VTExfVkFMVUUgOiBmcm9tU3RyaW5nKHRleHQyKTtcbiAgfVxuKTtcbnB0LnRleHQuYXJpdHkgPSAxO1xuY29uc3QgcmVsZWFzZXMgPSB7fTtcbnJlbGVhc2VzLmFsbCA9IGFycmF5RXhlY3V0b3IoXG4gICgpID0+ICh7IGFycmF5OiB7IHR5cGU6IFwiRXZlcnl0aGluZ1wiIH0gfSksXG4gIGZ1bmN0aW9uKiAoXywgdmFsdWUpIHtcbiAgICB0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAmJiBcIl90eXBlXCIgaW4gdmFsdWUgJiYgdmFsdWUuX3R5cGUgPT09IFwic3lzdGVtLnJlbGVhc2VcIiAmJiAoeWllbGQgdmFsdWUpO1xuICB9XG4pO1xucmVsZWFzZXMuYWxsLmFyaXR5ID0gMDtcbmNvbnN0IHNhbml0eSA9IHt9O1xuc2FuaXR5LnByb2plY3RJZCA9IGNvbnN0YW50RXhlY3V0b3IoKF8sIHNjb3BlKSA9PiBzY29wZS5jb250ZXh0LnNhbml0eSA/IGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC5zYW5pdHkucHJvamVjdElkKSA6IE5VTExfVkFMVUUpO1xuc2FuaXR5LmRhdGFzZXQgPSBjb25zdGFudEV4ZWN1dG9yKChfLCBzY29wZSkgPT4gc2NvcGUuY29udGV4dC5zYW5pdHkgPyBmcm9tU3RyaW5nKHNjb3BlLmNvbnRleHQuc2FuaXR5LmRhdGFzZXQpIDogTlVMTF9WQUxVRSk7XG5zYW5pdHkudmVyc2lvbk9mID0gbWFwcGVkRXhlY3V0b3IoXG4gIChbdmFsdWVdKSA9PiBbdmFsdWUsIHsgdHlwZTogXCJUaGlzXCIgfV0sXG4gIChfLCB2YWx1ZSwgdmFsKSA9PiB7XG4gICAgaWYgKHZhbHVlLnR5cGUgIT09IFwic3RyaW5nXCIpIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IGJhc2VJZCA9IHZhbHVlLmRhdGE7XG4gICAgaWYgKHZhbC50eXBlICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiB2YWwuZGF0YS5faWQgIT0gXCJzdHJpbmdcIikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgaWYgKHZhbC5kYXRhLl9pZCA9PT0gYmFzZUlkKSByZXR1cm4gVFJVRV9WQUxVRTtcbiAgICBjb25zdCBjb21wb25lbnRzID0gdmFsLmRhdGEuX2lkLnNwbGl0KFwiLlwiKTtcbiAgICByZXR1cm4gY29tcG9uZW50cy5sZW5ndGggPj0gMiAmJiBjb21wb25lbnRzWzBdID09PSBcImRyYWZ0c1wiICYmIGNvbXBvbmVudHMuc2xpY2UoMSkuam9pbihcIi5cIikgPT09IGJhc2VJZCB8fCBjb21wb25lbnRzLmxlbmd0aCA+PSAzICYmIGNvbXBvbmVudHNbMF0gPT09IFwidmVyc2lvbnNcIiAmJiBjb21wb25lbnRzLnNsaWNlKDIpLmpvaW4oXCIuXCIpID09PSBiYXNlSWQgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH1cbik7XG5zYW5pdHkudmVyc2lvbk9mLmFyaXR5ID0gMTtcbnNhbml0eS5wYXJ0T2ZSZWxlYXNlID0gbWFwcGVkRXhlY3V0b3IoXG4gIChhcmdzKSA9PiBbYXJnc1swXSwgeyB0eXBlOiBcIlRoaXNcIiB9XSxcbiAgKF8sIHZhbHVlLCB2YWwpID0+IHtcbiAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJzdHJpbmdcIikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgYmFzZUlkID0gdmFsdWUuZGF0YTtcbiAgICBpZiAodmFsLnR5cGUgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHZhbC5kYXRhLl9pZCAhPSBcInN0cmluZ1wiKSByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBjb25zdCBjb21wb25lbnRzID0gdmFsLmRhdGEuX2lkLnNwbGl0KFwiLlwiKTtcbiAgICByZXR1cm4gY29tcG9uZW50cy5sZW5ndGggPj0gMyAmJiBjb21wb25lbnRzWzBdID09PSBcInZlcnNpb25zXCIgJiYgY29tcG9uZW50c1sxXSA9PT0gYmFzZUlkID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9XG4pO1xuc2FuaXR5LnBhcnRPZlJlbGVhc2UuYXJpdHkgPSAxO1xuY29uc3QgdGV4dCA9IHt9O1xudGV4dC5xdWVyeSA9IGNvbnN0YW50RXhlY3V0b3IoKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG59KTtcbnRleHQucXVlcnkuYXJpdHkgPSAxO1xuY29uc3QgQk0yNWsgPSAxLjI7XG5hc3luYyBmdW5jdGlvbiBldmFsdWF0ZVNjb3JlQXN5bmMobm9kZSwgc2NvcGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJPcENhbGxcIiAmJiBub2RlLm9wID09PSBcIm1hdGNoXCIpXG4gICAgcmV0dXJuIGV2YWx1YXRlTWF0Y2hTY29yZUFzeW5jKG5vZGUubGVmdCwgbm9kZS5yaWdodCwgc2NvcGUpO1xuICBpZiAobm9kZS50eXBlID09PSBcIkZ1bmNDYWxsXCIgJiYgbm9kZS5uYW1lID09PSBcImJvb3N0XCIpIHtcbiAgICBjb25zdCBpbm5lclNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZUFzeW5jKG5vZGUuYXJnc1swXSwgc2NvcGUpLCBib29zdCA9IGF3YWl0IGV4ZWN1dGVBc3luYyhub2RlLmFyZ3NbMV0sIHNjb3BlKTtcbiAgICByZXR1cm4gYm9vc3QudHlwZSA9PT0gXCJudW1iZXJcIiAmJiBpbm5lclNjb3JlID4gMCA/IGlubmVyU2NvcmUgKyBib29zdC5kYXRhIDogMDtcbiAgfVxuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJPclwiOiB7XG4gICAgICBjb25zdCBsZWZ0U2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlQXN5bmMobm9kZS5sZWZ0LCBzY29wZSksIHJpZ2h0U2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlQXN5bmMobm9kZS5yaWdodCwgc2NvcGUpO1xuICAgICAgcmV0dXJuIGxlZnRTY29yZSArIHJpZ2h0U2NvcmU7XG4gICAgfVxuICAgIGNhc2UgXCJBbmRcIjoge1xuICAgICAgY29uc3QgbGVmdFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZUFzeW5jKG5vZGUubGVmdCwgc2NvcGUpLCByaWdodFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZUFzeW5jKG5vZGUucmlnaHQsIHNjb3BlKTtcbiAgICAgIHJldHVybiBsZWZ0U2NvcmUgPT09IDAgfHwgcmlnaHRTY29yZSA9PT0gMCA/IDAgOiBsZWZ0U2NvcmUgKyByaWdodFNjb3JlO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBleGVjdXRlQXN5bmMobm9kZSwgc2NvcGUpO1xuICAgICAgcmV0dXJuIHJlcy50eXBlID09PSBcImJvb2xlYW5cIiAmJiByZXMuZGF0YSA9PT0gITAgPyAxIDogMDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGV2YWx1YXRlU2NvcmVTeW5jKG5vZGUsIHNjb3BlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IFwiT3BDYWxsXCIgJiYgbm9kZS5vcCA9PT0gXCJtYXRjaFwiKVxuICAgIHJldHVybiBldmFsdWF0ZU1hdGNoU2NvcmVTeW5jKG5vZGUubGVmdCwgbm9kZS5yaWdodCwgc2NvcGUpO1xuICBpZiAobm9kZS50eXBlID09PSBcIkZ1bmNDYWxsXCIgJiYgbm9kZS5uYW1lID09PSBcImJvb3N0XCIpIHtcbiAgICBjb25zdCBpbm5lclNjb3JlID0gZXZhbHVhdGVTY29yZVN5bmMobm9kZS5hcmdzWzBdLCBzY29wZSksIGJvb3N0ID0gZXhlY3V0ZVN5bmMobm9kZS5hcmdzWzFdLCBzY29wZSk7XG4gICAgcmV0dXJuIGJvb3N0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgaW5uZXJTY29yZSA+IDAgPyBpbm5lclNjb3JlICsgYm9vc3QuZGF0YSA6IDA7XG4gIH1cbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiT3JcIjoge1xuICAgICAgY29uc3QgbGVmdFNjb3JlID0gZXZhbHVhdGVTY29yZVN5bmMobm9kZS5sZWZ0LCBzY29wZSksIHJpZ2h0U2NvcmUgPSBldmFsdWF0ZVNjb3JlU3luYyhub2RlLnJpZ2h0LCBzY29wZSk7XG4gICAgICByZXR1cm4gbGVmdFNjb3JlICsgcmlnaHRTY29yZTtcbiAgICB9XG4gICAgY2FzZSBcIkFuZFwiOiB7XG4gICAgICBjb25zdCBsZWZ0U2NvcmUgPSBldmFsdWF0ZVNjb3JlU3luYyhub2RlLmxlZnQsIHNjb3BlKSwgcmlnaHRTY29yZSA9IGV2YWx1YXRlU2NvcmVTeW5jKG5vZGUucmlnaHQsIHNjb3BlKTtcbiAgICAgIHJldHVybiBsZWZ0U2NvcmUgPT09IDAgfHwgcmlnaHRTY29yZSA9PT0gMCA/IDAgOiBsZWZ0U2NvcmUgKyByaWdodFNjb3JlO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCByZXMgPSBleGVjdXRlU3luYyhub2RlLCBzY29wZSk7XG4gICAgICByZXR1cm4gcmVzLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIHJlcy5kYXRhID09PSAhMCA/IDEgOiAwO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZXZhbHVhdGVNYXRjaFNjb3JlU3luYyhsZWZ0LCByaWdodCwgc2NvcGUpIHtcbiAgY29uc3QgdGV4dDIgPSBleGVjdXRlU3luYyhsZWZ0LCBzY29wZSksIHBhdHRlcm4gPSBleGVjdXRlU3luYyhyaWdodCwgc2NvcGUpLCByZXN1bHQgPSBwcm9jZXNzTWF0Y2hTY29yZSh0ZXh0MiwgcGF0dGVybik7XG4gIGlmICh0eXBlb2YgcmVzdWx0ID09IFwibnVtYmVyXCIpIHJldHVybiByZXN1bHQ7XG4gIHRocm93IG5ldyBFcnJvcihcIkZvdW5kIHN5bmNocm9ub3VzIHZhbHVlIGluIG1hdGNoKClcIik7XG59XG5hc3luYyBmdW5jdGlvbiBldmFsdWF0ZU1hdGNoU2NvcmVBc3luYyhsZWZ0LCByaWdodCwgc2NvcGUpIHtcbiAgY29uc3QgdGV4dDIgPSBhd2FpdCBleGVjdXRlQXN5bmMobGVmdCwgc2NvcGUpLCBwYXR0ZXJuID0gYXdhaXQgZXhlY3V0ZUFzeW5jKHJpZ2h0LCBzY29wZSk7XG4gIHJldHVybiBwcm9jZXNzTWF0Y2hTY29yZSh0ZXh0MiwgcGF0dGVybik7XG59XG5mdW5jdGlvbiBwcm9jZXNzTWF0Y2hTY29yZSh0ZXh0MiwgcGF0dGVybikge1xuICBjb25zdCB0b2tlbnMgPSBnYXRoZXJUZXh0KHRleHQyLCAocGFydCkgPT4gbWF0Y2hUb2tlbml6ZShwYXJ0KSksIHRlcm1zID0gZ2F0aGVyVGV4dChwYXR0ZXJuLCAocGFydCkgPT4gbWF0Y2hQYXR0ZXJuUmVnZXgocGFydCkpLCBwcm9jZXNzID0gKHRva2VuczIsIHRlcm1zMikgPT4ge1xuICAgIGlmICghdGVybXMyLnN1Y2Nlc3MgfHwgdG9rZW5zMi5wYXJ0cy5sZW5ndGggPT09IDAgfHwgdGVybXMyLnBhcnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiAwO1xuICAgIGxldCBzY29yZSA9IDA7XG4gICAgZm9yIChjb25zdCByZSBvZiB0ZXJtczIucGFydHMpIHtcbiAgICAgIGNvbnN0IGZyZXEgPSB0b2tlbnMyLnBhcnRzLnJlZHVjZSgoYywgdG9rZW4pID0+IGMgKyAocmUudGVzdCh0b2tlbikgPyAxIDogMCksIDApO1xuICAgICAgc2NvcmUgKz0gZnJlcSAqIChCTTI1ayArIDEpIC8gKGZyZXEgKyBCTTI1ayk7XG4gICAgfVxuICAgIHJldHVybiBzY29yZTtcbiAgfTtcbiAgcmV0dXJuIFwidGhlblwiIGluIHRva2VucyB8fCBcInRoZW5cIiBpbiB0ZXJtcyA/IChhc3luYyAoKSA9PiBwcm9jZXNzKGF3YWl0IHRva2VucywgYXdhaXQgdGVybXMpKSgpIDogcHJvY2Vzcyh0b2tlbnMsIHRlcm1zKTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RPcmRlckFyZ3MoYXJncykge1xuICBjb25zdCBtYXBwZXJzID0gW10sIGRpcmVjdGlvbnMgPSBbXTtcbiAgZm9yIChsZXQgbWFwcGVyIG9mIGFyZ3MpIHtcbiAgICBsZXQgZGlyZWN0aW9uID0gXCJhc2NcIjtcbiAgICBtYXBwZXIudHlwZSA9PT0gXCJEZXNjXCIgPyAoZGlyZWN0aW9uID0gXCJkZXNjXCIsIG1hcHBlciA9IG1hcHBlci5iYXNlKSA6IG1hcHBlci50eXBlID09PSBcIkFzY1wiICYmIChtYXBwZXIgPSBtYXBwZXIuYmFzZSksIG1hcHBlcnMucHVzaChtYXBwZXIpLCBkaXJlY3Rpb25zLnB1c2goZGlyZWN0aW9uKTtcbiAgfVxuICByZXR1cm4geyBtYXBwZXJzLCBkaXJlY3Rpb25zIH07XG59XG5mdW5jdGlvbiBzb3J0QXJyYXkoYXV4LCBkaXJlY3Rpb25zKSB7XG4gIHJldHVybiBhdXguc29ydCgoYVR1cGxlLCBiVHVwbGUpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpcmVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBjID0gdG90YWxDb21wYXJlKGFUdXBsZVtpICsgMl0sIGJUdXBsZVtpICsgMl0pO1xuICAgICAgaWYgKGRpcmVjdGlvbnNbaV0gPT09IFwiZGVzY1wiICYmIChjID0gLWMpLCBjICE9PSAwKVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgcmV0dXJuIGFUdXBsZVsxXSAtIGJUdXBsZVsxXTtcbiAgfSksIGF1eC5tYXAoKHYpID0+IHZbMF0pO1xufVxuY29uc3QgcGlwZUZ1bmN0aW9ucyA9IHt9O1xucGlwZUZ1bmN0aW9ucy5vcmRlciA9IHtcbiAgZXhlY3V0ZVN5bmMoeyBiYXNlLCBhcmdzIH0sIHNjb3BlKSB7XG4gICAgY29uc3QgeyBtYXBwZXJzLCBkaXJlY3Rpb25zIH0gPSBleHRyYWN0T3JkZXJBcmdzKGFyZ3MpLCBhdXggPSBbXTtcbiAgICBsZXQgaWR4ID0gMDtcbiAgICBjb25zdCBuID0gZGlyZWN0aW9ucy5sZW5ndGg7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBiYXNlLmRhdGEpIHtcbiAgICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKGZyb21KUyh2YWx1ZSkpLCB0dXBsZSA9IFt2YWx1ZSwgaWR4XTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGV4ZWN1dGVTeW5jKG1hcHBlcnNbaV0sIG5ld1Njb3BlKTtcbiAgICAgICAgdHVwbGUucHVzaChyZXN1bHQuZGF0YSk7XG4gICAgICB9XG4gICAgICBhdXgucHVzaCh0dXBsZSksIGlkeCsrO1xuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5KHNvcnRBcnJheShhdXgsIGRpcmVjdGlvbnMpKTtcbiAgfSxcbiAgYXN5bmMgZXhlY3V0ZUFzeW5jKHsgYmFzZSwgYXJncyB9LCBzY29wZSkge1xuICAgIGNvbnN0IHsgbWFwcGVycywgZGlyZWN0aW9ucyB9ID0gZXh0cmFjdE9yZGVyQXJncyhhcmdzKSwgYXV4ID0gW107XG4gICAgbGV0IGlkeCA9IDA7XG4gICAgY29uc3QgbiA9IGRpcmVjdGlvbnMubGVuZ3RoO1xuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgYmFzZSkge1xuICAgICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQodmFsdWUpLCB0dXBsZSA9IFthd2FpdCB2YWx1ZS5nZXQoKSwgaWR4XTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4ZWN1dGVBc3luYyhtYXBwZXJzW2ldLCBuZXdTY29wZSk7XG4gICAgICAgIHR1cGxlLnB1c2goYXdhaXQgcmVzdWx0LmdldCgpKTtcbiAgICAgIH1cbiAgICAgIGF1eC5wdXNoKHR1cGxlKSwgaWR4Kys7XG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXkoc29ydEFycmF5KGF1eCwgZGlyZWN0aW9ucykpO1xuICB9XG59O1xucGlwZUZ1bmN0aW9ucy5vcmRlci5hcml0eSA9IChjb3VudCkgPT4gY291bnQgPj0gMTtcbnBpcGVGdW5jdGlvbnMuc2NvcmUgPSB7XG4gIGFzeW5jIGV4ZWN1dGVBc3luYyh7IGJhc2UsIGFyZ3MgfSwgc2NvcGUpIHtcbiAgICBjb25zdCB1bmtub3duID0gW10sIHNjb3JlZCA9IFtdO1xuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgYmFzZSkge1xuICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdW5rbm93bi5wdXNoKGF3YWl0IHZhbHVlLmdldCgpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZCh2YWx1ZSk7XG4gICAgICBsZXQgdmFsdWVTY29yZSA9IHR5cGVvZiB2YWx1ZS5kYXRhLl9zY29yZSA9PSBcIm51bWJlclwiID8gdmFsdWUuZGF0YS5fc2NvcmUgOiAwO1xuICAgICAgZm9yIChjb25zdCBhcmcgb2YgYXJncylcbiAgICAgICAgdmFsdWVTY29yZSArPSBhd2FpdCBldmFsdWF0ZVNjb3JlQXN5bmMoYXJnLCBuZXdTY29wZSk7XG4gICAgICBjb25zdCBuZXdPYmplY3QgPSBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZS5kYXRhLCB7IF9zY29yZTogdmFsdWVTY29yZSB9KTtcbiAgICAgIHNjb3JlZC5wdXNoKG5ld09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiBzY29yZWQuc29ydCgoYSwgYikgPT4gYi5fc2NvcmUgLSBhLl9zY29yZSksIGZyb21KUyhzY29yZWQpO1xuICB9LFxuICBleGVjdXRlU3luYyh7IGJhc2UsIGFyZ3MgfSwgc2NvcGUpIHtcbiAgICBjb25zdCBzY29yZWQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGJhc2UuZGF0YSkge1xuICAgICAgaWYgKGdldFR5cGUodmFsdWUpICE9PSBcIm9iamVjdFwiKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IHZhbHVlT2JqID0gdmFsdWUsIG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKGZyb21KUyh2YWx1ZSkpO1xuICAgICAgbGV0IHZhbHVlU2NvcmUgPSB0eXBlb2YgdmFsdWVPYmouX3Njb3JlID09IFwibnVtYmVyXCIgPyB2YWx1ZU9iai5fc2NvcmUgOiAwO1xuICAgICAgZm9yIChjb25zdCBhcmcgb2YgYXJncylcbiAgICAgICAgdmFsdWVTY29yZSArPSBldmFsdWF0ZVNjb3JlU3luYyhhcmcsIG5ld1Njb3BlKTtcbiAgICAgIGNvbnN0IG5ld09iamVjdCA9IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlT2JqLCB7IF9zY29yZTogdmFsdWVTY29yZSB9KTtcbiAgICAgIHNjb3JlZC5wdXNoKG5ld09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiBzY29yZWQuc29ydCgoYSwgYikgPT4gYi5fc2NvcmUgLSBhLl9zY29yZSksIGZyb21BcnJheShzY29yZWQpO1xuICB9XG59O1xucGlwZUZ1bmN0aW9ucy5zY29yZS5hcml0eSA9IChjb3VudCkgPT4gY291bnQgPj0gMTtcbmNvbnN0IG5hbWVzcGFjZXMgPSB7XG4gIGdsb2JhbDogX2dsb2JhbCxcbiAgc3RyaW5nLFxuICBhcnJheSxcbiAgcHQsXG4gIGRlbHRhLFxuICBkaWZmLFxuICBzYW5pdHksXG4gIG1hdGgsXG4gIGRhdGVUaW1lLFxuICByZWxlYXNlcyxcbiAgdGV4dCxcbiAgZ2VvLFxuICBkb2N1bWVudHNcbn07XG5jbGFzcyBNYXJrUHJvY2Vzc29yIHtcbiAgc3RyaW5nO1xuICBtYXJrcztcbiAgaW5kZXg7XG4gIHBhcnNlT3B0aW9ucztcbiAgYWxsb3dCb29zdCA9ICExO1xuICBjb25zdHJ1Y3RvcihzdHJpbmcyLCBtYXJrcywgcGFyc2VPcHRpb25zKSB7XG4gICAgdGhpcy5zdHJpbmcgPSBzdHJpbmcyLCB0aGlzLm1hcmtzID0gbWFya3MsIHRoaXMuaW5kZXggPSAwLCB0aGlzLnBhcnNlT3B0aW9ucyA9IHBhcnNlT3B0aW9ucztcbiAgfVxuICBoYXNNYXJrKHBvcyA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleCArIHBvcyA8IHRoaXMubWFya3MubGVuZ3RoO1xuICB9XG4gIGdldE1hcmsocG9zID0gMCkge1xuICAgIHJldHVybiB0aGlzLm1hcmtzW3RoaXMuaW5kZXggKyBwb3NdO1xuICB9XG4gIHNoaWZ0KCkge1xuICAgIHRoaXMuaW5kZXggKz0gMTtcbiAgfVxuICBwcm9jZXNzKHZpc2l0b3IpIHtcbiAgICBjb25zdCBtYXJrID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4XTtcbiAgICB0aGlzLnNoaWZ0KCk7XG4gICAgY29uc3QgZnVuYyA9IHZpc2l0b3JbbWFyay5uYW1lXTtcbiAgICBpZiAoIWZ1bmMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gaGFuZGxlcjogJHttYXJrLm5hbWV9YCk7XG4gICAgcmV0dXJuIGZ1bmMuY2FsbCh2aXNpdG9yLCB0aGlzLCBtYXJrKTtcbiAgfVxuICBwcm9jZXNzU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnNoaWZ0KCksIHRoaXMucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICB9XG4gIHByb2Nlc3NTdHJpbmdFbmQoKSB7XG4gICAgY29uc3QgcHJldiA9IHRoaXMubWFya3NbdGhpcy5pbmRleCAtIDFdLCBjdXJyID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4XTtcbiAgICByZXR1cm4gdGhpcy5zaGlmdCgpLCB0aGlzLnN0cmluZy5zbGljZShwcmV2LnBvc2l0aW9uLCBjdXJyLnBvc2l0aW9uKTtcbiAgfVxuICBzbGljZShsZW4pIHtcbiAgICBjb25zdCBwb3MgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXhdLnBvc2l0aW9uO1xuICAgIHJldHVybiB0aGlzLnN0cmluZy5zbGljZShwb3MsIHBvcyArIGxlbik7XG4gIH1cbn1cbmNvbnN0IFdTID0gL14oW1xcdFxcblxcdlxcZlxcciBcXHUwMDg1XFx1MDBBMF18KFxcL1xcL1teXFxuXSpcXG4pKSsvLCBOVU0gPSAvXlxcZCsvLCBJREVOVCA9IC9eW2EtekEtWl9dW2EtekEtWl8wLTldKi87XG5mdW5jdGlvbiBwYXJzZSQxKHN0cikge1xuICBsZXQgcG9zID0gMDtcbiAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgbGV0IHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gIHJldHVybiByZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiID8gcmVzdWx0IDogKHBvcyA9IHNraXBXUyhzdHIsIHJlc3VsdC5wb3NpdGlvbiksIHBvcyAhPT0gc3RyLmxlbmd0aCA/IChyZXN1bHQuZmFpbFBvc2l0aW9uICYmIChwb3MgPSByZXN1bHQuZmFpbFBvc2l0aW9uIC0gMSksIHsgdHlwZTogXCJlcnJvclwiLCBtZXNzYWdlOiBcIlVuZXhwZWN0ZWQgZW5kIG9mIHF1ZXJ5XCIsIHBvc2l0aW9uOiBwb3MgfSkgOiAoZGVsZXRlIHJlc3VsdC5wb3NpdGlvbiwgZGVsZXRlIHJlc3VsdC5mYWlsUG9zaXRpb24sIHJlc3VsdCkpO1xufVxuZnVuY3Rpb24gcGFyc2VFeHByKHN0ciwgcG9zLCBsZXZlbCkge1xuICBsZXQgc3RhcnRQb3MgPSBwb3MsIHRva2VuID0gc3RyW3Bvc10sIG1hcmtzO1xuICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgY2FzZSBcIitcIjoge1xuICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIHBvcyArIDEpLCAxMCk7XG4gICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgIG1hcmtzID0gW3sgbmFtZTogXCJwb3NcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLmNvbmNhdChyaHMubWFya3MpLCBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIi1cIjoge1xuICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIHBvcyArIDEpLCA4KTtcbiAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgbWFya3MgPSBbeyBuYW1lOiBcIm5lZ1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0uY29uY2F0KHJocy5tYXJrcyksIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiKFwiOiB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VHcm91cE9yVHVwbGUoc3RyLCBwb3MpO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICBwb3MgPSByZXN1bHQucG9zaXRpb24sIG1hcmtzID0gcmVzdWx0Lm1hcmtzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCIhXCI6IHtcbiAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgMTApO1xuICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwibm90XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKSwgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJ7XCI6IHtcbiAgICAgIGxldCByZXN1bHQgPSBwYXJzZU9iamVjdChzdHIsIHBvcyk7XG4gICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJlc3VsdDtcbiAgICAgIG1hcmtzID0gcmVzdWx0Lm1hcmtzLCBwb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIltcIjpcbiAgICAgIGlmIChtYXJrcyA9IFt7IG5hbWU6IFwiYXJyYXlcIiwgcG9zaXRpb246IHBvcyB9XSwgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSksIHN0cltwb3NdICE9PSBcIl1cIilcbiAgICAgICAgZm9yICg7IDsgKSB7XG4gICAgICAgICAgc3RyLnNsaWNlKHBvcywgcG9zICsgMykgPT09IFwiLi4uXCIgJiYgKG1hcmtzLnB1c2goeyBuYW1lOiBcImFycmF5X3NwbGF0XCIsIHBvc2l0aW9uOiBwb3MgfSksIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDMpKTtcbiAgICAgICAgICBsZXQgcmVzID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgICAgICBpZiAocmVzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJlcztcbiAgICAgICAgICBpZiAobWFya3MgPSBtYXJrcy5jb25jYXQocmVzLm1hcmtzKSwgcG9zID0gcmVzLnBvc2l0aW9uLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MpLCBzdHJbcG9zXSAhPT0gXCIsXCIgfHwgKHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpLCBzdHJbcG9zXSA9PT0gXCJdXCIpKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgaWYgKHN0cltwb3NdID09PSBcIl1cIilcbiAgICAgICAgcG9zKyssIG1hcmtzLnB1c2goeyBuYW1lOiBcImFycmF5X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIG1lc3NhZ2U6ICdFeHBlY3RlZCBcIl1cIiBhZnRlciBhcnJheSBleHByZXNzaW9uJywgcG9zaXRpb246IHBvcyB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIidcIjpcbiAgICBjYXNlICdcIic6IHtcbiAgICAgIGxldCByZXN1bHQgPSBwYXJzZVN0cmluZyhzdHIsIHBvcyk7XG4gICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJlc3VsdDtcbiAgICAgIG1hcmtzID0gcmVzdWx0Lm1hcmtzLCBwb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIl5cIjoge1xuICAgICAgZm9yIChwb3MrKywgbWFya3MgPSBbXTsgc3RyW3Bvc10gPT09IFwiLlwiICYmIHN0cltwb3MgKyAxXSA9PT0gXCJeXCI7IClcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwiZGJscGFyZW50XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zICs9IDI7XG4gICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJwYXJlbnRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJAXCI6XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwidGhpc1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0sIHBvcysrO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIipcIjpcbiAgICAgIG1hcmtzID0gW3sgbmFtZTogXCJldmVyeXRoaW5nXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XSwgcG9zKys7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiJFwiOiB7XG4gICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zICsgMSwgSURFTlQpO1xuICAgICAgaWRlbnRMZW4gJiYgKHBvcyArPSAxICsgaWRlbnRMZW4sIG1hcmtzID0gW1xuICAgICAgICB7IG5hbWU6IFwicGFyYW1cIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0sXG4gICAgICAgIHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgKyAxIH0sXG4gICAgICAgIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyB9XG4gICAgICBdKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBsZXQgbnVtTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgTlVNKTtcbiAgICAgIGlmIChudW1MZW4pIHtcbiAgICAgICAgcG9zICs9IG51bUxlbjtcbiAgICAgICAgbGV0IG5hbWUgPSBcImludGVnZXJcIjtcbiAgICAgICAgaWYgKHN0cltwb3NdID09PSBcIi5cIikge1xuICAgICAgICAgIGxldCBmcmFjTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcyArIDEsIE5VTSk7XG4gICAgICAgICAgZnJhY0xlbiAmJiAobmFtZSA9IFwiZmxvYXRcIiwgcG9zICs9IDEgKyBmcmFjTGVuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiZVwiIHx8IHN0cltwb3NdID09PSBcIkVcIikge1xuICAgICAgICAgIG5hbWUgPSBcInNjaVwiLCBwb3MrKywgKHN0cltwb3NdID09PSBcIitcIiB8fCBzdHJbcG9zXSA9PT0gXCItXCIpICYmIHBvcysrO1xuICAgICAgICAgIGxldCBleHBMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBOVU0pO1xuICAgICAgICAgIGlmICghZXhwTGVuKSByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIG1lc3NhZ2U6IFwiRXhwb25lbnQgbXVzdCBiZSBhIG51bWJlclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICAgICAgcG9zICs9IGV4cExlbjtcbiAgICAgICAgfVxuICAgICAgICBtYXJrcyA9IFtcbiAgICAgICAgICB7IG5hbWUsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICAgIHsgbmFtZTogbmFtZSArIFwiX2VuZFwiLCBwb3NpdGlvbjogcG9zIH1cbiAgICAgICAgXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBJREVOVCk7XG4gICAgICBpZiAoaWRlbnRMZW4pIHtcbiAgICAgICAgc3dpdGNoIChwb3MgKz0gaWRlbnRMZW4sIHN0cltwb3NdKSB7XG4gICAgICAgICAgY2FzZSBcIjpcIjpcbiAgICAgICAgICBjYXNlIFwiKFwiOiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VGdW5jQ2FsbChzdHIsIHN0YXJ0UG9zLCBwb3MpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBtYXJrcyA9IHJlc3VsdC5tYXJrcywgcG9zID0gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBtYXJrcyA9IFtcbiAgICAgICAgICAgICAgeyBuYW1lOiBcInRoaXNfYXR0clwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcbiAgICAgICAgICAgICAgeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICAgICAgICB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFtYXJrcylcbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIG1lc3NhZ2U6IFwiRXhwZWN0ZWQgZXhwcmVzc2lvblwiLCBwb3NpdGlvbjogcG9zIH07XG4gIGxldCBsaHNMZXZlbCA9IDEyLCB0cmF2O1xuICBsb29wOiBmb3IgKDsgOyApIHtcbiAgICBsZXQgaW5uZXJQb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgIGlmIChpbm5lclBvcyA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgcG9zID0gaW5uZXJQb3M7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHRyYXYgPSBwYXJzZVRyYXZlcnNhbChzdHIsIGlubmVyUG9zKSwgdHJhdi50eXBlID09PSBcInN1Y2Nlc3NcIikge1xuICAgICAgZm9yIChtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJ0cmF2ZXJzZVwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7IHRyYXYudHlwZSA9PT0gXCJzdWNjZXNzXCI7IClcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQodHJhdi5tYXJrcyksIHBvcyA9IHRyYXYucG9zaXRpb24sIHRyYXYgPSBwYXJzZVRyYXZlcnNhbChzdHIsIHNraXBXUyhzdHIsIHBvcykpO1xuICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwidHJhdmVyc2FsX2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHN3aXRjaCAoc3RyW2lubmVyUG9zXSkge1xuICAgICAgY2FzZSBcIj1cIjoge1xuICAgICAgICBzd2l0Y2ggKHN0cltpbm5lclBvcyArIDFdKSB7XG4gICAgICAgICAgY2FzZSBcIj5cIjoge1xuICAgICAgICAgICAgaWYgKGxldmVsID4gMSB8fCBsaHNMZXZlbCA8PSAxKSBicmVhayBsb29wO1xuICAgICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIDEpO1xuICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJwYWlyXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIj1cIjoge1xuICAgICAgICAgICAgaWYgKGxldmVsID4gNCB8fCBsaHNMZXZlbCA8PSA0KSBicmVhayBsb29wO1xuICAgICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIDUpO1xuICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJjb21wXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgbWFya3MucHVzaCh7IG5hbWU6IFwib3BcIiwgcG9zaXRpb246IGlubmVyUG9zIH0sIHsgbmFtZTogXCJvcF9lbmRcIiwgcG9zaXRpb246IGlubmVyUG9zICsgMiB9KSwgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiK1wiOiB7XG4gICAgICAgIGlmIChsZXZlbCA+IDYgfHwgbGhzTGV2ZWwgPCA2KSBicmVhayBsb29wO1xuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKSwgNyk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJhZGRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gNjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiLVwiOiB7XG4gICAgICAgIGlmIChsZXZlbCA+IDYgfHwgbGhzTGV2ZWwgPCA2KSBicmVhayBsb29wO1xuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKSwgNyk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJzdWJcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gNjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiKlwiOiB7XG4gICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSA9PT0gXCIqXCIpIHtcbiAgICAgICAgICBpZiAobGV2ZWwgPiA4IHx8IGxoc0xldmVsIDw9IDgpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IHJoczIgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCA4KTtcbiAgICAgICAgICBpZiAocmhzMi50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHMyO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJoczIubWFya3MpLCBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJwb3dcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSByaHMyLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxldmVsID4gNyB8fCBsaHNMZXZlbCA8IDcpIGJyZWFrIGxvb3A7XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCA4KTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcIm11bFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSA3O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCIvXCI6IHtcbiAgICAgICAgaWYgKGxldmVsID4gNyB8fCBsaHNMZXZlbCA8IDcpIGJyZWFrIGxvb3A7XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCA4KTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImRpdlwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSA3O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCIlXCI6IHtcbiAgICAgICAgaWYgKGxldmVsID4gNyB8fCBsaHNMZXZlbCA8IDcpIGJyZWFrIGxvb3A7XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCA4KTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcIm1vZFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSA3O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCI8XCI6XG4gICAgICBjYXNlIFwiPlwiOiB7XG4gICAgICAgIGlmIChsZXZlbCA+IDQgfHwgbGhzTGV2ZWwgPD0gNCkgYnJlYWsgbG9vcDtcbiAgICAgICAgbGV0IG5leHRQb3MgPSBpbm5lclBvcyArIDE7XG4gICAgICAgIHN0cltuZXh0UG9zXSA9PT0gXCI9XCIgJiYgbmV4dFBvcysrO1xuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgbmV4dFBvcyksIDUpO1xuICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9wXCIsIHBvc2l0aW9uOiBpbm5lclBvcyB9LCB7IG5hbWU6IFwib3BfZW5kXCIsIHBvc2l0aW9uOiBuZXh0UG9zIH0pLCBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gNDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwifFwiOiB7XG4gICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSA9PT0gXCJ8XCIpIHtcbiAgICAgICAgICBpZiAobGV2ZWwgPiAyIHx8IGxoc0xldmVsIDwgMikgYnJlYWsgbG9vcDtcbiAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgMyk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwib3JcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobGV2ZWwgPiAxMSB8fCBsaHNMZXZlbCA8IDExKSBicmVhayBsb29wO1xuICAgICAgICAgIGxldCBpZGVudFBvcyA9IHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIGlkZW50UG9zLCBJREVOVCk7XG4gICAgICAgICAgaWYgKCFpZGVudExlbikgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBtZXNzYWdlOiBcIkV4cGVjdGVkIGlkZW50aWZpZXJcIiwgcG9zaXRpb246IGlkZW50UG9zIH07XG4gICAgICAgICAgaWYgKHBvcyA9IGlkZW50UG9zICsgaWRlbnRMZW4sIHN0cltwb3NdID09PSBcIihcIiB8fCBzdHJbcG9zXSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZUZ1bmNDYWxsKHN0ciwgaWRlbnRQb3MsIHBvcyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJlc3VsdC5tYXJrcyksIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInBpcGVjYWxsXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gcmVzdWx0LnBvc2l0aW9uLCBsaHNMZXZlbCA9IDExO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCImXCI6IHtcbiAgICAgICAgaWYgKHN0cltpbm5lclBvcyArIDFdICE9IFwiJlwiIHx8IGxldmVsID4gMyB8fCBsaHNMZXZlbCA8IDMpIGJyZWFrIGxvb3A7XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCA0KTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImFuZFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSAzO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCIhXCI6IHtcbiAgICAgICAgaWYgKHN0cltpbm5lclBvcyArIDFdICE9PSBcIj1cIiB8fCBsZXZlbCA+IDQgfHwgbGhzTGV2ZWwgPD0gNCkgYnJlYWsgbG9vcDtcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIDUpO1xuICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9wXCIsIHBvc2l0aW9uOiBpbm5lclBvcyB9LCB7IG5hbWU6IFwib3BfZW5kXCIsIHBvc2l0aW9uOiBpbm5lclBvcyArIDIgfSksIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSA0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkXCI6IHtcbiAgICAgICAgaWYgKHN0ci5zbGljZShpbm5lclBvcywgaW5uZXJQb3MgKyA0KSAhPT0gXCJkZXNjXCIgfHwgbGV2ZWwgPiA0IHx8IGxoc0xldmVsIDwgNCkgYnJlYWsgbG9vcDtcbiAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiZGVzY1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IGlubmVyUG9zICsgNCwgbGhzTGV2ZWwgPSA0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJhXCI6IHtcbiAgICAgICAgaWYgKHN0ci5zbGljZShpbm5lclBvcywgaW5uZXJQb3MgKyAzKSAhPT0gXCJhc2NcIiB8fCBsZXZlbCA+IDQgfHwgbGhzTGV2ZWwgPCA0KSBicmVhayBsb29wO1xuICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJhc2NcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSBpbm5lclBvcyArIDMsIGxoc0xldmVsID0gNDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzd2l0Y2ggKHBhcnNlUmVnZXhTdHIoc3RyLCBpbm5lclBvcywgSURFTlQpKSB7XG4gICAgICAgICAgY2FzZSBcImluXCI6IHtcbiAgICAgICAgICAgIGlmIChsZXZlbCA+IDQgfHwgbGhzTGV2ZWwgPD0gNCkgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIGlubmVyUG9zICsgMik7XG4gICAgICAgICAgICBsZXQgaXNHcm91cCA9ICExO1xuICAgICAgICAgICAgc3RyW3Bvc10gPT09IFwiKFwiICYmIChpc0dyb3VwID0gITAsIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpKTtcbiAgICAgICAgICAgIGxldCByYW5nZVBvcyA9IHBvcywgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCA1KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgaWYgKHBvcyA9IHNraXBXUyhzdHIsIHJlc3VsdC5wb3NpdGlvbiksIHN0cltwb3NdID09PSBcIi5cIiAmJiBzdHJbcG9zICsgMV0gPT09IFwiLlwiKSB7XG4gICAgICAgICAgICAgIGxldCB0eXBlID0gXCJpbmNfcmFuZ2VcIjtcbiAgICAgICAgICAgICAgc3RyW3BvcyArIDJdID09PSBcIi5cIiA/ICh0eXBlID0gXCJleGNfcmFuZ2VcIiwgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMykpIDogcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMik7XG4gICAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDUpO1xuICAgICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiaW5fcmFuZ2VcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBtYXJrcyA9IG1hcmtzLmNvbmNhdCh7IG5hbWU6IHR5cGUsIHBvc2l0aW9uOiByYW5nZVBvcyB9LCByZXN1bHQubWFya3MsIHJocy5tYXJrcyksIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJjb21wXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgbWFya3MucHVzaCh7IG5hbWU6IFwib3BcIiwgcG9zaXRpb246IGlubmVyUG9zIH0sIHsgbmFtZTogXCJvcF9lbmRcIiwgcG9zaXRpb246IGlubmVyUG9zICsgMiB9KSwgbWFya3MgPSBtYXJrcy5jb25jYXQocmVzdWx0Lm1hcmtzKTtcbiAgICAgICAgICAgIGlmIChpc0dyb3VwKSB7XG4gICAgICAgICAgICAgIGlmIChwb3MgPSBza2lwV1Moc3RyLCBwb3MpLCBzdHJbcG9zXSAhPT0gXCIpXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBtZXNzYWdlOiAnRXhwZWN0ZWQgXCIpXCIgaW4gZ3JvdXAnLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGhzTGV2ZWwgPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJtYXRjaFwiOiB7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPiA0IHx8IGxoc0xldmVsIDw9IDQpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyA1KSwgNSk7XG4gICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImNvbXBcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJvcFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgfSwgeyBuYW1lOiBcIm9wX2VuZFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgKyA1IH0pLCBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICBsZXQgZmFpbFBvc2l0aW9uID0gdHJhdj8udHlwZSA9PT0gXCJlcnJvclwiICYmIHRyYXYucG9zaXRpb247XG4gIHJldHVybiB7IHR5cGU6IFwic3VjY2Vzc1wiLCBtYXJrcywgcG9zaXRpb246IHBvcywgZmFpbFBvc2l0aW9uIH07XG59XG5mdW5jdGlvbiBwYXJzZUdyb3VwT3JUdXBsZShzdHIsIHBvcykge1xuICBjb25zdCBzdGFydFBvcyA9IHBvcztcbiAgbGV0IG1hcmtzLCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgMCk7XG4gIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICBzd2l0Y2ggKHBvcyA9IHNraXBXUyhzdHIsIHJocy5wb3NpdGlvbiksIHN0cltwb3NdKSB7XG4gICAgY2FzZSBcIixcIjoge1xuICAgICAgZm9yIChtYXJrcyA9IFt7IG5hbWU6IFwidHVwbGVcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLmNvbmNhdChyaHMubWFya3MpLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTsgOyApIHtcbiAgICAgICAgaWYgKHJocyA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCksIHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgIGlmIChtYXJrcy5wdXNoKC4uLnJocy5tYXJrcyksIHBvcyA9IHNraXBXUyhzdHIsIHJocy5wb3NpdGlvbiksIHN0cltwb3NdICE9PSBcIixcIikgYnJlYWs7XG4gICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0cltwb3NdICE9PSBcIilcIilcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBtZXNzYWdlOiAnRXhwZWN0ZWQgXCIpXCIgYWZ0ZXIgdHVwbGUgZXhwcmVzc2lvbicsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgIHBvcysrLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJ0dXBsZV9lbmRcIiwgcG9zaXRpb246IHBvcyB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiKVwiOiB7XG4gICAgICBwb3MrKywgbWFya3MgPSBbeyBuYW1lOiBcImdyb3VwXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBtZXNzYWdlOiBgVW5leHBlY3RlZCBjaGFyYWN0ZXIgXCIke3N0cltwb3NdfVwiYCwgcG9zaXRpb246IHBvcyB9O1xuICB9XG4gIHJldHVybiB7IHR5cGU6IFwic3VjY2Vzc1wiLCBtYXJrcywgcG9zaXRpb246IHBvcyB9O1xufVxuZnVuY3Rpb24gcGFyc2VUcmF2ZXJzYWwoc3RyLCBwb3MpIHtcbiAgbGV0IHN0YXJ0UG9zID0gcG9zO1xuICBzd2l0Y2ggKHN0cltwb3NdKSB7XG4gICAgY2FzZSBcIi5cIjoge1xuICAgICAgaWYgKHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpLCBzdHJbcG9zXSA9PT0gXCIoXCIpXG4gICAgICAgIHJldHVybiBwYXJzZUdyb3VwT3JUdXBsZShzdHIsIHBvcyk7XG4gICAgICBsZXQgaWRlbnRTdGFydCA9IHBvcywgaWRlbnRMZW4yID0gcGFyc2VSZWdleChzdHIsIHBvcywgSURFTlQpO1xuICAgICAgcmV0dXJuIGlkZW50TGVuMiA/IChwb3MgKz0gaWRlbnRMZW4yLCB7XG4gICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICBtYXJrczogW1xuICAgICAgICAgIHsgbmFtZTogXCJhdHRyX2FjY2Vzc1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcbiAgICAgICAgICB7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IGlkZW50U3RhcnQgfSxcbiAgICAgICAgICB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfVxuICAgICAgICBdLFxuICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICB9KSA6IHsgdHlwZTogXCJlcnJvclwiLCBtZXNzYWdlOiAnRXhwZWN0ZWQgaWRlbnRpZmllciBhZnRlciBcIi5cIicsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICB9XG4gICAgY2FzZSBcIi1cIjpcbiAgICAgIGlmIChzdHJbcG9zICsgMV0gIT09IFwiPlwiKVxuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIG1lc3NhZ2U6ICdFeHBlY3RlZCBcIj5cIiBpbiByZWZlcmVuY2UnLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICBsZXQgbWFya3MgPSBbeyBuYW1lOiBcImRlcmVmXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XTtcbiAgICAgIHBvcyArPSAyO1xuICAgICAgbGV0IGlkZW50UG9zID0gc2tpcFdTKHN0ciwgcG9zKSwgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgaWRlbnRQb3MsIElERU5UKTtcbiAgICAgIHJldHVybiBpZGVudExlbiAmJiAocG9zID0gaWRlbnRQb3MgKyBpZGVudExlbiwgbWFya3MucHVzaChcbiAgICAgICAgeyBuYW1lOiBcImRlcmVmX2F0dHJcIiwgcG9zaXRpb246IGlkZW50UG9zIH0sXG4gICAgICAgIHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogaWRlbnRQb3MgfSxcbiAgICAgICAgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH1cbiAgICAgICkpLCB7XG4gICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICBtYXJrcyxcbiAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgfTtcbiAgICBjYXNlIFwiW1wiOiB7XG4gICAgICBpZiAocG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSksIHN0cltwb3NdID09PSBcIl1cIilcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICBtYXJrczogW3sgbmFtZTogXCJhcnJheV9wb3N0Zml4XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XSxcbiAgICAgICAgICBwb3NpdGlvbjogcG9zICsgMVxuICAgICAgICB9O1xuICAgICAgbGV0IHJhbmdlUG9zID0gcG9zLCByZXN1bHQgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICBpZiAocG9zID0gc2tpcFdTKHN0ciwgcmVzdWx0LnBvc2l0aW9uKSwgc3RyW3Bvc10gPT09IFwiLlwiICYmIHN0cltwb3MgKyAxXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgbGV0IHR5cGUgPSBcImluY19yYW5nZVwiO1xuICAgICAgICBzdHJbcG9zICsgMl0gPT09IFwiLlwiID8gKHR5cGUgPSBcImV4Y19yYW5nZVwiLCBwb3MgKz0gMykgOiBwb3MgKz0gMiwgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgIHJldHVybiByaHMudHlwZSA9PT0gXCJlcnJvclwiID8gcmhzIDogKHBvcyA9IHNraXBXUyhzdHIsIHJocy5wb3NpdGlvbiksIHN0cltwb3NdICE9PSBcIl1cIiA/IHsgdHlwZTogXCJlcnJvclwiLCBtZXNzYWdlOiAnRXhwZWN0ZWQgXCJdXCIgYWZ0ZXIgYXJyYXkgZXhwcmVzc2lvbicsIHBvc2l0aW9uOiBwb3MgfSA6IHtcbiAgICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICBtYXJrczogW1xuICAgICAgICAgICAgeyBuYW1lOiBcInNsaWNlXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICAgICAgeyBuYW1lOiB0eXBlLCBwb3NpdGlvbjogcmFuZ2VQb3MgfVxuICAgICAgICAgIF0uY29uY2F0KHJlc3VsdC5tYXJrcywgcmhzLm1hcmtzKSxcbiAgICAgICAgICBwb3NpdGlvbjogcG9zICsgMVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJbcG9zXSAhPT0gXCJdXCIgPyB7IHR5cGU6IFwiZXJyb3JcIiwgbWVzc2FnZTogJ0V4cGVjdGVkIFwiXVwiIGFmdGVyIGFycmF5IGV4cHJlc3Npb24nLCBwb3NpdGlvbjogcG9zIH0gOiB7XG4gICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICBtYXJrczogW3sgbmFtZTogXCJzcXVhcmVfYnJhY2tldFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0uY29uY2F0KHJlc3VsdC5tYXJrcyksXG4gICAgICAgIHBvc2l0aW9uOiBwb3MgKyAxXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwifFwiOiB7XG4gICAgICBpZiAocG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSksIHN0cltwb3NdID09PSBcIntcIikge1xuICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VPYmplY3Qoc3RyLCBwb3MpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIiB8fCByZXN1bHQubWFya3MudW5zaGlmdCh7IG5hbWU6IFwicHJvamVjdGlvblwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwie1wiOiB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VPYmplY3Qoc3RyLCBwb3MpO1xuICAgICAgcmV0dXJuIHJlc3VsdC50eXBlID09PSBcImVycm9yXCIgfHwgcmVzdWx0Lm1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInByb2plY3Rpb25cIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCByZXN1bHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgbWVzc2FnZTogXCJVbmV4cGVjdGVkIGNoYXJhY3RlciBpbiB0cmF2ZXJzYWxcIiwgcG9zaXRpb246IHBvcyB9O1xufVxuZnVuY3Rpb24gcGFyc2VGdW5jQ2FsbChzdHIsIHN0YXJ0UG9zLCBwb3MpIHtcbiAgbGV0IG1hcmtzID0gW107XG4gIGlmIChtYXJrcy5wdXNoKHsgbmFtZTogXCJmdW5jX2NhbGxcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBzdHJbcG9zXSA9PT0gXCI6XCIgJiYgc3RyW3BvcyArIDFdID09PSBcIjpcIikge1xuICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm5hbWVzcGFjZVwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIG1hcmtzLnB1c2goeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LCB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSksIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDIpO1xuICAgIGxldCBuYW1lTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgSURFTlQpO1xuICAgIGlmICghbmFtZUxlbikgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBtZXNzYWdlOiBcIkV4cGVjdGVkIGZ1bmN0aW9uIG5hbWVcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgIGlmIChtYXJrcy5wdXNoKHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogcG9zIH0sIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyArIG5hbWVMZW4gfSksIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIG5hbWVMZW4pLCBzdHJbcG9zXSAhPT0gXCIoXCIpXG4gICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIG1lc3NhZ2U6ICdFeHBlY3RlZCBcIihcIiBhZnRlciBmdW5jdGlvbiBuYW1lJywgcG9zaXRpb246IHBvcyB9O1xuICAgIHBvcysrLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICB9IGVsc2VcbiAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSwgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgbGV0IGxhc3RQb3MgPSBwb3M7XG4gIGlmIChzdHJbcG9zXSAhPT0gXCIpXCIpXG4gICAgZm9yICg7IDsgKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzdWx0O1xuICAgICAgaWYgKG1hcmtzID0gbWFya3MuY29uY2F0KHJlc3VsdC5tYXJrcyksIGxhc3RQb3MgPSByZXN1bHQucG9zaXRpb24sIHBvcyA9IHNraXBXUyhzdHIsIHJlc3VsdC5wb3NpdGlvbiksIHN0cltwb3NdICE9PSBcIixcIiB8fCAocG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSksIHN0cltwb3NdID09PSBcIilcIikpIGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIHN0cltwb3NdICE9PSBcIilcIiA/IHsgdHlwZTogXCJlcnJvclwiLCBtZXNzYWdlOiAnRXhwZWN0ZWQgXCIpXCIgYWZ0ZXIgZnVuY3Rpb24gYXJndW1lbnRzJywgcG9zaXRpb246IHBvcyB9IDogKG1hcmtzLnB1c2goeyBuYW1lOiBcImZ1bmNfYXJnc19lbmRcIiwgcG9zaXRpb246IGxhc3RQb3MgfSksIHtcbiAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICBtYXJrcyxcbiAgICBwb3NpdGlvbjogcG9zICsgMVxuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlT2JqZWN0KHN0ciwgcG9zKSB7XG4gIGxldCBtYXJrcyA9IFt7IG5hbWU6IFwib2JqZWN0XCIsIHBvc2l0aW9uOiBwb3MgfV07XG4gIGZvciAocG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7IHN0cltwb3NdICE9PSBcIn1cIjsgKSB7XG4gICAgbGV0IHBhaXJQb3MgPSBwb3M7XG4gICAgaWYgKHN0ci5zbGljZShwb3MsIHBvcyArIDMpID09PSBcIi4uLlwiKVxuICAgICAgaWYgKHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDMpLCBzdHJbcG9zXSAhPT0gXCJ9XCIgJiYgc3RyW3Bvc10gIT09IFwiLFwiKSB7XG4gICAgICAgIGxldCBleHByID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgICAgaWYgKGV4cHIudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gZXhwcjtcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwib2JqZWN0X3NwbGF0XCIsIHBvc2l0aW9uOiBwYWlyUG9zIH0pLCBtYXJrcyA9IG1hcmtzLmNvbmNhdChleHByLm1hcmtzKSwgcG9zID0gZXhwci5wb3NpdGlvbjtcbiAgICAgIH0gZWxzZVxuICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJvYmplY3Rfc3BsYXRfdGhpc1wiLCBwb3NpdGlvbjogcGFpclBvcyB9KTtcbiAgICBlbHNlIHtcbiAgICAgIGxldCBleHByID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgIGlmIChleHByLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIGV4cHI7XG4gICAgICBsZXQgbmV4dFBvcyA9IHNraXBXUyhzdHIsIGV4cHIucG9zaXRpb24pO1xuICAgICAgaWYgKGV4cHIubWFya3NbMF0ubmFtZSA9PT0gXCJzdHJcIiAmJiBzdHJbbmV4dFBvc10gPT09IFwiOlwiKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIG5leHRQb3MgKyAxKSwgMCk7XG4gICAgICAgIGlmICh2YWx1ZS50eXBlID09PSBcImVycm9yXCIpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwib2JqZWN0X3BhaXJcIiwgcG9zaXRpb246IHBhaXJQb3MgfSksIG1hcmtzID0gbWFya3MuY29uY2F0KGV4cHIubWFya3MsIHZhbHVlLm1hcmtzKSwgcG9zID0gdmFsdWUucG9zaXRpb247XG4gICAgICB9IGVsc2VcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQoeyBuYW1lOiBcIm9iamVjdF9leHByXCIsIHBvc2l0aW9uOiBwb3MgfSwgZXhwci5tYXJrcyksIHBvcyA9IGV4cHIucG9zaXRpb247XG4gICAgfVxuICAgIGlmIChwb3MgPSBza2lwV1Moc3RyLCBwb3MpLCBzdHJbcG9zXSAhPT0gXCIsXCIpIGJyZWFrO1xuICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICB9XG4gIHJldHVybiBzdHJbcG9zXSAhPT0gXCJ9XCIgPyB7IHR5cGU6IFwiZXJyb3JcIiwgbWVzc2FnZTogJ0V4cGVjdGVkIFwifVwiIGFmdGVyIG9iamVjdCcsIHBvc2l0aW9uOiBwb3MgfSA6IChwb3MrKywgbWFya3MucHVzaCh7IG5hbWU6IFwib2JqZWN0X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pLCB7IHR5cGU6IFwic3VjY2Vzc1wiLCBtYXJrcywgcG9zaXRpb246IHBvcyB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0ciwgcG9zKSB7XG4gIGxldCB0b2tlbiA9IHN0cltwb3NdO1xuICBwb3MgPSBwb3MgKyAxO1xuICBjb25zdCBtYXJrcyA9IFt7IG5hbWU6IFwic3RyXCIsIHBvc2l0aW9uOiBwb3MgfV07XG4gIHN0cjogZm9yICg7IDsgcG9zKyspIHtcbiAgICBpZiAocG9zID4gc3RyLmxlbmd0aCkgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBtZXNzYWdlOiBcIlVuZXhwZWN0ZWQgZW5kIG9mIHF1ZXJ5XCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICBzd2l0Y2ggKHN0cltwb3NdKSB7XG4gICAgICBjYXNlIHRva2VuOiB7XG4gICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInN0cl9lbmRcIiwgcG9zaXRpb246IHBvcyB9KSwgcG9zKys7XG4gICAgICAgIGJyZWFrIHN0cjtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInN0cl9wYXVzZVwiLCBwb3NpdGlvbjogcG9zIH0pLCBzdHJbcG9zICsgMV0gPT09IFwidVwiID8gc3RyW3BvcyArIDJdID09PSBcIntcIiA/IChtYXJrcy5wdXNoKHsgbmFtZTogXCJ1bmljb2RlX2hleFwiLCBwb3NpdGlvbjogcG9zICsgMyB9KSwgcG9zID0gc3RyLmluZGV4T2YoXCJ9XCIsIHBvcyArIDMpLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJ1bmljb2RlX2hleF9lbmRcIiwgcG9zaXRpb246IHBvcyB9KSkgOiAobWFya3MucHVzaCh7IG5hbWU6IFwidW5pY29kZV9oZXhcIiwgcG9zaXRpb246IHBvcyArIDIgfSksIG1hcmtzLnB1c2goeyBuYW1lOiBcInVuaWNvZGVfaGV4X2VuZFwiLCBwb3NpdGlvbjogcG9zICsgNiB9KSwgcG9zICs9IDUpIDogKG1hcmtzLnB1c2goeyBuYW1lOiBcInNpbmdsZV9lc2NhcGVcIiwgcG9zaXRpb246IHBvcyArIDEgfSksIHBvcyArPSAxKSwgbWFya3MucHVzaCh7IG5hbWU6IFwic3RyX3N0YXJ0XCIsIHBvc2l0aW9uOiBwb3MgKyAxIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyB0eXBlOiBcInN1Y2Nlc3NcIiwgbWFya3MsIHBvc2l0aW9uOiBwb3MgfTtcbn1cbmZ1bmN0aW9uIHNraXBXUyhzdHIsIHBvcykge1xuICByZXR1cm4gcG9zICsgcGFyc2VSZWdleChzdHIsIHBvcywgV1MpO1xufVxuZnVuY3Rpb24gcGFyc2VSZWdleChzdHIsIHBvcywgcmUpIHtcbiAgbGV0IG0gPSByZS5leGVjKHN0ci5zbGljZShwb3MpKTtcbiAgcmV0dXJuIG0gPyBtWzBdLmxlbmd0aCA6IDA7XG59XG5mdW5jdGlvbiBwYXJzZVJlZ2V4U3RyKHN0ciwgcG9zLCByZSkge1xuICBsZXQgbSA9IHJlLmV4ZWMoc3RyLnNsaWNlKHBvcykpO1xuICByZXR1cm4gbSA/IG1bMF0gOiBudWxsO1xufVxuZnVuY3Rpb24gam9pbihhLCBiKSB7XG4gIHJldHVybiAoYmFzZSkgPT4gYihhKGJhc2UpKTtcbn1cbmZ1bmN0aW9uIG1hcChpbm5lcikge1xuICByZXR1cm4gKGJhc2UpID0+ICh7IHR5cGU6IFwiTWFwXCIsIGJhc2UsIGV4cHI6IGlubmVyKHsgdHlwZTogXCJUaGlzXCIgfSkgfSk7XG59XG5mdW5jdGlvbiBmbGF0TWFwKGlubmVyKSB7XG4gIHJldHVybiAoYmFzZSkgPT4gKHsgdHlwZTogXCJGbGF0TWFwXCIsIGJhc2UsIGV4cHI6IGlubmVyKHsgdHlwZTogXCJUaGlzXCIgfSkgfSk7XG59XG5mdW5jdGlvbiB0cmF2ZXJzZUFycmF5KGJ1aWxkLCByaWdodCkge1xuICBpZiAoIXJpZ2h0KVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgYnVpbGRcbiAgICB9O1xuICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcbiAgICBjYXNlIFwiYS1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgICBidWlsZDogam9pbihidWlsZCwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJhLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1iXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKGJ1aWxkLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImItYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIG1hcChyaWdodC5idWlsZCkpXG4gICAgICB9O1xuICAgIGNhc2UgXCJiLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKGJ1aWxkLCBmbGF0TWFwKHJpZ2h0LmJ1aWxkKSlcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlOiAke3JpZ2h0LnR5cGV9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyYXZlcnNlUGxhaW4obWFwcGVyLCByaWdodCkge1xuICBpZiAoIXJpZ2h0KVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImItYlwiLFxuICAgICAgYnVpbGQ6IG1hcHBlclxuICAgIH07XG4gIHN3aXRjaCAocmlnaHQudHlwZSkge1xuICAgIGNhc2UgXCJhLWFcIjpcbiAgICBjYXNlIFwiYi1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImItYVwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYS1iXCI6XG4gICAgY2FzZSBcImItYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJiLWJcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlOiAke3JpZ2h0LnR5cGV9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyYXZlcnNlRWxlbWVudChtYXBwZXIsIHJpZ2h0KSB7XG4gIGlmICghcmlnaHQpXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYS1iXCIsXG4gICAgICBidWlsZDogbWFwcGVyXG4gICAgfTtcbiAgc3dpdGNoIChyaWdodC50eXBlKSB7XG4gICAgY2FzZSBcImEtYVwiOlxuICAgIGNhc2UgXCJiLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJhLWJcIjpcbiAgICBjYXNlIFwiYi1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYlwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHR5cGU6ICR7cmlnaHQudHlwZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gdHJhdmVyc2VQcm9qZWN0aW9uKG1hcHBlciwgcmlnaHQpIHtcbiAgaWYgKCFyaWdodClcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJiLWJcIixcbiAgICAgIGJ1aWxkOiBtYXBwZXJcbiAgICB9O1xuICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcbiAgICBjYXNlIFwiYS1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgICBidWlsZDogam9pbihtYXAobWFwcGVyKSwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJhLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1iXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcChtYXBwZXIpLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImItYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJiLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImItYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJiLWJcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlOiAke3JpZ2h0LnR5cGV9YCk7XG4gIH1cbn1cbmNvbnN0IEVTQ0FQRV9TRVFVRU5DRSA9IHtcbiAgXCInXCI6IFwiJ1wiLFxuICAnXCInOiAnXCInLFxuICBcIlxcXFxcIjogXCJcXFxcXCIsXG4gIFwiL1wiOiBcIi9cIixcbiAgYjogXCJcXGJcIixcbiAgZjogXCJcXGZcIixcbiAgbjogYFxuYCxcbiAgcjogXCJcXHJcIixcbiAgdDogXCJcdFwiXG59O1xuZnVuY3Rpb24gZXhwYW5kSGV4KHN0cikge1xuICBjb25zdCBjaGFyQ29kZSA9IHBhcnNlSW50KHN0ciwgMTYpO1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG59XG5jbGFzcyBHcm9xUXVlcnlFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgbmFtZSA9IFwiR3JvcVF1ZXJ5RXJyb3JcIjtcbn1cbmNvbnN0IEVYUFJfQlVJTERFUiA9IHtcbiAgZ3JvdXAocCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkdyb3VwXCIsXG4gICAgICBiYXNlOiBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKVxuICAgIH07XG4gIH0sXG4gIGV2ZXJ5dGhpbmcoKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJFdmVyeXRoaW5nXCIgfTtcbiAgfSxcbiAgdGhpcygpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcIlRoaXNcIiB9O1xuICB9LFxuICBwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiUGFyZW50XCIsXG4gICAgICBuOiAxXG4gICAgfTtcbiAgfSxcbiAgZGJscGFyZW50KHApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJQYXJlbnRcIixcbiAgICAgIG46IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLm4gKyAxXG4gICAgfTtcbiAgfSxcbiAgdHJhdmVyc2UocCkge1xuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgdHJhdmVyc2FsTGlzdCA9IFtdO1xuICAgIGZvciAoOyBwLmdldE1hcmsoKS5uYW1lICE9PSBcInRyYXZlcnNhbF9lbmRcIjsgKVxuICAgICAgdHJhdmVyc2FsTGlzdC5wdXNoKHAucHJvY2VzcyhUUkFWRVJTRV9CVUlMREVSKSk7XG4gICAgcC5zaGlmdCgpO1xuICAgIGxldCB0cmF2ZXJzYWwgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSB0cmF2ZXJzYWxMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgdHJhdmVyc2FsID0gdHJhdmVyc2FsTGlzdFtpXSh0cmF2ZXJzYWwpO1xuICAgIGlmICgoYmFzZS50eXBlID09PSBcIkV2ZXJ5dGhpbmdcIiB8fCBiYXNlLnR5cGUgPT09IFwiQXJyYXlcIiB8fCBiYXNlLnR5cGUgPT09IFwiUGlwZUZ1bmNDYWxsXCIpICYmICh0cmF2ZXJzYWwgPSB0cmF2ZXJzZUFycmF5KCh2YWwpID0+IHZhbCwgdHJhdmVyc2FsKSksIHRyYXZlcnNhbCA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiQlVHOiB1bmV4cGVjdGVkIGVtcHR5IHRyYXZlcnNhbFwiKTtcbiAgICByZXR1cm4gdHJhdmVyc2FsLmJ1aWxkKGJhc2UpO1xuICB9LFxuICB0aGlzX2F0dHIocCkge1xuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICByZXR1cm4gbmFtZSA9PT0gXCJudWxsXCIgPyB7IHR5cGU6IFwiVmFsdWVcIiwgdmFsdWU6IG51bGwgfSA6IG5hbWUgPT09IFwidHJ1ZVwiID8geyB0eXBlOiBcIlZhbHVlXCIsIHZhbHVlOiAhMCB9IDogbmFtZSA9PT0gXCJmYWxzZVwiID8geyB0eXBlOiBcIlZhbHVlXCIsIHZhbHVlOiAhMSB9IDoge1xuICAgICAgdHlwZTogXCJBY2Nlc3NBdHRyaWJ1dGVcIixcbiAgICAgIG5hbWVcbiAgICB9O1xuICB9LFxuICBuZWcocCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk5lZ1wiLFxuICAgICAgYmFzZTogcC5wcm9jZXNzKEVYUFJfQlVJTERFUilcbiAgICB9O1xuICB9LFxuICBwb3MocCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBvc1wiLFxuICAgICAgYmFzZTogcC5wcm9jZXNzKEVYUFJfQlVJTERFUilcbiAgICB9O1xuICB9LFxuICBhZGQocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIitcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIHN1YihwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiLVwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgbXVsKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCIqXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBkaXYocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIi9cIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIG1vZChwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiJVwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgcG93KHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCIqKlwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgY29tcChwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCBvcCA9IHAucHJvY2Vzc1N0cmluZygpLCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3AsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBpbl9yYW5nZShwKSB7XG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCBpc0luY2x1c2l2ZSA9IHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiaW5jX3JhbmdlXCI7XG4gICAgcC5zaGlmdCgpO1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJJblJhbmdlXCIsXG4gICAgICBiYXNlLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0LFxuICAgICAgaXNJbmNsdXNpdmVcbiAgICB9O1xuICB9LFxuICBzdHIocCkge1xuICAgIGxldCB2YWx1ZSA9IFwiXCI7XG4gICAgbG9vcDogZm9yICg7IHAuaGFzTWFyaygpOyApIHtcbiAgICAgIGNvbnN0IG1hcmsgPSBwLmdldE1hcmsoKTtcbiAgICAgIHN3aXRjaCAobWFyay5uYW1lKSB7XG4gICAgICAgIGNhc2UgXCJzdHJfZW5kXCI6XG4gICAgICAgICAgdmFsdWUgKz0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgY2FzZSBcInN0cl9wYXVzZVwiOlxuICAgICAgICAgIHZhbHVlICs9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3RyX3N0YXJ0XCI6XG4gICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2luZ2xlX2VzY2FwZVwiOiB7XG4gICAgICAgICAgY29uc3QgY2hhciA9IHAuc2xpY2UoMSk7XG4gICAgICAgICAgcC5zaGlmdCgpLCB2YWx1ZSArPSBFU0NBUEVfU0VRVUVOQ0VbY2hhcl07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInVuaWNvZGVfaGV4XCI6XG4gICAgICAgICAgcC5zaGlmdCgpLCB2YWx1ZSArPSBleHBhbmRIZXgocC5wcm9jZXNzU3RyaW5nRW5kKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCBtYXJrOiAke21hcmsubmFtZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJWYWx1ZVwiLCB2YWx1ZSB9O1xuICB9LFxuICBpbnRlZ2VyKHApIHtcbiAgICBjb25zdCBzdHJWYWx1ZSA9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICB2YWx1ZTogTnVtYmVyKHN0clZhbHVlKVxuICAgIH07XG4gIH0sXG4gIGZsb2F0KHApIHtcbiAgICBjb25zdCBzdHJWYWx1ZSA9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICB2YWx1ZTogTnVtYmVyKHN0clZhbHVlKVxuICAgIH07XG4gIH0sXG4gIHNjaShwKSB7XG4gICAgY29uc3Qgc3RyVmFsdWUgPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgdmFsdWU6IE51bWJlcihzdHJWYWx1ZSlcbiAgICB9O1xuICB9LFxuICBvYmplY3QocCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBbXTtcbiAgICBmb3IgKDsgcC5nZXRNYXJrKCkubmFtZSAhPT0gXCJvYmplY3RfZW5kXCI7IClcbiAgICAgIGF0dHJpYnV0ZXMucHVzaChwLnByb2Nlc3MoT0JKRUNUX0JVSUxERVIpKTtcbiAgICByZXR1cm4gcC5zaGlmdCgpLCB7XG4gICAgICB0eXBlOiBcIk9iamVjdFwiLFxuICAgICAgYXR0cmlidXRlc1xuICAgIH07XG4gIH0sXG4gIGFycmF5KHApIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAgIGZvciAoOyBwLmdldE1hcmsoKS5uYW1lICE9PSBcImFycmF5X2VuZFwiOyApIHtcbiAgICAgIGxldCBpc1NwbGF0ID0gITE7XG4gICAgICBwLmdldE1hcmsoKS5uYW1lID09PSBcImFycmF5X3NwbGF0XCIgJiYgKGlzU3BsYXQgPSAhMCwgcC5zaGlmdCgpKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICBlbGVtZW50cy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJBcnJheUVsZW1lbnRcIixcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGlzU3BsYXRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcC5zaGlmdCgpLCB7XG4gICAgICB0eXBlOiBcIkFycmF5XCIsXG4gICAgICBlbGVtZW50c1xuICAgIH07XG4gIH0sXG4gIHR1cGxlKHApIHtcbiAgICBjb25zdCBtZW1iZXJzID0gW107XG4gICAgZm9yICg7IHAuZ2V0TWFyaygpLm5hbWUgIT09IFwidHVwbGVfZW5kXCI7IClcbiAgICAgIG1lbWJlcnMucHVzaChwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSk7XG4gICAgcmV0dXJuIHAuc2hpZnQoKSwge1xuICAgICAgdHlwZTogXCJUdXBsZVwiLFxuICAgICAgbWVtYmVyc1xuICAgIH07XG4gIH0sXG4gIGZ1bmNfY2FsbChwKSB7XG4gICAgbGV0IG5hbWVzcGFjZSA9IFwiZ2xvYmFsXCI7XG4gICAgcC5nZXRNYXJrKCkubmFtZSA9PT0gXCJuYW1lc3BhY2VcIiAmJiAocC5zaGlmdCgpLCBuYW1lc3BhY2UgPSBwLnByb2Nlc3NTdHJpbmcoKSk7XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIGlmIChuYW1lc3BhY2UgPT09IFwiZ2xvYmFsXCIgJiYgbmFtZSA9PT0gXCJzZWxlY3RcIikge1xuICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBcIlNlbGVjdFwiLFxuICAgICAgICBhbHRlcm5hdGl2ZXM6IFtdXG4gICAgICB9O1xuICAgICAgZm9yICg7IHAuZ2V0TWFyaygpLm5hbWUgIT09IFwiZnVuY19hcmdzX2VuZFwiOyApXG4gICAgICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcInBhaXJcIikge1xuICAgICAgICAgIGlmIChyZXN1bHQuZmFsbGJhY2spIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgYXJndW1lbnQgdG8gc2VsZWN0KClcIik7XG4gICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICAgIHJlc3VsdC5hbHRlcm5hdGl2ZXMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcIlNlbGVjdEFsdGVybmF0aXZlXCIsXG4gICAgICAgICAgICBjb25kaXRpb24sXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChyZXN1bHQuZmFsbGJhY2spIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgYXJndW1lbnQgdG8gc2VsZWN0KClcIik7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgICByZXN1bHQuZmFsbGJhY2sgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIHAuc2hpZnQoKSwgcmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gW107XG4gICAgZm9yICg7IHAuZ2V0TWFyaygpLm5hbWUgIT09IFwiZnVuY19hcmdzX2VuZFwiOyApXG4gICAgICBhcmd1bWVudFNob3VsZEJlU2VsZWN0b3IobmFtZXNwYWNlLCBuYW1lLCBhcmdzLmxlbmd0aCkgPyBhcmdzLnB1c2gocC5wcm9jZXNzKFNFTEVDVE9SX0JVSUxERVIpKSA6IGFyZ3MucHVzaChwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSk7XG4gICAgaWYgKHAuc2hpZnQoKSwgbmFtZXNwYWNlID09PSBcImdsb2JhbFwiICYmIChuYW1lID09PSBcImJlZm9yZVwiIHx8IG5hbWUgPT09IFwiYWZ0ZXJcIikgJiYgcC5wYXJzZU9wdGlvbnMubW9kZSA9PT0gXCJkZWx0YVwiKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJDb250ZXh0XCIsXG4gICAgICAgIGtleTogbmFtZVxuICAgICAgfTtcbiAgICBpZiAobmFtZXNwYWNlID09PSBcImdsb2JhbFwiICYmIG5hbWUgPT09IFwiYm9vc3RcIiAmJiAhcC5hbGxvd0Jvb3N0KVxuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCBib29zdFwiKTtcbiAgICBjb25zdCBmdW5jcyA9IG5hbWVzcGFjZXNbbmFtZXNwYWNlXTtcbiAgICBpZiAoIWZ1bmNzKVxuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBVbmRlZmluZWQgbmFtZXNwYWNlOiAke25hbWVzcGFjZX1gKTtcbiAgICBjb25zdCBmdW5jID0gZnVuY3NbbmFtZV07XG4gICAgaWYgKCFmdW5jKVxuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBVbmRlZmluZWQgZnVuY3Rpb246ICR7bmFtZX1gKTtcbiAgICBpZiAoZnVuYy5hcml0eSAhPT0gdm9pZCAwICYmIHZhbGlkYXRlQXJpdHkobmFtZSwgZnVuYy5hcml0eSwgYXJncy5sZW5ndGgpLCBmdW5jLm1vZGUgIT09IHZvaWQgMCAmJiBmdW5jLm1vZGUgIT09IHAucGFyc2VPcHRpb25zLm1vZGUpXG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoYFVuZGVmaW5lZCBmdW5jdGlvbjogJHtuYW1lfWApO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkZ1bmNDYWxsXCIsXG4gICAgICBmdW5jLFxuICAgICAgbmFtZXNwYWNlLFxuICAgICAgbmFtZSxcbiAgICAgIGFyZ3NcbiAgICB9O1xuICB9LFxuICBwaXBlY2FsbChwKSB7XG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHAuc2hpZnQoKTtcbiAgICBsZXQgbmFtZXNwYWNlID0gXCJnbG9iYWxcIjtcbiAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJuYW1lc3BhY2VcIiAmJiAocC5zaGlmdCgpLCBuYW1lc3BhY2UgPSBwLnByb2Nlc3NTdHJpbmcoKSksIG5hbWVzcGFjZSAhPT0gXCJnbG9iYWxcIilcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgVW5kZWZpbmVkIG5hbWVzcGFjZTogJHtuYW1lc3BhY2V9YCk7XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpLCBhcmdzID0gW10sIG9sZEFsbG93Qm9vc3QgPSBwLmFsbG93Qm9vc3Q7XG4gICAgZm9yIChuYW1lID09PSBcInNjb3JlXCIgJiYgKHAuYWxsb3dCb29zdCA9ICEwKTsgOyApIHtcbiAgICAgIGNvbnN0IG1hcmtOYW1lID0gcC5nZXRNYXJrKCkubmFtZTtcbiAgICAgIGlmIChtYXJrTmFtZSA9PT0gXCJmdW5jX2FyZ3NfZW5kXCIpXG4gICAgICAgIGJyZWFrO1xuICAgICAgaWYgKG5hbWUgPT09IFwib3JkZXJcIikge1xuICAgICAgICBpZiAobWFya05hbWUgPT09IFwiYXNjXCIpIHtcbiAgICAgICAgICBwLnNoaWZ0KCksIGFyZ3MucHVzaCh7IHR5cGU6IFwiQXNjXCIsIGJhc2U6IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG1hcmtOYW1lID09PSBcImRlc2NcIikge1xuICAgICAgICAgIHAuc2hpZnQoKSwgYXJncy5wdXNoKHsgdHlwZTogXCJEZXNjXCIsIGJhc2U6IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcmdzLnB1c2gocC5wcm9jZXNzKEVYUFJfQlVJTERFUikpO1xuICAgIH1cbiAgICBwLnNoaWZ0KCksIHAuYWxsb3dCb29zdCA9IG9sZEFsbG93Qm9vc3Q7XG4gICAgY29uc3QgZnVuYyA9IHBpcGVGdW5jdGlvbnNbbmFtZV07XG4gICAgaWYgKCFmdW5jKVxuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBVbmRlZmluZWQgcGlwZSBmdW5jdGlvbjogJHtuYW1lfWApO1xuICAgIHJldHVybiBmdW5jLmFyaXR5ICYmIHZhbGlkYXRlQXJpdHkobmFtZSwgZnVuYy5hcml0eSwgYXJncy5sZW5ndGgpLCB7XG4gICAgICB0eXBlOiBcIlBpcGVGdW5jQ2FsbFwiLFxuICAgICAgZnVuYyxcbiAgICAgIGJhc2UsXG4gICAgICBuYW1lLFxuICAgICAgYXJnc1xuICAgIH07XG4gIH0sXG4gIHBhaXIoKSB7XG4gICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCA9PlwiKTtcbiAgfSxcbiAgYW5kKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiQW5kXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBvcihwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9yXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBub3QocCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk5vdFwiLFxuICAgICAgYmFzZTogcC5wcm9jZXNzKEVYUFJfQlVJTERFUilcbiAgICB9O1xuICB9LFxuICBhc2MoKSB7XG4gICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCBhc2NcIik7XG4gIH0sXG4gIGRlc2MoKSB7XG4gICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCBkZXNjXCIpO1xuICB9LFxuICBwYXJhbShwKSB7XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIHJldHVybiBwLnBhcnNlT3B0aW9ucy5wYXJhbXMgJiYgcC5wYXJzZU9wdGlvbnMucGFyYW1zLmhhc093blByb3BlcnR5KG5hbWUpID8ge1xuICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgdmFsdWU6IHAucGFyc2VPcHRpb25zLnBhcmFtc1tuYW1lXVxuICAgIH0gOiB7XG4gICAgICB0eXBlOiBcIlBhcmFtZXRlclwiLFxuICAgICAgbmFtZVxuICAgIH07XG4gIH1cbn0sIE9CSkVDVF9CVUlMREVSID0ge1xuICBvYmplY3RfZXhwcihwKSB7XG4gICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwicGFpclwiKSB7XG4gICAgICBwLnNoaWZ0KCk7XG4gICAgICBjb25zdCBjb25kaXRpb24gPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgdmFsdWUyID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIk9iamVjdENvbmRpdGlvbmFsU3BsYXRcIixcbiAgICAgICAgY29uZGl0aW9uLFxuICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9iamVjdEF0dHJpYnV0ZVZhbHVlXCIsXG4gICAgICBuYW1lOiBleHRyYWN0UHJvcGVydHlLZXkodmFsdWUpLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9LFxuICBvYmplY3RfcGFpcihwKSB7XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGlmIChuYW1lLnR5cGUgIT09IFwiVmFsdWVcIikgdGhyb3cgbmV3IEVycm9yKFwibmFtZSBtdXN0IGJlIHN0cmluZ1wiKTtcbiAgICBjb25zdCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9iamVjdEF0dHJpYnV0ZVZhbHVlXCIsXG4gICAgICBuYW1lOiBuYW1lLnZhbHVlLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9LFxuICBvYmplY3Rfc3BsYXQocCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9iamVjdFNwbGF0XCIsXG4gICAgICB2YWx1ZTogcC5wcm9jZXNzKEVYUFJfQlVJTERFUilcbiAgICB9O1xuICB9LFxuICBvYmplY3Rfc3BsYXRfdGhpcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPYmplY3RTcGxhdFwiLFxuICAgICAgdmFsdWU6IHsgdHlwZTogXCJUaGlzXCIgfVxuICAgIH07XG4gIH1cbn0sIFRSQVZFUlNFX0JVSUxERVIgPSB7XG4gIHNxdWFyZV9icmFja2V0KHApIHtcbiAgICBjb25zdCBleHByID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHZhbHVlID0gdHJ5Q29uc3RhbnRFdmFsdWF0ZShleHByKTtcbiAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUudHlwZSA9PT0gXCJudW1iZXJcIiA/IChyaWdodCkgPT4gdHJhdmVyc2VFbGVtZW50KChiYXNlKSA9PiAoeyB0eXBlOiBcIkFjY2Vzc0VsZW1lbnRcIiwgYmFzZSwgaW5kZXg6IHZhbHVlLmRhdGEgfSksIHJpZ2h0KSA6IHZhbHVlICYmIHZhbHVlLnR5cGUgPT09IFwic3RyaW5nXCIgPyAocmlnaHQpID0+IHRyYXZlcnNlUGxhaW4oKGJhc2UpID0+ICh7IHR5cGU6IFwiQWNjZXNzQXR0cmlidXRlXCIsIGJhc2UsIG5hbWU6IHZhbHVlLmRhdGEgfSksIHJpZ2h0KSA6IChyaWdodCkgPT4gdHJhdmVyc2VBcnJheShcbiAgICAgIChiYXNlKSA9PiAoe1xuICAgICAgICB0eXBlOiBcIkZpbHRlclwiLFxuICAgICAgICBiYXNlLFxuICAgICAgICBleHByXG4gICAgICB9KSxcbiAgICAgIHJpZ2h0XG4gICAgKTtcbiAgfSxcbiAgc2xpY2UocCkge1xuICAgIGNvbnN0IGlzSW5jbHVzaXZlID0gcC5nZXRNYXJrKCkubmFtZSA9PT0gXCJpbmNfcmFuZ2VcIjtcbiAgICBwLnNoaWZ0KCk7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCBsZWZ0VmFsdWUgPSB0cnlDb25zdGFudEV2YWx1YXRlKGxlZnQpLCByaWdodFZhbHVlID0gdHJ5Q29uc3RhbnRFdmFsdWF0ZShyaWdodCk7XG4gICAgaWYgKCFsZWZ0VmFsdWUgfHwgIXJpZ2h0VmFsdWUgfHwgbGVmdFZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIgfHwgcmlnaHRWYWx1ZS50eXBlICE9PSBcIm51bWJlclwiKVxuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwic2xpY2luZyBtdXN0IHVzZSBjb25zdGFudCBudW1iZXJzXCIpO1xuICAgIHJldHVybiAocmhzKSA9PiB0cmF2ZXJzZUFycmF5KFxuICAgICAgKGJhc2UpID0+ICh7XG4gICAgICAgIHR5cGU6IFwiU2xpY2VcIixcbiAgICAgICAgYmFzZSxcbiAgICAgICAgbGVmdDogbGVmdFZhbHVlLmRhdGEsXG4gICAgICAgIHJpZ2h0OiByaWdodFZhbHVlLmRhdGEsXG4gICAgICAgIGlzSW5jbHVzaXZlXG4gICAgICB9KSxcbiAgICAgIHJoc1xuICAgICk7XG4gIH0sXG4gIHByb2plY3Rpb24ocCkge1xuICAgIGNvbnN0IG9iaiA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiAocmlnaHQpID0+IHRyYXZlcnNlUHJvamVjdGlvbigoYmFzZSkgPT4gKHsgdHlwZTogXCJQcm9qZWN0aW9uXCIsIGJhc2UsIGV4cHI6IG9iaiB9KSwgcmlnaHQpO1xuICB9LFxuICBhdHRyX2FjY2VzcyhwKSB7XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIHJldHVybiAocmlnaHQpID0+IHRyYXZlcnNlUGxhaW4oKGJhc2UpID0+ICh7IHR5cGU6IFwiQWNjZXNzQXR0cmlidXRlXCIsIGJhc2UsIG5hbWUgfSksIHJpZ2h0KTtcbiAgfSxcbiAgZGVyZWYocCkge1xuICAgIGxldCBhdHRyID0gbnVsbDtcbiAgICBwLmdldE1hcmsoKS5uYW1lID09PSBcImRlcmVmX2F0dHJcIiAmJiAocC5zaGlmdCgpLCBhdHRyID0gcC5wcm9jZXNzU3RyaW5nKCkpO1xuICAgIGNvbnN0IHdyYXAgPSAoYmFzZSkgPT4gYXR0ciA/IHsgdHlwZTogXCJBY2Nlc3NBdHRyaWJ1dGVcIiwgYmFzZSwgbmFtZTogYXR0ciB9IDogYmFzZTtcbiAgICByZXR1cm4gKHJpZ2h0KSA9PiB0cmF2ZXJzZVBsYWluKFxuICAgICAgKGJhc2UpID0+IHdyYXAoe1xuICAgICAgICB0eXBlOiBcIkRlcmVmXCIsXG4gICAgICAgIGJhc2VcbiAgICAgIH0pLFxuICAgICAgcmlnaHRcbiAgICApO1xuICB9LFxuICBhcnJheV9wb3N0Zml4KCkge1xuICAgIHJldHVybiAocmlnaHQpID0+IHRyYXZlcnNlQXJyYXkoKGJhc2UpID0+ICh7IHR5cGU6IFwiQXJyYXlDb2VyY2VcIiwgYmFzZSB9KSwgcmlnaHQpO1xuICB9XG59LCBTRUxFQ1RPUl9CVUlMREVSID0ge1xuICBncm91cChwKSB7XG4gICAgcmV0dXJuIHAucHJvY2VzcyhTRUxFQ1RPUl9CVUlMREVSKTtcbiAgfSxcbiAgZXZlcnl0aGluZygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgdGhpcygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgcGFyZW50KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBkYmxwYXJlbnQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHRyYXZlcnNlKHApIHtcbiAgICBsZXQgbm9kZSA9IHAucHJvY2VzcyhTRUxFQ1RPUl9CVUlMREVSKTtcbiAgICBmb3IgKDsgcC5nZXRNYXJrKCkubmFtZSAhPT0gXCJ0cmF2ZXJzYWxfZW5kXCI7IClcbiAgICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcImFycmF5X3Bvc3RmaXhcIilcbiAgICAgICAgcC5zaGlmdCgpLCBub2RlID0geyB0eXBlOiBcIkFycmF5Q29lcmNlXCIsIGJhc2U6IG5vZGUgfTtcbiAgICAgIGVsc2UgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwic3F1YXJlX2JyYWNrZXRcIikge1xuICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgIGNvbnN0IGV4cHIgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgdmFsdWUgPSB0cnlDb25zdGFudEV2YWx1YXRlKGV4cHIpO1xuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUudHlwZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFycmF5IGFjY2VzcyBleHByZXNzaW9uXCIpO1xuICAgICAgICB2YWx1ZSAmJiB2YWx1ZS50eXBlID09PSBcInN0cmluZ1wiID8gbm9kZSA9IHsgdHlwZTogXCJBY2Nlc3NBdHRyaWJ1dGVcIiwgYmFzZTogbm9kZSwgbmFtZTogdmFsdWUuZGF0YSB9IDogbm9kZSA9IHsgdHlwZTogXCJGaWx0ZXJcIiwgYmFzZTogbm9kZSwgZXhwciB9O1xuICAgICAgfSBlbHNlIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcImF0dHJfYWNjZXNzXCIpIHtcbiAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgICAgIG5vZGUgPSB7IHR5cGU6IFwiQWNjZXNzQXR0cmlidXRlXCIsIGJhc2U6IG5vZGUsIG5hbWUgfTtcbiAgICAgIH0gZWxzZSBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJ0dXBsZVwiIHx8IHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiZ3JvdXBcIikge1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9IHAucHJvY2VzcyhTRUxFQ1RPUl9CVUlMREVSKTtcbiAgICAgICAgaWYgKCFpc1NlbGVjdG9yTmVzdGVkKHNlbGVjdG9yKSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgcmVzdWx0IHBhcnNpbmcgbmVzdGVkIHNlbGVjdG9yOiAke3NlbGVjdG9yLnR5cGV9YCk7XG4gICAgICAgIG5vZGUgPSB7IHR5cGU6IFwiU2VsZWN0b3JOZXN0ZWRcIiwgYmFzZTogbm9kZSwgbmVzdGVkOiBzZWxlY3RvciB9O1xuICAgICAgfSBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICAgIHJldHVybiBwLnNoaWZ0KCksIG5vZGU7XG4gIH0sXG4gIHRoaXNfYXR0cihwKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJBY2Nlc3NBdHRyaWJ1dGVcIiwgbmFtZTogcC5wcm9jZXNzU3RyaW5nKCkgfTtcbiAgfSxcbiAgYXR0cl9hY2Nlc3MoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIG5lZygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgcG9zKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBhZGQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHN1YigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgbXVsKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBkaXYoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIG1vZCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgcG93KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBjb21wKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBpbl9yYW5nZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgc3RyKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBpbnRlZ2VyKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBmbG9hdCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgc2NpKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBvYmplY3QoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGFycmF5KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICB0dXBsZShwKSB7XG4gICAgY29uc3Qgc2VsZWN0b3JzID0gW107XG4gICAgZm9yICg7IHAuZ2V0TWFyaygpLm5hbWUgIT09IFwidHVwbGVfZW5kXCI7IClcbiAgICAgIHNlbGVjdG9ycy5wdXNoKHAucHJvY2VzcyhTRUxFQ1RPUl9CVUlMREVSKSk7XG4gICAgcmV0dXJuIHAuc2hpZnQoKSwgeyB0eXBlOiBcIlR1cGxlXCIsIG1lbWJlcnM6IHNlbGVjdG9ycyB9O1xuICB9LFxuICBmdW5jX2NhbGwocCwgbWFyaykge1xuICAgIGNvbnN0IGZ1bmMgPSBFWFBSX0JVSUxERVIuZnVuY19jYWxsKHAsIG1hcmspO1xuICAgIGlmIChmdW5jLm5hbWUgPT09IFwiYW55d2hlcmVcIiAmJiBmdW5jLmFyZ3MubGVuZ3RoID09PSAxKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJTZWxlY3RvckZ1bmNDYWxsXCIsXG4gICAgICAgIG5hbWU6IFwiYW55d2hlcmVcIixcbiAgICAgICAgYXJnOiBmdW5jLmFyZ3NbMF1cbiAgICAgIH07XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHBpcGVjYWxsKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBwYWlyKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBhbmQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIG9yKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBub3QoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGFzYygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgZGVzYygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgcGFyYW0oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH1cbn07XG5mdW5jdGlvbiBleHRyYWN0UHJvcGVydHlLZXkobm9kZSkge1xuICBpZiAobm9kZS50eXBlID09PSBcIkFjY2Vzc0F0dHJpYnV0ZVwiICYmICFub2RlLmJhc2UpXG4gICAgcmV0dXJuIG5vZGUubmFtZTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJQaXBlRnVuY0NhbGxcIiB8fCBub2RlLnR5cGUgPT09IFwiRGVyZWZcIiB8fCBub2RlLnR5cGUgPT09IFwiTWFwXCIgfHwgbm9kZS50eXBlID09PSBcIlByb2plY3Rpb25cIiB8fCBub2RlLnR5cGUgPT09IFwiU2xpY2VcIiB8fCBub2RlLnR5cGUgPT09IFwiRmlsdGVyXCIgfHwgbm9kZS50eXBlID09PSBcIkFjY2Vzc0VsZW1lbnRcIiB8fCBub2RlLnR5cGUgPT09IFwiQXJyYXlDb2VyY2VcIiB8fCBub2RlLnR5cGUgPT09IFwiR3JvdXBcIilcbiAgICByZXR1cm4gZXh0cmFjdFByb3BlcnR5S2V5KG5vZGUuYmFzZSk7XG4gIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgQ2Fubm90IGRldGVybWluZSBwcm9wZXJ0eSBrZXkgZm9yIHR5cGU6ICR7bm9kZS50eXBlfWApO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVBcml0eShuYW1lLCBhcml0eSwgY291bnQpIHtcbiAgaWYgKHR5cGVvZiBhcml0eSA9PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKGNvdW50ICE9PSBhcml0eSlcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcbiAgICAgICAgYEluY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGZ1bmN0aW9uICR7bmFtZX0oKS4gRXhwZWN0ZWQgJHthcml0eX0sIGdvdCAke2NvdW50fS5gXG4gICAgICApO1xuICB9IGVsc2UgaWYgKGFyaXR5ICYmICFhcml0eShjb3VudCkpXG4gICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBJbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBmdW5jdGlvbiAke25hbWV9KCkuYCk7XG59XG5mdW5jdGlvbiBhcmd1bWVudFNob3VsZEJlU2VsZWN0b3IobmFtZXNwYWNlLCBmdW5jdGlvbk5hbWUsIGFyZ0NvdW50KSB7XG4gIGNvbnN0IGZ1bmN0aW9uc1JlcXVpcmluZ1NlbGVjdG9ycyA9IFtcImNoYW5nZWRBbnlcIiwgXCJjaGFuZ2VkT25seVwiXTtcbiAgcmV0dXJuIG5hbWVzcGFjZSA9PSBcImRpZmZcIiAmJiBhcmdDb3VudCA9PSAyICYmIGZ1bmN0aW9uc1JlcXVpcmluZ1NlbGVjdG9ycy5pbmNsdWRlcyhmdW5jdGlvbk5hbWUpO1xufVxuY2xhc3MgR3JvcVN5bnRheEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBwb3NpdGlvbjtcbiAgbmFtZSA9IFwiR3JvcVN5bnRheEVycm9yXCI7XG4gIGNvbnN0cnVjdG9yKHBvc2l0aW9uLCBkZXRhaWwpIHtcbiAgICBzdXBlcihgU3ludGF4IGVycm9yIGluIEdST1EgcXVlcnkgYXQgcG9zaXRpb24gJHtwb3NpdGlvbn0ke2RldGFpbCA/IFwiOiBcIiArIGRldGFpbCA6IFwiXCJ9YCksIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2UoaW5wdXQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCByZXN1bHQgPSBwYXJzZSQxKGlucHV0KTtcbiAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgdGhyb3cgbmV3IEdyb3FTeW50YXhFcnJvcihyZXN1bHQucG9zaXRpb24sIHJlc3VsdC5tZXNzYWdlKTtcbiAgcmV0dXJuIG5ldyBNYXJrUHJvY2Vzc29yKGlucHV0LCByZXN1bHQubWFya3MsIG9wdGlvbnMpLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbn1cbmNvbnN0IHsgY29tcGFyZSB9ID0gbmV3IEludGwuQ29sbGF0b3IoXCJlblwiKTtcbmZ1bmN0aW9uIHR5cGVOb2Rlc1NvcnRlcihhLCBiKSB7XG4gIHJldHVybiBhLnR5cGUgPT09IFwibnVsbFwiID8gMSA6IGNvbXBhcmUoaGFzaEZpZWxkKGEpLCBoYXNoRmllbGQoYikpO1xufVxuY29uc3QgaGFzaENhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBoYXNoRmllbGQoZmllbGQpIHtcbiAgaWYgKGhhc2hDYWNoZS5oYXMoZmllbGQpKVxuICAgIHJldHVybiBoYXNoQ2FjaGUuZ2V0KGZpZWxkKTtcbiAgY29uc3QgaGFzaCA9IGNhbGN1bGF0ZUZpZWxkSGFzaChmaWVsZCk7XG4gIHJldHVybiBoYXNoQ2FjaGUuc2V0KGZpZWxkLCBoYXNoKSwgaGFzaDtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUZpZWxkSGFzaChmaWVsZCkge1xuICBzd2l0Y2ggKGZpZWxkLnR5cGUpIHtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICByZXR1cm4gZmllbGQudmFsdWUgIT09IHZvaWQgMCA/IGAke2ZpZWxkLnR5cGV9KCR7ZmllbGQudmFsdWV9KWAgOiBgJHtmaWVsZC50eXBlfWA7XG4gICAgY2FzZSBcIm51bGxcIjpcbiAgICBjYXNlIFwidW5rbm93blwiOlxuICAgICAgcmV0dXJuIGZpZWxkLnR5cGU7XG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgICByZXR1cm4gYCR7ZmllbGQudHlwZX0oJHtoYXNoRmllbGQoZmllbGQub2YpfSlgO1xuICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IE9iamVjdC5lbnRyaWVzKGZpZWxkLmF0dHJpYnV0ZXMpO1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXMuc29ydCgoW2FdLCBbYl0pID0+IGNvbXBhcmUoYSwgYikpLCBgJHtmaWVsZC50eXBlfTooJHthdHRyaWJ1dGVzLm1hcChcbiAgICAgICAgKFtrZXksIHZhbHVlXSkgPT4gYCR7a2V5fToke2hhc2hGaWVsZCh2YWx1ZS52YWx1ZSl9KCR7dmFsdWUub3B0aW9uYWwgPyBcIm9wdGlvbmFsXCIgOiBcIm5vbi1vcHRpb25hbFwifSlgXG4gICAgICApLmpvaW4oXCIsXCIpfSk6cmVmLSR7ZmllbGQuZGVyZWZlcmVuY2VzVG99OiR7ZmllbGQucmVzdCA/IGhhc2hGaWVsZChmaWVsZC5yZXN0KSA6IFwibm8tcmVzdFwifWA7XG4gICAgfVxuICAgIGNhc2UgXCJ1bmlvblwiOiB7XG4gICAgICBjb25zdCBzb3J0ZWQgPSBbLi4uZmllbGQub2ZdO1xuICAgICAgcmV0dXJuIHNvcnRlZC5zb3J0KHR5cGVOb2Rlc1NvcnRlciksIGAke2ZpZWxkLnR5cGV9KCR7c29ydGVkLm1hcChoYXNoRmllbGQpLmpvaW4oXCIsXCIpfSlgO1xuICAgIH1cbiAgICBjYXNlIFwiaW5saW5lXCI6XG4gICAgICByZXR1cm4gYCR7ZmllbGQudHlwZX0oJHtmaWVsZC5uYW1lfSlgO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmllbGQudHlwZTtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlVHlwZU5vZGVzKHR5cGVOb2Rlcykge1xuICBjb25zdCBzZWVuVHlwZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLCBuZXdUeXBlTm9kZXMgPSBbXSwgc29ydGVkVHlwZU5vZGVzID0gWy4uLnR5cGVOb2Rlc107XG4gIHNvcnRlZFR5cGVOb2Rlcy5zb3J0KHR5cGVOb2Rlc1NvcnRlcik7XG4gIGZvciAoY29uc3QgdHlwZU5vZGUgb2Ygc29ydGVkVHlwZU5vZGVzKSB7XG4gICAgY29uc3QgaGFzaCA9IGhhc2hGaWVsZCh0eXBlTm9kZSk7XG4gICAgaWYgKGhhc2ggPT09IG51bGwpIHtcbiAgICAgIG5ld1R5cGVOb2Rlcy5wdXNoKHR5cGVOb2RlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBzZWVuVHlwZXMuaGFzKGhhc2gpIHx8IChzZWVuVHlwZXMuYWRkKGhhc2gpLCBuZXdUeXBlTm9kZXMucHVzaCh0eXBlTm9kZSkpO1xuICB9XG4gIHJldHVybiBuZXdUeXBlTm9kZXM7XG59XG5mdW5jdGlvbiBvcHRpbWl6ZVVuaW9ucyhmaWVsZCkge1xuICBpZiAoZmllbGQudHlwZSA9PT0gXCJ1bmlvblwiKSB7XG4gICAgaWYgKGZpZWxkLm9mLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiBmaWVsZDtcbiAgICBpZiAoZmllbGQub2YgPSByZW1vdmVEdXBsaWNhdGVUeXBlTm9kZXMoZmllbGQub2YpLCBmaWVsZC5vZi5sZW5ndGggPT09IDEpXG4gICAgICByZXR1cm4gb3B0aW1pemVVbmlvbnMoZmllbGQub2ZbMF0pO1xuICAgIGZvciAobGV0IGlkeCA9IDA7IGZpZWxkLm9mLmxlbmd0aCA+IGlkeDsgaWR4KyspIHtcbiAgICAgIGNvbnN0IHN1YkZpZWxkID0gZmllbGQub2ZbaWR4XTtcbiAgICAgIGlmIChzdWJGaWVsZC50eXBlID09PSBcInVuaW9uXCIpIHtcbiAgICAgICAgZmllbGQub2Yuc3BsaWNlKGlkeCwgMSwgLi4uc3ViRmllbGQub2YpLCBpZHgtLTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmaWVsZC5vZltpZHhdID0gb3B0aW1pemVVbmlvbnMoc3ViRmllbGQpO1xuICAgIH1cbiAgICByZXR1cm4gZmllbGQub2Yuc29ydCgoYSwgYikgPT4gYS50eXBlID09PSBcIm51bGxcIiA/IDEgOiBjb21wYXJlKGhhc2hGaWVsZChhKSwgaGFzaEZpZWxkKGIpKSksIGZpZWxkO1xuICB9XG4gIGlmIChmaWVsZC50eXBlID09PSBcImFycmF5XCIpXG4gICAgcmV0dXJuIGZpZWxkLm9mID0gb3B0aW1pemVVbmlvbnMoZmllbGQub2YpLCBmaWVsZDtcbiAgaWYgKGZpZWxkLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICBmb3IgKGNvbnN0IGlkeCBpbiBmaWVsZC5hdHRyaWJ1dGVzKVxuICAgICAgT2JqZWN0Lmhhc093bihmaWVsZC5hdHRyaWJ1dGVzLCBpZHgpICYmIChmaWVsZC5hdHRyaWJ1dGVzW2lkeF0udmFsdWUgPSBvcHRpbWl6ZVVuaW9ucyhmaWVsZC5hdHRyaWJ1dGVzW2lkeF0udmFsdWUpKTtcbiAgICByZXR1cm4gZmllbGQ7XG4gIH1cbiAgcmV0dXJuIGZpZWxkO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVmZXJlbmNlVHlwZU5vZGUobmFtZSwgaW5BcnJheSA9ICExKSB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSB7XG4gICAgX3JlZjoge1xuICAgICAgdHlwZTogXCJvYmplY3RBdHRyaWJ1dGVcIixcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIF90eXBlOiB7XG4gICAgICB0eXBlOiBcIm9iamVjdEF0dHJpYnV0ZVwiLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgdmFsdWU6IFwicmVmZXJlbmNlXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIF93ZWFrOiB7XG4gICAgICB0eXBlOiBcIm9iamVjdEF0dHJpYnV0ZVwiLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdHlwZTogXCJib29sZWFuXCJcbiAgICAgIH0sXG4gICAgICBvcHRpb25hbDogITBcbiAgICB9XG4gIH07XG4gIHJldHVybiBpbkFycmF5ICYmIChhdHRyaWJ1dGVzLl9rZXkgPSB7XG4gICAgdHlwZTogXCJvYmplY3RBdHRyaWJ1dGVcIixcbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgIH1cbiAgfSksIHtcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIGF0dHJpYnV0ZXMsXG4gICAgZGVyZWZlcmVuY2VzVG86IG5hbWVcbiAgfTtcbn1cbmZ1bmN0aW9uIG51bGxVbmlvbihub2RlKSB7XG4gIHJldHVybiBub2RlLnR5cGUgPT09IFwidW5pb25cIiA/IHVuaW9uT2YoLi4ubm9kZS5vZiwgeyB0eXBlOiBcIm51bGxcIiB9KSA6IHVuaW9uT2Yobm9kZSwgeyB0eXBlOiBcIm51bGxcIiB9KTtcbn1cbmZ1bmN0aW9uIHVuaW9uT2YoLi4ubm9kZXMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgb2Y6IG5vZGVzXG4gIH07XG59XG5mdW5jdGlvbiByZXNvbHZlSW5saW5lKG5vZGUsIHNjb3BlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IFwiaW5saW5lXCIpIHtcbiAgICBjb25zdCByZXNvbHZlZElubGluZSA9IHNjb3BlLmNvbnRleHQubG9va3VwVHlwZURlY2xhcmF0aW9uKG5vZGUpO1xuICAgIHJldHVybiByZXNvbHZlSW5saW5lKHJlc29sdmVkSW5saW5lLCBzY29wZSk7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBtYXBOb2RlKG5vZGUsIHNjb3BlLCBtYXBwZXIsIG1lcmdlVW5pb25zID0gKG5vZGVzKSA9PiBvcHRpbWl6ZVVuaW9ucyh7IHR5cGU6IFwidW5pb25cIiwgb2Y6IG5vZGVzIH0pKSB7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICBjYXNlIFwibnVsbFwiOlxuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgIGNhc2UgXCJ1bmtub3duXCI6XG4gICAgICByZXR1cm4gbWFwcGVyKG5vZGUpO1xuICAgIGNhc2UgXCJ1bmlvblwiOlxuICAgICAgcmV0dXJuIG1lcmdlVW5pb25zKG5vZGUub2YubWFwKChpbm5lcikgPT4gbWFwTm9kZShpbm5lciwgc2NvcGUsIG1hcHBlciksIG1lcmdlVW5pb25zKSk7XG4gICAgY2FzZSBcImlubGluZVwiOiB7XG4gICAgICBjb25zdCByZXNvbHZlZElubGluZSA9IHJlc29sdmVJbmxpbmUobm9kZSwgc2NvcGUpO1xuICAgICAgcmV0dXJuIG1hcE5vZGUocmVzb2x2ZWRJbmxpbmUsIHNjb3BlLCBtYXBwZXIsIG1lcmdlVW5pb25zKTtcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB0eXBlOiAke25vZGUudHlwZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNGdW5jQ2FsbChub2RlLCBuYW1lKSB7XG4gIHJldHVybiBub2RlLnR5cGUgPT09IFwiR3JvdXBcIiA/IGlzRnVuY0NhbGwobm9kZS5iYXNlLCBuYW1lKSA6IG5vZGUudHlwZSA9PT0gXCJGdW5jQ2FsbFwiICYmIGAke25vZGUubmFtZXNwYWNlfTo6JHtub2RlLm5hbWV9YCA9PT0gbmFtZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUdlb0pzb24odHlwZSA9IFwiUG9pbnRcIikge1xuICBsZXQgY29vcmRpbmF0ZUF0dHJpYnV0ZSA9IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgb2Y6IHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCJcbiAgICB9XG4gIH07XG4gIHJldHVybiB0eXBlID09PSBcIkxpbmVTdHJpbmdcIiAmJiAoY29vcmRpbmF0ZUF0dHJpYnV0ZSA9IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgb2Y6IHtcbiAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgIG9mOiB7XG4gICAgICAgIHR5cGU6IFwibnVtYmVyXCJcbiAgICAgIH1cbiAgICB9XG4gIH0pLCB0eXBlID09PSBcIlBvbHlnb25cIiAmJiAoY29vcmRpbmF0ZUF0dHJpYnV0ZSA9IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgb2Y6IHtcbiAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgIG9mOiB7XG4gICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgb2Y6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pLCB7XG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICB0eXBlOiB7XG4gICAgICAgIHR5cGU6IFwib2JqZWN0QXR0cmlidXRlXCIsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY29vcmRpbmF0ZXM6IHtcbiAgICAgICAgdHlwZTogXCJvYmplY3RBdHRyaWJ1dGVcIixcbiAgICAgICAgdmFsdWU6IGNvb3JkaW5hdGVBdHRyaWJ1dGVcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBib29sZWFuVmFsdWUobm9kZSwgc2NvcGUpIHtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwidW5rbm93blwiOlxuICAgICAgcmV0dXJuIHsgY2FuQmVUcnVlOiAhMCwgY2FuQmVGYWxzZTogITAsIGNhbkJlTnVsbDogITAgfTtcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgcmV0dXJuIG5vZGUudmFsdWUgPT09ICEwID8geyBjYW5CZVRydWU6ICEwLCBjYW5CZUZhbHNlOiAhMSwgY2FuQmVOdWxsOiAhMSB9IDogbm9kZS52YWx1ZSA9PT0gITEgPyB7IGNhbkJlVHJ1ZTogITEsIGNhbkJlRmFsc2U6ICEwLCBjYW5CZU51bGw6ICExIH0gOiB7IGNhbkJlVHJ1ZTogITAsIGNhbkJlRmFsc2U6ICEwLCBjYW5CZU51bGw6ICExIH07XG4gICAgY2FzZSBcInVuaW9uXCI6IHtcbiAgICAgIGNvbnN0IHZhbHVlID0geyBjYW5CZVRydWU6ICExLCBjYW5CZUZhbHNlOiAhMSwgY2FuQmVOdWxsOiAhMSB9O1xuICAgICAgZm9yIChjb25zdCBzdWIgb2Ygbm9kZS5vZikge1xuICAgICAgICBjb25zdCBtYXRjaDIgPSBib29sZWFuVmFsdWUoc3ViLCBzY29wZSk7XG4gICAgICAgIG1hdGNoMi5jYW5CZU51bGwgJiYgKHZhbHVlLmNhbkJlTnVsbCA9ICEwKSwgbWF0Y2gyLmNhbkJlVHJ1ZSAmJiAodmFsdWUuY2FuQmVUcnVlID0gITApLCBtYXRjaDIuY2FuQmVGYWxzZSAmJiAodmFsdWUuY2FuQmVGYWxzZSA9ICEwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY2FzZSBcImlubGluZVwiOiB7XG4gICAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVJbmxpbmUobm9kZSwgc2NvcGUpO1xuICAgICAgcmV0dXJuIGJvb2xlYW5WYWx1ZShyZXNvbHZlZCwgc2NvcGUpO1xuICAgIH1cbiAgICBjYXNlIFwibnVsbFwiOlxuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgcmV0dXJuIHsgY2FuQmVUcnVlOiAhMSwgY2FuQmVGYWxzZTogITEsIGNhbkJlTnVsbDogITAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIG5vZGUgdHlwZSAke25vZGUudHlwZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gYm9vbGVhbk9yKGxlZnQsIHJpZ2h0KSB7XG4gIHJldHVybiBsZWZ0LmNhbkJlVHJ1ZSAmJiAhbGVmdC5jYW5CZUZhbHNlICYmICFsZWZ0LmNhbkJlTnVsbCA/IGxlZnQgOiByaWdodC5jYW5CZVRydWUgJiYgIXJpZ2h0LmNhbkJlRmFsc2UgJiYgIXJpZ2h0LmNhbkJlTnVsbCA/IHJpZ2h0IDoge1xuICAgIC8vIEVpdGhlciBzaWRlIGNhbiBiZSB0cnVlIGZvciB0aGUgZXhwcmVzc2lvbiB0byBiZSB0cnVlXG4gICAgY2FuQmVUcnVlOiBsZWZ0LmNhbkJlVHJ1ZSB8fCByaWdodC5jYW5CZVRydWUsXG4gICAgLy8gQm90aCBzaWRlcyBtdXN0IGJlIGZhbHNlIGZvciB0aGUgZXhwcmVzc2lvbiB0byBiZSBmYWxzZVxuICAgIGNhbkJlRmFsc2U6IGxlZnQuY2FuQmVGYWxzZSAmJiByaWdodC5jYW5CZUZhbHNlLFxuICAgIC8vIGlmIGVpdGhlciBzaWRlIGNhbiBiZSBudWxsLCB0aGUgZXhwcmVzc2lvbiBjYW4gYmUgbnVsbCBpZiB0aGUgb3RoZXIgc2lkZSBjYW4ndCBvbmx5IGJlIHRydWVcbiAgICBjYW5CZU51bGw6IGxlZnQuY2FuQmVOdWxsIHx8IHJpZ2h0LmNhbkJlTnVsbFxuICB9O1xufVxuZnVuY3Rpb24gYm9vbGVhbkFuZChsZWZ0LCByaWdodCkge1xuICByZXR1cm4gbGVmdC5jYW5CZUZhbHNlICYmICFsZWZ0LmNhbkJlVHJ1ZSAmJiAhbGVmdC5jYW5CZU51bGwgPyBsZWZ0IDogcmlnaHQuY2FuQmVGYWxzZSAmJiAhcmlnaHQuY2FuQmVUcnVlICYmICFyaWdodC5jYW5CZU51bGwgPyByaWdodCA6IHtcbiAgICAvLyBCb3RoIHNpZGVzIG11c3QgYmUgdHJ1ZSBmb3IgdGhlIGV4cHJlc3Npb24gdG8gYmUgdHJ1ZVxuICAgIGNhbkJlVHJ1ZTogbGVmdC5jYW5CZVRydWUgJiYgcmlnaHQuY2FuQmVUcnVlLFxuICAgIC8vIGlmIGVpdGhlciBzaWRlIGNhbiBiZSBmYWxzZSwgdGhlIGV4cHJlc3Npb24gY2FuIGJlIGZhbHNlXG4gICAgY2FuQmVGYWxzZTogbGVmdC5jYW5CZUZhbHNlIHx8IHJpZ2h0LmNhbkJlRmFsc2UsXG4gICAgLy8gaWYgZWl0aGVyIHNpZGUgY2FuIGJlIG51bGwsIHRoZSBleHByZXNzaW9uIGNhbiBiZSBudWxsXG4gICAgY2FuQmVOdWxsOiBsZWZ0LmNhbkJlTnVsbCB8fCByaWdodC5jYW5CZU51bGxcbiAgfTtcbn1cbmZ1bmN0aW9uIGJvb2xlYW5JbnRlcnByZXRhdGlvblRvVHlwZU5vZGUoYm9vbCkge1xuICByZXR1cm4gYm9vbC5jYW5CZVRydWUgPyBib29sLmNhbkJlRmFsc2UgPyBib29sLmNhbkJlTnVsbCA/IG51bGxVbmlvbih7IHR5cGU6IFwiYm9vbGVhblwiIH0pIDogeyB0eXBlOiBcImJvb2xlYW5cIiB9IDogYm9vbC5jYW5CZU51bGwgPyBudWxsVW5pb24oeyB0eXBlOiBcImJvb2xlYW5cIiwgdmFsdWU6ICEwIH0pIDogeyB0eXBlOiBcImJvb2xlYW5cIiwgdmFsdWU6ICEwIH0gOiBib29sLmNhbkJlRmFsc2UgPyBib29sLmNhbkJlTnVsbCA/IG51bGxVbmlvbih7IHR5cGU6IFwiYm9vbGVhblwiLCB2YWx1ZTogITEgfSkgOiB7IHR5cGU6IFwiYm9vbGVhblwiLCB2YWx1ZTogITEgfSA6IHsgdHlwZTogXCJudWxsXCIgfTtcbn1cbmZ1bmN0aW9uIHVuaW9uV2l0aG91dE51bGwodW5pb25UeXBlTm9kZSkge1xuICByZXR1cm4gdW5pb25UeXBlTm9kZS50eXBlID09PSBcInVuaW9uXCIgPyB7XG4gICAgdHlwZTogXCJ1bmlvblwiLFxuICAgIG9mOiB1bmlvblR5cGVOb2RlLm9mLmZpbHRlcigodHlwZSkgPT4gdHlwZS50eXBlICE9PSBcIm51bGxcIilcbiAgfSA6IHVuaW9uVHlwZU5vZGU7XG59XG5mdW5jdGlvbiBoYW5kbGVGdW5jQ2FsbE5vZGUobm9kZSwgc2NvcGUpIHtcbiAgc3dpdGNoIChgJHtub2RlLm5hbWVzcGFjZX0uJHtub2RlLm5hbWV9YCkge1xuICAgIGNhc2UgXCJhcnJheS5jb21wYWN0XCI6IHtcbiAgICAgIGNvbnN0IGFyZyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoYXJnLCBzY29wZSwgKGFyZzIpID0+IHtcbiAgICAgICAgaWYgKGFyZzIudHlwZSA9PT0gXCJ1bmtub3duXCIpXG4gICAgICAgICAgcmV0dXJuIG51bGxVbmlvbih7IHR5cGU6IFwiYXJyYXlcIiwgb2Y6IHsgdHlwZTogXCJ1bmtub3duXCIgfSB9KTtcbiAgICAgICAgaWYgKGFyZzIudHlwZSAhPT0gXCJhcnJheVwiKVxuICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwibnVsbFwiIH07XG4gICAgICAgIGNvbnN0IG9mID0gbWFwTm9kZShhcmcyLm9mLCBzY29wZSwgKG9mMikgPT4gb2YyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgb2Y6IHVuaW9uV2l0aG91dE51bGwob2YpXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgY2FzZSBcImFycmF5LmpvaW5cIjoge1xuICAgICAgY29uc3QgYXJyYXlBcmcgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KSwgc2VwQXJnID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1sxXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShcbiAgICAgICAgYXJyYXlBcmcsXG4gICAgICAgIHNjb3BlLFxuICAgICAgICAoYXJyYXlBcmcyKSA9PiBtYXBOb2RlKHNlcEFyZywgc2NvcGUsIChzZXBBcmcyKSA9PiBhcnJheUFyZzIudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgc2VwQXJnMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwic3RyaW5nXCIgfSkgOiBhcnJheUFyZzIudHlwZSAhPT0gXCJhcnJheVwiIHx8IHNlcEFyZzIudHlwZSAhPT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IG1hcE5vZGUoYXJyYXlBcmcyLm9mLCBzY29wZSwgKG9mKSA9PiBvZi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwic3RyaW5nXCIgfSkgOiBvZi50eXBlICE9PSBcInN0cmluZ1wiICYmIG9mLnR5cGUgIT09IFwibnVtYmVyXCIgJiYgb2YudHlwZSAhPT0gXCJib29sZWFuXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiB7IHR5cGU6IFwic3RyaW5nXCIgfSkpXG4gICAgICApO1xuICAgIH1cbiAgICBjYXNlIFwiYXJyYXkudW5pcXVlXCI6IHtcbiAgICAgIGNvbnN0IGFyZyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoYXJnLCBzY29wZSwgKGFyZzIpID0+IGFyZzIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcImFycmF5XCIsIG9mOiB7IHR5cGU6IFwidW5rbm93blwiIH0gfSkgOiBhcmcyLnR5cGUgIT09IFwiYXJyYXlcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IGFyZzIpO1xuICAgIH1cbiAgICBjYXNlIFwiYXJyYXkuaW50ZXJzZWN0c1wiOiB7XG4gICAgICBjb25zdCBhcmcxID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSksIGFyZzIgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzFdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKFxuICAgICAgICBhcmcxLFxuICAgICAgICBzY29wZSxcbiAgICAgICAgKGFyZzEyKSA9PiBtYXBOb2RlKGFyZzIsIHNjb3BlLCAoYXJnMjIpID0+IGFyZzEyLnR5cGUgIT09IFwiYXJyYXlcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IGFyZzIyLnR5cGUgIT09IFwiYXJyYXlcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IHsgdHlwZTogXCJib29sZWFuXCIgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGNhc2UgXCJnbG9iYWwubG93ZXJcIjoge1xuICAgICAgY29uc3QgYXJnID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShhcmcsIHNjb3BlLCAoYXJnMikgPT4gYXJnMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwic3RyaW5nXCIgfSkgOiBhcmcyLnR5cGUgIT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiBhcmcyLnZhbHVlICE9PSB2b2lkIDAgPyB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIHZhbHVlOiBhcmcyLnZhbHVlLnRvTG93ZXJDYXNlKClcbiAgICAgIH0gOiB7IHR5cGU6IFwic3RyaW5nXCIgfSk7XG4gICAgfVxuICAgIGNhc2UgXCJnbG9iYWwudXBwZXJcIjoge1xuICAgICAgY29uc3QgYXJnID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShhcmcsIHNjb3BlLCAoYXJnMikgPT4gYXJnMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwic3RyaW5nXCIgfSkgOiBhcmcyLnR5cGUgIT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiBhcmcyLnZhbHVlICE9PSB2b2lkIDAgPyB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIHZhbHVlOiBhcmcyLnZhbHVlLnRvVXBwZXJDYXNlKClcbiAgICAgIH0gOiB7IHR5cGU6IFwic3RyaW5nXCIgfSk7XG4gICAgfVxuICAgIGNhc2UgXCJkYXRlVGltZS5ub3dcIjpcbiAgICAgIHJldHVybiB7IHR5cGU6IFwic3RyaW5nXCIgfTtcbiAgICBjYXNlIFwiZ2xvYmFsLm5vd1wiOlxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJzdHJpbmdcIiB9O1xuICAgIGNhc2UgXCJnbG9iYWwuZGVmaW5lZFwiOiB7XG4gICAgICBjb25zdCBhcmcgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKGFyZywgc2NvcGUsIChub2RlMikgPT4gbm9kZTIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyB7IHR5cGU6IFwiYm9vbGVhblwiIH0gOiB7IHR5cGU6IFwiYm9vbGVhblwiLCB2YWx1ZTogbm9kZTIudHlwZSAhPT0gXCJudWxsXCIgfSk7XG4gICAgfVxuICAgIGNhc2UgXCJnbG9iYWwucGF0aFwiOiB7XG4gICAgICBjb25zdCBhcmcgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKGFyZywgc2NvcGUsIChhcmcyKSA9PiBhcmcyLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJzdHJpbmdcIiB9KSA6IGFyZzIudHlwZSA9PT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogXCJzdHJpbmdcIiB9IDogeyB0eXBlOiBcIm51bGxcIiB9KTtcbiAgICB9XG4gICAgY2FzZSBcImdsb2JhbC5jb2FsZXNjZVwiOiB7XG4gICAgICBpZiAobm9kZS5hcmdzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJudWxsXCIgfTtcbiAgICAgIGNvbnN0IHR5cGVOb2RlcyA9IFtdO1xuICAgICAgbGV0IGNhbkJlTnVsbCA9ICEwO1xuICAgICAgZm9yIChjb25zdCBhcmcgb2Ygbm9kZS5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGFyZ05vZGUgPSBvcHRpbWl6ZVVuaW9ucyh3YWxrKHsgbm9kZTogYXJnLCBzY29wZSB9KSksIGFsbE51bGwgPSBhcmdOb2RlLnR5cGUgPT09IFwibnVsbFwiIHx8IGFyZ05vZGUudHlwZSA9PT0gXCJ1bmlvblwiICYmIGFyZ05vZGUub2YuZXZlcnkoKHQpID0+IHQudHlwZSA9PT0gXCJudWxsXCIpO1xuICAgICAgICBpZiAoY2FuQmVOdWxsID0gYWxsTnVsbCB8fCBhcmdOb2RlLnR5cGUgPT09IFwidW5rbm93blwiIHx8IGFyZ05vZGUudHlwZSA9PT0gXCJ1bmlvblwiICYmIGFyZ05vZGUub2Yuc29tZSgodCkgPT4gdC50eXBlID09PSBcIm51bGxcIiB8fCB0LnR5cGUgPT09IFwidW5rbm93blwiKSwgYWxsTnVsbCB8fCB0eXBlTm9kZXMucHVzaCh1bmlvbldpdGhvdXROdWxsKGFyZ05vZGUpKSwgIWNhbkJlTnVsbClcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYW5CZU51bGwgJiYgdHlwZU5vZGVzLnB1c2goeyB0eXBlOiBcIm51bGxcIiB9KSwge1xuICAgICAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgICAgIG9mOiB0eXBlTm9kZXNcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJnbG9iYWwuY291bnRcIjoge1xuICAgICAgY29uc3QgYXJnID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShhcmcsIHNjb3BlLCAoYXJnMikgPT4gYXJnMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwic3RyaW5nXCIgfSkgOiBhcmcyLnR5cGUgPT09IFwiYXJyYXlcIiA/IHsgdHlwZTogXCJudW1iZXJcIiB9IDogeyB0eXBlOiBcIm51bGxcIiB9KTtcbiAgICB9XG4gICAgY2FzZSBcImdsb2JhbC5kYXRlVGltZVwiOiB7XG4gICAgICBjb25zdCBhcmcgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKGFyZywgc2NvcGUsIChhcmcyKSA9PiBhcmcyLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJzdHJpbmdcIiB9KSA6IGFyZzIudHlwZSA9PT0gXCJzdHJpbmdcIiA/IG51bGxVbmlvbih7IHR5cGU6IFwic3RyaW5nXCIgfSkgOiB7IHR5cGU6IFwibnVsbFwiIH0pO1xuICAgIH1cbiAgICBjYXNlIFwiZ2xvYmFsLmxlbmd0aFwiOiB7XG4gICAgICBjb25zdCBhcmcgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKGFyZywgc2NvcGUsIChhcmcyKSA9PiBhcmcyLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IGFyZzIudHlwZSA9PT0gXCJhcnJheVwiIHx8IGFyZzIudHlwZSA9PT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogXCJudW1iZXJcIiB9IDogeyB0eXBlOiBcIm51bGxcIiB9KTtcbiAgICB9XG4gICAgY2FzZSBcImdsb2JhbC5yZWZlcmVuY2VzXCI6XG4gICAgICByZXR1cm4geyB0eXBlOiBcImJvb2xlYW5cIiB9O1xuICAgIGNhc2UgXCJnbG9iYWwucm91bmRcIjoge1xuICAgICAgY29uc3QgbnVtTm9kZSA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUobnVtTm9kZSwgc2NvcGUsIChudW0pID0+IHtcbiAgICAgICAgaWYgKG51bS50eXBlID09PSBcInVua25vd25cIilcbiAgICAgICAgICByZXR1cm4gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KTtcbiAgICAgICAgaWYgKG51bS50eXBlICE9PSBcIm51bWJlclwiKVxuICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwibnVsbFwiIH07XG4gICAgICAgIGlmIChub2RlLmFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgY29uc3QgcHJlY2lzaW9uTm9kZSA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMV0sIHNjb3BlIH0pO1xuICAgICAgICAgIHJldHVybiBtYXBOb2RlKHByZWNpc2lvbk5vZGUsIHNjb3BlLCAocHJlY2lzaW9uKSA9PiBwcmVjaXNpb24udHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcIm51bWJlclwiIH0pIDogcHJlY2lzaW9uLnR5cGUgIT09IFwibnVtYmVyXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiB7IHR5cGU6IFwibnVtYmVyXCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJudW1iZXJcIiB9O1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNhc2UgXCJnbG9iYWwuc3RyaW5nXCI6IHtcbiAgICAgIGNvbnN0IGFyZyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoYXJnLCBzY29wZSwgKG5vZGUyKSA9PiBub2RlMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwic3RyaW5nXCIgfSkgOiBub2RlMi50eXBlID09PSBcInN0cmluZ1wiIHx8IG5vZGUyLnR5cGUgPT09IFwibnVtYmVyXCIgfHwgbm9kZTIudHlwZSA9PT0gXCJib29sZWFuXCIgPyBub2RlMi52YWx1ZSA/IHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgdmFsdWU6IG5vZGUyLnZhbHVlLnRvU3RyaW5nKClcbiAgICAgIH0gOiB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH0gOiB7IHR5cGU6IFwibnVsbFwiIH0pO1xuICAgIH1cbiAgICBjYXNlIFwibWF0aC5zdW1cIjoge1xuICAgICAgY29uc3QgdmFsdWVzID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZSh2YWx1ZXMsIHNjb3BlLCAobm9kZTIpID0+IG5vZGUyLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IG5vZGUyLnR5cGUgIT09IFwiYXJyYXlcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IG1hcE5vZGUobm9kZTIub2YsIHNjb3BlLCAobm9kZTMpID0+IG5vZGUzLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IG5vZGUzLnR5cGUgPT09IFwibnVtYmVyXCIgfHwgbm9kZTMudHlwZSA9PT0gXCJudWxsXCIgPyB7IHR5cGU6IFwibnVtYmVyXCIgfSA6IHsgdHlwZTogXCJudWxsXCIgfSkpO1xuICAgIH1cbiAgICBjYXNlIFwibWF0aC5hdmdcIjoge1xuICAgICAgY29uc3QgdmFsdWVzID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZSh2YWx1ZXMsIHNjb3BlLCAobm9kZTIpID0+IG5vZGUyLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IG5vZGUyLnR5cGUgIT09IFwiYXJyYXlcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IG1hcE5vZGUobm9kZTIub2YsIHNjb3BlLCAobm9kZTMpID0+IG5vZGUzLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IG5vZGUzLnR5cGUgPT09IFwibnVtYmVyXCIgPyB7IHR5cGU6IFwibnVtYmVyXCIgfSA6IHsgdHlwZTogXCJudWxsXCIgfSkpO1xuICAgIH1cbiAgICBjYXNlIFwibWF0aC5tYXhcIjpcbiAgICBjYXNlIFwibWF0aC5taW5cIjoge1xuICAgICAgY29uc3QgdmFsdWVzID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZSh2YWx1ZXMsIHNjb3BlLCAobm9kZTIpID0+IG5vZGUyLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IG5vZGUyLnR5cGUgIT09IFwiYXJyYXlcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IG1hcE5vZGUobm9kZTIub2YsIHNjb3BlLCAobm9kZTMpID0+IG5vZGUzLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IG5vZGUzLnR5cGUgPT09IFwibnVtYmVyXCIgPyBub2RlMyA6IHsgdHlwZTogXCJudWxsXCIgfSkpO1xuICAgIH1cbiAgICBjYXNlIFwicHQudGV4dFwiOlxuICAgICAgcmV0dXJuIG5vZGUuYXJncy5sZW5ndGggPT09IDAgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH07XG4gICAgY2FzZSBcInN0cmluZy5zdGFydHNXaXRoXCI6IHtcbiAgICAgIGNvbnN0IHN0clR5cGVOb2RlID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSksIHByZWZpeFR5cGVOb2RlID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1sxXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShzdHJUeXBlTm9kZSwgc2NvcGUsIChzdHJOb2RlKSA9PiBtYXBOb2RlKHByZWZpeFR5cGVOb2RlLCBzY29wZSwgKHByZWZpeE5vZGUpID0+IHN0ck5vZGUudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgcHJlZml4Tm9kZS50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwiYm9vbGVhblwiIH0pIDogc3RyTm9kZS50eXBlICE9PSBcInN0cmluZ1wiIHx8IHByZWZpeE5vZGUudHlwZSAhPT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IHsgdHlwZTogXCJib29sZWFuXCIgfSkpO1xuICAgIH1cbiAgICBjYXNlIFwic3RyaW5nLnNwbGl0XCI6IHtcbiAgICAgIGNvbnN0IHN0clR5cGVOb2RlID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSksIHNlcFR5cGVOb2RlID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1sxXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShzdHJUeXBlTm9kZSwgc2NvcGUsIChzdHJOb2RlKSA9PiBtYXBOb2RlKHNlcFR5cGVOb2RlLCBzY29wZSwgKHNlcE5vZGUpID0+IHN0ck5vZGUudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgc2VwTm9kZS50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwiYXJyYXlcIiwgb2Y6IHsgdHlwZTogXCJzdHJpbmdcIiB9IH0pIDogc3RyTm9kZS50eXBlICE9PSBcInN0cmluZ1wiIHx8IHNlcE5vZGUudHlwZSAhPT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IHsgdHlwZTogXCJhcnJheVwiLCBvZjogeyB0eXBlOiBcInN0cmluZ1wiIH0gfSkpO1xuICAgIH1cbiAgICBjYXNlIFwiZ2VvLmxhdExuZ1wiOiB7XG4gICAgICBjb25zdCBsYXRUeXBlTm9kZSA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pLCBsbmdUeXBlTm9kZSA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMV0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUobGF0VHlwZU5vZGUsIHNjb3BlLCAobGF0Tm9kZSkgPT4gbWFwTm9kZShsbmdUeXBlTm9kZSwgc2NvcGUsIChsbmdOb2RlKSA9PiBsYXROb2RlLnR5cGUgPT0gXCJ1bmtub3duXCIgfHwgbG5nTm9kZS50eXBlID09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKGNyZWF0ZUdlb0pzb24oKSkgOiBsYXROb2RlLnR5cGUgIT09IFwibnVtYmVyXCIgfHwgbG5nTm9kZS50eXBlICE9PSBcIm51bWJlclwiID8geyB0eXBlOiBcIm51bGxcIiB9IDogbnVsbFVuaW9uKGNyZWF0ZUdlb0pzb24oKSkpKTtcbiAgICB9XG4gICAgY2FzZSBcImdlby5jb250YWluc1wiOlxuICAgICAgcmV0dXJuIG51bGxVbmlvbih7IHR5cGU6IFwiYm9vbGVhblwiIH0pO1xuICAgIGNhc2UgXCJnZW8uaW50ZXJzZWN0c1wiOlxuICAgICAgcmV0dXJuIG51bGxVbmlvbih7IHR5cGU6IFwiYm9vbGVhblwiIH0pO1xuICAgIGNhc2UgXCJnZW8uZGlzdGFuY2VcIjpcbiAgICAgIHJldHVybiBudWxsVW5pb24oeyB0eXBlOiBcIm51bWJlclwiIH0pO1xuICAgIGNhc2UgXCJzYW5pdHkudmVyc2lvbk9mXCI6IHtcbiAgICAgIGNvbnN0IHR5cGVOb2RlID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZSh0eXBlTm9kZSwgc2NvcGUsICh0eXBlTm9kZTIpID0+IHR5cGVOb2RlMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwiYm9vbGVhblwiIH0pIDogdHlwZU5vZGUyLnR5cGUgIT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiB7IHR5cGU6IFwiYm9vbGVhblwiIH0pO1xuICAgIH1cbiAgICBjYXNlIFwic2FuaXR5LnBhcnRPZlJlbGVhc2VcIjoge1xuICAgICAgY29uc3QgdHlwZU5vZGUgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKHR5cGVOb2RlLCBzY29wZSwgKHR5cGVOb2RlMikgPT4gdHlwZU5vZGUyLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJib29sZWFuXCIgfSkgOiB0eXBlTm9kZTIudHlwZSAhPT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IHsgdHlwZTogXCJib29sZWFuXCIgfSk7XG4gICAgfVxuICAgIGNhc2UgXCJkb2N1bWVudHMuZ2V0XCI6IHtcbiAgICAgIGNvbnN0IHR5cGVOb2RlID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZSh0eXBlTm9kZSwgc2NvcGUsICh0eXBlTm9kZTIpID0+IHR5cGVOb2RlMi50eXBlID09PSBcInVua25vd25cIiA/IHR5cGVOb2RlMiA6IHR5cGVOb2RlMi50eXBlICE9PSBcIm9iamVjdFwiID8geyB0eXBlOiBcIm51bGxcIiB9IDogeyB0eXBlOiBcInVua25vd25cIiB9KTtcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidW5rbm93blwiIH07XG4gIH1cbn1cbmZ1bmN0aW9uIG1hdGNoKGxlZnQsIHJpZ2h0KSB7XG4gIGxldCB0b2tlbnMgPSBbXSwgcGF0dGVybnMgPSBbXTtcbiAgaWYgKGxlZnQudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChsZWZ0LnZhbHVlID09PSB2b2lkIDApXG4gICAgICByZXR1cm47XG4gICAgdG9rZW5zID0gdG9rZW5zLmNvbmNhdChtYXRjaFRva2VuaXplKGxlZnQudmFsdWUpKTtcbiAgfVxuICBpZiAobGVmdC50eXBlID09PSBcImFycmF5XCIpIHtcbiAgICBpZiAobGVmdC5vZi50eXBlID09PSBcInVua25vd25cIilcbiAgICAgIHJldHVybjtcbiAgICBpZiAobGVmdC5vZi50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAobGVmdC5vZi52YWx1ZSA9PT0gdm9pZCAwKVxuICAgICAgICByZXR1cm47XG4gICAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KG1hdGNoVG9rZW5pemUobGVmdC5vZi52YWx1ZSkpO1xuICAgIH1cbiAgICBpZiAobGVmdC5vZi50eXBlID09PSBcInVuaW9uXCIpXG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgbGVmdC5vZi5vZilcbiAgICAgICAgbm9kZS50eXBlID09PSBcInN0cmluZ1wiICYmIG5vZGUudmFsdWUgIT09IHZvaWQgMCAmJiAodG9rZW5zID0gdG9rZW5zLmNvbmNhdChtYXRjaFRva2VuaXplKG5vZGUudmFsdWUpKSk7XG4gIH1cbiAgaWYgKHJpZ2h0LnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAocmlnaHQudmFsdWUgPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICBwYXR0ZXJucyA9IHBhdHRlcm5zLmNvbmNhdChtYXRjaEFuYWx5emVQYXR0ZXJuKHJpZ2h0LnZhbHVlKSk7XG4gIH1cbiAgaWYgKHJpZ2h0LnR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgIGlmIChyaWdodC5vZi50eXBlID09PSBcInVua25vd25cIilcbiAgICAgIHJldHVybjtcbiAgICBpZiAocmlnaHQub2YudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKHJpZ2h0Lm9mLnZhbHVlID09PSB2b2lkIDApXG4gICAgICAgIHJldHVybjtcbiAgICAgIHBhdHRlcm5zID0gcGF0dGVybnMuY29uY2F0KG1hdGNoQW5hbHl6ZVBhdHRlcm4ocmlnaHQub2YudmFsdWUpKTtcbiAgICB9XG4gICAgaWYgKHJpZ2h0Lm9mLnR5cGUgPT09IFwidW5pb25cIilcbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiByaWdodC5vZi5vZikge1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWYgKG5vZGUudmFsdWUgPT09IHZvaWQgMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBwYXR0ZXJucyA9IHBhdHRlcm5zLmNvbmNhdChtYXRjaEFuYWx5emVQYXR0ZXJuKG5vZGUudmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS50eXBlICE9PSBcInN0cmluZ1wiKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gbWF0Y2hUZXh0KHRva2VucywgcGF0dGVybnMpO1xufVxuY29uc3QgJHRyYWNlJDEgPSBkZWJ1ZyhcInR5cGVFdmFsdWF0b3I6c2NvcGU6dHJhY2VcIik7XG4kdHJhY2UkMS5sb2cgPSBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuY2xhc3MgQ29udGV4dCB7XG4gIHNjaGVtYTtcbiAgY29uc3RydWN0b3Ioc2NoZW1hKSB7XG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gIH1cbiAgbG9va3VwUmVmKHJlZlRvKSB7XG4gICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5zY2hlbWEpXG4gICAgICBpZiAodmFsLnR5cGUgPT09IFwiZG9jdW1lbnRcIiAmJiB2YWwubmFtZSA9PT0gcmVmVG8pXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB2YWwuYXR0cmlidXRlc1xuICAgICAgICB9O1xuICAgIHJldHVybiB7IHR5cGU6IFwibnVsbFwiIH07XG4gIH1cbiAgbG9va3VwVHlwZURlY2xhcmF0aW9uKGFsaWFzKSB7XG4gICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5zY2hlbWEpXG4gICAgICBpZiAodmFsLnR5cGUgPT09IFwidHlwZVwiICYmIHZhbC5uYW1lID09PSBhbGlhcy5uYW1lKVxuICAgICAgICByZXR1cm4gdmFsLnZhbHVlO1xuICAgIHJldHVybiB7IHR5cGU6IFwibnVsbFwiIH07XG4gIH1cbn1cbmNsYXNzIFNjb3BlMiB7XG4gIHZhbHVlO1xuICBwYXJlbnQ7XG4gIGNvbnRleHQ7XG4gIGlzSGlkZGVuO1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgcGFyZW50LCBjb250ZXh0KSB7XG4gICAgdGhpcy52YWx1ZSA9IHsgdHlwZTogXCJ1bmlvblwiLCBvZjogdmFsdWUgfSwgdGhpcy5wYXJlbnQgPSBwYXJlbnQsIHRoaXMuY29udGV4dCA9IGNvbnRleHQgfHwgcGFyZW50Py5jb250ZXh0IHx8IG5ldyBDb250ZXh0KFtdKSwgdGhpcy5pc0hpZGRlbiA9ICExO1xuICB9XG4gIGNyZWF0ZU5lc3RlZCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmlzSGlkZGVuID8gbmV3IFNjb3BlMih2YWx1ZSwgdGhpcy5wYXJlbnQsIHRoaXMuY29udGV4dCkgOiBuZXcgU2NvcGUyKHZhbHVlLCB0aGlzLCB0aGlzLmNvbnRleHQpO1xuICB9XG4gIGNyZWF0ZUhpZGRlbih2YWx1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY3JlYXRlTmVzdGVkKHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0LmlzSGlkZGVuID0gITAsIHJlc3VsdDtcbiAgfVxufVxuY29uc3QgJHRyYWNlID0gZGVidWcoXCJ0eXBlRXZhbHVhdG9yOmV2YWx1YXRlOnRyYWNlXCIpO1xuJHRyYWNlLmxvZyA9IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG5jb25zdCAkZGVidWcgPSBkZWJ1ZyhcInR5cGVFdmFsdWF0b3I6ZXZhbHVhdGU6ZGVidWdcIik7XG4kZGVidWcubG9nID0gY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbmNvbnN0ICR3YXJuID0gZGVidWcoXCJ0eXBlRXZhbHVhdG9yOmV2YWx1YXRlOndhcm5cIik7XG5mdW5jdGlvbiB0eXBlRXZhbHVhdGUoYXN0LCBzY2hlbWEpIHtcbiAgJGRlYnVnKFwiZXZhbHVhdGVRdWVyeVR5cGUuYXN0ICVPXCIsIGFzdCksICRkZWJ1ZyhcImV2YWx1YXRlUXVlcnlUeXBlLnNjaGVtYSAlT1wiLCBzY2hlbWEpO1xuICBjb25zdCBwYXJzZWQgPSB3YWxrKHtcbiAgICBub2RlOiBhc3QsXG4gICAgc2NvcGU6IG5ldyBTY29wZTIoW10sIHZvaWQgMCwgbmV3IENvbnRleHQoc2NoZW1hKSlcbiAgfSk7XG4gICR0cmFjZShcImV2YWx1YXRlUXVlcnlUeXBlLnBhcnNlZCAlT1wiLCBwYXJzZWQpO1xuICBjb25zdCBvcHRpbWl6ZWQgPSBvcHRpbWl6ZVVuaW9ucyhwYXJzZWQpO1xuICByZXR1cm4gJGRlYnVnKFwiZXZhbHVhdGVRdWVyeVR5cGUub3B0aW1pemVkICVPXCIsIG9wdGltaXplZCksIG9wdGltaXplZDtcbn1cbmZ1bmN0aW9uIG1hcERlcmVmKG5vZGUsIHNjb3BlKSB7XG4gIHJldHVybiBtYXBOb2RlKG5vZGUsIHNjb3BlLCAoYmFzZSkgPT4ge1xuICAgIGlmIChiYXNlLnR5cGUgPT09IFwiYXJyYXlcIilcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgb2Y6IG1hcERlcmVmKGJhc2Uub2YsIHNjb3BlKVxuICAgICAgfTtcbiAgICBpZiAoYmFzZS50eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBpZiAoYmFzZS5kZXJlZmVyZW5jZXNUbyAhPT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4gc2NvcGUuY29udGV4dC5sb29rdXBSZWYoYmFzZS5kZXJlZmVyZW5jZXNUbyk7XG4gICAgICBpZiAoYmFzZS5yZXN0ICE9PSB2b2lkIDApXG4gICAgICAgIHJldHVybiBtYXBEZXJlZihyZXNvbHZlSW5saW5lKGJhc2UucmVzdCwgc2NvcGUpLCBzY29wZSk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwibnVsbFwiIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gaGFuZGxlRGVyZWZOb2RlKG5vZGUsIHNjb3BlKSB7XG4gICR0cmFjZShcImRlcmVmLm5vZGUgJU9cIiwgbm9kZSk7XG4gIGNvbnN0IGRlcmVmZWROb2RlID0gbWFwRGVyZWYod2Fsayh7IG5vZGU6IG5vZGUuYmFzZSwgc2NvcGUgfSksIHNjb3BlKTtcbiAgcmV0dXJuICR0cmFjZShcImRlcmVmLmRlcmVmZWROb2RlICVPXCIsIGRlcmVmZWROb2RlKSwgZGVyZWZlZE5vZGU7XG59XG5mdW5jdGlvbiBoYW5kbGVPYmplY3RTcGxhdE5vZGUoYXR0ciwgc2NvcGUpIHtcbiAgY29uc3QgdmFsdWUgPSB3YWxrKHsgbm9kZTogYXR0ci52YWx1ZSwgc2NvcGUgfSk7XG4gIHJldHVybiAkdHJhY2UoXCJvYmplY3Quc3BsYXQudmFsdWUgJU9cIiwgdmFsdWUpLCBtYXBOb2RlKHZhbHVlLCBzY29wZSwgKG5vZGUpID0+IHtcbiAgICBpZiAobm9kZS50eXBlID09PSBcInVua25vd25cIilcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidW5rbm93blwiIH07XG4gICAgaWYgKG5vZGUudHlwZSAhPT0gXCJvYmplY3RcIilcbiAgICAgIHJldHVybiB7IHR5cGU6IFwib2JqZWN0XCIsIGF0dHJpYnV0ZXM6IHt9IH07XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiBub2RlLmF0dHJpYnV0ZXMpXG4gICAgICBub2RlLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgKGF0dHJpYnV0ZXNbbmFtZV0gPSBub2RlLmF0dHJpYnV0ZXNbbmFtZV0pO1xuICAgIGlmIChub2RlLnJlc3QgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgcmVzb2x2ZWRSZXN0ID0gcmVzb2x2ZUlubGluZShub2RlLnJlc3QsIHNjb3BlKTtcbiAgICAgIGlmIChyZXNvbHZlZFJlc3QudHlwZSA9PT0gXCJ1bmtub3duXCIpXG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwidW5rbm93blwiIH07XG4gICAgICBpZiAocmVzb2x2ZWRSZXN0LnR5cGUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwibnVsbFwiIH07XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gcmVzb2x2ZWRSZXN0LmF0dHJpYnV0ZXMpXG4gICAgICAgIHJlc29sdmVkUmVzdC5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIChhdHRyaWJ1dGVzW25hbWVdID0gcmVzb2x2ZWRSZXN0LmF0dHJpYnV0ZXNbbmFtZV0pO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcIm9iamVjdFwiLCBhdHRyaWJ1dGVzIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gaGFuZGxlT2JqZWN0Tm9kZShub2RlLCBzY29wZSkge1xuICBpZiAoJHRyYWNlKFwib2JqZWN0Lm5vZGUgJU9cIiwgbm9kZSksIG5vZGUuYXR0cmlidXRlcy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBhdHRyaWJ1dGVzOiB7fVxuICAgIH07XG4gIGNvbnN0IG9iamVjdEF0dHJpYnV0ZXMgPSBbXSwgc3BsYXRWYXJpYW50cyA9IFtdLCBjb25kaXRpb25hbFZhcmlhbnRzID0gW107XG4gIGZvciAoY29uc3QgW2lkeCwgYXR0cl0gb2Ygbm9kZS5hdHRyaWJ1dGVzLmVudHJpZXMoKSkge1xuICAgIGlmIChhdHRyLnR5cGUgPT09IFwiT2JqZWN0QXR0cmlidXRlVmFsdWVcIikge1xuICAgICAgY29uc3QgYXR0cmlidXRlTm9kZSA9IHdhbGsoeyBub2RlOiBhdHRyLnZhbHVlLCBzY29wZSB9KTtcbiAgICAgIG9iamVjdEF0dHJpYnV0ZXMucHVzaChbXG4gICAgICAgIGlkeCxcbiAgICAgICAgYXR0ci5uYW1lLFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJvYmplY3RBdHRyaWJ1dGVcIixcbiAgICAgICAgICB2YWx1ZTogYXR0cmlidXRlTm9kZVxuICAgICAgICB9XG4gICAgICBdKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYXR0ci50eXBlID09PSBcIk9iamVjdFNwbGF0XCIpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZU5vZGUgPSBoYW5kbGVPYmplY3RTcGxhdE5vZGUoYXR0ciwgc2NvcGUpO1xuICAgICAgc3dpdGNoICgkdHJhY2UoXCJvYmplY3Quc3BsYXQucmVzdWx0ICVPXCIsIGF0dHJpYnV0ZU5vZGUpLCBhdHRyaWJ1dGVOb2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICAgICAgc3BsYXRWYXJpYW50cy5wdXNoKFtpZHgsIGF0dHJpYnV0ZU5vZGVdKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwidW5pb25cIjoge1xuICAgICAgICAgIGZvciAoY29uc3Qgbm9kZTIgb2YgYXR0cmlidXRlTm9kZS5vZilcbiAgICAgICAgICAgIGlmIChub2RlMi50eXBlID09PSBcInVua25vd25cIilcbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGUyO1xuICAgICAgICAgIHNwbGF0VmFyaWFudHMucHVzaChbaWR4LCBhdHRyaWJ1dGVOb2RlXSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4geyB0eXBlOiBcInVua25vd25cIiB9O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXR0ci50eXBlID09PSBcIk9iamVjdENvbmRpdGlvbmFsU3BsYXRcIikge1xuICAgICAgY29uc3QgY29uZGl0aW9uID0gYm9vbGVhblZhbHVlKHdhbGsoeyBub2RlOiBhdHRyLmNvbmRpdGlvbiwgc2NvcGUgfSksIHNjb3BlKTtcbiAgICAgIGlmICgkdHJhY2UoXCJvYmplY3QuY29uZGl0aW9uYWwuc3BsYXQuY29uZGl0aW9uICVPXCIsIGNvbmRpdGlvbiksIGNvbmRpdGlvbi5jYW5CZVRydWUgPT09ICExKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZU5vZGUgPSBoYW5kbGVPYmplY3RTcGxhdE5vZGUoYXR0ciwgc2NvcGUpO1xuICAgICAgaWYgKCR0cmFjZShcIm9iamVjdC5jb25kaXRpb25hbC5zcGxhdC5yZXN1bHQgJU9cIiwgYXR0cmlidXRlTm9kZSksIGNvbmRpdGlvbi5jYW5CZUZhbHNlID09PSAhMSAmJiBjb25kaXRpb24uY2FuQmVOdWxsID09PSAhMSlcbiAgICAgICAgc3dpdGNoIChhdHRyaWJ1dGVOb2RlLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgICAgICAgIHNwbGF0VmFyaWFudHMucHVzaChbaWR4LCBhdHRyaWJ1dGVOb2RlXSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcInVuaW9uXCI6IHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgbm9kZTIgb2YgYXR0cmlidXRlTm9kZS5vZilcbiAgICAgICAgICAgICAgaWYgKG5vZGUyLnR5cGUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ1bmtub3duXCIgfTtcbiAgICAgICAgICAgIHNwbGF0VmFyaWFudHMucHVzaChbaWR4LCBhdHRyaWJ1dGVOb2RlXSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwidW5rbm93blwiIH07XG4gICAgICAgIH1cbiAgICAgIGNvbnN0IHZhcmlhbnQgPSBtYXBOb2RlKGF0dHJpYnV0ZU5vZGUsIHNjb3BlLCAoYXR0cmlidXRlTm9kZTIpID0+ICgkdHJhY2UoXCJvYmplY3QuY29uZGl0aW9uYWwuc3BsYXQucmVzdWx0LmNvbmNyZXRlICVPXCIsIGF0dHJpYnV0ZU5vZGUyKSwgYXR0cmlidXRlTm9kZTIudHlwZSAhPT0gXCJvYmplY3RcIiA/IHsgdHlwZTogXCJ1bmtub3duXCIgfSA6IHtcbiAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlTm9kZTIuYXR0cmlidXRlc1xuICAgICAgfSkpO1xuICAgICAgaWYgKHZhcmlhbnQudHlwZSA9PT0gXCJ1bmlvblwiKSB7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZTIgb2YgdmFyaWFudC5vZilcbiAgICAgICAgICBpZiAobm9kZTIudHlwZSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwidW5rbm93blwiIH07XG4gICAgICAgIHZhcmlhbnQub2YucHVzaCh7IHR5cGU6IFwib2JqZWN0XCIsIGF0dHJpYnV0ZXM6IHt9IH0pLCBjb25kaXRpb25hbFZhcmlhbnRzLnB1c2goW2lkeCwgdmFyaWFudF0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YXJpYW50LnR5cGUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwidW5rbm93blwiIH07XG4gICAgICBjb25kaXRpb25hbFZhcmlhbnRzLnB1c2goW1xuICAgICAgICBpZHgsXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgICAgICAgb2Y6IFt7IHR5cGU6IFwib2JqZWN0XCIsIGF0dHJpYnV0ZXM6IHt9IH0sIHZhcmlhbnRdXG4gICAgICAgIH1cbiAgICAgIF0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBvYmplY3QgYXR0cmlidXRlIHR5cGU6ICR7YXR0ci50eXBlfWApO1xuICB9XG4gIGNvbnN0IGd1YXJhbnRlZWRBdHRyaWJ1dGVzID0gW107XG4gIGd1YXJhbnRlZWRBdHRyaWJ1dGVzLnB1c2goLi4ub2JqZWN0QXR0cmlidXRlcyk7XG4gIGZvciAoY29uc3QgW2lkeCwgc3BsYXROb2RlXSBvZiBzcGxhdFZhcmlhbnRzKSB7XG4gICAgaWYgKHNwbGF0Tm9kZS50eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gc3BsYXROb2RlLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKCFzcGxhdE5vZGUuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlID0gc3BsYXROb2RlLmF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgIGd1YXJhbnRlZWRBdHRyaWJ1dGVzLnB1c2goW2lkeCwgbmFtZSwgYXR0cmlidXRlXSk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uZGl0aW9uYWxWYXJpYW50cy5wdXNoKFtpZHgsIHNwbGF0Tm9kZV0pO1xuICB9XG4gIGlmIChndWFyYW50ZWVkQXR0cmlidXRlcy5zb3J0KChbYV0sIFtiXSkgPT4gYSAtIGIpLCBjb25kaXRpb25hbFZhcmlhbnRzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgIGF0dHJpYnV0ZXM6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgZ3VhcmFudGVlZEF0dHJpYnV0ZXMubWFwKChbLCBuYW1lLCBhdHRyaWJ1dGVdKSA9PiBbbmFtZSwgYXR0cmlidXRlXSlcbiAgICAgIClcbiAgICB9O1xuICBjb25zdCBtYXRyaXggPSBbXTtcbiAgZm9yIChjb25zdCBbdW5pb25JZHgsIHVuaW9uXSBvZiBjb25kaXRpb25hbFZhcmlhbnRzKSB7XG4gICAgY29uc3QgdW5pb25HdWFyYW50ZWVkQmVmb3JlID0gW10sIHVuaW9uR3VhcmFudGVlZEFmdGVyID0gW107XG4gICAgZm9yIChjb25zdCBbZ3VhcmFudGVlZEluZGV4LCBuYW1lLCBhdHRyaWJ1dGVdIG9mIGd1YXJhbnRlZWRBdHRyaWJ1dGVzKVxuICAgICAgZ3VhcmFudGVlZEluZGV4IDwgdW5pb25JZHggJiYgdW5pb25HdWFyYW50ZWVkQmVmb3JlLnB1c2goW2d1YXJhbnRlZWRJbmRleCwgbmFtZSwgYXR0cmlidXRlXSksIGd1YXJhbnRlZWRJbmRleCA+IHVuaW9uSWR4ICYmIHVuaW9uR3VhcmFudGVlZEFmdGVyLnB1c2goW2d1YXJhbnRlZWRJbmRleCwgbmFtZSwgYXR0cmlidXRlXSk7XG4gICAgY29uc3QgYWxsVmFyaWFudHNBdHRyaWJ1dGVzID0gW107XG4gICAgZm9yIChjb25zdCBbY29uZGl0aW9uYWxWYXJpYW50SWR4LCBvdGhlclVuaW9uXSBvZiBjb25kaXRpb25hbFZhcmlhbnRzKSB7XG4gICAgICBjb25zdCB2YXJpYW50QXR0cmlidXRlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBub2RlMiBvZiBvdGhlclVuaW9uLm9mKVxuICAgICAgICB2YXJpYW50QXR0cmlidXRlcy5wdXNoKG5vZGUyLmF0dHJpYnV0ZXMpO1xuICAgICAgYWxsVmFyaWFudHNBdHRyaWJ1dGVzLnB1c2goW2NvbmRpdGlvbmFsVmFyaWFudElkeCwgdmFyaWFudEF0dHJpYnV0ZXNdKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBub2RlMiBvZiB1bmlvbi5vZikge1xuICAgICAgbWF0cml4LnB1c2goe1xuICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgICAgdW5pb25HdWFyYW50ZWVkQmVmb3JlLm1hcCgoWywgbmFtZSwgYXR0cmlidXRlXSkgPT4gW25hbWUsIGF0dHJpYnV0ZV0pXG4gICAgICAgICAgKSxcbiAgICAgICAgICAuLi5ub2RlMi5hdHRyaWJ1dGVzLFxuICAgICAgICAgIC4uLk9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgIHVuaW9uR3VhcmFudGVlZEFmdGVyLm1hcCgoWywgbmFtZSwgYXR0cmlidXRlXSkgPT4gW25hbWUsIGF0dHJpYnV0ZV0pXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGZvciAoY29uc3QgW291dGVySWR4LCBvdXRlckF0dHJpYnV0ZXNdIG9mIGFsbFZhcmlhbnRzQXR0cmlidXRlcylcbiAgICAgICAgZm9yIChjb25zdCBvdXRlciBvZiBvdXRlckF0dHJpYnV0ZXMpXG4gICAgICAgICAgZm9yIChjb25zdCBbaW5uZXJJZHgsIGlubmVyQXR0cmlidXRlc10gb2YgYWxsVmFyaWFudHNBdHRyaWJ1dGVzKVxuICAgICAgICAgICAgaWYgKG91dGVySWR4ICE9PSBpbm5lcklkeClcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBpbm5lciBvZiBpbm5lckF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBfYmVmb3JlID0gWy4uLnVuaW9uR3VhcmFudGVlZEJlZm9yZV0sIF9hZnRlciA9IFsuLi51bmlvbkd1YXJhbnRlZWRBZnRlcl07XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIG91dGVyKVxuICAgICAgICAgICAgICAgICAgb3V0ZXIuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgb3V0ZXJJZHggIT09IHVuaW9uSWR4ICYmIChvdXRlcklkeCA8IHVuaW9uSWR4ICYmIF9iZWZvcmUucHVzaChbb3V0ZXJJZHgsIG5hbWUsIG91dGVyW25hbWVdXSksIG91dGVySWR4ID4gdW5pb25JZHggJiYgX2FmdGVyLnB1c2goW291dGVySWR4LCBuYW1lLCBvdXRlcltuYW1lXV0pKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gaW5uZXIpXG4gICAgICAgICAgICAgICAgICBpbm5lci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBvdXRlcklkeCAhPT0gdW5pb25JZHggJiYgKGlubmVySWR4IDwgdW5pb25JZHggJiYgX2JlZm9yZS5wdXNoKFtpbm5lcklkeCwgbmFtZSwgaW5uZXJbbmFtZV1dKSwgaW5uZXJJZHggPiB1bmlvbklkeCAmJiBfYWZ0ZXIucHVzaChbaW5uZXJJZHgsIG5hbWUsIGlubmVyW25hbWVdXSkpO1xuICAgICAgICAgICAgICAgIF9iZWZvcmUuc29ydCgoW2FdLCBbYl0pID0+IGEgLSBiKSwgX2FmdGVyLnNvcnQoKFthXSwgW2JdKSA9PiBhIC0gYik7XG4gICAgICAgICAgICAgICAgY29uc3QgYmVmb3JlID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgICAgICAgICAgX2JlZm9yZS5tYXAoKFssIG5hbWUsIGF0dHJpYnV0ZV0pID0+IFtuYW1lLCBhdHRyaWJ1dGVdKVxuICAgICAgICAgICAgICAgICksIGFmdGVyID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgICAgICAgICAgX2FmdGVyLm1hcCgoWywgbmFtZSwgYXR0cmlidXRlXSkgPT4gW25hbWUsIGF0dHJpYnV0ZV0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBtYXRyaXgucHVzaCh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAuLi5iZWZvcmUsXG4gICAgICAgICAgICAgICAgICAgIC4uLm5vZGUyLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgIC4uLmFmdGVyXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGltaXplVW5pb25zKHtcbiAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgb2Y6IG1hdHJpeFxuICB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU9wQ2FsbE5vZGUobm9kZSwgc2NvcGUpIHtcbiAgJHRyYWNlKFwib3BjYWxsLm5vZGUgJU9cIiwgbm9kZSk7XG4gIGNvbnN0IGxocyA9IHdhbGsoeyBub2RlOiBub2RlLmxlZnQsIHNjb3BlIH0pLCByaHMgPSB3YWxrKHsgbm9kZTogbm9kZS5yaWdodCwgc2NvcGUgfSk7XG4gIHJldHVybiBtYXBOb2RlKFxuICAgIGxocyxcbiAgICBzY29wZSxcbiAgICAobGVmdCkgPT4gKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHksIG1heC1zdGF0ZW1lbnRzXG4gICAgICBtYXBOb2RlKHJocywgc2NvcGUsIChyaWdodCkgPT4ge1xuICAgICAgICBzd2l0Y2ggKCR0cmFjZSgnb3BjYWxsLm5vZGUuY29uY3JldGUgXCIlc1wiICVPJywgbm9kZS5vcCwgeyBsZWZ0LCByaWdodCB9KSwgbm9kZS5vcCkge1xuICAgICAgICAgIGNhc2UgXCI9PVwiOlxuICAgICAgICAgICAgcmV0dXJuIGxlZnQudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJ1bmtub3duXCIgPyB7IHR5cGU6IFwiYm9vbGVhblwiIH0gOiBsZWZ0LnR5cGUgIT09IHJpZ2h0LnR5cGUgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICB2YWx1ZTogITFcbiAgICAgICAgICAgIH0gOiBsZWZ0LnR5cGUgPT09IFwibnVsbFwiID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICB9IDogIWlzUHJpbWl0aXZlVHlwZU5vZGUobGVmdCkgfHwgIWlzUHJpbWl0aXZlVHlwZU5vZGUocmlnaHQpID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgdmFsdWU6ICExXG4gICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgdmFsdWU6IGV2YWx1YXRlQ29tcGFyaXNvbihub2RlLm9wLCBsZWZ0LCByaWdodClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgY2FzZSBcIiE9XCI6IHtcbiAgICAgICAgICAgIGlmIChsZWZ0LnR5cGUgPT09IFwidW5rbm93blwiIHx8IHJpZ2h0LnR5cGUgPT09IFwidW5rbm93blwiKVxuICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImJvb2xlYW5cIiB9O1xuICAgICAgICAgICAgaWYgKGxlZnQudHlwZSAhPT0gcmlnaHQudHlwZSlcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogITBcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChsZWZ0LnR5cGUgPT09IFwibnVsbFwiKVxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAhMVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCFpc1ByaW1pdGl2ZVR5cGVOb2RlKGxlZnQpIHx8ICFpc1ByaW1pdGl2ZVR5cGVOb2RlKHJpZ2h0KSlcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogITBcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGV2YWx1YXRlQ29tcGFyaXNvbihcIj09XCIsIGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdm9pZCAwICYmICh2YWx1ZSA9ICF2YWx1ZSksIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiPlwiOlxuICAgICAgICAgIGNhc2UgXCI+PVwiOlxuICAgICAgICAgIGNhc2UgXCI8XCI6XG4gICAgICAgICAgY2FzZSBcIjw9XCI6XG4gICAgICAgICAgICByZXR1cm4gbGVmdC50eXBlID09PSBcInVua25vd25cIiB8fCByaWdodC50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwiYm9vbGVhblwiIH0pIDogbGVmdC50eXBlICE9PSByaWdodC50eXBlID8geyB0eXBlOiBcIm51bGxcIiB9IDogIWlzUHJpbWl0aXZlVHlwZU5vZGUobGVmdCkgfHwgIWlzUHJpbWl0aXZlVHlwZU5vZGUocmlnaHQpID8geyB0eXBlOiBcIm51bGxcIiB9IDoge1xuICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgdmFsdWU6IGV2YWx1YXRlQ29tcGFyaXNvbihub2RlLm9wLCBsZWZ0LCByaWdodClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgY2FzZSBcImluXCI6XG4gICAgICAgICAgICByZXR1cm4gbGVmdC50eXBlID09PSBcInVua25vd25cIiB8fCByaWdodC50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwiYm9vbGVhblwiIH0pIDogcmlnaHQudHlwZSAhPT0gXCJhcnJheVwiID8gaXNGdW5jQ2FsbChub2RlLnJpZ2h0LCBcImdsb2JhbDo6cGF0aFwiKSA/IHsgdHlwZTogXCJib29sZWFuXCIgfSA6IHsgdHlwZTogXCJudWxsXCIgfSA6ICFpc1ByaW1pdGl2ZVR5cGVOb2RlKGxlZnQpICYmIGxlZnQudHlwZSAhPT0gXCJudWxsXCIgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICB2YWx1ZTogITFcbiAgICAgICAgICAgIH0gOiBtYXBOb2RlKHJpZ2h0Lm9mLCBzY29wZSwgKGFycmF5VHlwZU5vZGUpID0+IGFycmF5VHlwZU5vZGUudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcImJvb2xlYW5cIiB9KSA6IGxlZnQudHlwZSA9PT0gXCJudWxsXCIgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICB2YWx1ZTogYXJyYXlUeXBlTm9kZS50eXBlID09PSBcIm51bGxcIlxuICAgICAgICAgICAgfSA6IGxlZnQudmFsdWUgPT09IHZvaWQgMCA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCJcbiAgICAgICAgICAgIH0gOiBpc1ByaW1pdGl2ZVR5cGVOb2RlKGFycmF5VHlwZU5vZGUpID8gYXJyYXlUeXBlTm9kZS52YWx1ZSA9PT0gdm9pZCAwID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIlxuICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBsZWZ0LnZhbHVlID09PSBhcnJheVR5cGVOb2RlLnZhbHVlXG4gICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgdmFsdWU6ICExXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBjYXNlIFwibWF0Y2hcIjpcbiAgICAgICAgICAgIHJldHVybiBsZWZ0LnR5cGUgPT09IFwidW5rbm93blwiIHx8IHJpZ2h0LnR5cGUgPT09IFwidW5rbm93blwiID8geyB0eXBlOiBcImJvb2xlYW5cIiB9IDoge1xuICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgdmFsdWU6IG1hdGNoKGxlZnQsIHJpZ2h0KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgICAgcmV0dXJuIGxlZnQudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJ1bmtub3duXCIgPyB7IHR5cGU6IFwidW5rbm93blwiIH0gOiBsZWZ0LnR5cGUgPT09IFwic3RyaW5nXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJzdHJpbmdcIiA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGxlZnQudmFsdWUgIT09IHZvaWQgMCAmJiByaWdodC52YWx1ZSAhPT0gdm9pZCAwID8gbGVmdC52YWx1ZSArIHJpZ2h0LnZhbHVlIDogdm9pZCAwXG4gICAgICAgICAgICB9IDogbGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBsZWZ0LnZhbHVlICE9PSB2b2lkIDAgJiYgcmlnaHQudmFsdWUgIT09IHZvaWQgMCA/IGxlZnQudmFsdWUgKyByaWdodC52YWx1ZSA6IHZvaWQgMFxuICAgICAgICAgICAgfSA6IGxlZnQudHlwZSA9PT0gXCJhcnJheVwiICYmIHJpZ2h0LnR5cGUgPT09IFwiYXJyYXlcIiA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICBvZjoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidW5pb25cIixcbiAgICAgICAgICAgICAgICBvZjogW2xlZnQub2YsIHJpZ2h0Lm9mXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IDogbGVmdC50eXBlID09PSBcIm9iamVjdFwiICYmIHJpZ2h0LnR5cGUgPT09IFwib2JqZWN0XCIgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHsgLi4ubGVmdC5hdHRyaWJ1dGVzLCAuLi5yaWdodC5hdHRyaWJ1dGVzIH1cbiAgICAgICAgICAgIH0gOiB7IHR5cGU6IFwibnVsbFwiIH07XG4gICAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgICAgIHJldHVybiBsZWZ0LnR5cGUgPT09IFwidW5rbm93blwiIHx8IHJpZ2h0LnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IGxlZnQudHlwZSA9PT0gXCJudW1iZXJcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICB2YWx1ZTogbGVmdC52YWx1ZSAhPT0gdm9pZCAwICYmIHJpZ2h0LnZhbHVlICE9PSB2b2lkIDAgPyBsZWZ0LnZhbHVlIC0gcmlnaHQudmFsdWUgOiB2b2lkIDBcbiAgICAgICAgICAgIH0gOiB7IHR5cGU6IFwibnVsbFwiIH07XG4gICAgICAgICAgY2FzZSBcIipcIjpcbiAgICAgICAgICAgIHJldHVybiBsZWZ0LnR5cGUgPT09IFwidW5rbm93blwiIHx8IHJpZ2h0LnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IGxlZnQudHlwZSA9PT0gXCJudW1iZXJcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICB2YWx1ZTogbGVmdC52YWx1ZSAhPT0gdm9pZCAwICYmIHJpZ2h0LnZhbHVlICE9PSB2b2lkIDAgPyBsZWZ0LnZhbHVlICogcmlnaHQudmFsdWUgOiB2b2lkIDBcbiAgICAgICAgICAgIH0gOiB7IHR5cGU6IFwibnVsbFwiIH07XG4gICAgICAgICAgY2FzZSBcIi9cIjpcbiAgICAgICAgICAgIHJldHVybiBsZWZ0LnR5cGUgPT09IFwidW5rbm93blwiIHx8IHJpZ2h0LnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IGxlZnQudHlwZSA9PT0gXCJudW1iZXJcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICB2YWx1ZTogbGVmdC52YWx1ZSAhPT0gdm9pZCAwICYmIHJpZ2h0LnZhbHVlICE9PSB2b2lkIDAgPyBsZWZ0LnZhbHVlIC8gcmlnaHQudmFsdWUgOiB2b2lkIDBcbiAgICAgICAgICAgIH0gOiB7IHR5cGU6IFwibnVsbFwiIH07XG4gICAgICAgICAgY2FzZSBcIioqXCI6XG4gICAgICAgICAgICByZXR1cm4gbGVmdC50eXBlID09PSBcInVua25vd25cIiB8fCByaWdodC50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIiA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGxlZnQudmFsdWUgIT09IHZvaWQgMCAmJiByaWdodC52YWx1ZSAhPT0gdm9pZCAwID8gbGVmdC52YWx1ZSAqKiByaWdodC52YWx1ZSA6IHZvaWQgMFxuICAgICAgICAgICAgfSA6IHsgdHlwZTogXCJudWxsXCIgfTtcbiAgICAgICAgICBjYXNlIFwiJVwiOlxuICAgICAgICAgICAgcmV0dXJuIGxlZnQudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcIm51bWJlclwiIH0pIDogbGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBsZWZ0LnZhbHVlICE9PSB2b2lkIDAgJiYgcmlnaHQudmFsdWUgIT09IHZvaWQgMCA/IGxlZnQudmFsdWUgJSByaWdodC52YWx1ZSA6IHZvaWQgMFxuICAgICAgICAgICAgfSA6IHsgdHlwZTogXCJudWxsXCIgfTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ1bmtub3duXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gaGFuZGxlU2VsZWN0Tm9kZShub2RlLCBzY29wZSkge1xuICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgbGV0IGd1YXJhbnRlZWQgPSAhMTtcbiAgZm9yIChjb25zdCBhbHRlcm5hdGl2ZSBvZiBub2RlLmFsdGVybmF0aXZlcykge1xuICAgIGNvbnN0IGNvbmRpdGlvblZhbHVlID0gd2Fsayh7IG5vZGU6IGFsdGVybmF0aXZlLmNvbmRpdGlvbiwgc2NvcGUgfSksIGNvbmRpdGlvblNjb3BlID0gcmVzb2x2ZUZpbHRlcihhbHRlcm5hdGl2ZS5jb25kaXRpb24sIHNjb3BlKTtcbiAgICBjb25kaXRpb25TY29wZS50eXBlID09PSBcInVuaW9uXCIgJiYgY29uZGl0aW9uU2NvcGUub2YubGVuZ3RoID4gMCAmJiB2YWx1ZXMucHVzaCh3YWxrKHsgbm9kZTogYWx0ZXJuYXRpdmUudmFsdWUsIHNjb3BlOiBzY29wZS5jcmVhdGVIaWRkZW4oY29uZGl0aW9uU2NvcGUub2YpIH0pKSwgY29uZGl0aW9uVmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgY29uZGl0aW9uVmFsdWUudmFsdWUgPT09ICEwICYmIChndWFyYW50ZWVkID0gITApO1xuICB9XG4gIHJldHVybiBub2RlLmZhbGxiYWNrICYmICFndWFyYW50ZWVkICYmIHZhbHVlcy5wdXNoKHdhbGsoeyBub2RlOiBub2RlLmZhbGxiYWNrLCBzY29wZSB9KSksIHZhbHVlcy5sZW5ndGggPT09IDAgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiB7XG4gICAgdHlwZTogXCJ1bmlvblwiLFxuICAgIG9mOiB2YWx1ZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUFycmF5Q29lcmNlTm9kZShub2RlLCBzY29wZSkge1xuICBjb25zdCBiYXNlID0gd2Fsayh7IG5vZGU6IG5vZGUuYmFzZSwgc2NvcGUgfSk7XG4gIHJldHVybiAkdHJhY2UoXCJhcnJheUNvZXJjZS5iYXNlICVPXCIsIGJhc2UpLCBtYXBBcnJheShiYXNlLCBzY29wZSwgKGJhc2UyKSA9PiBiYXNlMik7XG59XG5mdW5jdGlvbiBoYW5kbGVGbGF0TWFwKG5vZGUsIHNjb3BlKSB7XG4gIGNvbnN0IGJhc2UgPSB3YWxrKHsgbm9kZTogbm9kZS5iYXNlLCBzY29wZSB9KTtcbiAgcmV0dXJuIG1hcEFycmF5KGJhc2UsIHNjb3BlLCAoYmFzZTIpID0+IHtcbiAgICBjb25zdCBpbm5lciA9IHdhbGsoeyBub2RlOiBub2RlLmV4cHIsIHNjb3BlOiBzY29wZS5jcmVhdGVIaWRkZW4oW2Jhc2UyLm9mXSkgfSk7XG4gICAgcmV0dXJuIG1hcE5vZGUoXG4gICAgICBpbm5lcixcbiAgICAgIHNjb3BlLFxuICAgICAgKGlubmVyMikgPT4gaW5uZXIyLnR5cGUgPT09IFwiYXJyYXlcIiA/IGlubmVyMiA6IHsgdHlwZTogXCJhcnJheVwiLCBvZjogaW5uZXIyIH0sXG4gICAgICAobm9kZXMpID0+IHtcbiAgICAgICAgY29uc3QgaW5uZXIyID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZTIgb2Ygbm9kZXMpIHtcbiAgICAgICAgICBpZiAobm9kZTIudHlwZSA9PT0gXCJ1bmtub3duXCIpIHJldHVybiB7IHR5cGU6IFwiYXJyYXlcIiwgb2Y6IG5vZGUyIH07XG4gICAgICAgICAgaWYgKG5vZGUyLnR5cGUgIT09IFwiYXJyYXlcIikgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHR5cGU6ICR7bm9kZTIudHlwZX1gKTtcbiAgICAgICAgICBpbm5lcjIucHVzaChub2RlMi5vZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgb2Y6IG9wdGltaXplVW5pb25zKHsgdHlwZTogXCJ1bmlvblwiLCBvZjogaW5uZXIyIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVNYXAobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgYmFzZSA9IHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICByZXR1cm4gJHRyYWNlKFwibWFwLmJhc2UgJU9cIiwgYmFzZSksIG1hcEFycmF5KGJhc2UsIHNjb3BlLCAoYmFzZTIpID0+ICh7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIG9mOiB3YWxrKHsgbm9kZTogbm9kZS5leHByLCBzY29wZTogc2NvcGUuY3JlYXRlSGlkZGVuKFtiYXNlMi5vZl0pIH0pXG4gIH0pKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVByb2plY3Rpb25Ob2RlKG5vZGUsIHNjb3BlKSB7XG4gIGNvbnN0IGJhc2UgPSB3YWxrKHsgbm9kZTogbm9kZS5iYXNlLCBzY29wZSB9KTtcbiAgcmV0dXJuICR0cmFjZShcInByb2plY3Rpb24uYmFzZSAlT1wiLCBiYXNlKSwgbWFwT2JqZWN0KFxuICAgIGJhc2UsXG4gICAgc2NvcGUsXG4gICAgKGJhc2UyKSA9PiB3YWxrKHsgbm9kZTogbm9kZS5leHByLCBzY29wZTogc2NvcGUuY3JlYXRlTmVzdGVkKFtiYXNlMl0pIH0pXG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWx0ZXJTY29wZShiYXNlLCBzY29wZSkge1xuICByZXR1cm4gYmFzZS50eXBlID09PSBcImFycmF5XCIgPyBiYXNlLm9mLnR5cGUgPT09IFwidW5pb25cIiA/IHNjb3BlLmNyZWF0ZU5lc3RlZChiYXNlLm9mLm9mKSA6IHNjb3BlLmNyZWF0ZU5lc3RlZChbYmFzZS5vZl0pIDogc2NvcGUuY3JlYXRlTmVzdGVkKFtiYXNlXSk7XG59XG5mdW5jdGlvbiBoYW5kbGVGaWx0ZXJOb2RlKG5vZGUsIHNjb3BlKSB7XG4gIGNvbnN0IGJhc2UgPSB3YWxrKHsgbm9kZTogbm9kZS5iYXNlLCBzY29wZSB9KTtcbiAgcmV0dXJuICR0cmFjZShcImZpbHRlci5iYXNlICVPXCIsIGJhc2UpLCBtYXBOb2RlKGJhc2UsIHNjb3BlLCAoYmFzZTIpID0+IHtcbiAgICBpZiAoJHRyYWNlKFwiZmlsdGVyLnJlc29sdmluZyAlT1wiLCBiYXNlMiksIGJhc2UyLnR5cGUgPT09IFwibnVsbFwiKVxuICAgICAgcmV0dXJuIGJhc2UyO1xuICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZUZpbHRlcihub2RlLmV4cHIsIGNyZWF0ZUZpbHRlclNjb3BlKGJhc2UyLCBzY29wZSkpO1xuICAgIHJldHVybiAkdHJhY2UoXCJmaWx0ZXIucmVzb2x2ZWQgJU9cIiwgcmVzb2x2ZWQpLCB7XG4gICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICBvZjogcmVzb2x2ZWRcbiAgICB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUFjY2Vzc0F0dHJpYnV0ZU5vZGUobm9kZSwgc2NvcGUpIHtcbiAgbGV0IGF0dHJpYnV0ZUJhc2UgPSBzY29wZS52YWx1ZTtcbiAgcmV0dXJuIG5vZGUuYmFzZSAmJiAoYXR0cmlidXRlQmFzZSA9IHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pKSwgJHRyYWNlKFwiYWNjZXNzQXR0cmlidXRlLmJhc2UgJXMgJU9cIiwgbm9kZS5uYW1lLCBhdHRyaWJ1dGVCYXNlKSwgaGFuZGxlQWNjZXNzQXR0cmlidXRlQmFzZShhdHRyaWJ1dGVCYXNlLCBub2RlLm5hbWUsIHNjb3BlKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUFjY2Vzc0F0dHJpYnV0ZUJhc2UoYmFzZSwgbmFtZSwgc2NvcGUpIHtcbiAgcmV0dXJuIG1hcE9iamVjdChiYXNlLCBzY29wZSwgKGJhc2UyKSA9PiB7XG4gICAgJHRyYWNlKCdMb29raW5nIGZvciBhdHRyaWJ1dGUgXCIlc1wiIGluIG9iamVjdCAlTycsIG5hbWUsIGJhc2UyKTtcbiAgICBjb25zdCBhdHRyaWJ1dGUgPSBiYXNlMi5hdHRyaWJ1dGVzW25hbWVdO1xuICAgIHJldHVybiBhdHRyaWJ1dGUgIT09IHZvaWQgMCA/ICgkZGVidWcoYGFjY2Vzc0F0dHJpYnV0ZS5hdHRyaWJ1dGUgZm91bmQgJHtuYW1lfSAlT2AsIGF0dHJpYnV0ZSksIGF0dHJpYnV0ZS5vcHRpb25hbCA/IG51bGxVbmlvbihhdHRyaWJ1dGUudmFsdWUpIDogYXR0cmlidXRlLnZhbHVlKSA6IGJhc2UyLnJlc3QgPyBoYW5kbGVBY2Nlc3NBdHRyaWJ1dGVCYXNlKGJhc2UyLnJlc3QsIG5hbWUsIHNjb3BlKSA6ICgkd2FybihgYXR0cmlidXRlIFwiJHtuYW1lfVwiIG5vdCBmb3VuZCBpbiBvYmplY3RgKSwgeyB0eXBlOiBcIm51bGxcIiB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVBY2Nlc3NFbGVtZW50Tm9kZShub2RlLCBzY29wZSkge1xuICBjb25zdCBiYXNlID0gd2Fsayh7IG5vZGU6IG5vZGUuYmFzZSwgc2NvcGUgfSk7XG4gIHJldHVybiAkdHJhY2UoXCJhY2Nlc3NFbGVtZW50LmJhc2UgJU9cIiwgYmFzZSksIG1hcEFycmF5KGJhc2UsIHNjb3BlLCAoYmFzZTIpID0+IG51bGxVbmlvbihiYXNlMi5vZikpO1xufVxuZnVuY3Rpb24gaGFuZGxlQXJyYXlOb2RlKG5vZGUsIHNjb3BlKSB7XG4gIGNvbnN0IG9mID0gW107XG4gIGZvciAoY29uc3QgZWwgb2Ygbm9kZS5lbGVtZW50cykge1xuICAgIGNvbnN0IG5vZGUyID0gd2Fsayh7IG5vZGU6IGVsLnZhbHVlLCBzY29wZSB9KTtcbiAgICBub2RlMiAhPT0gbnVsbCAmJiBvZi5wdXNoKG5vZGUyKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBvZjoge1xuICAgICAgdHlwZTogXCJ1bmlvblwiLFxuICAgICAgb2ZcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBoYW5kbGVWYWx1ZU5vZGUobm9kZSwgc2NvcGUpIHtcbiAgaWYgKG5vZGUudmFsdWUgPT09IG51bGwpXG4gICAgcmV0dXJuIHsgdHlwZTogXCJudWxsXCIgfTtcbiAgc3dpdGNoICh0eXBlb2Ygbm9kZS52YWx1ZSkge1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIHZhbHVlOiBub2RlLnZhbHVlXG4gICAgICB9O1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgIHZhbHVlOiBub2RlLnZhbHVlXG4gICAgICB9O1xuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgdmFsdWU6IG5vZGUudmFsdWVcbiAgICAgIH07XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgcmV0dXJuIG5vZGUudmFsdWUgPT09IG51bGwgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiBBcnJheS5pc0FycmF5KG5vZGUudmFsdWUpID8ge1xuICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgIG9mOiB7XG4gICAgICAgICAgdHlwZTogXCJ1bmlvblwiLFxuICAgICAgICAgIG9mOiBub2RlLnZhbHVlLm1hcCgodmFsdWUpID0+IHdhbGsoeyBub2RlOiB7IHR5cGU6IFwiVmFsdWVcIiwgdmFsdWUgfSwgc2NvcGUgfSkpXG4gICAgICAgIH1cbiAgICAgIH0gOiB7XG4gICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgIGF0dHJpYnV0ZXM6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhub2RlLnZhbHVlKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdEF0dHJpYnV0ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogd2Fsayh7IG5vZGU6IHsgdHlwZTogXCJWYWx1ZVwiLCB2YWx1ZSB9LCBzY29wZSB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0pXG4gICAgICAgIClcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidW5rbm93blwiIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZVNsaWNlKG5vZGUsIHNjb3BlKSB7XG4gICR0cmFjZShcInNsaWNlLm5vZGUgJU9cIiwgbm9kZSk7XG4gIGNvbnN0IGJhc2UgPSB3YWxrKHsgbm9kZTogbm9kZS5iYXNlLCBzY29wZSB9KTtcbiAgcmV0dXJuIG1hcEFycmF5KGJhc2UsIHNjb3BlLCAoYmFzZTIpID0+IGJhc2UyKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVBhcmVudE5vZGUoeyBuIH0sIHNjb3BlKSB7XG4gICR0cmFjZShcImhhbmRsZS5wYXJlbnQuY3VycmVudFNjb3BlICVkICVPXCIsIG4sIHNjb3BlKTtcbiAgbGV0IGN1cnJlbnQgPSBzY29wZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBmb3IgKDsgY3VycmVudD8uaXNIaWRkZW47IClcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICBjdXJyZW50ID0gY3VycmVudD8ucGFyZW50O1xuICB9XG4gIHJldHVybiAkdHJhY2UoXCJoYW5kbGUucGFyZW50Lm5ld1Njb3BlICVkICVPXCIsIG4sIGN1cnJlbnQpLCBjdXJyZW50ID8gY3VycmVudC52YWx1ZS5vZi5sZW5ndGggPT09IDAgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiBjdXJyZW50LnZhbHVlIDogeyB0eXBlOiBcIm51bGxcIiB9O1xufVxuZnVuY3Rpb24gaGFuZGxlTm90Tm9kZShub2RlLCBzY29wZSkge1xuICBjb25zdCBiYXNlID0gd2Fsayh7IG5vZGU6IG5vZGUuYmFzZSwgc2NvcGUgfSk7XG4gIHJldHVybiBtYXBOb2RlKGJhc2UsIHNjb3BlLCAoYmFzZTIpID0+IGJhc2UyLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJib29sZWFuXCIgfSkgOiBiYXNlMi50eXBlID09PSBcImJvb2xlYW5cIiA/IGJhc2UyLnZhbHVlICE9PSB2b2lkIDAgPyB7IHR5cGU6IFwiYm9vbGVhblwiLCB2YWx1ZTogYmFzZTIudmFsdWUgPT09ICExIH0gOiB7IHR5cGU6IFwiYm9vbGVhblwiIH0gOiB7IHR5cGU6IFwibnVsbFwiIH0pO1xufVxuZnVuY3Rpb24gaGFuZGxlTmVnTm9kZShub2RlLCBzY29wZSkge1xuICBjb25zdCBiYXNlID0gd2Fsayh7IG5vZGU6IG5vZGUuYmFzZSwgc2NvcGUgfSk7XG4gIHJldHVybiBtYXBOb2RlKGJhc2UsIHNjb3BlLCAoYmFzZTIpID0+IGJhc2UyLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IGJhc2UyLnR5cGUgIT09IFwibnVtYmVyXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiBiYXNlMi52YWx1ZSAhPT0gdm9pZCAwID8geyB0eXBlOiBcIm51bWJlclwiLCB2YWx1ZTogLWJhc2UyLnZhbHVlIH0gOiBiYXNlMik7XG59XG5mdW5jdGlvbiBoYW5kbGVQb3NOb2RlKG5vZGUsIHNjb3BlKSB7XG4gIGNvbnN0IGJhc2UgPSB3YWxrKHsgbm9kZTogbm9kZS5iYXNlLCBzY29wZSB9KTtcbiAgcmV0dXJuIG1hcE5vZGUoYmFzZSwgc2NvcGUsIChiYXNlMikgPT4gYmFzZTIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcIm51bWJlclwiIH0pIDogYmFzZTIudHlwZSAhPT0gXCJudW1iZXJcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IGJhc2UyKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUV2ZXJ5dGhpbmdOb2RlKF8sIHNjb3BlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIG9mOiB7XG4gICAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgICBvZjogc2NvcGUuY29udGV4dC5zY2hlbWEuZmlsdGVyKChvYmopID0+IG9iai50eXBlID09PSBcImRvY3VtZW50XCIpLm1hcCgoZG9jKSA9PiAoe1xuICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICBhdHRyaWJ1dGVzOiBkb2MuYXR0cmlidXRlc1xuICAgICAgfSkpXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaGFuZGxlQW5kTm9kZShub2RlLCBzY29wZSkge1xuICBjb25zdCBsZWZ0ID0gd2Fsayh7IG5vZGU6IG5vZGUubGVmdCwgc2NvcGUgfSksIHJpZ2h0ID0gd2Fsayh7IG5vZGU6IG5vZGUucmlnaHQsIHNjb3BlIH0pO1xuICByZXR1cm4gbWFwTm9kZShcbiAgICBsZWZ0LFxuICAgIHNjb3BlLFxuICAgIChsaHMpID0+IG1hcE5vZGUocmlnaHQsIHNjb3BlLCAocmhzKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGJvb2xlYW5BbmQoYm9vbGVhblZhbHVlKGxocywgc2NvcGUpLCBib29sZWFuVmFsdWUocmhzLCBzY29wZSkpO1xuICAgICAgcmV0dXJuIGJvb2xlYW5JbnRlcnByZXRhdGlvblRvVHlwZU5vZGUodmFsdWUpO1xuICAgIH0pXG4gICk7XG59XG5mdW5jdGlvbiBoYW5kbGVPck5vZGUobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgbGVmdCA9IHdhbGsoeyBub2RlOiBub2RlLmxlZnQsIHNjb3BlIH0pLCByaWdodCA9IHdhbGsoeyBub2RlOiBub2RlLnJpZ2h0LCBzY29wZSB9KTtcbiAgcmV0dXJuIG1hcE5vZGUoXG4gICAgbGVmdCxcbiAgICBzY29wZSxcbiAgICAobGhzKSA9PiBtYXBOb2RlKHJpZ2h0LCBzY29wZSwgKHJocykgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBib29sZWFuT3IoYm9vbGVhblZhbHVlKGxocywgc2NvcGUpLCBib29sZWFuVmFsdWUocmhzLCBzY29wZSkpO1xuICAgICAgcmV0dXJuIGJvb2xlYW5JbnRlcnByZXRhdGlvblRvVHlwZU5vZGUodmFsdWUpO1xuICAgIH0pXG4gICk7XG59XG5jb25zdCBPVkVSUklERV9UWVBFX1NZTUJPTCA9IFN5bWJvbChcImdyb3EtanMudHlwZVwiKTtcbmZ1bmN0aW9uIHdhbGsoeyBub2RlLCBzY29wZSB9KSB7XG4gIGlmIChPVkVSUklERV9UWVBFX1NZTUJPTCBpbiBub2RlKVxuICAgIHJldHVybiBub2RlW09WRVJSSURFX1RZUEVfU1lNQk9MXTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAvLyBGaWx0ZXJpbmcsIHRyYXZlcnNhbCAmIHByb2plY3Rpb25zXG4gICAgY2FzZSBcIk1hcFwiOlxuICAgICAgcmV0dXJuIGhhbmRsZU1hcChub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIlByb2plY3Rpb25cIjpcbiAgICAgIHJldHVybiBoYW5kbGVQcm9qZWN0aW9uTm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIkZpbHRlclwiOlxuICAgICAgcmV0dXJuIGhhbmRsZUZpbHRlck5vZGUobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJBY2Nlc3NBdHRyaWJ1dGVcIjpcbiAgICAgIHJldHVybiBvcHRpbWl6ZVVuaW9ucyhoYW5kbGVBY2Nlc3NBdHRyaWJ1dGVOb2RlKG5vZGUsIHNjb3BlKSk7XG4gICAgY2FzZSBcIkFjY2Vzc0VsZW1lbnRcIjpcbiAgICAgIHJldHVybiBoYW5kbGVBY2Nlc3NFbGVtZW50Tm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIkFycmF5Q29lcmNlXCI6XG4gICAgICByZXR1cm4gaGFuZGxlQXJyYXlDb2VyY2VOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiRmxhdE1hcFwiOlxuICAgICAgcmV0dXJuIGhhbmRsZUZsYXRNYXAobm9kZSwgc2NvcGUpO1xuICAgIC8vIE9wZXJhdGlvbnNcbiAgICBjYXNlIFwiT3BDYWxsXCI6XG4gICAgICByZXR1cm4gaGFuZGxlT3BDYWxsTm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIkFuZFwiOlxuICAgICAgcmV0dXJuIGhhbmRsZUFuZE5vZGUobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJPclwiOlxuICAgICAgcmV0dXJuIGhhbmRsZU9yTm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIlNlbGVjdFwiOlxuICAgICAgcmV0dXJuIGhhbmRsZVNlbGVjdE5vZGUobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJQaXBlRnVuY0NhbGxcIjpcbiAgICAgIHJldHVybiB3YWxrKHsgbm9kZTogbm9kZS5iYXNlLCBzY29wZSB9KTtcbiAgICAvLyBWYWx1ZXNcbiAgICBjYXNlIFwiRGVyZWZcIjpcbiAgICAgIHJldHVybiBoYW5kbGVEZXJlZk5vZGUobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJPYmplY3RcIjpcbiAgICAgIHJldHVybiBoYW5kbGVPYmplY3ROb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiVmFsdWVcIjpcbiAgICAgIHJldHVybiBoYW5kbGVWYWx1ZU5vZGUobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJBcnJheVwiOlxuICAgICAgcmV0dXJuIGhhbmRsZUFycmF5Tm9kZShub2RlLCBzY29wZSk7XG4gICAgLy8gU3BlY2lhbCBjYXNlc1xuICAgIGNhc2UgXCJFdmVyeXRoaW5nXCI6XG4gICAgICByZXR1cm4gaGFuZGxlRXZlcnl0aGluZ05vZGUobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJUaGlzXCI6XG4gICAgICByZXR1cm4gJHRyYWNlKFwidGhpcyAlT1wiLCBzY29wZS52YWx1ZSksIHNjb3BlLnZhbHVlO1xuICAgIGNhc2UgXCJQYXJlbnRcIjpcbiAgICAgIHJldHVybiBoYW5kbGVQYXJlbnROb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiRnVuY0NhbGxcIjpcbiAgICAgIHJldHVybiBoYW5kbGVGdW5jQ2FsbE5vZGUobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJHcm91cFwiOlxuICAgICAgcmV0dXJuIHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICAgIGNhc2UgXCJOb3RcIjpcbiAgICAgIHJldHVybiBoYW5kbGVOb3ROb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiUGFyYW1ldGVyXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInVua25vd25cIlxuICAgICAgfTtcbiAgICBjYXNlIFwiU2xpY2VcIjpcbiAgICAgIHJldHVybiBoYW5kbGVTbGljZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIk5lZ1wiOlxuICAgICAgcmV0dXJuIGhhbmRsZU5lZ05vZGUobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJQb3NcIjpcbiAgICAgIHJldHVybiBoYW5kbGVQb3NOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICAvLyBldmVyeXRoaW5nIGVsc2VcbiAgICBjYXNlIFwiQXNjXCI6XG4gICAgY2FzZSBcIkRlc2NcIjpcbiAgICBjYXNlIFwiQ29udGV4dFwiOlxuICAgIGNhc2UgXCJUdXBsZVwiOlxuICAgIGNhc2UgXCJTZWxlY3RvckZ1bmNDYWxsXCI6XG4gICAgY2FzZSBcIlNlbGVjdG9yTmVzdGVkXCI6XG4gICAgY2FzZSBcIkluUmFuZ2VcIjpcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidW5rbm93blwiIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBub2RlIHR5cGUgJHtub2RlLnR5cGV9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlVHlwZU5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZS50eXBlID09PSBcInN0cmluZ1wiIHx8IG5vZGUudHlwZSA9PT0gXCJudW1iZXJcIiB8fCBub2RlLnR5cGUgPT09IFwiYm9vbGVhblwiO1xufVxuZnVuY3Rpb24gZXZhbHVhdGVDb21wYXJpc29uKG9wY2FsbCwgbGVmdCwgcmlnaHQpIHtcbiAgaWYgKCEobGVmdC52YWx1ZSA9PT0gdm9pZCAwIHx8IHJpZ2h0LnZhbHVlID09PSB2b2lkIDApKVxuICAgIHN3aXRjaCAob3BjYWxsKSB7XG4gICAgICBjYXNlIFwiPT1cIjpcbiAgICAgICAgcmV0dXJuIGxlZnQudmFsdWUgPT09IHJpZ2h0LnZhbHVlO1xuICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgcmV0dXJuIGxlZnQudmFsdWUgPCByaWdodC52YWx1ZTtcbiAgICAgIGNhc2UgXCI8PVwiOlxuICAgICAgICByZXR1cm4gbGVmdC52YWx1ZSA8PSByaWdodC52YWx1ZTtcbiAgICAgIGNhc2UgXCI+XCI6XG4gICAgICAgIHJldHVybiBsZWZ0LnZhbHVlID4gcmlnaHQudmFsdWU7XG4gICAgICBjYXNlIFwiPj1cIjpcbiAgICAgICAgcmV0dXJuIGxlZnQudmFsdWUgPj0gcmlnaHQudmFsdWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gY29tcGFyaXNvbiBvcGVyYXRvciAke29wY2FsbH1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyKGV4cHIsIHNjb3BlKSB7XG4gICR0cmFjZShcInJlc29sdmVGaWx0ZXIuZXhwciAlT1wiLCBleHByKTtcbiAgY29uc3QgZmlsdGVyZWQgPSBzY29wZS52YWx1ZS5vZi5maWx0ZXIoKG5vZGUpID0+IHtcbiAgICBjb25zdCBzdWJTY29wZSA9IHNjb3BlLmNyZWF0ZUhpZGRlbihbbm9kZV0pLCBjb25kID0gd2Fsayh7IG5vZGU6IGV4cHIsIHNjb3BlOiBzdWJTY29wZSB9KTtcbiAgICByZXR1cm4gYm9vbGVhblZhbHVlKGNvbmQsIHN1YlNjb3BlKS5jYW5CZVRydWU7XG4gIH0pO1xuICByZXR1cm4gJHRyYWNlKFxuICAgIGByZXNvbHZlRmlsdGVyICR7ZXhwci50eXBlID09PSBcIk9wQ2FsbFwiID8gYCR7ZXhwci50eXBlfS8ke2V4cHIub3B9YCA6IGV4cHIudHlwZX0gJU9gLFxuICAgIGZpbHRlcmVkXG4gICksIHsgdHlwZTogXCJ1bmlvblwiLCBvZjogZmlsdGVyZWQgfTtcbn1cbmZ1bmN0aW9uIG1hcEFycmF5KG5vZGUsIHNjb3BlLCBtYXBwZXIpIHtcbiAgcmV0dXJuIG1hcE5vZGUobm9kZSwgc2NvcGUsIChiYXNlKSA9PiBiYXNlLnR5cGUgPT09IFwidW5rbm93blwiID8gYmFzZSA6IGJhc2UudHlwZSA9PT0gXCJhcnJheVwiID8gbWFwcGVyKGJhc2UpIDogeyB0eXBlOiBcIm51bGxcIiB9KTtcbn1cbmZ1bmN0aW9uIG1hcE9iamVjdChub2RlLCBzY29wZSwgbWFwcGVyKSB7XG4gIHJldHVybiBtYXBOb2RlKG5vZGUsIHNjb3BlLCAoYmFzZSkgPT4gYmFzZS50eXBlID09PSBcInVua25vd25cIiA/IGJhc2UgOiBiYXNlLnR5cGUgPT09IFwib2JqZWN0XCIgPyBtYXBwZXIoYmFzZSkgOiB7IHR5cGU6IFwibnVsbFwiIH0pO1xufVxuZXhwb3J0IHtcbiAgRGF0ZVRpbWUsXG4gIFBhdGgsXG4gIGNyZWF0ZVJlZmVyZW5jZVR5cGVOb2RlLFxuICBldmFsdWF0ZVF1ZXJ5IGFzIGV2YWx1YXRlLFxuICBldmFsdWF0ZVF1ZXJ5U3luYyBhcyBldmFsdWF0ZVN5bmMsXG4gIGlzU2VsZWN0b3JOZXN0ZWQsXG4gIGlzU2VsZWN0b3JOb2RlLFxuICBwYXJzZSxcbiAgdG9KUyxcbiAgdHlwZUV2YWx1YXRlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9MS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/groq-js/dist/1.mjs\n");

/***/ })

};
;